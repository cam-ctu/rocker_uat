
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "zip"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('zip')

Attaching package: ‘zip’

The following objects are masked from ‘package:utils’:

    unzip, zip

> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("deflate")
> ### * deflate
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: deflate
> ### Title: Compress a raw GZIP stream
> ### Aliases: deflate
> 
> ### ** Examples
> 
> data_gz <- deflate(charToRaw("Hello world!"))
> inflate(data_gz$output)
$output
 [1] 48 65 6c 6c 6f 20 77 6f 72 6c 64 21

$bytes_read
[1] 24

$bytes_written
[1] 12

> 
> 
> 
> cleanEx()
> nameEx("inflate")
> ### * inflate
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: inflate
> ### Title: Uncompress a raw GZIP stream
> ### Aliases: inflate
> 
> ### ** Examples
> 
> data_gz <- deflate(charToRaw("Hello world!"))
> inflate(data_gz$output)
$output
 [1] 48 65 6c 6c 6f 20 77 6f 72 6c 64 21

$bytes_read
[1] 24

$bytes_written
[1] 12

> 
> 
> 
> cleanEx()
> nameEx("unzip")
> ### * unzip
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: unzip
> ### Title: Uncompress 'zip' Archives
> ### Aliases: unzip
> 
> ### ** Examples
> 
> ## temporary directory, to avoid messing up the user's workspace.
> dir.create(tmp <- tempfile())
> dir.create(file.path(tmp, "mydir"))
> cat("first file", file = file.path(tmp, "mydir", "file1"))
> cat("second file", file = file.path(tmp, "mydir", "file2"))
> 
> zipfile <- tempfile(fileext = ".zip")
> zip::zip(zipfile, "mydir", root = tmp)
> 
> ## List contents
> zip_list(zipfile)
     filename compressed_size uncompressed_size           timestamp permissions
1      mydir/               0                 0 2025-01-06 17:13:14         755
2 mydir/file1              15                10 2025-01-06 17:13:14         644
3 mydir/file2              16                11 2025-01-06 17:13:14         644
     crc32 offset
1 00000000      0
2 00effe3a     36
3 735af9a0    108
> 
> ## Extract
> tmp2 <- tempfile()
> unzip(zipfile, exdir = tmp2)
> dir(tmp2, recursive = TRUE)
[1] "mydir/file1" "mydir/file2"
> 
> 
> 
> cleanEx()
> nameEx("unzip_process")
> ### * unzip_process
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: unzip_process
> ### Title: Class for an external unzip process
> ### Aliases: unzip_process
> 
> ### ** Examples
> 
> ex <- system.file("example.zip", package = "zip")
> tmp <- tempfile()
> up <- unzip_process()$new(ex, exdir = tmp)
> up$wait()
> up$get_exit_status()
[1] 0
> dir(tmp)
[1] "example"
> 
> 
> 
> cleanEx()
> nameEx("zip")
> ### * zip
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: zip
> ### Title: Compress Files into 'zip' Archives
> ### Aliases: zip zipr zip_append zipr_append
> 
> ### ** Examples
> 
> ## Some files to zip up. We will run all this in the R session's
> ## temporary directory, to avoid messing up the user's workspace.
> dir.create(tmp <- tempfile())
> dir.create(file.path(tmp, "mydir"))
> cat("first file", file = file.path(tmp, "mydir", "file1"))
> cat("second file", file = file.path(tmp, "mydir", "file2"))
> 
> zipfile <- tempfile(fileext = ".zip")
> zip::zip(zipfile, "mydir", root = tmp)
> 
> ## List contents
> zip_list(zipfile)
     filename compressed_size uncompressed_size           timestamp permissions
1      mydir/               0                 0 2025-01-06 17:13:14         755
2 mydir/file1              15                10 2025-01-06 17:13:14         644
3 mydir/file2              16                11 2025-01-06 17:13:14         644
     crc32 offset
1 00000000      0
2 00effe3a     36
3 735af9a0    108
> 
> ## Add another file
> cat("third file", file = file.path(tmp, "mydir", "file3"))
> zip_append(zipfile, file.path("mydir", "file3"), root = tmp)
> zip_list(zipfile)
     filename compressed_size uncompressed_size           timestamp permissions
1      mydir/               0                 0 2025-01-06 17:13:14         644
2 mydir/file1              15                10 2025-01-06 17:13:14         644
3 mydir/file2              16                11 2025-01-06 17:13:14         644
4 mydir/file3              15                10 2025-01-06 17:13:14         600
     crc32 offset
1 00000000      0
2 00effe3a     36
3 735af9a0    108
4 b0bf9ffe    181
> 
> 
> 
> cleanEx()
> nameEx("zip_process")
> ### * zip_process
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: zip_process
> ### Title: Class for an external zip process
> ### Aliases: zip_process
> 
> ### ** Examples
> 
> dir.create(tmp <- tempfile())
> write.table(iris, file = file.path(tmp, "iris.ssv"))
> zipfile <- tempfile(fileext = ".zip")
> zp <- zip_process()$new(zipfile, tmp)
> zp$wait()
> zp$get_exit_status()
[1] 0
> zip_list(zipfile)
                    filename compressed_size uncompressed_size
1         file25d731568b6dd/               0                 0
2 file25d731568b6dd/iris.ssv            1126              4818
            timestamp permissions    crc32 offset
1 2025-01-06 17:13:14         755 00000000      0
2 2025-01-06 17:13:14         644 474bc924     48
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.114 0.021 0.139 0 0.005 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
