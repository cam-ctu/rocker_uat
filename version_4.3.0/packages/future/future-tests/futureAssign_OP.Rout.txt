
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[13:20:15.078] plan(): Setting new future strategy stack:
[13:20:15.079] List of future strategies:
[13:20:15.079] 1. sequential:
[13:20:15.079]    - args: function (..., envir = parent.frame())
[13:20:15.079]    - tweaked: FALSE
[13:20:15.079]    - call: future::plan("sequential")
[13:20:15.092] plan(): nbrOfWorkers() = 1
> 
> message("*** %<-% ...")
*** %<-% ...
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("*** %%<-%% with %s futures ...", sQuote(strategy)))
+     plan(strategy)
+ 
+     rm(list = intersect(c("x", "y"), ls()))
+ 
+     message("** Future evaluation without globals")
+     v1 %<-% { x <- 1 }
+     stopifnot(!exists("x", inherits = FALSE), identical(v1, 1))
+ 
+     message("** Future evaluation with globals")
+     a <- 2
+     v2 %<-% { x <- a }
+     stopifnot(!exists("x", inherits = FALSE), identical(v2, a))
+ 
+     message("** Future evaluation with errors")
+     v3 %<-% {
+       x <- 3
+       stop("Woops!")
+       x
+     }
+     stopifnot(!exists("x", inherits = FALSE))
+     res <- tryCatch(identical(v3, 3), error = identity)
+     stopifnot(inherits(res, "error"))
+ 
+ 
+     y <- listenv::listenv()
+     for (ii in 1:3) {
+       y[[ii]] %<-% {
+         if (ii %% 2 == 0) stop("Woops!")
+         ii
+       }
+     }
+     res <- tryCatch(as.list(y), error = identity)
+     stopifnot(inherits(res, "error"))
+     z <- y[c(1, 3)]
+     z <- unlist(z)
+     stopifnot(all(z == c(1, 3)))
+     res <- tryCatch(y[[2]], error = identity)
+     stopifnot(inherits(res, "error"))
+     res <- tryCatch(y[1:2], error = identity)
+     stopifnot(inherits(res, "error"))
+ 
+ 
+     message("** Future evaluation with a poor-man's \"progress bar\"")
+     v4 %<-% {
+       cat("Processing: ")
+       for (ii in 1:10) { cat(".") }
+       cat(" [100%]\n")
+       4
+     }
+ 
+ 
+     message("** Collecting results")
+     printf("v1 = %s\n", v1)
+     stopifnot(v1 == 1)
+ 
+     printf("v2 = %s\n", v2)
+     stopifnot(v2 == a)
+ 
+     stopifnot(tryCatch({
+       printf("v3 = %s\n", v3)
+     }, error = function(ex) {
+       printf("v3: <%s> (as expect)\n", class(ex)[1])
+       TRUE
+     }))
+ 
+     printf("v4 = %s\n", v4)
+     #stopifnot(v4 == 4)
+ 
+ 
+     message("** Left-to-right and right-to-left future assignments")
+     c %<-% 1
+     printf("c = %s\n", c)
+     1 %->% d
+     printf("d = %s\n", d)
+     stopifnot(d == c)
+ 
+ 
+ 
+     message("** Nested future assignments")
+     a %<-% {
+       b <- 1
+       c %<-% 2
+       3 -> d
+       4 %->% e
+       b + c + d + e
+     }
+     printf("a = %s\n", a)
+     stopifnot(a == 10)
+ 
+     { a + 1 } %->% b
+     printf("b = %s\n", b)
+     stopifnot(b == a + 1)
+ 
+     message(sprintf("*** %%<-%% with %s futures ... DONE", sQuote(strategy)))
+   } # for (strategy in ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
*** %<-% with ‘sequential’ futures ...
[13:20:15.150] plan(): Setting new future strategy stack:
[13:20:15.150] List of future strategies:
[13:20:15.150] 1. sequential:
[13:20:15.150]    - args: function (..., envir = parent.frame())
[13:20:15.150]    - tweaked: FALSE
[13:20:15.150]    - call: plan(strategy)
[13:20:15.161] plan(): nbrOfWorkers() = 1
** Future evaluation without globals
[13:20:15.163] getGlobalsAndPackages() ...
[13:20:15.163] Searching for globals...
[13:20:15.168] - globals found: [2] ‘{’, ‘<-’
[13:20:15.168] Searching for globals ... DONE
[13:20:15.168] Resolving globals: FALSE
[13:20:15.169] 
[13:20:15.169] 
[13:20:15.169] getGlobalsAndPackages() ... DONE
[13:20:15.170] run() for ‘Future’ ...
[13:20:15.170] - state: ‘created’
[13:20:15.170] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:15.171] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:15.171] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:15.171]   - Field: ‘label’
[13:20:15.171]   - Field: ‘local’
[13:20:15.171]   - Field: ‘owner’
[13:20:15.171]   - Field: ‘envir’
[13:20:15.171]   - Field: ‘packages’
[13:20:15.171]   - Field: ‘gc’
[13:20:15.171]   - Field: ‘conditions’
[13:20:15.172]   - Field: ‘expr’
[13:20:15.172]   - Field: ‘uuid’
[13:20:15.172]   - Field: ‘seed’
[13:20:15.172]   - Field: ‘version’
[13:20:15.172]   - Field: ‘result’
[13:20:15.172]   - Field: ‘asynchronous’
[13:20:15.172]   - Field: ‘calls’
[13:20:15.172]   - Field: ‘globals’
[13:20:15.172]   - Field: ‘stdout’
[13:20:15.172]   - Field: ‘earlySignal’
[13:20:15.172]   - Field: ‘lazy’
[13:20:15.173]   - Field: ‘state’
[13:20:15.173] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:15.173] - Launch lazy future ...
[13:20:15.174] Packages needed by the future expression (n = 0): <none>
[13:20:15.174] Packages needed by future strategies (n = 0): <none>
[13:20:15.175] {
[13:20:15.175]     {
[13:20:15.175]         {
[13:20:15.175]             ...future.startTime <- base::Sys.time()
[13:20:15.175]             {
[13:20:15.175]                 {
[13:20:15.175]                   {
[13:20:15.175]                     base::local({
[13:20:15.175]                       has_future <- base::requireNamespace("future", 
[13:20:15.175]                         quietly = TRUE)
[13:20:15.175]                       if (has_future) {
[13:20:15.175]                         ns <- base::getNamespace("future")
[13:20:15.175]                         version <- ns[[".package"]][["version"]]
[13:20:15.175]                         if (is.null(version)) 
[13:20:15.175]                           version <- utils::packageVersion("future")
[13:20:15.175]                       }
[13:20:15.175]                       else {
[13:20:15.175]                         version <- NULL
[13:20:15.175]                       }
[13:20:15.175]                       if (!has_future || version < "1.8.0") {
[13:20:15.175]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:15.175]                           "", base::R.version$version.string), 
[13:20:15.175]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:15.175]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:15.175]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:15.175]                             "release", "version")], collapse = " "), 
[13:20:15.175]                           hostname = base::Sys.info()[["nodename"]])
[13:20:15.175]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:15.175]                           info)
[13:20:15.175]                         info <- base::paste(info, collapse = "; ")
[13:20:15.175]                         if (!has_future) {
[13:20:15.175]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:15.175]                             info)
[13:20:15.175]                         }
[13:20:15.175]                         else {
[13:20:15.175]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:15.175]                             info, version)
[13:20:15.175]                         }
[13:20:15.175]                         base::stop(msg)
[13:20:15.175]                       }
[13:20:15.175]                     })
[13:20:15.175]                   }
[13:20:15.175]                   options(future.plan = NULL)
[13:20:15.175]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.175]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:15.175]                 }
[13:20:15.175]                 ...future.workdir <- getwd()
[13:20:15.175]             }
[13:20:15.175]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:15.175]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:15.175]         }
[13:20:15.175]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:15.175]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:15.175]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:15.175]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:15.175]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:15.175]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:15.175]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:15.175]             base::names(...future.oldOptions))
[13:20:15.175]     }
[13:20:15.175]     if (FALSE) {
[13:20:15.175]     }
[13:20:15.175]     else {
[13:20:15.175]         if (TRUE) {
[13:20:15.175]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:15.175]                 open = "w")
[13:20:15.175]         }
[13:20:15.175]         else {
[13:20:15.175]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:15.175]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:15.175]         }
[13:20:15.175]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:15.175]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:15.175]             base::sink(type = "output", split = FALSE)
[13:20:15.175]             base::close(...future.stdout)
[13:20:15.175]         }, add = TRUE)
[13:20:15.175]     }
[13:20:15.175]     ...future.frame <- base::sys.nframe()
[13:20:15.175]     ...future.conditions <- base::list()
[13:20:15.175]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:15.175]     if (FALSE) {
[13:20:15.175]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:15.175]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:15.175]     }
[13:20:15.175]     ...future.result <- base::tryCatch({
[13:20:15.175]         base::withCallingHandlers({
[13:20:15.175]             ...future.value <- base::withVisible(base::local({
[13:20:15.175]                 x <- 1
[13:20:15.175]             }))
[13:20:15.175]             future::FutureResult(value = ...future.value$value, 
[13:20:15.175]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.175]                   ...future.rng), globalenv = if (FALSE) 
[13:20:15.175]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:15.175]                     ...future.globalenv.names))
[13:20:15.175]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:15.175]         }, condition = base::local({
[13:20:15.175]             c <- base::c
[13:20:15.175]             inherits <- base::inherits
[13:20:15.175]             invokeRestart <- base::invokeRestart
[13:20:15.175]             length <- base::length
[13:20:15.175]             list <- base::list
[13:20:15.175]             seq.int <- base::seq.int
[13:20:15.175]             signalCondition <- base::signalCondition
[13:20:15.175]             sys.calls <- base::sys.calls
[13:20:15.175]             `[[` <- base::`[[`
[13:20:15.175]             `+` <- base::`+`
[13:20:15.175]             `<<-` <- base::`<<-`
[13:20:15.175]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:15.175]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:15.175]                   3L)]
[13:20:15.175]             }
[13:20:15.175]             function(cond) {
[13:20:15.175]                 is_error <- inherits(cond, "error")
[13:20:15.175]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:15.175]                   NULL)
[13:20:15.175]                 if (is_error) {
[13:20:15.175]                   sessionInformation <- function() {
[13:20:15.175]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:15.175]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:15.175]                       search = base::search(), system = base::Sys.info())
[13:20:15.175]                   }
[13:20:15.175]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.175]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:15.175]                     cond$call), session = sessionInformation(), 
[13:20:15.175]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:15.175]                   signalCondition(cond)
[13:20:15.175]                 }
[13:20:15.175]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:15.175]                 "immediateCondition"))) {
[13:20:15.175]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:15.175]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.175]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:15.175]                   if (TRUE && !signal) {
[13:20:15.175]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.175]                     {
[13:20:15.175]                       inherits <- base::inherits
[13:20:15.175]                       invokeRestart <- base::invokeRestart
[13:20:15.175]                       is.null <- base::is.null
[13:20:15.175]                       muffled <- FALSE
[13:20:15.175]                       if (inherits(cond, "message")) {
[13:20:15.175]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.175]                         if (muffled) 
[13:20:15.175]                           invokeRestart("muffleMessage")
[13:20:15.175]                       }
[13:20:15.175]                       else if (inherits(cond, "warning")) {
[13:20:15.175]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.175]                         if (muffled) 
[13:20:15.175]                           invokeRestart("muffleWarning")
[13:20:15.175]                       }
[13:20:15.175]                       else if (inherits(cond, "condition")) {
[13:20:15.175]                         if (!is.null(pattern)) {
[13:20:15.175]                           computeRestarts <- base::computeRestarts
[13:20:15.175]                           grepl <- base::grepl
[13:20:15.175]                           restarts <- computeRestarts(cond)
[13:20:15.175]                           for (restart in restarts) {
[13:20:15.175]                             name <- restart$name
[13:20:15.175]                             if (is.null(name)) 
[13:20:15.175]                               next
[13:20:15.175]                             if (!grepl(pattern, name)) 
[13:20:15.175]                               next
[13:20:15.175]                             invokeRestart(restart)
[13:20:15.175]                             muffled <- TRUE
[13:20:15.175]                             break
[13:20:15.175]                           }
[13:20:15.175]                         }
[13:20:15.175]                       }
[13:20:15.175]                       invisible(muffled)
[13:20:15.175]                     }
[13:20:15.175]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.175]                   }
[13:20:15.175]                 }
[13:20:15.175]                 else {
[13:20:15.175]                   if (TRUE) {
[13:20:15.175]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.175]                     {
[13:20:15.175]                       inherits <- base::inherits
[13:20:15.175]                       invokeRestart <- base::invokeRestart
[13:20:15.175]                       is.null <- base::is.null
[13:20:15.175]                       muffled <- FALSE
[13:20:15.175]                       if (inherits(cond, "message")) {
[13:20:15.175]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.175]                         if (muffled) 
[13:20:15.175]                           invokeRestart("muffleMessage")
[13:20:15.175]                       }
[13:20:15.175]                       else if (inherits(cond, "warning")) {
[13:20:15.175]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.175]                         if (muffled) 
[13:20:15.175]                           invokeRestart("muffleWarning")
[13:20:15.175]                       }
[13:20:15.175]                       else if (inherits(cond, "condition")) {
[13:20:15.175]                         if (!is.null(pattern)) {
[13:20:15.175]                           computeRestarts <- base::computeRestarts
[13:20:15.175]                           grepl <- base::grepl
[13:20:15.175]                           restarts <- computeRestarts(cond)
[13:20:15.175]                           for (restart in restarts) {
[13:20:15.175]                             name <- restart$name
[13:20:15.175]                             if (is.null(name)) 
[13:20:15.175]                               next
[13:20:15.175]                             if (!grepl(pattern, name)) 
[13:20:15.175]                               next
[13:20:15.175]                             invokeRestart(restart)
[13:20:15.175]                             muffled <- TRUE
[13:20:15.175]                             break
[13:20:15.175]                           }
[13:20:15.175]                         }
[13:20:15.175]                       }
[13:20:15.175]                       invisible(muffled)
[13:20:15.175]                     }
[13:20:15.175]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.175]                   }
[13:20:15.175]                 }
[13:20:15.175]             }
[13:20:15.175]         }))
[13:20:15.175]     }, error = function(ex) {
[13:20:15.175]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:15.175]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.175]                 ...future.rng), started = ...future.startTime, 
[13:20:15.175]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:15.175]             version = "1.8"), class = "FutureResult")
[13:20:15.175]     }, finally = {
[13:20:15.175]         if (!identical(...future.workdir, getwd())) 
[13:20:15.175]             setwd(...future.workdir)
[13:20:15.175]         {
[13:20:15.175]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:15.175]                 ...future.oldOptions$nwarnings <- NULL
[13:20:15.175]             }
[13:20:15.175]             base::options(...future.oldOptions)
[13:20:15.175]             if (.Platform$OS.type == "windows") {
[13:20:15.175]                 old_names <- names(...future.oldEnvVars)
[13:20:15.175]                 envs <- base::Sys.getenv()
[13:20:15.175]                 names <- names(envs)
[13:20:15.175]                 common <- intersect(names, old_names)
[13:20:15.175]                 added <- setdiff(names, old_names)
[13:20:15.175]                 removed <- setdiff(old_names, names)
[13:20:15.175]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:15.175]                   envs[common]]
[13:20:15.175]                 NAMES <- toupper(changed)
[13:20:15.175]                 args <- list()
[13:20:15.175]                 for (kk in seq_along(NAMES)) {
[13:20:15.175]                   name <- changed[[kk]]
[13:20:15.175]                   NAME <- NAMES[[kk]]
[13:20:15.175]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.175]                     next
[13:20:15.175]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.175]                 }
[13:20:15.175]                 NAMES <- toupper(added)
[13:20:15.175]                 for (kk in seq_along(NAMES)) {
[13:20:15.175]                   name <- added[[kk]]
[13:20:15.175]                   NAME <- NAMES[[kk]]
[13:20:15.175]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.175]                     next
[13:20:15.175]                   args[[name]] <- ""
[13:20:15.175]                 }
[13:20:15.175]                 NAMES <- toupper(removed)
[13:20:15.175]                 for (kk in seq_along(NAMES)) {
[13:20:15.175]                   name <- removed[[kk]]
[13:20:15.175]                   NAME <- NAMES[[kk]]
[13:20:15.175]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.175]                     next
[13:20:15.175]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.175]                 }
[13:20:15.175]                 if (length(args) > 0) 
[13:20:15.175]                   base::do.call(base::Sys.setenv, args = args)
[13:20:15.175]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:15.175]             }
[13:20:15.175]             else {
[13:20:15.175]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:15.175]             }
[13:20:15.175]             {
[13:20:15.175]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:15.175]                   0L) {
[13:20:15.175]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:15.175]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:15.175]                   base::options(opts)
[13:20:15.175]                 }
[13:20:15.175]                 {
[13:20:15.175]                   {
[13:20:15.175]                     NULL
[13:20:15.175]                     RNGkind("Mersenne-Twister")
[13:20:15.175]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:15.175]                       inherits = FALSE)
[13:20:15.175]                   }
[13:20:15.175]                   options(future.plan = NULL)
[13:20:15.175]                   if (is.na(NA_character_)) 
[13:20:15.175]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.175]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:15.175]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:15.175]                   {
[13:20:15.175]                     future <- SequentialFuture(..., envir = envir)
[13:20:15.175]                     if (!future$lazy) 
[13:20:15.175]                       future <- run(future)
[13:20:15.175]                     invisible(future)
[13:20:15.175]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:15.175]                 }
[13:20:15.175]             }
[13:20:15.175]         }
[13:20:15.175]     })
[13:20:15.175]     if (TRUE) {
[13:20:15.175]         base::sink(type = "output", split = FALSE)
[13:20:15.175]         if (TRUE) {
[13:20:15.175]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:15.175]         }
[13:20:15.175]         else {
[13:20:15.175]             ...future.result["stdout"] <- base::list(NULL)
[13:20:15.175]         }
[13:20:15.175]         base::close(...future.stdout)
[13:20:15.175]         ...future.stdout <- NULL
[13:20:15.175]     }
[13:20:15.175]     ...future.result$conditions <- ...future.conditions
[13:20:15.175]     ...future.result$finished <- base::Sys.time()
[13:20:15.175]     ...future.result
[13:20:15.175] }
[13:20:15.177] plan(): Setting new future strategy stack:
[13:20:15.177] List of future strategies:
[13:20:15.177] 1. sequential:
[13:20:15.177]    - args: function (..., envir = parent.frame())
[13:20:15.177]    - tweaked: FALSE
[13:20:15.177]    - call: NULL
[13:20:15.177] plan(): nbrOfWorkers() = 1
[13:20:15.178] plan(): Setting new future strategy stack:
[13:20:15.178] List of future strategies:
[13:20:15.178] 1. sequential:
[13:20:15.178]    - args: function (..., envir = parent.frame())
[13:20:15.178]    - tweaked: FALSE
[13:20:15.178]    - call: plan(strategy)
[13:20:15.179] plan(): nbrOfWorkers() = 1
[13:20:15.179] SequentialFuture started (and completed)
[13:20:15.179] - Launch lazy future ... done
[13:20:15.180] run() for ‘SequentialFuture’ ... done
** Future evaluation with globals
[13:20:15.180] getGlobalsAndPackages() ...
[13:20:15.180] Searching for globals...
[13:20:15.181] - globals found: [3] ‘{’, ‘<-’, ‘a’
[13:20:15.181] Searching for globals ... DONE
[13:20:15.182] Resolving globals: FALSE
[13:20:15.185] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:15.185] The total size of the 1 globals exported for future expression (‘{; x <- a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:20:15.185] - globals: [1] ‘a’
[13:20:15.186] 
[13:20:15.186] getGlobalsAndPackages() ... DONE
[13:20:15.186] run() for ‘Future’ ...
[13:20:15.186] - state: ‘created’
[13:20:15.186] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:15.186] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:15.187] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:15.187]   - Field: ‘label’
[13:20:15.187]   - Field: ‘local’
[13:20:15.187]   - Field: ‘owner’
[13:20:15.187]   - Field: ‘envir’
[13:20:15.187]   - Field: ‘packages’
[13:20:15.187]   - Field: ‘gc’
[13:20:15.187]   - Field: ‘conditions’
[13:20:15.188]   - Field: ‘expr’
[13:20:15.188]   - Field: ‘uuid’
[13:20:15.188]   - Field: ‘seed’
[13:20:15.188]   - Field: ‘version’
[13:20:15.188]   - Field: ‘result’
[13:20:15.188]   - Field: ‘asynchronous’
[13:20:15.188]   - Field: ‘calls’
[13:20:15.188]   - Field: ‘globals’
[13:20:15.188]   - Field: ‘stdout’
[13:20:15.188]   - Field: ‘earlySignal’
[13:20:15.189]   - Field: ‘lazy’
[13:20:15.189]   - Field: ‘state’
[13:20:15.189] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:15.189] - Launch lazy future ...
[13:20:15.189] Packages needed by the future expression (n = 0): <none>
[13:20:15.189] Packages needed by future strategies (n = 0): <none>
[13:20:15.190] {
[13:20:15.190]     {
[13:20:15.190]         {
[13:20:15.190]             ...future.startTime <- base::Sys.time()
[13:20:15.190]             {
[13:20:15.190]                 {
[13:20:15.190]                   {
[13:20:15.190]                     base::local({
[13:20:15.190]                       has_future <- base::requireNamespace("future", 
[13:20:15.190]                         quietly = TRUE)
[13:20:15.190]                       if (has_future) {
[13:20:15.190]                         ns <- base::getNamespace("future")
[13:20:15.190]                         version <- ns[[".package"]][["version"]]
[13:20:15.190]                         if (is.null(version)) 
[13:20:15.190]                           version <- utils::packageVersion("future")
[13:20:15.190]                       }
[13:20:15.190]                       else {
[13:20:15.190]                         version <- NULL
[13:20:15.190]                       }
[13:20:15.190]                       if (!has_future || version < "1.8.0") {
[13:20:15.190]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:15.190]                           "", base::R.version$version.string), 
[13:20:15.190]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:15.190]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:15.190]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:15.190]                             "release", "version")], collapse = " "), 
[13:20:15.190]                           hostname = base::Sys.info()[["nodename"]])
[13:20:15.190]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:15.190]                           info)
[13:20:15.190]                         info <- base::paste(info, collapse = "; ")
[13:20:15.190]                         if (!has_future) {
[13:20:15.190]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:15.190]                             info)
[13:20:15.190]                         }
[13:20:15.190]                         else {
[13:20:15.190]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:15.190]                             info, version)
[13:20:15.190]                         }
[13:20:15.190]                         base::stop(msg)
[13:20:15.190]                       }
[13:20:15.190]                     })
[13:20:15.190]                   }
[13:20:15.190]                   options(future.plan = NULL)
[13:20:15.190]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.190]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:15.190]                 }
[13:20:15.190]                 ...future.workdir <- getwd()
[13:20:15.190]             }
[13:20:15.190]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:15.190]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:15.190]         }
[13:20:15.190]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:15.190]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:15.190]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:15.190]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:15.190]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:15.190]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:15.190]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:15.190]             base::names(...future.oldOptions))
[13:20:15.190]     }
[13:20:15.190]     if (FALSE) {
[13:20:15.190]     }
[13:20:15.190]     else {
[13:20:15.190]         if (TRUE) {
[13:20:15.190]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:15.190]                 open = "w")
[13:20:15.190]         }
[13:20:15.190]         else {
[13:20:15.190]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:15.190]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:15.190]         }
[13:20:15.190]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:15.190]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:15.190]             base::sink(type = "output", split = FALSE)
[13:20:15.190]             base::close(...future.stdout)
[13:20:15.190]         }, add = TRUE)
[13:20:15.190]     }
[13:20:15.190]     ...future.frame <- base::sys.nframe()
[13:20:15.190]     ...future.conditions <- base::list()
[13:20:15.190]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:15.190]     if (FALSE) {
[13:20:15.190]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:15.190]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:15.190]     }
[13:20:15.190]     ...future.result <- base::tryCatch({
[13:20:15.190]         base::withCallingHandlers({
[13:20:15.190]             ...future.value <- base::withVisible(base::local({
[13:20:15.190]                 x <- a
[13:20:15.190]             }))
[13:20:15.190]             future::FutureResult(value = ...future.value$value, 
[13:20:15.190]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.190]                   ...future.rng), globalenv = if (FALSE) 
[13:20:15.190]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:15.190]                     ...future.globalenv.names))
[13:20:15.190]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:15.190]         }, condition = base::local({
[13:20:15.190]             c <- base::c
[13:20:15.190]             inherits <- base::inherits
[13:20:15.190]             invokeRestart <- base::invokeRestart
[13:20:15.190]             length <- base::length
[13:20:15.190]             list <- base::list
[13:20:15.190]             seq.int <- base::seq.int
[13:20:15.190]             signalCondition <- base::signalCondition
[13:20:15.190]             sys.calls <- base::sys.calls
[13:20:15.190]             `[[` <- base::`[[`
[13:20:15.190]             `+` <- base::`+`
[13:20:15.190]             `<<-` <- base::`<<-`
[13:20:15.190]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:15.190]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:15.190]                   3L)]
[13:20:15.190]             }
[13:20:15.190]             function(cond) {
[13:20:15.190]                 is_error <- inherits(cond, "error")
[13:20:15.190]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:15.190]                   NULL)
[13:20:15.190]                 if (is_error) {
[13:20:15.190]                   sessionInformation <- function() {
[13:20:15.190]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:15.190]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:15.190]                       search = base::search(), system = base::Sys.info())
[13:20:15.190]                   }
[13:20:15.190]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.190]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:15.190]                     cond$call), session = sessionInformation(), 
[13:20:15.190]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:15.190]                   signalCondition(cond)
[13:20:15.190]                 }
[13:20:15.190]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:15.190]                 "immediateCondition"))) {
[13:20:15.190]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:15.190]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.190]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:15.190]                   if (TRUE && !signal) {
[13:20:15.190]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.190]                     {
[13:20:15.190]                       inherits <- base::inherits
[13:20:15.190]                       invokeRestart <- base::invokeRestart
[13:20:15.190]                       is.null <- base::is.null
[13:20:15.190]                       muffled <- FALSE
[13:20:15.190]                       if (inherits(cond, "message")) {
[13:20:15.190]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.190]                         if (muffled) 
[13:20:15.190]                           invokeRestart("muffleMessage")
[13:20:15.190]                       }
[13:20:15.190]                       else if (inherits(cond, "warning")) {
[13:20:15.190]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.190]                         if (muffled) 
[13:20:15.190]                           invokeRestart("muffleWarning")
[13:20:15.190]                       }
[13:20:15.190]                       else if (inherits(cond, "condition")) {
[13:20:15.190]                         if (!is.null(pattern)) {
[13:20:15.190]                           computeRestarts <- base::computeRestarts
[13:20:15.190]                           grepl <- base::grepl
[13:20:15.190]                           restarts <- computeRestarts(cond)
[13:20:15.190]                           for (restart in restarts) {
[13:20:15.190]                             name <- restart$name
[13:20:15.190]                             if (is.null(name)) 
[13:20:15.190]                               next
[13:20:15.190]                             if (!grepl(pattern, name)) 
[13:20:15.190]                               next
[13:20:15.190]                             invokeRestart(restart)
[13:20:15.190]                             muffled <- TRUE
[13:20:15.190]                             break
[13:20:15.190]                           }
[13:20:15.190]                         }
[13:20:15.190]                       }
[13:20:15.190]                       invisible(muffled)
[13:20:15.190]                     }
[13:20:15.190]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.190]                   }
[13:20:15.190]                 }
[13:20:15.190]                 else {
[13:20:15.190]                   if (TRUE) {
[13:20:15.190]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.190]                     {
[13:20:15.190]                       inherits <- base::inherits
[13:20:15.190]                       invokeRestart <- base::invokeRestart
[13:20:15.190]                       is.null <- base::is.null
[13:20:15.190]                       muffled <- FALSE
[13:20:15.190]                       if (inherits(cond, "message")) {
[13:20:15.190]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.190]                         if (muffled) 
[13:20:15.190]                           invokeRestart("muffleMessage")
[13:20:15.190]                       }
[13:20:15.190]                       else if (inherits(cond, "warning")) {
[13:20:15.190]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.190]                         if (muffled) 
[13:20:15.190]                           invokeRestart("muffleWarning")
[13:20:15.190]                       }
[13:20:15.190]                       else if (inherits(cond, "condition")) {
[13:20:15.190]                         if (!is.null(pattern)) {
[13:20:15.190]                           computeRestarts <- base::computeRestarts
[13:20:15.190]                           grepl <- base::grepl
[13:20:15.190]                           restarts <- computeRestarts(cond)
[13:20:15.190]                           for (restart in restarts) {
[13:20:15.190]                             name <- restart$name
[13:20:15.190]                             if (is.null(name)) 
[13:20:15.190]                               next
[13:20:15.190]                             if (!grepl(pattern, name)) 
[13:20:15.190]                               next
[13:20:15.190]                             invokeRestart(restart)
[13:20:15.190]                             muffled <- TRUE
[13:20:15.190]                             break
[13:20:15.190]                           }
[13:20:15.190]                         }
[13:20:15.190]                       }
[13:20:15.190]                       invisible(muffled)
[13:20:15.190]                     }
[13:20:15.190]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.190]                   }
[13:20:15.190]                 }
[13:20:15.190]             }
[13:20:15.190]         }))
[13:20:15.190]     }, error = function(ex) {
[13:20:15.190]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:15.190]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.190]                 ...future.rng), started = ...future.startTime, 
[13:20:15.190]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:15.190]             version = "1.8"), class = "FutureResult")
[13:20:15.190]     }, finally = {
[13:20:15.190]         if (!identical(...future.workdir, getwd())) 
[13:20:15.190]             setwd(...future.workdir)
[13:20:15.190]         {
[13:20:15.190]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:15.190]                 ...future.oldOptions$nwarnings <- NULL
[13:20:15.190]             }
[13:20:15.190]             base::options(...future.oldOptions)
[13:20:15.190]             if (.Platform$OS.type == "windows") {
[13:20:15.190]                 old_names <- names(...future.oldEnvVars)
[13:20:15.190]                 envs <- base::Sys.getenv()
[13:20:15.190]                 names <- names(envs)
[13:20:15.190]                 common <- intersect(names, old_names)
[13:20:15.190]                 added <- setdiff(names, old_names)
[13:20:15.190]                 removed <- setdiff(old_names, names)
[13:20:15.190]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:15.190]                   envs[common]]
[13:20:15.190]                 NAMES <- toupper(changed)
[13:20:15.190]                 args <- list()
[13:20:15.190]                 for (kk in seq_along(NAMES)) {
[13:20:15.190]                   name <- changed[[kk]]
[13:20:15.190]                   NAME <- NAMES[[kk]]
[13:20:15.190]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.190]                     next
[13:20:15.190]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.190]                 }
[13:20:15.190]                 NAMES <- toupper(added)
[13:20:15.190]                 for (kk in seq_along(NAMES)) {
[13:20:15.190]                   name <- added[[kk]]
[13:20:15.190]                   NAME <- NAMES[[kk]]
[13:20:15.190]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.190]                     next
[13:20:15.190]                   args[[name]] <- ""
[13:20:15.190]                 }
[13:20:15.190]                 NAMES <- toupper(removed)
[13:20:15.190]                 for (kk in seq_along(NAMES)) {
[13:20:15.190]                   name <- removed[[kk]]
[13:20:15.190]                   NAME <- NAMES[[kk]]
[13:20:15.190]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.190]                     next
[13:20:15.190]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.190]                 }
[13:20:15.190]                 if (length(args) > 0) 
[13:20:15.190]                   base::do.call(base::Sys.setenv, args = args)
[13:20:15.190]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:15.190]             }
[13:20:15.190]             else {
[13:20:15.190]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:15.190]             }
[13:20:15.190]             {
[13:20:15.190]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:15.190]                   0L) {
[13:20:15.190]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:15.190]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:15.190]                   base::options(opts)
[13:20:15.190]                 }
[13:20:15.190]                 {
[13:20:15.190]                   {
[13:20:15.190]                     NULL
[13:20:15.190]                     RNGkind("Mersenne-Twister")
[13:20:15.190]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:15.190]                       inherits = FALSE)
[13:20:15.190]                   }
[13:20:15.190]                   options(future.plan = NULL)
[13:20:15.190]                   if (is.na(NA_character_)) 
[13:20:15.190]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.190]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:15.190]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:15.190]                   {
[13:20:15.190]                     future <- SequentialFuture(..., envir = envir)
[13:20:15.190]                     if (!future$lazy) 
[13:20:15.190]                       future <- run(future)
[13:20:15.190]                     invisible(future)
[13:20:15.190]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:15.190]                 }
[13:20:15.190]             }
[13:20:15.190]         }
[13:20:15.190]     })
[13:20:15.190]     if (TRUE) {
[13:20:15.190]         base::sink(type = "output", split = FALSE)
[13:20:15.190]         if (TRUE) {
[13:20:15.190]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:15.190]         }
[13:20:15.190]         else {
[13:20:15.190]             ...future.result["stdout"] <- base::list(NULL)
[13:20:15.190]         }
[13:20:15.190]         base::close(...future.stdout)
[13:20:15.190]         ...future.stdout <- NULL
[13:20:15.190]     }
[13:20:15.190]     ...future.result$conditions <- ...future.conditions
[13:20:15.190]     ...future.result$finished <- base::Sys.time()
[13:20:15.190]     ...future.result
[13:20:15.190] }
[13:20:15.191] assign_globals() ...
[13:20:15.191] List of 1
[13:20:15.191]  $ a: num 2
[13:20:15.191]  - attr(*, "where")=List of 1
[13:20:15.191]   ..$ a:<environment: R_EmptyEnv> 
[13:20:15.191]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:15.191]  - attr(*, "resolved")= logi FALSE
[13:20:15.191]  - attr(*, "total_size")= num 56
[13:20:15.191]  - attr(*, "already-done")= logi TRUE
[13:20:15.196] - copied ‘a’ to environment
[13:20:15.197] assign_globals() ... done
[13:20:15.197] plan(): Setting new future strategy stack:
[13:20:15.197] List of future strategies:
[13:20:15.197] 1. sequential:
[13:20:15.197]    - args: function (..., envir = parent.frame())
[13:20:15.197]    - tweaked: FALSE
[13:20:15.197]    - call: NULL
[13:20:15.197] plan(): nbrOfWorkers() = 1
[13:20:15.198] plan(): Setting new future strategy stack:
[13:20:15.198] List of future strategies:
[13:20:15.198] 1. sequential:
[13:20:15.198]    - args: function (..., envir = parent.frame())
[13:20:15.198]    - tweaked: FALSE
[13:20:15.198]    - call: plan(strategy)
[13:20:15.198] plan(): nbrOfWorkers() = 1
[13:20:15.199] SequentialFuture started (and completed)
[13:20:15.199] - Launch lazy future ... done
[13:20:15.199] run() for ‘SequentialFuture’ ... done
** Future evaluation with errors
[13:20:15.199] getGlobalsAndPackages() ...
[13:20:15.199] Searching for globals...
[13:20:15.203] - globals found: [3] ‘{’, ‘<-’, ‘stop’
[13:20:15.203] Searching for globals ... DONE
[13:20:15.203] Resolving globals: FALSE
[13:20:15.203] 
[13:20:15.203] 
[13:20:15.203] getGlobalsAndPackages() ... DONE
[13:20:15.204] run() for ‘Future’ ...
[13:20:15.204] - state: ‘created’
[13:20:15.204] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:15.204] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:15.204] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:15.204]   - Field: ‘label’
[13:20:15.204]   - Field: ‘local’
[13:20:15.204]   - Field: ‘owner’
[13:20:15.205]   - Field: ‘envir’
[13:20:15.205]   - Field: ‘packages’
[13:20:15.205]   - Field: ‘gc’
[13:20:15.205]   - Field: ‘conditions’
[13:20:15.205]   - Field: ‘expr’
[13:20:15.205]   - Field: ‘uuid’
[13:20:15.205]   - Field: ‘seed’
[13:20:15.205]   - Field: ‘version’
[13:20:15.205]   - Field: ‘result’
[13:20:15.205]   - Field: ‘asynchronous’
[13:20:15.205]   - Field: ‘calls’
[13:20:15.206]   - Field: ‘globals’
[13:20:15.206]   - Field: ‘stdout’
[13:20:15.206]   - Field: ‘earlySignal’
[13:20:15.206]   - Field: ‘lazy’
[13:20:15.206]   - Field: ‘state’
[13:20:15.206] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:15.206] - Launch lazy future ...
[13:20:15.206] Packages needed by the future expression (n = 0): <none>
[13:20:15.206] Packages needed by future strategies (n = 0): <none>
[13:20:15.207] {
[13:20:15.207]     {
[13:20:15.207]         {
[13:20:15.207]             ...future.startTime <- base::Sys.time()
[13:20:15.207]             {
[13:20:15.207]                 {
[13:20:15.207]                   {
[13:20:15.207]                     base::local({
[13:20:15.207]                       has_future <- base::requireNamespace("future", 
[13:20:15.207]                         quietly = TRUE)
[13:20:15.207]                       if (has_future) {
[13:20:15.207]                         ns <- base::getNamespace("future")
[13:20:15.207]                         version <- ns[[".package"]][["version"]]
[13:20:15.207]                         if (is.null(version)) 
[13:20:15.207]                           version <- utils::packageVersion("future")
[13:20:15.207]                       }
[13:20:15.207]                       else {
[13:20:15.207]                         version <- NULL
[13:20:15.207]                       }
[13:20:15.207]                       if (!has_future || version < "1.8.0") {
[13:20:15.207]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:15.207]                           "", base::R.version$version.string), 
[13:20:15.207]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:15.207]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:15.207]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:15.207]                             "release", "version")], collapse = " "), 
[13:20:15.207]                           hostname = base::Sys.info()[["nodename"]])
[13:20:15.207]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:15.207]                           info)
[13:20:15.207]                         info <- base::paste(info, collapse = "; ")
[13:20:15.207]                         if (!has_future) {
[13:20:15.207]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:15.207]                             info)
[13:20:15.207]                         }
[13:20:15.207]                         else {
[13:20:15.207]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:15.207]                             info, version)
[13:20:15.207]                         }
[13:20:15.207]                         base::stop(msg)
[13:20:15.207]                       }
[13:20:15.207]                     })
[13:20:15.207]                   }
[13:20:15.207]                   options(future.plan = NULL)
[13:20:15.207]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.207]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:15.207]                 }
[13:20:15.207]                 ...future.workdir <- getwd()
[13:20:15.207]             }
[13:20:15.207]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:15.207]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:15.207]         }
[13:20:15.207]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:15.207]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:15.207]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:15.207]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:15.207]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:15.207]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:15.207]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:15.207]             base::names(...future.oldOptions))
[13:20:15.207]     }
[13:20:15.207]     if (FALSE) {
[13:20:15.207]     }
[13:20:15.207]     else {
[13:20:15.207]         if (TRUE) {
[13:20:15.207]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:15.207]                 open = "w")
[13:20:15.207]         }
[13:20:15.207]         else {
[13:20:15.207]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:15.207]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:15.207]         }
[13:20:15.207]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:15.207]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:15.207]             base::sink(type = "output", split = FALSE)
[13:20:15.207]             base::close(...future.stdout)
[13:20:15.207]         }, add = TRUE)
[13:20:15.207]     }
[13:20:15.207]     ...future.frame <- base::sys.nframe()
[13:20:15.207]     ...future.conditions <- base::list()
[13:20:15.207]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:15.207]     if (FALSE) {
[13:20:15.207]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:15.207]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:15.207]     }
[13:20:15.207]     ...future.result <- base::tryCatch({
[13:20:15.207]         base::withCallingHandlers({
[13:20:15.207]             ...future.value <- base::withVisible(base::local({
[13:20:15.207]                 x <- 3
[13:20:15.207]                 stop("Woops!")
[13:20:15.207]                 x
[13:20:15.207]             }))
[13:20:15.207]             future::FutureResult(value = ...future.value$value, 
[13:20:15.207]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.207]                   ...future.rng), globalenv = if (FALSE) 
[13:20:15.207]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:15.207]                     ...future.globalenv.names))
[13:20:15.207]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:15.207]         }, condition = base::local({
[13:20:15.207]             c <- base::c
[13:20:15.207]             inherits <- base::inherits
[13:20:15.207]             invokeRestart <- base::invokeRestart
[13:20:15.207]             length <- base::length
[13:20:15.207]             list <- base::list
[13:20:15.207]             seq.int <- base::seq.int
[13:20:15.207]             signalCondition <- base::signalCondition
[13:20:15.207]             sys.calls <- base::sys.calls
[13:20:15.207]             `[[` <- base::`[[`
[13:20:15.207]             `+` <- base::`+`
[13:20:15.207]             `<<-` <- base::`<<-`
[13:20:15.207]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:15.207]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:15.207]                   3L)]
[13:20:15.207]             }
[13:20:15.207]             function(cond) {
[13:20:15.207]                 is_error <- inherits(cond, "error")
[13:20:15.207]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:15.207]                   NULL)
[13:20:15.207]                 if (is_error) {
[13:20:15.207]                   sessionInformation <- function() {
[13:20:15.207]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:15.207]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:15.207]                       search = base::search(), system = base::Sys.info())
[13:20:15.207]                   }
[13:20:15.207]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.207]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:15.207]                     cond$call), session = sessionInformation(), 
[13:20:15.207]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:15.207]                   signalCondition(cond)
[13:20:15.207]                 }
[13:20:15.207]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:15.207]                 "immediateCondition"))) {
[13:20:15.207]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:15.207]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.207]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:15.207]                   if (TRUE && !signal) {
[13:20:15.207]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.207]                     {
[13:20:15.207]                       inherits <- base::inherits
[13:20:15.207]                       invokeRestart <- base::invokeRestart
[13:20:15.207]                       is.null <- base::is.null
[13:20:15.207]                       muffled <- FALSE
[13:20:15.207]                       if (inherits(cond, "message")) {
[13:20:15.207]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.207]                         if (muffled) 
[13:20:15.207]                           invokeRestart("muffleMessage")
[13:20:15.207]                       }
[13:20:15.207]                       else if (inherits(cond, "warning")) {
[13:20:15.207]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.207]                         if (muffled) 
[13:20:15.207]                           invokeRestart("muffleWarning")
[13:20:15.207]                       }
[13:20:15.207]                       else if (inherits(cond, "condition")) {
[13:20:15.207]                         if (!is.null(pattern)) {
[13:20:15.207]                           computeRestarts <- base::computeRestarts
[13:20:15.207]                           grepl <- base::grepl
[13:20:15.207]                           restarts <- computeRestarts(cond)
[13:20:15.207]                           for (restart in restarts) {
[13:20:15.207]                             name <- restart$name
[13:20:15.207]                             if (is.null(name)) 
[13:20:15.207]                               next
[13:20:15.207]                             if (!grepl(pattern, name)) 
[13:20:15.207]                               next
[13:20:15.207]                             invokeRestart(restart)
[13:20:15.207]                             muffled <- TRUE
[13:20:15.207]                             break
[13:20:15.207]                           }
[13:20:15.207]                         }
[13:20:15.207]                       }
[13:20:15.207]                       invisible(muffled)
[13:20:15.207]                     }
[13:20:15.207]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.207]                   }
[13:20:15.207]                 }
[13:20:15.207]                 else {
[13:20:15.207]                   if (TRUE) {
[13:20:15.207]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.207]                     {
[13:20:15.207]                       inherits <- base::inherits
[13:20:15.207]                       invokeRestart <- base::invokeRestart
[13:20:15.207]                       is.null <- base::is.null
[13:20:15.207]                       muffled <- FALSE
[13:20:15.207]                       if (inherits(cond, "message")) {
[13:20:15.207]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.207]                         if (muffled) 
[13:20:15.207]                           invokeRestart("muffleMessage")
[13:20:15.207]                       }
[13:20:15.207]                       else if (inherits(cond, "warning")) {
[13:20:15.207]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.207]                         if (muffled) 
[13:20:15.207]                           invokeRestart("muffleWarning")
[13:20:15.207]                       }
[13:20:15.207]                       else if (inherits(cond, "condition")) {
[13:20:15.207]                         if (!is.null(pattern)) {
[13:20:15.207]                           computeRestarts <- base::computeRestarts
[13:20:15.207]                           grepl <- base::grepl
[13:20:15.207]                           restarts <- computeRestarts(cond)
[13:20:15.207]                           for (restart in restarts) {
[13:20:15.207]                             name <- restart$name
[13:20:15.207]                             if (is.null(name)) 
[13:20:15.207]                               next
[13:20:15.207]                             if (!grepl(pattern, name)) 
[13:20:15.207]                               next
[13:20:15.207]                             invokeRestart(restart)
[13:20:15.207]                             muffled <- TRUE
[13:20:15.207]                             break
[13:20:15.207]                           }
[13:20:15.207]                         }
[13:20:15.207]                       }
[13:20:15.207]                       invisible(muffled)
[13:20:15.207]                     }
[13:20:15.207]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.207]                   }
[13:20:15.207]                 }
[13:20:15.207]             }
[13:20:15.207]         }))
[13:20:15.207]     }, error = function(ex) {
[13:20:15.207]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:15.207]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.207]                 ...future.rng), started = ...future.startTime, 
[13:20:15.207]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:15.207]             version = "1.8"), class = "FutureResult")
[13:20:15.207]     }, finally = {
[13:20:15.207]         if (!identical(...future.workdir, getwd())) 
[13:20:15.207]             setwd(...future.workdir)
[13:20:15.207]         {
[13:20:15.207]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:15.207]                 ...future.oldOptions$nwarnings <- NULL
[13:20:15.207]             }
[13:20:15.207]             base::options(...future.oldOptions)
[13:20:15.207]             if (.Platform$OS.type == "windows") {
[13:20:15.207]                 old_names <- names(...future.oldEnvVars)
[13:20:15.207]                 envs <- base::Sys.getenv()
[13:20:15.207]                 names <- names(envs)
[13:20:15.207]                 common <- intersect(names, old_names)
[13:20:15.207]                 added <- setdiff(names, old_names)
[13:20:15.207]                 removed <- setdiff(old_names, names)
[13:20:15.207]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:15.207]                   envs[common]]
[13:20:15.207]                 NAMES <- toupper(changed)
[13:20:15.207]                 args <- list()
[13:20:15.207]                 for (kk in seq_along(NAMES)) {
[13:20:15.207]                   name <- changed[[kk]]
[13:20:15.207]                   NAME <- NAMES[[kk]]
[13:20:15.207]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.207]                     next
[13:20:15.207]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.207]                 }
[13:20:15.207]                 NAMES <- toupper(added)
[13:20:15.207]                 for (kk in seq_along(NAMES)) {
[13:20:15.207]                   name <- added[[kk]]
[13:20:15.207]                   NAME <- NAMES[[kk]]
[13:20:15.207]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.207]                     next
[13:20:15.207]                   args[[name]] <- ""
[13:20:15.207]                 }
[13:20:15.207]                 NAMES <- toupper(removed)
[13:20:15.207]                 for (kk in seq_along(NAMES)) {
[13:20:15.207]                   name <- removed[[kk]]
[13:20:15.207]                   NAME <- NAMES[[kk]]
[13:20:15.207]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.207]                     next
[13:20:15.207]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.207]                 }
[13:20:15.207]                 if (length(args) > 0) 
[13:20:15.207]                   base::do.call(base::Sys.setenv, args = args)
[13:20:15.207]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:15.207]             }
[13:20:15.207]             else {
[13:20:15.207]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:15.207]             }
[13:20:15.207]             {
[13:20:15.207]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:15.207]                   0L) {
[13:20:15.207]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:15.207]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:15.207]                   base::options(opts)
[13:20:15.207]                 }
[13:20:15.207]                 {
[13:20:15.207]                   {
[13:20:15.207]                     NULL
[13:20:15.207]                     RNGkind("Mersenne-Twister")
[13:20:15.207]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:15.207]                       inherits = FALSE)
[13:20:15.207]                   }
[13:20:15.207]                   options(future.plan = NULL)
[13:20:15.207]                   if (is.na(NA_character_)) 
[13:20:15.207]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.207]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:15.207]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:15.207]                   {
[13:20:15.207]                     future <- SequentialFuture(..., envir = envir)
[13:20:15.207]                     if (!future$lazy) 
[13:20:15.207]                       future <- run(future)
[13:20:15.207]                     invisible(future)
[13:20:15.207]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:15.207]                 }
[13:20:15.207]             }
[13:20:15.207]         }
[13:20:15.207]     })
[13:20:15.207]     if (TRUE) {
[13:20:15.207]         base::sink(type = "output", split = FALSE)
[13:20:15.207]         if (TRUE) {
[13:20:15.207]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:15.207]         }
[13:20:15.207]         else {
[13:20:15.207]             ...future.result["stdout"] <- base::list(NULL)
[13:20:15.207]         }
[13:20:15.207]         base::close(...future.stdout)
[13:20:15.207]         ...future.stdout <- NULL
[13:20:15.207]     }
[13:20:15.207]     ...future.result$conditions <- ...future.conditions
[13:20:15.207]     ...future.result$finished <- base::Sys.time()
[13:20:15.207]     ...future.result
[13:20:15.207] }
[13:20:15.209] plan(): Setting new future strategy stack:
[13:20:15.209] List of future strategies:
[13:20:15.209] 1. sequential:
[13:20:15.209]    - args: function (..., envir = parent.frame())
[13:20:15.209]    - tweaked: FALSE
[13:20:15.209]    - call: NULL
[13:20:15.209] plan(): nbrOfWorkers() = 1
[13:20:15.210] plan(): Setting new future strategy stack:
[13:20:15.210] List of future strategies:
[13:20:15.210] 1. sequential:
[13:20:15.210]    - args: function (..., envir = parent.frame())
[13:20:15.210]    - tweaked: FALSE
[13:20:15.210]    - call: plan(strategy)
[13:20:15.210] plan(): nbrOfWorkers() = 1
[13:20:15.211] SequentialFuture started (and completed)
[13:20:15.211] signalConditions() ...
[13:20:15.211]  - include = ‘immediateCondition’
[13:20:15.211]  - exclude = 
[13:20:15.211]  - resignal = FALSE
[13:20:15.211]  - Number of conditions: 1
[13:20:15.211] signalConditions() ... done
[13:20:15.211] - Launch lazy future ... done
[13:20:15.211] run() for ‘SequentialFuture’ ... done
[13:20:15.211] signalConditions() ...
[13:20:15.212]  - include = ‘immediateCondition’
[13:20:15.212]  - exclude = 
[13:20:15.212]  - resignal = FALSE
[13:20:15.212]  - Number of conditions: 1
[13:20:15.212] signalConditions() ... done
[13:20:15.212] Future state: ‘finished’
[13:20:15.212] signalConditions() ...
[13:20:15.212]  - include = ‘condition’
[13:20:15.212]  - exclude = ‘immediateCondition’
[13:20:15.212]  - resignal = TRUE
[13:20:15.212]  - Number of conditions: 1
[13:20:15.213]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:20:15.213] signalConditions() ... done
[13:20:15.213] getGlobalsAndPackages() ...
[13:20:15.214] Searching for globals...
[13:20:15.217] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[13:20:15.217] Searching for globals ... DONE
[13:20:15.217] Resolving globals: FALSE
[13:20:15.218] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:15.218] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:20:15.218] - globals: [1] ‘ii’
[13:20:15.219] 
[13:20:15.219] getGlobalsAndPackages() ... DONE
[13:20:15.219] run() for ‘Future’ ...
[13:20:15.219] - state: ‘created’
[13:20:15.219] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:15.219] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:15.219] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:15.220]   - Field: ‘label’
[13:20:15.220]   - Field: ‘local’
[13:20:15.220]   - Field: ‘owner’
[13:20:15.220]   - Field: ‘envir’
[13:20:15.220]   - Field: ‘packages’
[13:20:15.220]   - Field: ‘gc’
[13:20:15.220]   - Field: ‘conditions’
[13:20:15.220]   - Field: ‘expr’
[13:20:15.220]   - Field: ‘uuid’
[13:20:15.220]   - Field: ‘seed’
[13:20:15.220]   - Field: ‘version’
[13:20:15.221]   - Field: ‘result’
[13:20:15.221]   - Field: ‘asynchronous’
[13:20:15.221]   - Field: ‘calls’
[13:20:15.221]   - Field: ‘globals’
[13:20:15.221]   - Field: ‘stdout’
[13:20:15.221]   - Field: ‘earlySignal’
[13:20:15.221]   - Field: ‘lazy’
[13:20:15.221]   - Field: ‘state’
[13:20:15.221] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:15.221] - Launch lazy future ...
[13:20:15.222] Packages needed by the future expression (n = 0): <none>
[13:20:15.222] Packages needed by future strategies (n = 0): <none>
[13:20:15.222] {
[13:20:15.222]     {
[13:20:15.222]         {
[13:20:15.222]             ...future.startTime <- base::Sys.time()
[13:20:15.222]             {
[13:20:15.222]                 {
[13:20:15.222]                   {
[13:20:15.222]                     base::local({
[13:20:15.222]                       has_future <- base::requireNamespace("future", 
[13:20:15.222]                         quietly = TRUE)
[13:20:15.222]                       if (has_future) {
[13:20:15.222]                         ns <- base::getNamespace("future")
[13:20:15.222]                         version <- ns[[".package"]][["version"]]
[13:20:15.222]                         if (is.null(version)) 
[13:20:15.222]                           version <- utils::packageVersion("future")
[13:20:15.222]                       }
[13:20:15.222]                       else {
[13:20:15.222]                         version <- NULL
[13:20:15.222]                       }
[13:20:15.222]                       if (!has_future || version < "1.8.0") {
[13:20:15.222]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:15.222]                           "", base::R.version$version.string), 
[13:20:15.222]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:15.222]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:15.222]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:15.222]                             "release", "version")], collapse = " "), 
[13:20:15.222]                           hostname = base::Sys.info()[["nodename"]])
[13:20:15.222]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:15.222]                           info)
[13:20:15.222]                         info <- base::paste(info, collapse = "; ")
[13:20:15.222]                         if (!has_future) {
[13:20:15.222]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:15.222]                             info)
[13:20:15.222]                         }
[13:20:15.222]                         else {
[13:20:15.222]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:15.222]                             info, version)
[13:20:15.222]                         }
[13:20:15.222]                         base::stop(msg)
[13:20:15.222]                       }
[13:20:15.222]                     })
[13:20:15.222]                   }
[13:20:15.222]                   options(future.plan = NULL)
[13:20:15.222]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.222]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:15.222]                 }
[13:20:15.222]                 ...future.workdir <- getwd()
[13:20:15.222]             }
[13:20:15.222]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:15.222]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:15.222]         }
[13:20:15.222]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:15.222]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:15.222]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:15.222]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:15.222]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:15.222]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:15.222]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:15.222]             base::names(...future.oldOptions))
[13:20:15.222]     }
[13:20:15.222]     if (FALSE) {
[13:20:15.222]     }
[13:20:15.222]     else {
[13:20:15.222]         if (TRUE) {
[13:20:15.222]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:15.222]                 open = "w")
[13:20:15.222]         }
[13:20:15.222]         else {
[13:20:15.222]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:15.222]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:15.222]         }
[13:20:15.222]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:15.222]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:15.222]             base::sink(type = "output", split = FALSE)
[13:20:15.222]             base::close(...future.stdout)
[13:20:15.222]         }, add = TRUE)
[13:20:15.222]     }
[13:20:15.222]     ...future.frame <- base::sys.nframe()
[13:20:15.222]     ...future.conditions <- base::list()
[13:20:15.222]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:15.222]     if (FALSE) {
[13:20:15.222]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:15.222]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:15.222]     }
[13:20:15.222]     ...future.result <- base::tryCatch({
[13:20:15.222]         base::withCallingHandlers({
[13:20:15.222]             ...future.value <- base::withVisible(base::local({
[13:20:15.222]                 if (ii%%2 == 0) 
[13:20:15.222]                   stop("Woops!")
[13:20:15.222]                 ii
[13:20:15.222]             }))
[13:20:15.222]             future::FutureResult(value = ...future.value$value, 
[13:20:15.222]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.222]                   ...future.rng), globalenv = if (FALSE) 
[13:20:15.222]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:15.222]                     ...future.globalenv.names))
[13:20:15.222]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:15.222]         }, condition = base::local({
[13:20:15.222]             c <- base::c
[13:20:15.222]             inherits <- base::inherits
[13:20:15.222]             invokeRestart <- base::invokeRestart
[13:20:15.222]             length <- base::length
[13:20:15.222]             list <- base::list
[13:20:15.222]             seq.int <- base::seq.int
[13:20:15.222]             signalCondition <- base::signalCondition
[13:20:15.222]             sys.calls <- base::sys.calls
[13:20:15.222]             `[[` <- base::`[[`
[13:20:15.222]             `+` <- base::`+`
[13:20:15.222]             `<<-` <- base::`<<-`
[13:20:15.222]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:15.222]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:15.222]                   3L)]
[13:20:15.222]             }
[13:20:15.222]             function(cond) {
[13:20:15.222]                 is_error <- inherits(cond, "error")
[13:20:15.222]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:15.222]                   NULL)
[13:20:15.222]                 if (is_error) {
[13:20:15.222]                   sessionInformation <- function() {
[13:20:15.222]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:15.222]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:15.222]                       search = base::search(), system = base::Sys.info())
[13:20:15.222]                   }
[13:20:15.222]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.222]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:15.222]                     cond$call), session = sessionInformation(), 
[13:20:15.222]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:15.222]                   signalCondition(cond)
[13:20:15.222]                 }
[13:20:15.222]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:15.222]                 "immediateCondition"))) {
[13:20:15.222]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:15.222]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.222]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:15.222]                   if (TRUE && !signal) {
[13:20:15.222]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.222]                     {
[13:20:15.222]                       inherits <- base::inherits
[13:20:15.222]                       invokeRestart <- base::invokeRestart
[13:20:15.222]                       is.null <- base::is.null
[13:20:15.222]                       muffled <- FALSE
[13:20:15.222]                       if (inherits(cond, "message")) {
[13:20:15.222]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.222]                         if (muffled) 
[13:20:15.222]                           invokeRestart("muffleMessage")
[13:20:15.222]                       }
[13:20:15.222]                       else if (inherits(cond, "warning")) {
[13:20:15.222]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.222]                         if (muffled) 
[13:20:15.222]                           invokeRestart("muffleWarning")
[13:20:15.222]                       }
[13:20:15.222]                       else if (inherits(cond, "condition")) {
[13:20:15.222]                         if (!is.null(pattern)) {
[13:20:15.222]                           computeRestarts <- base::computeRestarts
[13:20:15.222]                           grepl <- base::grepl
[13:20:15.222]                           restarts <- computeRestarts(cond)
[13:20:15.222]                           for (restart in restarts) {
[13:20:15.222]                             name <- restart$name
[13:20:15.222]                             if (is.null(name)) 
[13:20:15.222]                               next
[13:20:15.222]                             if (!grepl(pattern, name)) 
[13:20:15.222]                               next
[13:20:15.222]                             invokeRestart(restart)
[13:20:15.222]                             muffled <- TRUE
[13:20:15.222]                             break
[13:20:15.222]                           }
[13:20:15.222]                         }
[13:20:15.222]                       }
[13:20:15.222]                       invisible(muffled)
[13:20:15.222]                     }
[13:20:15.222]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.222]                   }
[13:20:15.222]                 }
[13:20:15.222]                 else {
[13:20:15.222]                   if (TRUE) {
[13:20:15.222]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.222]                     {
[13:20:15.222]                       inherits <- base::inherits
[13:20:15.222]                       invokeRestart <- base::invokeRestart
[13:20:15.222]                       is.null <- base::is.null
[13:20:15.222]                       muffled <- FALSE
[13:20:15.222]                       if (inherits(cond, "message")) {
[13:20:15.222]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.222]                         if (muffled) 
[13:20:15.222]                           invokeRestart("muffleMessage")
[13:20:15.222]                       }
[13:20:15.222]                       else if (inherits(cond, "warning")) {
[13:20:15.222]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.222]                         if (muffled) 
[13:20:15.222]                           invokeRestart("muffleWarning")
[13:20:15.222]                       }
[13:20:15.222]                       else if (inherits(cond, "condition")) {
[13:20:15.222]                         if (!is.null(pattern)) {
[13:20:15.222]                           computeRestarts <- base::computeRestarts
[13:20:15.222]                           grepl <- base::grepl
[13:20:15.222]                           restarts <- computeRestarts(cond)
[13:20:15.222]                           for (restart in restarts) {
[13:20:15.222]                             name <- restart$name
[13:20:15.222]                             if (is.null(name)) 
[13:20:15.222]                               next
[13:20:15.222]                             if (!grepl(pattern, name)) 
[13:20:15.222]                               next
[13:20:15.222]                             invokeRestart(restart)
[13:20:15.222]                             muffled <- TRUE
[13:20:15.222]                             break
[13:20:15.222]                           }
[13:20:15.222]                         }
[13:20:15.222]                       }
[13:20:15.222]                       invisible(muffled)
[13:20:15.222]                     }
[13:20:15.222]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.222]                   }
[13:20:15.222]                 }
[13:20:15.222]             }
[13:20:15.222]         }))
[13:20:15.222]     }, error = function(ex) {
[13:20:15.222]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:15.222]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.222]                 ...future.rng), started = ...future.startTime, 
[13:20:15.222]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:15.222]             version = "1.8"), class = "FutureResult")
[13:20:15.222]     }, finally = {
[13:20:15.222]         if (!identical(...future.workdir, getwd())) 
[13:20:15.222]             setwd(...future.workdir)
[13:20:15.222]         {
[13:20:15.222]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:15.222]                 ...future.oldOptions$nwarnings <- NULL
[13:20:15.222]             }
[13:20:15.222]             base::options(...future.oldOptions)
[13:20:15.222]             if (.Platform$OS.type == "windows") {
[13:20:15.222]                 old_names <- names(...future.oldEnvVars)
[13:20:15.222]                 envs <- base::Sys.getenv()
[13:20:15.222]                 names <- names(envs)
[13:20:15.222]                 common <- intersect(names, old_names)
[13:20:15.222]                 added <- setdiff(names, old_names)
[13:20:15.222]                 removed <- setdiff(old_names, names)
[13:20:15.222]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:15.222]                   envs[common]]
[13:20:15.222]                 NAMES <- toupper(changed)
[13:20:15.222]                 args <- list()
[13:20:15.222]                 for (kk in seq_along(NAMES)) {
[13:20:15.222]                   name <- changed[[kk]]
[13:20:15.222]                   NAME <- NAMES[[kk]]
[13:20:15.222]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.222]                     next
[13:20:15.222]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.222]                 }
[13:20:15.222]                 NAMES <- toupper(added)
[13:20:15.222]                 for (kk in seq_along(NAMES)) {
[13:20:15.222]                   name <- added[[kk]]
[13:20:15.222]                   NAME <- NAMES[[kk]]
[13:20:15.222]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.222]                     next
[13:20:15.222]                   args[[name]] <- ""
[13:20:15.222]                 }
[13:20:15.222]                 NAMES <- toupper(removed)
[13:20:15.222]                 for (kk in seq_along(NAMES)) {
[13:20:15.222]                   name <- removed[[kk]]
[13:20:15.222]                   NAME <- NAMES[[kk]]
[13:20:15.222]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.222]                     next
[13:20:15.222]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.222]                 }
[13:20:15.222]                 if (length(args) > 0) 
[13:20:15.222]                   base::do.call(base::Sys.setenv, args = args)
[13:20:15.222]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:15.222]             }
[13:20:15.222]             else {
[13:20:15.222]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:15.222]             }
[13:20:15.222]             {
[13:20:15.222]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:15.222]                   0L) {
[13:20:15.222]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:15.222]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:15.222]                   base::options(opts)
[13:20:15.222]                 }
[13:20:15.222]                 {
[13:20:15.222]                   {
[13:20:15.222]                     NULL
[13:20:15.222]                     RNGkind("Mersenne-Twister")
[13:20:15.222]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:15.222]                       inherits = FALSE)
[13:20:15.222]                   }
[13:20:15.222]                   options(future.plan = NULL)
[13:20:15.222]                   if (is.na(NA_character_)) 
[13:20:15.222]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.222]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:15.222]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:15.222]                   {
[13:20:15.222]                     future <- SequentialFuture(..., envir = envir)
[13:20:15.222]                     if (!future$lazy) 
[13:20:15.222]                       future <- run(future)
[13:20:15.222]                     invisible(future)
[13:20:15.222]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:15.222]                 }
[13:20:15.222]             }
[13:20:15.222]         }
[13:20:15.222]     })
[13:20:15.222]     if (TRUE) {
[13:20:15.222]         base::sink(type = "output", split = FALSE)
[13:20:15.222]         if (TRUE) {
[13:20:15.222]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:15.222]         }
[13:20:15.222]         else {
[13:20:15.222]             ...future.result["stdout"] <- base::list(NULL)
[13:20:15.222]         }
[13:20:15.222]         base::close(...future.stdout)
[13:20:15.222]         ...future.stdout <- NULL
[13:20:15.222]     }
[13:20:15.222]     ...future.result$conditions <- ...future.conditions
[13:20:15.222]     ...future.result$finished <- base::Sys.time()
[13:20:15.222]     ...future.result
[13:20:15.222] }
[13:20:15.224] assign_globals() ...
[13:20:15.224] List of 1
[13:20:15.224]  $ ii: int 1
[13:20:15.224]  - attr(*, "where")=List of 1
[13:20:15.224]   ..$ ii:<environment: R_EmptyEnv> 
[13:20:15.224]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:15.224]  - attr(*, "resolved")= logi FALSE
[13:20:15.224]  - attr(*, "total_size")= num 56
[13:20:15.224]  - attr(*, "already-done")= logi TRUE
[13:20:15.226] - copied ‘ii’ to environment
[13:20:15.226] assign_globals() ... done
[13:20:15.226] plan(): Setting new future strategy stack:
[13:20:15.227] List of future strategies:
[13:20:15.227] 1. sequential:
[13:20:15.227]    - args: function (..., envir = parent.frame())
[13:20:15.227]    - tweaked: FALSE
[13:20:15.227]    - call: NULL
[13:20:15.227] plan(): nbrOfWorkers() = 1
[13:20:15.228] plan(): Setting new future strategy stack:
[13:20:15.228] List of future strategies:
[13:20:15.228] 1. sequential:
[13:20:15.228]    - args: function (..., envir = parent.frame())
[13:20:15.228]    - tweaked: FALSE
[13:20:15.228]    - call: plan(strategy)
[13:20:15.228] plan(): nbrOfWorkers() = 1
[13:20:15.228] SequentialFuture started (and completed)
[13:20:15.228] - Launch lazy future ... done
[13:20:15.228] run() for ‘SequentialFuture’ ... done
[13:20:15.229] getGlobalsAndPackages() ...
[13:20:15.229] Searching for globals...
[13:20:15.230] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[13:20:15.230] Searching for globals ... DONE
[13:20:15.231] Resolving globals: FALSE
[13:20:15.231] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:15.231] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:20:15.231] - globals: [1] ‘ii’
[13:20:15.232] 
[13:20:15.232] getGlobalsAndPackages() ... DONE
[13:20:15.232] run() for ‘Future’ ...
[13:20:15.232] - state: ‘created’
[13:20:15.232] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:15.232] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:15.232] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:15.233]   - Field: ‘label’
[13:20:15.233]   - Field: ‘local’
[13:20:15.233]   - Field: ‘owner’
[13:20:15.233]   - Field: ‘envir’
[13:20:15.233]   - Field: ‘packages’
[13:20:15.233]   - Field: ‘gc’
[13:20:15.233]   - Field: ‘conditions’
[13:20:15.233]   - Field: ‘expr’
[13:20:15.233]   - Field: ‘uuid’
[13:20:15.233]   - Field: ‘seed’
[13:20:15.233]   - Field: ‘version’
[13:20:15.234]   - Field: ‘result’
[13:20:15.234]   - Field: ‘asynchronous’
[13:20:15.234]   - Field: ‘calls’
[13:20:15.234]   - Field: ‘globals’
[13:20:15.234]   - Field: ‘stdout’
[13:20:15.234]   - Field: ‘earlySignal’
[13:20:15.234]   - Field: ‘lazy’
[13:20:15.234]   - Field: ‘state’
[13:20:15.234] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:15.234] - Launch lazy future ...
[13:20:15.235] Packages needed by the future expression (n = 0): <none>
[13:20:15.235] Packages needed by future strategies (n = 0): <none>
[13:20:15.235] {
[13:20:15.235]     {
[13:20:15.235]         {
[13:20:15.235]             ...future.startTime <- base::Sys.time()
[13:20:15.235]             {
[13:20:15.235]                 {
[13:20:15.235]                   {
[13:20:15.235]                     base::local({
[13:20:15.235]                       has_future <- base::requireNamespace("future", 
[13:20:15.235]                         quietly = TRUE)
[13:20:15.235]                       if (has_future) {
[13:20:15.235]                         ns <- base::getNamespace("future")
[13:20:15.235]                         version <- ns[[".package"]][["version"]]
[13:20:15.235]                         if (is.null(version)) 
[13:20:15.235]                           version <- utils::packageVersion("future")
[13:20:15.235]                       }
[13:20:15.235]                       else {
[13:20:15.235]                         version <- NULL
[13:20:15.235]                       }
[13:20:15.235]                       if (!has_future || version < "1.8.0") {
[13:20:15.235]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:15.235]                           "", base::R.version$version.string), 
[13:20:15.235]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:15.235]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:15.235]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:15.235]                             "release", "version")], collapse = " "), 
[13:20:15.235]                           hostname = base::Sys.info()[["nodename"]])
[13:20:15.235]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:15.235]                           info)
[13:20:15.235]                         info <- base::paste(info, collapse = "; ")
[13:20:15.235]                         if (!has_future) {
[13:20:15.235]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:15.235]                             info)
[13:20:15.235]                         }
[13:20:15.235]                         else {
[13:20:15.235]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:15.235]                             info, version)
[13:20:15.235]                         }
[13:20:15.235]                         base::stop(msg)
[13:20:15.235]                       }
[13:20:15.235]                     })
[13:20:15.235]                   }
[13:20:15.235]                   options(future.plan = NULL)
[13:20:15.235]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.235]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:15.235]                 }
[13:20:15.235]                 ...future.workdir <- getwd()
[13:20:15.235]             }
[13:20:15.235]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:15.235]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:15.235]         }
[13:20:15.235]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:15.235]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:15.235]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:15.235]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:15.235]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:15.235]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:15.235]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:15.235]             base::names(...future.oldOptions))
[13:20:15.235]     }
[13:20:15.235]     if (FALSE) {
[13:20:15.235]     }
[13:20:15.235]     else {
[13:20:15.235]         if (TRUE) {
[13:20:15.235]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:15.235]                 open = "w")
[13:20:15.235]         }
[13:20:15.235]         else {
[13:20:15.235]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:15.235]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:15.235]         }
[13:20:15.235]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:15.235]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:15.235]             base::sink(type = "output", split = FALSE)
[13:20:15.235]             base::close(...future.stdout)
[13:20:15.235]         }, add = TRUE)
[13:20:15.235]     }
[13:20:15.235]     ...future.frame <- base::sys.nframe()
[13:20:15.235]     ...future.conditions <- base::list()
[13:20:15.235]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:15.235]     if (FALSE) {
[13:20:15.235]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:15.235]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:15.235]     }
[13:20:15.235]     ...future.result <- base::tryCatch({
[13:20:15.235]         base::withCallingHandlers({
[13:20:15.235]             ...future.value <- base::withVisible(base::local({
[13:20:15.235]                 if (ii%%2 == 0) 
[13:20:15.235]                   stop("Woops!")
[13:20:15.235]                 ii
[13:20:15.235]             }))
[13:20:15.235]             future::FutureResult(value = ...future.value$value, 
[13:20:15.235]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.235]                   ...future.rng), globalenv = if (FALSE) 
[13:20:15.235]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:15.235]                     ...future.globalenv.names))
[13:20:15.235]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:15.235]         }, condition = base::local({
[13:20:15.235]             c <- base::c
[13:20:15.235]             inherits <- base::inherits
[13:20:15.235]             invokeRestart <- base::invokeRestart
[13:20:15.235]             length <- base::length
[13:20:15.235]             list <- base::list
[13:20:15.235]             seq.int <- base::seq.int
[13:20:15.235]             signalCondition <- base::signalCondition
[13:20:15.235]             sys.calls <- base::sys.calls
[13:20:15.235]             `[[` <- base::`[[`
[13:20:15.235]             `+` <- base::`+`
[13:20:15.235]             `<<-` <- base::`<<-`
[13:20:15.235]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:15.235]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:15.235]                   3L)]
[13:20:15.235]             }
[13:20:15.235]             function(cond) {
[13:20:15.235]                 is_error <- inherits(cond, "error")
[13:20:15.235]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:15.235]                   NULL)
[13:20:15.235]                 if (is_error) {
[13:20:15.235]                   sessionInformation <- function() {
[13:20:15.235]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:15.235]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:15.235]                       search = base::search(), system = base::Sys.info())
[13:20:15.235]                   }
[13:20:15.235]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.235]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:15.235]                     cond$call), session = sessionInformation(), 
[13:20:15.235]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:15.235]                   signalCondition(cond)
[13:20:15.235]                 }
[13:20:15.235]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:15.235]                 "immediateCondition"))) {
[13:20:15.235]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:15.235]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.235]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:15.235]                   if (TRUE && !signal) {
[13:20:15.235]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.235]                     {
[13:20:15.235]                       inherits <- base::inherits
[13:20:15.235]                       invokeRestart <- base::invokeRestart
[13:20:15.235]                       is.null <- base::is.null
[13:20:15.235]                       muffled <- FALSE
[13:20:15.235]                       if (inherits(cond, "message")) {
[13:20:15.235]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.235]                         if (muffled) 
[13:20:15.235]                           invokeRestart("muffleMessage")
[13:20:15.235]                       }
[13:20:15.235]                       else if (inherits(cond, "warning")) {
[13:20:15.235]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.235]                         if (muffled) 
[13:20:15.235]                           invokeRestart("muffleWarning")
[13:20:15.235]                       }
[13:20:15.235]                       else if (inherits(cond, "condition")) {
[13:20:15.235]                         if (!is.null(pattern)) {
[13:20:15.235]                           computeRestarts <- base::computeRestarts
[13:20:15.235]                           grepl <- base::grepl
[13:20:15.235]                           restarts <- computeRestarts(cond)
[13:20:15.235]                           for (restart in restarts) {
[13:20:15.235]                             name <- restart$name
[13:20:15.235]                             if (is.null(name)) 
[13:20:15.235]                               next
[13:20:15.235]                             if (!grepl(pattern, name)) 
[13:20:15.235]                               next
[13:20:15.235]                             invokeRestart(restart)
[13:20:15.235]                             muffled <- TRUE
[13:20:15.235]                             break
[13:20:15.235]                           }
[13:20:15.235]                         }
[13:20:15.235]                       }
[13:20:15.235]                       invisible(muffled)
[13:20:15.235]                     }
[13:20:15.235]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.235]                   }
[13:20:15.235]                 }
[13:20:15.235]                 else {
[13:20:15.235]                   if (TRUE) {
[13:20:15.235]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.235]                     {
[13:20:15.235]                       inherits <- base::inherits
[13:20:15.235]                       invokeRestart <- base::invokeRestart
[13:20:15.235]                       is.null <- base::is.null
[13:20:15.235]                       muffled <- FALSE
[13:20:15.235]                       if (inherits(cond, "message")) {
[13:20:15.235]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.235]                         if (muffled) 
[13:20:15.235]                           invokeRestart("muffleMessage")
[13:20:15.235]                       }
[13:20:15.235]                       else if (inherits(cond, "warning")) {
[13:20:15.235]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.235]                         if (muffled) 
[13:20:15.235]                           invokeRestart("muffleWarning")
[13:20:15.235]                       }
[13:20:15.235]                       else if (inherits(cond, "condition")) {
[13:20:15.235]                         if (!is.null(pattern)) {
[13:20:15.235]                           computeRestarts <- base::computeRestarts
[13:20:15.235]                           grepl <- base::grepl
[13:20:15.235]                           restarts <- computeRestarts(cond)
[13:20:15.235]                           for (restart in restarts) {
[13:20:15.235]                             name <- restart$name
[13:20:15.235]                             if (is.null(name)) 
[13:20:15.235]                               next
[13:20:15.235]                             if (!grepl(pattern, name)) 
[13:20:15.235]                               next
[13:20:15.235]                             invokeRestart(restart)
[13:20:15.235]                             muffled <- TRUE
[13:20:15.235]                             break
[13:20:15.235]                           }
[13:20:15.235]                         }
[13:20:15.235]                       }
[13:20:15.235]                       invisible(muffled)
[13:20:15.235]                     }
[13:20:15.235]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.235]                   }
[13:20:15.235]                 }
[13:20:15.235]             }
[13:20:15.235]         }))
[13:20:15.235]     }, error = function(ex) {
[13:20:15.235]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:15.235]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.235]                 ...future.rng), started = ...future.startTime, 
[13:20:15.235]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:15.235]             version = "1.8"), class = "FutureResult")
[13:20:15.235]     }, finally = {
[13:20:15.235]         if (!identical(...future.workdir, getwd())) 
[13:20:15.235]             setwd(...future.workdir)
[13:20:15.235]         {
[13:20:15.235]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:15.235]                 ...future.oldOptions$nwarnings <- NULL
[13:20:15.235]             }
[13:20:15.235]             base::options(...future.oldOptions)
[13:20:15.235]             if (.Platform$OS.type == "windows") {
[13:20:15.235]                 old_names <- names(...future.oldEnvVars)
[13:20:15.235]                 envs <- base::Sys.getenv()
[13:20:15.235]                 names <- names(envs)
[13:20:15.235]                 common <- intersect(names, old_names)
[13:20:15.235]                 added <- setdiff(names, old_names)
[13:20:15.235]                 removed <- setdiff(old_names, names)
[13:20:15.235]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:15.235]                   envs[common]]
[13:20:15.235]                 NAMES <- toupper(changed)
[13:20:15.235]                 args <- list()
[13:20:15.235]                 for (kk in seq_along(NAMES)) {
[13:20:15.235]                   name <- changed[[kk]]
[13:20:15.235]                   NAME <- NAMES[[kk]]
[13:20:15.235]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.235]                     next
[13:20:15.235]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.235]                 }
[13:20:15.235]                 NAMES <- toupper(added)
[13:20:15.235]                 for (kk in seq_along(NAMES)) {
[13:20:15.235]                   name <- added[[kk]]
[13:20:15.235]                   NAME <- NAMES[[kk]]
[13:20:15.235]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.235]                     next
[13:20:15.235]                   args[[name]] <- ""
[13:20:15.235]                 }
[13:20:15.235]                 NAMES <- toupper(removed)
[13:20:15.235]                 for (kk in seq_along(NAMES)) {
[13:20:15.235]                   name <- removed[[kk]]
[13:20:15.235]                   NAME <- NAMES[[kk]]
[13:20:15.235]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.235]                     next
[13:20:15.235]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.235]                 }
[13:20:15.235]                 if (length(args) > 0) 
[13:20:15.235]                   base::do.call(base::Sys.setenv, args = args)
[13:20:15.235]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:15.235]             }
[13:20:15.235]             else {
[13:20:15.235]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:15.235]             }
[13:20:15.235]             {
[13:20:15.235]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:15.235]                   0L) {
[13:20:15.235]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:15.235]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:15.235]                   base::options(opts)
[13:20:15.235]                 }
[13:20:15.235]                 {
[13:20:15.235]                   {
[13:20:15.235]                     NULL
[13:20:15.235]                     RNGkind("Mersenne-Twister")
[13:20:15.235]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:15.235]                       inherits = FALSE)
[13:20:15.235]                   }
[13:20:15.235]                   options(future.plan = NULL)
[13:20:15.235]                   if (is.na(NA_character_)) 
[13:20:15.235]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.235]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:15.235]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:15.235]                   {
[13:20:15.235]                     future <- SequentialFuture(..., envir = envir)
[13:20:15.235]                     if (!future$lazy) 
[13:20:15.235]                       future <- run(future)
[13:20:15.235]                     invisible(future)
[13:20:15.235]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:15.235]                 }
[13:20:15.235]             }
[13:20:15.235]         }
[13:20:15.235]     })
[13:20:15.235]     if (TRUE) {
[13:20:15.235]         base::sink(type = "output", split = FALSE)
[13:20:15.235]         if (TRUE) {
[13:20:15.235]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:15.235]         }
[13:20:15.235]         else {
[13:20:15.235]             ...future.result["stdout"] <- base::list(NULL)
[13:20:15.235]         }
[13:20:15.235]         base::close(...future.stdout)
[13:20:15.235]         ...future.stdout <- NULL
[13:20:15.235]     }
[13:20:15.235]     ...future.result$conditions <- ...future.conditions
[13:20:15.235]     ...future.result$finished <- base::Sys.time()
[13:20:15.235]     ...future.result
[13:20:15.235] }
[13:20:15.237] assign_globals() ...
[13:20:15.237] List of 1
[13:20:15.237]  $ ii: int 2
[13:20:15.237]  - attr(*, "where")=List of 1
[13:20:15.237]   ..$ ii:<environment: R_EmptyEnv> 
[13:20:15.237]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:15.237]  - attr(*, "resolved")= logi FALSE
[13:20:15.237]  - attr(*, "total_size")= num 56
[13:20:15.237]  - attr(*, "already-done")= logi TRUE
[13:20:15.239] - copied ‘ii’ to environment
[13:20:15.239] assign_globals() ... done
[13:20:15.239] plan(): Setting new future strategy stack:
[13:20:15.239] List of future strategies:
[13:20:15.239] 1. sequential:
[13:20:15.239]    - args: function (..., envir = parent.frame())
[13:20:15.239]    - tweaked: FALSE
[13:20:15.239]    - call: NULL
[13:20:15.240] plan(): nbrOfWorkers() = 1
[13:20:15.241] plan(): Setting new future strategy stack:
[13:20:15.241] List of future strategies:
[13:20:15.241] 1. sequential:
[13:20:15.241]    - args: function (..., envir = parent.frame())
[13:20:15.241]    - tweaked: FALSE
[13:20:15.241]    - call: plan(strategy)
[13:20:15.241] plan(): nbrOfWorkers() = 1
[13:20:15.241] SequentialFuture started (and completed)
[13:20:15.241] signalConditions() ...
[13:20:15.241]  - include = ‘immediateCondition’
[13:20:15.242]  - exclude = 
[13:20:15.242]  - resignal = FALSE
[13:20:15.242]  - Number of conditions: 1
[13:20:15.242] signalConditions() ... done
[13:20:15.242] - Launch lazy future ... done
[13:20:15.242] run() for ‘SequentialFuture’ ... done
[13:20:15.242] getGlobalsAndPackages() ...
[13:20:15.242] Searching for globals...
[13:20:15.245] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[13:20:15.245] Searching for globals ... DONE
[13:20:15.245] Resolving globals: FALSE
[13:20:15.246] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:15.246] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:20:15.246] - globals: [1] ‘ii’
[13:20:15.247] 
[13:20:15.247] getGlobalsAndPackages() ... DONE
[13:20:15.247] run() for ‘Future’ ...
[13:20:15.247] - state: ‘created’
[13:20:15.247] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:15.247] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:15.247] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:15.248]   - Field: ‘label’
[13:20:15.248]   - Field: ‘local’
[13:20:15.248]   - Field: ‘owner’
[13:20:15.248]   - Field: ‘envir’
[13:20:15.248]   - Field: ‘packages’
[13:20:15.248]   - Field: ‘gc’
[13:20:15.248]   - Field: ‘conditions’
[13:20:15.248]   - Field: ‘expr’
[13:20:15.248]   - Field: ‘uuid’
[13:20:15.248]   - Field: ‘seed’
[13:20:15.249]   - Field: ‘version’
[13:20:15.249]   - Field: ‘result’
[13:20:15.249]   - Field: ‘asynchronous’
[13:20:15.249]   - Field: ‘calls’
[13:20:15.249]   - Field: ‘globals’
[13:20:15.249]   - Field: ‘stdout’
[13:20:15.249]   - Field: ‘earlySignal’
[13:20:15.249]   - Field: ‘lazy’
[13:20:15.249]   - Field: ‘state’
[13:20:15.249] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:15.249] - Launch lazy future ...
[13:20:15.250] Packages needed by the future expression (n = 0): <none>
[13:20:15.250] Packages needed by future strategies (n = 0): <none>
[13:20:15.250] {
[13:20:15.250]     {
[13:20:15.250]         {
[13:20:15.250]             ...future.startTime <- base::Sys.time()
[13:20:15.250]             {
[13:20:15.250]                 {
[13:20:15.250]                   {
[13:20:15.250]                     base::local({
[13:20:15.250]                       has_future <- base::requireNamespace("future", 
[13:20:15.250]                         quietly = TRUE)
[13:20:15.250]                       if (has_future) {
[13:20:15.250]                         ns <- base::getNamespace("future")
[13:20:15.250]                         version <- ns[[".package"]][["version"]]
[13:20:15.250]                         if (is.null(version)) 
[13:20:15.250]                           version <- utils::packageVersion("future")
[13:20:15.250]                       }
[13:20:15.250]                       else {
[13:20:15.250]                         version <- NULL
[13:20:15.250]                       }
[13:20:15.250]                       if (!has_future || version < "1.8.0") {
[13:20:15.250]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:15.250]                           "", base::R.version$version.string), 
[13:20:15.250]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:15.250]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:15.250]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:15.250]                             "release", "version")], collapse = " "), 
[13:20:15.250]                           hostname = base::Sys.info()[["nodename"]])
[13:20:15.250]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:15.250]                           info)
[13:20:15.250]                         info <- base::paste(info, collapse = "; ")
[13:20:15.250]                         if (!has_future) {
[13:20:15.250]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:15.250]                             info)
[13:20:15.250]                         }
[13:20:15.250]                         else {
[13:20:15.250]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:15.250]                             info, version)
[13:20:15.250]                         }
[13:20:15.250]                         base::stop(msg)
[13:20:15.250]                       }
[13:20:15.250]                     })
[13:20:15.250]                   }
[13:20:15.250]                   options(future.plan = NULL)
[13:20:15.250]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.250]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:15.250]                 }
[13:20:15.250]                 ...future.workdir <- getwd()
[13:20:15.250]             }
[13:20:15.250]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:15.250]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:15.250]         }
[13:20:15.250]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:15.250]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:15.250]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:15.250]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:15.250]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:15.250]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:15.250]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:15.250]             base::names(...future.oldOptions))
[13:20:15.250]     }
[13:20:15.250]     if (FALSE) {
[13:20:15.250]     }
[13:20:15.250]     else {
[13:20:15.250]         if (TRUE) {
[13:20:15.250]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:15.250]                 open = "w")
[13:20:15.250]         }
[13:20:15.250]         else {
[13:20:15.250]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:15.250]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:15.250]         }
[13:20:15.250]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:15.250]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:15.250]             base::sink(type = "output", split = FALSE)
[13:20:15.250]             base::close(...future.stdout)
[13:20:15.250]         }, add = TRUE)
[13:20:15.250]     }
[13:20:15.250]     ...future.frame <- base::sys.nframe()
[13:20:15.250]     ...future.conditions <- base::list()
[13:20:15.250]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:15.250]     if (FALSE) {
[13:20:15.250]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:15.250]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:15.250]     }
[13:20:15.250]     ...future.result <- base::tryCatch({
[13:20:15.250]         base::withCallingHandlers({
[13:20:15.250]             ...future.value <- base::withVisible(base::local({
[13:20:15.250]                 if (ii%%2 == 0) 
[13:20:15.250]                   stop("Woops!")
[13:20:15.250]                 ii
[13:20:15.250]             }))
[13:20:15.250]             future::FutureResult(value = ...future.value$value, 
[13:20:15.250]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.250]                   ...future.rng), globalenv = if (FALSE) 
[13:20:15.250]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:15.250]                     ...future.globalenv.names))
[13:20:15.250]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:15.250]         }, condition = base::local({
[13:20:15.250]             c <- base::c
[13:20:15.250]             inherits <- base::inherits
[13:20:15.250]             invokeRestart <- base::invokeRestart
[13:20:15.250]             length <- base::length
[13:20:15.250]             list <- base::list
[13:20:15.250]             seq.int <- base::seq.int
[13:20:15.250]             signalCondition <- base::signalCondition
[13:20:15.250]             sys.calls <- base::sys.calls
[13:20:15.250]             `[[` <- base::`[[`
[13:20:15.250]             `+` <- base::`+`
[13:20:15.250]             `<<-` <- base::`<<-`
[13:20:15.250]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:15.250]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:15.250]                   3L)]
[13:20:15.250]             }
[13:20:15.250]             function(cond) {
[13:20:15.250]                 is_error <- inherits(cond, "error")
[13:20:15.250]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:15.250]                   NULL)
[13:20:15.250]                 if (is_error) {
[13:20:15.250]                   sessionInformation <- function() {
[13:20:15.250]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:15.250]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:15.250]                       search = base::search(), system = base::Sys.info())
[13:20:15.250]                   }
[13:20:15.250]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.250]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:15.250]                     cond$call), session = sessionInformation(), 
[13:20:15.250]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:15.250]                   signalCondition(cond)
[13:20:15.250]                 }
[13:20:15.250]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:15.250]                 "immediateCondition"))) {
[13:20:15.250]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:15.250]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.250]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:15.250]                   if (TRUE && !signal) {
[13:20:15.250]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.250]                     {
[13:20:15.250]                       inherits <- base::inherits
[13:20:15.250]                       invokeRestart <- base::invokeRestart
[13:20:15.250]                       is.null <- base::is.null
[13:20:15.250]                       muffled <- FALSE
[13:20:15.250]                       if (inherits(cond, "message")) {
[13:20:15.250]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.250]                         if (muffled) 
[13:20:15.250]                           invokeRestart("muffleMessage")
[13:20:15.250]                       }
[13:20:15.250]                       else if (inherits(cond, "warning")) {
[13:20:15.250]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.250]                         if (muffled) 
[13:20:15.250]                           invokeRestart("muffleWarning")
[13:20:15.250]                       }
[13:20:15.250]                       else if (inherits(cond, "condition")) {
[13:20:15.250]                         if (!is.null(pattern)) {
[13:20:15.250]                           computeRestarts <- base::computeRestarts
[13:20:15.250]                           grepl <- base::grepl
[13:20:15.250]                           restarts <- computeRestarts(cond)
[13:20:15.250]                           for (restart in restarts) {
[13:20:15.250]                             name <- restart$name
[13:20:15.250]                             if (is.null(name)) 
[13:20:15.250]                               next
[13:20:15.250]                             if (!grepl(pattern, name)) 
[13:20:15.250]                               next
[13:20:15.250]                             invokeRestart(restart)
[13:20:15.250]                             muffled <- TRUE
[13:20:15.250]                             break
[13:20:15.250]                           }
[13:20:15.250]                         }
[13:20:15.250]                       }
[13:20:15.250]                       invisible(muffled)
[13:20:15.250]                     }
[13:20:15.250]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.250]                   }
[13:20:15.250]                 }
[13:20:15.250]                 else {
[13:20:15.250]                   if (TRUE) {
[13:20:15.250]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.250]                     {
[13:20:15.250]                       inherits <- base::inherits
[13:20:15.250]                       invokeRestart <- base::invokeRestart
[13:20:15.250]                       is.null <- base::is.null
[13:20:15.250]                       muffled <- FALSE
[13:20:15.250]                       if (inherits(cond, "message")) {
[13:20:15.250]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.250]                         if (muffled) 
[13:20:15.250]                           invokeRestart("muffleMessage")
[13:20:15.250]                       }
[13:20:15.250]                       else if (inherits(cond, "warning")) {
[13:20:15.250]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.250]                         if (muffled) 
[13:20:15.250]                           invokeRestart("muffleWarning")
[13:20:15.250]                       }
[13:20:15.250]                       else if (inherits(cond, "condition")) {
[13:20:15.250]                         if (!is.null(pattern)) {
[13:20:15.250]                           computeRestarts <- base::computeRestarts
[13:20:15.250]                           grepl <- base::grepl
[13:20:15.250]                           restarts <- computeRestarts(cond)
[13:20:15.250]                           for (restart in restarts) {
[13:20:15.250]                             name <- restart$name
[13:20:15.250]                             if (is.null(name)) 
[13:20:15.250]                               next
[13:20:15.250]                             if (!grepl(pattern, name)) 
[13:20:15.250]                               next
[13:20:15.250]                             invokeRestart(restart)
[13:20:15.250]                             muffled <- TRUE
[13:20:15.250]                             break
[13:20:15.250]                           }
[13:20:15.250]                         }
[13:20:15.250]                       }
[13:20:15.250]                       invisible(muffled)
[13:20:15.250]                     }
[13:20:15.250]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.250]                   }
[13:20:15.250]                 }
[13:20:15.250]             }
[13:20:15.250]         }))
[13:20:15.250]     }, error = function(ex) {
[13:20:15.250]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:15.250]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.250]                 ...future.rng), started = ...future.startTime, 
[13:20:15.250]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:15.250]             version = "1.8"), class = "FutureResult")
[13:20:15.250]     }, finally = {
[13:20:15.250]         if (!identical(...future.workdir, getwd())) 
[13:20:15.250]             setwd(...future.workdir)
[13:20:15.250]         {
[13:20:15.250]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:15.250]                 ...future.oldOptions$nwarnings <- NULL
[13:20:15.250]             }
[13:20:15.250]             base::options(...future.oldOptions)
[13:20:15.250]             if (.Platform$OS.type == "windows") {
[13:20:15.250]                 old_names <- names(...future.oldEnvVars)
[13:20:15.250]                 envs <- base::Sys.getenv()
[13:20:15.250]                 names <- names(envs)
[13:20:15.250]                 common <- intersect(names, old_names)
[13:20:15.250]                 added <- setdiff(names, old_names)
[13:20:15.250]                 removed <- setdiff(old_names, names)
[13:20:15.250]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:15.250]                   envs[common]]
[13:20:15.250]                 NAMES <- toupper(changed)
[13:20:15.250]                 args <- list()
[13:20:15.250]                 for (kk in seq_along(NAMES)) {
[13:20:15.250]                   name <- changed[[kk]]
[13:20:15.250]                   NAME <- NAMES[[kk]]
[13:20:15.250]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.250]                     next
[13:20:15.250]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.250]                 }
[13:20:15.250]                 NAMES <- toupper(added)
[13:20:15.250]                 for (kk in seq_along(NAMES)) {
[13:20:15.250]                   name <- added[[kk]]
[13:20:15.250]                   NAME <- NAMES[[kk]]
[13:20:15.250]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.250]                     next
[13:20:15.250]                   args[[name]] <- ""
[13:20:15.250]                 }
[13:20:15.250]                 NAMES <- toupper(removed)
[13:20:15.250]                 for (kk in seq_along(NAMES)) {
[13:20:15.250]                   name <- removed[[kk]]
[13:20:15.250]                   NAME <- NAMES[[kk]]
[13:20:15.250]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.250]                     next
[13:20:15.250]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.250]                 }
[13:20:15.250]                 if (length(args) > 0) 
[13:20:15.250]                   base::do.call(base::Sys.setenv, args = args)
[13:20:15.250]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:15.250]             }
[13:20:15.250]             else {
[13:20:15.250]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:15.250]             }
[13:20:15.250]             {
[13:20:15.250]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:15.250]                   0L) {
[13:20:15.250]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:15.250]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:15.250]                   base::options(opts)
[13:20:15.250]                 }
[13:20:15.250]                 {
[13:20:15.250]                   {
[13:20:15.250]                     NULL
[13:20:15.250]                     RNGkind("Mersenne-Twister")
[13:20:15.250]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:15.250]                       inherits = FALSE)
[13:20:15.250]                   }
[13:20:15.250]                   options(future.plan = NULL)
[13:20:15.250]                   if (is.na(NA_character_)) 
[13:20:15.250]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.250]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:15.250]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:15.250]                   {
[13:20:15.250]                     future <- SequentialFuture(..., envir = envir)
[13:20:15.250]                     if (!future$lazy) 
[13:20:15.250]                       future <- run(future)
[13:20:15.250]                     invisible(future)
[13:20:15.250]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:15.250]                 }
[13:20:15.250]             }
[13:20:15.250]         }
[13:20:15.250]     })
[13:20:15.250]     if (TRUE) {
[13:20:15.250]         base::sink(type = "output", split = FALSE)
[13:20:15.250]         if (TRUE) {
[13:20:15.250]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:15.250]         }
[13:20:15.250]         else {
[13:20:15.250]             ...future.result["stdout"] <- base::list(NULL)
[13:20:15.250]         }
[13:20:15.250]         base::close(...future.stdout)
[13:20:15.250]         ...future.stdout <- NULL
[13:20:15.250]     }
[13:20:15.250]     ...future.result$conditions <- ...future.conditions
[13:20:15.250]     ...future.result$finished <- base::Sys.time()
[13:20:15.250]     ...future.result
[13:20:15.250] }
[13:20:15.252] assign_globals() ...
[13:20:15.252] List of 1
[13:20:15.252]  $ ii: int 3
[13:20:15.252]  - attr(*, "where")=List of 1
[13:20:15.252]   ..$ ii:<environment: R_EmptyEnv> 
[13:20:15.252]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:15.252]  - attr(*, "resolved")= logi FALSE
[13:20:15.252]  - attr(*, "total_size")= num 56
[13:20:15.252]  - attr(*, "already-done")= logi TRUE
[13:20:15.254] - copied ‘ii’ to environment
[13:20:15.254] assign_globals() ... done
[13:20:15.254] plan(): Setting new future strategy stack:
[13:20:15.255] List of future strategies:
[13:20:15.255] 1. sequential:
[13:20:15.255]    - args: function (..., envir = parent.frame())
[13:20:15.255]    - tweaked: FALSE
[13:20:15.255]    - call: NULL
[13:20:15.255] plan(): nbrOfWorkers() = 1
[13:20:15.256] plan(): Setting new future strategy stack:
[13:20:15.256] List of future strategies:
[13:20:15.256] 1. sequential:
[13:20:15.256]    - args: function (..., envir = parent.frame())
[13:20:15.256]    - tweaked: FALSE
[13:20:15.256]    - call: plan(strategy)
[13:20:15.256] plan(): nbrOfWorkers() = 1
[13:20:15.256] SequentialFuture started (and completed)
[13:20:15.256] - Launch lazy future ... done
[13:20:15.256] run() for ‘SequentialFuture’ ... done
[13:20:15.257] signalConditions() ...
[13:20:15.257]  - include = ‘immediateCondition’
[13:20:15.257]  - exclude = 
[13:20:15.257]  - resignal = FALSE
[13:20:15.257]  - Number of conditions: 1
[13:20:15.257] signalConditions() ... done
[13:20:15.257] Future state: ‘finished’
[13:20:15.257] signalConditions() ...
[13:20:15.258]  - include = ‘condition’
[13:20:15.258]  - exclude = ‘immediateCondition’
[13:20:15.258]  - resignal = TRUE
[13:20:15.258]  - Number of conditions: 1
[13:20:15.258]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:20:15.258] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[13:20:15.259] signalConditions() ...
[13:20:15.259]  - include = ‘immediateCondition’
[13:20:15.259]  - exclude = 
[13:20:15.259]  - resignal = FALSE
[13:20:15.259]  - Number of conditions: 1
[13:20:15.260] signalConditions() ... done
[13:20:15.260] Future state: ‘finished’
[13:20:15.260] signalConditions() ...
[13:20:15.260]  - include = ‘condition’
[13:20:15.260]  - exclude = ‘immediateCondition’
[13:20:15.260]  - resignal = TRUE
[13:20:15.260]  - Number of conditions: 1
[13:20:15.260]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:20:15.260] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[13:20:15.261] signalConditions() ...
[13:20:15.261]  - include = ‘immediateCondition’
[13:20:15.261]  - exclude = 
[13:20:15.261]  - resignal = FALSE
[13:20:15.261]  - Number of conditions: 1
[13:20:15.261] signalConditions() ... done
[13:20:15.261] Future state: ‘finished’
[13:20:15.261] signalConditions() ...
[13:20:15.261]  - include = ‘condition’
[13:20:15.262]  - exclude = ‘immediateCondition’
[13:20:15.262]  - resignal = TRUE
[13:20:15.262]  - Number of conditions: 1
[13:20:15.262]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:20:15.262] signalConditions() ... done
** Future evaluation with a poor-man's "progress bar"
[13:20:15.262] getGlobalsAndPackages() ...
[13:20:15.262] Searching for globals...
[13:20:15.264] - globals found: [4] ‘{’, ‘cat’, ‘for’, ‘:’
[13:20:15.264] Searching for globals ... DONE
[13:20:15.264] Resolving globals: FALSE
[13:20:15.265] 
[13:20:15.265] 
[13:20:15.265] getGlobalsAndPackages() ... DONE
[13:20:15.265] run() for ‘Future’ ...
[13:20:15.265] - state: ‘created’
[13:20:15.265] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:15.266] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:15.266] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:15.266]   - Field: ‘label’
[13:20:15.266]   - Field: ‘local’
[13:20:15.266]   - Field: ‘owner’
[13:20:15.266]   - Field: ‘envir’
[13:20:15.266]   - Field: ‘packages’
[13:20:15.266]   - Field: ‘gc’
[13:20:15.266]   - Field: ‘conditions’
[13:20:15.266]   - Field: ‘expr’
[13:20:15.267]   - Field: ‘uuid’
[13:20:15.267]   - Field: ‘seed’
[13:20:15.267]   - Field: ‘version’
[13:20:15.267]   - Field: ‘result’
[13:20:15.267]   - Field: ‘asynchronous’
[13:20:15.267]   - Field: ‘calls’
[13:20:15.267]   - Field: ‘globals’
[13:20:15.267]   - Field: ‘stdout’
[13:20:15.267]   - Field: ‘earlySignal’
[13:20:15.267]   - Field: ‘lazy’
[13:20:15.267]   - Field: ‘state’
[13:20:15.267] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:15.268] - Launch lazy future ...
[13:20:15.268] Packages needed by the future expression (n = 0): <none>
[13:20:15.268] Packages needed by future strategies (n = 0): <none>
[13:20:15.268] {
[13:20:15.268]     {
[13:20:15.268]         {
[13:20:15.268]             ...future.startTime <- base::Sys.time()
[13:20:15.268]             {
[13:20:15.268]                 {
[13:20:15.268]                   {
[13:20:15.268]                     base::local({
[13:20:15.268]                       has_future <- base::requireNamespace("future", 
[13:20:15.268]                         quietly = TRUE)
[13:20:15.268]                       if (has_future) {
[13:20:15.268]                         ns <- base::getNamespace("future")
[13:20:15.268]                         version <- ns[[".package"]][["version"]]
[13:20:15.268]                         if (is.null(version)) 
[13:20:15.268]                           version <- utils::packageVersion("future")
[13:20:15.268]                       }
[13:20:15.268]                       else {
[13:20:15.268]                         version <- NULL
[13:20:15.268]                       }
[13:20:15.268]                       if (!has_future || version < "1.8.0") {
[13:20:15.268]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:15.268]                           "", base::R.version$version.string), 
[13:20:15.268]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:15.268]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:15.268]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:15.268]                             "release", "version")], collapse = " "), 
[13:20:15.268]                           hostname = base::Sys.info()[["nodename"]])
[13:20:15.268]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:15.268]                           info)
[13:20:15.268]                         info <- base::paste(info, collapse = "; ")
[13:20:15.268]                         if (!has_future) {
[13:20:15.268]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:15.268]                             info)
[13:20:15.268]                         }
[13:20:15.268]                         else {
[13:20:15.268]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:15.268]                             info, version)
[13:20:15.268]                         }
[13:20:15.268]                         base::stop(msg)
[13:20:15.268]                       }
[13:20:15.268]                     })
[13:20:15.268]                   }
[13:20:15.268]                   options(future.plan = NULL)
[13:20:15.268]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.268]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:15.268]                 }
[13:20:15.268]                 ...future.workdir <- getwd()
[13:20:15.268]             }
[13:20:15.268]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:15.268]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:15.268]         }
[13:20:15.268]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:15.268]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:15.268]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:15.268]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:15.268]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:15.268]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:15.268]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:15.268]             base::names(...future.oldOptions))
[13:20:15.268]     }
[13:20:15.268]     if (FALSE) {
[13:20:15.268]     }
[13:20:15.268]     else {
[13:20:15.268]         if (TRUE) {
[13:20:15.268]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:15.268]                 open = "w")
[13:20:15.268]         }
[13:20:15.268]         else {
[13:20:15.268]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:15.268]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:15.268]         }
[13:20:15.268]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:15.268]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:15.268]             base::sink(type = "output", split = FALSE)
[13:20:15.268]             base::close(...future.stdout)
[13:20:15.268]         }, add = TRUE)
[13:20:15.268]     }
[13:20:15.268]     ...future.frame <- base::sys.nframe()
[13:20:15.268]     ...future.conditions <- base::list()
[13:20:15.268]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:15.268]     if (FALSE) {
[13:20:15.268]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:15.268]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:15.268]     }
[13:20:15.268]     ...future.result <- base::tryCatch({
[13:20:15.268]         base::withCallingHandlers({
[13:20:15.268]             ...future.value <- base::withVisible(base::local({
[13:20:15.268]                 cat("Processing: ")
[13:20:15.268]                 for (ii in 1:10) {
[13:20:15.268]                   cat(".")
[13:20:15.268]                 }
[13:20:15.268]                 cat(" [100%]\n")
[13:20:15.268]                 4
[13:20:15.268]             }))
[13:20:15.268]             future::FutureResult(value = ...future.value$value, 
[13:20:15.268]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.268]                   ...future.rng), globalenv = if (FALSE) 
[13:20:15.268]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:15.268]                     ...future.globalenv.names))
[13:20:15.268]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:15.268]         }, condition = base::local({
[13:20:15.268]             c <- base::c
[13:20:15.268]             inherits <- base::inherits
[13:20:15.268]             invokeRestart <- base::invokeRestart
[13:20:15.268]             length <- base::length
[13:20:15.268]             list <- base::list
[13:20:15.268]             seq.int <- base::seq.int
[13:20:15.268]             signalCondition <- base::signalCondition
[13:20:15.268]             sys.calls <- base::sys.calls
[13:20:15.268]             `[[` <- base::`[[`
[13:20:15.268]             `+` <- base::`+`
[13:20:15.268]             `<<-` <- base::`<<-`
[13:20:15.268]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:15.268]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:15.268]                   3L)]
[13:20:15.268]             }
[13:20:15.268]             function(cond) {
[13:20:15.268]                 is_error <- inherits(cond, "error")
[13:20:15.268]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:15.268]                   NULL)
[13:20:15.268]                 if (is_error) {
[13:20:15.268]                   sessionInformation <- function() {
[13:20:15.268]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:15.268]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:15.268]                       search = base::search(), system = base::Sys.info())
[13:20:15.268]                   }
[13:20:15.268]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.268]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:15.268]                     cond$call), session = sessionInformation(), 
[13:20:15.268]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:15.268]                   signalCondition(cond)
[13:20:15.268]                 }
[13:20:15.268]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:15.268]                 "immediateCondition"))) {
[13:20:15.268]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:15.268]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.268]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:15.268]                   if (TRUE && !signal) {
[13:20:15.268]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.268]                     {
[13:20:15.268]                       inherits <- base::inherits
[13:20:15.268]                       invokeRestart <- base::invokeRestart
[13:20:15.268]                       is.null <- base::is.null
[13:20:15.268]                       muffled <- FALSE
[13:20:15.268]                       if (inherits(cond, "message")) {
[13:20:15.268]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.268]                         if (muffled) 
[13:20:15.268]                           invokeRestart("muffleMessage")
[13:20:15.268]                       }
[13:20:15.268]                       else if (inherits(cond, "warning")) {
[13:20:15.268]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.268]                         if (muffled) 
[13:20:15.268]                           invokeRestart("muffleWarning")
[13:20:15.268]                       }
[13:20:15.268]                       else if (inherits(cond, "condition")) {
[13:20:15.268]                         if (!is.null(pattern)) {
[13:20:15.268]                           computeRestarts <- base::computeRestarts
[13:20:15.268]                           grepl <- base::grepl
[13:20:15.268]                           restarts <- computeRestarts(cond)
[13:20:15.268]                           for (restart in restarts) {
[13:20:15.268]                             name <- restart$name
[13:20:15.268]                             if (is.null(name)) 
[13:20:15.268]                               next
[13:20:15.268]                             if (!grepl(pattern, name)) 
[13:20:15.268]                               next
[13:20:15.268]                             invokeRestart(restart)
[13:20:15.268]                             muffled <- TRUE
[13:20:15.268]                             break
[13:20:15.268]                           }
[13:20:15.268]                         }
[13:20:15.268]                       }
[13:20:15.268]                       invisible(muffled)
[13:20:15.268]                     }
[13:20:15.268]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.268]                   }
[13:20:15.268]                 }
[13:20:15.268]                 else {
[13:20:15.268]                   if (TRUE) {
[13:20:15.268]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.268]                     {
[13:20:15.268]                       inherits <- base::inherits
[13:20:15.268]                       invokeRestart <- base::invokeRestart
[13:20:15.268]                       is.null <- base::is.null
[13:20:15.268]                       muffled <- FALSE
[13:20:15.268]                       if (inherits(cond, "message")) {
[13:20:15.268]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.268]                         if (muffled) 
[13:20:15.268]                           invokeRestart("muffleMessage")
[13:20:15.268]                       }
[13:20:15.268]                       else if (inherits(cond, "warning")) {
[13:20:15.268]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.268]                         if (muffled) 
[13:20:15.268]                           invokeRestart("muffleWarning")
[13:20:15.268]                       }
[13:20:15.268]                       else if (inherits(cond, "condition")) {
[13:20:15.268]                         if (!is.null(pattern)) {
[13:20:15.268]                           computeRestarts <- base::computeRestarts
[13:20:15.268]                           grepl <- base::grepl
[13:20:15.268]                           restarts <- computeRestarts(cond)
[13:20:15.268]                           for (restart in restarts) {
[13:20:15.268]                             name <- restart$name
[13:20:15.268]                             if (is.null(name)) 
[13:20:15.268]                               next
[13:20:15.268]                             if (!grepl(pattern, name)) 
[13:20:15.268]                               next
[13:20:15.268]                             invokeRestart(restart)
[13:20:15.268]                             muffled <- TRUE
[13:20:15.268]                             break
[13:20:15.268]                           }
[13:20:15.268]                         }
[13:20:15.268]                       }
[13:20:15.268]                       invisible(muffled)
[13:20:15.268]                     }
[13:20:15.268]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.268]                   }
[13:20:15.268]                 }
[13:20:15.268]             }
[13:20:15.268]         }))
[13:20:15.268]     }, error = function(ex) {
[13:20:15.268]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:15.268]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.268]                 ...future.rng), started = ...future.startTime, 
[13:20:15.268]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:15.268]             version = "1.8"), class = "FutureResult")
[13:20:15.268]     }, finally = {
[13:20:15.268]         if (!identical(...future.workdir, getwd())) 
[13:20:15.268]             setwd(...future.workdir)
[13:20:15.268]         {
[13:20:15.268]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:15.268]                 ...future.oldOptions$nwarnings <- NULL
[13:20:15.268]             }
[13:20:15.268]             base::options(...future.oldOptions)
[13:20:15.268]             if (.Platform$OS.type == "windows") {
[13:20:15.268]                 old_names <- names(...future.oldEnvVars)
[13:20:15.268]                 envs <- base::Sys.getenv()
[13:20:15.268]                 names <- names(envs)
[13:20:15.268]                 common <- intersect(names, old_names)
[13:20:15.268]                 added <- setdiff(names, old_names)
[13:20:15.268]                 removed <- setdiff(old_names, names)
[13:20:15.268]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:15.268]                   envs[common]]
[13:20:15.268]                 NAMES <- toupper(changed)
[13:20:15.268]                 args <- list()
[13:20:15.268]                 for (kk in seq_along(NAMES)) {
[13:20:15.268]                   name <- changed[[kk]]
[13:20:15.268]                   NAME <- NAMES[[kk]]
[13:20:15.268]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.268]                     next
[13:20:15.268]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.268]                 }
[13:20:15.268]                 NAMES <- toupper(added)
[13:20:15.268]                 for (kk in seq_along(NAMES)) {
[13:20:15.268]                   name <- added[[kk]]
[13:20:15.268]                   NAME <- NAMES[[kk]]
[13:20:15.268]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.268]                     next
[13:20:15.268]                   args[[name]] <- ""
[13:20:15.268]                 }
[13:20:15.268]                 NAMES <- toupper(removed)
[13:20:15.268]                 for (kk in seq_along(NAMES)) {
[13:20:15.268]                   name <- removed[[kk]]
[13:20:15.268]                   NAME <- NAMES[[kk]]
[13:20:15.268]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.268]                     next
[13:20:15.268]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.268]                 }
[13:20:15.268]                 if (length(args) > 0) 
[13:20:15.268]                   base::do.call(base::Sys.setenv, args = args)
[13:20:15.268]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:15.268]             }
[13:20:15.268]             else {
[13:20:15.268]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:15.268]             }
[13:20:15.268]             {
[13:20:15.268]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:15.268]                   0L) {
[13:20:15.268]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:15.268]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:15.268]                   base::options(opts)
[13:20:15.268]                 }
[13:20:15.268]                 {
[13:20:15.268]                   {
[13:20:15.268]                     NULL
[13:20:15.268]                     RNGkind("Mersenne-Twister")
[13:20:15.268]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:15.268]                       inherits = FALSE)
[13:20:15.268]                   }
[13:20:15.268]                   options(future.plan = NULL)
[13:20:15.268]                   if (is.na(NA_character_)) 
[13:20:15.268]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.268]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:15.268]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:15.268]                   {
[13:20:15.268]                     future <- SequentialFuture(..., envir = envir)
[13:20:15.268]                     if (!future$lazy) 
[13:20:15.268]                       future <- run(future)
[13:20:15.268]                     invisible(future)
[13:20:15.268]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:15.268]                 }
[13:20:15.268]             }
[13:20:15.268]         }
[13:20:15.268]     })
[13:20:15.268]     if (TRUE) {
[13:20:15.268]         base::sink(type = "output", split = FALSE)
[13:20:15.268]         if (TRUE) {
[13:20:15.268]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:15.268]         }
[13:20:15.268]         else {
[13:20:15.268]             ...future.result["stdout"] <- base::list(NULL)
[13:20:15.268]         }
[13:20:15.268]         base::close(...future.stdout)
[13:20:15.268]         ...future.stdout <- NULL
[13:20:15.268]     }
[13:20:15.268]     ...future.result$conditions <- ...future.conditions
[13:20:15.268]     ...future.result$finished <- base::Sys.time()
[13:20:15.268]     ...future.result
[13:20:15.268] }
[13:20:15.270] plan(): Setting new future strategy stack:
[13:20:15.270] List of future strategies:
[13:20:15.270] 1. sequential:
[13:20:15.270]    - args: function (..., envir = parent.frame())
[13:20:15.270]    - tweaked: FALSE
[13:20:15.270]    - call: NULL
[13:20:15.270] plan(): nbrOfWorkers() = 1
[13:20:15.273] plan(): Setting new future strategy stack:
[13:20:15.273] List of future strategies:
[13:20:15.273] 1. sequential:
[13:20:15.273]    - args: function (..., envir = parent.frame())
[13:20:15.273]    - tweaked: FALSE
[13:20:15.273]    - call: plan(strategy)
[13:20:15.273] plan(): nbrOfWorkers() = 1
[13:20:15.274] SequentialFuture started (and completed)
[13:20:15.274] - Launch lazy future ... done
[13:20:15.274] run() for ‘SequentialFuture’ ... done
** Collecting results
v1 = 1
v2 = 2
Warning in sprintf(...) : restarting interrupted promise evaluation
[13:20:15.275] signalConditions() ...
[13:20:15.275]  - include = ‘immediateCondition’
[13:20:15.275]  - exclude = 
[13:20:15.275]  - resignal = FALSE
[13:20:15.275]  - Number of conditions: 1
[13:20:15.276] signalConditions() ... done
[13:20:15.276] Future state: ‘finished’
[13:20:15.276] signalConditions() ...
[13:20:15.276]  - include = ‘condition’
[13:20:15.276]  - exclude = ‘immediateCondition’
[13:20:15.276]  - resignal = TRUE
[13:20:15.276]  - Number of conditions: 1
[13:20:15.276]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:20:15.276] signalConditions() ... done
v3: <simpleError> (as expect)
Processing: .......... [100%]
v4 = 4
** Left-to-right and right-to-left future assignments
[13:20:15.277] getGlobalsAndPackages() ...
[13:20:15.277] Searching for globals...
[13:20:15.277] 
[13:20:15.277] Searching for globals ... DONE
[13:20:15.277] - globals: [0] <none>
[13:20:15.278] getGlobalsAndPackages() ... DONE
[13:20:15.278] run() for ‘Future’ ...
[13:20:15.278] - state: ‘created’
[13:20:15.278] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:15.278] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:15.278] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:15.278]   - Field: ‘label’
[13:20:15.279]   - Field: ‘local’
[13:20:15.279]   - Field: ‘owner’
[13:20:15.279]   - Field: ‘envir’
[13:20:15.279]   - Field: ‘packages’
[13:20:15.279]   - Field: ‘gc’
[13:20:15.279]   - Field: ‘conditions’
[13:20:15.279]   - Field: ‘expr’
[13:20:15.279]   - Field: ‘uuid’
[13:20:15.279]   - Field: ‘seed’
[13:20:15.279]   - Field: ‘version’
[13:20:15.279]   - Field: ‘result’
[13:20:15.280]   - Field: ‘asynchronous’
[13:20:15.280]   - Field: ‘calls’
[13:20:15.280]   - Field: ‘globals’
[13:20:15.280]   - Field: ‘stdout’
[13:20:15.280]   - Field: ‘earlySignal’
[13:20:15.280]   - Field: ‘lazy’
[13:20:15.280]   - Field: ‘state’
[13:20:15.280] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:15.280] - Launch lazy future ...
[13:20:15.280] Packages needed by the future expression (n = 0): <none>
[13:20:15.281] Packages needed by future strategies (n = 0): <none>
[13:20:15.281] {
[13:20:15.281]     {
[13:20:15.281]         {
[13:20:15.281]             ...future.startTime <- base::Sys.time()
[13:20:15.281]             {
[13:20:15.281]                 {
[13:20:15.281]                   {
[13:20:15.281]                     base::local({
[13:20:15.281]                       has_future <- base::requireNamespace("future", 
[13:20:15.281]                         quietly = TRUE)
[13:20:15.281]                       if (has_future) {
[13:20:15.281]                         ns <- base::getNamespace("future")
[13:20:15.281]                         version <- ns[[".package"]][["version"]]
[13:20:15.281]                         if (is.null(version)) 
[13:20:15.281]                           version <- utils::packageVersion("future")
[13:20:15.281]                       }
[13:20:15.281]                       else {
[13:20:15.281]                         version <- NULL
[13:20:15.281]                       }
[13:20:15.281]                       if (!has_future || version < "1.8.0") {
[13:20:15.281]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:15.281]                           "", base::R.version$version.string), 
[13:20:15.281]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:15.281]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:15.281]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:15.281]                             "release", "version")], collapse = " "), 
[13:20:15.281]                           hostname = base::Sys.info()[["nodename"]])
[13:20:15.281]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:15.281]                           info)
[13:20:15.281]                         info <- base::paste(info, collapse = "; ")
[13:20:15.281]                         if (!has_future) {
[13:20:15.281]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:15.281]                             info)
[13:20:15.281]                         }
[13:20:15.281]                         else {
[13:20:15.281]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:15.281]                             info, version)
[13:20:15.281]                         }
[13:20:15.281]                         base::stop(msg)
[13:20:15.281]                       }
[13:20:15.281]                     })
[13:20:15.281]                   }
[13:20:15.281]                   options(future.plan = NULL)
[13:20:15.281]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.281]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:15.281]                 }
[13:20:15.281]                 ...future.workdir <- getwd()
[13:20:15.281]             }
[13:20:15.281]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:15.281]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:15.281]         }
[13:20:15.281]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:15.281]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:15.281]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:15.281]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:15.281]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:15.281]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:15.281]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:15.281]             base::names(...future.oldOptions))
[13:20:15.281]     }
[13:20:15.281]     if (FALSE) {
[13:20:15.281]     }
[13:20:15.281]     else {
[13:20:15.281]         if (TRUE) {
[13:20:15.281]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:15.281]                 open = "w")
[13:20:15.281]         }
[13:20:15.281]         else {
[13:20:15.281]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:15.281]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:15.281]         }
[13:20:15.281]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:15.281]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:15.281]             base::sink(type = "output", split = FALSE)
[13:20:15.281]             base::close(...future.stdout)
[13:20:15.281]         }, add = TRUE)
[13:20:15.281]     }
[13:20:15.281]     ...future.frame <- base::sys.nframe()
[13:20:15.281]     ...future.conditions <- base::list()
[13:20:15.281]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:15.281]     if (FALSE) {
[13:20:15.281]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:15.281]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:15.281]     }
[13:20:15.281]     ...future.result <- base::tryCatch({
[13:20:15.281]         base::withCallingHandlers({
[13:20:15.281]             ...future.value <- base::withVisible(base::local(1))
[13:20:15.281]             future::FutureResult(value = ...future.value$value, 
[13:20:15.281]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.281]                   ...future.rng), globalenv = if (FALSE) 
[13:20:15.281]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:15.281]                     ...future.globalenv.names))
[13:20:15.281]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:15.281]         }, condition = base::local({
[13:20:15.281]             c <- base::c
[13:20:15.281]             inherits <- base::inherits
[13:20:15.281]             invokeRestart <- base::invokeRestart
[13:20:15.281]             length <- base::length
[13:20:15.281]             list <- base::list
[13:20:15.281]             seq.int <- base::seq.int
[13:20:15.281]             signalCondition <- base::signalCondition
[13:20:15.281]             sys.calls <- base::sys.calls
[13:20:15.281]             `[[` <- base::`[[`
[13:20:15.281]             `+` <- base::`+`
[13:20:15.281]             `<<-` <- base::`<<-`
[13:20:15.281]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:15.281]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:15.281]                   3L)]
[13:20:15.281]             }
[13:20:15.281]             function(cond) {
[13:20:15.281]                 is_error <- inherits(cond, "error")
[13:20:15.281]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:15.281]                   NULL)
[13:20:15.281]                 if (is_error) {
[13:20:15.281]                   sessionInformation <- function() {
[13:20:15.281]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:15.281]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:15.281]                       search = base::search(), system = base::Sys.info())
[13:20:15.281]                   }
[13:20:15.281]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.281]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:15.281]                     cond$call), session = sessionInformation(), 
[13:20:15.281]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:15.281]                   signalCondition(cond)
[13:20:15.281]                 }
[13:20:15.281]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:15.281]                 "immediateCondition"))) {
[13:20:15.281]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:15.281]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.281]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:15.281]                   if (TRUE && !signal) {
[13:20:15.281]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.281]                     {
[13:20:15.281]                       inherits <- base::inherits
[13:20:15.281]                       invokeRestart <- base::invokeRestart
[13:20:15.281]                       is.null <- base::is.null
[13:20:15.281]                       muffled <- FALSE
[13:20:15.281]                       if (inherits(cond, "message")) {
[13:20:15.281]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.281]                         if (muffled) 
[13:20:15.281]                           invokeRestart("muffleMessage")
[13:20:15.281]                       }
[13:20:15.281]                       else if (inherits(cond, "warning")) {
[13:20:15.281]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.281]                         if (muffled) 
[13:20:15.281]                           invokeRestart("muffleWarning")
[13:20:15.281]                       }
[13:20:15.281]                       else if (inherits(cond, "condition")) {
[13:20:15.281]                         if (!is.null(pattern)) {
[13:20:15.281]                           computeRestarts <- base::computeRestarts
[13:20:15.281]                           grepl <- base::grepl
[13:20:15.281]                           restarts <- computeRestarts(cond)
[13:20:15.281]                           for (restart in restarts) {
[13:20:15.281]                             name <- restart$name
[13:20:15.281]                             if (is.null(name)) 
[13:20:15.281]                               next
[13:20:15.281]                             if (!grepl(pattern, name)) 
[13:20:15.281]                               next
[13:20:15.281]                             invokeRestart(restart)
[13:20:15.281]                             muffled <- TRUE
[13:20:15.281]                             break
[13:20:15.281]                           }
[13:20:15.281]                         }
[13:20:15.281]                       }
[13:20:15.281]                       invisible(muffled)
[13:20:15.281]                     }
[13:20:15.281]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.281]                   }
[13:20:15.281]                 }
[13:20:15.281]                 else {
[13:20:15.281]                   if (TRUE) {
[13:20:15.281]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.281]                     {
[13:20:15.281]                       inherits <- base::inherits
[13:20:15.281]                       invokeRestart <- base::invokeRestart
[13:20:15.281]                       is.null <- base::is.null
[13:20:15.281]                       muffled <- FALSE
[13:20:15.281]                       if (inherits(cond, "message")) {
[13:20:15.281]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.281]                         if (muffled) 
[13:20:15.281]                           invokeRestart("muffleMessage")
[13:20:15.281]                       }
[13:20:15.281]                       else if (inherits(cond, "warning")) {
[13:20:15.281]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.281]                         if (muffled) 
[13:20:15.281]                           invokeRestart("muffleWarning")
[13:20:15.281]                       }
[13:20:15.281]                       else if (inherits(cond, "condition")) {
[13:20:15.281]                         if (!is.null(pattern)) {
[13:20:15.281]                           computeRestarts <- base::computeRestarts
[13:20:15.281]                           grepl <- base::grepl
[13:20:15.281]                           restarts <- computeRestarts(cond)
[13:20:15.281]                           for (restart in restarts) {
[13:20:15.281]                             name <- restart$name
[13:20:15.281]                             if (is.null(name)) 
[13:20:15.281]                               next
[13:20:15.281]                             if (!grepl(pattern, name)) 
[13:20:15.281]                               next
[13:20:15.281]                             invokeRestart(restart)
[13:20:15.281]                             muffled <- TRUE
[13:20:15.281]                             break
[13:20:15.281]                           }
[13:20:15.281]                         }
[13:20:15.281]                       }
[13:20:15.281]                       invisible(muffled)
[13:20:15.281]                     }
[13:20:15.281]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.281]                   }
[13:20:15.281]                 }
[13:20:15.281]             }
[13:20:15.281]         }))
[13:20:15.281]     }, error = function(ex) {
[13:20:15.281]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:15.281]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.281]                 ...future.rng), started = ...future.startTime, 
[13:20:15.281]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:15.281]             version = "1.8"), class = "FutureResult")
[13:20:15.281]     }, finally = {
[13:20:15.281]         if (!identical(...future.workdir, getwd())) 
[13:20:15.281]             setwd(...future.workdir)
[13:20:15.281]         {
[13:20:15.281]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:15.281]                 ...future.oldOptions$nwarnings <- NULL
[13:20:15.281]             }
[13:20:15.281]             base::options(...future.oldOptions)
[13:20:15.281]             if (.Platform$OS.type == "windows") {
[13:20:15.281]                 old_names <- names(...future.oldEnvVars)
[13:20:15.281]                 envs <- base::Sys.getenv()
[13:20:15.281]                 names <- names(envs)
[13:20:15.281]                 common <- intersect(names, old_names)
[13:20:15.281]                 added <- setdiff(names, old_names)
[13:20:15.281]                 removed <- setdiff(old_names, names)
[13:20:15.281]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:15.281]                   envs[common]]
[13:20:15.281]                 NAMES <- toupper(changed)
[13:20:15.281]                 args <- list()
[13:20:15.281]                 for (kk in seq_along(NAMES)) {
[13:20:15.281]                   name <- changed[[kk]]
[13:20:15.281]                   NAME <- NAMES[[kk]]
[13:20:15.281]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.281]                     next
[13:20:15.281]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.281]                 }
[13:20:15.281]                 NAMES <- toupper(added)
[13:20:15.281]                 for (kk in seq_along(NAMES)) {
[13:20:15.281]                   name <- added[[kk]]
[13:20:15.281]                   NAME <- NAMES[[kk]]
[13:20:15.281]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.281]                     next
[13:20:15.281]                   args[[name]] <- ""
[13:20:15.281]                 }
[13:20:15.281]                 NAMES <- toupper(removed)
[13:20:15.281]                 for (kk in seq_along(NAMES)) {
[13:20:15.281]                   name <- removed[[kk]]
[13:20:15.281]                   NAME <- NAMES[[kk]]
[13:20:15.281]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.281]                     next
[13:20:15.281]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.281]                 }
[13:20:15.281]                 if (length(args) > 0) 
[13:20:15.281]                   base::do.call(base::Sys.setenv, args = args)
[13:20:15.281]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:15.281]             }
[13:20:15.281]             else {
[13:20:15.281]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:15.281]             }
[13:20:15.281]             {
[13:20:15.281]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:15.281]                   0L) {
[13:20:15.281]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:15.281]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:15.281]                   base::options(opts)
[13:20:15.281]                 }
[13:20:15.281]                 {
[13:20:15.281]                   {
[13:20:15.281]                     NULL
[13:20:15.281]                     RNGkind("Mersenne-Twister")
[13:20:15.281]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:15.281]                       inherits = FALSE)
[13:20:15.281]                   }
[13:20:15.281]                   options(future.plan = NULL)
[13:20:15.281]                   if (is.na(NA_character_)) 
[13:20:15.281]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.281]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:15.281]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:15.281]                   {
[13:20:15.281]                     future <- SequentialFuture(..., envir = envir)
[13:20:15.281]                     if (!future$lazy) 
[13:20:15.281]                       future <- run(future)
[13:20:15.281]                     invisible(future)
[13:20:15.281]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:15.281]                 }
[13:20:15.281]             }
[13:20:15.281]         }
[13:20:15.281]     })
[13:20:15.281]     if (TRUE) {
[13:20:15.281]         base::sink(type = "output", split = FALSE)
[13:20:15.281]         if (TRUE) {
[13:20:15.281]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:15.281]         }
[13:20:15.281]         else {
[13:20:15.281]             ...future.result["stdout"] <- base::list(NULL)
[13:20:15.281]         }
[13:20:15.281]         base::close(...future.stdout)
[13:20:15.281]         ...future.stdout <- NULL
[13:20:15.281]     }
[13:20:15.281]     ...future.result$conditions <- ...future.conditions
[13:20:15.281]     ...future.result$finished <- base::Sys.time()
[13:20:15.281]     ...future.result
[13:20:15.281] }
[13:20:15.283] plan(): Setting new future strategy stack:
[13:20:15.283] List of future strategies:
[13:20:15.283] 1. sequential:
[13:20:15.283]    - args: function (..., envir = parent.frame())
[13:20:15.283]    - tweaked: FALSE
[13:20:15.283]    - call: NULL
[13:20:15.283] plan(): nbrOfWorkers() = 1
[13:20:15.284] plan(): Setting new future strategy stack:
[13:20:15.284] List of future strategies:
[13:20:15.284] 1. sequential:
[13:20:15.284]    - args: function (..., envir = parent.frame())
[13:20:15.284]    - tweaked: FALSE
[13:20:15.284]    - call: plan(strategy)
[13:20:15.284] plan(): nbrOfWorkers() = 1
[13:20:15.284] SequentialFuture started (and completed)
[13:20:15.285] - Launch lazy future ... done
[13:20:15.285] run() for ‘SequentialFuture’ ... done
c = 1
[13:20:15.285] getGlobalsAndPackages() ...
[13:20:15.285] Searching for globals...
[13:20:15.285] 
[13:20:15.286] Searching for globals ... DONE
[13:20:15.286] - globals: [0] <none>
[13:20:15.286] getGlobalsAndPackages() ... DONE
[13:20:15.286] run() for ‘Future’ ...
[13:20:15.286] - state: ‘created’
[13:20:15.286] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:15.286] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:15.286] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:15.287]   - Field: ‘label’
[13:20:15.287]   - Field: ‘local’
[13:20:15.287]   - Field: ‘owner’
[13:20:15.287]   - Field: ‘envir’
[13:20:15.287]   - Field: ‘packages’
[13:20:15.287]   - Field: ‘gc’
[13:20:15.287]   - Field: ‘conditions’
[13:20:15.287]   - Field: ‘expr’
[13:20:15.287]   - Field: ‘uuid’
[13:20:15.287]   - Field: ‘seed’
[13:20:15.288]   - Field: ‘version’
[13:20:15.288]   - Field: ‘result’
[13:20:15.288]   - Field: ‘asynchronous’
[13:20:15.288]   - Field: ‘calls’
[13:20:15.288]   - Field: ‘globals’
[13:20:15.288]   - Field: ‘stdout’
[13:20:15.288]   - Field: ‘earlySignal’
[13:20:15.288]   - Field: ‘lazy’
[13:20:15.288]   - Field: ‘state’
[13:20:15.288] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:15.288] - Launch lazy future ...
[13:20:15.289] Packages needed by the future expression (n = 0): <none>
[13:20:15.289] Packages needed by future strategies (n = 0): <none>
[13:20:15.289] {
[13:20:15.289]     {
[13:20:15.289]         {
[13:20:15.289]             ...future.startTime <- base::Sys.time()
[13:20:15.289]             {
[13:20:15.289]                 {
[13:20:15.289]                   {
[13:20:15.289]                     base::local({
[13:20:15.289]                       has_future <- base::requireNamespace("future", 
[13:20:15.289]                         quietly = TRUE)
[13:20:15.289]                       if (has_future) {
[13:20:15.289]                         ns <- base::getNamespace("future")
[13:20:15.289]                         version <- ns[[".package"]][["version"]]
[13:20:15.289]                         if (is.null(version)) 
[13:20:15.289]                           version <- utils::packageVersion("future")
[13:20:15.289]                       }
[13:20:15.289]                       else {
[13:20:15.289]                         version <- NULL
[13:20:15.289]                       }
[13:20:15.289]                       if (!has_future || version < "1.8.0") {
[13:20:15.289]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:15.289]                           "", base::R.version$version.string), 
[13:20:15.289]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:15.289]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:15.289]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:15.289]                             "release", "version")], collapse = " "), 
[13:20:15.289]                           hostname = base::Sys.info()[["nodename"]])
[13:20:15.289]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:15.289]                           info)
[13:20:15.289]                         info <- base::paste(info, collapse = "; ")
[13:20:15.289]                         if (!has_future) {
[13:20:15.289]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:15.289]                             info)
[13:20:15.289]                         }
[13:20:15.289]                         else {
[13:20:15.289]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:15.289]                             info, version)
[13:20:15.289]                         }
[13:20:15.289]                         base::stop(msg)
[13:20:15.289]                       }
[13:20:15.289]                     })
[13:20:15.289]                   }
[13:20:15.289]                   options(future.plan = NULL)
[13:20:15.289]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.289]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:15.289]                 }
[13:20:15.289]                 ...future.workdir <- getwd()
[13:20:15.289]             }
[13:20:15.289]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:15.289]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:15.289]         }
[13:20:15.289]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:15.289]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:15.289]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:15.289]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:15.289]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:15.289]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:15.289]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:15.289]             base::names(...future.oldOptions))
[13:20:15.289]     }
[13:20:15.289]     if (FALSE) {
[13:20:15.289]     }
[13:20:15.289]     else {
[13:20:15.289]         if (TRUE) {
[13:20:15.289]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:15.289]                 open = "w")
[13:20:15.289]         }
[13:20:15.289]         else {
[13:20:15.289]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:15.289]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:15.289]         }
[13:20:15.289]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:15.289]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:15.289]             base::sink(type = "output", split = FALSE)
[13:20:15.289]             base::close(...future.stdout)
[13:20:15.289]         }, add = TRUE)
[13:20:15.289]     }
[13:20:15.289]     ...future.frame <- base::sys.nframe()
[13:20:15.289]     ...future.conditions <- base::list()
[13:20:15.289]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:15.289]     if (FALSE) {
[13:20:15.289]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:15.289]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:15.289]     }
[13:20:15.289]     ...future.result <- base::tryCatch({
[13:20:15.289]         base::withCallingHandlers({
[13:20:15.289]             ...future.value <- base::withVisible(base::local(1))
[13:20:15.289]             future::FutureResult(value = ...future.value$value, 
[13:20:15.289]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.289]                   ...future.rng), globalenv = if (FALSE) 
[13:20:15.289]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:15.289]                     ...future.globalenv.names))
[13:20:15.289]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:15.289]         }, condition = base::local({
[13:20:15.289]             c <- base::c
[13:20:15.289]             inherits <- base::inherits
[13:20:15.289]             invokeRestart <- base::invokeRestart
[13:20:15.289]             length <- base::length
[13:20:15.289]             list <- base::list
[13:20:15.289]             seq.int <- base::seq.int
[13:20:15.289]             signalCondition <- base::signalCondition
[13:20:15.289]             sys.calls <- base::sys.calls
[13:20:15.289]             `[[` <- base::`[[`
[13:20:15.289]             `+` <- base::`+`
[13:20:15.289]             `<<-` <- base::`<<-`
[13:20:15.289]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:15.289]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:15.289]                   3L)]
[13:20:15.289]             }
[13:20:15.289]             function(cond) {
[13:20:15.289]                 is_error <- inherits(cond, "error")
[13:20:15.289]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:15.289]                   NULL)
[13:20:15.289]                 if (is_error) {
[13:20:15.289]                   sessionInformation <- function() {
[13:20:15.289]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:15.289]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:15.289]                       search = base::search(), system = base::Sys.info())
[13:20:15.289]                   }
[13:20:15.289]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.289]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:15.289]                     cond$call), session = sessionInformation(), 
[13:20:15.289]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:15.289]                   signalCondition(cond)
[13:20:15.289]                 }
[13:20:15.289]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:15.289]                 "immediateCondition"))) {
[13:20:15.289]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:15.289]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.289]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:15.289]                   if (TRUE && !signal) {
[13:20:15.289]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.289]                     {
[13:20:15.289]                       inherits <- base::inherits
[13:20:15.289]                       invokeRestart <- base::invokeRestart
[13:20:15.289]                       is.null <- base::is.null
[13:20:15.289]                       muffled <- FALSE
[13:20:15.289]                       if (inherits(cond, "message")) {
[13:20:15.289]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.289]                         if (muffled) 
[13:20:15.289]                           invokeRestart("muffleMessage")
[13:20:15.289]                       }
[13:20:15.289]                       else if (inherits(cond, "warning")) {
[13:20:15.289]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.289]                         if (muffled) 
[13:20:15.289]                           invokeRestart("muffleWarning")
[13:20:15.289]                       }
[13:20:15.289]                       else if (inherits(cond, "condition")) {
[13:20:15.289]                         if (!is.null(pattern)) {
[13:20:15.289]                           computeRestarts <- base::computeRestarts
[13:20:15.289]                           grepl <- base::grepl
[13:20:15.289]                           restarts <- computeRestarts(cond)
[13:20:15.289]                           for (restart in restarts) {
[13:20:15.289]                             name <- restart$name
[13:20:15.289]                             if (is.null(name)) 
[13:20:15.289]                               next
[13:20:15.289]                             if (!grepl(pattern, name)) 
[13:20:15.289]                               next
[13:20:15.289]                             invokeRestart(restart)
[13:20:15.289]                             muffled <- TRUE
[13:20:15.289]                             break
[13:20:15.289]                           }
[13:20:15.289]                         }
[13:20:15.289]                       }
[13:20:15.289]                       invisible(muffled)
[13:20:15.289]                     }
[13:20:15.289]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.289]                   }
[13:20:15.289]                 }
[13:20:15.289]                 else {
[13:20:15.289]                   if (TRUE) {
[13:20:15.289]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.289]                     {
[13:20:15.289]                       inherits <- base::inherits
[13:20:15.289]                       invokeRestart <- base::invokeRestart
[13:20:15.289]                       is.null <- base::is.null
[13:20:15.289]                       muffled <- FALSE
[13:20:15.289]                       if (inherits(cond, "message")) {
[13:20:15.289]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.289]                         if (muffled) 
[13:20:15.289]                           invokeRestart("muffleMessage")
[13:20:15.289]                       }
[13:20:15.289]                       else if (inherits(cond, "warning")) {
[13:20:15.289]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.289]                         if (muffled) 
[13:20:15.289]                           invokeRestart("muffleWarning")
[13:20:15.289]                       }
[13:20:15.289]                       else if (inherits(cond, "condition")) {
[13:20:15.289]                         if (!is.null(pattern)) {
[13:20:15.289]                           computeRestarts <- base::computeRestarts
[13:20:15.289]                           grepl <- base::grepl
[13:20:15.289]                           restarts <- computeRestarts(cond)
[13:20:15.289]                           for (restart in restarts) {
[13:20:15.289]                             name <- restart$name
[13:20:15.289]                             if (is.null(name)) 
[13:20:15.289]                               next
[13:20:15.289]                             if (!grepl(pattern, name)) 
[13:20:15.289]                               next
[13:20:15.289]                             invokeRestart(restart)
[13:20:15.289]                             muffled <- TRUE
[13:20:15.289]                             break
[13:20:15.289]                           }
[13:20:15.289]                         }
[13:20:15.289]                       }
[13:20:15.289]                       invisible(muffled)
[13:20:15.289]                     }
[13:20:15.289]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.289]                   }
[13:20:15.289]                 }
[13:20:15.289]             }
[13:20:15.289]         }))
[13:20:15.289]     }, error = function(ex) {
[13:20:15.289]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:15.289]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.289]                 ...future.rng), started = ...future.startTime, 
[13:20:15.289]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:15.289]             version = "1.8"), class = "FutureResult")
[13:20:15.289]     }, finally = {
[13:20:15.289]         if (!identical(...future.workdir, getwd())) 
[13:20:15.289]             setwd(...future.workdir)
[13:20:15.289]         {
[13:20:15.289]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:15.289]                 ...future.oldOptions$nwarnings <- NULL
[13:20:15.289]             }
[13:20:15.289]             base::options(...future.oldOptions)
[13:20:15.289]             if (.Platform$OS.type == "windows") {
[13:20:15.289]                 old_names <- names(...future.oldEnvVars)
[13:20:15.289]                 envs <- base::Sys.getenv()
[13:20:15.289]                 names <- names(envs)
[13:20:15.289]                 common <- intersect(names, old_names)
[13:20:15.289]                 added <- setdiff(names, old_names)
[13:20:15.289]                 removed <- setdiff(old_names, names)
[13:20:15.289]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:15.289]                   envs[common]]
[13:20:15.289]                 NAMES <- toupper(changed)
[13:20:15.289]                 args <- list()
[13:20:15.289]                 for (kk in seq_along(NAMES)) {
[13:20:15.289]                   name <- changed[[kk]]
[13:20:15.289]                   NAME <- NAMES[[kk]]
[13:20:15.289]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.289]                     next
[13:20:15.289]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.289]                 }
[13:20:15.289]                 NAMES <- toupper(added)
[13:20:15.289]                 for (kk in seq_along(NAMES)) {
[13:20:15.289]                   name <- added[[kk]]
[13:20:15.289]                   NAME <- NAMES[[kk]]
[13:20:15.289]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.289]                     next
[13:20:15.289]                   args[[name]] <- ""
[13:20:15.289]                 }
[13:20:15.289]                 NAMES <- toupper(removed)
[13:20:15.289]                 for (kk in seq_along(NAMES)) {
[13:20:15.289]                   name <- removed[[kk]]
[13:20:15.289]                   NAME <- NAMES[[kk]]
[13:20:15.289]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.289]                     next
[13:20:15.289]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.289]                 }
[13:20:15.289]                 if (length(args) > 0) 
[13:20:15.289]                   base::do.call(base::Sys.setenv, args = args)
[13:20:15.289]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:15.289]             }
[13:20:15.289]             else {
[13:20:15.289]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:15.289]             }
[13:20:15.289]             {
[13:20:15.289]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:15.289]                   0L) {
[13:20:15.289]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:15.289]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:15.289]                   base::options(opts)
[13:20:15.289]                 }
[13:20:15.289]                 {
[13:20:15.289]                   {
[13:20:15.289]                     NULL
[13:20:15.289]                     RNGkind("Mersenne-Twister")
[13:20:15.289]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:15.289]                       inherits = FALSE)
[13:20:15.289]                   }
[13:20:15.289]                   options(future.plan = NULL)
[13:20:15.289]                   if (is.na(NA_character_)) 
[13:20:15.289]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.289]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:15.289]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:15.289]                   {
[13:20:15.289]                     future <- SequentialFuture(..., envir = envir)
[13:20:15.289]                     if (!future$lazy) 
[13:20:15.289]                       future <- run(future)
[13:20:15.289]                     invisible(future)
[13:20:15.289]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:15.289]                 }
[13:20:15.289]             }
[13:20:15.289]         }
[13:20:15.289]     })
[13:20:15.289]     if (TRUE) {
[13:20:15.289]         base::sink(type = "output", split = FALSE)
[13:20:15.289]         if (TRUE) {
[13:20:15.289]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:15.289]         }
[13:20:15.289]         else {
[13:20:15.289]             ...future.result["stdout"] <- base::list(NULL)
[13:20:15.289]         }
[13:20:15.289]         base::close(...future.stdout)
[13:20:15.289]         ...future.stdout <- NULL
[13:20:15.289]     }
[13:20:15.289]     ...future.result$conditions <- ...future.conditions
[13:20:15.289]     ...future.result$finished <- base::Sys.time()
[13:20:15.289]     ...future.result
[13:20:15.289] }
[13:20:15.291] plan(): Setting new future strategy stack:
[13:20:15.291] List of future strategies:
[13:20:15.291] 1. sequential:
[13:20:15.291]    - args: function (..., envir = parent.frame())
[13:20:15.291]    - tweaked: FALSE
[13:20:15.291]    - call: NULL
[13:20:15.291] plan(): nbrOfWorkers() = 1
[13:20:15.292] plan(): Setting new future strategy stack:
[13:20:15.292] List of future strategies:
[13:20:15.292] 1. sequential:
[13:20:15.292]    - args: function (..., envir = parent.frame())
[13:20:15.292]    - tweaked: FALSE
[13:20:15.292]    - call: plan(strategy)
[13:20:15.292] plan(): nbrOfWorkers() = 1
[13:20:15.293] SequentialFuture started (and completed)
[13:20:15.293] - Launch lazy future ... done
[13:20:15.293] run() for ‘SequentialFuture’ ... done
d = 1
** Nested future assignments
[13:20:15.293] getGlobalsAndPackages() ...
[13:20:15.293] Searching for globals...
[13:20:15.297] - globals found: [5] ‘{’, ‘<-’, ‘%<-%’, ‘%->%’, ‘+’
[13:20:15.297] Searching for globals ... DONE
[13:20:15.297] Resolving globals: FALSE
[13:20:15.297] 
[13:20:15.297] - packages: [1] ‘future’
[13:20:15.298] getGlobalsAndPackages() ... DONE
[13:20:15.299] run() for ‘Future’ ...
[13:20:15.299] - state: ‘created’
[13:20:15.299] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:15.300] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:15.300] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:15.300]   - Field: ‘label’
[13:20:15.300]   - Field: ‘local’
[13:20:15.300]   - Field: ‘owner’
[13:20:15.300]   - Field: ‘envir’
[13:20:15.300]   - Field: ‘packages’
[13:20:15.300]   - Field: ‘gc’
[13:20:15.301]   - Field: ‘conditions’
[13:20:15.301]   - Field: ‘expr’
[13:20:15.301]   - Field: ‘uuid’
[13:20:15.301]   - Field: ‘seed’
[13:20:15.301]   - Field: ‘version’
[13:20:15.301]   - Field: ‘result’
[13:20:15.301]   - Field: ‘asynchronous’
[13:20:15.301]   - Field: ‘calls’
[13:20:15.301]   - Field: ‘globals’
[13:20:15.301]   - Field: ‘stdout’
[13:20:15.301]   - Field: ‘earlySignal’
[13:20:15.302]   - Field: ‘lazy’
[13:20:15.302]   - Field: ‘state’
[13:20:15.302] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:15.302] - Launch lazy future ...
[13:20:15.302] Packages needed by the future expression (n = 1): ‘future’
[13:20:15.302] Packages needed by future strategies (n = 0): <none>
[13:20:15.303] {
[13:20:15.303]     {
[13:20:15.303]         {
[13:20:15.303]             ...future.startTime <- base::Sys.time()
[13:20:15.303]             {
[13:20:15.303]                 {
[13:20:15.303]                   {
[13:20:15.303]                     {
[13:20:15.303]                       base::local({
[13:20:15.303]                         has_future <- base::requireNamespace("future", 
[13:20:15.303]                           quietly = TRUE)
[13:20:15.303]                         if (has_future) {
[13:20:15.303]                           ns <- base::getNamespace("future")
[13:20:15.303]                           version <- ns[[".package"]][["version"]]
[13:20:15.303]                           if (is.null(version)) 
[13:20:15.303]                             version <- utils::packageVersion("future")
[13:20:15.303]                         }
[13:20:15.303]                         else {
[13:20:15.303]                           version <- NULL
[13:20:15.303]                         }
[13:20:15.303]                         if (!has_future || version < "1.8.0") {
[13:20:15.303]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:15.303]                             "", base::R.version$version.string), 
[13:20:15.303]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:15.303]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:15.303]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:15.303]                               "release", "version")], collapse = " "), 
[13:20:15.303]                             hostname = base::Sys.info()[["nodename"]])
[13:20:15.303]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:15.303]                             info)
[13:20:15.303]                           info <- base::paste(info, collapse = "; ")
[13:20:15.303]                           if (!has_future) {
[13:20:15.303]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:15.303]                               info)
[13:20:15.303]                           }
[13:20:15.303]                           else {
[13:20:15.303]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:15.303]                               info, version)
[13:20:15.303]                           }
[13:20:15.303]                           base::stop(msg)
[13:20:15.303]                         }
[13:20:15.303]                       })
[13:20:15.303]                     }
[13:20:15.303]                     base::local({
[13:20:15.303]                       for (pkg in "future") {
[13:20:15.303]                         base::loadNamespace(pkg)
[13:20:15.303]                         base::library(pkg, character.only = TRUE)
[13:20:15.303]                       }
[13:20:15.303]                     })
[13:20:15.303]                   }
[13:20:15.303]                   options(future.plan = NULL)
[13:20:15.303]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.303]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:15.303]                 }
[13:20:15.303]                 ...future.workdir <- getwd()
[13:20:15.303]             }
[13:20:15.303]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:15.303]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:15.303]         }
[13:20:15.303]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:15.303]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:15.303]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:15.303]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:15.303]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:15.303]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:15.303]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:15.303]             base::names(...future.oldOptions))
[13:20:15.303]     }
[13:20:15.303]     if (FALSE) {
[13:20:15.303]     }
[13:20:15.303]     else {
[13:20:15.303]         if (TRUE) {
[13:20:15.303]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:15.303]                 open = "w")
[13:20:15.303]         }
[13:20:15.303]         else {
[13:20:15.303]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:15.303]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:15.303]         }
[13:20:15.303]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:15.303]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:15.303]             base::sink(type = "output", split = FALSE)
[13:20:15.303]             base::close(...future.stdout)
[13:20:15.303]         }, add = TRUE)
[13:20:15.303]     }
[13:20:15.303]     ...future.frame <- base::sys.nframe()
[13:20:15.303]     ...future.conditions <- base::list()
[13:20:15.303]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:15.303]     if (FALSE) {
[13:20:15.303]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:15.303]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:15.303]     }
[13:20:15.303]     ...future.result <- base::tryCatch({
[13:20:15.303]         base::withCallingHandlers({
[13:20:15.303]             ...future.value <- base::withVisible(base::local({
[13:20:15.303]                 b <- 1
[13:20:15.303]                 c %<-% 2
[13:20:15.303]                 d <- 3
[13:20:15.303]                 4 %->% e
[13:20:15.303]                 b + c + d + e
[13:20:15.303]             }))
[13:20:15.303]             future::FutureResult(value = ...future.value$value, 
[13:20:15.303]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.303]                   ...future.rng), globalenv = if (FALSE) 
[13:20:15.303]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:15.303]                     ...future.globalenv.names))
[13:20:15.303]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:15.303]         }, condition = base::local({
[13:20:15.303]             c <- base::c
[13:20:15.303]             inherits <- base::inherits
[13:20:15.303]             invokeRestart <- base::invokeRestart
[13:20:15.303]             length <- base::length
[13:20:15.303]             list <- base::list
[13:20:15.303]             seq.int <- base::seq.int
[13:20:15.303]             signalCondition <- base::signalCondition
[13:20:15.303]             sys.calls <- base::sys.calls
[13:20:15.303]             `[[` <- base::`[[`
[13:20:15.303]             `+` <- base::`+`
[13:20:15.303]             `<<-` <- base::`<<-`
[13:20:15.303]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:15.303]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:15.303]                   3L)]
[13:20:15.303]             }
[13:20:15.303]             function(cond) {
[13:20:15.303]                 is_error <- inherits(cond, "error")
[13:20:15.303]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:15.303]                   NULL)
[13:20:15.303]                 if (is_error) {
[13:20:15.303]                   sessionInformation <- function() {
[13:20:15.303]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:15.303]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:15.303]                       search = base::search(), system = base::Sys.info())
[13:20:15.303]                   }
[13:20:15.303]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.303]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:15.303]                     cond$call), session = sessionInformation(), 
[13:20:15.303]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:15.303]                   signalCondition(cond)
[13:20:15.303]                 }
[13:20:15.303]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:15.303]                 "immediateCondition"))) {
[13:20:15.303]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:15.303]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.303]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:15.303]                   if (TRUE && !signal) {
[13:20:15.303]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.303]                     {
[13:20:15.303]                       inherits <- base::inherits
[13:20:15.303]                       invokeRestart <- base::invokeRestart
[13:20:15.303]                       is.null <- base::is.null
[13:20:15.303]                       muffled <- FALSE
[13:20:15.303]                       if (inherits(cond, "message")) {
[13:20:15.303]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.303]                         if (muffled) 
[13:20:15.303]                           invokeRestart("muffleMessage")
[13:20:15.303]                       }
[13:20:15.303]                       else if (inherits(cond, "warning")) {
[13:20:15.303]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.303]                         if (muffled) 
[13:20:15.303]                           invokeRestart("muffleWarning")
[13:20:15.303]                       }
[13:20:15.303]                       else if (inherits(cond, "condition")) {
[13:20:15.303]                         if (!is.null(pattern)) {
[13:20:15.303]                           computeRestarts <- base::computeRestarts
[13:20:15.303]                           grepl <- base::grepl
[13:20:15.303]                           restarts <- computeRestarts(cond)
[13:20:15.303]                           for (restart in restarts) {
[13:20:15.303]                             name <- restart$name
[13:20:15.303]                             if (is.null(name)) 
[13:20:15.303]                               next
[13:20:15.303]                             if (!grepl(pattern, name)) 
[13:20:15.303]                               next
[13:20:15.303]                             invokeRestart(restart)
[13:20:15.303]                             muffled <- TRUE
[13:20:15.303]                             break
[13:20:15.303]                           }
[13:20:15.303]                         }
[13:20:15.303]                       }
[13:20:15.303]                       invisible(muffled)
[13:20:15.303]                     }
[13:20:15.303]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.303]                   }
[13:20:15.303]                 }
[13:20:15.303]                 else {
[13:20:15.303]                   if (TRUE) {
[13:20:15.303]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.303]                     {
[13:20:15.303]                       inherits <- base::inherits
[13:20:15.303]                       invokeRestart <- base::invokeRestart
[13:20:15.303]                       is.null <- base::is.null
[13:20:15.303]                       muffled <- FALSE
[13:20:15.303]                       if (inherits(cond, "message")) {
[13:20:15.303]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.303]                         if (muffled) 
[13:20:15.303]                           invokeRestart("muffleMessage")
[13:20:15.303]                       }
[13:20:15.303]                       else if (inherits(cond, "warning")) {
[13:20:15.303]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.303]                         if (muffled) 
[13:20:15.303]                           invokeRestart("muffleWarning")
[13:20:15.303]                       }
[13:20:15.303]                       else if (inherits(cond, "condition")) {
[13:20:15.303]                         if (!is.null(pattern)) {
[13:20:15.303]                           computeRestarts <- base::computeRestarts
[13:20:15.303]                           grepl <- base::grepl
[13:20:15.303]                           restarts <- computeRestarts(cond)
[13:20:15.303]                           for (restart in restarts) {
[13:20:15.303]                             name <- restart$name
[13:20:15.303]                             if (is.null(name)) 
[13:20:15.303]                               next
[13:20:15.303]                             if (!grepl(pattern, name)) 
[13:20:15.303]                               next
[13:20:15.303]                             invokeRestart(restart)
[13:20:15.303]                             muffled <- TRUE
[13:20:15.303]                             break
[13:20:15.303]                           }
[13:20:15.303]                         }
[13:20:15.303]                       }
[13:20:15.303]                       invisible(muffled)
[13:20:15.303]                     }
[13:20:15.303]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.303]                   }
[13:20:15.303]                 }
[13:20:15.303]             }
[13:20:15.303]         }))
[13:20:15.303]     }, error = function(ex) {
[13:20:15.303]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:15.303]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.303]                 ...future.rng), started = ...future.startTime, 
[13:20:15.303]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:15.303]             version = "1.8"), class = "FutureResult")
[13:20:15.303]     }, finally = {
[13:20:15.303]         if (!identical(...future.workdir, getwd())) 
[13:20:15.303]             setwd(...future.workdir)
[13:20:15.303]         {
[13:20:15.303]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:15.303]                 ...future.oldOptions$nwarnings <- NULL
[13:20:15.303]             }
[13:20:15.303]             base::options(...future.oldOptions)
[13:20:15.303]             if (.Platform$OS.type == "windows") {
[13:20:15.303]                 old_names <- names(...future.oldEnvVars)
[13:20:15.303]                 envs <- base::Sys.getenv()
[13:20:15.303]                 names <- names(envs)
[13:20:15.303]                 common <- intersect(names, old_names)
[13:20:15.303]                 added <- setdiff(names, old_names)
[13:20:15.303]                 removed <- setdiff(old_names, names)
[13:20:15.303]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:15.303]                   envs[common]]
[13:20:15.303]                 NAMES <- toupper(changed)
[13:20:15.303]                 args <- list()
[13:20:15.303]                 for (kk in seq_along(NAMES)) {
[13:20:15.303]                   name <- changed[[kk]]
[13:20:15.303]                   NAME <- NAMES[[kk]]
[13:20:15.303]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.303]                     next
[13:20:15.303]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.303]                 }
[13:20:15.303]                 NAMES <- toupper(added)
[13:20:15.303]                 for (kk in seq_along(NAMES)) {
[13:20:15.303]                   name <- added[[kk]]
[13:20:15.303]                   NAME <- NAMES[[kk]]
[13:20:15.303]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.303]                     next
[13:20:15.303]                   args[[name]] <- ""
[13:20:15.303]                 }
[13:20:15.303]                 NAMES <- toupper(removed)
[13:20:15.303]                 for (kk in seq_along(NAMES)) {
[13:20:15.303]                   name <- removed[[kk]]
[13:20:15.303]                   NAME <- NAMES[[kk]]
[13:20:15.303]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.303]                     next
[13:20:15.303]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.303]                 }
[13:20:15.303]                 if (length(args) > 0) 
[13:20:15.303]                   base::do.call(base::Sys.setenv, args = args)
[13:20:15.303]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:15.303]             }
[13:20:15.303]             else {
[13:20:15.303]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:15.303]             }
[13:20:15.303]             {
[13:20:15.303]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:15.303]                   0L) {
[13:20:15.303]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:15.303]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:15.303]                   base::options(opts)
[13:20:15.303]                 }
[13:20:15.303]                 {
[13:20:15.303]                   {
[13:20:15.303]                     NULL
[13:20:15.303]                     RNGkind("Mersenne-Twister")
[13:20:15.303]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:15.303]                       inherits = FALSE)
[13:20:15.303]                   }
[13:20:15.303]                   options(future.plan = NULL)
[13:20:15.303]                   if (is.na(NA_character_)) 
[13:20:15.303]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.303]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:15.303]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:15.303]                   {
[13:20:15.303]                     future <- SequentialFuture(..., envir = envir)
[13:20:15.303]                     if (!future$lazy) 
[13:20:15.303]                       future <- run(future)
[13:20:15.303]                     invisible(future)
[13:20:15.303]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:15.303]                 }
[13:20:15.303]             }
[13:20:15.303]         }
[13:20:15.303]     })
[13:20:15.303]     if (TRUE) {
[13:20:15.303]         base::sink(type = "output", split = FALSE)
[13:20:15.303]         if (TRUE) {
[13:20:15.303]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:15.303]         }
[13:20:15.303]         else {
[13:20:15.303]             ...future.result["stdout"] <- base::list(NULL)
[13:20:15.303]         }
[13:20:15.303]         base::close(...future.stdout)
[13:20:15.303]         ...future.stdout <- NULL
[13:20:15.303]     }
[13:20:15.303]     ...future.result$conditions <- ...future.conditions
[13:20:15.303]     ...future.result$finished <- base::Sys.time()
[13:20:15.303]     ...future.result
[13:20:15.303] }
[13:20:15.305] plan(): Setting new future strategy stack:
[13:20:15.305] List of future strategies:
[13:20:15.305] 1. sequential:
[13:20:15.305]    - args: function (..., envir = parent.frame())
[13:20:15.305]    - tweaked: FALSE
[13:20:15.305]    - call: NULL
[13:20:15.305] plan(): nbrOfWorkers() = 1
[13:20:15.337] plan(): Setting new future strategy stack:
[13:20:15.337] List of future strategies:
[13:20:15.337] 1. sequential:
[13:20:15.337]    - args: function (..., envir = parent.frame())
[13:20:15.337]    - tweaked: FALSE
[13:20:15.337]    - call: plan(strategy)
[13:20:15.338] plan(): nbrOfWorkers() = 1
[13:20:15.338] SequentialFuture started (and completed)
[13:20:15.338] signalConditions() ...
[13:20:15.338]  - include = ‘immediateCondition’
[13:20:15.338]  - exclude = 
[13:20:15.338]  - resignal = FALSE
[13:20:15.338]  - Number of conditions: 88
[13:20:15.339] signalConditions() ... done
[13:20:15.339] - Launch lazy future ... done
[13:20:15.339] run() for ‘SequentialFuture’ ... done
[13:20:15.339] signalConditions() ...
[13:20:15.339]  - include = ‘immediateCondition’
[13:20:15.339]  - exclude = 
[13:20:15.339]  - resignal = FALSE
[13:20:15.339]  - Number of conditions: 88
[13:20:15.339] signalConditions() ... done
[13:20:15.340] Future state: ‘finished’
[13:20:15.340] signalConditions() ...
[13:20:15.340]  - include = ‘condition’
[13:20:15.340]  - exclude = ‘immediateCondition’
[13:20:15.340]  - resignal = TRUE
[13:20:15.340]  - Number of conditions: 88
[13:20:15.340]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.306] getGlobalsAndPackages() ...
[13:20:15.340]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.306] Searching for globals...
[13:20:15.340]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.319] 
[13:20:15.340]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.319] Searching for globals ... DONE
[13:20:15.341]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.320] - globals: [0] <none>
[13:20:15.341]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.320] getGlobalsAndPackages() ... DONE
[13:20:15.341]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.321] run() for ‘Future’ ...
[13:20:15.341]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.321] - state: ‘created’
[13:20:15.341]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.321] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:15.341]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.321] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:15.341]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.321] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:15.342]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.321]   - Field: ‘label’
[13:20:15.342]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.322]   - Field: ‘local’
[13:20:15.342]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.322]   - Field: ‘owner’
[13:20:15.342]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.322]   - Field: ‘envir’
[13:20:15.342]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.322]   - Field: ‘packages’
[13:20:15.342]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.322]   - Field: ‘gc’
[13:20:15.342]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.322]   - Field: ‘conditions’
[13:20:15.342]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.322]   - Field: ‘expr’
[13:20:15.343]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.322]   - Field: ‘uuid’
[13:20:15.343]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.322]   - Field: ‘seed’
[13:20:15.343]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.323]   - Field: ‘version’
[13:20:15.343]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.323]   - Field: ‘result’
[13:20:15.343]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.323]   - Field: ‘asynchronous’
[13:20:15.343]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.323]   - Field: ‘calls’
[13:20:15.343]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.323]   - Field: ‘globals’
[13:20:15.343]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.323]   - Field: ‘stdout’
[13:20:15.344]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.323]   - Field: ‘earlySignal’
[13:20:15.344]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.323]   - Field: ‘lazy’
[13:20:15.344]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.323]   - Field: ‘state’
[13:20:15.344]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.324] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:15.344]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.324] - Launch lazy future ...
[13:20:15.344]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.324] Packages needed by the future expression (n = 0): <none>
[13:20:15.344]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.324] Packages needed by future strategies (n = 0): <none>
[13:20:15.345]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.324] {
[13:20:15.324]     {
[13:20:15.324]         {
[13:20:15.324]             ...future.startTime <- base::Sys.time()
[13:20:15.324]             {
[13:20:15.324]                 {
[13:20:15.324]                   {
[13:20:15.324]                     base::local({
[13:20:15.324]                       has_future <- base::requireNamespace("future", 
[13:20:15.324]                         quietly = TRUE)
[13:20:15.324]                       if (has_future) {
[13:20:15.324]                         ns <- base::getNamespace("future")
[13:20:15.324]                         version <- ns[[".package"]][["version"]]
[13:20:15.324]                         if (is.null(version)) 
[13:20:15.324]                           version <- utils::packageVersion("future")
[13:20:15.324]                       }
[13:20:15.324]                       else {
[13:20:15.324]                         version <- NULL
[13:20:15.324]                       }
[13:20:15.324]                       if (!has_future || version < "1.8.0") {
[13:20:15.324]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:15.324]                           "", base::R.version$version.string), 
[13:20:15.324]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:15.324]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:15.324]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:15.324]                             "release", "version")], collapse = " "), 
[13:20:15.324]                           hostname = base::Sys.info()[["nodename"]])
[13:20:15.324]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:15.324]                           info)
[13:20:15.324]                         info <- base::paste(info, collapse = "; ")
[13:20:15.324]                         if (!has_future) {
[13:20:15.324]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:15.324]                             info)
[13:20:15.324]                         }
[13:20:15.324]                         else {
[13:20:15.324]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:15.324]                             info, version)
[13:20:15.324]                         }
[13:20:15.324]                         base::stop(msg)
[13:20:15.324]                       }
[13:20:15.324]                     })
[13:20:15.324]                   }
[13:20:15.324]                   options(future.plan = NULL)
[13:20:15.324]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.324]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:15.324]                 }
[13:20:15.324]                 ...future.workdir <- getwd()
[13:20:15.324]             }
[13:20:15.324]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:15.324]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:15.324]         }
[13:20:15.324]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:15.324]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:15.324]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:15.324]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:15.324]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:15.324]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:15.324]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:15.324]             base::names(...future.oldOptions))
[13:20:15.324]     }
[13:20:15.324]     if (FALSE) {
[13:20:15.324]     }
[13:20:15.324]     else {
[13:20:15.324]         if (TRUE) {
[13:20:15.324]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:15.324]                 open = "w")
[13:20:15.324]         }
[13:20:15.324]         else {
[13:20:15.324]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:15.324]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:15.324]         }
[13:20:15.324]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:15.324]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:15.324]             base::sink(type = "output", split = FALSE)
[13:20:15.324]             base::close(...future.stdout)
[13:20:15.324]         }, add = TRUE)
[13:20:15.324]     }
[13:20:15.324]     ...future.frame <- base::sys.nframe()
[13:20:15.324]     ...future.conditions <- base::list()
[13:20:15.324]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:15.324]     if (FALSE) {
[13:20:15.324]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:15.324]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:15.324]     }
[13:20:15.324]     ...future.result <- base::tryCatch({
[13:20:15.324]         base::withCallingHandlers({
[13:20:15.324]             ...future.value <- base::withVisible(base::local(2))
[13:20:15.324]             future::FutureResult(value = ...future.value$value, 
[13:20:15.324]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.324]                   ...future.rng), globalenv = if (FALSE) 
[13:20:15.324]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:15.324]                     ...future.globalenv.names))
[13:20:15.324]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:15.324]         }, condition = base::local({
[13:20:15.324]             c <- base::c
[13:20:15.324]             inherits <- base::inherits
[13:20:15.324]             invokeRestart <- base::invokeRestart
[13:20:15.324]             length <- base::length
[13:20:15.324]             list <- base::list
[13:20:15.324]             seq.int <- base::seq.int
[13:20:15.324]             signalCondition <- base::signalCondition
[13:20:15.324]             sys.calls <- base::sys.calls
[13:20:15.324]             `[[` <- base::`[[`
[13:20:15.324]             `+` <- base::`+`
[13:20:15.324]             `<<-` <- base::`<<-`
[13:20:15.324]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:15.324]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:15.324]                   3L)]
[13:20:15.324]             }
[13:20:15.324]             function(cond) {
[13:20:15.324]                 is_error <- inherits(cond, "error")
[13:20:15.324]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:15.324]                   NULL)
[13:20:15.324]                 if (is_error) {
[13:20:15.324]                   sessionInformation <- function() {
[13:20:15.324]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:15.324]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:15.324]                       search = base::search(), system = base::Sys.info())
[13:20:15.324]                   }
[13:20:15.324]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.324]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:15.324]                     cond$call), session = sessionInformation(), 
[13:20:15.324]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:15.324]                   signalCondition(cond)
[13:20:15.324]                 }
[13:20:15.324]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:15.324]                 "immediateCondition"))) {
[13:20:15.324]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:15.324]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.324]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:15.324]                   if (TRUE && !signal) {
[13:20:15.324]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.324]                     {
[13:20:15.324]                       inherits <- base::inherits
[13:20:15.324]                       invokeRestart <- base::invokeRestart
[13:20:15.324]                       is.null <- base::is.null
[13:20:15.324]                       muffled <- FALSE
[13:20:15.324]                       if (inherits(cond, "message")) {
[13:20:15.324]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.324]                         if (muffled) 
[13:20:15.324]                           invokeRestart("muffleMessage")
[13:20:15.324]                       }
[13:20:15.324]                       else if (inherits(cond, "warning")) {
[13:20:15.324]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.324]                         if (muffled) 
[13:20:15.324]                           invokeRestart("muffleWarning")
[13:20:15.324]                       }
[13:20:15.324]                       else if (inherits(cond, "condition")) {
[13:20:15.324]                         if (!is.null(pattern)) {
[13:20:15.324]                           computeRestarts <- base::computeRestarts
[13:20:15.324]                           grepl <- base::grepl
[13:20:15.324]                           restarts <- computeRestarts(cond)
[13:20:15.324]                           for (restart in restarts) {
[13:20:15.324]                             name <- restart$name
[13:20:15.324]                             if (is.null(name)) 
[13:20:15.324]                               next
[13:20:15.324]                             if (!grepl(pattern, name)) 
[13:20:15.324]                               next
[13:20:15.324]                             invokeRestart(restart)
[13:20:15.324]                             muffled <- TRUE
[13:20:15.324]                             break
[13:20:15.324]                           }
[13:20:15.324]                         }
[13:20:15.324]                       }
[13:20:15.324]                       invisible(muffled)
[13:20:15.324]                     }
[13:20:15.324]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.324]                   }
[13:20:15.324]                 }
[13:20:15.324]                 else {
[13:20:15.324]                   if (TRUE) {
[13:20:15.324]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.324]                     {
[13:20:15.324]                       inherits <- base::inherits
[13:20:15.324]                       invokeRestart <- base::invokeRestart
[13:20:15.324]                       is.null <- base::is.null
[13:20:15.324]                       muffled <- FALSE
[13:20:15.324]                       if (inherits(cond, "message")) {
[13:20:15.324]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.324]                         if (muffled) 
[13:20:15.324]                           invokeRestart("muffleMessage")
[13:20:15.324]                       }
[13:20:15.324]                       else if (inherits(cond, "warning")) {
[13:20:15.324]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.324]                         if (muffled) 
[13:20:15.324]                           invokeRestart("muffleWarning")
[13:20:15.324]                       }
[13:20:15.324]                       else if (inherits(cond, "condition")) {
[13:20:15.324]                         if (!is.null(pattern)) {
[13:20:15.324]                           computeRestarts <- base::computeRestarts
[13:20:15.324]                           grepl <- base::grepl
[13:20:15.324]                           restarts <- computeRestarts(cond)
[13:20:15.324]                           for (restart in restarts) {
[13:20:15.324]                             name <- restart$name
[13:20:15.324]                             if (is.null(name)) 
[13:20:15.324]                               next
[13:20:15.324]                             if (!grepl(pattern, name)) 
[13:20:15.324]                               next
[13:20:15.324]                             invokeRestart(restart)
[13:20:15.324]                             muffled <- TRUE
[13:20:15.324]                             break
[13:20:15.324]                           }
[13:20:15.324]                         }
[13:20:15.324]                       }
[13:20:15.324]                       invisible(muffled)
[13:20:15.324]                     }
[13:20:15.324]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.324]                   }
[13:20:15.324]                 }
[13:20:15.324]             }
[13:20:15.324]         }))
[13:20:15.324]     }, error = function(ex) {
[13:20:15.324]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:15.324]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.324]                 ...future.rng), started = ...future.startTime, 
[13:20:15.324]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:15.324]             version = "1.8"), class = "FutureResult")
[13:20:15.324]     }, finally = {
[13:20:15.324]         if (!identical(...future.workdir, getwd())) 
[13:20:15.324]             setwd(...future.workdir)
[13:20:15.324]         {
[13:20:15.324]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:15.324]                 ...future.oldOptions$nwarnings <- NULL
[13:20:15.324]             }
[13:20:15.324]             base::options(...future.oldOptions)
[13:20:15.324]             if (.Platform$OS.type == "windows") {
[13:20:15.324]                 old_names <- names(...future.oldEnvVars)
[13:20:15.324]                 envs <- base::Sys.getenv()
[13:20:15.324]                 names <- names(envs)
[13:20:15.324]                 common <- intersect(names, old_names)
[13:20:15.324]                 added <- setdiff(names, old_names)
[13:20:15.324]                 removed <- setdiff(old_names, names)
[13:20:15.324]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:15.324]                   envs[common]]
[13:20:15.324]                 NAMES <- toupper(changed)
[13:20:15.324]                 args <- list()
[13:20:15.324]                 for (kk in seq_along(NAMES)) {
[13:20:15.324]                   name <- changed[[kk]]
[13:20:15.324]                   NAME <- NAMES[[kk]]
[13:20:15.324]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.324]                     next
[13:20:15.324]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.324]                 }
[13:20:15.324]                 NAMES <- toupper(added)
[13:20:15.324]                 for (kk in seq_along(NAMES)) {
[13:20:15.324]                   name <- added[[kk]]
[13:20:15.324]                   NAME <- NAMES[[kk]]
[13:20:15.324]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.324]                     next
[13:20:15.324]                   args[[name]] <- ""
[13:20:15.324]                 }
[13:20:15.324]                 NAMES <- toupper(removed)
[13:20:15.324]                 for (kk in seq_along(NAMES)) {
[13:20:15.324]                   name <- removed[[kk]]
[13:20:15.324]                   NAME <- NAMES[[kk]]
[13:20:15.324]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.324]                     next
[13:20:15.324]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.324]                 }
[13:20:15.324]                 if (length(args) > 0) 
[13:20:15.324]                   base::do.call(base::Sys.setenv, args = args)
[13:20:15.324]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:15.324]             }
[13:20:15.324]             else {
[13:20:15.324]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:15.324]             }
[13:20:15.324]             {
[13:20:15.324]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:15.324]                   0L) {
[13:20:15.324]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:15.324]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:15.324]                   base::options(opts)
[13:20:15.324]                 }
[13:20:15.324]                 {
[13:20:15.324]                   {
[13:20:15.324]                     NULL
[13:20:15.324]                     RNGkind("Mersenne-Twister")
[13:20:15.324]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:15.324]                       inherits = FALSE)
[13:20:15.324]                   }
[13:20:15.324]                   options(future.plan = NULL)
[13:20:15.324]                   if (is.na(NA_character_)) 
[13:20:15.324]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.324]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:15.324]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:15.324]                   {
[13:20:15.324]                     future <- SequentialFuture(..., envir = envir)
[13:20:15.324]                     if (!future$lazy) 
[13:20:15.324]                       future <- run(future)
[13:20:15.324]                     invisible(future)
[13:20:15.324]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:15.324]                 }
[13:20:15.324]             }
[13:20:15.324]         }
[13:20:15.324]     })
[13:20:15.324]     if (TRUE) {
[13:20:15.324]         base::sink(type = "output", split = FALSE)
[13:20:15.324]         if (TRUE) {
[13:20:15.324]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:15.324]         }
[13:20:15.324]         else {
[13:20:15.324]             ...future.result["stdout"] <- base::list(NULL)
[13:20:15.324]         }
[13:20:15.324]         base::close(...future.stdout)
[13:20:15.324]         ...future.stdout <- NULL
[13:20:15.324]     }
[13:20:15.324]     ...future.result$conditions <- ...future.conditions
[13:20:15.324]     ...future.result$finished <- base::Sys.time()
[13:20:15.324]     ...future.result
[13:20:15.324] }
[13:20:15.345]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.326] plan(): Setting new future strategy stack:
[13:20:15.345]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.326] List of future strategies:
[13:20:15.326] 1. sequential:
[13:20:15.326]    - args: function (..., envir = parent.frame())
[13:20:15.326]    - tweaked: FALSE
[13:20:15.326]    - call: NULL
[13:20:15.347]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.327] plan(): nbrOfWorkers() = 1
[13:20:15.347]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.327] plan(): Setting new future strategy stack:
[13:20:15.347]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.327] List of future strategies:
[13:20:15.327] 1. sequential:
[13:20:15.327]    - args: function (..., envir = parent.frame())
[13:20:15.327]    - tweaked: FALSE
[13:20:15.327]    - call: NULL
[13:20:15.347]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.328] plan(): nbrOfWorkers() = 1
[13:20:15.347]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.328] SequentialFuture started (and completed)
[13:20:15.347]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.328] - Launch lazy future ... done
[13:20:15.348]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.328] run() for ‘SequentialFuture’ ... done
[13:20:15.348]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.328] getGlobalsAndPackages() ...
[13:20:15.348]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.329] Searching for globals...
[13:20:15.348]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.329] 
[13:20:15.348]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.329] Searching for globals ... DONE
[13:20:15.348]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.329] - globals: [0] <none>
[13:20:15.348]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.329] getGlobalsAndPackages() ... DONE
[13:20:15.348]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.329] run() for ‘Future’ ...
[13:20:15.349]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.330] - state: ‘created’
[13:20:15.349]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.330] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:15.349]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.330] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:15.349]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.330] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:15.349]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.330]   - Field: ‘label’
[13:20:15.349]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.330]   - Field: ‘local’
[13:20:15.349]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.330]   - Field: ‘owner’
[13:20:15.350]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.330]   - Field: ‘envir’
[13:20:15.350]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.331]   - Field: ‘packages’
[13:20:15.350]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.331]   - Field: ‘gc’
[13:20:15.350]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.331]   - Field: ‘conditions’
[13:20:15.350]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.331]   - Field: ‘expr’
[13:20:15.350]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.331]   - Field: ‘uuid’
[13:20:15.350]  - Condition #65: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.331]   - Field: ‘seed’
[13:20:15.350]  - Condition #66: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.331]   - Field: ‘version’
[13:20:15.351]  - Condition #67: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.331]   - Field: ‘result’
[13:20:15.351]  - Condition #68: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.331]   - Field: ‘asynchronous’
[13:20:15.351]  - Condition #69: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.332]   - Field: ‘calls’
[13:20:15.351]  - Condition #70: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.332]   - Field: ‘globals’
[13:20:15.351]  - Condition #71: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.332]   - Field: ‘stdout’
[13:20:15.351]  - Condition #72: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.332]   - Field: ‘earlySignal’
[13:20:15.351]  - Condition #73: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.332]   - Field: ‘lazy’
[13:20:15.352]  - Condition #74: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.332]   - Field: ‘state’
[13:20:15.352]  - Condition #75: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.332] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:15.352]  - Condition #76: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.332] - Launch lazy future ...
[13:20:15.352]  - Condition #77: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.332] Packages needed by the future expression (n = 0): <none>
[13:20:15.352]  - Condition #78: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.333] Packages needed by future strategies (n = 0): <none>
[13:20:15.352]  - Condition #79: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.333] {
[13:20:15.333]     {
[13:20:15.333]         {
[13:20:15.333]             ...future.startTime <- base::Sys.time()
[13:20:15.333]             {
[13:20:15.333]                 {
[13:20:15.333]                   {
[13:20:15.333]                     base::local({
[13:20:15.333]                       has_future <- base::requireNamespace("future", 
[13:20:15.333]                         quietly = TRUE)
[13:20:15.333]                       if (has_future) {
[13:20:15.333]                         ns <- base::getNamespace("future")
[13:20:15.333]                         version <- ns[[".package"]][["version"]]
[13:20:15.333]                         if (is.null(version)) 
[13:20:15.333]                           version <- utils::packageVersion("future")
[13:20:15.333]                       }
[13:20:15.333]                       else {
[13:20:15.333]                         version <- NULL
[13:20:15.333]                       }
[13:20:15.333]                       if (!has_future || version < "1.8.0") {
[13:20:15.333]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:15.333]                           "", base::R.version$version.string), 
[13:20:15.333]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:15.333]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:15.333]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:15.333]                             "release", "version")], collapse = " "), 
[13:20:15.333]                           hostname = base::Sys.info()[["nodename"]])
[13:20:15.333]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:15.333]                           info)
[13:20:15.333]                         info <- base::paste(info, collapse = "; ")
[13:20:15.333]                         if (!has_future) {
[13:20:15.333]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:15.333]                             info)
[13:20:15.333]                         }
[13:20:15.333]                         else {
[13:20:15.333]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:15.333]                             info, version)
[13:20:15.333]                         }
[13:20:15.333]                         base::stop(msg)
[13:20:15.333]                       }
[13:20:15.333]                     })
[13:20:15.333]                   }
[13:20:15.333]                   options(future.plan = NULL)
[13:20:15.333]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.333]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:15.333]                 }
[13:20:15.333]                 ...future.workdir <- getwd()
[13:20:15.333]             }
[13:20:15.333]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:15.333]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:15.333]         }
[13:20:15.333]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:15.333]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:15.333]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:15.333]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:15.333]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:15.333]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:15.333]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:15.333]             base::names(...future.oldOptions))
[13:20:15.333]     }
[13:20:15.333]     if (FALSE) {
[13:20:15.333]     }
[13:20:15.333]     else {
[13:20:15.333]         if (TRUE) {
[13:20:15.333]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:15.333]                 open = "w")
[13:20:15.333]         }
[13:20:15.333]         else {
[13:20:15.333]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:15.333]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:15.333]         }
[13:20:15.333]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:15.333]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:15.333]             base::sink(type = "output", split = FALSE)
[13:20:15.333]             base::close(...future.stdout)
[13:20:15.333]         }, add = TRUE)
[13:20:15.333]     }
[13:20:15.333]     ...future.frame <- base::sys.nframe()
[13:20:15.333]     ...future.conditions <- base::list()
[13:20:15.333]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:15.333]     if (FALSE) {
[13:20:15.333]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:15.333]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:15.333]     }
[13:20:15.333]     ...future.result <- base::tryCatch({
[13:20:15.333]         base::withCallingHandlers({
[13:20:15.333]             ...future.value <- base::withVisible(base::local(4))
[13:20:15.333]             future::FutureResult(value = ...future.value$value, 
[13:20:15.333]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.333]                   ...future.rng), globalenv = if (FALSE) 
[13:20:15.333]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:15.333]                     ...future.globalenv.names))
[13:20:15.333]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:15.333]         }, condition = base::local({
[13:20:15.333]             c <- base::c
[13:20:15.333]             inherits <- base::inherits
[13:20:15.333]             invokeRestart <- base::invokeRestart
[13:20:15.333]             length <- base::length
[13:20:15.333]             list <- base::list
[13:20:15.333]             seq.int <- base::seq.int
[13:20:15.333]             signalCondition <- base::signalCondition
[13:20:15.333]             sys.calls <- base::sys.calls
[13:20:15.333]             `[[` <- base::`[[`
[13:20:15.333]             `+` <- base::`+`
[13:20:15.333]             `<<-` <- base::`<<-`
[13:20:15.333]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:15.333]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:15.333]                   3L)]
[13:20:15.333]             }
[13:20:15.333]             function(cond) {
[13:20:15.333]                 is_error <- inherits(cond, "error")
[13:20:15.333]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:15.333]                   NULL)
[13:20:15.333]                 if (is_error) {
[13:20:15.333]                   sessionInformation <- function() {
[13:20:15.333]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:15.333]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:15.333]                       search = base::search(), system = base::Sys.info())
[13:20:15.333]                   }
[13:20:15.333]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.333]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:15.333]                     cond$call), session = sessionInformation(), 
[13:20:15.333]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:15.333]                   signalCondition(cond)
[13:20:15.333]                 }
[13:20:15.333]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:15.333]                 "immediateCondition"))) {
[13:20:15.333]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:15.333]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.333]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:15.333]                   if (TRUE && !signal) {
[13:20:15.333]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.333]                     {
[13:20:15.333]                       inherits <- base::inherits
[13:20:15.333]                       invokeRestart <- base::invokeRestart
[13:20:15.333]                       is.null <- base::is.null
[13:20:15.333]                       muffled <- FALSE
[13:20:15.333]                       if (inherits(cond, "message")) {
[13:20:15.333]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.333]                         if (muffled) 
[13:20:15.333]                           invokeRestart("muffleMessage")
[13:20:15.333]                       }
[13:20:15.333]                       else if (inherits(cond, "warning")) {
[13:20:15.333]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.333]                         if (muffled) 
[13:20:15.333]                           invokeRestart("muffleWarning")
[13:20:15.333]                       }
[13:20:15.333]                       else if (inherits(cond, "condition")) {
[13:20:15.333]                         if (!is.null(pattern)) {
[13:20:15.333]                           computeRestarts <- base::computeRestarts
[13:20:15.333]                           grepl <- base::grepl
[13:20:15.333]                           restarts <- computeRestarts(cond)
[13:20:15.333]                           for (restart in restarts) {
[13:20:15.333]                             name <- restart$name
[13:20:15.333]                             if (is.null(name)) 
[13:20:15.333]                               next
[13:20:15.333]                             if (!grepl(pattern, name)) 
[13:20:15.333]                               next
[13:20:15.333]                             invokeRestart(restart)
[13:20:15.333]                             muffled <- TRUE
[13:20:15.333]                             break
[13:20:15.333]                           }
[13:20:15.333]                         }
[13:20:15.333]                       }
[13:20:15.333]                       invisible(muffled)
[13:20:15.333]                     }
[13:20:15.333]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.333]                   }
[13:20:15.333]                 }
[13:20:15.333]                 else {
[13:20:15.333]                   if (TRUE) {
[13:20:15.333]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.333]                     {
[13:20:15.333]                       inherits <- base::inherits
[13:20:15.333]                       invokeRestart <- base::invokeRestart
[13:20:15.333]                       is.null <- base::is.null
[13:20:15.333]                       muffled <- FALSE
[13:20:15.333]                       if (inherits(cond, "message")) {
[13:20:15.333]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.333]                         if (muffled) 
[13:20:15.333]                           invokeRestart("muffleMessage")
[13:20:15.333]                       }
[13:20:15.333]                       else if (inherits(cond, "warning")) {
[13:20:15.333]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.333]                         if (muffled) 
[13:20:15.333]                           invokeRestart("muffleWarning")
[13:20:15.333]                       }
[13:20:15.333]                       else if (inherits(cond, "condition")) {
[13:20:15.333]                         if (!is.null(pattern)) {
[13:20:15.333]                           computeRestarts <- base::computeRestarts
[13:20:15.333]                           grepl <- base::grepl
[13:20:15.333]                           restarts <- computeRestarts(cond)
[13:20:15.333]                           for (restart in restarts) {
[13:20:15.333]                             name <- restart$name
[13:20:15.333]                             if (is.null(name)) 
[13:20:15.333]                               next
[13:20:15.333]                             if (!grepl(pattern, name)) 
[13:20:15.333]                               next
[13:20:15.333]                             invokeRestart(restart)
[13:20:15.333]                             muffled <- TRUE
[13:20:15.333]                             break
[13:20:15.333]                           }
[13:20:15.333]                         }
[13:20:15.333]                       }
[13:20:15.333]                       invisible(muffled)
[13:20:15.333]                     }
[13:20:15.333]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.333]                   }
[13:20:15.333]                 }
[13:20:15.333]             }
[13:20:15.333]         }))
[13:20:15.333]     }, error = function(ex) {
[13:20:15.333]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:15.333]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.333]                 ...future.rng), started = ...future.startTime, 
[13:20:15.333]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:15.333]             version = "1.8"), class = "FutureResult")
[13:20:15.333]     }, finally = {
[13:20:15.333]         if (!identical(...future.workdir, getwd())) 
[13:20:15.333]             setwd(...future.workdir)
[13:20:15.333]         {
[13:20:15.333]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:15.333]                 ...future.oldOptions$nwarnings <- NULL
[13:20:15.333]             }
[13:20:15.333]             base::options(...future.oldOptions)
[13:20:15.333]             if (.Platform$OS.type == "windows") {
[13:20:15.333]                 old_names <- names(...future.oldEnvVars)
[13:20:15.333]                 envs <- base::Sys.getenv()
[13:20:15.333]                 names <- names(envs)
[13:20:15.333]                 common <- intersect(names, old_names)
[13:20:15.333]                 added <- setdiff(names, old_names)
[13:20:15.333]                 removed <- setdiff(old_names, names)
[13:20:15.333]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:15.333]                   envs[common]]
[13:20:15.333]                 NAMES <- toupper(changed)
[13:20:15.333]                 args <- list()
[13:20:15.333]                 for (kk in seq_along(NAMES)) {
[13:20:15.333]                   name <- changed[[kk]]
[13:20:15.333]                   NAME <- NAMES[[kk]]
[13:20:15.333]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.333]                     next
[13:20:15.333]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.333]                 }
[13:20:15.333]                 NAMES <- toupper(added)
[13:20:15.333]                 for (kk in seq_along(NAMES)) {
[13:20:15.333]                   name <- added[[kk]]
[13:20:15.333]                   NAME <- NAMES[[kk]]
[13:20:15.333]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.333]                     next
[13:20:15.333]                   args[[name]] <- ""
[13:20:15.333]                 }
[13:20:15.333]                 NAMES <- toupper(removed)
[13:20:15.333]                 for (kk in seq_along(NAMES)) {
[13:20:15.333]                   name <- removed[[kk]]
[13:20:15.333]                   NAME <- NAMES[[kk]]
[13:20:15.333]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.333]                     next
[13:20:15.333]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.333]                 }
[13:20:15.333]                 if (length(args) > 0) 
[13:20:15.333]                   base::do.call(base::Sys.setenv, args = args)
[13:20:15.333]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:15.333]             }
[13:20:15.333]             else {
[13:20:15.333]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:15.333]             }
[13:20:15.333]             {
[13:20:15.333]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:15.333]                   0L) {
[13:20:15.333]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:15.333]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:15.333]                   base::options(opts)
[13:20:15.333]                 }
[13:20:15.333]                 {
[13:20:15.333]                   {
[13:20:15.333]                     NULL
[13:20:15.333]                     RNGkind("Mersenne-Twister")
[13:20:15.333]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:15.333]                       inherits = FALSE)
[13:20:15.333]                   }
[13:20:15.333]                   options(future.plan = NULL)
[13:20:15.333]                   if (is.na(NA_character_)) 
[13:20:15.333]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.333]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:15.333]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:15.333]                   {
[13:20:15.333]                     future <- SequentialFuture(..., envir = envir)
[13:20:15.333]                     if (!future$lazy) 
[13:20:15.333]                       future <- run(future)
[13:20:15.333]                     invisible(future)
[13:20:15.333]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:15.333]                 }
[13:20:15.333]             }
[13:20:15.333]         }
[13:20:15.333]     })
[13:20:15.333]     if (TRUE) {
[13:20:15.333]         base::sink(type = "output", split = FALSE)
[13:20:15.333]         if (TRUE) {
[13:20:15.333]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:15.333]         }
[13:20:15.333]         else {
[13:20:15.333]             ...future.result["stdout"] <- base::list(NULL)
[13:20:15.333]         }
[13:20:15.333]         base::close(...future.stdout)
[13:20:15.333]         ...future.stdout <- NULL
[13:20:15.333]     }
[13:20:15.333]     ...future.result$conditions <- ...future.conditions
[13:20:15.333]     ...future.result$finished <- base::Sys.time()
[13:20:15.333]     ...future.result
[13:20:15.333] }
[13:20:15.352]  - Condition #80: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.335] plan(): Setting new future strategy stack:
[13:20:15.353]  - Condition #81: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.335] List of future strategies:
[13:20:15.335] 1. sequential:
[13:20:15.335]    - args: function (..., envir = parent.frame())
[13:20:15.335]    - tweaked: FALSE
[13:20:15.335]    - call: NULL
[13:20:15.353]  - Condition #82: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.335] plan(): nbrOfWorkers() = 1
[13:20:15.353]  - Condition #83: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.336] plan(): Setting new future strategy stack:
[13:20:15.353]  - Condition #84: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.336] List of future strategies:
[13:20:15.336] 1. sequential:
[13:20:15.336]    - args: function (..., envir = parent.frame())
[13:20:15.336]    - tweaked: FALSE
[13:20:15.336]    - call: NULL
[13:20:15.353]  - Condition #85: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.336] plan(): nbrOfWorkers() = 1
[13:20:15.353]  - Condition #86: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.336] SequentialFuture started (and completed)
[13:20:15.353]  - Condition #87: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.337] - Launch lazy future ... done
[13:20:15.353]  - Condition #88: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.337] run() for ‘SequentialFuture’ ... done
[13:20:15.354] signalConditions() ... done
a = 10
[13:20:15.354] getGlobalsAndPackages() ...
[13:20:15.354] Searching for globals...
[13:20:15.355] - globals found: [3] ‘{’, ‘+’, ‘a’
[13:20:15.355] Searching for globals ... DONE
[13:20:15.355] Resolving globals: FALSE
[13:20:15.355] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:15.356] The total size of the 1 globals exported for future expression (‘{; a + 1; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:20:15.356] - globals: [1] ‘a’
[13:20:15.356] 
[13:20:15.356] getGlobalsAndPackages() ... DONE
[13:20:15.356] run() for ‘Future’ ...
[13:20:15.357] - state: ‘created’
[13:20:15.357] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:15.357] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:15.357] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:15.357]   - Field: ‘label’
[13:20:15.357]   - Field: ‘local’
[13:20:15.357]   - Field: ‘owner’
[13:20:15.357]   - Field: ‘envir’
[13:20:15.357]   - Field: ‘packages’
[13:20:15.358]   - Field: ‘gc’
[13:20:15.358]   - Field: ‘conditions’
[13:20:15.358]   - Field: ‘expr’
[13:20:15.358]   - Field: ‘uuid’
[13:20:15.358]   - Field: ‘seed’
[13:20:15.358]   - Field: ‘version’
[13:20:15.358]   - Field: ‘result’
[13:20:15.358]   - Field: ‘asynchronous’
[13:20:15.358]   - Field: ‘calls’
[13:20:15.358]   - Field: ‘globals’
[13:20:15.358]   - Field: ‘stdout’
[13:20:15.359]   - Field: ‘earlySignal’
[13:20:15.359]   - Field: ‘lazy’
[13:20:15.359]   - Field: ‘state’
[13:20:15.359] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:15.359] - Launch lazy future ...
[13:20:15.359] Packages needed by the future expression (n = 0): <none>
[13:20:15.359] Packages needed by future strategies (n = 0): <none>
[13:20:15.360] {
[13:20:15.360]     {
[13:20:15.360]         {
[13:20:15.360]             ...future.startTime <- base::Sys.time()
[13:20:15.360]             {
[13:20:15.360]                 {
[13:20:15.360]                   {
[13:20:15.360]                     base::local({
[13:20:15.360]                       has_future <- base::requireNamespace("future", 
[13:20:15.360]                         quietly = TRUE)
[13:20:15.360]                       if (has_future) {
[13:20:15.360]                         ns <- base::getNamespace("future")
[13:20:15.360]                         version <- ns[[".package"]][["version"]]
[13:20:15.360]                         if (is.null(version)) 
[13:20:15.360]                           version <- utils::packageVersion("future")
[13:20:15.360]                       }
[13:20:15.360]                       else {
[13:20:15.360]                         version <- NULL
[13:20:15.360]                       }
[13:20:15.360]                       if (!has_future || version < "1.8.0") {
[13:20:15.360]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:15.360]                           "", base::R.version$version.string), 
[13:20:15.360]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:15.360]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:15.360]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:15.360]                             "release", "version")], collapse = " "), 
[13:20:15.360]                           hostname = base::Sys.info()[["nodename"]])
[13:20:15.360]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:15.360]                           info)
[13:20:15.360]                         info <- base::paste(info, collapse = "; ")
[13:20:15.360]                         if (!has_future) {
[13:20:15.360]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:15.360]                             info)
[13:20:15.360]                         }
[13:20:15.360]                         else {
[13:20:15.360]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:15.360]                             info, version)
[13:20:15.360]                         }
[13:20:15.360]                         base::stop(msg)
[13:20:15.360]                       }
[13:20:15.360]                     })
[13:20:15.360]                   }
[13:20:15.360]                   options(future.plan = NULL)
[13:20:15.360]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.360]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:15.360]                 }
[13:20:15.360]                 ...future.workdir <- getwd()
[13:20:15.360]             }
[13:20:15.360]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:15.360]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:15.360]         }
[13:20:15.360]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:15.360]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:15.360]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:15.360]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:15.360]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:15.360]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:15.360]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:15.360]             base::names(...future.oldOptions))
[13:20:15.360]     }
[13:20:15.360]     if (FALSE) {
[13:20:15.360]     }
[13:20:15.360]     else {
[13:20:15.360]         if (TRUE) {
[13:20:15.360]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:15.360]                 open = "w")
[13:20:15.360]         }
[13:20:15.360]         else {
[13:20:15.360]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:15.360]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:15.360]         }
[13:20:15.360]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:15.360]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:15.360]             base::sink(type = "output", split = FALSE)
[13:20:15.360]             base::close(...future.stdout)
[13:20:15.360]         }, add = TRUE)
[13:20:15.360]     }
[13:20:15.360]     ...future.frame <- base::sys.nframe()
[13:20:15.360]     ...future.conditions <- base::list()
[13:20:15.360]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:15.360]     if (FALSE) {
[13:20:15.360]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:15.360]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:15.360]     }
[13:20:15.360]     ...future.result <- base::tryCatch({
[13:20:15.360]         base::withCallingHandlers({
[13:20:15.360]             ...future.value <- base::withVisible(base::local({
[13:20:15.360]                 a + 1
[13:20:15.360]             }))
[13:20:15.360]             future::FutureResult(value = ...future.value$value, 
[13:20:15.360]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.360]                   ...future.rng), globalenv = if (FALSE) 
[13:20:15.360]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:15.360]                     ...future.globalenv.names))
[13:20:15.360]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:15.360]         }, condition = base::local({
[13:20:15.360]             c <- base::c
[13:20:15.360]             inherits <- base::inherits
[13:20:15.360]             invokeRestart <- base::invokeRestart
[13:20:15.360]             length <- base::length
[13:20:15.360]             list <- base::list
[13:20:15.360]             seq.int <- base::seq.int
[13:20:15.360]             signalCondition <- base::signalCondition
[13:20:15.360]             sys.calls <- base::sys.calls
[13:20:15.360]             `[[` <- base::`[[`
[13:20:15.360]             `+` <- base::`+`
[13:20:15.360]             `<<-` <- base::`<<-`
[13:20:15.360]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:15.360]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:15.360]                   3L)]
[13:20:15.360]             }
[13:20:15.360]             function(cond) {
[13:20:15.360]                 is_error <- inherits(cond, "error")
[13:20:15.360]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:15.360]                   NULL)
[13:20:15.360]                 if (is_error) {
[13:20:15.360]                   sessionInformation <- function() {
[13:20:15.360]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:15.360]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:15.360]                       search = base::search(), system = base::Sys.info())
[13:20:15.360]                   }
[13:20:15.360]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.360]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:15.360]                     cond$call), session = sessionInformation(), 
[13:20:15.360]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:15.360]                   signalCondition(cond)
[13:20:15.360]                 }
[13:20:15.360]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:15.360]                 "immediateCondition"))) {
[13:20:15.360]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:15.360]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.360]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:15.360]                   if (TRUE && !signal) {
[13:20:15.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.360]                     {
[13:20:15.360]                       inherits <- base::inherits
[13:20:15.360]                       invokeRestart <- base::invokeRestart
[13:20:15.360]                       is.null <- base::is.null
[13:20:15.360]                       muffled <- FALSE
[13:20:15.360]                       if (inherits(cond, "message")) {
[13:20:15.360]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.360]                         if (muffled) 
[13:20:15.360]                           invokeRestart("muffleMessage")
[13:20:15.360]                       }
[13:20:15.360]                       else if (inherits(cond, "warning")) {
[13:20:15.360]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.360]                         if (muffled) 
[13:20:15.360]                           invokeRestart("muffleWarning")
[13:20:15.360]                       }
[13:20:15.360]                       else if (inherits(cond, "condition")) {
[13:20:15.360]                         if (!is.null(pattern)) {
[13:20:15.360]                           computeRestarts <- base::computeRestarts
[13:20:15.360]                           grepl <- base::grepl
[13:20:15.360]                           restarts <- computeRestarts(cond)
[13:20:15.360]                           for (restart in restarts) {
[13:20:15.360]                             name <- restart$name
[13:20:15.360]                             if (is.null(name)) 
[13:20:15.360]                               next
[13:20:15.360]                             if (!grepl(pattern, name)) 
[13:20:15.360]                               next
[13:20:15.360]                             invokeRestart(restart)
[13:20:15.360]                             muffled <- TRUE
[13:20:15.360]                             break
[13:20:15.360]                           }
[13:20:15.360]                         }
[13:20:15.360]                       }
[13:20:15.360]                       invisible(muffled)
[13:20:15.360]                     }
[13:20:15.360]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.360]                   }
[13:20:15.360]                 }
[13:20:15.360]                 else {
[13:20:15.360]                   if (TRUE) {
[13:20:15.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.360]                     {
[13:20:15.360]                       inherits <- base::inherits
[13:20:15.360]                       invokeRestart <- base::invokeRestart
[13:20:15.360]                       is.null <- base::is.null
[13:20:15.360]                       muffled <- FALSE
[13:20:15.360]                       if (inherits(cond, "message")) {
[13:20:15.360]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.360]                         if (muffled) 
[13:20:15.360]                           invokeRestart("muffleMessage")
[13:20:15.360]                       }
[13:20:15.360]                       else if (inherits(cond, "warning")) {
[13:20:15.360]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.360]                         if (muffled) 
[13:20:15.360]                           invokeRestart("muffleWarning")
[13:20:15.360]                       }
[13:20:15.360]                       else if (inherits(cond, "condition")) {
[13:20:15.360]                         if (!is.null(pattern)) {
[13:20:15.360]                           computeRestarts <- base::computeRestarts
[13:20:15.360]                           grepl <- base::grepl
[13:20:15.360]                           restarts <- computeRestarts(cond)
[13:20:15.360]                           for (restart in restarts) {
[13:20:15.360]                             name <- restart$name
[13:20:15.360]                             if (is.null(name)) 
[13:20:15.360]                               next
[13:20:15.360]                             if (!grepl(pattern, name)) 
[13:20:15.360]                               next
[13:20:15.360]                             invokeRestart(restart)
[13:20:15.360]                             muffled <- TRUE
[13:20:15.360]                             break
[13:20:15.360]                           }
[13:20:15.360]                         }
[13:20:15.360]                       }
[13:20:15.360]                       invisible(muffled)
[13:20:15.360]                     }
[13:20:15.360]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.360]                   }
[13:20:15.360]                 }
[13:20:15.360]             }
[13:20:15.360]         }))
[13:20:15.360]     }, error = function(ex) {
[13:20:15.360]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:15.360]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.360]                 ...future.rng), started = ...future.startTime, 
[13:20:15.360]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:15.360]             version = "1.8"), class = "FutureResult")
[13:20:15.360]     }, finally = {
[13:20:15.360]         if (!identical(...future.workdir, getwd())) 
[13:20:15.360]             setwd(...future.workdir)
[13:20:15.360]         {
[13:20:15.360]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:15.360]                 ...future.oldOptions$nwarnings <- NULL
[13:20:15.360]             }
[13:20:15.360]             base::options(...future.oldOptions)
[13:20:15.360]             if (.Platform$OS.type == "windows") {
[13:20:15.360]                 old_names <- names(...future.oldEnvVars)
[13:20:15.360]                 envs <- base::Sys.getenv()
[13:20:15.360]                 names <- names(envs)
[13:20:15.360]                 common <- intersect(names, old_names)
[13:20:15.360]                 added <- setdiff(names, old_names)
[13:20:15.360]                 removed <- setdiff(old_names, names)
[13:20:15.360]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:15.360]                   envs[common]]
[13:20:15.360]                 NAMES <- toupper(changed)
[13:20:15.360]                 args <- list()
[13:20:15.360]                 for (kk in seq_along(NAMES)) {
[13:20:15.360]                   name <- changed[[kk]]
[13:20:15.360]                   NAME <- NAMES[[kk]]
[13:20:15.360]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.360]                     next
[13:20:15.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.360]                 }
[13:20:15.360]                 NAMES <- toupper(added)
[13:20:15.360]                 for (kk in seq_along(NAMES)) {
[13:20:15.360]                   name <- added[[kk]]
[13:20:15.360]                   NAME <- NAMES[[kk]]
[13:20:15.360]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.360]                     next
[13:20:15.360]                   args[[name]] <- ""
[13:20:15.360]                 }
[13:20:15.360]                 NAMES <- toupper(removed)
[13:20:15.360]                 for (kk in seq_along(NAMES)) {
[13:20:15.360]                   name <- removed[[kk]]
[13:20:15.360]                   NAME <- NAMES[[kk]]
[13:20:15.360]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.360]                     next
[13:20:15.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.360]                 }
[13:20:15.360]                 if (length(args) > 0) 
[13:20:15.360]                   base::do.call(base::Sys.setenv, args = args)
[13:20:15.360]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:15.360]             }
[13:20:15.360]             else {
[13:20:15.360]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:15.360]             }
[13:20:15.360]             {
[13:20:15.360]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:15.360]                   0L) {
[13:20:15.360]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:15.360]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:15.360]                   base::options(opts)
[13:20:15.360]                 }
[13:20:15.360]                 {
[13:20:15.360]                   {
[13:20:15.360]                     NULL
[13:20:15.360]                     RNGkind("Mersenne-Twister")
[13:20:15.360]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:15.360]                       inherits = FALSE)
[13:20:15.360]                   }
[13:20:15.360]                   options(future.plan = NULL)
[13:20:15.360]                   if (is.na(NA_character_)) 
[13:20:15.360]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.360]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:15.360]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:15.360]                   {
[13:20:15.360]                     future <- SequentialFuture(..., envir = envir)
[13:20:15.360]                     if (!future$lazy) 
[13:20:15.360]                       future <- run(future)
[13:20:15.360]                     invisible(future)
[13:20:15.360]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:15.360]                 }
[13:20:15.360]             }
[13:20:15.360]         }
[13:20:15.360]     })
[13:20:15.360]     if (TRUE) {
[13:20:15.360]         base::sink(type = "output", split = FALSE)
[13:20:15.360]         if (TRUE) {
[13:20:15.360]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:15.360]         }
[13:20:15.360]         else {
[13:20:15.360]             ...future.result["stdout"] <- base::list(NULL)
[13:20:15.360]         }
[13:20:15.360]         base::close(...future.stdout)
[13:20:15.360]         ...future.stdout <- NULL
[13:20:15.360]     }
[13:20:15.360]     ...future.result$conditions <- ...future.conditions
[13:20:15.360]     ...future.result$finished <- base::Sys.time()
[13:20:15.360]     ...future.result
[13:20:15.360] }
[13:20:15.361] assign_globals() ...
[13:20:15.361] List of 1
[13:20:15.361]  $ a: num 10
[13:20:15.361]  - attr(*, "where")=List of 1
[13:20:15.361]   ..$ a:<environment: R_EmptyEnv> 
[13:20:15.361]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:15.361]  - attr(*, "resolved")= logi FALSE
[13:20:15.361]  - attr(*, "total_size")= num 56
[13:20:15.361]  - attr(*, "already-done")= logi TRUE
[13:20:15.364] - copied ‘a’ to environment
[13:20:15.364] assign_globals() ... done
[13:20:15.364] plan(): Setting new future strategy stack:
[13:20:15.364] List of future strategies:
[13:20:15.364] 1. sequential:
[13:20:15.364]    - args: function (..., envir = parent.frame())
[13:20:15.364]    - tweaked: FALSE
[13:20:15.364]    - call: NULL
[13:20:15.365] plan(): nbrOfWorkers() = 1
[13:20:15.365] plan(): Setting new future strategy stack:
[13:20:15.366] List of future strategies:
[13:20:15.366] 1. sequential:
[13:20:15.366]    - args: function (..., envir = parent.frame())
[13:20:15.366]    - tweaked: FALSE
[13:20:15.366]    - call: plan(strategy)
[13:20:15.366] plan(): nbrOfWorkers() = 1
[13:20:15.366] SequentialFuture started (and completed)
[13:20:15.366] - Launch lazy future ... done
[13:20:15.366] run() for ‘SequentialFuture’ ... done
b = 11
*** %<-% with ‘sequential’ futures ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
*** %<-% with ‘multicore’ futures ...
[13:20:15.374] plan(): Setting new future strategy stack:
[13:20:15.374] List of future strategies:
[13:20:15.374] 1. multicore:
[13:20:15.374]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:15.374]    - tweaked: FALSE
[13:20:15.374]    - call: plan(strategy)
[13:20:15.378] plan(): nbrOfWorkers() = 2
** Future evaluation without globals
[13:20:15.378] getGlobalsAndPackages() ...
[13:20:15.379] Searching for globals...
[13:20:15.379] - globals found: [2] ‘{’, ‘<-’
[13:20:15.380] Searching for globals ... DONE
[13:20:15.380] Resolving globals: FALSE
[13:20:15.380] 
[13:20:15.380] 
[13:20:15.380] getGlobalsAndPackages() ... DONE
[13:20:15.380] run() for ‘Future’ ...
[13:20:15.380] - state: ‘created’
[13:20:15.381] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:15.384] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:15.384] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:15.384]   - Field: ‘label’
[13:20:15.384]   - Field: ‘local’
[13:20:15.384]   - Field: ‘owner’
[13:20:15.385]   - Field: ‘envir’
[13:20:15.385]   - Field: ‘workers’
[13:20:15.385]   - Field: ‘packages’
[13:20:15.385]   - Field: ‘gc’
[13:20:15.385]   - Field: ‘job’
[13:20:15.385]   - Field: ‘conditions’
[13:20:15.385]   - Field: ‘expr’
[13:20:15.385]   - Field: ‘uuid’
[13:20:15.385]   - Field: ‘seed’
[13:20:15.385]   - Field: ‘version’
[13:20:15.386]   - Field: ‘result’
[13:20:15.386]   - Field: ‘asynchronous’
[13:20:15.386]   - Field: ‘calls’
[13:20:15.386]   - Field: ‘globals’
[13:20:15.386]   - Field: ‘stdout’
[13:20:15.386]   - Field: ‘earlySignal’
[13:20:15.386]   - Field: ‘lazy’
[13:20:15.386]   - Field: ‘state’
[13:20:15.386] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:15.386] - Launch lazy future ...
[13:20:15.387] Packages needed by the future expression (n = 0): <none>
[13:20:15.387] Packages needed by future strategies (n = 0): <none>
[13:20:15.388] {
[13:20:15.388]     {
[13:20:15.388]         {
[13:20:15.388]             ...future.startTime <- base::Sys.time()
[13:20:15.388]             {
[13:20:15.388]                 {
[13:20:15.388]                   {
[13:20:15.388]                     {
[13:20:15.388]                       base::local({
[13:20:15.388]                         has_future <- base::requireNamespace("future", 
[13:20:15.388]                           quietly = TRUE)
[13:20:15.388]                         if (has_future) {
[13:20:15.388]                           ns <- base::getNamespace("future")
[13:20:15.388]                           version <- ns[[".package"]][["version"]]
[13:20:15.388]                           if (is.null(version)) 
[13:20:15.388]                             version <- utils::packageVersion("future")
[13:20:15.388]                         }
[13:20:15.388]                         else {
[13:20:15.388]                           version <- NULL
[13:20:15.388]                         }
[13:20:15.388]                         if (!has_future || version < "1.8.0") {
[13:20:15.388]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:15.388]                             "", base::R.version$version.string), 
[13:20:15.388]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:15.388]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:15.388]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:15.388]                               "release", "version")], collapse = " "), 
[13:20:15.388]                             hostname = base::Sys.info()[["nodename"]])
[13:20:15.388]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:15.388]                             info)
[13:20:15.388]                           info <- base::paste(info, collapse = "; ")
[13:20:15.388]                           if (!has_future) {
[13:20:15.388]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:15.388]                               info)
[13:20:15.388]                           }
[13:20:15.388]                           else {
[13:20:15.388]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:15.388]                               info, version)
[13:20:15.388]                           }
[13:20:15.388]                           base::stop(msg)
[13:20:15.388]                         }
[13:20:15.388]                       })
[13:20:15.388]                     }
[13:20:15.388]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:15.388]                     base::options(mc.cores = 1L)
[13:20:15.388]                   }
[13:20:15.388]                   options(future.plan = NULL)
[13:20:15.388]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.388]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:15.388]                 }
[13:20:15.388]                 ...future.workdir <- getwd()
[13:20:15.388]             }
[13:20:15.388]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:15.388]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:15.388]         }
[13:20:15.388]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:15.388]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:15.388]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:15.388]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:15.388]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:15.388]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:15.388]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:15.388]             base::names(...future.oldOptions))
[13:20:15.388]     }
[13:20:15.388]     if (FALSE) {
[13:20:15.388]     }
[13:20:15.388]     else {
[13:20:15.388]         if (TRUE) {
[13:20:15.388]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:15.388]                 open = "w")
[13:20:15.388]         }
[13:20:15.388]         else {
[13:20:15.388]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:15.388]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:15.388]         }
[13:20:15.388]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:15.388]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:15.388]             base::sink(type = "output", split = FALSE)
[13:20:15.388]             base::close(...future.stdout)
[13:20:15.388]         }, add = TRUE)
[13:20:15.388]     }
[13:20:15.388]     ...future.frame <- base::sys.nframe()
[13:20:15.388]     ...future.conditions <- base::list()
[13:20:15.388]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:15.388]     if (FALSE) {
[13:20:15.388]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:15.388]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:15.388]     }
[13:20:15.388]     ...future.result <- base::tryCatch({
[13:20:15.388]         base::withCallingHandlers({
[13:20:15.388]             ...future.value <- base::withVisible(base::local({
[13:20:15.388]                 withCallingHandlers({
[13:20:15.388]                   {
[13:20:15.388]                     x <- 1
[13:20:15.388]                   }
[13:20:15.388]                 }, immediateCondition = function(cond) {
[13:20:15.388]                   save_rds <- function (object, pathname, ...) 
[13:20:15.388]                   {
[13:20:15.388]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:15.388]                     if (file_test("-f", pathname_tmp)) {
[13:20:15.388]                       fi_tmp <- file.info(pathname_tmp)
[13:20:15.388]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:15.388]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:15.388]                         fi_tmp[["mtime"]])
[13:20:15.388]                     }
[13:20:15.388]                     tryCatch({
[13:20:15.388]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:15.388]                     }, error = function(ex) {
[13:20:15.388]                       msg <- conditionMessage(ex)
[13:20:15.388]                       fi_tmp <- file.info(pathname_tmp)
[13:20:15.388]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:15.388]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:15.388]                         fi_tmp[["mtime"]], msg)
[13:20:15.388]                       ex$message <- msg
[13:20:15.388]                       stop(ex)
[13:20:15.388]                     })
[13:20:15.388]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:15.388]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:15.388]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:15.388]                       fi_tmp <- file.info(pathname_tmp)
[13:20:15.388]                       fi <- file.info(pathname)
[13:20:15.388]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:15.388]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:15.388]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:15.388]                         fi[["size"]], fi[["mtime"]])
[13:20:15.388]                       stop(msg)
[13:20:15.388]                     }
[13:20:15.388]                     invisible(pathname)
[13:20:15.388]                   }
[13:20:15.388]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:15.388]                     rootPath = tempdir()) 
[13:20:15.388]                   {
[13:20:15.388]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:15.388]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:15.388]                       tmpdir = path, fileext = ".rds")
[13:20:15.388]                     save_rds(obj, file)
[13:20:15.388]                   }
[13:20:15.388]                   saveImmediateCondition(cond, path = "/tmp/RtmpakA0rS/.future/immediateConditions")
[13:20:15.388]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.388]                   {
[13:20:15.388]                     inherits <- base::inherits
[13:20:15.388]                     invokeRestart <- base::invokeRestart
[13:20:15.388]                     is.null <- base::is.null
[13:20:15.388]                     muffled <- FALSE
[13:20:15.388]                     if (inherits(cond, "message")) {
[13:20:15.388]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:15.388]                       if (muffled) 
[13:20:15.388]                         invokeRestart("muffleMessage")
[13:20:15.388]                     }
[13:20:15.388]                     else if (inherits(cond, "warning")) {
[13:20:15.388]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:15.388]                       if (muffled) 
[13:20:15.388]                         invokeRestart("muffleWarning")
[13:20:15.388]                     }
[13:20:15.388]                     else if (inherits(cond, "condition")) {
[13:20:15.388]                       if (!is.null(pattern)) {
[13:20:15.388]                         computeRestarts <- base::computeRestarts
[13:20:15.388]                         grepl <- base::grepl
[13:20:15.388]                         restarts <- computeRestarts(cond)
[13:20:15.388]                         for (restart in restarts) {
[13:20:15.388]                           name <- restart$name
[13:20:15.388]                           if (is.null(name)) 
[13:20:15.388]                             next
[13:20:15.388]                           if (!grepl(pattern, name)) 
[13:20:15.388]                             next
[13:20:15.388]                           invokeRestart(restart)
[13:20:15.388]                           muffled <- TRUE
[13:20:15.388]                           break
[13:20:15.388]                         }
[13:20:15.388]                       }
[13:20:15.388]                     }
[13:20:15.388]                     invisible(muffled)
[13:20:15.388]                   }
[13:20:15.388]                   muffleCondition(cond)
[13:20:15.388]                 })
[13:20:15.388]             }))
[13:20:15.388]             future::FutureResult(value = ...future.value$value, 
[13:20:15.388]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.388]                   ...future.rng), globalenv = if (FALSE) 
[13:20:15.388]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:15.388]                     ...future.globalenv.names))
[13:20:15.388]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:15.388]         }, condition = base::local({
[13:20:15.388]             c <- base::c
[13:20:15.388]             inherits <- base::inherits
[13:20:15.388]             invokeRestart <- base::invokeRestart
[13:20:15.388]             length <- base::length
[13:20:15.388]             list <- base::list
[13:20:15.388]             seq.int <- base::seq.int
[13:20:15.388]             signalCondition <- base::signalCondition
[13:20:15.388]             sys.calls <- base::sys.calls
[13:20:15.388]             `[[` <- base::`[[`
[13:20:15.388]             `+` <- base::`+`
[13:20:15.388]             `<<-` <- base::`<<-`
[13:20:15.388]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:15.388]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:15.388]                   3L)]
[13:20:15.388]             }
[13:20:15.388]             function(cond) {
[13:20:15.388]                 is_error <- inherits(cond, "error")
[13:20:15.388]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:15.388]                   NULL)
[13:20:15.388]                 if (is_error) {
[13:20:15.388]                   sessionInformation <- function() {
[13:20:15.388]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:15.388]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:15.388]                       search = base::search(), system = base::Sys.info())
[13:20:15.388]                   }
[13:20:15.388]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.388]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:15.388]                     cond$call), session = sessionInformation(), 
[13:20:15.388]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:15.388]                   signalCondition(cond)
[13:20:15.388]                 }
[13:20:15.388]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:15.388]                 "immediateCondition"))) {
[13:20:15.388]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:15.388]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.388]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:15.388]                   if (TRUE && !signal) {
[13:20:15.388]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.388]                     {
[13:20:15.388]                       inherits <- base::inherits
[13:20:15.388]                       invokeRestart <- base::invokeRestart
[13:20:15.388]                       is.null <- base::is.null
[13:20:15.388]                       muffled <- FALSE
[13:20:15.388]                       if (inherits(cond, "message")) {
[13:20:15.388]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.388]                         if (muffled) 
[13:20:15.388]                           invokeRestart("muffleMessage")
[13:20:15.388]                       }
[13:20:15.388]                       else if (inherits(cond, "warning")) {
[13:20:15.388]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.388]                         if (muffled) 
[13:20:15.388]                           invokeRestart("muffleWarning")
[13:20:15.388]                       }
[13:20:15.388]                       else if (inherits(cond, "condition")) {
[13:20:15.388]                         if (!is.null(pattern)) {
[13:20:15.388]                           computeRestarts <- base::computeRestarts
[13:20:15.388]                           grepl <- base::grepl
[13:20:15.388]                           restarts <- computeRestarts(cond)
[13:20:15.388]                           for (restart in restarts) {
[13:20:15.388]                             name <- restart$name
[13:20:15.388]                             if (is.null(name)) 
[13:20:15.388]                               next
[13:20:15.388]                             if (!grepl(pattern, name)) 
[13:20:15.388]                               next
[13:20:15.388]                             invokeRestart(restart)
[13:20:15.388]                             muffled <- TRUE
[13:20:15.388]                             break
[13:20:15.388]                           }
[13:20:15.388]                         }
[13:20:15.388]                       }
[13:20:15.388]                       invisible(muffled)
[13:20:15.388]                     }
[13:20:15.388]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.388]                   }
[13:20:15.388]                 }
[13:20:15.388]                 else {
[13:20:15.388]                   if (TRUE) {
[13:20:15.388]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.388]                     {
[13:20:15.388]                       inherits <- base::inherits
[13:20:15.388]                       invokeRestart <- base::invokeRestart
[13:20:15.388]                       is.null <- base::is.null
[13:20:15.388]                       muffled <- FALSE
[13:20:15.388]                       if (inherits(cond, "message")) {
[13:20:15.388]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.388]                         if (muffled) 
[13:20:15.388]                           invokeRestart("muffleMessage")
[13:20:15.388]                       }
[13:20:15.388]                       else if (inherits(cond, "warning")) {
[13:20:15.388]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.388]                         if (muffled) 
[13:20:15.388]                           invokeRestart("muffleWarning")
[13:20:15.388]                       }
[13:20:15.388]                       else if (inherits(cond, "condition")) {
[13:20:15.388]                         if (!is.null(pattern)) {
[13:20:15.388]                           computeRestarts <- base::computeRestarts
[13:20:15.388]                           grepl <- base::grepl
[13:20:15.388]                           restarts <- computeRestarts(cond)
[13:20:15.388]                           for (restart in restarts) {
[13:20:15.388]                             name <- restart$name
[13:20:15.388]                             if (is.null(name)) 
[13:20:15.388]                               next
[13:20:15.388]                             if (!grepl(pattern, name)) 
[13:20:15.388]                               next
[13:20:15.388]                             invokeRestart(restart)
[13:20:15.388]                             muffled <- TRUE
[13:20:15.388]                             break
[13:20:15.388]                           }
[13:20:15.388]                         }
[13:20:15.388]                       }
[13:20:15.388]                       invisible(muffled)
[13:20:15.388]                     }
[13:20:15.388]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.388]                   }
[13:20:15.388]                 }
[13:20:15.388]             }
[13:20:15.388]         }))
[13:20:15.388]     }, error = function(ex) {
[13:20:15.388]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:15.388]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.388]                 ...future.rng), started = ...future.startTime, 
[13:20:15.388]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:15.388]             version = "1.8"), class = "FutureResult")
[13:20:15.388]     }, finally = {
[13:20:15.388]         if (!identical(...future.workdir, getwd())) 
[13:20:15.388]             setwd(...future.workdir)
[13:20:15.388]         {
[13:20:15.388]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:15.388]                 ...future.oldOptions$nwarnings <- NULL
[13:20:15.388]             }
[13:20:15.388]             base::options(...future.oldOptions)
[13:20:15.388]             if (.Platform$OS.type == "windows") {
[13:20:15.388]                 old_names <- names(...future.oldEnvVars)
[13:20:15.388]                 envs <- base::Sys.getenv()
[13:20:15.388]                 names <- names(envs)
[13:20:15.388]                 common <- intersect(names, old_names)
[13:20:15.388]                 added <- setdiff(names, old_names)
[13:20:15.388]                 removed <- setdiff(old_names, names)
[13:20:15.388]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:15.388]                   envs[common]]
[13:20:15.388]                 NAMES <- toupper(changed)
[13:20:15.388]                 args <- list()
[13:20:15.388]                 for (kk in seq_along(NAMES)) {
[13:20:15.388]                   name <- changed[[kk]]
[13:20:15.388]                   NAME <- NAMES[[kk]]
[13:20:15.388]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.388]                     next
[13:20:15.388]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.388]                 }
[13:20:15.388]                 NAMES <- toupper(added)
[13:20:15.388]                 for (kk in seq_along(NAMES)) {
[13:20:15.388]                   name <- added[[kk]]
[13:20:15.388]                   NAME <- NAMES[[kk]]
[13:20:15.388]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.388]                     next
[13:20:15.388]                   args[[name]] <- ""
[13:20:15.388]                 }
[13:20:15.388]                 NAMES <- toupper(removed)
[13:20:15.388]                 for (kk in seq_along(NAMES)) {
[13:20:15.388]                   name <- removed[[kk]]
[13:20:15.388]                   NAME <- NAMES[[kk]]
[13:20:15.388]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.388]                     next
[13:20:15.388]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.388]                 }
[13:20:15.388]                 if (length(args) > 0) 
[13:20:15.388]                   base::do.call(base::Sys.setenv, args = args)
[13:20:15.388]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:15.388]             }
[13:20:15.388]             else {
[13:20:15.388]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:15.388]             }
[13:20:15.388]             {
[13:20:15.388]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:15.388]                   0L) {
[13:20:15.388]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:15.388]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:15.388]                   base::options(opts)
[13:20:15.388]                 }
[13:20:15.388]                 {
[13:20:15.388]                   {
[13:20:15.388]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:15.388]                     NULL
[13:20:15.388]                   }
[13:20:15.388]                   options(future.plan = NULL)
[13:20:15.388]                   if (is.na(NA_character_)) 
[13:20:15.388]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.388]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:15.388]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:15.388]                     envir = parent.frame()) 
[13:20:15.388]                   {
[13:20:15.388]                     default_workers <- missing(workers)
[13:20:15.388]                     if (is.function(workers)) 
[13:20:15.388]                       workers <- workers()
[13:20:15.388]                     workers <- structure(as.integer(workers), 
[13:20:15.388]                       class = class(workers))
[13:20:15.388]                     stop_if_not(is.finite(workers), workers >= 
[13:20:15.388]                       1L)
[13:20:15.388]                     if ((workers == 1L && !inherits(workers, 
[13:20:15.388]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:15.388]                       if (default_workers) 
[13:20:15.388]                         supportsMulticore(warn = TRUE)
[13:20:15.388]                       return(sequential(..., envir = envir))
[13:20:15.388]                     }
[13:20:15.388]                     oopts <- options(mc.cores = workers)
[13:20:15.388]                     on.exit(options(oopts))
[13:20:15.388]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:15.388]                       envir = envir)
[13:20:15.388]                     if (!future$lazy) 
[13:20:15.388]                       future <- run(future)
[13:20:15.388]                     invisible(future)
[13:20:15.388]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:15.388]                 }
[13:20:15.388]             }
[13:20:15.388]         }
[13:20:15.388]     })
[13:20:15.388]     if (TRUE) {
[13:20:15.388]         base::sink(type = "output", split = FALSE)
[13:20:15.388]         if (TRUE) {
[13:20:15.388]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:15.388]         }
[13:20:15.388]         else {
[13:20:15.388]             ...future.result["stdout"] <- base::list(NULL)
[13:20:15.388]         }
[13:20:15.388]         base::close(...future.stdout)
[13:20:15.388]         ...future.stdout <- NULL
[13:20:15.388]     }
[13:20:15.388]     ...future.result$conditions <- ...future.conditions
[13:20:15.388]     ...future.result$finished <- base::Sys.time()
[13:20:15.388]     ...future.result
[13:20:15.388] }
[13:20:15.390] requestCore(): workers = 2
[13:20:15.393] MulticoreFuture started
[13:20:15.394] - Launch lazy future ... done
[13:20:15.394] run() for ‘MulticoreFuture’ ... done
[13:20:15.394] plan(): Setting new future strategy stack:
[13:20:15.395] List of future strategies:
[13:20:15.395] 1. sequential:
[13:20:15.395]    - args: function (..., envir = parent.frame())
[13:20:15.395]    - tweaked: FALSE
[13:20:15.395]    - call: NULL
[13:20:15.396] plan(): nbrOfWorkers() = 1
[13:20:15.398] plan(): Setting new future strategy stack:
[13:20:15.398] List of future strategies:
[13:20:15.398] 1. multicore:
[13:20:15.398]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:15.398]    - tweaked: FALSE
[13:20:15.398]    - call: plan(strategy)
[13:20:15.404] plan(): nbrOfWorkers() = 2
** Future evaluation with globals
[13:20:15.409] getGlobalsAndPackages() ...
[13:20:15.409] Searching for globals...
[13:20:15.410] - globals found: [3] ‘{’, ‘<-’, ‘a’
[13:20:15.410] Searching for globals ... DONE
[13:20:15.411] Resolving globals: FALSE
[13:20:15.411] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:15.411] The total size of the 1 globals exported for future expression (‘{; x <- a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:20:15.412] - globals: [1] ‘a’
[13:20:15.412] 
[13:20:15.412] getGlobalsAndPackages() ... DONE
[13:20:15.412] run() for ‘Future’ ...
[13:20:15.412] - state: ‘created’
[13:20:15.412] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:15.416] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:15.417] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:15.417]   - Field: ‘label’
[13:20:15.417]   - Field: ‘local’
[13:20:15.417]   - Field: ‘owner’
[13:20:15.417]   - Field: ‘envir’
[13:20:15.417]   - Field: ‘workers’
[13:20:15.417]   - Field: ‘packages’
[13:20:15.417]   - Field: ‘gc’
[13:20:15.417]   - Field: ‘job’
[13:20:15.418]   - Field: ‘conditions’
[13:20:15.418]   - Field: ‘expr’
[13:20:15.418]   - Field: ‘uuid’
[13:20:15.418]   - Field: ‘seed’
[13:20:15.418]   - Field: ‘version’
[13:20:15.418]   - Field: ‘result’
[13:20:15.418]   - Field: ‘asynchronous’
[13:20:15.418]   - Field: ‘calls’
[13:20:15.418]   - Field: ‘globals’
[13:20:15.419]   - Field: ‘stdout’
[13:20:15.419]   - Field: ‘earlySignal’
[13:20:15.421]   - Field: ‘lazy’
[13:20:15.421]   - Field: ‘state’
[13:20:15.422] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:15.422] - Launch lazy future ...
[13:20:15.422] Packages needed by the future expression (n = 0): <none>
[13:20:15.422] Packages needed by future strategies (n = 0): <none>
[13:20:15.423] {
[13:20:15.423]     {
[13:20:15.423]         {
[13:20:15.423]             ...future.startTime <- base::Sys.time()
[13:20:15.423]             {
[13:20:15.423]                 {
[13:20:15.423]                   {
[13:20:15.423]                     {
[13:20:15.423]                       base::local({
[13:20:15.423]                         has_future <- base::requireNamespace("future", 
[13:20:15.423]                           quietly = TRUE)
[13:20:15.423]                         if (has_future) {
[13:20:15.423]                           ns <- base::getNamespace("future")
[13:20:15.423]                           version <- ns[[".package"]][["version"]]
[13:20:15.423]                           if (is.null(version)) 
[13:20:15.423]                             version <- utils::packageVersion("future")
[13:20:15.423]                         }
[13:20:15.423]                         else {
[13:20:15.423]                           version <- NULL
[13:20:15.423]                         }
[13:20:15.423]                         if (!has_future || version < "1.8.0") {
[13:20:15.423]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:15.423]                             "", base::R.version$version.string), 
[13:20:15.423]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:15.423]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:15.423]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:15.423]                               "release", "version")], collapse = " "), 
[13:20:15.423]                             hostname = base::Sys.info()[["nodename"]])
[13:20:15.423]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:15.423]                             info)
[13:20:15.423]                           info <- base::paste(info, collapse = "; ")
[13:20:15.423]                           if (!has_future) {
[13:20:15.423]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:15.423]                               info)
[13:20:15.423]                           }
[13:20:15.423]                           else {
[13:20:15.423]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:15.423]                               info, version)
[13:20:15.423]                           }
[13:20:15.423]                           base::stop(msg)
[13:20:15.423]                         }
[13:20:15.423]                       })
[13:20:15.423]                     }
[13:20:15.423]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:15.423]                     base::options(mc.cores = 1L)
[13:20:15.423]                   }
[13:20:15.423]                   options(future.plan = NULL)
[13:20:15.423]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.423]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:15.423]                 }
[13:20:15.423]                 ...future.workdir <- getwd()
[13:20:15.423]             }
[13:20:15.423]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:15.423]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:15.423]         }
[13:20:15.423]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:15.423]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:15.423]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:15.423]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:15.423]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:15.423]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:15.423]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:15.423]             base::names(...future.oldOptions))
[13:20:15.423]     }
[13:20:15.423]     if (FALSE) {
[13:20:15.423]     }
[13:20:15.423]     else {
[13:20:15.423]         if (TRUE) {
[13:20:15.423]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:15.423]                 open = "w")
[13:20:15.423]         }
[13:20:15.423]         else {
[13:20:15.423]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:15.423]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:15.423]         }
[13:20:15.423]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:15.423]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:15.423]             base::sink(type = "output", split = FALSE)
[13:20:15.423]             base::close(...future.stdout)
[13:20:15.423]         }, add = TRUE)
[13:20:15.423]     }
[13:20:15.423]     ...future.frame <- base::sys.nframe()
[13:20:15.423]     ...future.conditions <- base::list()
[13:20:15.423]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:15.423]     if (FALSE) {
[13:20:15.423]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:15.423]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:15.423]     }
[13:20:15.423]     ...future.result <- base::tryCatch({
[13:20:15.423]         base::withCallingHandlers({
[13:20:15.423]             ...future.value <- base::withVisible(base::local({
[13:20:15.423]                 withCallingHandlers({
[13:20:15.423]                   {
[13:20:15.423]                     x <- a
[13:20:15.423]                   }
[13:20:15.423]                 }, immediateCondition = function(cond) {
[13:20:15.423]                   save_rds <- function (object, pathname, ...) 
[13:20:15.423]                   {
[13:20:15.423]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:15.423]                     if (file_test("-f", pathname_tmp)) {
[13:20:15.423]                       fi_tmp <- file.info(pathname_tmp)
[13:20:15.423]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:15.423]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:15.423]                         fi_tmp[["mtime"]])
[13:20:15.423]                     }
[13:20:15.423]                     tryCatch({
[13:20:15.423]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:15.423]                     }, error = function(ex) {
[13:20:15.423]                       msg <- conditionMessage(ex)
[13:20:15.423]                       fi_tmp <- file.info(pathname_tmp)
[13:20:15.423]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:15.423]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:15.423]                         fi_tmp[["mtime"]], msg)
[13:20:15.423]                       ex$message <- msg
[13:20:15.423]                       stop(ex)
[13:20:15.423]                     })
[13:20:15.423]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:15.423]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:15.423]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:15.423]                       fi_tmp <- file.info(pathname_tmp)
[13:20:15.423]                       fi <- file.info(pathname)
[13:20:15.423]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:15.423]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:15.423]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:15.423]                         fi[["size"]], fi[["mtime"]])
[13:20:15.423]                       stop(msg)
[13:20:15.423]                     }
[13:20:15.423]                     invisible(pathname)
[13:20:15.423]                   }
[13:20:15.423]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:15.423]                     rootPath = tempdir()) 
[13:20:15.423]                   {
[13:20:15.423]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:15.423]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:15.423]                       tmpdir = path, fileext = ".rds")
[13:20:15.423]                     save_rds(obj, file)
[13:20:15.423]                   }
[13:20:15.423]                   saveImmediateCondition(cond, path = "/tmp/RtmpakA0rS/.future/immediateConditions")
[13:20:15.423]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.423]                   {
[13:20:15.423]                     inherits <- base::inherits
[13:20:15.423]                     invokeRestart <- base::invokeRestart
[13:20:15.423]                     is.null <- base::is.null
[13:20:15.423]                     muffled <- FALSE
[13:20:15.423]                     if (inherits(cond, "message")) {
[13:20:15.423]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:15.423]                       if (muffled) 
[13:20:15.423]                         invokeRestart("muffleMessage")
[13:20:15.423]                     }
[13:20:15.423]                     else if (inherits(cond, "warning")) {
[13:20:15.423]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:15.423]                       if (muffled) 
[13:20:15.423]                         invokeRestart("muffleWarning")
[13:20:15.423]                     }
[13:20:15.423]                     else if (inherits(cond, "condition")) {
[13:20:15.423]                       if (!is.null(pattern)) {
[13:20:15.423]                         computeRestarts <- base::computeRestarts
[13:20:15.423]                         grepl <- base::grepl
[13:20:15.423]                         restarts <- computeRestarts(cond)
[13:20:15.423]                         for (restart in restarts) {
[13:20:15.423]                           name <- restart$name
[13:20:15.423]                           if (is.null(name)) 
[13:20:15.423]                             next
[13:20:15.423]                           if (!grepl(pattern, name)) 
[13:20:15.423]                             next
[13:20:15.423]                           invokeRestart(restart)
[13:20:15.423]                           muffled <- TRUE
[13:20:15.423]                           break
[13:20:15.423]                         }
[13:20:15.423]                       }
[13:20:15.423]                     }
[13:20:15.423]                     invisible(muffled)
[13:20:15.423]                   }
[13:20:15.423]                   muffleCondition(cond)
[13:20:15.423]                 })
[13:20:15.423]             }))
[13:20:15.423]             future::FutureResult(value = ...future.value$value, 
[13:20:15.423]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.423]                   ...future.rng), globalenv = if (FALSE) 
[13:20:15.423]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:15.423]                     ...future.globalenv.names))
[13:20:15.423]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:15.423]         }, condition = base::local({
[13:20:15.423]             c <- base::c
[13:20:15.423]             inherits <- base::inherits
[13:20:15.423]             invokeRestart <- base::invokeRestart
[13:20:15.423]             length <- base::length
[13:20:15.423]             list <- base::list
[13:20:15.423]             seq.int <- base::seq.int
[13:20:15.423]             signalCondition <- base::signalCondition
[13:20:15.423]             sys.calls <- base::sys.calls
[13:20:15.423]             `[[` <- base::`[[`
[13:20:15.423]             `+` <- base::`+`
[13:20:15.423]             `<<-` <- base::`<<-`
[13:20:15.423]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:15.423]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:15.423]                   3L)]
[13:20:15.423]             }
[13:20:15.423]             function(cond) {
[13:20:15.423]                 is_error <- inherits(cond, "error")
[13:20:15.423]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:15.423]                   NULL)
[13:20:15.423]                 if (is_error) {
[13:20:15.423]                   sessionInformation <- function() {
[13:20:15.423]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:15.423]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:15.423]                       search = base::search(), system = base::Sys.info())
[13:20:15.423]                   }
[13:20:15.423]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.423]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:15.423]                     cond$call), session = sessionInformation(), 
[13:20:15.423]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:15.423]                   signalCondition(cond)
[13:20:15.423]                 }
[13:20:15.423]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:15.423]                 "immediateCondition"))) {
[13:20:15.423]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:15.423]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.423]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:15.423]                   if (TRUE && !signal) {
[13:20:15.423]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.423]                     {
[13:20:15.423]                       inherits <- base::inherits
[13:20:15.423]                       invokeRestart <- base::invokeRestart
[13:20:15.423]                       is.null <- base::is.null
[13:20:15.423]                       muffled <- FALSE
[13:20:15.423]                       if (inherits(cond, "message")) {
[13:20:15.423]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.423]                         if (muffled) 
[13:20:15.423]                           invokeRestart("muffleMessage")
[13:20:15.423]                       }
[13:20:15.423]                       else if (inherits(cond, "warning")) {
[13:20:15.423]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.423]                         if (muffled) 
[13:20:15.423]                           invokeRestart("muffleWarning")
[13:20:15.423]                       }
[13:20:15.423]                       else if (inherits(cond, "condition")) {
[13:20:15.423]                         if (!is.null(pattern)) {
[13:20:15.423]                           computeRestarts <- base::computeRestarts
[13:20:15.423]                           grepl <- base::grepl
[13:20:15.423]                           restarts <- computeRestarts(cond)
[13:20:15.423]                           for (restart in restarts) {
[13:20:15.423]                             name <- restart$name
[13:20:15.423]                             if (is.null(name)) 
[13:20:15.423]                               next
[13:20:15.423]                             if (!grepl(pattern, name)) 
[13:20:15.423]                               next
[13:20:15.423]                             invokeRestart(restart)
[13:20:15.423]                             muffled <- TRUE
[13:20:15.423]                             break
[13:20:15.423]                           }
[13:20:15.423]                         }
[13:20:15.423]                       }
[13:20:15.423]                       invisible(muffled)
[13:20:15.423]                     }
[13:20:15.423]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.423]                   }
[13:20:15.423]                 }
[13:20:15.423]                 else {
[13:20:15.423]                   if (TRUE) {
[13:20:15.423]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.423]                     {
[13:20:15.423]                       inherits <- base::inherits
[13:20:15.423]                       invokeRestart <- base::invokeRestart
[13:20:15.423]                       is.null <- base::is.null
[13:20:15.423]                       muffled <- FALSE
[13:20:15.423]                       if (inherits(cond, "message")) {
[13:20:15.423]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.423]                         if (muffled) 
[13:20:15.423]                           invokeRestart("muffleMessage")
[13:20:15.423]                       }
[13:20:15.423]                       else if (inherits(cond, "warning")) {
[13:20:15.423]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.423]                         if (muffled) 
[13:20:15.423]                           invokeRestart("muffleWarning")
[13:20:15.423]                       }
[13:20:15.423]                       else if (inherits(cond, "condition")) {
[13:20:15.423]                         if (!is.null(pattern)) {
[13:20:15.423]                           computeRestarts <- base::computeRestarts
[13:20:15.423]                           grepl <- base::grepl
[13:20:15.423]                           restarts <- computeRestarts(cond)
[13:20:15.423]                           for (restart in restarts) {
[13:20:15.423]                             name <- restart$name
[13:20:15.423]                             if (is.null(name)) 
[13:20:15.423]                               next
[13:20:15.423]                             if (!grepl(pattern, name)) 
[13:20:15.423]                               next
[13:20:15.423]                             invokeRestart(restart)
[13:20:15.423]                             muffled <- TRUE
[13:20:15.423]                             break
[13:20:15.423]                           }
[13:20:15.423]                         }
[13:20:15.423]                       }
[13:20:15.423]                       invisible(muffled)
[13:20:15.423]                     }
[13:20:15.423]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.423]                   }
[13:20:15.423]                 }
[13:20:15.423]             }
[13:20:15.423]         }))
[13:20:15.423]     }, error = function(ex) {
[13:20:15.423]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:15.423]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.423]                 ...future.rng), started = ...future.startTime, 
[13:20:15.423]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:15.423]             version = "1.8"), class = "FutureResult")
[13:20:15.423]     }, finally = {
[13:20:15.423]         if (!identical(...future.workdir, getwd())) 
[13:20:15.423]             setwd(...future.workdir)
[13:20:15.423]         {
[13:20:15.423]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:15.423]                 ...future.oldOptions$nwarnings <- NULL
[13:20:15.423]             }
[13:20:15.423]             base::options(...future.oldOptions)
[13:20:15.423]             if (.Platform$OS.type == "windows") {
[13:20:15.423]                 old_names <- names(...future.oldEnvVars)
[13:20:15.423]                 envs <- base::Sys.getenv()
[13:20:15.423]                 names <- names(envs)
[13:20:15.423]                 common <- intersect(names, old_names)
[13:20:15.423]                 added <- setdiff(names, old_names)
[13:20:15.423]                 removed <- setdiff(old_names, names)
[13:20:15.423]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:15.423]                   envs[common]]
[13:20:15.423]                 NAMES <- toupper(changed)
[13:20:15.423]                 args <- list()
[13:20:15.423]                 for (kk in seq_along(NAMES)) {
[13:20:15.423]                   name <- changed[[kk]]
[13:20:15.423]                   NAME <- NAMES[[kk]]
[13:20:15.423]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.423]                     next
[13:20:15.423]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.423]                 }
[13:20:15.423]                 NAMES <- toupper(added)
[13:20:15.423]                 for (kk in seq_along(NAMES)) {
[13:20:15.423]                   name <- added[[kk]]
[13:20:15.423]                   NAME <- NAMES[[kk]]
[13:20:15.423]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.423]                     next
[13:20:15.423]                   args[[name]] <- ""
[13:20:15.423]                 }
[13:20:15.423]                 NAMES <- toupper(removed)
[13:20:15.423]                 for (kk in seq_along(NAMES)) {
[13:20:15.423]                   name <- removed[[kk]]
[13:20:15.423]                   NAME <- NAMES[[kk]]
[13:20:15.423]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.423]                     next
[13:20:15.423]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.423]                 }
[13:20:15.423]                 if (length(args) > 0) 
[13:20:15.423]                   base::do.call(base::Sys.setenv, args = args)
[13:20:15.423]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:15.423]             }
[13:20:15.423]             else {
[13:20:15.423]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:15.423]             }
[13:20:15.423]             {
[13:20:15.423]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:15.423]                   0L) {
[13:20:15.423]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:15.423]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:15.423]                   base::options(opts)
[13:20:15.423]                 }
[13:20:15.423]                 {
[13:20:15.423]                   {
[13:20:15.423]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:15.423]                     NULL
[13:20:15.423]                   }
[13:20:15.423]                   options(future.plan = NULL)
[13:20:15.423]                   if (is.na(NA_character_)) 
[13:20:15.423]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.423]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:15.423]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:15.423]                     envir = parent.frame()) 
[13:20:15.423]                   {
[13:20:15.423]                     default_workers <- missing(workers)
[13:20:15.423]                     if (is.function(workers)) 
[13:20:15.423]                       workers <- workers()
[13:20:15.423]                     workers <- structure(as.integer(workers), 
[13:20:15.423]                       class = class(workers))
[13:20:15.423]                     stop_if_not(is.finite(workers), workers >= 
[13:20:15.423]                       1L)
[13:20:15.423]                     if ((workers == 1L && !inherits(workers, 
[13:20:15.423]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:15.423]                       if (default_workers) 
[13:20:15.423]                         supportsMulticore(warn = TRUE)
[13:20:15.423]                       return(sequential(..., envir = envir))
[13:20:15.423]                     }
[13:20:15.423]                     oopts <- options(mc.cores = workers)
[13:20:15.423]                     on.exit(options(oopts))
[13:20:15.423]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:15.423]                       envir = envir)
[13:20:15.423]                     if (!future$lazy) 
[13:20:15.423]                       future <- run(future)
[13:20:15.423]                     invisible(future)
[13:20:15.423]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:15.423]                 }
[13:20:15.423]             }
[13:20:15.423]         }
[13:20:15.423]     })
[13:20:15.423]     if (TRUE) {
[13:20:15.423]         base::sink(type = "output", split = FALSE)
[13:20:15.423]         if (TRUE) {
[13:20:15.423]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:15.423]         }
[13:20:15.423]         else {
[13:20:15.423]             ...future.result["stdout"] <- base::list(NULL)
[13:20:15.423]         }
[13:20:15.423]         base::close(...future.stdout)
[13:20:15.423]         ...future.stdout <- NULL
[13:20:15.423]     }
[13:20:15.423]     ...future.result$conditions <- ...future.conditions
[13:20:15.423]     ...future.result$finished <- base::Sys.time()
[13:20:15.423]     ...future.result
[13:20:15.423] }
[13:20:15.425] assign_globals() ...
[13:20:15.426] List of 1
[13:20:15.426]  $ a: num 2
[13:20:15.426]  - attr(*, "where")=List of 1
[13:20:15.426]   ..$ a:<environment: R_EmptyEnv> 
[13:20:15.426]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:15.426]  - attr(*, "resolved")= logi FALSE
[13:20:15.426]  - attr(*, "total_size")= num 56
[13:20:15.426]  - attr(*, "already-done")= logi TRUE
[13:20:15.429] - copied ‘a’ to environment
[13:20:15.429] assign_globals() ... done
[13:20:15.429] requestCore(): workers = 2
[13:20:15.431] MulticoreFuture started
[13:20:15.431] - Launch lazy future ... done
[13:20:15.432] run() for ‘MulticoreFuture’ ... done
[13:20:15.432] plan(): Setting new future strategy stack:
[13:20:15.433] List of future strategies:
[13:20:15.433] 1. sequential:
[13:20:15.433]    - args: function (..., envir = parent.frame())
[13:20:15.433]    - tweaked: FALSE
[13:20:15.433]    - call: NULL
[13:20:15.433] plan(): nbrOfWorkers() = 1
[13:20:15.435] plan(): Setting new future strategy stack:
[13:20:15.435] List of future strategies:
[13:20:15.435] 1. multicore:
[13:20:15.435]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:15.435]    - tweaked: FALSE
[13:20:15.435]    - call: plan(strategy)
[13:20:15.441] plan(): nbrOfWorkers() = 2
** Future evaluation with errors
[13:20:15.442] getGlobalsAndPackages() ...
[13:20:15.442] Searching for globals...
[13:20:15.444] - globals found: [3] ‘{’, ‘<-’, ‘stop’
[13:20:15.445] Searching for globals ... DONE
[13:20:15.445] Resolving globals: FALSE
[13:20:15.445] 
[13:20:15.445] 
[13:20:15.445] getGlobalsAndPackages() ... DONE
[13:20:15.446] run() for ‘Future’ ...
[13:20:15.446] - state: ‘created’
[13:20:15.446] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:15.450] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:15.450] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:15.451]   - Field: ‘label’
[13:20:15.451]   - Field: ‘local’
[13:20:15.451]   - Field: ‘owner’
[13:20:15.451]   - Field: ‘envir’
[13:20:15.451]   - Field: ‘workers’
[13:20:15.451]   - Field: ‘packages’
[13:20:15.451]   - Field: ‘gc’
[13:20:15.451]   - Field: ‘job’
[13:20:15.452]   - Field: ‘conditions’
[13:20:15.452]   - Field: ‘expr’
[13:20:15.452]   - Field: ‘uuid’
[13:20:15.452]   - Field: ‘seed’
[13:20:15.452]   - Field: ‘version’
[13:20:15.452]   - Field: ‘result’
[13:20:15.452]   - Field: ‘asynchronous’
[13:20:15.452]   - Field: ‘calls’
[13:20:15.453]   - Field: ‘globals’
[13:20:15.453]   - Field: ‘stdout’
[13:20:15.453]   - Field: ‘earlySignal’
[13:20:15.453]   - Field: ‘lazy’
[13:20:15.453]   - Field: ‘state’
[13:20:15.453] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:15.453] - Launch lazy future ...
[13:20:15.454] Packages needed by the future expression (n = 0): <none>
[13:20:15.454] Packages needed by future strategies (n = 0): <none>
[13:20:15.454] {
[13:20:15.454]     {
[13:20:15.454]         {
[13:20:15.454]             ...future.startTime <- base::Sys.time()
[13:20:15.454]             {
[13:20:15.454]                 {
[13:20:15.454]                   {
[13:20:15.454]                     {
[13:20:15.454]                       base::local({
[13:20:15.454]                         has_future <- base::requireNamespace("future", 
[13:20:15.454]                           quietly = TRUE)
[13:20:15.454]                         if (has_future) {
[13:20:15.454]                           ns <- base::getNamespace("future")
[13:20:15.454]                           version <- ns[[".package"]][["version"]]
[13:20:15.454]                           if (is.null(version)) 
[13:20:15.454]                             version <- utils::packageVersion("future")
[13:20:15.454]                         }
[13:20:15.454]                         else {
[13:20:15.454]                           version <- NULL
[13:20:15.454]                         }
[13:20:15.454]                         if (!has_future || version < "1.8.0") {
[13:20:15.454]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:15.454]                             "", base::R.version$version.string), 
[13:20:15.454]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:15.454]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:15.454]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:15.454]                               "release", "version")], collapse = " "), 
[13:20:15.454]                             hostname = base::Sys.info()[["nodename"]])
[13:20:15.454]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:15.454]                             info)
[13:20:15.454]                           info <- base::paste(info, collapse = "; ")
[13:20:15.454]                           if (!has_future) {
[13:20:15.454]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:15.454]                               info)
[13:20:15.454]                           }
[13:20:15.454]                           else {
[13:20:15.454]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:15.454]                               info, version)
[13:20:15.454]                           }
[13:20:15.454]                           base::stop(msg)
[13:20:15.454]                         }
[13:20:15.454]                       })
[13:20:15.454]                     }
[13:20:15.454]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:15.454]                     base::options(mc.cores = 1L)
[13:20:15.454]                   }
[13:20:15.454]                   options(future.plan = NULL)
[13:20:15.454]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.454]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:15.454]                 }
[13:20:15.454]                 ...future.workdir <- getwd()
[13:20:15.454]             }
[13:20:15.454]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:15.454]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:15.454]         }
[13:20:15.454]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:15.454]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:15.454]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:15.454]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:15.454]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:15.454]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:15.454]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:15.454]             base::names(...future.oldOptions))
[13:20:15.454]     }
[13:20:15.454]     if (FALSE) {
[13:20:15.454]     }
[13:20:15.454]     else {
[13:20:15.454]         if (TRUE) {
[13:20:15.454]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:15.454]                 open = "w")
[13:20:15.454]         }
[13:20:15.454]         else {
[13:20:15.454]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:15.454]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:15.454]         }
[13:20:15.454]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:15.454]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:15.454]             base::sink(type = "output", split = FALSE)
[13:20:15.454]             base::close(...future.stdout)
[13:20:15.454]         }, add = TRUE)
[13:20:15.454]     }
[13:20:15.454]     ...future.frame <- base::sys.nframe()
[13:20:15.454]     ...future.conditions <- base::list()
[13:20:15.454]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:15.454]     if (FALSE) {
[13:20:15.454]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:15.454]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:15.454]     }
[13:20:15.454]     ...future.result <- base::tryCatch({
[13:20:15.454]         base::withCallingHandlers({
[13:20:15.454]             ...future.value <- base::withVisible(base::local({
[13:20:15.454]                 withCallingHandlers({
[13:20:15.454]                   {
[13:20:15.454]                     x <- 3
[13:20:15.454]                     stop("Woops!")
[13:20:15.454]                     x
[13:20:15.454]                   }
[13:20:15.454]                 }, immediateCondition = function(cond) {
[13:20:15.454]                   save_rds <- function (object, pathname, ...) 
[13:20:15.454]                   {
[13:20:15.454]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:15.454]                     if (file_test("-f", pathname_tmp)) {
[13:20:15.454]                       fi_tmp <- file.info(pathname_tmp)
[13:20:15.454]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:15.454]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:15.454]                         fi_tmp[["mtime"]])
[13:20:15.454]                     }
[13:20:15.454]                     tryCatch({
[13:20:15.454]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:15.454]                     }, error = function(ex) {
[13:20:15.454]                       msg <- conditionMessage(ex)
[13:20:15.454]                       fi_tmp <- file.info(pathname_tmp)
[13:20:15.454]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:15.454]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:15.454]                         fi_tmp[["mtime"]], msg)
[13:20:15.454]                       ex$message <- msg
[13:20:15.454]                       stop(ex)
[13:20:15.454]                     })
[13:20:15.454]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:15.454]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:15.454]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:15.454]                       fi_tmp <- file.info(pathname_tmp)
[13:20:15.454]                       fi <- file.info(pathname)
[13:20:15.454]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:15.454]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:15.454]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:15.454]                         fi[["size"]], fi[["mtime"]])
[13:20:15.454]                       stop(msg)
[13:20:15.454]                     }
[13:20:15.454]                     invisible(pathname)
[13:20:15.454]                   }
[13:20:15.454]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:15.454]                     rootPath = tempdir()) 
[13:20:15.454]                   {
[13:20:15.454]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:15.454]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:15.454]                       tmpdir = path, fileext = ".rds")
[13:20:15.454]                     save_rds(obj, file)
[13:20:15.454]                   }
[13:20:15.454]                   saveImmediateCondition(cond, path = "/tmp/RtmpakA0rS/.future/immediateConditions")
[13:20:15.454]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.454]                   {
[13:20:15.454]                     inherits <- base::inherits
[13:20:15.454]                     invokeRestart <- base::invokeRestart
[13:20:15.454]                     is.null <- base::is.null
[13:20:15.454]                     muffled <- FALSE
[13:20:15.454]                     if (inherits(cond, "message")) {
[13:20:15.454]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:15.454]                       if (muffled) 
[13:20:15.454]                         invokeRestart("muffleMessage")
[13:20:15.454]                     }
[13:20:15.454]                     else if (inherits(cond, "warning")) {
[13:20:15.454]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:15.454]                       if (muffled) 
[13:20:15.454]                         invokeRestart("muffleWarning")
[13:20:15.454]                     }
[13:20:15.454]                     else if (inherits(cond, "condition")) {
[13:20:15.454]                       if (!is.null(pattern)) {
[13:20:15.454]                         computeRestarts <- base::computeRestarts
[13:20:15.454]                         grepl <- base::grepl
[13:20:15.454]                         restarts <- computeRestarts(cond)
[13:20:15.454]                         for (restart in restarts) {
[13:20:15.454]                           name <- restart$name
[13:20:15.454]                           if (is.null(name)) 
[13:20:15.454]                             next
[13:20:15.454]                           if (!grepl(pattern, name)) 
[13:20:15.454]                             next
[13:20:15.454]                           invokeRestart(restart)
[13:20:15.454]                           muffled <- TRUE
[13:20:15.454]                           break
[13:20:15.454]                         }
[13:20:15.454]                       }
[13:20:15.454]                     }
[13:20:15.454]                     invisible(muffled)
[13:20:15.454]                   }
[13:20:15.454]                   muffleCondition(cond)
[13:20:15.454]                 })
[13:20:15.454]             }))
[13:20:15.454]             future::FutureResult(value = ...future.value$value, 
[13:20:15.454]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.454]                   ...future.rng), globalenv = if (FALSE) 
[13:20:15.454]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:15.454]                     ...future.globalenv.names))
[13:20:15.454]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:15.454]         }, condition = base::local({
[13:20:15.454]             c <- base::c
[13:20:15.454]             inherits <- base::inherits
[13:20:15.454]             invokeRestart <- base::invokeRestart
[13:20:15.454]             length <- base::length
[13:20:15.454]             list <- base::list
[13:20:15.454]             seq.int <- base::seq.int
[13:20:15.454]             signalCondition <- base::signalCondition
[13:20:15.454]             sys.calls <- base::sys.calls
[13:20:15.454]             `[[` <- base::`[[`
[13:20:15.454]             `+` <- base::`+`
[13:20:15.454]             `<<-` <- base::`<<-`
[13:20:15.454]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:15.454]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:15.454]                   3L)]
[13:20:15.454]             }
[13:20:15.454]             function(cond) {
[13:20:15.454]                 is_error <- inherits(cond, "error")
[13:20:15.454]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:15.454]                   NULL)
[13:20:15.454]                 if (is_error) {
[13:20:15.454]                   sessionInformation <- function() {
[13:20:15.454]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:15.454]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:15.454]                       search = base::search(), system = base::Sys.info())
[13:20:15.454]                   }
[13:20:15.454]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.454]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:15.454]                     cond$call), session = sessionInformation(), 
[13:20:15.454]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:15.454]                   signalCondition(cond)
[13:20:15.454]                 }
[13:20:15.454]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:15.454]                 "immediateCondition"))) {
[13:20:15.454]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:15.454]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.454]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:15.454]                   if (TRUE && !signal) {
[13:20:15.454]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.454]                     {
[13:20:15.454]                       inherits <- base::inherits
[13:20:15.454]                       invokeRestart <- base::invokeRestart
[13:20:15.454]                       is.null <- base::is.null
[13:20:15.454]                       muffled <- FALSE
[13:20:15.454]                       if (inherits(cond, "message")) {
[13:20:15.454]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.454]                         if (muffled) 
[13:20:15.454]                           invokeRestart("muffleMessage")
[13:20:15.454]                       }
[13:20:15.454]                       else if (inherits(cond, "warning")) {
[13:20:15.454]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.454]                         if (muffled) 
[13:20:15.454]                           invokeRestart("muffleWarning")
[13:20:15.454]                       }
[13:20:15.454]                       else if (inherits(cond, "condition")) {
[13:20:15.454]                         if (!is.null(pattern)) {
[13:20:15.454]                           computeRestarts <- base::computeRestarts
[13:20:15.454]                           grepl <- base::grepl
[13:20:15.454]                           restarts <- computeRestarts(cond)
[13:20:15.454]                           for (restart in restarts) {
[13:20:15.454]                             name <- restart$name
[13:20:15.454]                             if (is.null(name)) 
[13:20:15.454]                               next
[13:20:15.454]                             if (!grepl(pattern, name)) 
[13:20:15.454]                               next
[13:20:15.454]                             invokeRestart(restart)
[13:20:15.454]                             muffled <- TRUE
[13:20:15.454]                             break
[13:20:15.454]                           }
[13:20:15.454]                         }
[13:20:15.454]                       }
[13:20:15.454]                       invisible(muffled)
[13:20:15.454]                     }
[13:20:15.454]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.454]                   }
[13:20:15.454]                 }
[13:20:15.454]                 else {
[13:20:15.454]                   if (TRUE) {
[13:20:15.454]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.454]                     {
[13:20:15.454]                       inherits <- base::inherits
[13:20:15.454]                       invokeRestart <- base::invokeRestart
[13:20:15.454]                       is.null <- base::is.null
[13:20:15.454]                       muffled <- FALSE
[13:20:15.454]                       if (inherits(cond, "message")) {
[13:20:15.454]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.454]                         if (muffled) 
[13:20:15.454]                           invokeRestart("muffleMessage")
[13:20:15.454]                       }
[13:20:15.454]                       else if (inherits(cond, "warning")) {
[13:20:15.454]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.454]                         if (muffled) 
[13:20:15.454]                           invokeRestart("muffleWarning")
[13:20:15.454]                       }
[13:20:15.454]                       else if (inherits(cond, "condition")) {
[13:20:15.454]                         if (!is.null(pattern)) {
[13:20:15.454]                           computeRestarts <- base::computeRestarts
[13:20:15.454]                           grepl <- base::grepl
[13:20:15.454]                           restarts <- computeRestarts(cond)
[13:20:15.454]                           for (restart in restarts) {
[13:20:15.454]                             name <- restart$name
[13:20:15.454]                             if (is.null(name)) 
[13:20:15.454]                               next
[13:20:15.454]                             if (!grepl(pattern, name)) 
[13:20:15.454]                               next
[13:20:15.454]                             invokeRestart(restart)
[13:20:15.454]                             muffled <- TRUE
[13:20:15.454]                             break
[13:20:15.454]                           }
[13:20:15.454]                         }
[13:20:15.454]                       }
[13:20:15.454]                       invisible(muffled)
[13:20:15.454]                     }
[13:20:15.454]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.454]                   }
[13:20:15.454]                 }
[13:20:15.454]             }
[13:20:15.454]         }))
[13:20:15.454]     }, error = function(ex) {
[13:20:15.454]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:15.454]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.454]                 ...future.rng), started = ...future.startTime, 
[13:20:15.454]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:15.454]             version = "1.8"), class = "FutureResult")
[13:20:15.454]     }, finally = {
[13:20:15.454]         if (!identical(...future.workdir, getwd())) 
[13:20:15.454]             setwd(...future.workdir)
[13:20:15.454]         {
[13:20:15.454]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:15.454]                 ...future.oldOptions$nwarnings <- NULL
[13:20:15.454]             }
[13:20:15.454]             base::options(...future.oldOptions)
[13:20:15.454]             if (.Platform$OS.type == "windows") {
[13:20:15.454]                 old_names <- names(...future.oldEnvVars)
[13:20:15.454]                 envs <- base::Sys.getenv()
[13:20:15.454]                 names <- names(envs)
[13:20:15.454]                 common <- intersect(names, old_names)
[13:20:15.454]                 added <- setdiff(names, old_names)
[13:20:15.454]                 removed <- setdiff(old_names, names)
[13:20:15.454]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:15.454]                   envs[common]]
[13:20:15.454]                 NAMES <- toupper(changed)
[13:20:15.454]                 args <- list()
[13:20:15.454]                 for (kk in seq_along(NAMES)) {
[13:20:15.454]                   name <- changed[[kk]]
[13:20:15.454]                   NAME <- NAMES[[kk]]
[13:20:15.454]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.454]                     next
[13:20:15.454]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.454]                 }
[13:20:15.454]                 NAMES <- toupper(added)
[13:20:15.454]                 for (kk in seq_along(NAMES)) {
[13:20:15.454]                   name <- added[[kk]]
[13:20:15.454]                   NAME <- NAMES[[kk]]
[13:20:15.454]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.454]                     next
[13:20:15.454]                   args[[name]] <- ""
[13:20:15.454]                 }
[13:20:15.454]                 NAMES <- toupper(removed)
[13:20:15.454]                 for (kk in seq_along(NAMES)) {
[13:20:15.454]                   name <- removed[[kk]]
[13:20:15.454]                   NAME <- NAMES[[kk]]
[13:20:15.454]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.454]                     next
[13:20:15.454]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.454]                 }
[13:20:15.454]                 if (length(args) > 0) 
[13:20:15.454]                   base::do.call(base::Sys.setenv, args = args)
[13:20:15.454]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:15.454]             }
[13:20:15.454]             else {
[13:20:15.454]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:15.454]             }
[13:20:15.454]             {
[13:20:15.454]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:15.454]                   0L) {
[13:20:15.454]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:15.454]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:15.454]                   base::options(opts)
[13:20:15.454]                 }
[13:20:15.454]                 {
[13:20:15.454]                   {
[13:20:15.454]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:15.454]                     NULL
[13:20:15.454]                   }
[13:20:15.454]                   options(future.plan = NULL)
[13:20:15.454]                   if (is.na(NA_character_)) 
[13:20:15.454]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.454]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:15.454]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:15.454]                     envir = parent.frame()) 
[13:20:15.454]                   {
[13:20:15.454]                     default_workers <- missing(workers)
[13:20:15.454]                     if (is.function(workers)) 
[13:20:15.454]                       workers <- workers()
[13:20:15.454]                     workers <- structure(as.integer(workers), 
[13:20:15.454]                       class = class(workers))
[13:20:15.454]                     stop_if_not(is.finite(workers), workers >= 
[13:20:15.454]                       1L)
[13:20:15.454]                     if ((workers == 1L && !inherits(workers, 
[13:20:15.454]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:15.454]                       if (default_workers) 
[13:20:15.454]                         supportsMulticore(warn = TRUE)
[13:20:15.454]                       return(sequential(..., envir = envir))
[13:20:15.454]                     }
[13:20:15.454]                     oopts <- options(mc.cores = workers)
[13:20:15.454]                     on.exit(options(oopts))
[13:20:15.454]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:15.454]                       envir = envir)
[13:20:15.454]                     if (!future$lazy) 
[13:20:15.454]                       future <- run(future)
[13:20:15.454]                     invisible(future)
[13:20:15.454]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:15.454]                 }
[13:20:15.454]             }
[13:20:15.454]         }
[13:20:15.454]     })
[13:20:15.454]     if (TRUE) {
[13:20:15.454]         base::sink(type = "output", split = FALSE)
[13:20:15.454]         if (TRUE) {
[13:20:15.454]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:15.454]         }
[13:20:15.454]         else {
[13:20:15.454]             ...future.result["stdout"] <- base::list(NULL)
[13:20:15.454]         }
[13:20:15.454]         base::close(...future.stdout)
[13:20:15.454]         ...future.stdout <- NULL
[13:20:15.454]     }
[13:20:15.454]     ...future.result$conditions <- ...future.conditions
[13:20:15.454]     ...future.result$finished <- base::Sys.time()
[13:20:15.454]     ...future.result
[13:20:15.454] }
[13:20:15.457] requestCore(): workers = 2
[13:20:15.459] MulticoreFuture started
[13:20:15.460] - Launch lazy future ... done
[13:20:15.460] run() for ‘MulticoreFuture’ ... done
[13:20:15.461] plan(): Setting new future strategy stack:
[13:20:15.461] List of future strategies:
[13:20:15.461] 1. sequential:
[13:20:15.461]    - args: function (..., envir = parent.frame())
[13:20:15.461]    - tweaked: FALSE
[13:20:15.461]    - call: NULL
[13:20:15.462] plan(): nbrOfWorkers() = 1
[13:20:15.464] plan(): Setting new future strategy stack:
[13:20:15.464] List of future strategies:
[13:20:15.464] 1. multicore:
[13:20:15.464]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:15.464]    - tweaked: FALSE
[13:20:15.464]    - call: plan(strategy)
[13:20:15.469] plan(): nbrOfWorkers() = 2
[13:20:15.474] signalConditions() ...
[13:20:15.474]  - include = ‘immediateCondition’
[13:20:15.474]  - exclude = 
[13:20:15.474]  - resignal = FALSE
[13:20:15.474]  - Number of conditions: 1
[13:20:15.475] signalConditions() ... done
[13:20:15.475] signalConditions() ...
[13:20:15.475]  - include = ‘immediateCondition’
[13:20:15.475]  - exclude = 
[13:20:15.475]  - resignal = FALSE
[13:20:15.475]  - Number of conditions: 1
[13:20:15.475] signalConditions() ... done
[13:20:15.475] Future state: ‘finished’
[13:20:15.476] signalConditions() ...
[13:20:15.476]  - include = ‘condition’
[13:20:15.476]  - exclude = ‘immediateCondition’
[13:20:15.476]  - resignal = TRUE
[13:20:15.476]  - Number of conditions: 1
[13:20:15.476]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:20:15.476] signalConditions() ... done
[13:20:15.477] getGlobalsAndPackages() ...
[13:20:15.477] Searching for globals...
[13:20:15.479] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[13:20:15.479] Searching for globals ... DONE
[13:20:15.479] Resolving globals: FALSE
[13:20:15.480] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:15.480] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:20:15.481] - globals: [1] ‘ii’
[13:20:15.481] 
[13:20:15.481] getGlobalsAndPackages() ... DONE
[13:20:15.481] run() for ‘Future’ ...
[13:20:15.481] - state: ‘created’
[13:20:15.482] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:15.488] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:15.489] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:15.489]   - Field: ‘label’
[13:20:15.489]   - Field: ‘local’
[13:20:15.489]   - Field: ‘owner’
[13:20:15.489]   - Field: ‘envir’
[13:20:15.489]   - Field: ‘workers’
[13:20:15.490]   - Field: ‘packages’
[13:20:15.490]   - Field: ‘gc’
[13:20:15.490]   - Field: ‘job’
[13:20:15.490]   - Field: ‘conditions’
[13:20:15.490]   - Field: ‘expr’
[13:20:15.490]   - Field: ‘uuid’
[13:20:15.490]   - Field: ‘seed’
[13:20:15.490]   - Field: ‘version’
[13:20:15.491]   - Field: ‘result’
[13:20:15.491]   - Field: ‘asynchronous’
[13:20:15.491]   - Field: ‘calls’
[13:20:15.491]   - Field: ‘globals’
[13:20:15.491]   - Field: ‘stdout’
[13:20:15.491]   - Field: ‘earlySignal’
[13:20:15.491]   - Field: ‘lazy’
[13:20:15.492]   - Field: ‘state’
[13:20:15.492] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:15.492] - Launch lazy future ...
[13:20:15.492] Packages needed by the future expression (n = 0): <none>
[13:20:15.492] Packages needed by future strategies (n = 0): <none>
[13:20:15.493] {
[13:20:15.493]     {
[13:20:15.493]         {
[13:20:15.493]             ...future.startTime <- base::Sys.time()
[13:20:15.493]             {
[13:20:15.493]                 {
[13:20:15.493]                   {
[13:20:15.493]                     {
[13:20:15.493]                       base::local({
[13:20:15.493]                         has_future <- base::requireNamespace("future", 
[13:20:15.493]                           quietly = TRUE)
[13:20:15.493]                         if (has_future) {
[13:20:15.493]                           ns <- base::getNamespace("future")
[13:20:15.493]                           version <- ns[[".package"]][["version"]]
[13:20:15.493]                           if (is.null(version)) 
[13:20:15.493]                             version <- utils::packageVersion("future")
[13:20:15.493]                         }
[13:20:15.493]                         else {
[13:20:15.493]                           version <- NULL
[13:20:15.493]                         }
[13:20:15.493]                         if (!has_future || version < "1.8.0") {
[13:20:15.493]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:15.493]                             "", base::R.version$version.string), 
[13:20:15.493]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:15.493]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:15.493]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:15.493]                               "release", "version")], collapse = " "), 
[13:20:15.493]                             hostname = base::Sys.info()[["nodename"]])
[13:20:15.493]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:15.493]                             info)
[13:20:15.493]                           info <- base::paste(info, collapse = "; ")
[13:20:15.493]                           if (!has_future) {
[13:20:15.493]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:15.493]                               info)
[13:20:15.493]                           }
[13:20:15.493]                           else {
[13:20:15.493]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:15.493]                               info, version)
[13:20:15.493]                           }
[13:20:15.493]                           base::stop(msg)
[13:20:15.493]                         }
[13:20:15.493]                       })
[13:20:15.493]                     }
[13:20:15.493]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:15.493]                     base::options(mc.cores = 1L)
[13:20:15.493]                   }
[13:20:15.493]                   options(future.plan = NULL)
[13:20:15.493]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.493]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:15.493]                 }
[13:20:15.493]                 ...future.workdir <- getwd()
[13:20:15.493]             }
[13:20:15.493]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:15.493]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:15.493]         }
[13:20:15.493]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:15.493]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:15.493]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:15.493]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:15.493]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:15.493]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:15.493]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:15.493]             base::names(...future.oldOptions))
[13:20:15.493]     }
[13:20:15.493]     if (FALSE) {
[13:20:15.493]     }
[13:20:15.493]     else {
[13:20:15.493]         if (TRUE) {
[13:20:15.493]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:15.493]                 open = "w")
[13:20:15.493]         }
[13:20:15.493]         else {
[13:20:15.493]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:15.493]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:15.493]         }
[13:20:15.493]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:15.493]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:15.493]             base::sink(type = "output", split = FALSE)
[13:20:15.493]             base::close(...future.stdout)
[13:20:15.493]         }, add = TRUE)
[13:20:15.493]     }
[13:20:15.493]     ...future.frame <- base::sys.nframe()
[13:20:15.493]     ...future.conditions <- base::list()
[13:20:15.493]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:15.493]     if (FALSE) {
[13:20:15.493]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:15.493]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:15.493]     }
[13:20:15.493]     ...future.result <- base::tryCatch({
[13:20:15.493]         base::withCallingHandlers({
[13:20:15.493]             ...future.value <- base::withVisible(base::local({
[13:20:15.493]                 withCallingHandlers({
[13:20:15.493]                   {
[13:20:15.493]                     if (ii%%2 == 0) 
[13:20:15.493]                       stop("Woops!")
[13:20:15.493]                     ii
[13:20:15.493]                   }
[13:20:15.493]                 }, immediateCondition = function(cond) {
[13:20:15.493]                   save_rds <- function (object, pathname, ...) 
[13:20:15.493]                   {
[13:20:15.493]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:15.493]                     if (file_test("-f", pathname_tmp)) {
[13:20:15.493]                       fi_tmp <- file.info(pathname_tmp)
[13:20:15.493]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:15.493]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:15.493]                         fi_tmp[["mtime"]])
[13:20:15.493]                     }
[13:20:15.493]                     tryCatch({
[13:20:15.493]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:15.493]                     }, error = function(ex) {
[13:20:15.493]                       msg <- conditionMessage(ex)
[13:20:15.493]                       fi_tmp <- file.info(pathname_tmp)
[13:20:15.493]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:15.493]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:15.493]                         fi_tmp[["mtime"]], msg)
[13:20:15.493]                       ex$message <- msg
[13:20:15.493]                       stop(ex)
[13:20:15.493]                     })
[13:20:15.493]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:15.493]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:15.493]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:15.493]                       fi_tmp <- file.info(pathname_tmp)
[13:20:15.493]                       fi <- file.info(pathname)
[13:20:15.493]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:15.493]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:15.493]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:15.493]                         fi[["size"]], fi[["mtime"]])
[13:20:15.493]                       stop(msg)
[13:20:15.493]                     }
[13:20:15.493]                     invisible(pathname)
[13:20:15.493]                   }
[13:20:15.493]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:15.493]                     rootPath = tempdir()) 
[13:20:15.493]                   {
[13:20:15.493]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:15.493]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:15.493]                       tmpdir = path, fileext = ".rds")
[13:20:15.493]                     save_rds(obj, file)
[13:20:15.493]                   }
[13:20:15.493]                   saveImmediateCondition(cond, path = "/tmp/RtmpakA0rS/.future/immediateConditions")
[13:20:15.493]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.493]                   {
[13:20:15.493]                     inherits <- base::inherits
[13:20:15.493]                     invokeRestart <- base::invokeRestart
[13:20:15.493]                     is.null <- base::is.null
[13:20:15.493]                     muffled <- FALSE
[13:20:15.493]                     if (inherits(cond, "message")) {
[13:20:15.493]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:15.493]                       if (muffled) 
[13:20:15.493]                         invokeRestart("muffleMessage")
[13:20:15.493]                     }
[13:20:15.493]                     else if (inherits(cond, "warning")) {
[13:20:15.493]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:15.493]                       if (muffled) 
[13:20:15.493]                         invokeRestart("muffleWarning")
[13:20:15.493]                     }
[13:20:15.493]                     else if (inherits(cond, "condition")) {
[13:20:15.493]                       if (!is.null(pattern)) {
[13:20:15.493]                         computeRestarts <- base::computeRestarts
[13:20:15.493]                         grepl <- base::grepl
[13:20:15.493]                         restarts <- computeRestarts(cond)
[13:20:15.493]                         for (restart in restarts) {
[13:20:15.493]                           name <- restart$name
[13:20:15.493]                           if (is.null(name)) 
[13:20:15.493]                             next
[13:20:15.493]                           if (!grepl(pattern, name)) 
[13:20:15.493]                             next
[13:20:15.493]                           invokeRestart(restart)
[13:20:15.493]                           muffled <- TRUE
[13:20:15.493]                           break
[13:20:15.493]                         }
[13:20:15.493]                       }
[13:20:15.493]                     }
[13:20:15.493]                     invisible(muffled)
[13:20:15.493]                   }
[13:20:15.493]                   muffleCondition(cond)
[13:20:15.493]                 })
[13:20:15.493]             }))
[13:20:15.493]             future::FutureResult(value = ...future.value$value, 
[13:20:15.493]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.493]                   ...future.rng), globalenv = if (FALSE) 
[13:20:15.493]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:15.493]                     ...future.globalenv.names))
[13:20:15.493]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:15.493]         }, condition = base::local({
[13:20:15.493]             c <- base::c
[13:20:15.493]             inherits <- base::inherits
[13:20:15.493]             invokeRestart <- base::invokeRestart
[13:20:15.493]             length <- base::length
[13:20:15.493]             list <- base::list
[13:20:15.493]             seq.int <- base::seq.int
[13:20:15.493]             signalCondition <- base::signalCondition
[13:20:15.493]             sys.calls <- base::sys.calls
[13:20:15.493]             `[[` <- base::`[[`
[13:20:15.493]             `+` <- base::`+`
[13:20:15.493]             `<<-` <- base::`<<-`
[13:20:15.493]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:15.493]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:15.493]                   3L)]
[13:20:15.493]             }
[13:20:15.493]             function(cond) {
[13:20:15.493]                 is_error <- inherits(cond, "error")
[13:20:15.493]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:15.493]                   NULL)
[13:20:15.493]                 if (is_error) {
[13:20:15.493]                   sessionInformation <- function() {
[13:20:15.493]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:15.493]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:15.493]                       search = base::search(), system = base::Sys.info())
[13:20:15.493]                   }
[13:20:15.493]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.493]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:15.493]                     cond$call), session = sessionInformation(), 
[13:20:15.493]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:15.493]                   signalCondition(cond)
[13:20:15.493]                 }
[13:20:15.493]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:15.493]                 "immediateCondition"))) {
[13:20:15.493]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:15.493]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.493]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:15.493]                   if (TRUE && !signal) {
[13:20:15.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.493]                     {
[13:20:15.493]                       inherits <- base::inherits
[13:20:15.493]                       invokeRestart <- base::invokeRestart
[13:20:15.493]                       is.null <- base::is.null
[13:20:15.493]                       muffled <- FALSE
[13:20:15.493]                       if (inherits(cond, "message")) {
[13:20:15.493]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.493]                         if (muffled) 
[13:20:15.493]                           invokeRestart("muffleMessage")
[13:20:15.493]                       }
[13:20:15.493]                       else if (inherits(cond, "warning")) {
[13:20:15.493]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.493]                         if (muffled) 
[13:20:15.493]                           invokeRestart("muffleWarning")
[13:20:15.493]                       }
[13:20:15.493]                       else if (inherits(cond, "condition")) {
[13:20:15.493]                         if (!is.null(pattern)) {
[13:20:15.493]                           computeRestarts <- base::computeRestarts
[13:20:15.493]                           grepl <- base::grepl
[13:20:15.493]                           restarts <- computeRestarts(cond)
[13:20:15.493]                           for (restart in restarts) {
[13:20:15.493]                             name <- restart$name
[13:20:15.493]                             if (is.null(name)) 
[13:20:15.493]                               next
[13:20:15.493]                             if (!grepl(pattern, name)) 
[13:20:15.493]                               next
[13:20:15.493]                             invokeRestart(restart)
[13:20:15.493]                             muffled <- TRUE
[13:20:15.493]                             break
[13:20:15.493]                           }
[13:20:15.493]                         }
[13:20:15.493]                       }
[13:20:15.493]                       invisible(muffled)
[13:20:15.493]                     }
[13:20:15.493]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.493]                   }
[13:20:15.493]                 }
[13:20:15.493]                 else {
[13:20:15.493]                   if (TRUE) {
[13:20:15.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.493]                     {
[13:20:15.493]                       inherits <- base::inherits
[13:20:15.493]                       invokeRestart <- base::invokeRestart
[13:20:15.493]                       is.null <- base::is.null
[13:20:15.493]                       muffled <- FALSE
[13:20:15.493]                       if (inherits(cond, "message")) {
[13:20:15.493]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.493]                         if (muffled) 
[13:20:15.493]                           invokeRestart("muffleMessage")
[13:20:15.493]                       }
[13:20:15.493]                       else if (inherits(cond, "warning")) {
[13:20:15.493]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.493]                         if (muffled) 
[13:20:15.493]                           invokeRestart("muffleWarning")
[13:20:15.493]                       }
[13:20:15.493]                       else if (inherits(cond, "condition")) {
[13:20:15.493]                         if (!is.null(pattern)) {
[13:20:15.493]                           computeRestarts <- base::computeRestarts
[13:20:15.493]                           grepl <- base::grepl
[13:20:15.493]                           restarts <- computeRestarts(cond)
[13:20:15.493]                           for (restart in restarts) {
[13:20:15.493]                             name <- restart$name
[13:20:15.493]                             if (is.null(name)) 
[13:20:15.493]                               next
[13:20:15.493]                             if (!grepl(pattern, name)) 
[13:20:15.493]                               next
[13:20:15.493]                             invokeRestart(restart)
[13:20:15.493]                             muffled <- TRUE
[13:20:15.493]                             break
[13:20:15.493]                           }
[13:20:15.493]                         }
[13:20:15.493]                       }
[13:20:15.493]                       invisible(muffled)
[13:20:15.493]                     }
[13:20:15.493]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.493]                   }
[13:20:15.493]                 }
[13:20:15.493]             }
[13:20:15.493]         }))
[13:20:15.493]     }, error = function(ex) {
[13:20:15.493]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:15.493]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.493]                 ...future.rng), started = ...future.startTime, 
[13:20:15.493]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:15.493]             version = "1.8"), class = "FutureResult")
[13:20:15.493]     }, finally = {
[13:20:15.493]         if (!identical(...future.workdir, getwd())) 
[13:20:15.493]             setwd(...future.workdir)
[13:20:15.493]         {
[13:20:15.493]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:15.493]                 ...future.oldOptions$nwarnings <- NULL
[13:20:15.493]             }
[13:20:15.493]             base::options(...future.oldOptions)
[13:20:15.493]             if (.Platform$OS.type == "windows") {
[13:20:15.493]                 old_names <- names(...future.oldEnvVars)
[13:20:15.493]                 envs <- base::Sys.getenv()
[13:20:15.493]                 names <- names(envs)
[13:20:15.493]                 common <- intersect(names, old_names)
[13:20:15.493]                 added <- setdiff(names, old_names)
[13:20:15.493]                 removed <- setdiff(old_names, names)
[13:20:15.493]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:15.493]                   envs[common]]
[13:20:15.493]                 NAMES <- toupper(changed)
[13:20:15.493]                 args <- list()
[13:20:15.493]                 for (kk in seq_along(NAMES)) {
[13:20:15.493]                   name <- changed[[kk]]
[13:20:15.493]                   NAME <- NAMES[[kk]]
[13:20:15.493]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.493]                     next
[13:20:15.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.493]                 }
[13:20:15.493]                 NAMES <- toupper(added)
[13:20:15.493]                 for (kk in seq_along(NAMES)) {
[13:20:15.493]                   name <- added[[kk]]
[13:20:15.493]                   NAME <- NAMES[[kk]]
[13:20:15.493]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.493]                     next
[13:20:15.493]                   args[[name]] <- ""
[13:20:15.493]                 }
[13:20:15.493]                 NAMES <- toupper(removed)
[13:20:15.493]                 for (kk in seq_along(NAMES)) {
[13:20:15.493]                   name <- removed[[kk]]
[13:20:15.493]                   NAME <- NAMES[[kk]]
[13:20:15.493]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.493]                     next
[13:20:15.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.493]                 }
[13:20:15.493]                 if (length(args) > 0) 
[13:20:15.493]                   base::do.call(base::Sys.setenv, args = args)
[13:20:15.493]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:15.493]             }
[13:20:15.493]             else {
[13:20:15.493]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:15.493]             }
[13:20:15.493]             {
[13:20:15.493]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:15.493]                   0L) {
[13:20:15.493]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:15.493]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:15.493]                   base::options(opts)
[13:20:15.493]                 }
[13:20:15.493]                 {
[13:20:15.493]                   {
[13:20:15.493]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:15.493]                     NULL
[13:20:15.493]                   }
[13:20:15.493]                   options(future.plan = NULL)
[13:20:15.493]                   if (is.na(NA_character_)) 
[13:20:15.493]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.493]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:15.493]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:15.493]                     envir = parent.frame()) 
[13:20:15.493]                   {
[13:20:15.493]                     default_workers <- missing(workers)
[13:20:15.493]                     if (is.function(workers)) 
[13:20:15.493]                       workers <- workers()
[13:20:15.493]                     workers <- structure(as.integer(workers), 
[13:20:15.493]                       class = class(workers))
[13:20:15.493]                     stop_if_not(is.finite(workers), workers >= 
[13:20:15.493]                       1L)
[13:20:15.493]                     if ((workers == 1L && !inherits(workers, 
[13:20:15.493]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:15.493]                       if (default_workers) 
[13:20:15.493]                         supportsMulticore(warn = TRUE)
[13:20:15.493]                       return(sequential(..., envir = envir))
[13:20:15.493]                     }
[13:20:15.493]                     oopts <- options(mc.cores = workers)
[13:20:15.493]                     on.exit(options(oopts))
[13:20:15.493]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:15.493]                       envir = envir)
[13:20:15.493]                     if (!future$lazy) 
[13:20:15.493]                       future <- run(future)
[13:20:15.493]                     invisible(future)
[13:20:15.493]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:15.493]                 }
[13:20:15.493]             }
[13:20:15.493]         }
[13:20:15.493]     })
[13:20:15.493]     if (TRUE) {
[13:20:15.493]         base::sink(type = "output", split = FALSE)
[13:20:15.493]         if (TRUE) {
[13:20:15.493]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:15.493]         }
[13:20:15.493]         else {
[13:20:15.493]             ...future.result["stdout"] <- base::list(NULL)
[13:20:15.493]         }
[13:20:15.493]         base::close(...future.stdout)
[13:20:15.493]         ...future.stdout <- NULL
[13:20:15.493]     }
[13:20:15.493]     ...future.result$conditions <- ...future.conditions
[13:20:15.493]     ...future.result$finished <- base::Sys.time()
[13:20:15.493]     ...future.result
[13:20:15.493] }
[13:20:15.495] assign_globals() ...
[13:20:15.495] List of 1
[13:20:15.495]  $ ii: int 1
[13:20:15.495]  - attr(*, "where")=List of 1
[13:20:15.495]   ..$ ii:<environment: R_EmptyEnv> 
[13:20:15.495]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:15.495]  - attr(*, "resolved")= logi FALSE
[13:20:15.495]  - attr(*, "total_size")= num 56
[13:20:15.495]  - attr(*, "already-done")= logi TRUE
[13:20:15.499] - copied ‘ii’ to environment
[13:20:15.499] assign_globals() ... done
[13:20:15.499] requestCore(): workers = 2
[13:20:15.501] MulticoreFuture started
[13:20:15.501] - Launch lazy future ... done
[13:20:15.501] run() for ‘MulticoreFuture’ ... done
[13:20:15.502] plan(): Setting new future strategy stack:
[13:20:15.502] getGlobalsAndPackages() ...
[13:20:15.503] Searching for globals...
[13:20:15.502] List of future strategies:
[13:20:15.502] 1. sequential:
[13:20:15.502]    - args: function (..., envir = parent.frame())
[13:20:15.502]    - tweaked: FALSE
[13:20:15.502]    - call: NULL
[13:20:15.503] plan(): nbrOfWorkers() = 1
[13:20:15.505] plan(): Setting new future strategy stack:
[13:20:15.505] List of future strategies:
[13:20:15.505] 1. multicore:
[13:20:15.505]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:15.505]    - tweaked: FALSE
[13:20:15.505]    - call: plan(strategy)
[13:20:15.506] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[13:20:15.506] Searching for globals ... DONE
[13:20:15.507] Resolving globals: FALSE
[13:20:15.507] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:15.508] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:20:15.508] - globals: [1] ‘ii’
[13:20:15.508] 
[13:20:15.509] getGlobalsAndPackages() ... DONE
[13:20:15.509] run() for ‘Future’ ...
[13:20:15.509] - state: ‘created’
[13:20:15.510] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:15.510] plan(): nbrOfWorkers() = 2
[13:20:15.514] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:15.514] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:15.514]   - Field: ‘label’
[13:20:15.515]   - Field: ‘local’
[13:20:15.515]   - Field: ‘owner’
[13:20:15.515]   - Field: ‘envir’
[13:20:15.515]   - Field: ‘workers’
[13:20:15.515]   - Field: ‘packages’
[13:20:15.515]   - Field: ‘gc’
[13:20:15.516]   - Field: ‘job’
[13:20:15.516]   - Field: ‘conditions’
[13:20:15.516]   - Field: ‘expr’
[13:20:15.516]   - Field: ‘uuid’
[13:20:15.516]   - Field: ‘seed’
[13:20:15.516]   - Field: ‘version’
[13:20:15.516]   - Field: ‘result’
[13:20:15.517]   - Field: ‘asynchronous’
[13:20:15.517]   - Field: ‘calls’
[13:20:15.517]   - Field: ‘globals’
[13:20:15.517]   - Field: ‘stdout’
[13:20:15.517]   - Field: ‘earlySignal’
[13:20:15.517]   - Field: ‘lazy’
[13:20:15.517]   - Field: ‘state’
[13:20:15.518] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:15.518] - Launch lazy future ...
[13:20:15.518] Packages needed by the future expression (n = 0): <none>
[13:20:15.518] Packages needed by future strategies (n = 0): <none>
[13:20:15.519] {
[13:20:15.519]     {
[13:20:15.519]         {
[13:20:15.519]             ...future.startTime <- base::Sys.time()
[13:20:15.519]             {
[13:20:15.519]                 {
[13:20:15.519]                   {
[13:20:15.519]                     {
[13:20:15.519]                       base::local({
[13:20:15.519]                         has_future <- base::requireNamespace("future", 
[13:20:15.519]                           quietly = TRUE)
[13:20:15.519]                         if (has_future) {
[13:20:15.519]                           ns <- base::getNamespace("future")
[13:20:15.519]                           version <- ns[[".package"]][["version"]]
[13:20:15.519]                           if (is.null(version)) 
[13:20:15.519]                             version <- utils::packageVersion("future")
[13:20:15.519]                         }
[13:20:15.519]                         else {
[13:20:15.519]                           version <- NULL
[13:20:15.519]                         }
[13:20:15.519]                         if (!has_future || version < "1.8.0") {
[13:20:15.519]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:15.519]                             "", base::R.version$version.string), 
[13:20:15.519]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:15.519]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:15.519]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:15.519]                               "release", "version")], collapse = " "), 
[13:20:15.519]                             hostname = base::Sys.info()[["nodename"]])
[13:20:15.519]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:15.519]                             info)
[13:20:15.519]                           info <- base::paste(info, collapse = "; ")
[13:20:15.519]                           if (!has_future) {
[13:20:15.519]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:15.519]                               info)
[13:20:15.519]                           }
[13:20:15.519]                           else {
[13:20:15.519]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:15.519]                               info, version)
[13:20:15.519]                           }
[13:20:15.519]                           base::stop(msg)
[13:20:15.519]                         }
[13:20:15.519]                       })
[13:20:15.519]                     }
[13:20:15.519]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:15.519]                     base::options(mc.cores = 1L)
[13:20:15.519]                   }
[13:20:15.519]                   options(future.plan = NULL)
[13:20:15.519]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.519]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:15.519]                 }
[13:20:15.519]                 ...future.workdir <- getwd()
[13:20:15.519]             }
[13:20:15.519]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:15.519]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:15.519]         }
[13:20:15.519]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:15.519]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:15.519]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:15.519]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:15.519]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:15.519]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:15.519]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:15.519]             base::names(...future.oldOptions))
[13:20:15.519]     }
[13:20:15.519]     if (FALSE) {
[13:20:15.519]     }
[13:20:15.519]     else {
[13:20:15.519]         if (TRUE) {
[13:20:15.519]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:15.519]                 open = "w")
[13:20:15.519]         }
[13:20:15.519]         else {
[13:20:15.519]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:15.519]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:15.519]         }
[13:20:15.519]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:15.519]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:15.519]             base::sink(type = "output", split = FALSE)
[13:20:15.519]             base::close(...future.stdout)
[13:20:15.519]         }, add = TRUE)
[13:20:15.519]     }
[13:20:15.519]     ...future.frame <- base::sys.nframe()
[13:20:15.519]     ...future.conditions <- base::list()
[13:20:15.519]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:15.519]     if (FALSE) {
[13:20:15.519]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:15.519]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:15.519]     }
[13:20:15.519]     ...future.result <- base::tryCatch({
[13:20:15.519]         base::withCallingHandlers({
[13:20:15.519]             ...future.value <- base::withVisible(base::local({
[13:20:15.519]                 withCallingHandlers({
[13:20:15.519]                   {
[13:20:15.519]                     if (ii%%2 == 0) 
[13:20:15.519]                       stop("Woops!")
[13:20:15.519]                     ii
[13:20:15.519]                   }
[13:20:15.519]                 }, immediateCondition = function(cond) {
[13:20:15.519]                   save_rds <- function (object, pathname, ...) 
[13:20:15.519]                   {
[13:20:15.519]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:15.519]                     if (file_test("-f", pathname_tmp)) {
[13:20:15.519]                       fi_tmp <- file.info(pathname_tmp)
[13:20:15.519]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:15.519]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:15.519]                         fi_tmp[["mtime"]])
[13:20:15.519]                     }
[13:20:15.519]                     tryCatch({
[13:20:15.519]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:15.519]                     }, error = function(ex) {
[13:20:15.519]                       msg <- conditionMessage(ex)
[13:20:15.519]                       fi_tmp <- file.info(pathname_tmp)
[13:20:15.519]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:15.519]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:15.519]                         fi_tmp[["mtime"]], msg)
[13:20:15.519]                       ex$message <- msg
[13:20:15.519]                       stop(ex)
[13:20:15.519]                     })
[13:20:15.519]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:15.519]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:15.519]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:15.519]                       fi_tmp <- file.info(pathname_tmp)
[13:20:15.519]                       fi <- file.info(pathname)
[13:20:15.519]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:15.519]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:15.519]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:15.519]                         fi[["size"]], fi[["mtime"]])
[13:20:15.519]                       stop(msg)
[13:20:15.519]                     }
[13:20:15.519]                     invisible(pathname)
[13:20:15.519]                   }
[13:20:15.519]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:15.519]                     rootPath = tempdir()) 
[13:20:15.519]                   {
[13:20:15.519]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:15.519]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:15.519]                       tmpdir = path, fileext = ".rds")
[13:20:15.519]                     save_rds(obj, file)
[13:20:15.519]                   }
[13:20:15.519]                   saveImmediateCondition(cond, path = "/tmp/RtmpakA0rS/.future/immediateConditions")
[13:20:15.519]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.519]                   {
[13:20:15.519]                     inherits <- base::inherits
[13:20:15.519]                     invokeRestart <- base::invokeRestart
[13:20:15.519]                     is.null <- base::is.null
[13:20:15.519]                     muffled <- FALSE
[13:20:15.519]                     if (inherits(cond, "message")) {
[13:20:15.519]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:15.519]                       if (muffled) 
[13:20:15.519]                         invokeRestart("muffleMessage")
[13:20:15.519]                     }
[13:20:15.519]                     else if (inherits(cond, "warning")) {
[13:20:15.519]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:15.519]                       if (muffled) 
[13:20:15.519]                         invokeRestart("muffleWarning")
[13:20:15.519]                     }
[13:20:15.519]                     else if (inherits(cond, "condition")) {
[13:20:15.519]                       if (!is.null(pattern)) {
[13:20:15.519]                         computeRestarts <- base::computeRestarts
[13:20:15.519]                         grepl <- base::grepl
[13:20:15.519]                         restarts <- computeRestarts(cond)
[13:20:15.519]                         for (restart in restarts) {
[13:20:15.519]                           name <- restart$name
[13:20:15.519]                           if (is.null(name)) 
[13:20:15.519]                             next
[13:20:15.519]                           if (!grepl(pattern, name)) 
[13:20:15.519]                             next
[13:20:15.519]                           invokeRestart(restart)
[13:20:15.519]                           muffled <- TRUE
[13:20:15.519]                           break
[13:20:15.519]                         }
[13:20:15.519]                       }
[13:20:15.519]                     }
[13:20:15.519]                     invisible(muffled)
[13:20:15.519]                   }
[13:20:15.519]                   muffleCondition(cond)
[13:20:15.519]                 })
[13:20:15.519]             }))
[13:20:15.519]             future::FutureResult(value = ...future.value$value, 
[13:20:15.519]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.519]                   ...future.rng), globalenv = if (FALSE) 
[13:20:15.519]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:15.519]                     ...future.globalenv.names))
[13:20:15.519]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:15.519]         }, condition = base::local({
[13:20:15.519]             c <- base::c
[13:20:15.519]             inherits <- base::inherits
[13:20:15.519]             invokeRestart <- base::invokeRestart
[13:20:15.519]             length <- base::length
[13:20:15.519]             list <- base::list
[13:20:15.519]             seq.int <- base::seq.int
[13:20:15.519]             signalCondition <- base::signalCondition
[13:20:15.519]             sys.calls <- base::sys.calls
[13:20:15.519]             `[[` <- base::`[[`
[13:20:15.519]             `+` <- base::`+`
[13:20:15.519]             `<<-` <- base::`<<-`
[13:20:15.519]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:15.519]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:15.519]                   3L)]
[13:20:15.519]             }
[13:20:15.519]             function(cond) {
[13:20:15.519]                 is_error <- inherits(cond, "error")
[13:20:15.519]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:15.519]                   NULL)
[13:20:15.519]                 if (is_error) {
[13:20:15.519]                   sessionInformation <- function() {
[13:20:15.519]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:15.519]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:15.519]                       search = base::search(), system = base::Sys.info())
[13:20:15.519]                   }
[13:20:15.519]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.519]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:15.519]                     cond$call), session = sessionInformation(), 
[13:20:15.519]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:15.519]                   signalCondition(cond)
[13:20:15.519]                 }
[13:20:15.519]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:15.519]                 "immediateCondition"))) {
[13:20:15.519]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:15.519]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.519]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:15.519]                   if (TRUE && !signal) {
[13:20:15.519]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.519]                     {
[13:20:15.519]                       inherits <- base::inherits
[13:20:15.519]                       invokeRestart <- base::invokeRestart
[13:20:15.519]                       is.null <- base::is.null
[13:20:15.519]                       muffled <- FALSE
[13:20:15.519]                       if (inherits(cond, "message")) {
[13:20:15.519]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.519]                         if (muffled) 
[13:20:15.519]                           invokeRestart("muffleMessage")
[13:20:15.519]                       }
[13:20:15.519]                       else if (inherits(cond, "warning")) {
[13:20:15.519]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.519]                         if (muffled) 
[13:20:15.519]                           invokeRestart("muffleWarning")
[13:20:15.519]                       }
[13:20:15.519]                       else if (inherits(cond, "condition")) {
[13:20:15.519]                         if (!is.null(pattern)) {
[13:20:15.519]                           computeRestarts <- base::computeRestarts
[13:20:15.519]                           grepl <- base::grepl
[13:20:15.519]                           restarts <- computeRestarts(cond)
[13:20:15.519]                           for (restart in restarts) {
[13:20:15.519]                             name <- restart$name
[13:20:15.519]                             if (is.null(name)) 
[13:20:15.519]                               next
[13:20:15.519]                             if (!grepl(pattern, name)) 
[13:20:15.519]                               next
[13:20:15.519]                             invokeRestart(restart)
[13:20:15.519]                             muffled <- TRUE
[13:20:15.519]                             break
[13:20:15.519]                           }
[13:20:15.519]                         }
[13:20:15.519]                       }
[13:20:15.519]                       invisible(muffled)
[13:20:15.519]                     }
[13:20:15.519]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.519]                   }
[13:20:15.519]                 }
[13:20:15.519]                 else {
[13:20:15.519]                   if (TRUE) {
[13:20:15.519]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.519]                     {
[13:20:15.519]                       inherits <- base::inherits
[13:20:15.519]                       invokeRestart <- base::invokeRestart
[13:20:15.519]                       is.null <- base::is.null
[13:20:15.519]                       muffled <- FALSE
[13:20:15.519]                       if (inherits(cond, "message")) {
[13:20:15.519]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.519]                         if (muffled) 
[13:20:15.519]                           invokeRestart("muffleMessage")
[13:20:15.519]                       }
[13:20:15.519]                       else if (inherits(cond, "warning")) {
[13:20:15.519]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.519]                         if (muffled) 
[13:20:15.519]                           invokeRestart("muffleWarning")
[13:20:15.519]                       }
[13:20:15.519]                       else if (inherits(cond, "condition")) {
[13:20:15.519]                         if (!is.null(pattern)) {
[13:20:15.519]                           computeRestarts <- base::computeRestarts
[13:20:15.519]                           grepl <- base::grepl
[13:20:15.519]                           restarts <- computeRestarts(cond)
[13:20:15.519]                           for (restart in restarts) {
[13:20:15.519]                             name <- restart$name
[13:20:15.519]                             if (is.null(name)) 
[13:20:15.519]                               next
[13:20:15.519]                             if (!grepl(pattern, name)) 
[13:20:15.519]                               next
[13:20:15.519]                             invokeRestart(restart)
[13:20:15.519]                             muffled <- TRUE
[13:20:15.519]                             break
[13:20:15.519]                           }
[13:20:15.519]                         }
[13:20:15.519]                       }
[13:20:15.519]                       invisible(muffled)
[13:20:15.519]                     }
[13:20:15.519]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.519]                   }
[13:20:15.519]                 }
[13:20:15.519]             }
[13:20:15.519]         }))
[13:20:15.519]     }, error = function(ex) {
[13:20:15.519]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:15.519]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.519]                 ...future.rng), started = ...future.startTime, 
[13:20:15.519]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:15.519]             version = "1.8"), class = "FutureResult")
[13:20:15.519]     }, finally = {
[13:20:15.519]         if (!identical(...future.workdir, getwd())) 
[13:20:15.519]             setwd(...future.workdir)
[13:20:15.519]         {
[13:20:15.519]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:15.519]                 ...future.oldOptions$nwarnings <- NULL
[13:20:15.519]             }
[13:20:15.519]             base::options(...future.oldOptions)
[13:20:15.519]             if (.Platform$OS.type == "windows") {
[13:20:15.519]                 old_names <- names(...future.oldEnvVars)
[13:20:15.519]                 envs <- base::Sys.getenv()
[13:20:15.519]                 names <- names(envs)
[13:20:15.519]                 common <- intersect(names, old_names)
[13:20:15.519]                 added <- setdiff(names, old_names)
[13:20:15.519]                 removed <- setdiff(old_names, names)
[13:20:15.519]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:15.519]                   envs[common]]
[13:20:15.519]                 NAMES <- toupper(changed)
[13:20:15.519]                 args <- list()
[13:20:15.519]                 for (kk in seq_along(NAMES)) {
[13:20:15.519]                   name <- changed[[kk]]
[13:20:15.519]                   NAME <- NAMES[[kk]]
[13:20:15.519]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.519]                     next
[13:20:15.519]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.519]                 }
[13:20:15.519]                 NAMES <- toupper(added)
[13:20:15.519]                 for (kk in seq_along(NAMES)) {
[13:20:15.519]                   name <- added[[kk]]
[13:20:15.519]                   NAME <- NAMES[[kk]]
[13:20:15.519]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.519]                     next
[13:20:15.519]                   args[[name]] <- ""
[13:20:15.519]                 }
[13:20:15.519]                 NAMES <- toupper(removed)
[13:20:15.519]                 for (kk in seq_along(NAMES)) {
[13:20:15.519]                   name <- removed[[kk]]
[13:20:15.519]                   NAME <- NAMES[[kk]]
[13:20:15.519]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.519]                     next
[13:20:15.519]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.519]                 }
[13:20:15.519]                 if (length(args) > 0) 
[13:20:15.519]                   base::do.call(base::Sys.setenv, args = args)
[13:20:15.519]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:15.519]             }
[13:20:15.519]             else {
[13:20:15.519]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:15.519]             }
[13:20:15.519]             {
[13:20:15.519]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:15.519]                   0L) {
[13:20:15.519]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:15.519]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:15.519]                   base::options(opts)
[13:20:15.519]                 }
[13:20:15.519]                 {
[13:20:15.519]                   {
[13:20:15.519]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:15.519]                     NULL
[13:20:15.519]                   }
[13:20:15.519]                   options(future.plan = NULL)
[13:20:15.519]                   if (is.na(NA_character_)) 
[13:20:15.519]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.519]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:15.519]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:15.519]                     envir = parent.frame()) 
[13:20:15.519]                   {
[13:20:15.519]                     default_workers <- missing(workers)
[13:20:15.519]                     if (is.function(workers)) 
[13:20:15.519]                       workers <- workers()
[13:20:15.519]                     workers <- structure(as.integer(workers), 
[13:20:15.519]                       class = class(workers))
[13:20:15.519]                     stop_if_not(is.finite(workers), workers >= 
[13:20:15.519]                       1L)
[13:20:15.519]                     if ((workers == 1L && !inherits(workers, 
[13:20:15.519]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:15.519]                       if (default_workers) 
[13:20:15.519]                         supportsMulticore(warn = TRUE)
[13:20:15.519]                       return(sequential(..., envir = envir))
[13:20:15.519]                     }
[13:20:15.519]                     oopts <- options(mc.cores = workers)
[13:20:15.519]                     on.exit(options(oopts))
[13:20:15.519]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:15.519]                       envir = envir)
[13:20:15.519]                     if (!future$lazy) 
[13:20:15.519]                       future <- run(future)
[13:20:15.519]                     invisible(future)
[13:20:15.519]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:15.519]                 }
[13:20:15.519]             }
[13:20:15.519]         }
[13:20:15.519]     })
[13:20:15.519]     if (TRUE) {
[13:20:15.519]         base::sink(type = "output", split = FALSE)
[13:20:15.519]         if (TRUE) {
[13:20:15.519]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:15.519]         }
[13:20:15.519]         else {
[13:20:15.519]             ...future.result["stdout"] <- base::list(NULL)
[13:20:15.519]         }
[13:20:15.519]         base::close(...future.stdout)
[13:20:15.519]         ...future.stdout <- NULL
[13:20:15.519]     }
[13:20:15.519]     ...future.result$conditions <- ...future.conditions
[13:20:15.519]     ...future.result$finished <- base::Sys.time()
[13:20:15.519]     ...future.result
[13:20:15.519] }
[13:20:15.522] assign_globals() ...
[13:20:15.523] List of 1
[13:20:15.523]  $ ii: int 2
[13:20:15.523]  - attr(*, "where")=List of 1
[13:20:15.523]   ..$ ii:<environment: R_EmptyEnv> 
[13:20:15.523]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:15.523]  - attr(*, "resolved")= logi FALSE
[13:20:15.523]  - attr(*, "total_size")= num 56
[13:20:15.523]  - attr(*, "already-done")= logi TRUE
[13:20:15.526] - copied ‘ii’ to environment
[13:20:15.527] assign_globals() ... done
[13:20:15.527] requestCore(): workers = 2
[13:20:15.529] MulticoreFuture started
[13:20:15.530] - Launch lazy future ... done
[13:20:15.530] run() for ‘MulticoreFuture’ ... done
[13:20:15.530] plan(): Setting new future strategy stack:
[13:20:15.531] getGlobalsAndPackages() ...
[13:20:15.531] Searching for globals...
[13:20:15.531] List of future strategies:
[13:20:15.531] 1. sequential:
[13:20:15.531]    - args: function (..., envir = parent.frame())
[13:20:15.531]    - tweaked: FALSE
[13:20:15.531]    - call: NULL
[13:20:15.532] plan(): nbrOfWorkers() = 1
[13:20:15.534] plan(): Setting new future strategy stack:
[13:20:15.534] List of future strategies:
[13:20:15.534] 1. multicore:
[13:20:15.534]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:15.534]    - tweaked: FALSE
[13:20:15.534]    - call: plan(strategy)
[13:20:15.539] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[13:20:15.539] Searching for globals ... DONE
[13:20:15.540] Resolving globals: FALSE
[13:20:15.541] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:15.542] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:20:15.542] - globals: [1] ‘ii’
[13:20:15.542] 
[13:20:15.542] getGlobalsAndPackages() ... DONE
[13:20:15.543] run() for ‘Future’ ...
[13:20:15.543] - state: ‘created’
[13:20:15.543] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:15.543] plan(): nbrOfWorkers() = 2
[13:20:15.548] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:15.548] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:15.548]   - Field: ‘label’
[13:20:15.548]   - Field: ‘local’
[13:20:15.549]   - Field: ‘owner’
[13:20:15.549]   - Field: ‘envir’
[13:20:15.549]   - Field: ‘workers’
[13:20:15.549]   - Field: ‘packages’
[13:20:15.549]   - Field: ‘gc’
[13:20:15.550]   - Field: ‘job’
[13:20:15.550]   - Field: ‘conditions’
[13:20:15.550]   - Field: ‘expr’
[13:20:15.550]   - Field: ‘uuid’
[13:20:15.550]   - Field: ‘seed’
[13:20:15.550]   - Field: ‘version’
[13:20:15.550]   - Field: ‘result’
[13:20:15.551]   - Field: ‘asynchronous’
[13:20:15.551]   - Field: ‘calls’
[13:20:15.551]   - Field: ‘globals’
[13:20:15.551]   - Field: ‘stdout’
[13:20:15.551]   - Field: ‘earlySignal’
[13:20:15.551]   - Field: ‘lazy’
[13:20:15.551]   - Field: ‘state’
[13:20:15.551] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:15.552] - Launch lazy future ...
[13:20:15.552] Packages needed by the future expression (n = 0): <none>
[13:20:15.552] Packages needed by future strategies (n = 0): <none>
[13:20:15.553] {
[13:20:15.553]     {
[13:20:15.553]         {
[13:20:15.553]             ...future.startTime <- base::Sys.time()
[13:20:15.553]             {
[13:20:15.553]                 {
[13:20:15.553]                   {
[13:20:15.553]                     {
[13:20:15.553]                       base::local({
[13:20:15.553]                         has_future <- base::requireNamespace("future", 
[13:20:15.553]                           quietly = TRUE)
[13:20:15.553]                         if (has_future) {
[13:20:15.553]                           ns <- base::getNamespace("future")
[13:20:15.553]                           version <- ns[[".package"]][["version"]]
[13:20:15.553]                           if (is.null(version)) 
[13:20:15.553]                             version <- utils::packageVersion("future")
[13:20:15.553]                         }
[13:20:15.553]                         else {
[13:20:15.553]                           version <- NULL
[13:20:15.553]                         }
[13:20:15.553]                         if (!has_future || version < "1.8.0") {
[13:20:15.553]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:15.553]                             "", base::R.version$version.string), 
[13:20:15.553]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:15.553]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:15.553]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:15.553]                               "release", "version")], collapse = " "), 
[13:20:15.553]                             hostname = base::Sys.info()[["nodename"]])
[13:20:15.553]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:15.553]                             info)
[13:20:15.553]                           info <- base::paste(info, collapse = "; ")
[13:20:15.553]                           if (!has_future) {
[13:20:15.553]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:15.553]                               info)
[13:20:15.553]                           }
[13:20:15.553]                           else {
[13:20:15.553]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:15.553]                               info, version)
[13:20:15.553]                           }
[13:20:15.553]                           base::stop(msg)
[13:20:15.553]                         }
[13:20:15.553]                       })
[13:20:15.553]                     }
[13:20:15.553]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:15.553]                     base::options(mc.cores = 1L)
[13:20:15.553]                   }
[13:20:15.553]                   options(future.plan = NULL)
[13:20:15.553]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.553]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:15.553]                 }
[13:20:15.553]                 ...future.workdir <- getwd()
[13:20:15.553]             }
[13:20:15.553]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:15.553]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:15.553]         }
[13:20:15.553]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:15.553]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:15.553]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:15.553]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:15.553]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:15.553]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:15.553]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:15.553]             base::names(...future.oldOptions))
[13:20:15.553]     }
[13:20:15.553]     if (FALSE) {
[13:20:15.553]     }
[13:20:15.553]     else {
[13:20:15.553]         if (TRUE) {
[13:20:15.553]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:15.553]                 open = "w")
[13:20:15.553]         }
[13:20:15.553]         else {
[13:20:15.553]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:15.553]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:15.553]         }
[13:20:15.553]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:15.553]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:15.553]             base::sink(type = "output", split = FALSE)
[13:20:15.553]             base::close(...future.stdout)
[13:20:15.553]         }, add = TRUE)
[13:20:15.553]     }
[13:20:15.553]     ...future.frame <- base::sys.nframe()
[13:20:15.553]     ...future.conditions <- base::list()
[13:20:15.553]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:15.553]     if (FALSE) {
[13:20:15.553]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:15.553]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:15.553]     }
[13:20:15.553]     ...future.result <- base::tryCatch({
[13:20:15.553]         base::withCallingHandlers({
[13:20:15.553]             ...future.value <- base::withVisible(base::local({
[13:20:15.553]                 withCallingHandlers({
[13:20:15.553]                   {
[13:20:15.553]                     if (ii%%2 == 0) 
[13:20:15.553]                       stop("Woops!")
[13:20:15.553]                     ii
[13:20:15.553]                   }
[13:20:15.553]                 }, immediateCondition = function(cond) {
[13:20:15.553]                   save_rds <- function (object, pathname, ...) 
[13:20:15.553]                   {
[13:20:15.553]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:15.553]                     if (file_test("-f", pathname_tmp)) {
[13:20:15.553]                       fi_tmp <- file.info(pathname_tmp)
[13:20:15.553]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:15.553]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:15.553]                         fi_tmp[["mtime"]])
[13:20:15.553]                     }
[13:20:15.553]                     tryCatch({
[13:20:15.553]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:15.553]                     }, error = function(ex) {
[13:20:15.553]                       msg <- conditionMessage(ex)
[13:20:15.553]                       fi_tmp <- file.info(pathname_tmp)
[13:20:15.553]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:15.553]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:15.553]                         fi_tmp[["mtime"]], msg)
[13:20:15.553]                       ex$message <- msg
[13:20:15.553]                       stop(ex)
[13:20:15.553]                     })
[13:20:15.553]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:15.553]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:15.553]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:15.553]                       fi_tmp <- file.info(pathname_tmp)
[13:20:15.553]                       fi <- file.info(pathname)
[13:20:15.553]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:15.553]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:15.553]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:15.553]                         fi[["size"]], fi[["mtime"]])
[13:20:15.553]                       stop(msg)
[13:20:15.553]                     }
[13:20:15.553]                     invisible(pathname)
[13:20:15.553]                   }
[13:20:15.553]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:15.553]                     rootPath = tempdir()) 
[13:20:15.553]                   {
[13:20:15.553]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:15.553]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:15.553]                       tmpdir = path, fileext = ".rds")
[13:20:15.553]                     save_rds(obj, file)
[13:20:15.553]                   }
[13:20:15.553]                   saveImmediateCondition(cond, path = "/tmp/RtmpakA0rS/.future/immediateConditions")
[13:20:15.553]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.553]                   {
[13:20:15.553]                     inherits <- base::inherits
[13:20:15.553]                     invokeRestart <- base::invokeRestart
[13:20:15.553]                     is.null <- base::is.null
[13:20:15.553]                     muffled <- FALSE
[13:20:15.553]                     if (inherits(cond, "message")) {
[13:20:15.553]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:15.553]                       if (muffled) 
[13:20:15.553]                         invokeRestart("muffleMessage")
[13:20:15.553]                     }
[13:20:15.553]                     else if (inherits(cond, "warning")) {
[13:20:15.553]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:15.553]                       if (muffled) 
[13:20:15.553]                         invokeRestart("muffleWarning")
[13:20:15.553]                     }
[13:20:15.553]                     else if (inherits(cond, "condition")) {
[13:20:15.553]                       if (!is.null(pattern)) {
[13:20:15.553]                         computeRestarts <- base::computeRestarts
[13:20:15.553]                         grepl <- base::grepl
[13:20:15.553]                         restarts <- computeRestarts(cond)
[13:20:15.553]                         for (restart in restarts) {
[13:20:15.553]                           name <- restart$name
[13:20:15.553]                           if (is.null(name)) 
[13:20:15.553]                             next
[13:20:15.553]                           if (!grepl(pattern, name)) 
[13:20:15.553]                             next
[13:20:15.553]                           invokeRestart(restart)
[13:20:15.553]                           muffled <- TRUE
[13:20:15.553]                           break
[13:20:15.553]                         }
[13:20:15.553]                       }
[13:20:15.553]                     }
[13:20:15.553]                     invisible(muffled)
[13:20:15.553]                   }
[13:20:15.553]                   muffleCondition(cond)
[13:20:15.553]                 })
[13:20:15.553]             }))
[13:20:15.553]             future::FutureResult(value = ...future.value$value, 
[13:20:15.553]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.553]                   ...future.rng), globalenv = if (FALSE) 
[13:20:15.553]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:15.553]                     ...future.globalenv.names))
[13:20:15.553]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:15.553]         }, condition = base::local({
[13:20:15.553]             c <- base::c
[13:20:15.553]             inherits <- base::inherits
[13:20:15.553]             invokeRestart <- base::invokeRestart
[13:20:15.553]             length <- base::length
[13:20:15.553]             list <- base::list
[13:20:15.553]             seq.int <- base::seq.int
[13:20:15.553]             signalCondition <- base::signalCondition
[13:20:15.553]             sys.calls <- base::sys.calls
[13:20:15.553]             `[[` <- base::`[[`
[13:20:15.553]             `+` <- base::`+`
[13:20:15.553]             `<<-` <- base::`<<-`
[13:20:15.553]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:15.553]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:15.553]                   3L)]
[13:20:15.553]             }
[13:20:15.553]             function(cond) {
[13:20:15.553]                 is_error <- inherits(cond, "error")
[13:20:15.553]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:15.553]                   NULL)
[13:20:15.553]                 if (is_error) {
[13:20:15.553]                   sessionInformation <- function() {
[13:20:15.553]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:15.553]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:15.553]                       search = base::search(), system = base::Sys.info())
[13:20:15.553]                   }
[13:20:15.553]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.553]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:15.553]                     cond$call), session = sessionInformation(), 
[13:20:15.553]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:15.553]                   signalCondition(cond)
[13:20:15.553]                 }
[13:20:15.553]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:15.553]                 "immediateCondition"))) {
[13:20:15.553]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:15.553]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.553]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:15.553]                   if (TRUE && !signal) {
[13:20:15.553]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.553]                     {
[13:20:15.553]                       inherits <- base::inherits
[13:20:15.553]                       invokeRestart <- base::invokeRestart
[13:20:15.553]                       is.null <- base::is.null
[13:20:15.553]                       muffled <- FALSE
[13:20:15.553]                       if (inherits(cond, "message")) {
[13:20:15.553]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.553]                         if (muffled) 
[13:20:15.553]                           invokeRestart("muffleMessage")
[13:20:15.553]                       }
[13:20:15.553]                       else if (inherits(cond, "warning")) {
[13:20:15.553]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.553]                         if (muffled) 
[13:20:15.553]                           invokeRestart("muffleWarning")
[13:20:15.553]                       }
[13:20:15.553]                       else if (inherits(cond, "condition")) {
[13:20:15.553]                         if (!is.null(pattern)) {
[13:20:15.553]                           computeRestarts <- base::computeRestarts
[13:20:15.553]                           grepl <- base::grepl
[13:20:15.553]                           restarts <- computeRestarts(cond)
[13:20:15.553]                           for (restart in restarts) {
[13:20:15.553]                             name <- restart$name
[13:20:15.553]                             if (is.null(name)) 
[13:20:15.553]                               next
[13:20:15.553]                             if (!grepl(pattern, name)) 
[13:20:15.553]                               next
[13:20:15.553]                             invokeRestart(restart)
[13:20:15.553]                             muffled <- TRUE
[13:20:15.553]                             break
[13:20:15.553]                           }
[13:20:15.553]                         }
[13:20:15.553]                       }
[13:20:15.553]                       invisible(muffled)
[13:20:15.553]                     }
[13:20:15.553]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.553]                   }
[13:20:15.553]                 }
[13:20:15.553]                 else {
[13:20:15.553]                   if (TRUE) {
[13:20:15.553]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.553]                     {
[13:20:15.553]                       inherits <- base::inherits
[13:20:15.553]                       invokeRestart <- base::invokeRestart
[13:20:15.553]                       is.null <- base::is.null
[13:20:15.553]                       muffled <- FALSE
[13:20:15.553]                       if (inherits(cond, "message")) {
[13:20:15.553]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.553]                         if (muffled) 
[13:20:15.553]                           invokeRestart("muffleMessage")
[13:20:15.553]                       }
[13:20:15.553]                       else if (inherits(cond, "warning")) {
[13:20:15.553]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.553]                         if (muffled) 
[13:20:15.553]                           invokeRestart("muffleWarning")
[13:20:15.553]                       }
[13:20:15.553]                       else if (inherits(cond, "condition")) {
[13:20:15.553]                         if (!is.null(pattern)) {
[13:20:15.553]                           computeRestarts <- base::computeRestarts
[13:20:15.553]                           grepl <- base::grepl
[13:20:15.553]                           restarts <- computeRestarts(cond)
[13:20:15.553]                           for (restart in restarts) {
[13:20:15.553]                             name <- restart$name
[13:20:15.553]                             if (is.null(name)) 
[13:20:15.553]                               next
[13:20:15.553]                             if (!grepl(pattern, name)) 
[13:20:15.553]                               next
[13:20:15.553]                             invokeRestart(restart)
[13:20:15.553]                             muffled <- TRUE
[13:20:15.553]                             break
[13:20:15.553]                           }
[13:20:15.553]                         }
[13:20:15.553]                       }
[13:20:15.553]                       invisible(muffled)
[13:20:15.553]                     }
[13:20:15.553]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.553]                   }
[13:20:15.553]                 }
[13:20:15.553]             }
[13:20:15.553]         }))
[13:20:15.553]     }, error = function(ex) {
[13:20:15.553]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:15.553]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.553]                 ...future.rng), started = ...future.startTime, 
[13:20:15.553]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:15.553]             version = "1.8"), class = "FutureResult")
[13:20:15.553]     }, finally = {
[13:20:15.553]         if (!identical(...future.workdir, getwd())) 
[13:20:15.553]             setwd(...future.workdir)
[13:20:15.553]         {
[13:20:15.553]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:15.553]                 ...future.oldOptions$nwarnings <- NULL
[13:20:15.553]             }
[13:20:15.553]             base::options(...future.oldOptions)
[13:20:15.553]             if (.Platform$OS.type == "windows") {
[13:20:15.553]                 old_names <- names(...future.oldEnvVars)
[13:20:15.553]                 envs <- base::Sys.getenv()
[13:20:15.553]                 names <- names(envs)
[13:20:15.553]                 common <- intersect(names, old_names)
[13:20:15.553]                 added <- setdiff(names, old_names)
[13:20:15.553]                 removed <- setdiff(old_names, names)
[13:20:15.553]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:15.553]                   envs[common]]
[13:20:15.553]                 NAMES <- toupper(changed)
[13:20:15.553]                 args <- list()
[13:20:15.553]                 for (kk in seq_along(NAMES)) {
[13:20:15.553]                   name <- changed[[kk]]
[13:20:15.553]                   NAME <- NAMES[[kk]]
[13:20:15.553]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.553]                     next
[13:20:15.553]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.553]                 }
[13:20:15.553]                 NAMES <- toupper(added)
[13:20:15.553]                 for (kk in seq_along(NAMES)) {
[13:20:15.553]                   name <- added[[kk]]
[13:20:15.553]                   NAME <- NAMES[[kk]]
[13:20:15.553]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.553]                     next
[13:20:15.553]                   args[[name]] <- ""
[13:20:15.553]                 }
[13:20:15.553]                 NAMES <- toupper(removed)
[13:20:15.553]                 for (kk in seq_along(NAMES)) {
[13:20:15.553]                   name <- removed[[kk]]
[13:20:15.553]                   NAME <- NAMES[[kk]]
[13:20:15.553]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.553]                     next
[13:20:15.553]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.553]                 }
[13:20:15.553]                 if (length(args) > 0) 
[13:20:15.553]                   base::do.call(base::Sys.setenv, args = args)
[13:20:15.553]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:15.553]             }
[13:20:15.553]             else {
[13:20:15.553]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:15.553]             }
[13:20:15.553]             {
[13:20:15.553]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:15.553]                   0L) {
[13:20:15.553]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:15.553]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:15.553]                   base::options(opts)
[13:20:15.553]                 }
[13:20:15.553]                 {
[13:20:15.553]                   {
[13:20:15.553]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:15.553]                     NULL
[13:20:15.553]                   }
[13:20:15.553]                   options(future.plan = NULL)
[13:20:15.553]                   if (is.na(NA_character_)) 
[13:20:15.553]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.553]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:15.553]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:15.553]                     envir = parent.frame()) 
[13:20:15.553]                   {
[13:20:15.553]                     default_workers <- missing(workers)
[13:20:15.553]                     if (is.function(workers)) 
[13:20:15.553]                       workers <- workers()
[13:20:15.553]                     workers <- structure(as.integer(workers), 
[13:20:15.553]                       class = class(workers))
[13:20:15.553]                     stop_if_not(is.finite(workers), workers >= 
[13:20:15.553]                       1L)
[13:20:15.553]                     if ((workers == 1L && !inherits(workers, 
[13:20:15.553]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:15.553]                       if (default_workers) 
[13:20:15.553]                         supportsMulticore(warn = TRUE)
[13:20:15.553]                       return(sequential(..., envir = envir))
[13:20:15.553]                     }
[13:20:15.553]                     oopts <- options(mc.cores = workers)
[13:20:15.553]                     on.exit(options(oopts))
[13:20:15.553]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:15.553]                       envir = envir)
[13:20:15.553]                     if (!future$lazy) 
[13:20:15.553]                       future <- run(future)
[13:20:15.553]                     invisible(future)
[13:20:15.553]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:15.553]                 }
[13:20:15.553]             }
[13:20:15.553]         }
[13:20:15.553]     })
[13:20:15.553]     if (TRUE) {
[13:20:15.553]         base::sink(type = "output", split = FALSE)
[13:20:15.553]         if (TRUE) {
[13:20:15.553]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:15.553]         }
[13:20:15.553]         else {
[13:20:15.553]             ...future.result["stdout"] <- base::list(NULL)
[13:20:15.553]         }
[13:20:15.553]         base::close(...future.stdout)
[13:20:15.553]         ...future.stdout <- NULL
[13:20:15.553]     }
[13:20:15.553]     ...future.result$conditions <- ...future.conditions
[13:20:15.553]     ...future.result$finished <- base::Sys.time()
[13:20:15.553]     ...future.result
[13:20:15.553] }
[13:20:15.556] assign_globals() ...
[13:20:15.556] List of 1
[13:20:15.556]  $ ii: int 3
[13:20:15.556]  - attr(*, "where")=List of 1
[13:20:15.556]   ..$ ii:<environment: R_EmptyEnv> 
[13:20:15.556]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:15.556]  - attr(*, "resolved")= logi FALSE
[13:20:15.556]  - attr(*, "total_size")= num 56
[13:20:15.556]  - attr(*, "already-done")= logi TRUE
[13:20:15.560] - copied ‘ii’ to environment
[13:20:15.560] assign_globals() ... done
[13:20:15.560] requestCore(): workers = 2
[13:20:15.560] Poll #1 (0): usedCores() = 2, workers = 2
[13:20:15.576] MulticoreFuture started
[13:20:15.576] - Launch lazy future ... done
[13:20:15.576] run() for ‘MulticoreFuture’ ... done
[13:20:15.577] plan(): Setting new future strategy stack:
[13:20:15.577] List of future strategies:
[13:20:15.577] 1. sequential:
[13:20:15.577]    - args: function (..., envir = parent.frame())
[13:20:15.577]    - tweaked: FALSE
[13:20:15.577]    - call: NULL
[13:20:15.578] plan(): nbrOfWorkers() = 1
[13:20:15.580] plan(): Setting new future strategy stack:
[13:20:15.580] List of future strategies:
[13:20:15.580] 1. multicore:
[13:20:15.580]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:15.580]    - tweaked: FALSE
[13:20:15.580]    - call: plan(strategy)
[13:20:15.581] signalConditions() ...
[13:20:15.581]  - include = ‘immediateCondition’
[13:20:15.582]  - exclude = 
[13:20:15.582]  - resignal = FALSE
[13:20:15.582]  - Number of conditions: 1
[13:20:15.582] signalConditions() ... done
[13:20:15.582] signalConditions() ...
[13:20:15.583]  - include = ‘immediateCondition’
[13:20:15.583]  - exclude = 
[13:20:15.583]  - resignal = FALSE
[13:20:15.583]  - Number of conditions: 1
[13:20:15.583] signalConditions() ... done
[13:20:15.584] Future state: ‘finished’
[13:20:15.584] signalConditions() ...
[13:20:15.584]  - include = ‘condition’
[13:20:15.584]  - exclude = ‘immediateCondition’
[13:20:15.584]  - resignal = TRUE
[13:20:15.584]  - Number of conditions: 1
[13:20:15.585]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:20:15.585] signalConditions() ... done
[13:20:15.585] plan(): nbrOfWorkers() = 2
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[13:20:15.586] signalConditions() ...
[13:20:15.587]  - include = ‘immediateCondition’
[13:20:15.587]  - exclude = 
[13:20:15.587]  - resignal = FALSE
[13:20:15.587]  - Number of conditions: 1
[13:20:15.587] signalConditions() ... done
[13:20:15.587] Future state: ‘finished’
[13:20:15.587] signalConditions() ...
[13:20:15.588]  - include = ‘condition’
[13:20:15.588]  - exclude = ‘immediateCondition’
[13:20:15.588]  - resignal = TRUE
[13:20:15.588]  - Number of conditions: 1
[13:20:15.588]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:20:15.588] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[13:20:15.589] signalConditions() ...
[13:20:15.589]  - include = ‘immediateCondition’
[13:20:15.589]  - exclude = 
[13:20:15.589]  - resignal = FALSE
[13:20:15.589]  - Number of conditions: 1
[13:20:15.589] signalConditions() ... done
[13:20:15.589] Future state: ‘finished’
[13:20:15.589] signalConditions() ...
[13:20:15.590]  - include = ‘condition’
[13:20:15.590]  - exclude = ‘immediateCondition’
[13:20:15.590]  - resignal = TRUE
[13:20:15.590]  - Number of conditions: 1
[13:20:15.590]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:20:15.590] signalConditions() ... done
** Future evaluation with a poor-man's "progress bar"
[13:20:15.591] getGlobalsAndPackages() ...
[13:20:15.591] Searching for globals...
[13:20:15.596] - globals found: [4] ‘{’, ‘cat’, ‘for’, ‘:’
[13:20:15.596] Searching for globals ... DONE
[13:20:15.597] Resolving globals: FALSE
[13:20:15.597] 
[13:20:15.597] 
[13:20:15.597] getGlobalsAndPackages() ... DONE
[13:20:15.598] run() for ‘Future’ ...
[13:20:15.598] - state: ‘created’
[13:20:15.598] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:15.602] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:15.602] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:15.603]   - Field: ‘label’
[13:20:15.603]   - Field: ‘local’
[13:20:15.603]   - Field: ‘owner’
[13:20:15.603]   - Field: ‘envir’
[13:20:15.603]   - Field: ‘workers’
[13:20:15.603]   - Field: ‘packages’
[13:20:15.603]   - Field: ‘gc’
[13:20:15.603]   - Field: ‘job’
[13:20:15.604]   - Field: ‘conditions’
[13:20:15.604]   - Field: ‘expr’
[13:20:15.604]   - Field: ‘uuid’
[13:20:15.604]   - Field: ‘seed’
[13:20:15.604]   - Field: ‘version’
[13:20:15.604]   - Field: ‘result’
[13:20:15.604]   - Field: ‘asynchronous’
[13:20:15.604]   - Field: ‘calls’
[13:20:15.604]   - Field: ‘globals’
[13:20:15.605]   - Field: ‘stdout’
[13:20:15.605]   - Field: ‘earlySignal’
[13:20:15.605]   - Field: ‘lazy’
[13:20:15.605]   - Field: ‘state’
[13:20:15.605] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:15.605] - Launch lazy future ...
[13:20:15.606] Packages needed by the future expression (n = 0): <none>
[13:20:15.606] Packages needed by future strategies (n = 0): <none>
[13:20:15.606] {
[13:20:15.606]     {
[13:20:15.606]         {
[13:20:15.606]             ...future.startTime <- base::Sys.time()
[13:20:15.606]             {
[13:20:15.606]                 {
[13:20:15.606]                   {
[13:20:15.606]                     {
[13:20:15.606]                       base::local({
[13:20:15.606]                         has_future <- base::requireNamespace("future", 
[13:20:15.606]                           quietly = TRUE)
[13:20:15.606]                         if (has_future) {
[13:20:15.606]                           ns <- base::getNamespace("future")
[13:20:15.606]                           version <- ns[[".package"]][["version"]]
[13:20:15.606]                           if (is.null(version)) 
[13:20:15.606]                             version <- utils::packageVersion("future")
[13:20:15.606]                         }
[13:20:15.606]                         else {
[13:20:15.606]                           version <- NULL
[13:20:15.606]                         }
[13:20:15.606]                         if (!has_future || version < "1.8.0") {
[13:20:15.606]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:15.606]                             "", base::R.version$version.string), 
[13:20:15.606]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:15.606]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:15.606]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:15.606]                               "release", "version")], collapse = " "), 
[13:20:15.606]                             hostname = base::Sys.info()[["nodename"]])
[13:20:15.606]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:15.606]                             info)
[13:20:15.606]                           info <- base::paste(info, collapse = "; ")
[13:20:15.606]                           if (!has_future) {
[13:20:15.606]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:15.606]                               info)
[13:20:15.606]                           }
[13:20:15.606]                           else {
[13:20:15.606]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:15.606]                               info, version)
[13:20:15.606]                           }
[13:20:15.606]                           base::stop(msg)
[13:20:15.606]                         }
[13:20:15.606]                       })
[13:20:15.606]                     }
[13:20:15.606]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:15.606]                     base::options(mc.cores = 1L)
[13:20:15.606]                   }
[13:20:15.606]                   options(future.plan = NULL)
[13:20:15.606]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.606]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:15.606]                 }
[13:20:15.606]                 ...future.workdir <- getwd()
[13:20:15.606]             }
[13:20:15.606]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:15.606]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:15.606]         }
[13:20:15.606]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:15.606]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:15.606]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:15.606]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:15.606]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:15.606]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:15.606]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:15.606]             base::names(...future.oldOptions))
[13:20:15.606]     }
[13:20:15.606]     if (FALSE) {
[13:20:15.606]     }
[13:20:15.606]     else {
[13:20:15.606]         if (TRUE) {
[13:20:15.606]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:15.606]                 open = "w")
[13:20:15.606]         }
[13:20:15.606]         else {
[13:20:15.606]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:15.606]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:15.606]         }
[13:20:15.606]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:15.606]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:15.606]             base::sink(type = "output", split = FALSE)
[13:20:15.606]             base::close(...future.stdout)
[13:20:15.606]         }, add = TRUE)
[13:20:15.606]     }
[13:20:15.606]     ...future.frame <- base::sys.nframe()
[13:20:15.606]     ...future.conditions <- base::list()
[13:20:15.606]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:15.606]     if (FALSE) {
[13:20:15.606]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:15.606]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:15.606]     }
[13:20:15.606]     ...future.result <- base::tryCatch({
[13:20:15.606]         base::withCallingHandlers({
[13:20:15.606]             ...future.value <- base::withVisible(base::local({
[13:20:15.606]                 withCallingHandlers({
[13:20:15.606]                   {
[13:20:15.606]                     cat("Processing: ")
[13:20:15.606]                     for (ii in 1:10) {
[13:20:15.606]                       cat(".")
[13:20:15.606]                     }
[13:20:15.606]                     cat(" [100%]\n")
[13:20:15.606]                     4
[13:20:15.606]                   }
[13:20:15.606]                 }, immediateCondition = function(cond) {
[13:20:15.606]                   save_rds <- function (object, pathname, ...) 
[13:20:15.606]                   {
[13:20:15.606]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:15.606]                     if (file_test("-f", pathname_tmp)) {
[13:20:15.606]                       fi_tmp <- file.info(pathname_tmp)
[13:20:15.606]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:15.606]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:15.606]                         fi_tmp[["mtime"]])
[13:20:15.606]                     }
[13:20:15.606]                     tryCatch({
[13:20:15.606]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:15.606]                     }, error = function(ex) {
[13:20:15.606]                       msg <- conditionMessage(ex)
[13:20:15.606]                       fi_tmp <- file.info(pathname_tmp)
[13:20:15.606]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:15.606]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:15.606]                         fi_tmp[["mtime"]], msg)
[13:20:15.606]                       ex$message <- msg
[13:20:15.606]                       stop(ex)
[13:20:15.606]                     })
[13:20:15.606]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:15.606]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:15.606]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:15.606]                       fi_tmp <- file.info(pathname_tmp)
[13:20:15.606]                       fi <- file.info(pathname)
[13:20:15.606]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:15.606]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:15.606]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:15.606]                         fi[["size"]], fi[["mtime"]])
[13:20:15.606]                       stop(msg)
[13:20:15.606]                     }
[13:20:15.606]                     invisible(pathname)
[13:20:15.606]                   }
[13:20:15.606]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:15.606]                     rootPath = tempdir()) 
[13:20:15.606]                   {
[13:20:15.606]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:15.606]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:15.606]                       tmpdir = path, fileext = ".rds")
[13:20:15.606]                     save_rds(obj, file)
[13:20:15.606]                   }
[13:20:15.606]                   saveImmediateCondition(cond, path = "/tmp/RtmpakA0rS/.future/immediateConditions")
[13:20:15.606]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.606]                   {
[13:20:15.606]                     inherits <- base::inherits
[13:20:15.606]                     invokeRestart <- base::invokeRestart
[13:20:15.606]                     is.null <- base::is.null
[13:20:15.606]                     muffled <- FALSE
[13:20:15.606]                     if (inherits(cond, "message")) {
[13:20:15.606]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:15.606]                       if (muffled) 
[13:20:15.606]                         invokeRestart("muffleMessage")
[13:20:15.606]                     }
[13:20:15.606]                     else if (inherits(cond, "warning")) {
[13:20:15.606]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:15.606]                       if (muffled) 
[13:20:15.606]                         invokeRestart("muffleWarning")
[13:20:15.606]                     }
[13:20:15.606]                     else if (inherits(cond, "condition")) {
[13:20:15.606]                       if (!is.null(pattern)) {
[13:20:15.606]                         computeRestarts <- base::computeRestarts
[13:20:15.606]                         grepl <- base::grepl
[13:20:15.606]                         restarts <- computeRestarts(cond)
[13:20:15.606]                         for (restart in restarts) {
[13:20:15.606]                           name <- restart$name
[13:20:15.606]                           if (is.null(name)) 
[13:20:15.606]                             next
[13:20:15.606]                           if (!grepl(pattern, name)) 
[13:20:15.606]                             next
[13:20:15.606]                           invokeRestart(restart)
[13:20:15.606]                           muffled <- TRUE
[13:20:15.606]                           break
[13:20:15.606]                         }
[13:20:15.606]                       }
[13:20:15.606]                     }
[13:20:15.606]                     invisible(muffled)
[13:20:15.606]                   }
[13:20:15.606]                   muffleCondition(cond)
[13:20:15.606]                 })
[13:20:15.606]             }))
[13:20:15.606]             future::FutureResult(value = ...future.value$value, 
[13:20:15.606]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.606]                   ...future.rng), globalenv = if (FALSE) 
[13:20:15.606]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:15.606]                     ...future.globalenv.names))
[13:20:15.606]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:15.606]         }, condition = base::local({
[13:20:15.606]             c <- base::c
[13:20:15.606]             inherits <- base::inherits
[13:20:15.606]             invokeRestart <- base::invokeRestart
[13:20:15.606]             length <- base::length
[13:20:15.606]             list <- base::list
[13:20:15.606]             seq.int <- base::seq.int
[13:20:15.606]             signalCondition <- base::signalCondition
[13:20:15.606]             sys.calls <- base::sys.calls
[13:20:15.606]             `[[` <- base::`[[`
[13:20:15.606]             `+` <- base::`+`
[13:20:15.606]             `<<-` <- base::`<<-`
[13:20:15.606]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:15.606]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:15.606]                   3L)]
[13:20:15.606]             }
[13:20:15.606]             function(cond) {
[13:20:15.606]                 is_error <- inherits(cond, "error")
[13:20:15.606]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:15.606]                   NULL)
[13:20:15.606]                 if (is_error) {
[13:20:15.606]                   sessionInformation <- function() {
[13:20:15.606]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:15.606]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:15.606]                       search = base::search(), system = base::Sys.info())
[13:20:15.606]                   }
[13:20:15.606]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.606]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:15.606]                     cond$call), session = sessionInformation(), 
[13:20:15.606]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:15.606]                   signalCondition(cond)
[13:20:15.606]                 }
[13:20:15.606]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:15.606]                 "immediateCondition"))) {
[13:20:15.606]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:15.606]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.606]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:15.606]                   if (TRUE && !signal) {
[13:20:15.606]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.606]                     {
[13:20:15.606]                       inherits <- base::inherits
[13:20:15.606]                       invokeRestart <- base::invokeRestart
[13:20:15.606]                       is.null <- base::is.null
[13:20:15.606]                       muffled <- FALSE
[13:20:15.606]                       if (inherits(cond, "message")) {
[13:20:15.606]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.606]                         if (muffled) 
[13:20:15.606]                           invokeRestart("muffleMessage")
[13:20:15.606]                       }
[13:20:15.606]                       else if (inherits(cond, "warning")) {
[13:20:15.606]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.606]                         if (muffled) 
[13:20:15.606]                           invokeRestart("muffleWarning")
[13:20:15.606]                       }
[13:20:15.606]                       else if (inherits(cond, "condition")) {
[13:20:15.606]                         if (!is.null(pattern)) {
[13:20:15.606]                           computeRestarts <- base::computeRestarts
[13:20:15.606]                           grepl <- base::grepl
[13:20:15.606]                           restarts <- computeRestarts(cond)
[13:20:15.606]                           for (restart in restarts) {
[13:20:15.606]                             name <- restart$name
[13:20:15.606]                             if (is.null(name)) 
[13:20:15.606]                               next
[13:20:15.606]                             if (!grepl(pattern, name)) 
[13:20:15.606]                               next
[13:20:15.606]                             invokeRestart(restart)
[13:20:15.606]                             muffled <- TRUE
[13:20:15.606]                             break
[13:20:15.606]                           }
[13:20:15.606]                         }
[13:20:15.606]                       }
[13:20:15.606]                       invisible(muffled)
[13:20:15.606]                     }
[13:20:15.606]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.606]                   }
[13:20:15.606]                 }
[13:20:15.606]                 else {
[13:20:15.606]                   if (TRUE) {
[13:20:15.606]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.606]                     {
[13:20:15.606]                       inherits <- base::inherits
[13:20:15.606]                       invokeRestart <- base::invokeRestart
[13:20:15.606]                       is.null <- base::is.null
[13:20:15.606]                       muffled <- FALSE
[13:20:15.606]                       if (inherits(cond, "message")) {
[13:20:15.606]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.606]                         if (muffled) 
[13:20:15.606]                           invokeRestart("muffleMessage")
[13:20:15.606]                       }
[13:20:15.606]                       else if (inherits(cond, "warning")) {
[13:20:15.606]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.606]                         if (muffled) 
[13:20:15.606]                           invokeRestart("muffleWarning")
[13:20:15.606]                       }
[13:20:15.606]                       else if (inherits(cond, "condition")) {
[13:20:15.606]                         if (!is.null(pattern)) {
[13:20:15.606]                           computeRestarts <- base::computeRestarts
[13:20:15.606]                           grepl <- base::grepl
[13:20:15.606]                           restarts <- computeRestarts(cond)
[13:20:15.606]                           for (restart in restarts) {
[13:20:15.606]                             name <- restart$name
[13:20:15.606]                             if (is.null(name)) 
[13:20:15.606]                               next
[13:20:15.606]                             if (!grepl(pattern, name)) 
[13:20:15.606]                               next
[13:20:15.606]                             invokeRestart(restart)
[13:20:15.606]                             muffled <- TRUE
[13:20:15.606]                             break
[13:20:15.606]                           }
[13:20:15.606]                         }
[13:20:15.606]                       }
[13:20:15.606]                       invisible(muffled)
[13:20:15.606]                     }
[13:20:15.606]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.606]                   }
[13:20:15.606]                 }
[13:20:15.606]             }
[13:20:15.606]         }))
[13:20:15.606]     }, error = function(ex) {
[13:20:15.606]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:15.606]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.606]                 ...future.rng), started = ...future.startTime, 
[13:20:15.606]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:15.606]             version = "1.8"), class = "FutureResult")
[13:20:15.606]     }, finally = {
[13:20:15.606]         if (!identical(...future.workdir, getwd())) 
[13:20:15.606]             setwd(...future.workdir)
[13:20:15.606]         {
[13:20:15.606]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:15.606]                 ...future.oldOptions$nwarnings <- NULL
[13:20:15.606]             }
[13:20:15.606]             base::options(...future.oldOptions)
[13:20:15.606]             if (.Platform$OS.type == "windows") {
[13:20:15.606]                 old_names <- names(...future.oldEnvVars)
[13:20:15.606]                 envs <- base::Sys.getenv()
[13:20:15.606]                 names <- names(envs)
[13:20:15.606]                 common <- intersect(names, old_names)
[13:20:15.606]                 added <- setdiff(names, old_names)
[13:20:15.606]                 removed <- setdiff(old_names, names)
[13:20:15.606]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:15.606]                   envs[common]]
[13:20:15.606]                 NAMES <- toupper(changed)
[13:20:15.606]                 args <- list()
[13:20:15.606]                 for (kk in seq_along(NAMES)) {
[13:20:15.606]                   name <- changed[[kk]]
[13:20:15.606]                   NAME <- NAMES[[kk]]
[13:20:15.606]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.606]                     next
[13:20:15.606]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.606]                 }
[13:20:15.606]                 NAMES <- toupper(added)
[13:20:15.606]                 for (kk in seq_along(NAMES)) {
[13:20:15.606]                   name <- added[[kk]]
[13:20:15.606]                   NAME <- NAMES[[kk]]
[13:20:15.606]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.606]                     next
[13:20:15.606]                   args[[name]] <- ""
[13:20:15.606]                 }
[13:20:15.606]                 NAMES <- toupper(removed)
[13:20:15.606]                 for (kk in seq_along(NAMES)) {
[13:20:15.606]                   name <- removed[[kk]]
[13:20:15.606]                   NAME <- NAMES[[kk]]
[13:20:15.606]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.606]                     next
[13:20:15.606]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.606]                 }
[13:20:15.606]                 if (length(args) > 0) 
[13:20:15.606]                   base::do.call(base::Sys.setenv, args = args)
[13:20:15.606]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:15.606]             }
[13:20:15.606]             else {
[13:20:15.606]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:15.606]             }
[13:20:15.606]             {
[13:20:15.606]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:15.606]                   0L) {
[13:20:15.606]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:15.606]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:15.606]                   base::options(opts)
[13:20:15.606]                 }
[13:20:15.606]                 {
[13:20:15.606]                   {
[13:20:15.606]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:15.606]                     NULL
[13:20:15.606]                   }
[13:20:15.606]                   options(future.plan = NULL)
[13:20:15.606]                   if (is.na(NA_character_)) 
[13:20:15.606]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.606]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:15.606]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:15.606]                     envir = parent.frame()) 
[13:20:15.606]                   {
[13:20:15.606]                     default_workers <- missing(workers)
[13:20:15.606]                     if (is.function(workers)) 
[13:20:15.606]                       workers <- workers()
[13:20:15.606]                     workers <- structure(as.integer(workers), 
[13:20:15.606]                       class = class(workers))
[13:20:15.606]                     stop_if_not(is.finite(workers), workers >= 
[13:20:15.606]                       1L)
[13:20:15.606]                     if ((workers == 1L && !inherits(workers, 
[13:20:15.606]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:15.606]                       if (default_workers) 
[13:20:15.606]                         supportsMulticore(warn = TRUE)
[13:20:15.606]                       return(sequential(..., envir = envir))
[13:20:15.606]                     }
[13:20:15.606]                     oopts <- options(mc.cores = workers)
[13:20:15.606]                     on.exit(options(oopts))
[13:20:15.606]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:15.606]                       envir = envir)
[13:20:15.606]                     if (!future$lazy) 
[13:20:15.606]                       future <- run(future)
[13:20:15.606]                     invisible(future)
[13:20:15.606]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:15.606]                 }
[13:20:15.606]             }
[13:20:15.606]         }
[13:20:15.606]     })
[13:20:15.606]     if (TRUE) {
[13:20:15.606]         base::sink(type = "output", split = FALSE)
[13:20:15.606]         if (TRUE) {
[13:20:15.606]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:15.606]         }
[13:20:15.606]         else {
[13:20:15.606]             ...future.result["stdout"] <- base::list(NULL)
[13:20:15.606]         }
[13:20:15.606]         base::close(...future.stdout)
[13:20:15.606]         ...future.stdout <- NULL
[13:20:15.606]     }
[13:20:15.606]     ...future.result$conditions <- ...future.conditions
[13:20:15.606]     ...future.result$finished <- base::Sys.time()
[13:20:15.606]     ...future.result
[13:20:15.606] }
[13:20:15.609] requestCore(): workers = 2
[13:20:15.611] MulticoreFuture started
[13:20:15.611] - Launch lazy future ... done
[13:20:15.612] run() for ‘MulticoreFuture’ ... done
** Collecting results
v1 = 1
v2 = 2
[13:20:15.612] plan(): Setting new future strategy stack:
Warning in sprintf(...) : restarting interrupted promise evaluation
[13:20:15.613] signalConditions() ...
[13:20:15.613]  - include = ‘immediateCondition’
[13:20:15.612] List of future strategies:
[13:20:15.612] 1. sequential:
[13:20:15.612]    - args: function (..., envir = parent.frame())
[13:20:15.612]    - tweaked: FALSE
[13:20:15.612]    - call: NULL
[13:20:15.613]  - exclude = 
[13:20:15.613]  - resignal = FALSE
[13:20:15.613]  - Number of conditions: 1
[13:20:15.613] plan(): nbrOfWorkers() = 1
[13:20:15.614] signalConditions() ... done
[13:20:15.614] Future state: ‘finished’
[13:20:15.614] signalConditions() ...
[13:20:15.614]  - include = ‘condition’
[13:20:15.614]  - exclude = ‘immediateCondition’
[13:20:15.614]  - resignal = TRUE
[13:20:15.615]  - Number of conditions: 1
[13:20:15.615]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:20:15.615] signalConditions() ... done
v3: <simpleError> (as expect)
[13:20:15.615] plan(): Setting new future strategy stack:
[13:20:15.616] List of future strategies:
[13:20:15.616] 1. multicore:
[13:20:15.616]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:15.616]    - tweaked: FALSE
[13:20:15.616]    - call: plan(strategy)
[13:20:15.621] plan(): nbrOfWorkers() = 2
Processing: .......... [100%]
v4 = 4
** Left-to-right and right-to-left future assignments
[13:20:15.622] getGlobalsAndPackages() ...
[13:20:15.622] Searching for globals...
[13:20:15.623] 
[13:20:15.623] Searching for globals ... DONE
[13:20:15.623] - globals: [0] <none>
[13:20:15.623] getGlobalsAndPackages() ... DONE
[13:20:15.624] run() for ‘Future’ ...
[13:20:15.624] - state: ‘created’
[13:20:15.624] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:15.628] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:15.628] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:15.629]   - Field: ‘label’
[13:20:15.629]   - Field: ‘local’
[13:20:15.629]   - Field: ‘owner’
[13:20:15.629]   - Field: ‘envir’
[13:20:15.629]   - Field: ‘workers’
[13:20:15.629]   - Field: ‘packages’
[13:20:15.629]   - Field: ‘gc’
[13:20:15.629]   - Field: ‘job’
[13:20:15.630]   - Field: ‘conditions’
[13:20:15.630]   - Field: ‘expr’
[13:20:15.630]   - Field: ‘uuid’
[13:20:15.630]   - Field: ‘seed’
[13:20:15.630]   - Field: ‘version’
[13:20:15.630]   - Field: ‘result’
[13:20:15.630]   - Field: ‘asynchronous’
[13:20:15.630]   - Field: ‘calls’
[13:20:15.630]   - Field: ‘globals’
[13:20:15.630]   - Field: ‘stdout’
[13:20:15.631]   - Field: ‘earlySignal’
[13:20:15.631]   - Field: ‘lazy’
[13:20:15.631]   - Field: ‘state’
[13:20:15.631] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:15.631] - Launch lazy future ...
[13:20:15.631] Packages needed by the future expression (n = 0): <none>
[13:20:15.632] Packages needed by future strategies (n = 0): <none>
[13:20:15.632] {
[13:20:15.632]     {
[13:20:15.632]         {
[13:20:15.632]             ...future.startTime <- base::Sys.time()
[13:20:15.632]             {
[13:20:15.632]                 {
[13:20:15.632]                   {
[13:20:15.632]                     {
[13:20:15.632]                       base::local({
[13:20:15.632]                         has_future <- base::requireNamespace("future", 
[13:20:15.632]                           quietly = TRUE)
[13:20:15.632]                         if (has_future) {
[13:20:15.632]                           ns <- base::getNamespace("future")
[13:20:15.632]                           version <- ns[[".package"]][["version"]]
[13:20:15.632]                           if (is.null(version)) 
[13:20:15.632]                             version <- utils::packageVersion("future")
[13:20:15.632]                         }
[13:20:15.632]                         else {
[13:20:15.632]                           version <- NULL
[13:20:15.632]                         }
[13:20:15.632]                         if (!has_future || version < "1.8.0") {
[13:20:15.632]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:15.632]                             "", base::R.version$version.string), 
[13:20:15.632]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:15.632]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:15.632]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:15.632]                               "release", "version")], collapse = " "), 
[13:20:15.632]                             hostname = base::Sys.info()[["nodename"]])
[13:20:15.632]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:15.632]                             info)
[13:20:15.632]                           info <- base::paste(info, collapse = "; ")
[13:20:15.632]                           if (!has_future) {
[13:20:15.632]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:15.632]                               info)
[13:20:15.632]                           }
[13:20:15.632]                           else {
[13:20:15.632]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:15.632]                               info, version)
[13:20:15.632]                           }
[13:20:15.632]                           base::stop(msg)
[13:20:15.632]                         }
[13:20:15.632]                       })
[13:20:15.632]                     }
[13:20:15.632]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:15.632]                     base::options(mc.cores = 1L)
[13:20:15.632]                   }
[13:20:15.632]                   options(future.plan = NULL)
[13:20:15.632]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.632]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:15.632]                 }
[13:20:15.632]                 ...future.workdir <- getwd()
[13:20:15.632]             }
[13:20:15.632]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:15.632]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:15.632]         }
[13:20:15.632]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:15.632]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:15.632]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:15.632]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:15.632]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:15.632]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:15.632]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:15.632]             base::names(...future.oldOptions))
[13:20:15.632]     }
[13:20:15.632]     if (FALSE) {
[13:20:15.632]     }
[13:20:15.632]     else {
[13:20:15.632]         if (TRUE) {
[13:20:15.632]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:15.632]                 open = "w")
[13:20:15.632]         }
[13:20:15.632]         else {
[13:20:15.632]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:15.632]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:15.632]         }
[13:20:15.632]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:15.632]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:15.632]             base::sink(type = "output", split = FALSE)
[13:20:15.632]             base::close(...future.stdout)
[13:20:15.632]         }, add = TRUE)
[13:20:15.632]     }
[13:20:15.632]     ...future.frame <- base::sys.nframe()
[13:20:15.632]     ...future.conditions <- base::list()
[13:20:15.632]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:15.632]     if (FALSE) {
[13:20:15.632]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:15.632]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:15.632]     }
[13:20:15.632]     ...future.result <- base::tryCatch({
[13:20:15.632]         base::withCallingHandlers({
[13:20:15.632]             ...future.value <- base::withVisible(base::local({
[13:20:15.632]                 withCallingHandlers({
[13:20:15.632]                   1
[13:20:15.632]                 }, immediateCondition = function(cond) {
[13:20:15.632]                   save_rds <- function (object, pathname, ...) 
[13:20:15.632]                   {
[13:20:15.632]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:15.632]                     if (file_test("-f", pathname_tmp)) {
[13:20:15.632]                       fi_tmp <- file.info(pathname_tmp)
[13:20:15.632]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:15.632]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:15.632]                         fi_tmp[["mtime"]])
[13:20:15.632]                     }
[13:20:15.632]                     tryCatch({
[13:20:15.632]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:15.632]                     }, error = function(ex) {
[13:20:15.632]                       msg <- conditionMessage(ex)
[13:20:15.632]                       fi_tmp <- file.info(pathname_tmp)
[13:20:15.632]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:15.632]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:15.632]                         fi_tmp[["mtime"]], msg)
[13:20:15.632]                       ex$message <- msg
[13:20:15.632]                       stop(ex)
[13:20:15.632]                     })
[13:20:15.632]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:15.632]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:15.632]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:15.632]                       fi_tmp <- file.info(pathname_tmp)
[13:20:15.632]                       fi <- file.info(pathname)
[13:20:15.632]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:15.632]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:15.632]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:15.632]                         fi[["size"]], fi[["mtime"]])
[13:20:15.632]                       stop(msg)
[13:20:15.632]                     }
[13:20:15.632]                     invisible(pathname)
[13:20:15.632]                   }
[13:20:15.632]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:15.632]                     rootPath = tempdir()) 
[13:20:15.632]                   {
[13:20:15.632]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:15.632]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:15.632]                       tmpdir = path, fileext = ".rds")
[13:20:15.632]                     save_rds(obj, file)
[13:20:15.632]                   }
[13:20:15.632]                   saveImmediateCondition(cond, path = "/tmp/RtmpakA0rS/.future/immediateConditions")
[13:20:15.632]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.632]                   {
[13:20:15.632]                     inherits <- base::inherits
[13:20:15.632]                     invokeRestart <- base::invokeRestart
[13:20:15.632]                     is.null <- base::is.null
[13:20:15.632]                     muffled <- FALSE
[13:20:15.632]                     if (inherits(cond, "message")) {
[13:20:15.632]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:15.632]                       if (muffled) 
[13:20:15.632]                         invokeRestart("muffleMessage")
[13:20:15.632]                     }
[13:20:15.632]                     else if (inherits(cond, "warning")) {
[13:20:15.632]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:15.632]                       if (muffled) 
[13:20:15.632]                         invokeRestart("muffleWarning")
[13:20:15.632]                     }
[13:20:15.632]                     else if (inherits(cond, "condition")) {
[13:20:15.632]                       if (!is.null(pattern)) {
[13:20:15.632]                         computeRestarts <- base::computeRestarts
[13:20:15.632]                         grepl <- base::grepl
[13:20:15.632]                         restarts <- computeRestarts(cond)
[13:20:15.632]                         for (restart in restarts) {
[13:20:15.632]                           name <- restart$name
[13:20:15.632]                           if (is.null(name)) 
[13:20:15.632]                             next
[13:20:15.632]                           if (!grepl(pattern, name)) 
[13:20:15.632]                             next
[13:20:15.632]                           invokeRestart(restart)
[13:20:15.632]                           muffled <- TRUE
[13:20:15.632]                           break
[13:20:15.632]                         }
[13:20:15.632]                       }
[13:20:15.632]                     }
[13:20:15.632]                     invisible(muffled)
[13:20:15.632]                   }
[13:20:15.632]                   muffleCondition(cond)
[13:20:15.632]                 })
[13:20:15.632]             }))
[13:20:15.632]             future::FutureResult(value = ...future.value$value, 
[13:20:15.632]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.632]                   ...future.rng), globalenv = if (FALSE) 
[13:20:15.632]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:15.632]                     ...future.globalenv.names))
[13:20:15.632]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:15.632]         }, condition = base::local({
[13:20:15.632]             c <- base::c
[13:20:15.632]             inherits <- base::inherits
[13:20:15.632]             invokeRestart <- base::invokeRestart
[13:20:15.632]             length <- base::length
[13:20:15.632]             list <- base::list
[13:20:15.632]             seq.int <- base::seq.int
[13:20:15.632]             signalCondition <- base::signalCondition
[13:20:15.632]             sys.calls <- base::sys.calls
[13:20:15.632]             `[[` <- base::`[[`
[13:20:15.632]             `+` <- base::`+`
[13:20:15.632]             `<<-` <- base::`<<-`
[13:20:15.632]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:15.632]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:15.632]                   3L)]
[13:20:15.632]             }
[13:20:15.632]             function(cond) {
[13:20:15.632]                 is_error <- inherits(cond, "error")
[13:20:15.632]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:15.632]                   NULL)
[13:20:15.632]                 if (is_error) {
[13:20:15.632]                   sessionInformation <- function() {
[13:20:15.632]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:15.632]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:15.632]                       search = base::search(), system = base::Sys.info())
[13:20:15.632]                   }
[13:20:15.632]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.632]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:15.632]                     cond$call), session = sessionInformation(), 
[13:20:15.632]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:15.632]                   signalCondition(cond)
[13:20:15.632]                 }
[13:20:15.632]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:15.632]                 "immediateCondition"))) {
[13:20:15.632]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:15.632]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.632]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:15.632]                   if (TRUE && !signal) {
[13:20:15.632]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.632]                     {
[13:20:15.632]                       inherits <- base::inherits
[13:20:15.632]                       invokeRestart <- base::invokeRestart
[13:20:15.632]                       is.null <- base::is.null
[13:20:15.632]                       muffled <- FALSE
[13:20:15.632]                       if (inherits(cond, "message")) {
[13:20:15.632]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.632]                         if (muffled) 
[13:20:15.632]                           invokeRestart("muffleMessage")
[13:20:15.632]                       }
[13:20:15.632]                       else if (inherits(cond, "warning")) {
[13:20:15.632]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.632]                         if (muffled) 
[13:20:15.632]                           invokeRestart("muffleWarning")
[13:20:15.632]                       }
[13:20:15.632]                       else if (inherits(cond, "condition")) {
[13:20:15.632]                         if (!is.null(pattern)) {
[13:20:15.632]                           computeRestarts <- base::computeRestarts
[13:20:15.632]                           grepl <- base::grepl
[13:20:15.632]                           restarts <- computeRestarts(cond)
[13:20:15.632]                           for (restart in restarts) {
[13:20:15.632]                             name <- restart$name
[13:20:15.632]                             if (is.null(name)) 
[13:20:15.632]                               next
[13:20:15.632]                             if (!grepl(pattern, name)) 
[13:20:15.632]                               next
[13:20:15.632]                             invokeRestart(restart)
[13:20:15.632]                             muffled <- TRUE
[13:20:15.632]                             break
[13:20:15.632]                           }
[13:20:15.632]                         }
[13:20:15.632]                       }
[13:20:15.632]                       invisible(muffled)
[13:20:15.632]                     }
[13:20:15.632]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.632]                   }
[13:20:15.632]                 }
[13:20:15.632]                 else {
[13:20:15.632]                   if (TRUE) {
[13:20:15.632]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.632]                     {
[13:20:15.632]                       inherits <- base::inherits
[13:20:15.632]                       invokeRestart <- base::invokeRestart
[13:20:15.632]                       is.null <- base::is.null
[13:20:15.632]                       muffled <- FALSE
[13:20:15.632]                       if (inherits(cond, "message")) {
[13:20:15.632]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.632]                         if (muffled) 
[13:20:15.632]                           invokeRestart("muffleMessage")
[13:20:15.632]                       }
[13:20:15.632]                       else if (inherits(cond, "warning")) {
[13:20:15.632]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.632]                         if (muffled) 
[13:20:15.632]                           invokeRestart("muffleWarning")
[13:20:15.632]                       }
[13:20:15.632]                       else if (inherits(cond, "condition")) {
[13:20:15.632]                         if (!is.null(pattern)) {
[13:20:15.632]                           computeRestarts <- base::computeRestarts
[13:20:15.632]                           grepl <- base::grepl
[13:20:15.632]                           restarts <- computeRestarts(cond)
[13:20:15.632]                           for (restart in restarts) {
[13:20:15.632]                             name <- restart$name
[13:20:15.632]                             if (is.null(name)) 
[13:20:15.632]                               next
[13:20:15.632]                             if (!grepl(pattern, name)) 
[13:20:15.632]                               next
[13:20:15.632]                             invokeRestart(restart)
[13:20:15.632]                             muffled <- TRUE
[13:20:15.632]                             break
[13:20:15.632]                           }
[13:20:15.632]                         }
[13:20:15.632]                       }
[13:20:15.632]                       invisible(muffled)
[13:20:15.632]                     }
[13:20:15.632]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.632]                   }
[13:20:15.632]                 }
[13:20:15.632]             }
[13:20:15.632]         }))
[13:20:15.632]     }, error = function(ex) {
[13:20:15.632]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:15.632]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.632]                 ...future.rng), started = ...future.startTime, 
[13:20:15.632]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:15.632]             version = "1.8"), class = "FutureResult")
[13:20:15.632]     }, finally = {
[13:20:15.632]         if (!identical(...future.workdir, getwd())) 
[13:20:15.632]             setwd(...future.workdir)
[13:20:15.632]         {
[13:20:15.632]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:15.632]                 ...future.oldOptions$nwarnings <- NULL
[13:20:15.632]             }
[13:20:15.632]             base::options(...future.oldOptions)
[13:20:15.632]             if (.Platform$OS.type == "windows") {
[13:20:15.632]                 old_names <- names(...future.oldEnvVars)
[13:20:15.632]                 envs <- base::Sys.getenv()
[13:20:15.632]                 names <- names(envs)
[13:20:15.632]                 common <- intersect(names, old_names)
[13:20:15.632]                 added <- setdiff(names, old_names)
[13:20:15.632]                 removed <- setdiff(old_names, names)
[13:20:15.632]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:15.632]                   envs[common]]
[13:20:15.632]                 NAMES <- toupper(changed)
[13:20:15.632]                 args <- list()
[13:20:15.632]                 for (kk in seq_along(NAMES)) {
[13:20:15.632]                   name <- changed[[kk]]
[13:20:15.632]                   NAME <- NAMES[[kk]]
[13:20:15.632]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.632]                     next
[13:20:15.632]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.632]                 }
[13:20:15.632]                 NAMES <- toupper(added)
[13:20:15.632]                 for (kk in seq_along(NAMES)) {
[13:20:15.632]                   name <- added[[kk]]
[13:20:15.632]                   NAME <- NAMES[[kk]]
[13:20:15.632]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.632]                     next
[13:20:15.632]                   args[[name]] <- ""
[13:20:15.632]                 }
[13:20:15.632]                 NAMES <- toupper(removed)
[13:20:15.632]                 for (kk in seq_along(NAMES)) {
[13:20:15.632]                   name <- removed[[kk]]
[13:20:15.632]                   NAME <- NAMES[[kk]]
[13:20:15.632]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.632]                     next
[13:20:15.632]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.632]                 }
[13:20:15.632]                 if (length(args) > 0) 
[13:20:15.632]                   base::do.call(base::Sys.setenv, args = args)
[13:20:15.632]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:15.632]             }
[13:20:15.632]             else {
[13:20:15.632]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:15.632]             }
[13:20:15.632]             {
[13:20:15.632]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:15.632]                   0L) {
[13:20:15.632]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:15.632]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:15.632]                   base::options(opts)
[13:20:15.632]                 }
[13:20:15.632]                 {
[13:20:15.632]                   {
[13:20:15.632]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:15.632]                     NULL
[13:20:15.632]                   }
[13:20:15.632]                   options(future.plan = NULL)
[13:20:15.632]                   if (is.na(NA_character_)) 
[13:20:15.632]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.632]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:15.632]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:15.632]                     envir = parent.frame()) 
[13:20:15.632]                   {
[13:20:15.632]                     default_workers <- missing(workers)
[13:20:15.632]                     if (is.function(workers)) 
[13:20:15.632]                       workers <- workers()
[13:20:15.632]                     workers <- structure(as.integer(workers), 
[13:20:15.632]                       class = class(workers))
[13:20:15.632]                     stop_if_not(is.finite(workers), workers >= 
[13:20:15.632]                       1L)
[13:20:15.632]                     if ((workers == 1L && !inherits(workers, 
[13:20:15.632]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:15.632]                       if (default_workers) 
[13:20:15.632]                         supportsMulticore(warn = TRUE)
[13:20:15.632]                       return(sequential(..., envir = envir))
[13:20:15.632]                     }
[13:20:15.632]                     oopts <- options(mc.cores = workers)
[13:20:15.632]                     on.exit(options(oopts))
[13:20:15.632]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:15.632]                       envir = envir)
[13:20:15.632]                     if (!future$lazy) 
[13:20:15.632]                       future <- run(future)
[13:20:15.632]                     invisible(future)
[13:20:15.632]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:15.632]                 }
[13:20:15.632]             }
[13:20:15.632]         }
[13:20:15.632]     })
[13:20:15.632]     if (TRUE) {
[13:20:15.632]         base::sink(type = "output", split = FALSE)
[13:20:15.632]         if (TRUE) {
[13:20:15.632]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:15.632]         }
[13:20:15.632]         else {
[13:20:15.632]             ...future.result["stdout"] <- base::list(NULL)
[13:20:15.632]         }
[13:20:15.632]         base::close(...future.stdout)
[13:20:15.632]         ...future.stdout <- NULL
[13:20:15.632]     }
[13:20:15.632]     ...future.result$conditions <- ...future.conditions
[13:20:15.632]     ...future.result$finished <- base::Sys.time()
[13:20:15.632]     ...future.result
[13:20:15.632] }
[13:20:15.635] requestCore(): workers = 2
[13:20:15.637] MulticoreFuture started
[13:20:15.637] - Launch lazy future ... done
[13:20:15.637] run() for ‘MulticoreFuture’ ... done
[13:20:15.638] plan(): Setting new future strategy stack:
[13:20:15.638] List of future strategies:
[13:20:15.638] 1. sequential:
[13:20:15.638]    - args: function (..., envir = parent.frame())
[13:20:15.638]    - tweaked: FALSE
[13:20:15.638]    - call: NULL
[13:20:15.639] plan(): nbrOfWorkers() = 1
[13:20:15.641] plan(): Setting new future strategy stack:
[13:20:15.641] List of future strategies:
[13:20:15.641] 1. multicore:
[13:20:15.641]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:15.641]    - tweaked: FALSE
[13:20:15.641]    - call: plan(strategy)
[13:20:15.651] plan(): nbrOfWorkers() = 2
c = 1
[13:20:15.652] getGlobalsAndPackages() ...
[13:20:15.652] Searching for globals...
[13:20:15.653] 
[13:20:15.653] Searching for globals ... DONE
[13:20:15.653] - globals: [0] <none>
[13:20:15.653] getGlobalsAndPackages() ... DONE
[13:20:15.653] run() for ‘Future’ ...
[13:20:15.654] - state: ‘created’
[13:20:15.654] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:15.661] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:15.661] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:15.661]   - Field: ‘label’
[13:20:15.662]   - Field: ‘local’
[13:20:15.662]   - Field: ‘owner’
[13:20:15.662]   - Field: ‘envir’
[13:20:15.662]   - Field: ‘workers’
[13:20:15.662]   - Field: ‘packages’
[13:20:15.662]   - Field: ‘gc’
[13:20:15.662]   - Field: ‘job’
[13:20:15.662]   - Field: ‘conditions’
[13:20:15.663]   - Field: ‘expr’
[13:20:15.663]   - Field: ‘uuid’
[13:20:15.663]   - Field: ‘seed’
[13:20:15.663]   - Field: ‘version’
[13:20:15.663]   - Field: ‘result’
[13:20:15.663]   - Field: ‘asynchronous’
[13:20:15.663]   - Field: ‘calls’
[13:20:15.664]   - Field: ‘globals’
[13:20:15.664]   - Field: ‘stdout’
[13:20:15.664]   - Field: ‘earlySignal’
[13:20:15.664]   - Field: ‘lazy’
[13:20:15.664]   - Field: ‘state’
[13:20:15.664] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:15.664] - Launch lazy future ...
[13:20:15.665] Packages needed by the future expression (n = 0): <none>
[13:20:15.665] Packages needed by future strategies (n = 0): <none>
[13:20:15.665] {
[13:20:15.665]     {
[13:20:15.665]         {
[13:20:15.665]             ...future.startTime <- base::Sys.time()
[13:20:15.665]             {
[13:20:15.665]                 {
[13:20:15.665]                   {
[13:20:15.665]                     {
[13:20:15.665]                       base::local({
[13:20:15.665]                         has_future <- base::requireNamespace("future", 
[13:20:15.665]                           quietly = TRUE)
[13:20:15.665]                         if (has_future) {
[13:20:15.665]                           ns <- base::getNamespace("future")
[13:20:15.665]                           version <- ns[[".package"]][["version"]]
[13:20:15.665]                           if (is.null(version)) 
[13:20:15.665]                             version <- utils::packageVersion("future")
[13:20:15.665]                         }
[13:20:15.665]                         else {
[13:20:15.665]                           version <- NULL
[13:20:15.665]                         }
[13:20:15.665]                         if (!has_future || version < "1.8.0") {
[13:20:15.665]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:15.665]                             "", base::R.version$version.string), 
[13:20:15.665]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:15.665]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:15.665]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:15.665]                               "release", "version")], collapse = " "), 
[13:20:15.665]                             hostname = base::Sys.info()[["nodename"]])
[13:20:15.665]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:15.665]                             info)
[13:20:15.665]                           info <- base::paste(info, collapse = "; ")
[13:20:15.665]                           if (!has_future) {
[13:20:15.665]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:15.665]                               info)
[13:20:15.665]                           }
[13:20:15.665]                           else {
[13:20:15.665]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:15.665]                               info, version)
[13:20:15.665]                           }
[13:20:15.665]                           base::stop(msg)
[13:20:15.665]                         }
[13:20:15.665]                       })
[13:20:15.665]                     }
[13:20:15.665]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:15.665]                     base::options(mc.cores = 1L)
[13:20:15.665]                   }
[13:20:15.665]                   options(future.plan = NULL)
[13:20:15.665]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.665]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:15.665]                 }
[13:20:15.665]                 ...future.workdir <- getwd()
[13:20:15.665]             }
[13:20:15.665]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:15.665]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:15.665]         }
[13:20:15.665]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:15.665]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:15.665]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:15.665]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:15.665]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:15.665]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:15.665]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:15.665]             base::names(...future.oldOptions))
[13:20:15.665]     }
[13:20:15.665]     if (FALSE) {
[13:20:15.665]     }
[13:20:15.665]     else {
[13:20:15.665]         if (TRUE) {
[13:20:15.665]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:15.665]                 open = "w")
[13:20:15.665]         }
[13:20:15.665]         else {
[13:20:15.665]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:15.665]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:15.665]         }
[13:20:15.665]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:15.665]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:15.665]             base::sink(type = "output", split = FALSE)
[13:20:15.665]             base::close(...future.stdout)
[13:20:15.665]         }, add = TRUE)
[13:20:15.665]     }
[13:20:15.665]     ...future.frame <- base::sys.nframe()
[13:20:15.665]     ...future.conditions <- base::list()
[13:20:15.665]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:15.665]     if (FALSE) {
[13:20:15.665]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:15.665]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:15.665]     }
[13:20:15.665]     ...future.result <- base::tryCatch({
[13:20:15.665]         base::withCallingHandlers({
[13:20:15.665]             ...future.value <- base::withVisible(base::local({
[13:20:15.665]                 withCallingHandlers({
[13:20:15.665]                   1
[13:20:15.665]                 }, immediateCondition = function(cond) {
[13:20:15.665]                   save_rds <- function (object, pathname, ...) 
[13:20:15.665]                   {
[13:20:15.665]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:15.665]                     if (file_test("-f", pathname_tmp)) {
[13:20:15.665]                       fi_tmp <- file.info(pathname_tmp)
[13:20:15.665]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:15.665]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:15.665]                         fi_tmp[["mtime"]])
[13:20:15.665]                     }
[13:20:15.665]                     tryCatch({
[13:20:15.665]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:15.665]                     }, error = function(ex) {
[13:20:15.665]                       msg <- conditionMessage(ex)
[13:20:15.665]                       fi_tmp <- file.info(pathname_tmp)
[13:20:15.665]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:15.665]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:15.665]                         fi_tmp[["mtime"]], msg)
[13:20:15.665]                       ex$message <- msg
[13:20:15.665]                       stop(ex)
[13:20:15.665]                     })
[13:20:15.665]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:15.665]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:15.665]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:15.665]                       fi_tmp <- file.info(pathname_tmp)
[13:20:15.665]                       fi <- file.info(pathname)
[13:20:15.665]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:15.665]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:15.665]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:15.665]                         fi[["size"]], fi[["mtime"]])
[13:20:15.665]                       stop(msg)
[13:20:15.665]                     }
[13:20:15.665]                     invisible(pathname)
[13:20:15.665]                   }
[13:20:15.665]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:15.665]                     rootPath = tempdir()) 
[13:20:15.665]                   {
[13:20:15.665]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:15.665]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:15.665]                       tmpdir = path, fileext = ".rds")
[13:20:15.665]                     save_rds(obj, file)
[13:20:15.665]                   }
[13:20:15.665]                   saveImmediateCondition(cond, path = "/tmp/RtmpakA0rS/.future/immediateConditions")
[13:20:15.665]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.665]                   {
[13:20:15.665]                     inherits <- base::inherits
[13:20:15.665]                     invokeRestart <- base::invokeRestart
[13:20:15.665]                     is.null <- base::is.null
[13:20:15.665]                     muffled <- FALSE
[13:20:15.665]                     if (inherits(cond, "message")) {
[13:20:15.665]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:15.665]                       if (muffled) 
[13:20:15.665]                         invokeRestart("muffleMessage")
[13:20:15.665]                     }
[13:20:15.665]                     else if (inherits(cond, "warning")) {
[13:20:15.665]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:15.665]                       if (muffled) 
[13:20:15.665]                         invokeRestart("muffleWarning")
[13:20:15.665]                     }
[13:20:15.665]                     else if (inherits(cond, "condition")) {
[13:20:15.665]                       if (!is.null(pattern)) {
[13:20:15.665]                         computeRestarts <- base::computeRestarts
[13:20:15.665]                         grepl <- base::grepl
[13:20:15.665]                         restarts <- computeRestarts(cond)
[13:20:15.665]                         for (restart in restarts) {
[13:20:15.665]                           name <- restart$name
[13:20:15.665]                           if (is.null(name)) 
[13:20:15.665]                             next
[13:20:15.665]                           if (!grepl(pattern, name)) 
[13:20:15.665]                             next
[13:20:15.665]                           invokeRestart(restart)
[13:20:15.665]                           muffled <- TRUE
[13:20:15.665]                           break
[13:20:15.665]                         }
[13:20:15.665]                       }
[13:20:15.665]                     }
[13:20:15.665]                     invisible(muffled)
[13:20:15.665]                   }
[13:20:15.665]                   muffleCondition(cond)
[13:20:15.665]                 })
[13:20:15.665]             }))
[13:20:15.665]             future::FutureResult(value = ...future.value$value, 
[13:20:15.665]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.665]                   ...future.rng), globalenv = if (FALSE) 
[13:20:15.665]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:15.665]                     ...future.globalenv.names))
[13:20:15.665]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:15.665]         }, condition = base::local({
[13:20:15.665]             c <- base::c
[13:20:15.665]             inherits <- base::inherits
[13:20:15.665]             invokeRestart <- base::invokeRestart
[13:20:15.665]             length <- base::length
[13:20:15.665]             list <- base::list
[13:20:15.665]             seq.int <- base::seq.int
[13:20:15.665]             signalCondition <- base::signalCondition
[13:20:15.665]             sys.calls <- base::sys.calls
[13:20:15.665]             `[[` <- base::`[[`
[13:20:15.665]             `+` <- base::`+`
[13:20:15.665]             `<<-` <- base::`<<-`
[13:20:15.665]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:15.665]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:15.665]                   3L)]
[13:20:15.665]             }
[13:20:15.665]             function(cond) {
[13:20:15.665]                 is_error <- inherits(cond, "error")
[13:20:15.665]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:15.665]                   NULL)
[13:20:15.665]                 if (is_error) {
[13:20:15.665]                   sessionInformation <- function() {
[13:20:15.665]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:15.665]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:15.665]                       search = base::search(), system = base::Sys.info())
[13:20:15.665]                   }
[13:20:15.665]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.665]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:15.665]                     cond$call), session = sessionInformation(), 
[13:20:15.665]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:15.665]                   signalCondition(cond)
[13:20:15.665]                 }
[13:20:15.665]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:15.665]                 "immediateCondition"))) {
[13:20:15.665]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:15.665]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.665]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:15.665]                   if (TRUE && !signal) {
[13:20:15.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.665]                     {
[13:20:15.665]                       inherits <- base::inherits
[13:20:15.665]                       invokeRestart <- base::invokeRestart
[13:20:15.665]                       is.null <- base::is.null
[13:20:15.665]                       muffled <- FALSE
[13:20:15.665]                       if (inherits(cond, "message")) {
[13:20:15.665]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.665]                         if (muffled) 
[13:20:15.665]                           invokeRestart("muffleMessage")
[13:20:15.665]                       }
[13:20:15.665]                       else if (inherits(cond, "warning")) {
[13:20:15.665]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.665]                         if (muffled) 
[13:20:15.665]                           invokeRestart("muffleWarning")
[13:20:15.665]                       }
[13:20:15.665]                       else if (inherits(cond, "condition")) {
[13:20:15.665]                         if (!is.null(pattern)) {
[13:20:15.665]                           computeRestarts <- base::computeRestarts
[13:20:15.665]                           grepl <- base::grepl
[13:20:15.665]                           restarts <- computeRestarts(cond)
[13:20:15.665]                           for (restart in restarts) {
[13:20:15.665]                             name <- restart$name
[13:20:15.665]                             if (is.null(name)) 
[13:20:15.665]                               next
[13:20:15.665]                             if (!grepl(pattern, name)) 
[13:20:15.665]                               next
[13:20:15.665]                             invokeRestart(restart)
[13:20:15.665]                             muffled <- TRUE
[13:20:15.665]                             break
[13:20:15.665]                           }
[13:20:15.665]                         }
[13:20:15.665]                       }
[13:20:15.665]                       invisible(muffled)
[13:20:15.665]                     }
[13:20:15.665]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.665]                   }
[13:20:15.665]                 }
[13:20:15.665]                 else {
[13:20:15.665]                   if (TRUE) {
[13:20:15.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.665]                     {
[13:20:15.665]                       inherits <- base::inherits
[13:20:15.665]                       invokeRestart <- base::invokeRestart
[13:20:15.665]                       is.null <- base::is.null
[13:20:15.665]                       muffled <- FALSE
[13:20:15.665]                       if (inherits(cond, "message")) {
[13:20:15.665]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.665]                         if (muffled) 
[13:20:15.665]                           invokeRestart("muffleMessage")
[13:20:15.665]                       }
[13:20:15.665]                       else if (inherits(cond, "warning")) {
[13:20:15.665]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.665]                         if (muffled) 
[13:20:15.665]                           invokeRestart("muffleWarning")
[13:20:15.665]                       }
[13:20:15.665]                       else if (inherits(cond, "condition")) {
[13:20:15.665]                         if (!is.null(pattern)) {
[13:20:15.665]                           computeRestarts <- base::computeRestarts
[13:20:15.665]                           grepl <- base::grepl
[13:20:15.665]                           restarts <- computeRestarts(cond)
[13:20:15.665]                           for (restart in restarts) {
[13:20:15.665]                             name <- restart$name
[13:20:15.665]                             if (is.null(name)) 
[13:20:15.665]                               next
[13:20:15.665]                             if (!grepl(pattern, name)) 
[13:20:15.665]                               next
[13:20:15.665]                             invokeRestart(restart)
[13:20:15.665]                             muffled <- TRUE
[13:20:15.665]                             break
[13:20:15.665]                           }
[13:20:15.665]                         }
[13:20:15.665]                       }
[13:20:15.665]                       invisible(muffled)
[13:20:15.665]                     }
[13:20:15.665]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.665]                   }
[13:20:15.665]                 }
[13:20:15.665]             }
[13:20:15.665]         }))
[13:20:15.665]     }, error = function(ex) {
[13:20:15.665]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:15.665]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.665]                 ...future.rng), started = ...future.startTime, 
[13:20:15.665]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:15.665]             version = "1.8"), class = "FutureResult")
[13:20:15.665]     }, finally = {
[13:20:15.665]         if (!identical(...future.workdir, getwd())) 
[13:20:15.665]             setwd(...future.workdir)
[13:20:15.665]         {
[13:20:15.665]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:15.665]                 ...future.oldOptions$nwarnings <- NULL
[13:20:15.665]             }
[13:20:15.665]             base::options(...future.oldOptions)
[13:20:15.665]             if (.Platform$OS.type == "windows") {
[13:20:15.665]                 old_names <- names(...future.oldEnvVars)
[13:20:15.665]                 envs <- base::Sys.getenv()
[13:20:15.665]                 names <- names(envs)
[13:20:15.665]                 common <- intersect(names, old_names)
[13:20:15.665]                 added <- setdiff(names, old_names)
[13:20:15.665]                 removed <- setdiff(old_names, names)
[13:20:15.665]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:15.665]                   envs[common]]
[13:20:15.665]                 NAMES <- toupper(changed)
[13:20:15.665]                 args <- list()
[13:20:15.665]                 for (kk in seq_along(NAMES)) {
[13:20:15.665]                   name <- changed[[kk]]
[13:20:15.665]                   NAME <- NAMES[[kk]]
[13:20:15.665]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.665]                     next
[13:20:15.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.665]                 }
[13:20:15.665]                 NAMES <- toupper(added)
[13:20:15.665]                 for (kk in seq_along(NAMES)) {
[13:20:15.665]                   name <- added[[kk]]
[13:20:15.665]                   NAME <- NAMES[[kk]]
[13:20:15.665]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.665]                     next
[13:20:15.665]                   args[[name]] <- ""
[13:20:15.665]                 }
[13:20:15.665]                 NAMES <- toupper(removed)
[13:20:15.665]                 for (kk in seq_along(NAMES)) {
[13:20:15.665]                   name <- removed[[kk]]
[13:20:15.665]                   NAME <- NAMES[[kk]]
[13:20:15.665]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.665]                     next
[13:20:15.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.665]                 }
[13:20:15.665]                 if (length(args) > 0) 
[13:20:15.665]                   base::do.call(base::Sys.setenv, args = args)
[13:20:15.665]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:15.665]             }
[13:20:15.665]             else {
[13:20:15.665]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:15.665]             }
[13:20:15.665]             {
[13:20:15.665]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:15.665]                   0L) {
[13:20:15.665]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:15.665]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:15.665]                   base::options(opts)
[13:20:15.665]                 }
[13:20:15.665]                 {
[13:20:15.665]                   {
[13:20:15.665]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:15.665]                     NULL
[13:20:15.665]                   }
[13:20:15.665]                   options(future.plan = NULL)
[13:20:15.665]                   if (is.na(NA_character_)) 
[13:20:15.665]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.665]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:15.665]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:15.665]                     envir = parent.frame()) 
[13:20:15.665]                   {
[13:20:15.665]                     default_workers <- missing(workers)
[13:20:15.665]                     if (is.function(workers)) 
[13:20:15.665]                       workers <- workers()
[13:20:15.665]                     workers <- structure(as.integer(workers), 
[13:20:15.665]                       class = class(workers))
[13:20:15.665]                     stop_if_not(is.finite(workers), workers >= 
[13:20:15.665]                       1L)
[13:20:15.665]                     if ((workers == 1L && !inherits(workers, 
[13:20:15.665]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:15.665]                       if (default_workers) 
[13:20:15.665]                         supportsMulticore(warn = TRUE)
[13:20:15.665]                       return(sequential(..., envir = envir))
[13:20:15.665]                     }
[13:20:15.665]                     oopts <- options(mc.cores = workers)
[13:20:15.665]                     on.exit(options(oopts))
[13:20:15.665]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:15.665]                       envir = envir)
[13:20:15.665]                     if (!future$lazy) 
[13:20:15.665]                       future <- run(future)
[13:20:15.665]                     invisible(future)
[13:20:15.665]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:15.665]                 }
[13:20:15.665]             }
[13:20:15.665]         }
[13:20:15.665]     })
[13:20:15.665]     if (TRUE) {
[13:20:15.665]         base::sink(type = "output", split = FALSE)
[13:20:15.665]         if (TRUE) {
[13:20:15.665]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:15.665]         }
[13:20:15.665]         else {
[13:20:15.665]             ...future.result["stdout"] <- base::list(NULL)
[13:20:15.665]         }
[13:20:15.665]         base::close(...future.stdout)
[13:20:15.665]         ...future.stdout <- NULL
[13:20:15.665]     }
[13:20:15.665]     ...future.result$conditions <- ...future.conditions
[13:20:15.665]     ...future.result$finished <- base::Sys.time()
[13:20:15.665]     ...future.result
[13:20:15.665] }
[13:20:15.668] requestCore(): workers = 2
[13:20:15.670] MulticoreFuture started
[13:20:15.670] - Launch lazy future ... done
[13:20:15.670] run() for ‘MulticoreFuture’ ... done
[13:20:15.671] plan(): Setting new future strategy stack:
[13:20:15.671] List of future strategies:
[13:20:15.671] 1. sequential:
[13:20:15.671]    - args: function (..., envir = parent.frame())
[13:20:15.671]    - tweaked: FALSE
[13:20:15.671]    - call: NULL
[13:20:15.672] plan(): nbrOfWorkers() = 1
[13:20:15.674] plan(): Setting new future strategy stack:
[13:20:15.674] List of future strategies:
[13:20:15.674] 1. multicore:
[13:20:15.674]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:15.674]    - tweaked: FALSE
[13:20:15.674]    - call: plan(strategy)
[13:20:15.679] plan(): nbrOfWorkers() = 2
d = 1
** Nested future assignments
[13:20:15.680] getGlobalsAndPackages() ...
[13:20:15.681] Searching for globals...
[13:20:15.686] - globals found: [5] ‘{’, ‘<-’, ‘%<-%’, ‘%->%’, ‘+’
[13:20:15.686] Searching for globals ... DONE
[13:20:15.686] Resolving globals: FALSE
[13:20:15.686] 
[13:20:15.687] - packages: [1] ‘future’
[13:20:15.687] getGlobalsAndPackages() ... DONE
[13:20:15.687] run() for ‘Future’ ...
[13:20:15.687] - state: ‘created’
[13:20:15.687] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:15.691] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:15.691] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:15.692]   - Field: ‘label’
[13:20:15.692]   - Field: ‘local’
[13:20:15.692]   - Field: ‘owner’
[13:20:15.692]   - Field: ‘envir’
[13:20:15.692]   - Field: ‘workers’
[13:20:15.692]   - Field: ‘packages’
[13:20:15.692]   - Field: ‘gc’
[13:20:15.692]   - Field: ‘job’
[13:20:15.693]   - Field: ‘conditions’
[13:20:15.693]   - Field: ‘expr’
[13:20:15.693]   - Field: ‘uuid’
[13:20:15.693]   - Field: ‘seed’
[13:20:15.693]   - Field: ‘version’
[13:20:15.693]   - Field: ‘result’
[13:20:15.693]   - Field: ‘asynchronous’
[13:20:15.693]   - Field: ‘calls’
[13:20:15.694]   - Field: ‘globals’
[13:20:15.694]   - Field: ‘stdout’
[13:20:15.694]   - Field: ‘earlySignal’
[13:20:15.694]   - Field: ‘lazy’
[13:20:15.694]   - Field: ‘state’
[13:20:15.694] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:15.694] - Launch lazy future ...
[13:20:15.694] Packages needed by the future expression (n = 1): ‘future’
[13:20:15.695] Packages needed by future strategies (n = 0): <none>
[13:20:15.695] {
[13:20:15.695]     {
[13:20:15.695]         {
[13:20:15.695]             ...future.startTime <- base::Sys.time()
[13:20:15.695]             {
[13:20:15.695]                 {
[13:20:15.695]                   {
[13:20:15.695]                     {
[13:20:15.695]                       {
[13:20:15.695]                         base::local({
[13:20:15.695]                           has_future <- base::requireNamespace("future", 
[13:20:15.695]                             quietly = TRUE)
[13:20:15.695]                           if (has_future) {
[13:20:15.695]                             ns <- base::getNamespace("future")
[13:20:15.695]                             version <- ns[[".package"]][["version"]]
[13:20:15.695]                             if (is.null(version)) 
[13:20:15.695]                               version <- utils::packageVersion("future")
[13:20:15.695]                           }
[13:20:15.695]                           else {
[13:20:15.695]                             version <- NULL
[13:20:15.695]                           }
[13:20:15.695]                           if (!has_future || version < "1.8.0") {
[13:20:15.695]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:15.695]                               "", base::R.version$version.string), 
[13:20:15.695]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:15.695]                                 base::R.version$platform, 8 * 
[13:20:15.695]                                   base::.Machine$sizeof.pointer), 
[13:20:15.695]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:15.695]                                 "release", "version")], collapse = " "), 
[13:20:15.695]                               hostname = base::Sys.info()[["nodename"]])
[13:20:15.695]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:15.695]                               info)
[13:20:15.695]                             info <- base::paste(info, collapse = "; ")
[13:20:15.695]                             if (!has_future) {
[13:20:15.695]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:15.695]                                 info)
[13:20:15.695]                             }
[13:20:15.695]                             else {
[13:20:15.695]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:15.695]                                 info, version)
[13:20:15.695]                             }
[13:20:15.695]                             base::stop(msg)
[13:20:15.695]                           }
[13:20:15.695]                         })
[13:20:15.695]                       }
[13:20:15.695]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:15.695]                       base::options(mc.cores = 1L)
[13:20:15.695]                     }
[13:20:15.695]                     base::local({
[13:20:15.695]                       for (pkg in "future") {
[13:20:15.695]                         base::loadNamespace(pkg)
[13:20:15.695]                         base::library(pkg, character.only = TRUE)
[13:20:15.695]                       }
[13:20:15.695]                     })
[13:20:15.695]                   }
[13:20:15.695]                   options(future.plan = NULL)
[13:20:15.695]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.695]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:15.695]                 }
[13:20:15.695]                 ...future.workdir <- getwd()
[13:20:15.695]             }
[13:20:15.695]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:15.695]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:15.695]         }
[13:20:15.695]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:15.695]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:15.695]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:15.695]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:15.695]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:15.695]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:15.695]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:15.695]             base::names(...future.oldOptions))
[13:20:15.695]     }
[13:20:15.695]     if (FALSE) {
[13:20:15.695]     }
[13:20:15.695]     else {
[13:20:15.695]         if (TRUE) {
[13:20:15.695]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:15.695]                 open = "w")
[13:20:15.695]         }
[13:20:15.695]         else {
[13:20:15.695]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:15.695]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:15.695]         }
[13:20:15.695]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:15.695]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:15.695]             base::sink(type = "output", split = FALSE)
[13:20:15.695]             base::close(...future.stdout)
[13:20:15.695]         }, add = TRUE)
[13:20:15.695]     }
[13:20:15.695]     ...future.frame <- base::sys.nframe()
[13:20:15.695]     ...future.conditions <- base::list()
[13:20:15.695]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:15.695]     if (FALSE) {
[13:20:15.695]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:15.695]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:15.695]     }
[13:20:15.695]     ...future.result <- base::tryCatch({
[13:20:15.695]         base::withCallingHandlers({
[13:20:15.695]             ...future.value <- base::withVisible(base::local({
[13:20:15.695]                 withCallingHandlers({
[13:20:15.695]                   {
[13:20:15.695]                     b <- 1
[13:20:15.695]                     c %<-% 2
[13:20:15.695]                     d <- 3
[13:20:15.695]                     4 %->% e
[13:20:15.695]                     b + c + d + e
[13:20:15.695]                   }
[13:20:15.695]                 }, immediateCondition = function(cond) {
[13:20:15.695]                   save_rds <- function (object, pathname, ...) 
[13:20:15.695]                   {
[13:20:15.695]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:15.695]                     if (file_test("-f", pathname_tmp)) {
[13:20:15.695]                       fi_tmp <- file.info(pathname_tmp)
[13:20:15.695]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:15.695]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:15.695]                         fi_tmp[["mtime"]])
[13:20:15.695]                     }
[13:20:15.695]                     tryCatch({
[13:20:15.695]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:15.695]                     }, error = function(ex) {
[13:20:15.695]                       msg <- conditionMessage(ex)
[13:20:15.695]                       fi_tmp <- file.info(pathname_tmp)
[13:20:15.695]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:15.695]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:15.695]                         fi_tmp[["mtime"]], msg)
[13:20:15.695]                       ex$message <- msg
[13:20:15.695]                       stop(ex)
[13:20:15.695]                     })
[13:20:15.695]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:15.695]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:15.695]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:15.695]                       fi_tmp <- file.info(pathname_tmp)
[13:20:15.695]                       fi <- file.info(pathname)
[13:20:15.695]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:15.695]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:15.695]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:15.695]                         fi[["size"]], fi[["mtime"]])
[13:20:15.695]                       stop(msg)
[13:20:15.695]                     }
[13:20:15.695]                     invisible(pathname)
[13:20:15.695]                   }
[13:20:15.695]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:15.695]                     rootPath = tempdir()) 
[13:20:15.695]                   {
[13:20:15.695]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:15.695]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:15.695]                       tmpdir = path, fileext = ".rds")
[13:20:15.695]                     save_rds(obj, file)
[13:20:15.695]                   }
[13:20:15.695]                   saveImmediateCondition(cond, path = "/tmp/RtmpakA0rS/.future/immediateConditions")
[13:20:15.695]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.695]                   {
[13:20:15.695]                     inherits <- base::inherits
[13:20:15.695]                     invokeRestart <- base::invokeRestart
[13:20:15.695]                     is.null <- base::is.null
[13:20:15.695]                     muffled <- FALSE
[13:20:15.695]                     if (inherits(cond, "message")) {
[13:20:15.695]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:15.695]                       if (muffled) 
[13:20:15.695]                         invokeRestart("muffleMessage")
[13:20:15.695]                     }
[13:20:15.695]                     else if (inherits(cond, "warning")) {
[13:20:15.695]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:15.695]                       if (muffled) 
[13:20:15.695]                         invokeRestart("muffleWarning")
[13:20:15.695]                     }
[13:20:15.695]                     else if (inherits(cond, "condition")) {
[13:20:15.695]                       if (!is.null(pattern)) {
[13:20:15.695]                         computeRestarts <- base::computeRestarts
[13:20:15.695]                         grepl <- base::grepl
[13:20:15.695]                         restarts <- computeRestarts(cond)
[13:20:15.695]                         for (restart in restarts) {
[13:20:15.695]                           name <- restart$name
[13:20:15.695]                           if (is.null(name)) 
[13:20:15.695]                             next
[13:20:15.695]                           if (!grepl(pattern, name)) 
[13:20:15.695]                             next
[13:20:15.695]                           invokeRestart(restart)
[13:20:15.695]                           muffled <- TRUE
[13:20:15.695]                           break
[13:20:15.695]                         }
[13:20:15.695]                       }
[13:20:15.695]                     }
[13:20:15.695]                     invisible(muffled)
[13:20:15.695]                   }
[13:20:15.695]                   muffleCondition(cond)
[13:20:15.695]                 })
[13:20:15.695]             }))
[13:20:15.695]             future::FutureResult(value = ...future.value$value, 
[13:20:15.695]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.695]                   ...future.rng), globalenv = if (FALSE) 
[13:20:15.695]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:15.695]                     ...future.globalenv.names))
[13:20:15.695]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:15.695]         }, condition = base::local({
[13:20:15.695]             c <- base::c
[13:20:15.695]             inherits <- base::inherits
[13:20:15.695]             invokeRestart <- base::invokeRestart
[13:20:15.695]             length <- base::length
[13:20:15.695]             list <- base::list
[13:20:15.695]             seq.int <- base::seq.int
[13:20:15.695]             signalCondition <- base::signalCondition
[13:20:15.695]             sys.calls <- base::sys.calls
[13:20:15.695]             `[[` <- base::`[[`
[13:20:15.695]             `+` <- base::`+`
[13:20:15.695]             `<<-` <- base::`<<-`
[13:20:15.695]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:15.695]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:15.695]                   3L)]
[13:20:15.695]             }
[13:20:15.695]             function(cond) {
[13:20:15.695]                 is_error <- inherits(cond, "error")
[13:20:15.695]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:15.695]                   NULL)
[13:20:15.695]                 if (is_error) {
[13:20:15.695]                   sessionInformation <- function() {
[13:20:15.695]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:15.695]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:15.695]                       search = base::search(), system = base::Sys.info())
[13:20:15.695]                   }
[13:20:15.695]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.695]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:15.695]                     cond$call), session = sessionInformation(), 
[13:20:15.695]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:15.695]                   signalCondition(cond)
[13:20:15.695]                 }
[13:20:15.695]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:15.695]                 "immediateCondition"))) {
[13:20:15.695]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:15.695]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.695]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:15.695]                   if (TRUE && !signal) {
[13:20:15.695]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.695]                     {
[13:20:15.695]                       inherits <- base::inherits
[13:20:15.695]                       invokeRestart <- base::invokeRestart
[13:20:15.695]                       is.null <- base::is.null
[13:20:15.695]                       muffled <- FALSE
[13:20:15.695]                       if (inherits(cond, "message")) {
[13:20:15.695]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.695]                         if (muffled) 
[13:20:15.695]                           invokeRestart("muffleMessage")
[13:20:15.695]                       }
[13:20:15.695]                       else if (inherits(cond, "warning")) {
[13:20:15.695]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.695]                         if (muffled) 
[13:20:15.695]                           invokeRestart("muffleWarning")
[13:20:15.695]                       }
[13:20:15.695]                       else if (inherits(cond, "condition")) {
[13:20:15.695]                         if (!is.null(pattern)) {
[13:20:15.695]                           computeRestarts <- base::computeRestarts
[13:20:15.695]                           grepl <- base::grepl
[13:20:15.695]                           restarts <- computeRestarts(cond)
[13:20:15.695]                           for (restart in restarts) {
[13:20:15.695]                             name <- restart$name
[13:20:15.695]                             if (is.null(name)) 
[13:20:15.695]                               next
[13:20:15.695]                             if (!grepl(pattern, name)) 
[13:20:15.695]                               next
[13:20:15.695]                             invokeRestart(restart)
[13:20:15.695]                             muffled <- TRUE
[13:20:15.695]                             break
[13:20:15.695]                           }
[13:20:15.695]                         }
[13:20:15.695]                       }
[13:20:15.695]                       invisible(muffled)
[13:20:15.695]                     }
[13:20:15.695]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.695]                   }
[13:20:15.695]                 }
[13:20:15.695]                 else {
[13:20:15.695]                   if (TRUE) {
[13:20:15.695]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.695]                     {
[13:20:15.695]                       inherits <- base::inherits
[13:20:15.695]                       invokeRestart <- base::invokeRestart
[13:20:15.695]                       is.null <- base::is.null
[13:20:15.695]                       muffled <- FALSE
[13:20:15.695]                       if (inherits(cond, "message")) {
[13:20:15.695]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.695]                         if (muffled) 
[13:20:15.695]                           invokeRestart("muffleMessage")
[13:20:15.695]                       }
[13:20:15.695]                       else if (inherits(cond, "warning")) {
[13:20:15.695]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.695]                         if (muffled) 
[13:20:15.695]                           invokeRestart("muffleWarning")
[13:20:15.695]                       }
[13:20:15.695]                       else if (inherits(cond, "condition")) {
[13:20:15.695]                         if (!is.null(pattern)) {
[13:20:15.695]                           computeRestarts <- base::computeRestarts
[13:20:15.695]                           grepl <- base::grepl
[13:20:15.695]                           restarts <- computeRestarts(cond)
[13:20:15.695]                           for (restart in restarts) {
[13:20:15.695]                             name <- restart$name
[13:20:15.695]                             if (is.null(name)) 
[13:20:15.695]                               next
[13:20:15.695]                             if (!grepl(pattern, name)) 
[13:20:15.695]                               next
[13:20:15.695]                             invokeRestart(restart)
[13:20:15.695]                             muffled <- TRUE
[13:20:15.695]                             break
[13:20:15.695]                           }
[13:20:15.695]                         }
[13:20:15.695]                       }
[13:20:15.695]                       invisible(muffled)
[13:20:15.695]                     }
[13:20:15.695]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.695]                   }
[13:20:15.695]                 }
[13:20:15.695]             }
[13:20:15.695]         }))
[13:20:15.695]     }, error = function(ex) {
[13:20:15.695]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:15.695]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.695]                 ...future.rng), started = ...future.startTime, 
[13:20:15.695]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:15.695]             version = "1.8"), class = "FutureResult")
[13:20:15.695]     }, finally = {
[13:20:15.695]         if (!identical(...future.workdir, getwd())) 
[13:20:15.695]             setwd(...future.workdir)
[13:20:15.695]         {
[13:20:15.695]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:15.695]                 ...future.oldOptions$nwarnings <- NULL
[13:20:15.695]             }
[13:20:15.695]             base::options(...future.oldOptions)
[13:20:15.695]             if (.Platform$OS.type == "windows") {
[13:20:15.695]                 old_names <- names(...future.oldEnvVars)
[13:20:15.695]                 envs <- base::Sys.getenv()
[13:20:15.695]                 names <- names(envs)
[13:20:15.695]                 common <- intersect(names, old_names)
[13:20:15.695]                 added <- setdiff(names, old_names)
[13:20:15.695]                 removed <- setdiff(old_names, names)
[13:20:15.695]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:15.695]                   envs[common]]
[13:20:15.695]                 NAMES <- toupper(changed)
[13:20:15.695]                 args <- list()
[13:20:15.695]                 for (kk in seq_along(NAMES)) {
[13:20:15.695]                   name <- changed[[kk]]
[13:20:15.695]                   NAME <- NAMES[[kk]]
[13:20:15.695]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.695]                     next
[13:20:15.695]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.695]                 }
[13:20:15.695]                 NAMES <- toupper(added)
[13:20:15.695]                 for (kk in seq_along(NAMES)) {
[13:20:15.695]                   name <- added[[kk]]
[13:20:15.695]                   NAME <- NAMES[[kk]]
[13:20:15.695]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.695]                     next
[13:20:15.695]                   args[[name]] <- ""
[13:20:15.695]                 }
[13:20:15.695]                 NAMES <- toupper(removed)
[13:20:15.695]                 for (kk in seq_along(NAMES)) {
[13:20:15.695]                   name <- removed[[kk]]
[13:20:15.695]                   NAME <- NAMES[[kk]]
[13:20:15.695]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.695]                     next
[13:20:15.695]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.695]                 }
[13:20:15.695]                 if (length(args) > 0) 
[13:20:15.695]                   base::do.call(base::Sys.setenv, args = args)
[13:20:15.695]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:15.695]             }
[13:20:15.695]             else {
[13:20:15.695]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:15.695]             }
[13:20:15.695]             {
[13:20:15.695]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:15.695]                   0L) {
[13:20:15.695]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:15.695]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:15.695]                   base::options(opts)
[13:20:15.695]                 }
[13:20:15.695]                 {
[13:20:15.695]                   {
[13:20:15.695]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:15.695]                     NULL
[13:20:15.695]                   }
[13:20:15.695]                   options(future.plan = NULL)
[13:20:15.695]                   if (is.na(NA_character_)) 
[13:20:15.695]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.695]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:15.695]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:15.695]                     envir = parent.frame()) 
[13:20:15.695]                   {
[13:20:15.695]                     default_workers <- missing(workers)
[13:20:15.695]                     if (is.function(workers)) 
[13:20:15.695]                       workers <- workers()
[13:20:15.695]                     workers <- structure(as.integer(workers), 
[13:20:15.695]                       class = class(workers))
[13:20:15.695]                     stop_if_not(is.finite(workers), workers >= 
[13:20:15.695]                       1L)
[13:20:15.695]                     if ((workers == 1L && !inherits(workers, 
[13:20:15.695]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:15.695]                       if (default_workers) 
[13:20:15.695]                         supportsMulticore(warn = TRUE)
[13:20:15.695]                       return(sequential(..., envir = envir))
[13:20:15.695]                     }
[13:20:15.695]                     oopts <- options(mc.cores = workers)
[13:20:15.695]                     on.exit(options(oopts))
[13:20:15.695]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:15.695]                       envir = envir)
[13:20:15.695]                     if (!future$lazy) 
[13:20:15.695]                       future <- run(future)
[13:20:15.695]                     invisible(future)
[13:20:15.695]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:15.695]                 }
[13:20:15.695]             }
[13:20:15.695]         }
[13:20:15.695]     })
[13:20:15.695]     if (TRUE) {
[13:20:15.695]         base::sink(type = "output", split = FALSE)
[13:20:15.695]         if (TRUE) {
[13:20:15.695]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:15.695]         }
[13:20:15.695]         else {
[13:20:15.695]             ...future.result["stdout"] <- base::list(NULL)
[13:20:15.695]         }
[13:20:15.695]         base::close(...future.stdout)
[13:20:15.695]         ...future.stdout <- NULL
[13:20:15.695]     }
[13:20:15.695]     ...future.result$conditions <- ...future.conditions
[13:20:15.695]     ...future.result$finished <- base::Sys.time()
[13:20:15.695]     ...future.result
[13:20:15.695] }
[13:20:15.698] requestCore(): workers = 2
[13:20:15.700] MulticoreFuture started
[13:20:15.700] - Launch lazy future ... done
[13:20:15.700] run() for ‘MulticoreFuture’ ... done
[13:20:15.701] plan(): Setting new future strategy stack:
[13:20:15.702] List of future strategies:
[13:20:15.702] 1. sequential:
[13:20:15.702]    - args: function (..., envir = parent.frame())
[13:20:15.702]    - tweaked: FALSE
[13:20:15.702]    - call: NULL
[13:20:15.702] plan(): nbrOfWorkers() = 1
[13:20:15.737] plan(): Setting new future strategy stack:
[13:20:15.737] List of future strategies:
[13:20:15.737] 1. multicore:
[13:20:15.737]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:15.737]    - tweaked: FALSE
[13:20:15.737]    - call: plan(strategy)
[13:20:15.741] plan(): nbrOfWorkers() = 2
[13:20:15.743] signalConditions() ...
[13:20:15.743]  - include = ‘immediateCondition’
[13:20:15.743]  - exclude = 
[13:20:15.743]  - resignal = FALSE
[13:20:15.743]  - Number of conditions: 88
[13:20:15.746] signalConditions() ... done
[13:20:15.746] signalConditions() ...
[13:20:15.747]  - include = ‘immediateCondition’
[13:20:15.747]  - exclude = 
[13:20:15.747]  - resignal = FALSE
[13:20:15.747]  - Number of conditions: 88
[13:20:15.747] signalConditions() ... done
[13:20:15.747] Future state: ‘finished’
[13:20:15.748] signalConditions() ...
[13:20:15.748]  - include = ‘condition’
[13:20:15.748]  - exclude = ‘immediateCondition’
[13:20:15.748]  - resignal = TRUE
[13:20:15.748]  - Number of conditions: 88
[13:20:15.748]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.704] getGlobalsAndPackages() ...
[13:20:15.748]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.704] Searching for globals...
[13:20:15.749]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.709] 
[13:20:15.749]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.710] Searching for globals ... DONE
[13:20:15.749]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.710] - globals: [0] <none>
[13:20:15.749]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.710] getGlobalsAndPackages() ... DONE
[13:20:15.749]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.711] run() for ‘Future’ ...
[13:20:15.750]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.711] - state: ‘created’
[13:20:15.750]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.712] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:15.750]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.712] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:15.750]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.713] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:15.750]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.713]   - Field: ‘label’
[13:20:15.751]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.713]   - Field: ‘local’
[13:20:15.751]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.713]   - Field: ‘owner’
[13:20:15.751]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.714]   - Field: ‘envir’
[13:20:15.751]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.714]   - Field: ‘packages’
[13:20:15.751]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.714]   - Field: ‘gc’
[13:20:15.751]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.714]   - Field: ‘conditions’
[13:20:15.752]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.714]   - Field: ‘expr’
[13:20:15.752]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.715]   - Field: ‘uuid’
[13:20:15.752]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.715]   - Field: ‘seed’
[13:20:15.752]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.715]   - Field: ‘version’
[13:20:15.752]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.715]   - Field: ‘result’
[13:20:15.753]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.715]   - Field: ‘asynchronous’
[13:20:15.753]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.716]   - Field: ‘calls’
[13:20:15.753]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.716]   - Field: ‘globals’
[13:20:15.753]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.716]   - Field: ‘stdout’
[13:20:15.753]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.716]   - Field: ‘earlySignal’
[13:20:15.753]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.716]   - Field: ‘lazy’
[13:20:15.754]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.717]   - Field: ‘state’
[13:20:15.754]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.717] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:15.754]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.717] - Launch lazy future ...
[13:20:15.754]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.717] Packages needed by the future expression (n = 0): <none>
[13:20:15.754]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.718] Packages needed by future strategies (n = 0): <none>
[13:20:15.754]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.719] {
[13:20:15.719]     {
[13:20:15.719]         {
[13:20:15.719]             ...future.startTime <- base::Sys.time()
[13:20:15.719]             {
[13:20:15.719]                 {
[13:20:15.719]                   {
[13:20:15.719]                     base::local({
[13:20:15.719]                       has_future <- base::requireNamespace("future", 
[13:20:15.719]                         quietly = TRUE)
[13:20:15.719]                       if (has_future) {
[13:20:15.719]                         ns <- base::getNamespace("future")
[13:20:15.719]                         version <- ns[[".package"]][["version"]]
[13:20:15.719]                         if (is.null(version)) 
[13:20:15.719]                           version <- utils::packageVersion("future")
[13:20:15.719]                       }
[13:20:15.719]                       else {
[13:20:15.719]                         version <- NULL
[13:20:15.719]                       }
[13:20:15.719]                       if (!has_future || version < "1.8.0") {
[13:20:15.719]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:15.719]                           "", base::R.version$version.string), 
[13:20:15.719]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:15.719]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:15.719]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:15.719]                             "release", "version")], collapse = " "), 
[13:20:15.719]                           hostname = base::Sys.info()[["nodename"]])
[13:20:15.719]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:15.719]                           info)
[13:20:15.719]                         info <- base::paste(info, collapse = "; ")
[13:20:15.719]                         if (!has_future) {
[13:20:15.719]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:15.719]                             info)
[13:20:15.719]                         }
[13:20:15.719]                         else {
[13:20:15.719]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:15.719]                             info, version)
[13:20:15.719]                         }
[13:20:15.719]                         base::stop(msg)
[13:20:15.719]                       }
[13:20:15.719]                     })
[13:20:15.719]                   }
[13:20:15.719]                   options(future.plan = NULL)
[13:20:15.719]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.719]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:15.719]                 }
[13:20:15.719]                 ...future.workdir <- getwd()
[13:20:15.719]             }
[13:20:15.719]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:15.719]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:15.719]         }
[13:20:15.719]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:15.719]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:15.719]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:15.719]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:15.719]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:15.719]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:15.719]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:15.719]             base::names(...future.oldOptions))
[13:20:15.719]     }
[13:20:15.719]     if (FALSE) {
[13:20:15.719]     }
[13:20:15.719]     else {
[13:20:15.719]         if (TRUE) {
[13:20:15.719]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:15.719]                 open = "w")
[13:20:15.719]         }
[13:20:15.719]         else {
[13:20:15.719]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:15.719]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:15.719]         }
[13:20:15.719]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:15.719]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:15.719]             base::sink(type = "output", split = FALSE)
[13:20:15.719]             base::close(...future.stdout)
[13:20:15.719]         }, add = TRUE)
[13:20:15.719]     }
[13:20:15.719]     ...future.frame <- base::sys.nframe()
[13:20:15.719]     ...future.conditions <- base::list()
[13:20:15.719]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:15.719]     if (FALSE) {
[13:20:15.719]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:15.719]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:15.719]     }
[13:20:15.719]     ...future.result <- base::tryCatch({
[13:20:15.719]         base::withCallingHandlers({
[13:20:15.719]             ...future.value <- base::withVisible(base::local(2))
[13:20:15.719]             future::FutureResult(value = ...future.value$value, 
[13:20:15.719]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.719]                   ...future.rng), globalenv = if (FALSE) 
[13:20:15.719]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:15.719]                     ...future.globalenv.names))
[13:20:15.719]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:15.719]         }, condition = base::local({
[13:20:15.719]             c <- base::c
[13:20:15.719]             inherits <- base::inherits
[13:20:15.719]             invokeRestart <- base::invokeRestart
[13:20:15.719]             length <- base::length
[13:20:15.719]             list <- base::list
[13:20:15.719]             seq.int <- base::seq.int
[13:20:15.719]             signalCondition <- base::signalCondition
[13:20:15.719]             sys.calls <- base::sys.calls
[13:20:15.719]             `[[` <- base::`[[`
[13:20:15.719]             `+` <- base::`+`
[13:20:15.719]             `<<-` <- base::`<<-`
[13:20:15.719]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:15.719]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:15.719]                   3L)]
[13:20:15.719]             }
[13:20:15.719]             function(cond) {
[13:20:15.719]                 is_error <- inherits(cond, "error")
[13:20:15.719]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:15.719]                   NULL)
[13:20:15.719]                 if (is_error) {
[13:20:15.719]                   sessionInformation <- function() {
[13:20:15.719]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:15.719]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:15.719]                       search = base::search(), system = base::Sys.info())
[13:20:15.719]                   }
[13:20:15.719]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.719]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:15.719]                     cond$call), session = sessionInformation(), 
[13:20:15.719]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:15.719]                   signalCondition(cond)
[13:20:15.719]                 }
[13:20:15.719]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:15.719]                 "immediateCondition"))) {
[13:20:15.719]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:15.719]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.719]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:15.719]                   if (TRUE && !signal) {
[13:20:15.719]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.719]                     {
[13:20:15.719]                       inherits <- base::inherits
[13:20:15.719]                       invokeRestart <- base::invokeRestart
[13:20:15.719]                       is.null <- base::is.null
[13:20:15.719]                       muffled <- FALSE
[13:20:15.719]                       if (inherits(cond, "message")) {
[13:20:15.719]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.719]                         if (muffled) 
[13:20:15.719]                           invokeRestart("muffleMessage")
[13:20:15.719]                       }
[13:20:15.719]                       else if (inherits(cond, "warning")) {
[13:20:15.719]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.719]                         if (muffled) 
[13:20:15.719]                           invokeRestart("muffleWarning")
[13:20:15.719]                       }
[13:20:15.719]                       else if (inherits(cond, "condition")) {
[13:20:15.719]                         if (!is.null(pattern)) {
[13:20:15.719]                           computeRestarts <- base::computeRestarts
[13:20:15.719]                           grepl <- base::grepl
[13:20:15.719]                           restarts <- computeRestarts(cond)
[13:20:15.719]                           for (restart in restarts) {
[13:20:15.719]                             name <- restart$name
[13:20:15.719]                             if (is.null(name)) 
[13:20:15.719]                               next
[13:20:15.719]                             if (!grepl(pattern, name)) 
[13:20:15.719]                               next
[13:20:15.719]                             invokeRestart(restart)
[13:20:15.719]                             muffled <- TRUE
[13:20:15.719]                             break
[13:20:15.719]                           }
[13:20:15.719]                         }
[13:20:15.719]                       }
[13:20:15.719]                       invisible(muffled)
[13:20:15.719]                     }
[13:20:15.719]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.719]                   }
[13:20:15.719]                 }
[13:20:15.719]                 else {
[13:20:15.719]                   if (TRUE) {
[13:20:15.719]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.719]                     {
[13:20:15.719]                       inherits <- base::inherits
[13:20:15.719]                       invokeRestart <- base::invokeRestart
[13:20:15.719]                       is.null <- base::is.null
[13:20:15.719]                       muffled <- FALSE
[13:20:15.719]                       if (inherits(cond, "message")) {
[13:20:15.719]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.719]                         if (muffled) 
[13:20:15.719]                           invokeRestart("muffleMessage")
[13:20:15.719]                       }
[13:20:15.719]                       else if (inherits(cond, "warning")) {
[13:20:15.719]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.719]                         if (muffled) 
[13:20:15.719]                           invokeRestart("muffleWarning")
[13:20:15.719]                       }
[13:20:15.719]                       else if (inherits(cond, "condition")) {
[13:20:15.719]                         if (!is.null(pattern)) {
[13:20:15.719]                           computeRestarts <- base::computeRestarts
[13:20:15.719]                           grepl <- base::grepl
[13:20:15.719]                           restarts <- computeRestarts(cond)
[13:20:15.719]                           for (restart in restarts) {
[13:20:15.719]                             name <- restart$name
[13:20:15.719]                             if (is.null(name)) 
[13:20:15.719]                               next
[13:20:15.719]                             if (!grepl(pattern, name)) 
[13:20:15.719]                               next
[13:20:15.719]                             invokeRestart(restart)
[13:20:15.719]                             muffled <- TRUE
[13:20:15.719]                             break
[13:20:15.719]                           }
[13:20:15.719]                         }
[13:20:15.719]                       }
[13:20:15.719]                       invisible(muffled)
[13:20:15.719]                     }
[13:20:15.719]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.719]                   }
[13:20:15.719]                 }
[13:20:15.719]             }
[13:20:15.719]         }))
[13:20:15.719]     }, error = function(ex) {
[13:20:15.719]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:15.719]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.719]                 ...future.rng), started = ...future.startTime, 
[13:20:15.719]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:15.719]             version = "1.8"), class = "FutureResult")
[13:20:15.719]     }, finally = {
[13:20:15.719]         if (!identical(...future.workdir, getwd())) 
[13:20:15.719]             setwd(...future.workdir)
[13:20:15.719]         {
[13:20:15.719]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:15.719]                 ...future.oldOptions$nwarnings <- NULL
[13:20:15.719]             }
[13:20:15.719]             base::options(...future.oldOptions)
[13:20:15.719]             if (.Platform$OS.type == "windows") {
[13:20:15.719]                 old_names <- names(...future.oldEnvVars)
[13:20:15.719]                 envs <- base::Sys.getenv()
[13:20:15.719]                 names <- names(envs)
[13:20:15.719]                 common <- intersect(names, old_names)
[13:20:15.719]                 added <- setdiff(names, old_names)
[13:20:15.719]                 removed <- setdiff(old_names, names)
[13:20:15.719]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:15.719]                   envs[common]]
[13:20:15.719]                 NAMES <- toupper(changed)
[13:20:15.719]                 args <- list()
[13:20:15.719]                 for (kk in seq_along(NAMES)) {
[13:20:15.719]                   name <- changed[[kk]]
[13:20:15.719]                   NAME <- NAMES[[kk]]
[13:20:15.719]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.719]                     next
[13:20:15.719]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.719]                 }
[13:20:15.719]                 NAMES <- toupper(added)
[13:20:15.719]                 for (kk in seq_along(NAMES)) {
[13:20:15.719]                   name <- added[[kk]]
[13:20:15.719]                   NAME <- NAMES[[kk]]
[13:20:15.719]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.719]                     next
[13:20:15.719]                   args[[name]] <- ""
[13:20:15.719]                 }
[13:20:15.719]                 NAMES <- toupper(removed)
[13:20:15.719]                 for (kk in seq_along(NAMES)) {
[13:20:15.719]                   name <- removed[[kk]]
[13:20:15.719]                   NAME <- NAMES[[kk]]
[13:20:15.719]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.719]                     next
[13:20:15.719]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.719]                 }
[13:20:15.719]                 if (length(args) > 0) 
[13:20:15.719]                   base::do.call(base::Sys.setenv, args = args)
[13:20:15.719]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:15.719]             }
[13:20:15.719]             else {
[13:20:15.719]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:15.719]             }
[13:20:15.719]             {
[13:20:15.719]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:15.719]                   0L) {
[13:20:15.719]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:15.719]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:15.719]                   base::options(opts)
[13:20:15.719]                 }
[13:20:15.719]                 {
[13:20:15.719]                   {
[13:20:15.719]                     NULL
[13:20:15.719]                     RNGkind("Mersenne-Twister")
[13:20:15.719]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:15.719]                       inherits = FALSE)
[13:20:15.719]                   }
[13:20:15.719]                   options(future.plan = NULL)
[13:20:15.719]                   if (is.na(NA_character_)) 
[13:20:15.719]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.719]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:15.719]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:15.719]                   {
[13:20:15.719]                     future <- SequentialFuture(..., envir = envir)
[13:20:15.719]                     if (!future$lazy) 
[13:20:15.719]                       future <- run(future)
[13:20:15.719]                     invisible(future)
[13:20:15.719]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:15.719]                 }
[13:20:15.719]             }
[13:20:15.719]         }
[13:20:15.719]     })
[13:20:15.719]     if (TRUE) {
[13:20:15.719]         base::sink(type = "output", split = FALSE)
[13:20:15.719]         if (TRUE) {
[13:20:15.719]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:15.719]         }
[13:20:15.719]         else {
[13:20:15.719]             ...future.result["stdout"] <- base::list(NULL)
[13:20:15.719]         }
[13:20:15.719]         base::close(...future.stdout)
[13:20:15.719]         ...future.stdout <- NULL
[13:20:15.719]     }
[13:20:15.719]     ...future.result$conditions <- ...future.conditions
[13:20:15.719]     ...future.result$finished <- base::Sys.time()
[13:20:15.719]     ...future.result
[13:20:15.719] }
[13:20:15.754]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.721] plan(): Setting new future strategy stack:
[13:20:15.755]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.721] List of future strategies:
[13:20:15.721] 1. sequential:
[13:20:15.721]    - args: function (..., envir = parent.frame())
[13:20:15.721]    - tweaked: FALSE
[13:20:15.721]    - call: NULL
[13:20:15.755]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.721] plan(): nbrOfWorkers() = 1
[13:20:15.755]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.722] plan(): Setting new future strategy stack:
[13:20:15.755]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.723] List of future strategies:
[13:20:15.723] 1. sequential:
[13:20:15.723]    - args: function (..., envir = parent.frame())
[13:20:15.723]    - tweaked: FALSE
[13:20:15.723]    - call: NULL
[13:20:15.755]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.723] plan(): nbrOfWorkers() = 1
[13:20:15.755]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.723] SequentialFuture started (and completed)
[13:20:15.756]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.724] - Launch lazy future ... done
[13:20:15.756]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.724] run() for ‘SequentialFuture’ ... done
[13:20:15.756]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.724] getGlobalsAndPackages() ...
[13:20:15.756]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.724] Searching for globals...
[13:20:15.756]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.725] 
[13:20:15.756]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.725] Searching for globals ... DONE
[13:20:15.757]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.725] - globals: [0] <none>
[13:20:15.757]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.725] getGlobalsAndPackages() ... DONE
[13:20:15.757]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.726] run() for ‘Future’ ...
[13:20:15.757]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.726] - state: ‘created’
[13:20:15.757]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.726] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:15.758]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.727] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:15.758]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.727] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:15.758]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.727]   - Field: ‘label’
[13:20:15.758]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.727]   - Field: ‘local’
[13:20:15.758]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.727]   - Field: ‘owner’
[13:20:15.758]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.727]   - Field: ‘envir’
[13:20:15.758]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.728]   - Field: ‘packages’
[13:20:15.759]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.728]   - Field: ‘gc’
[13:20:15.759]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.728]   - Field: ‘conditions’
[13:20:15.759]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.728]   - Field: ‘expr’
[13:20:15.759]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.728]   - Field: ‘uuid’
[13:20:15.759]  - Condition #65: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.728]   - Field: ‘seed’
[13:20:15.760]  - Condition #66: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.729]   - Field: ‘version’
[13:20:15.760]  - Condition #67: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.729]   - Field: ‘result’
[13:20:15.760]  - Condition #68: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.729]   - Field: ‘asynchronous’
[13:20:15.760]  - Condition #69: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.729]   - Field: ‘calls’
[13:20:15.760]  - Condition #70: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.729]   - Field: ‘globals’
[13:20:15.760]  - Condition #71: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.729]   - Field: ‘stdout’
[13:20:15.760]  - Condition #72: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.730]   - Field: ‘earlySignal’
[13:20:15.761]  - Condition #73: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.730]   - Field: ‘lazy’
[13:20:15.761]  - Condition #74: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.730]   - Field: ‘state’
[13:20:15.761]  - Condition #75: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.730] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:15.761]  - Condition #76: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.730] - Launch lazy future ...
[13:20:15.761]  - Condition #77: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.730] Packages needed by the future expression (n = 0): <none>
[13:20:15.761]  - Condition #78: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.731] Packages needed by future strategies (n = 0): <none>
[13:20:15.762]  - Condition #79: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.731] {
[13:20:15.731]     {
[13:20:15.731]         {
[13:20:15.731]             ...future.startTime <- base::Sys.time()
[13:20:15.731]             {
[13:20:15.731]                 {
[13:20:15.731]                   {
[13:20:15.731]                     base::local({
[13:20:15.731]                       has_future <- base::requireNamespace("future", 
[13:20:15.731]                         quietly = TRUE)
[13:20:15.731]                       if (has_future) {
[13:20:15.731]                         ns <- base::getNamespace("future")
[13:20:15.731]                         version <- ns[[".package"]][["version"]]
[13:20:15.731]                         if (is.null(version)) 
[13:20:15.731]                           version <- utils::packageVersion("future")
[13:20:15.731]                       }
[13:20:15.731]                       else {
[13:20:15.731]                         version <- NULL
[13:20:15.731]                       }
[13:20:15.731]                       if (!has_future || version < "1.8.0") {
[13:20:15.731]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:15.731]                           "", base::R.version$version.string), 
[13:20:15.731]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:15.731]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:15.731]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:15.731]                             "release", "version")], collapse = " "), 
[13:20:15.731]                           hostname = base::Sys.info()[["nodename"]])
[13:20:15.731]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:15.731]                           info)
[13:20:15.731]                         info <- base::paste(info, collapse = "; ")
[13:20:15.731]                         if (!has_future) {
[13:20:15.731]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:15.731]                             info)
[13:20:15.731]                         }
[13:20:15.731]                         else {
[13:20:15.731]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:15.731]                             info, version)
[13:20:15.731]                         }
[13:20:15.731]                         base::stop(msg)
[13:20:15.731]                       }
[13:20:15.731]                     })
[13:20:15.731]                   }
[13:20:15.731]                   options(future.plan = NULL)
[13:20:15.731]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.731]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:15.731]                 }
[13:20:15.731]                 ...future.workdir <- getwd()
[13:20:15.731]             }
[13:20:15.731]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:15.731]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:15.731]         }
[13:20:15.731]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:15.731]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:15.731]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:15.731]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:15.731]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:15.731]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:15.731]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:15.731]             base::names(...future.oldOptions))
[13:20:15.731]     }
[13:20:15.731]     if (FALSE) {
[13:20:15.731]     }
[13:20:15.731]     else {
[13:20:15.731]         if (TRUE) {
[13:20:15.731]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:15.731]                 open = "w")
[13:20:15.731]         }
[13:20:15.731]         else {
[13:20:15.731]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:15.731]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:15.731]         }
[13:20:15.731]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:15.731]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:15.731]             base::sink(type = "output", split = FALSE)
[13:20:15.731]             base::close(...future.stdout)
[13:20:15.731]         }, add = TRUE)
[13:20:15.731]     }
[13:20:15.731]     ...future.frame <- base::sys.nframe()
[13:20:15.731]     ...future.conditions <- base::list()
[13:20:15.731]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:15.731]     if (FALSE) {
[13:20:15.731]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:15.731]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:15.731]     }
[13:20:15.731]     ...future.result <- base::tryCatch({
[13:20:15.731]         base::withCallingHandlers({
[13:20:15.731]             ...future.value <- base::withVisible(base::local(4))
[13:20:15.731]             future::FutureResult(value = ...future.value$value, 
[13:20:15.731]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.731]                   ...future.rng), globalenv = if (FALSE) 
[13:20:15.731]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:15.731]                     ...future.globalenv.names))
[13:20:15.731]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:15.731]         }, condition = base::local({
[13:20:15.731]             c <- base::c
[13:20:15.731]             inherits <- base::inherits
[13:20:15.731]             invokeRestart <- base::invokeRestart
[13:20:15.731]             length <- base::length
[13:20:15.731]             list <- base::list
[13:20:15.731]             seq.int <- base::seq.int
[13:20:15.731]             signalCondition <- base::signalCondition
[13:20:15.731]             sys.calls <- base::sys.calls
[13:20:15.731]             `[[` <- base::`[[`
[13:20:15.731]             `+` <- base::`+`
[13:20:15.731]             `<<-` <- base::`<<-`
[13:20:15.731]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:15.731]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:15.731]                   3L)]
[13:20:15.731]             }
[13:20:15.731]             function(cond) {
[13:20:15.731]                 is_error <- inherits(cond, "error")
[13:20:15.731]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:15.731]                   NULL)
[13:20:15.731]                 if (is_error) {
[13:20:15.731]                   sessionInformation <- function() {
[13:20:15.731]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:15.731]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:15.731]                       search = base::search(), system = base::Sys.info())
[13:20:15.731]                   }
[13:20:15.731]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.731]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:15.731]                     cond$call), session = sessionInformation(), 
[13:20:15.731]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:15.731]                   signalCondition(cond)
[13:20:15.731]                 }
[13:20:15.731]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:15.731]                 "immediateCondition"))) {
[13:20:15.731]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:15.731]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.731]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:15.731]                   if (TRUE && !signal) {
[13:20:15.731]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.731]                     {
[13:20:15.731]                       inherits <- base::inherits
[13:20:15.731]                       invokeRestart <- base::invokeRestart
[13:20:15.731]                       is.null <- base::is.null
[13:20:15.731]                       muffled <- FALSE
[13:20:15.731]                       if (inherits(cond, "message")) {
[13:20:15.731]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.731]                         if (muffled) 
[13:20:15.731]                           invokeRestart("muffleMessage")
[13:20:15.731]                       }
[13:20:15.731]                       else if (inherits(cond, "warning")) {
[13:20:15.731]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.731]                         if (muffled) 
[13:20:15.731]                           invokeRestart("muffleWarning")
[13:20:15.731]                       }
[13:20:15.731]                       else if (inherits(cond, "condition")) {
[13:20:15.731]                         if (!is.null(pattern)) {
[13:20:15.731]                           computeRestarts <- base::computeRestarts
[13:20:15.731]                           grepl <- base::grepl
[13:20:15.731]                           restarts <- computeRestarts(cond)
[13:20:15.731]                           for (restart in restarts) {
[13:20:15.731]                             name <- restart$name
[13:20:15.731]                             if (is.null(name)) 
[13:20:15.731]                               next
[13:20:15.731]                             if (!grepl(pattern, name)) 
[13:20:15.731]                               next
[13:20:15.731]                             invokeRestart(restart)
[13:20:15.731]                             muffled <- TRUE
[13:20:15.731]                             break
[13:20:15.731]                           }
[13:20:15.731]                         }
[13:20:15.731]                       }
[13:20:15.731]                       invisible(muffled)
[13:20:15.731]                     }
[13:20:15.731]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.731]                   }
[13:20:15.731]                 }
[13:20:15.731]                 else {
[13:20:15.731]                   if (TRUE) {
[13:20:15.731]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.731]                     {
[13:20:15.731]                       inherits <- base::inherits
[13:20:15.731]                       invokeRestart <- base::invokeRestart
[13:20:15.731]                       is.null <- base::is.null
[13:20:15.731]                       muffled <- FALSE
[13:20:15.731]                       if (inherits(cond, "message")) {
[13:20:15.731]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.731]                         if (muffled) 
[13:20:15.731]                           invokeRestart("muffleMessage")
[13:20:15.731]                       }
[13:20:15.731]                       else if (inherits(cond, "warning")) {
[13:20:15.731]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.731]                         if (muffled) 
[13:20:15.731]                           invokeRestart("muffleWarning")
[13:20:15.731]                       }
[13:20:15.731]                       else if (inherits(cond, "condition")) {
[13:20:15.731]                         if (!is.null(pattern)) {
[13:20:15.731]                           computeRestarts <- base::computeRestarts
[13:20:15.731]                           grepl <- base::grepl
[13:20:15.731]                           restarts <- computeRestarts(cond)
[13:20:15.731]                           for (restart in restarts) {
[13:20:15.731]                             name <- restart$name
[13:20:15.731]                             if (is.null(name)) 
[13:20:15.731]                               next
[13:20:15.731]                             if (!grepl(pattern, name)) 
[13:20:15.731]                               next
[13:20:15.731]                             invokeRestart(restart)
[13:20:15.731]                             muffled <- TRUE
[13:20:15.731]                             break
[13:20:15.731]                           }
[13:20:15.731]                         }
[13:20:15.731]                       }
[13:20:15.731]                       invisible(muffled)
[13:20:15.731]                     }
[13:20:15.731]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.731]                   }
[13:20:15.731]                 }
[13:20:15.731]             }
[13:20:15.731]         }))
[13:20:15.731]     }, error = function(ex) {
[13:20:15.731]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:15.731]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.731]                 ...future.rng), started = ...future.startTime, 
[13:20:15.731]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:15.731]             version = "1.8"), class = "FutureResult")
[13:20:15.731]     }, finally = {
[13:20:15.731]         if (!identical(...future.workdir, getwd())) 
[13:20:15.731]             setwd(...future.workdir)
[13:20:15.731]         {
[13:20:15.731]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:15.731]                 ...future.oldOptions$nwarnings <- NULL
[13:20:15.731]             }
[13:20:15.731]             base::options(...future.oldOptions)
[13:20:15.731]             if (.Platform$OS.type == "windows") {
[13:20:15.731]                 old_names <- names(...future.oldEnvVars)
[13:20:15.731]                 envs <- base::Sys.getenv()
[13:20:15.731]                 names <- names(envs)
[13:20:15.731]                 common <- intersect(names, old_names)
[13:20:15.731]                 added <- setdiff(names, old_names)
[13:20:15.731]                 removed <- setdiff(old_names, names)
[13:20:15.731]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:15.731]                   envs[common]]
[13:20:15.731]                 NAMES <- toupper(changed)
[13:20:15.731]                 args <- list()
[13:20:15.731]                 for (kk in seq_along(NAMES)) {
[13:20:15.731]                   name <- changed[[kk]]
[13:20:15.731]                   NAME <- NAMES[[kk]]
[13:20:15.731]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.731]                     next
[13:20:15.731]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.731]                 }
[13:20:15.731]                 NAMES <- toupper(added)
[13:20:15.731]                 for (kk in seq_along(NAMES)) {
[13:20:15.731]                   name <- added[[kk]]
[13:20:15.731]                   NAME <- NAMES[[kk]]
[13:20:15.731]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.731]                     next
[13:20:15.731]                   args[[name]] <- ""
[13:20:15.731]                 }
[13:20:15.731]                 NAMES <- toupper(removed)
[13:20:15.731]                 for (kk in seq_along(NAMES)) {
[13:20:15.731]                   name <- removed[[kk]]
[13:20:15.731]                   NAME <- NAMES[[kk]]
[13:20:15.731]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.731]                     next
[13:20:15.731]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.731]                 }
[13:20:15.731]                 if (length(args) > 0) 
[13:20:15.731]                   base::do.call(base::Sys.setenv, args = args)
[13:20:15.731]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:15.731]             }
[13:20:15.731]             else {
[13:20:15.731]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:15.731]             }
[13:20:15.731]             {
[13:20:15.731]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:15.731]                   0L) {
[13:20:15.731]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:15.731]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:15.731]                   base::options(opts)
[13:20:15.731]                 }
[13:20:15.731]                 {
[13:20:15.731]                   {
[13:20:15.731]                     NULL
[13:20:15.731]                     RNGkind("Mersenne-Twister")
[13:20:15.731]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:15.731]                       inherits = FALSE)
[13:20:15.731]                   }
[13:20:15.731]                   options(future.plan = NULL)
[13:20:15.731]                   if (is.na(NA_character_)) 
[13:20:15.731]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.731]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:15.731]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:15.731]                   {
[13:20:15.731]                     future <- SequentialFuture(..., envir = envir)
[13:20:15.731]                     if (!future$lazy) 
[13:20:15.731]                       future <- run(future)
[13:20:15.731]                     invisible(future)
[13:20:15.731]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:15.731]                 }
[13:20:15.731]             }
[13:20:15.731]         }
[13:20:15.731]     })
[13:20:15.731]     if (TRUE) {
[13:20:15.731]         base::sink(type = "output", split = FALSE)
[13:20:15.731]         if (TRUE) {
[13:20:15.731]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:15.731]         }
[13:20:15.731]         else {
[13:20:15.731]             ...future.result["stdout"] <- base::list(NULL)
[13:20:15.731]         }
[13:20:15.731]         base::close(...future.stdout)
[13:20:15.731]         ...future.stdout <- NULL
[13:20:15.731]     }
[13:20:15.731]     ...future.result$conditions <- ...future.conditions
[13:20:15.731]     ...future.result$finished <- base::Sys.time()
[13:20:15.731]     ...future.result
[13:20:15.731] }
[13:20:15.762]  - Condition #80: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.733] plan(): Setting new future strategy stack:
[13:20:15.762]  - Condition #81: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.733] List of future strategies:
[13:20:15.733] 1. sequential:
[13:20:15.733]    - args: function (..., envir = parent.frame())
[13:20:15.733]    - tweaked: FALSE
[13:20:15.733]    - call: NULL
[13:20:15.762]  - Condition #82: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.734] plan(): nbrOfWorkers() = 1
[13:20:15.762]  - Condition #83: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.735] plan(): Setting new future strategy stack:
[13:20:15.762]  - Condition #84: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.735] List of future strategies:
[13:20:15.735] 1. sequential:
[13:20:15.735]    - args: function (..., envir = parent.frame())
[13:20:15.735]    - tweaked: FALSE
[13:20:15.735]    - call: NULL
[13:20:15.763]  - Condition #85: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.735] plan(): nbrOfWorkers() = 1
[13:20:15.763]  - Condition #86: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.736] SequentialFuture started (and completed)
[13:20:15.763]  - Condition #87: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.736] - Launch lazy future ... done
[13:20:15.763]  - Condition #88: ‘simpleMessage’, ‘message’, ‘condition’
[13:20:15.736] run() for ‘SequentialFuture’ ... done
[13:20:15.763] signalConditions() ... done
a = 10
[13:20:15.764] getGlobalsAndPackages() ...
[13:20:15.764] Searching for globals...
[13:20:15.765] - globals found: [3] ‘{’, ‘+’, ‘a’
[13:20:15.765] Searching for globals ... DONE
[13:20:15.765] Resolving globals: FALSE
[13:20:15.766] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:15.766] The total size of the 1 globals exported for future expression (‘{; a + 1; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:20:15.766] - globals: [1] ‘a’
[13:20:15.766] 
[13:20:15.767] getGlobalsAndPackages() ... DONE
[13:20:15.767] run() for ‘Future’ ...
[13:20:15.767] - state: ‘created’
[13:20:15.767] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:15.773] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:15.773] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:15.773]   - Field: ‘label’
[13:20:15.773]   - Field: ‘local’
[13:20:15.773]   - Field: ‘owner’
[13:20:15.773]   - Field: ‘envir’
[13:20:15.773]   - Field: ‘workers’
[13:20:15.773]   - Field: ‘packages’
[13:20:15.774]   - Field: ‘gc’
[13:20:15.774]   - Field: ‘job’
[13:20:15.774]   - Field: ‘conditions’
[13:20:15.774]   - Field: ‘expr’
[13:20:15.774]   - Field: ‘uuid’
[13:20:15.774]   - Field: ‘seed’
[13:20:15.774]   - Field: ‘version’
[13:20:15.774]   - Field: ‘result’
[13:20:15.774]   - Field: ‘asynchronous’
[13:20:15.774]   - Field: ‘calls’
[13:20:15.775]   - Field: ‘globals’
[13:20:15.775]   - Field: ‘stdout’
[13:20:15.775]   - Field: ‘earlySignal’
[13:20:15.775]   - Field: ‘lazy’
[13:20:15.775]   - Field: ‘state’
[13:20:15.775] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:15.775] - Launch lazy future ...
[13:20:15.775] Packages needed by the future expression (n = 0): <none>
[13:20:15.776] Packages needed by future strategies (n = 0): <none>
[13:20:15.776] {
[13:20:15.776]     {
[13:20:15.776]         {
[13:20:15.776]             ...future.startTime <- base::Sys.time()
[13:20:15.776]             {
[13:20:15.776]                 {
[13:20:15.776]                   {
[13:20:15.776]                     {
[13:20:15.776]                       base::local({
[13:20:15.776]                         has_future <- base::requireNamespace("future", 
[13:20:15.776]                           quietly = TRUE)
[13:20:15.776]                         if (has_future) {
[13:20:15.776]                           ns <- base::getNamespace("future")
[13:20:15.776]                           version <- ns[[".package"]][["version"]]
[13:20:15.776]                           if (is.null(version)) 
[13:20:15.776]                             version <- utils::packageVersion("future")
[13:20:15.776]                         }
[13:20:15.776]                         else {
[13:20:15.776]                           version <- NULL
[13:20:15.776]                         }
[13:20:15.776]                         if (!has_future || version < "1.8.0") {
[13:20:15.776]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:15.776]                             "", base::R.version$version.string), 
[13:20:15.776]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:15.776]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:15.776]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:15.776]                               "release", "version")], collapse = " "), 
[13:20:15.776]                             hostname = base::Sys.info()[["nodename"]])
[13:20:15.776]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:15.776]                             info)
[13:20:15.776]                           info <- base::paste(info, collapse = "; ")
[13:20:15.776]                           if (!has_future) {
[13:20:15.776]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:15.776]                               info)
[13:20:15.776]                           }
[13:20:15.776]                           else {
[13:20:15.776]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:15.776]                               info, version)
[13:20:15.776]                           }
[13:20:15.776]                           base::stop(msg)
[13:20:15.776]                         }
[13:20:15.776]                       })
[13:20:15.776]                     }
[13:20:15.776]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:15.776]                     base::options(mc.cores = 1L)
[13:20:15.776]                   }
[13:20:15.776]                   options(future.plan = NULL)
[13:20:15.776]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.776]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:15.776]                 }
[13:20:15.776]                 ...future.workdir <- getwd()
[13:20:15.776]             }
[13:20:15.776]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:15.776]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:15.776]         }
[13:20:15.776]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:15.776]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:15.776]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:15.776]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:15.776]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:15.776]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:15.776]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:15.776]             base::names(...future.oldOptions))
[13:20:15.776]     }
[13:20:15.776]     if (FALSE) {
[13:20:15.776]     }
[13:20:15.776]     else {
[13:20:15.776]         if (TRUE) {
[13:20:15.776]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:15.776]                 open = "w")
[13:20:15.776]         }
[13:20:15.776]         else {
[13:20:15.776]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:15.776]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:15.776]         }
[13:20:15.776]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:15.776]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:15.776]             base::sink(type = "output", split = FALSE)
[13:20:15.776]             base::close(...future.stdout)
[13:20:15.776]         }, add = TRUE)
[13:20:15.776]     }
[13:20:15.776]     ...future.frame <- base::sys.nframe()
[13:20:15.776]     ...future.conditions <- base::list()
[13:20:15.776]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:15.776]     if (FALSE) {
[13:20:15.776]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:15.776]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:15.776]     }
[13:20:15.776]     ...future.result <- base::tryCatch({
[13:20:15.776]         base::withCallingHandlers({
[13:20:15.776]             ...future.value <- base::withVisible(base::local({
[13:20:15.776]                 withCallingHandlers({
[13:20:15.776]                   {
[13:20:15.776]                     a + 1
[13:20:15.776]                   }
[13:20:15.776]                 }, immediateCondition = function(cond) {
[13:20:15.776]                   save_rds <- function (object, pathname, ...) 
[13:20:15.776]                   {
[13:20:15.776]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:15.776]                     if (file_test("-f", pathname_tmp)) {
[13:20:15.776]                       fi_tmp <- file.info(pathname_tmp)
[13:20:15.776]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:15.776]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:15.776]                         fi_tmp[["mtime"]])
[13:20:15.776]                     }
[13:20:15.776]                     tryCatch({
[13:20:15.776]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:15.776]                     }, error = function(ex) {
[13:20:15.776]                       msg <- conditionMessage(ex)
[13:20:15.776]                       fi_tmp <- file.info(pathname_tmp)
[13:20:15.776]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:15.776]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:15.776]                         fi_tmp[["mtime"]], msg)
[13:20:15.776]                       ex$message <- msg
[13:20:15.776]                       stop(ex)
[13:20:15.776]                     })
[13:20:15.776]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:15.776]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:15.776]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:15.776]                       fi_tmp <- file.info(pathname_tmp)
[13:20:15.776]                       fi <- file.info(pathname)
[13:20:15.776]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:15.776]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:15.776]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:15.776]                         fi[["size"]], fi[["mtime"]])
[13:20:15.776]                       stop(msg)
[13:20:15.776]                     }
[13:20:15.776]                     invisible(pathname)
[13:20:15.776]                   }
[13:20:15.776]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:15.776]                     rootPath = tempdir()) 
[13:20:15.776]                   {
[13:20:15.776]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:15.776]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:15.776]                       tmpdir = path, fileext = ".rds")
[13:20:15.776]                     save_rds(obj, file)
[13:20:15.776]                   }
[13:20:15.776]                   saveImmediateCondition(cond, path = "/tmp/RtmpakA0rS/.future/immediateConditions")
[13:20:15.776]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.776]                   {
[13:20:15.776]                     inherits <- base::inherits
[13:20:15.776]                     invokeRestart <- base::invokeRestart
[13:20:15.776]                     is.null <- base::is.null
[13:20:15.776]                     muffled <- FALSE
[13:20:15.776]                     if (inherits(cond, "message")) {
[13:20:15.776]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:15.776]                       if (muffled) 
[13:20:15.776]                         invokeRestart("muffleMessage")
[13:20:15.776]                     }
[13:20:15.776]                     else if (inherits(cond, "warning")) {
[13:20:15.776]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:15.776]                       if (muffled) 
[13:20:15.776]                         invokeRestart("muffleWarning")
[13:20:15.776]                     }
[13:20:15.776]                     else if (inherits(cond, "condition")) {
[13:20:15.776]                       if (!is.null(pattern)) {
[13:20:15.776]                         computeRestarts <- base::computeRestarts
[13:20:15.776]                         grepl <- base::grepl
[13:20:15.776]                         restarts <- computeRestarts(cond)
[13:20:15.776]                         for (restart in restarts) {
[13:20:15.776]                           name <- restart$name
[13:20:15.776]                           if (is.null(name)) 
[13:20:15.776]                             next
[13:20:15.776]                           if (!grepl(pattern, name)) 
[13:20:15.776]                             next
[13:20:15.776]                           invokeRestart(restart)
[13:20:15.776]                           muffled <- TRUE
[13:20:15.776]                           break
[13:20:15.776]                         }
[13:20:15.776]                       }
[13:20:15.776]                     }
[13:20:15.776]                     invisible(muffled)
[13:20:15.776]                   }
[13:20:15.776]                   muffleCondition(cond)
[13:20:15.776]                 })
[13:20:15.776]             }))
[13:20:15.776]             future::FutureResult(value = ...future.value$value, 
[13:20:15.776]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.776]                   ...future.rng), globalenv = if (FALSE) 
[13:20:15.776]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:15.776]                     ...future.globalenv.names))
[13:20:15.776]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:15.776]         }, condition = base::local({
[13:20:15.776]             c <- base::c
[13:20:15.776]             inherits <- base::inherits
[13:20:15.776]             invokeRestart <- base::invokeRestart
[13:20:15.776]             length <- base::length
[13:20:15.776]             list <- base::list
[13:20:15.776]             seq.int <- base::seq.int
[13:20:15.776]             signalCondition <- base::signalCondition
[13:20:15.776]             sys.calls <- base::sys.calls
[13:20:15.776]             `[[` <- base::`[[`
[13:20:15.776]             `+` <- base::`+`
[13:20:15.776]             `<<-` <- base::`<<-`
[13:20:15.776]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:15.776]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:15.776]                   3L)]
[13:20:15.776]             }
[13:20:15.776]             function(cond) {
[13:20:15.776]                 is_error <- inherits(cond, "error")
[13:20:15.776]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:15.776]                   NULL)
[13:20:15.776]                 if (is_error) {
[13:20:15.776]                   sessionInformation <- function() {
[13:20:15.776]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:15.776]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:15.776]                       search = base::search(), system = base::Sys.info())
[13:20:15.776]                   }
[13:20:15.776]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.776]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:15.776]                     cond$call), session = sessionInformation(), 
[13:20:15.776]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:15.776]                   signalCondition(cond)
[13:20:15.776]                 }
[13:20:15.776]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:15.776]                 "immediateCondition"))) {
[13:20:15.776]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:15.776]                   ...future.conditions[[length(...future.conditions) + 
[13:20:15.776]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:15.776]                   if (TRUE && !signal) {
[13:20:15.776]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.776]                     {
[13:20:15.776]                       inherits <- base::inherits
[13:20:15.776]                       invokeRestart <- base::invokeRestart
[13:20:15.776]                       is.null <- base::is.null
[13:20:15.776]                       muffled <- FALSE
[13:20:15.776]                       if (inherits(cond, "message")) {
[13:20:15.776]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.776]                         if (muffled) 
[13:20:15.776]                           invokeRestart("muffleMessage")
[13:20:15.776]                       }
[13:20:15.776]                       else if (inherits(cond, "warning")) {
[13:20:15.776]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.776]                         if (muffled) 
[13:20:15.776]                           invokeRestart("muffleWarning")
[13:20:15.776]                       }
[13:20:15.776]                       else if (inherits(cond, "condition")) {
[13:20:15.776]                         if (!is.null(pattern)) {
[13:20:15.776]                           computeRestarts <- base::computeRestarts
[13:20:15.776]                           grepl <- base::grepl
[13:20:15.776]                           restarts <- computeRestarts(cond)
[13:20:15.776]                           for (restart in restarts) {
[13:20:15.776]                             name <- restart$name
[13:20:15.776]                             if (is.null(name)) 
[13:20:15.776]                               next
[13:20:15.776]                             if (!grepl(pattern, name)) 
[13:20:15.776]                               next
[13:20:15.776]                             invokeRestart(restart)
[13:20:15.776]                             muffled <- TRUE
[13:20:15.776]                             break
[13:20:15.776]                           }
[13:20:15.776]                         }
[13:20:15.776]                       }
[13:20:15.776]                       invisible(muffled)
[13:20:15.776]                     }
[13:20:15.776]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.776]                   }
[13:20:15.776]                 }
[13:20:15.776]                 else {
[13:20:15.776]                   if (TRUE) {
[13:20:15.776]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:15.776]                     {
[13:20:15.776]                       inherits <- base::inherits
[13:20:15.776]                       invokeRestart <- base::invokeRestart
[13:20:15.776]                       is.null <- base::is.null
[13:20:15.776]                       muffled <- FALSE
[13:20:15.776]                       if (inherits(cond, "message")) {
[13:20:15.776]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:15.776]                         if (muffled) 
[13:20:15.776]                           invokeRestart("muffleMessage")
[13:20:15.776]                       }
[13:20:15.776]                       else if (inherits(cond, "warning")) {
[13:20:15.776]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:15.776]                         if (muffled) 
[13:20:15.776]                           invokeRestart("muffleWarning")
[13:20:15.776]                       }
[13:20:15.776]                       else if (inherits(cond, "condition")) {
[13:20:15.776]                         if (!is.null(pattern)) {
[13:20:15.776]                           computeRestarts <- base::computeRestarts
[13:20:15.776]                           grepl <- base::grepl
[13:20:15.776]                           restarts <- computeRestarts(cond)
[13:20:15.776]                           for (restart in restarts) {
[13:20:15.776]                             name <- restart$name
[13:20:15.776]                             if (is.null(name)) 
[13:20:15.776]                               next
[13:20:15.776]                             if (!grepl(pattern, name)) 
[13:20:15.776]                               next
[13:20:15.776]                             invokeRestart(restart)
[13:20:15.776]                             muffled <- TRUE
[13:20:15.776]                             break
[13:20:15.776]                           }
[13:20:15.776]                         }
[13:20:15.776]                       }
[13:20:15.776]                       invisible(muffled)
[13:20:15.776]                     }
[13:20:15.776]                     muffleCondition(cond, pattern = "^muffle")
[13:20:15.776]                   }
[13:20:15.776]                 }
[13:20:15.776]             }
[13:20:15.776]         }))
[13:20:15.776]     }, error = function(ex) {
[13:20:15.776]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:15.776]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:15.776]                 ...future.rng), started = ...future.startTime, 
[13:20:15.776]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:15.776]             version = "1.8"), class = "FutureResult")
[13:20:15.776]     }, finally = {
[13:20:15.776]         if (!identical(...future.workdir, getwd())) 
[13:20:15.776]             setwd(...future.workdir)
[13:20:15.776]         {
[13:20:15.776]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:15.776]                 ...future.oldOptions$nwarnings <- NULL
[13:20:15.776]             }
[13:20:15.776]             base::options(...future.oldOptions)
[13:20:15.776]             if (.Platform$OS.type == "windows") {
[13:20:15.776]                 old_names <- names(...future.oldEnvVars)
[13:20:15.776]                 envs <- base::Sys.getenv()
[13:20:15.776]                 names <- names(envs)
[13:20:15.776]                 common <- intersect(names, old_names)
[13:20:15.776]                 added <- setdiff(names, old_names)
[13:20:15.776]                 removed <- setdiff(old_names, names)
[13:20:15.776]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:15.776]                   envs[common]]
[13:20:15.776]                 NAMES <- toupper(changed)
[13:20:15.776]                 args <- list()
[13:20:15.776]                 for (kk in seq_along(NAMES)) {
[13:20:15.776]                   name <- changed[[kk]]
[13:20:15.776]                   NAME <- NAMES[[kk]]
[13:20:15.776]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.776]                     next
[13:20:15.776]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.776]                 }
[13:20:15.776]                 NAMES <- toupper(added)
[13:20:15.776]                 for (kk in seq_along(NAMES)) {
[13:20:15.776]                   name <- added[[kk]]
[13:20:15.776]                   NAME <- NAMES[[kk]]
[13:20:15.776]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.776]                     next
[13:20:15.776]                   args[[name]] <- ""
[13:20:15.776]                 }
[13:20:15.776]                 NAMES <- toupper(removed)
[13:20:15.776]                 for (kk in seq_along(NAMES)) {
[13:20:15.776]                   name <- removed[[kk]]
[13:20:15.776]                   NAME <- NAMES[[kk]]
[13:20:15.776]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:15.776]                     next
[13:20:15.776]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:15.776]                 }
[13:20:15.776]                 if (length(args) > 0) 
[13:20:15.776]                   base::do.call(base::Sys.setenv, args = args)
[13:20:15.776]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:15.776]             }
[13:20:15.776]             else {
[13:20:15.776]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:15.776]             }
[13:20:15.776]             {
[13:20:15.776]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:15.776]                   0L) {
[13:20:15.776]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:15.776]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:15.776]                   base::options(opts)
[13:20:15.776]                 }
[13:20:15.776]                 {
[13:20:15.776]                   {
[13:20:15.776]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:15.776]                     NULL
[13:20:15.776]                   }
[13:20:15.776]                   options(future.plan = NULL)
[13:20:15.776]                   if (is.na(NA_character_)) 
[13:20:15.776]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:15.776]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:15.776]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:15.776]                     envir = parent.frame()) 
[13:20:15.776]                   {
[13:20:15.776]                     default_workers <- missing(workers)
[13:20:15.776]                     if (is.function(workers)) 
[13:20:15.776]                       workers <- workers()
[13:20:15.776]                     workers <- structure(as.integer(workers), 
[13:20:15.776]                       class = class(workers))
[13:20:15.776]                     stop_if_not(is.finite(workers), workers >= 
[13:20:15.776]                       1L)
[13:20:15.776]                     if ((workers == 1L && !inherits(workers, 
[13:20:15.776]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:15.776]                       if (default_workers) 
[13:20:15.776]                         supportsMulticore(warn = TRUE)
[13:20:15.776]                       return(sequential(..., envir = envir))
[13:20:15.776]                     }
[13:20:15.776]                     oopts <- options(mc.cores = workers)
[13:20:15.776]                     on.exit(options(oopts))
[13:20:15.776]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:15.776]                       envir = envir)
[13:20:15.776]                     if (!future$lazy) 
[13:20:15.776]                       future <- run(future)
[13:20:15.776]                     invisible(future)
[13:20:15.776]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:15.776]                 }
[13:20:15.776]             }
[13:20:15.776]         }
[13:20:15.776]     })
[13:20:15.776]     if (TRUE) {
[13:20:15.776]         base::sink(type = "output", split = FALSE)
[13:20:15.776]         if (TRUE) {
[13:20:15.776]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:15.776]         }
[13:20:15.776]         else {
[13:20:15.776]             ...future.result["stdout"] <- base::list(NULL)
[13:20:15.776]         }
[13:20:15.776]         base::close(...future.stdout)
[13:20:15.776]         ...future.stdout <- NULL
[13:20:15.776]     }
[13:20:15.776]     ...future.result$conditions <- ...future.conditions
[13:20:15.776]     ...future.result$finished <- base::Sys.time()
[13:20:15.776]     ...future.result
[13:20:15.776] }
[13:20:15.778] assign_globals() ...
[13:20:15.778] List of 1
[13:20:15.778]  $ a: num 10
[13:20:15.778]  - attr(*, "where")=List of 1
[13:20:15.778]   ..$ a:<environment: R_EmptyEnv> 
[13:20:15.778]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:15.778]  - attr(*, "resolved")= logi FALSE
[13:20:15.778]  - attr(*, "total_size")= num 56
[13:20:15.778]  - attr(*, "already-done")= logi TRUE
[13:20:15.781] - copied ‘a’ to environment
[13:20:15.781] assign_globals() ... done
[13:20:15.781] requestCore(): workers = 2
[13:20:15.783] MulticoreFuture started
[13:20:15.784] - Launch lazy future ... done
[13:20:15.784] run() for ‘MulticoreFuture’ ... done
[13:20:15.785] plan(): Setting new future strategy stack:
[13:20:15.785] List of future strategies:
[13:20:15.785] 1. sequential:
[13:20:15.785]    - args: function (..., envir = parent.frame())
[13:20:15.785]    - tweaked: FALSE
[13:20:15.785]    - call: NULL
[13:20:15.786] plan(): nbrOfWorkers() = 1
[13:20:15.788] plan(): Setting new future strategy stack:
[13:20:15.788] List of future strategies:
[13:20:15.788] 1. multicore:
[13:20:15.788]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:15.788]    - tweaked: FALSE
[13:20:15.788]    - call: plan(strategy)
[13:20:15.793] plan(): nbrOfWorkers() = 2
b = 11
*** %<-% with ‘multicore’ futures ... DONE
*** %<-% with ‘multisession’ futures ...
[13:20:15.795] plan(): Setting new future strategy stack:
[13:20:15.795] List of future strategies:
[13:20:15.795] 1. multisession:
[13:20:15.795]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:20:15.795]    - tweaked: FALSE
[13:20:15.795]    - call: plan(strategy)
[13:20:15.796] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:20:15.796] multisession:
[13:20:15.796] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:20:15.796] - tweaked: FALSE
[13:20:15.796] - call: plan(strategy)
[13:20:15.803] getGlobalsAndPackages() ...
[13:20:15.803] Not searching for globals
[13:20:15.803] - globals: [0] <none>
[13:20:15.803] getGlobalsAndPackages() ... DONE
[13:20:15.804] [local output] makeClusterPSOCK() ...
[13:20:15.851] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:20:15.857] [local output] Base port: 11518
[13:20:15.857] [local output] Getting setup options for 2 cluster nodes ...
[13:20:15.857] [local output]  - Node 1 of 2 ...
[13:20:15.858] [local output] localMachine=TRUE => revtunnel=FALSE

[13:20:15.858] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpakA0rS/worker.rank=1.parallelly.parent=83417.145d95ab5e818.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpakA0rS/worker.rank=1.parallelly.parent=83417.145d95ab5e818.pid")'’
[13:20:16.051] - Possible to infer worker's PID: TRUE
[13:20:16.052] [local output] Rscript port: 11518

[13:20:16.052] [local output]  - Node 2 of 2 ...
[13:20:16.052] [local output] localMachine=TRUE => revtunnel=FALSE

[13:20:16.053] [local output] Rscript port: 11518

[13:20:16.053] [local output] Getting setup options for 2 cluster nodes ... done
[13:20:16.053] [local output]  - Parallel setup requested for some PSOCK nodes
[13:20:16.054] [local output] Setting up PSOCK nodes in parallel
[13:20:16.054] List of 36
[13:20:16.054]  $ worker          : chr "localhost"
[13:20:16.054]   ..- attr(*, "localhost")= logi TRUE
[13:20:16.054]  $ master          : chr "localhost"
[13:20:16.054]  $ port            : int 11518
[13:20:16.054]  $ connectTimeout  : num 120
[13:20:16.054]  $ timeout         : num 2592000
[13:20:16.054]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:20:16.054]  $ homogeneous     : logi TRUE
[13:20:16.054]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:20:16.054]  $ rscript_envs    : NULL
[13:20:16.054]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:20:16.054]  $ rscript_startup : NULL
[13:20:16.054]  $ rscript_sh      : chr "sh"
[13:20:16.054]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:20:16.054]  $ methods         : logi TRUE
[13:20:16.054]  $ socketOptions   : chr "no-delay"
[13:20:16.054]  $ useXDR          : logi FALSE
[13:20:16.054]  $ outfile         : chr "/dev/null"
[13:20:16.054]  $ renice          : int NA
[13:20:16.054]  $ rshcmd          : NULL
[13:20:16.054]  $ user            : chr(0) 
[13:20:16.054]  $ revtunnel       : logi FALSE
[13:20:16.054]  $ rshlogfile      : NULL
[13:20:16.054]  $ rshopts         : chr(0) 
[13:20:16.054]  $ rank            : int 1
[13:20:16.054]  $ manual          : logi FALSE
[13:20:16.054]  $ dryrun          : logi FALSE
[13:20:16.054]  $ quiet           : logi FALSE
[13:20:16.054]  $ setup_strategy  : chr "parallel"
[13:20:16.054]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:20:16.054]  $ pidfile         : chr "/tmp/RtmpakA0rS/worker.rank=1.parallelly.parent=83417.145d95ab5e818.pid"
[13:20:16.054]  $ rshcmd_label    : NULL
[13:20:16.054]  $ rsh_call        : NULL
[13:20:16.054]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:20:16.054]  $ localMachine    : logi TRUE
[13:20:16.054]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:20:16.054]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:20:16.054]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:20:16.054]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:20:16.054]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:20:16.054]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:20:16.054]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:20:16.054]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:20:16.054]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:20:16.054]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:20:16.054]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:20:16.054]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:20:16.054]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:20:16.054]  $ arguments       :List of 28
[13:20:16.054]   ..$ worker          : chr "localhost"
[13:20:16.054]   ..$ master          : NULL
[13:20:16.054]   ..$ port            : int 11518
[13:20:16.054]   ..$ connectTimeout  : num 120
[13:20:16.054]   ..$ timeout         : num 2592000
[13:20:16.054]   ..$ rscript         : NULL
[13:20:16.054]   ..$ homogeneous     : NULL
[13:20:16.054]   ..$ rscript_args    : NULL
[13:20:16.054]   ..$ rscript_envs    : NULL
[13:20:16.054]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:20:16.054]   ..$ rscript_startup : NULL
[13:20:16.054]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:20:16.054]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:20:16.054]   ..$ methods         : logi TRUE
[13:20:16.054]   ..$ socketOptions   : chr "no-delay"
[13:20:16.054]   ..$ useXDR          : logi FALSE
[13:20:16.054]   ..$ outfile         : chr "/dev/null"
[13:20:16.054]   ..$ renice          : int NA
[13:20:16.054]   ..$ rshcmd          : NULL
[13:20:16.054]   ..$ user            : NULL
[13:20:16.054]   ..$ revtunnel       : logi NA
[13:20:16.054]   ..$ rshlogfile      : NULL
[13:20:16.054]   ..$ rshopts         : NULL
[13:20:16.054]   ..$ rank            : int 1
[13:20:16.054]   ..$ manual          : logi FALSE
[13:20:16.054]   ..$ dryrun          : logi FALSE
[13:20:16.054]   ..$ quiet           : logi FALSE
[13:20:16.054]   ..$ setup_strategy  : chr "parallel"
[13:20:16.054]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:20:16.071] [local output] System call to launch all workers:
[13:20:16.071] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpakA0rS/worker.rank=1.parallelly.parent=83417.145d95ab5e818.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11518 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:20:16.071] [local output] Starting PSOCK main server
[13:20:16.073] [local output] Workers launched
[13:20:16.073] [local output] Waiting for workers to connect back
[13:20:16.073]  - [local output] 0 workers out of 2 ready
[13:20:16.343]  - [local output] 0 workers out of 2 ready
[13:20:16.343]  - [local output] 1 workers out of 2 ready
[13:20:16.348]  - [local output] 1 workers out of 2 ready
[13:20:16.348]  - [local output] 2 workers out of 2 ready
[13:20:16.348] [local output] Launching of workers completed
[13:20:16.348] [local output] Collecting session information from workers
[13:20:16.349] [local output]  - Worker #1 of 2
[13:20:16.350] [local output]  - Worker #2 of 2
[13:20:16.350] [local output] makeClusterPSOCK() ... done
[13:20:16.362] Packages needed by the future expression (n = 0): <none>
[13:20:16.362] Packages needed by future strategies (n = 0): <none>
[13:20:16.362] {
[13:20:16.362]     {
[13:20:16.362]         {
[13:20:16.362]             ...future.startTime <- base::Sys.time()
[13:20:16.362]             {
[13:20:16.362]                 {
[13:20:16.362]                   {
[13:20:16.362]                     {
[13:20:16.362]                       base::local({
[13:20:16.362]                         has_future <- base::requireNamespace("future", 
[13:20:16.362]                           quietly = TRUE)
[13:20:16.362]                         if (has_future) {
[13:20:16.362]                           ns <- base::getNamespace("future")
[13:20:16.362]                           version <- ns[[".package"]][["version"]]
[13:20:16.362]                           if (is.null(version)) 
[13:20:16.362]                             version <- utils::packageVersion("future")
[13:20:16.362]                         }
[13:20:16.362]                         else {
[13:20:16.362]                           version <- NULL
[13:20:16.362]                         }
[13:20:16.362]                         if (!has_future || version < "1.8.0") {
[13:20:16.362]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:16.362]                             "", base::R.version$version.string), 
[13:20:16.362]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:16.362]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:16.362]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:16.362]                               "release", "version")], collapse = " "), 
[13:20:16.362]                             hostname = base::Sys.info()[["nodename"]])
[13:20:16.362]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:16.362]                             info)
[13:20:16.362]                           info <- base::paste(info, collapse = "; ")
[13:20:16.362]                           if (!has_future) {
[13:20:16.362]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:16.362]                               info)
[13:20:16.362]                           }
[13:20:16.362]                           else {
[13:20:16.362]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:16.362]                               info, version)
[13:20:16.362]                           }
[13:20:16.362]                           base::stop(msg)
[13:20:16.362]                         }
[13:20:16.362]                       })
[13:20:16.362]                     }
[13:20:16.362]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:16.362]                     base::options(mc.cores = 1L)
[13:20:16.362]                   }
[13:20:16.362]                   options(future.plan = NULL)
[13:20:16.362]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:16.362]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:16.362]                 }
[13:20:16.362]                 ...future.workdir <- getwd()
[13:20:16.362]             }
[13:20:16.362]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:16.362]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:16.362]         }
[13:20:16.362]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:16.362]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:16.362]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:16.362]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:16.362]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:16.362]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:16.362]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:16.362]             base::names(...future.oldOptions))
[13:20:16.362]     }
[13:20:16.362]     if (FALSE) {
[13:20:16.362]     }
[13:20:16.362]     else {
[13:20:16.362]         if (TRUE) {
[13:20:16.362]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:16.362]                 open = "w")
[13:20:16.362]         }
[13:20:16.362]         else {
[13:20:16.362]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:16.362]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:16.362]         }
[13:20:16.362]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:16.362]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:16.362]             base::sink(type = "output", split = FALSE)
[13:20:16.362]             base::close(...future.stdout)
[13:20:16.362]         }, add = TRUE)
[13:20:16.362]     }
[13:20:16.362]     ...future.frame <- base::sys.nframe()
[13:20:16.362]     ...future.conditions <- base::list()
[13:20:16.362]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:16.362]     if (FALSE) {
[13:20:16.362]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:16.362]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:16.362]     }
[13:20:16.362]     ...future.result <- base::tryCatch({
[13:20:16.362]         base::withCallingHandlers({
[13:20:16.362]             ...future.value <- base::withVisible(base::local({
[13:20:16.362]                 ...future.makeSendCondition <- local({
[13:20:16.362]                   sendCondition <- NULL
[13:20:16.362]                   function(frame = 1L) {
[13:20:16.362]                     if (is.function(sendCondition)) 
[13:20:16.362]                       return(sendCondition)
[13:20:16.362]                     ns <- getNamespace("parallel")
[13:20:16.362]                     if (exists("sendData", mode = "function", 
[13:20:16.362]                       envir = ns)) {
[13:20:16.362]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:16.362]                         envir = ns)
[13:20:16.362]                       envir <- sys.frame(frame)
[13:20:16.362]                       master <- NULL
[13:20:16.362]                       while (!identical(envir, .GlobalEnv) && 
[13:20:16.362]                         !identical(envir, emptyenv())) {
[13:20:16.362]                         if (exists("master", mode = "list", envir = envir, 
[13:20:16.362]                           inherits = FALSE)) {
[13:20:16.362]                           master <- get("master", mode = "list", 
[13:20:16.362]                             envir = envir, inherits = FALSE)
[13:20:16.362]                           if (inherits(master, c("SOCKnode", 
[13:20:16.362]                             "SOCK0node"))) {
[13:20:16.362]                             sendCondition <<- function(cond) {
[13:20:16.362]                               data <- list(type = "VALUE", value = cond, 
[13:20:16.362]                                 success = TRUE)
[13:20:16.362]                               parallel_sendData(master, data)
[13:20:16.362]                             }
[13:20:16.362]                             return(sendCondition)
[13:20:16.362]                           }
[13:20:16.362]                         }
[13:20:16.362]                         frame <- frame + 1L
[13:20:16.362]                         envir <- sys.frame(frame)
[13:20:16.362]                       }
[13:20:16.362]                     }
[13:20:16.362]                     sendCondition <<- function(cond) NULL
[13:20:16.362]                   }
[13:20:16.362]                 })
[13:20:16.362]                 withCallingHandlers({
[13:20:16.362]                   NA
[13:20:16.362]                 }, immediateCondition = function(cond) {
[13:20:16.362]                   sendCondition <- ...future.makeSendCondition()
[13:20:16.362]                   sendCondition(cond)
[13:20:16.362]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:16.362]                   {
[13:20:16.362]                     inherits <- base::inherits
[13:20:16.362]                     invokeRestart <- base::invokeRestart
[13:20:16.362]                     is.null <- base::is.null
[13:20:16.362]                     muffled <- FALSE
[13:20:16.362]                     if (inherits(cond, "message")) {
[13:20:16.362]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:16.362]                       if (muffled) 
[13:20:16.362]                         invokeRestart("muffleMessage")
[13:20:16.362]                     }
[13:20:16.362]                     else if (inherits(cond, "warning")) {
[13:20:16.362]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:16.362]                       if (muffled) 
[13:20:16.362]                         invokeRestart("muffleWarning")
[13:20:16.362]                     }
[13:20:16.362]                     else if (inherits(cond, "condition")) {
[13:20:16.362]                       if (!is.null(pattern)) {
[13:20:16.362]                         computeRestarts <- base::computeRestarts
[13:20:16.362]                         grepl <- base::grepl
[13:20:16.362]                         restarts <- computeRestarts(cond)
[13:20:16.362]                         for (restart in restarts) {
[13:20:16.362]                           name <- restart$name
[13:20:16.362]                           if (is.null(name)) 
[13:20:16.362]                             next
[13:20:16.362]                           if (!grepl(pattern, name)) 
[13:20:16.362]                             next
[13:20:16.362]                           invokeRestart(restart)
[13:20:16.362]                           muffled <- TRUE
[13:20:16.362]                           break
[13:20:16.362]                         }
[13:20:16.362]                       }
[13:20:16.362]                     }
[13:20:16.362]                     invisible(muffled)
[13:20:16.362]                   }
[13:20:16.362]                   muffleCondition(cond)
[13:20:16.362]                 })
[13:20:16.362]             }))
[13:20:16.362]             future::FutureResult(value = ...future.value$value, 
[13:20:16.362]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:16.362]                   ...future.rng), globalenv = if (FALSE) 
[13:20:16.362]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:16.362]                     ...future.globalenv.names))
[13:20:16.362]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:16.362]         }, condition = base::local({
[13:20:16.362]             c <- base::c
[13:20:16.362]             inherits <- base::inherits
[13:20:16.362]             invokeRestart <- base::invokeRestart
[13:20:16.362]             length <- base::length
[13:20:16.362]             list <- base::list
[13:20:16.362]             seq.int <- base::seq.int
[13:20:16.362]             signalCondition <- base::signalCondition
[13:20:16.362]             sys.calls <- base::sys.calls
[13:20:16.362]             `[[` <- base::`[[`
[13:20:16.362]             `+` <- base::`+`
[13:20:16.362]             `<<-` <- base::`<<-`
[13:20:16.362]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:16.362]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:16.362]                   3L)]
[13:20:16.362]             }
[13:20:16.362]             function(cond) {
[13:20:16.362]                 is_error <- inherits(cond, "error")
[13:20:16.362]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:16.362]                   NULL)
[13:20:16.362]                 if (is_error) {
[13:20:16.362]                   sessionInformation <- function() {
[13:20:16.362]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:16.362]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:16.362]                       search = base::search(), system = base::Sys.info())
[13:20:16.362]                   }
[13:20:16.362]                   ...future.conditions[[length(...future.conditions) + 
[13:20:16.362]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:16.362]                     cond$call), session = sessionInformation(), 
[13:20:16.362]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:16.362]                   signalCondition(cond)
[13:20:16.362]                 }
[13:20:16.362]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:16.362]                 "immediateCondition"))) {
[13:20:16.362]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:16.362]                   ...future.conditions[[length(...future.conditions) + 
[13:20:16.362]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:16.362]                   if (TRUE && !signal) {
[13:20:16.362]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:16.362]                     {
[13:20:16.362]                       inherits <- base::inherits
[13:20:16.362]                       invokeRestart <- base::invokeRestart
[13:20:16.362]                       is.null <- base::is.null
[13:20:16.362]                       muffled <- FALSE
[13:20:16.362]                       if (inherits(cond, "message")) {
[13:20:16.362]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:16.362]                         if (muffled) 
[13:20:16.362]                           invokeRestart("muffleMessage")
[13:20:16.362]                       }
[13:20:16.362]                       else if (inherits(cond, "warning")) {
[13:20:16.362]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:16.362]                         if (muffled) 
[13:20:16.362]                           invokeRestart("muffleWarning")
[13:20:16.362]                       }
[13:20:16.362]                       else if (inherits(cond, "condition")) {
[13:20:16.362]                         if (!is.null(pattern)) {
[13:20:16.362]                           computeRestarts <- base::computeRestarts
[13:20:16.362]                           grepl <- base::grepl
[13:20:16.362]                           restarts <- computeRestarts(cond)
[13:20:16.362]                           for (restart in restarts) {
[13:20:16.362]                             name <- restart$name
[13:20:16.362]                             if (is.null(name)) 
[13:20:16.362]                               next
[13:20:16.362]                             if (!grepl(pattern, name)) 
[13:20:16.362]                               next
[13:20:16.362]                             invokeRestart(restart)
[13:20:16.362]                             muffled <- TRUE
[13:20:16.362]                             break
[13:20:16.362]                           }
[13:20:16.362]                         }
[13:20:16.362]                       }
[13:20:16.362]                       invisible(muffled)
[13:20:16.362]                     }
[13:20:16.362]                     muffleCondition(cond, pattern = "^muffle")
[13:20:16.362]                   }
[13:20:16.362]                 }
[13:20:16.362]                 else {
[13:20:16.362]                   if (TRUE) {
[13:20:16.362]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:16.362]                     {
[13:20:16.362]                       inherits <- base::inherits
[13:20:16.362]                       invokeRestart <- base::invokeRestart
[13:20:16.362]                       is.null <- base::is.null
[13:20:16.362]                       muffled <- FALSE
[13:20:16.362]                       if (inherits(cond, "message")) {
[13:20:16.362]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:16.362]                         if (muffled) 
[13:20:16.362]                           invokeRestart("muffleMessage")
[13:20:16.362]                       }
[13:20:16.362]                       else if (inherits(cond, "warning")) {
[13:20:16.362]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:16.362]                         if (muffled) 
[13:20:16.362]                           invokeRestart("muffleWarning")
[13:20:16.362]                       }
[13:20:16.362]                       else if (inherits(cond, "condition")) {
[13:20:16.362]                         if (!is.null(pattern)) {
[13:20:16.362]                           computeRestarts <- base::computeRestarts
[13:20:16.362]                           grepl <- base::grepl
[13:20:16.362]                           restarts <- computeRestarts(cond)
[13:20:16.362]                           for (restart in restarts) {
[13:20:16.362]                             name <- restart$name
[13:20:16.362]                             if (is.null(name)) 
[13:20:16.362]                               next
[13:20:16.362]                             if (!grepl(pattern, name)) 
[13:20:16.362]                               next
[13:20:16.362]                             invokeRestart(restart)
[13:20:16.362]                             muffled <- TRUE
[13:20:16.362]                             break
[13:20:16.362]                           }
[13:20:16.362]                         }
[13:20:16.362]                       }
[13:20:16.362]                       invisible(muffled)
[13:20:16.362]                     }
[13:20:16.362]                     muffleCondition(cond, pattern = "^muffle")
[13:20:16.362]                   }
[13:20:16.362]                 }
[13:20:16.362]             }
[13:20:16.362]         }))
[13:20:16.362]     }, error = function(ex) {
[13:20:16.362]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:16.362]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:16.362]                 ...future.rng), started = ...future.startTime, 
[13:20:16.362]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:16.362]             version = "1.8"), class = "FutureResult")
[13:20:16.362]     }, finally = {
[13:20:16.362]         if (!identical(...future.workdir, getwd())) 
[13:20:16.362]             setwd(...future.workdir)
[13:20:16.362]         {
[13:20:16.362]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:16.362]                 ...future.oldOptions$nwarnings <- NULL
[13:20:16.362]             }
[13:20:16.362]             base::options(...future.oldOptions)
[13:20:16.362]             if (.Platform$OS.type == "windows") {
[13:20:16.362]                 old_names <- names(...future.oldEnvVars)
[13:20:16.362]                 envs <- base::Sys.getenv()
[13:20:16.362]                 names <- names(envs)
[13:20:16.362]                 common <- intersect(names, old_names)
[13:20:16.362]                 added <- setdiff(names, old_names)
[13:20:16.362]                 removed <- setdiff(old_names, names)
[13:20:16.362]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:16.362]                   envs[common]]
[13:20:16.362]                 NAMES <- toupper(changed)
[13:20:16.362]                 args <- list()
[13:20:16.362]                 for (kk in seq_along(NAMES)) {
[13:20:16.362]                   name <- changed[[kk]]
[13:20:16.362]                   NAME <- NAMES[[kk]]
[13:20:16.362]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:16.362]                     next
[13:20:16.362]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:16.362]                 }
[13:20:16.362]                 NAMES <- toupper(added)
[13:20:16.362]                 for (kk in seq_along(NAMES)) {
[13:20:16.362]                   name <- added[[kk]]
[13:20:16.362]                   NAME <- NAMES[[kk]]
[13:20:16.362]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:16.362]                     next
[13:20:16.362]                   args[[name]] <- ""
[13:20:16.362]                 }
[13:20:16.362]                 NAMES <- toupper(removed)
[13:20:16.362]                 for (kk in seq_along(NAMES)) {
[13:20:16.362]                   name <- removed[[kk]]
[13:20:16.362]                   NAME <- NAMES[[kk]]
[13:20:16.362]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:16.362]                     next
[13:20:16.362]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:16.362]                 }
[13:20:16.362]                 if (length(args) > 0) 
[13:20:16.362]                   base::do.call(base::Sys.setenv, args = args)
[13:20:16.362]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:16.362]             }
[13:20:16.362]             else {
[13:20:16.362]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:16.362]             }
[13:20:16.362]             {
[13:20:16.362]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:16.362]                   0L) {
[13:20:16.362]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:16.362]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:16.362]                   base::options(opts)
[13:20:16.362]                 }
[13:20:16.362]                 {
[13:20:16.362]                   {
[13:20:16.362]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:16.362]                     NULL
[13:20:16.362]                   }
[13:20:16.362]                   options(future.plan = NULL)
[13:20:16.362]                   if (is.na(NA_character_)) 
[13:20:16.362]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:16.362]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:16.362]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:16.362]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:16.362]                     envir = parent.frame()) 
[13:20:16.362]                   {
[13:20:16.362]                     if (is.function(workers)) 
[13:20:16.362]                       workers <- workers()
[13:20:16.362]                     workers <- structure(as.integer(workers), 
[13:20:16.362]                       class = class(workers))
[13:20:16.362]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:16.362]                       workers >= 1)
[13:20:16.362]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:16.362]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:16.362]                     }
[13:20:16.362]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:16.362]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:16.362]                       envir = envir)
[13:20:16.362]                     if (!future$lazy) 
[13:20:16.362]                       future <- run(future)
[13:20:16.362]                     invisible(future)
[13:20:16.362]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:16.362]                 }
[13:20:16.362]             }
[13:20:16.362]         }
[13:20:16.362]     })
[13:20:16.362]     if (TRUE) {
[13:20:16.362]         base::sink(type = "output", split = FALSE)
[13:20:16.362]         if (TRUE) {
[13:20:16.362]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:16.362]         }
[13:20:16.362]         else {
[13:20:16.362]             ...future.result["stdout"] <- base::list(NULL)
[13:20:16.362]         }
[13:20:16.362]         base::close(...future.stdout)
[13:20:16.362]         ...future.stdout <- NULL
[13:20:16.362]     }
[13:20:16.362]     ...future.result$conditions <- ...future.conditions
[13:20:16.362]     ...future.result$finished <- base::Sys.time()
[13:20:16.362]     ...future.result
[13:20:16.362] }
[13:20:16.433] MultisessionFuture started
[13:20:16.434] result() for ClusterFuture ...
[13:20:16.434] receiveMessageFromWorker() for ClusterFuture ...
[13:20:16.434] - Validating connection of MultisessionFuture
[13:20:16.466] - received message: FutureResult
[13:20:16.466] - Received FutureResult
[13:20:16.466] - Erased future from FutureRegistry
[13:20:16.466] result() for ClusterFuture ...
[13:20:16.466] - result already collected: FutureResult
[13:20:16.466] result() for ClusterFuture ... done
[13:20:16.467] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:16.467] result() for ClusterFuture ... done
[13:20:16.467] result() for ClusterFuture ...
[13:20:16.467] - result already collected: FutureResult
[13:20:16.467] result() for ClusterFuture ... done
[13:20:16.467] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:20:16.471] plan(): nbrOfWorkers() = 2
** Future evaluation without globals
[13:20:16.472] getGlobalsAndPackages() ...
[13:20:16.472] Searching for globals...
[13:20:16.473] - globals found: [2] ‘{’, ‘<-’
[13:20:16.473] Searching for globals ... DONE
[13:20:16.473] Resolving globals: FALSE
[13:20:16.473] 
[13:20:16.474] 
[13:20:16.474] getGlobalsAndPackages() ... DONE
[13:20:16.474] run() for ‘Future’ ...
[13:20:16.474] - state: ‘created’
[13:20:16.474] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:16.489] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:16.489] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:16.489]   - Field: ‘node’
[13:20:16.489]   - Field: ‘label’
[13:20:16.490]   - Field: ‘local’
[13:20:16.490]   - Field: ‘owner’
[13:20:16.490]   - Field: ‘envir’
[13:20:16.490]   - Field: ‘workers’
[13:20:16.490]   - Field: ‘packages’
[13:20:16.490]   - Field: ‘gc’
[13:20:16.490]   - Field: ‘conditions’
[13:20:16.490]   - Field: ‘persistent’
[13:20:16.490]   - Field: ‘expr’
[13:20:16.491]   - Field: ‘uuid’
[13:20:16.491]   - Field: ‘seed’
[13:20:16.491]   - Field: ‘version’
[13:20:16.491]   - Field: ‘result’
[13:20:16.491]   - Field: ‘asynchronous’
[13:20:16.491]   - Field: ‘calls’
[13:20:16.491]   - Field: ‘globals’
[13:20:16.491]   - Field: ‘stdout’
[13:20:16.491]   - Field: ‘earlySignal’
[13:20:16.492]   - Field: ‘lazy’
[13:20:16.492]   - Field: ‘state’
[13:20:16.492] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:16.492] - Launch lazy future ...
[13:20:16.492] Packages needed by the future expression (n = 0): <none>
[13:20:16.492] Packages needed by future strategies (n = 0): <none>
[13:20:16.493] {
[13:20:16.493]     {
[13:20:16.493]         {
[13:20:16.493]             ...future.startTime <- base::Sys.time()
[13:20:16.493]             {
[13:20:16.493]                 {
[13:20:16.493]                   {
[13:20:16.493]                     {
[13:20:16.493]                       base::local({
[13:20:16.493]                         has_future <- base::requireNamespace("future", 
[13:20:16.493]                           quietly = TRUE)
[13:20:16.493]                         if (has_future) {
[13:20:16.493]                           ns <- base::getNamespace("future")
[13:20:16.493]                           version <- ns[[".package"]][["version"]]
[13:20:16.493]                           if (is.null(version)) 
[13:20:16.493]                             version <- utils::packageVersion("future")
[13:20:16.493]                         }
[13:20:16.493]                         else {
[13:20:16.493]                           version <- NULL
[13:20:16.493]                         }
[13:20:16.493]                         if (!has_future || version < "1.8.0") {
[13:20:16.493]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:16.493]                             "", base::R.version$version.string), 
[13:20:16.493]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:16.493]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:16.493]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:16.493]                               "release", "version")], collapse = " "), 
[13:20:16.493]                             hostname = base::Sys.info()[["nodename"]])
[13:20:16.493]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:16.493]                             info)
[13:20:16.493]                           info <- base::paste(info, collapse = "; ")
[13:20:16.493]                           if (!has_future) {
[13:20:16.493]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:16.493]                               info)
[13:20:16.493]                           }
[13:20:16.493]                           else {
[13:20:16.493]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:16.493]                               info, version)
[13:20:16.493]                           }
[13:20:16.493]                           base::stop(msg)
[13:20:16.493]                         }
[13:20:16.493]                       })
[13:20:16.493]                     }
[13:20:16.493]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:16.493]                     base::options(mc.cores = 1L)
[13:20:16.493]                   }
[13:20:16.493]                   options(future.plan = NULL)
[13:20:16.493]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:16.493]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:16.493]                 }
[13:20:16.493]                 ...future.workdir <- getwd()
[13:20:16.493]             }
[13:20:16.493]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:16.493]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:16.493]         }
[13:20:16.493]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:16.493]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:16.493]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:16.493]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:16.493]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:16.493]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:16.493]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:16.493]             base::names(...future.oldOptions))
[13:20:16.493]     }
[13:20:16.493]     if (FALSE) {
[13:20:16.493]     }
[13:20:16.493]     else {
[13:20:16.493]         if (TRUE) {
[13:20:16.493]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:16.493]                 open = "w")
[13:20:16.493]         }
[13:20:16.493]         else {
[13:20:16.493]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:16.493]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:16.493]         }
[13:20:16.493]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:16.493]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:16.493]             base::sink(type = "output", split = FALSE)
[13:20:16.493]             base::close(...future.stdout)
[13:20:16.493]         }, add = TRUE)
[13:20:16.493]     }
[13:20:16.493]     ...future.frame <- base::sys.nframe()
[13:20:16.493]     ...future.conditions <- base::list()
[13:20:16.493]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:16.493]     if (FALSE) {
[13:20:16.493]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:16.493]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:16.493]     }
[13:20:16.493]     ...future.result <- base::tryCatch({
[13:20:16.493]         base::withCallingHandlers({
[13:20:16.493]             ...future.value <- base::withVisible(base::local({
[13:20:16.493]                 ...future.makeSendCondition <- local({
[13:20:16.493]                   sendCondition <- NULL
[13:20:16.493]                   function(frame = 1L) {
[13:20:16.493]                     if (is.function(sendCondition)) 
[13:20:16.493]                       return(sendCondition)
[13:20:16.493]                     ns <- getNamespace("parallel")
[13:20:16.493]                     if (exists("sendData", mode = "function", 
[13:20:16.493]                       envir = ns)) {
[13:20:16.493]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:16.493]                         envir = ns)
[13:20:16.493]                       envir <- sys.frame(frame)
[13:20:16.493]                       master <- NULL
[13:20:16.493]                       while (!identical(envir, .GlobalEnv) && 
[13:20:16.493]                         !identical(envir, emptyenv())) {
[13:20:16.493]                         if (exists("master", mode = "list", envir = envir, 
[13:20:16.493]                           inherits = FALSE)) {
[13:20:16.493]                           master <- get("master", mode = "list", 
[13:20:16.493]                             envir = envir, inherits = FALSE)
[13:20:16.493]                           if (inherits(master, c("SOCKnode", 
[13:20:16.493]                             "SOCK0node"))) {
[13:20:16.493]                             sendCondition <<- function(cond) {
[13:20:16.493]                               data <- list(type = "VALUE", value = cond, 
[13:20:16.493]                                 success = TRUE)
[13:20:16.493]                               parallel_sendData(master, data)
[13:20:16.493]                             }
[13:20:16.493]                             return(sendCondition)
[13:20:16.493]                           }
[13:20:16.493]                         }
[13:20:16.493]                         frame <- frame + 1L
[13:20:16.493]                         envir <- sys.frame(frame)
[13:20:16.493]                       }
[13:20:16.493]                     }
[13:20:16.493]                     sendCondition <<- function(cond) NULL
[13:20:16.493]                   }
[13:20:16.493]                 })
[13:20:16.493]                 withCallingHandlers({
[13:20:16.493]                   {
[13:20:16.493]                     x <- 1
[13:20:16.493]                   }
[13:20:16.493]                 }, immediateCondition = function(cond) {
[13:20:16.493]                   sendCondition <- ...future.makeSendCondition()
[13:20:16.493]                   sendCondition(cond)
[13:20:16.493]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:16.493]                   {
[13:20:16.493]                     inherits <- base::inherits
[13:20:16.493]                     invokeRestart <- base::invokeRestart
[13:20:16.493]                     is.null <- base::is.null
[13:20:16.493]                     muffled <- FALSE
[13:20:16.493]                     if (inherits(cond, "message")) {
[13:20:16.493]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:16.493]                       if (muffled) 
[13:20:16.493]                         invokeRestart("muffleMessage")
[13:20:16.493]                     }
[13:20:16.493]                     else if (inherits(cond, "warning")) {
[13:20:16.493]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:16.493]                       if (muffled) 
[13:20:16.493]                         invokeRestart("muffleWarning")
[13:20:16.493]                     }
[13:20:16.493]                     else if (inherits(cond, "condition")) {
[13:20:16.493]                       if (!is.null(pattern)) {
[13:20:16.493]                         computeRestarts <- base::computeRestarts
[13:20:16.493]                         grepl <- base::grepl
[13:20:16.493]                         restarts <- computeRestarts(cond)
[13:20:16.493]                         for (restart in restarts) {
[13:20:16.493]                           name <- restart$name
[13:20:16.493]                           if (is.null(name)) 
[13:20:16.493]                             next
[13:20:16.493]                           if (!grepl(pattern, name)) 
[13:20:16.493]                             next
[13:20:16.493]                           invokeRestart(restart)
[13:20:16.493]                           muffled <- TRUE
[13:20:16.493]                           break
[13:20:16.493]                         }
[13:20:16.493]                       }
[13:20:16.493]                     }
[13:20:16.493]                     invisible(muffled)
[13:20:16.493]                   }
[13:20:16.493]                   muffleCondition(cond)
[13:20:16.493]                 })
[13:20:16.493]             }))
[13:20:16.493]             future::FutureResult(value = ...future.value$value, 
[13:20:16.493]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:16.493]                   ...future.rng), globalenv = if (FALSE) 
[13:20:16.493]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:16.493]                     ...future.globalenv.names))
[13:20:16.493]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:16.493]         }, condition = base::local({
[13:20:16.493]             c <- base::c
[13:20:16.493]             inherits <- base::inherits
[13:20:16.493]             invokeRestart <- base::invokeRestart
[13:20:16.493]             length <- base::length
[13:20:16.493]             list <- base::list
[13:20:16.493]             seq.int <- base::seq.int
[13:20:16.493]             signalCondition <- base::signalCondition
[13:20:16.493]             sys.calls <- base::sys.calls
[13:20:16.493]             `[[` <- base::`[[`
[13:20:16.493]             `+` <- base::`+`
[13:20:16.493]             `<<-` <- base::`<<-`
[13:20:16.493]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:16.493]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:16.493]                   3L)]
[13:20:16.493]             }
[13:20:16.493]             function(cond) {
[13:20:16.493]                 is_error <- inherits(cond, "error")
[13:20:16.493]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:16.493]                   NULL)
[13:20:16.493]                 if (is_error) {
[13:20:16.493]                   sessionInformation <- function() {
[13:20:16.493]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:16.493]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:16.493]                       search = base::search(), system = base::Sys.info())
[13:20:16.493]                   }
[13:20:16.493]                   ...future.conditions[[length(...future.conditions) + 
[13:20:16.493]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:16.493]                     cond$call), session = sessionInformation(), 
[13:20:16.493]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:16.493]                   signalCondition(cond)
[13:20:16.493]                 }
[13:20:16.493]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:16.493]                 "immediateCondition"))) {
[13:20:16.493]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:16.493]                   ...future.conditions[[length(...future.conditions) + 
[13:20:16.493]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:16.493]                   if (TRUE && !signal) {
[13:20:16.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:16.493]                     {
[13:20:16.493]                       inherits <- base::inherits
[13:20:16.493]                       invokeRestart <- base::invokeRestart
[13:20:16.493]                       is.null <- base::is.null
[13:20:16.493]                       muffled <- FALSE
[13:20:16.493]                       if (inherits(cond, "message")) {
[13:20:16.493]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:16.493]                         if (muffled) 
[13:20:16.493]                           invokeRestart("muffleMessage")
[13:20:16.493]                       }
[13:20:16.493]                       else if (inherits(cond, "warning")) {
[13:20:16.493]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:16.493]                         if (muffled) 
[13:20:16.493]                           invokeRestart("muffleWarning")
[13:20:16.493]                       }
[13:20:16.493]                       else if (inherits(cond, "condition")) {
[13:20:16.493]                         if (!is.null(pattern)) {
[13:20:16.493]                           computeRestarts <- base::computeRestarts
[13:20:16.493]                           grepl <- base::grepl
[13:20:16.493]                           restarts <- computeRestarts(cond)
[13:20:16.493]                           for (restart in restarts) {
[13:20:16.493]                             name <- restart$name
[13:20:16.493]                             if (is.null(name)) 
[13:20:16.493]                               next
[13:20:16.493]                             if (!grepl(pattern, name)) 
[13:20:16.493]                               next
[13:20:16.493]                             invokeRestart(restart)
[13:20:16.493]                             muffled <- TRUE
[13:20:16.493]                             break
[13:20:16.493]                           }
[13:20:16.493]                         }
[13:20:16.493]                       }
[13:20:16.493]                       invisible(muffled)
[13:20:16.493]                     }
[13:20:16.493]                     muffleCondition(cond, pattern = "^muffle")
[13:20:16.493]                   }
[13:20:16.493]                 }
[13:20:16.493]                 else {
[13:20:16.493]                   if (TRUE) {
[13:20:16.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:16.493]                     {
[13:20:16.493]                       inherits <- base::inherits
[13:20:16.493]                       invokeRestart <- base::invokeRestart
[13:20:16.493]                       is.null <- base::is.null
[13:20:16.493]                       muffled <- FALSE
[13:20:16.493]                       if (inherits(cond, "message")) {
[13:20:16.493]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:16.493]                         if (muffled) 
[13:20:16.493]                           invokeRestart("muffleMessage")
[13:20:16.493]                       }
[13:20:16.493]                       else if (inherits(cond, "warning")) {
[13:20:16.493]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:16.493]                         if (muffled) 
[13:20:16.493]                           invokeRestart("muffleWarning")
[13:20:16.493]                       }
[13:20:16.493]                       else if (inherits(cond, "condition")) {
[13:20:16.493]                         if (!is.null(pattern)) {
[13:20:16.493]                           computeRestarts <- base::computeRestarts
[13:20:16.493]                           grepl <- base::grepl
[13:20:16.493]                           restarts <- computeRestarts(cond)
[13:20:16.493]                           for (restart in restarts) {
[13:20:16.493]                             name <- restart$name
[13:20:16.493]                             if (is.null(name)) 
[13:20:16.493]                               next
[13:20:16.493]                             if (!grepl(pattern, name)) 
[13:20:16.493]                               next
[13:20:16.493]                             invokeRestart(restart)
[13:20:16.493]                             muffled <- TRUE
[13:20:16.493]                             break
[13:20:16.493]                           }
[13:20:16.493]                         }
[13:20:16.493]                       }
[13:20:16.493]                       invisible(muffled)
[13:20:16.493]                     }
[13:20:16.493]                     muffleCondition(cond, pattern = "^muffle")
[13:20:16.493]                   }
[13:20:16.493]                 }
[13:20:16.493]             }
[13:20:16.493]         }))
[13:20:16.493]     }, error = function(ex) {
[13:20:16.493]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:16.493]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:16.493]                 ...future.rng), started = ...future.startTime, 
[13:20:16.493]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:16.493]             version = "1.8"), class = "FutureResult")
[13:20:16.493]     }, finally = {
[13:20:16.493]         if (!identical(...future.workdir, getwd())) 
[13:20:16.493]             setwd(...future.workdir)
[13:20:16.493]         {
[13:20:16.493]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:16.493]                 ...future.oldOptions$nwarnings <- NULL
[13:20:16.493]             }
[13:20:16.493]             base::options(...future.oldOptions)
[13:20:16.493]             if (.Platform$OS.type == "windows") {
[13:20:16.493]                 old_names <- names(...future.oldEnvVars)
[13:20:16.493]                 envs <- base::Sys.getenv()
[13:20:16.493]                 names <- names(envs)
[13:20:16.493]                 common <- intersect(names, old_names)
[13:20:16.493]                 added <- setdiff(names, old_names)
[13:20:16.493]                 removed <- setdiff(old_names, names)
[13:20:16.493]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:16.493]                   envs[common]]
[13:20:16.493]                 NAMES <- toupper(changed)
[13:20:16.493]                 args <- list()
[13:20:16.493]                 for (kk in seq_along(NAMES)) {
[13:20:16.493]                   name <- changed[[kk]]
[13:20:16.493]                   NAME <- NAMES[[kk]]
[13:20:16.493]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:16.493]                     next
[13:20:16.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:16.493]                 }
[13:20:16.493]                 NAMES <- toupper(added)
[13:20:16.493]                 for (kk in seq_along(NAMES)) {
[13:20:16.493]                   name <- added[[kk]]
[13:20:16.493]                   NAME <- NAMES[[kk]]
[13:20:16.493]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:16.493]                     next
[13:20:16.493]                   args[[name]] <- ""
[13:20:16.493]                 }
[13:20:16.493]                 NAMES <- toupper(removed)
[13:20:16.493]                 for (kk in seq_along(NAMES)) {
[13:20:16.493]                   name <- removed[[kk]]
[13:20:16.493]                   NAME <- NAMES[[kk]]
[13:20:16.493]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:16.493]                     next
[13:20:16.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:16.493]                 }
[13:20:16.493]                 if (length(args) > 0) 
[13:20:16.493]                   base::do.call(base::Sys.setenv, args = args)
[13:20:16.493]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:16.493]             }
[13:20:16.493]             else {
[13:20:16.493]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:16.493]             }
[13:20:16.493]             {
[13:20:16.493]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:16.493]                   0L) {
[13:20:16.493]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:16.493]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:16.493]                   base::options(opts)
[13:20:16.493]                 }
[13:20:16.493]                 {
[13:20:16.493]                   {
[13:20:16.493]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:16.493]                     NULL
[13:20:16.493]                   }
[13:20:16.493]                   options(future.plan = NULL)
[13:20:16.493]                   if (is.na(NA_character_)) 
[13:20:16.493]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:16.493]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:16.493]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:16.493]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:16.493]                     envir = parent.frame()) 
[13:20:16.493]                   {
[13:20:16.493]                     if (is.function(workers)) 
[13:20:16.493]                       workers <- workers()
[13:20:16.493]                     workers <- structure(as.integer(workers), 
[13:20:16.493]                       class = class(workers))
[13:20:16.493]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:16.493]                       workers >= 1)
[13:20:16.493]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:16.493]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:16.493]                     }
[13:20:16.493]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:16.493]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:16.493]                       envir = envir)
[13:20:16.493]                     if (!future$lazy) 
[13:20:16.493]                       future <- run(future)
[13:20:16.493]                     invisible(future)
[13:20:16.493]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:16.493]                 }
[13:20:16.493]             }
[13:20:16.493]         }
[13:20:16.493]     })
[13:20:16.493]     if (TRUE) {
[13:20:16.493]         base::sink(type = "output", split = FALSE)
[13:20:16.493]         if (TRUE) {
[13:20:16.493]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:16.493]         }
[13:20:16.493]         else {
[13:20:16.493]             ...future.result["stdout"] <- base::list(NULL)
[13:20:16.493]         }
[13:20:16.493]         base::close(...future.stdout)
[13:20:16.493]         ...future.stdout <- NULL
[13:20:16.493]     }
[13:20:16.493]     ...future.result$conditions <- ...future.conditions
[13:20:16.493]     ...future.result$finished <- base::Sys.time()
[13:20:16.493]     ...future.result
[13:20:16.493] }
[13:20:16.497] MultisessionFuture started
[13:20:16.497] - Launch lazy future ... done
[13:20:16.497] run() for ‘MultisessionFuture’ ... done
[13:20:16.497] result() for ClusterFuture ...
[13:20:16.497] receiveMessageFromWorker() for ClusterFuture ...
[13:20:16.497] - Validating connection of MultisessionFuture
[13:20:16.542] - received message: FutureResult
[13:20:16.542] - Received FutureResult
[13:20:16.542] - Erased future from FutureRegistry
[13:20:16.543] result() for ClusterFuture ...
[13:20:16.543] - result already collected: FutureResult
[13:20:16.543] result() for ClusterFuture ... done
[13:20:16.543] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:16.543] result() for ClusterFuture ... done
[13:20:16.543] result() for ClusterFuture ...
[13:20:16.543] - result already collected: FutureResult
[13:20:16.543] result() for ClusterFuture ... done
** Future evaluation with globals
[13:20:16.544] getGlobalsAndPackages() ...
[13:20:16.544] Searching for globals...
[13:20:16.545] - globals found: [3] ‘{’, ‘<-’, ‘a’
[13:20:16.546] Searching for globals ... DONE
[13:20:16.546] Resolving globals: FALSE
[13:20:16.546] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:16.547] The total size of the 1 globals exported for future expression (‘{; x <- a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:20:16.547] - globals: [1] ‘a’
[13:20:16.547] 
[13:20:16.547] getGlobalsAndPackages() ... DONE
[13:20:16.547] run() for ‘Future’ ...
[13:20:16.548] - state: ‘created’
[13:20:16.548] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:16.563] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:16.563] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:16.563]   - Field: ‘node’
[13:20:16.563]   - Field: ‘label’
[13:20:16.563]   - Field: ‘local’
[13:20:16.563]   - Field: ‘owner’
[13:20:16.564]   - Field: ‘envir’
[13:20:16.564]   - Field: ‘workers’
[13:20:16.564]   - Field: ‘packages’
[13:20:16.564]   - Field: ‘gc’
[13:20:16.564]   - Field: ‘conditions’
[13:20:16.564]   - Field: ‘persistent’
[13:20:16.564]   - Field: ‘expr’
[13:20:16.564]   - Field: ‘uuid’
[13:20:16.564]   - Field: ‘seed’
[13:20:16.565]   - Field: ‘version’
[13:20:16.565]   - Field: ‘result’
[13:20:16.565]   - Field: ‘asynchronous’
[13:20:16.565]   - Field: ‘calls’
[13:20:16.565]   - Field: ‘globals’
[13:20:16.565]   - Field: ‘stdout’
[13:20:16.565]   - Field: ‘earlySignal’
[13:20:16.565]   - Field: ‘lazy’
[13:20:16.566]   - Field: ‘state’
[13:20:16.566] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:16.566] - Launch lazy future ...
[13:20:16.566] Packages needed by the future expression (n = 0): <none>
[13:20:16.566] Packages needed by future strategies (n = 0): <none>
[13:20:16.567] {
[13:20:16.567]     {
[13:20:16.567]         {
[13:20:16.567]             ...future.startTime <- base::Sys.time()
[13:20:16.567]             {
[13:20:16.567]                 {
[13:20:16.567]                   {
[13:20:16.567]                     {
[13:20:16.567]                       base::local({
[13:20:16.567]                         has_future <- base::requireNamespace("future", 
[13:20:16.567]                           quietly = TRUE)
[13:20:16.567]                         if (has_future) {
[13:20:16.567]                           ns <- base::getNamespace("future")
[13:20:16.567]                           version <- ns[[".package"]][["version"]]
[13:20:16.567]                           if (is.null(version)) 
[13:20:16.567]                             version <- utils::packageVersion("future")
[13:20:16.567]                         }
[13:20:16.567]                         else {
[13:20:16.567]                           version <- NULL
[13:20:16.567]                         }
[13:20:16.567]                         if (!has_future || version < "1.8.0") {
[13:20:16.567]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:16.567]                             "", base::R.version$version.string), 
[13:20:16.567]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:16.567]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:16.567]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:16.567]                               "release", "version")], collapse = " "), 
[13:20:16.567]                             hostname = base::Sys.info()[["nodename"]])
[13:20:16.567]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:16.567]                             info)
[13:20:16.567]                           info <- base::paste(info, collapse = "; ")
[13:20:16.567]                           if (!has_future) {
[13:20:16.567]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:16.567]                               info)
[13:20:16.567]                           }
[13:20:16.567]                           else {
[13:20:16.567]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:16.567]                               info, version)
[13:20:16.567]                           }
[13:20:16.567]                           base::stop(msg)
[13:20:16.567]                         }
[13:20:16.567]                       })
[13:20:16.567]                     }
[13:20:16.567]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:16.567]                     base::options(mc.cores = 1L)
[13:20:16.567]                   }
[13:20:16.567]                   options(future.plan = NULL)
[13:20:16.567]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:16.567]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:16.567]                 }
[13:20:16.567]                 ...future.workdir <- getwd()
[13:20:16.567]             }
[13:20:16.567]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:16.567]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:16.567]         }
[13:20:16.567]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:16.567]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:16.567]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:16.567]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:16.567]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:16.567]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:16.567]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:16.567]             base::names(...future.oldOptions))
[13:20:16.567]     }
[13:20:16.567]     if (FALSE) {
[13:20:16.567]     }
[13:20:16.567]     else {
[13:20:16.567]         if (TRUE) {
[13:20:16.567]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:16.567]                 open = "w")
[13:20:16.567]         }
[13:20:16.567]         else {
[13:20:16.567]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:16.567]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:16.567]         }
[13:20:16.567]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:16.567]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:16.567]             base::sink(type = "output", split = FALSE)
[13:20:16.567]             base::close(...future.stdout)
[13:20:16.567]         }, add = TRUE)
[13:20:16.567]     }
[13:20:16.567]     ...future.frame <- base::sys.nframe()
[13:20:16.567]     ...future.conditions <- base::list()
[13:20:16.567]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:16.567]     if (FALSE) {
[13:20:16.567]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:16.567]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:16.567]     }
[13:20:16.567]     ...future.result <- base::tryCatch({
[13:20:16.567]         base::withCallingHandlers({
[13:20:16.567]             ...future.value <- base::withVisible(base::local({
[13:20:16.567]                 ...future.makeSendCondition <- local({
[13:20:16.567]                   sendCondition <- NULL
[13:20:16.567]                   function(frame = 1L) {
[13:20:16.567]                     if (is.function(sendCondition)) 
[13:20:16.567]                       return(sendCondition)
[13:20:16.567]                     ns <- getNamespace("parallel")
[13:20:16.567]                     if (exists("sendData", mode = "function", 
[13:20:16.567]                       envir = ns)) {
[13:20:16.567]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:16.567]                         envir = ns)
[13:20:16.567]                       envir <- sys.frame(frame)
[13:20:16.567]                       master <- NULL
[13:20:16.567]                       while (!identical(envir, .GlobalEnv) && 
[13:20:16.567]                         !identical(envir, emptyenv())) {
[13:20:16.567]                         if (exists("master", mode = "list", envir = envir, 
[13:20:16.567]                           inherits = FALSE)) {
[13:20:16.567]                           master <- get("master", mode = "list", 
[13:20:16.567]                             envir = envir, inherits = FALSE)
[13:20:16.567]                           if (inherits(master, c("SOCKnode", 
[13:20:16.567]                             "SOCK0node"))) {
[13:20:16.567]                             sendCondition <<- function(cond) {
[13:20:16.567]                               data <- list(type = "VALUE", value = cond, 
[13:20:16.567]                                 success = TRUE)
[13:20:16.567]                               parallel_sendData(master, data)
[13:20:16.567]                             }
[13:20:16.567]                             return(sendCondition)
[13:20:16.567]                           }
[13:20:16.567]                         }
[13:20:16.567]                         frame <- frame + 1L
[13:20:16.567]                         envir <- sys.frame(frame)
[13:20:16.567]                       }
[13:20:16.567]                     }
[13:20:16.567]                     sendCondition <<- function(cond) NULL
[13:20:16.567]                   }
[13:20:16.567]                 })
[13:20:16.567]                 withCallingHandlers({
[13:20:16.567]                   {
[13:20:16.567]                     x <- a
[13:20:16.567]                   }
[13:20:16.567]                 }, immediateCondition = function(cond) {
[13:20:16.567]                   sendCondition <- ...future.makeSendCondition()
[13:20:16.567]                   sendCondition(cond)
[13:20:16.567]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:16.567]                   {
[13:20:16.567]                     inherits <- base::inherits
[13:20:16.567]                     invokeRestart <- base::invokeRestart
[13:20:16.567]                     is.null <- base::is.null
[13:20:16.567]                     muffled <- FALSE
[13:20:16.567]                     if (inherits(cond, "message")) {
[13:20:16.567]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:16.567]                       if (muffled) 
[13:20:16.567]                         invokeRestart("muffleMessage")
[13:20:16.567]                     }
[13:20:16.567]                     else if (inherits(cond, "warning")) {
[13:20:16.567]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:16.567]                       if (muffled) 
[13:20:16.567]                         invokeRestart("muffleWarning")
[13:20:16.567]                     }
[13:20:16.567]                     else if (inherits(cond, "condition")) {
[13:20:16.567]                       if (!is.null(pattern)) {
[13:20:16.567]                         computeRestarts <- base::computeRestarts
[13:20:16.567]                         grepl <- base::grepl
[13:20:16.567]                         restarts <- computeRestarts(cond)
[13:20:16.567]                         for (restart in restarts) {
[13:20:16.567]                           name <- restart$name
[13:20:16.567]                           if (is.null(name)) 
[13:20:16.567]                             next
[13:20:16.567]                           if (!grepl(pattern, name)) 
[13:20:16.567]                             next
[13:20:16.567]                           invokeRestart(restart)
[13:20:16.567]                           muffled <- TRUE
[13:20:16.567]                           break
[13:20:16.567]                         }
[13:20:16.567]                       }
[13:20:16.567]                     }
[13:20:16.567]                     invisible(muffled)
[13:20:16.567]                   }
[13:20:16.567]                   muffleCondition(cond)
[13:20:16.567]                 })
[13:20:16.567]             }))
[13:20:16.567]             future::FutureResult(value = ...future.value$value, 
[13:20:16.567]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:16.567]                   ...future.rng), globalenv = if (FALSE) 
[13:20:16.567]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:16.567]                     ...future.globalenv.names))
[13:20:16.567]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:16.567]         }, condition = base::local({
[13:20:16.567]             c <- base::c
[13:20:16.567]             inherits <- base::inherits
[13:20:16.567]             invokeRestart <- base::invokeRestart
[13:20:16.567]             length <- base::length
[13:20:16.567]             list <- base::list
[13:20:16.567]             seq.int <- base::seq.int
[13:20:16.567]             signalCondition <- base::signalCondition
[13:20:16.567]             sys.calls <- base::sys.calls
[13:20:16.567]             `[[` <- base::`[[`
[13:20:16.567]             `+` <- base::`+`
[13:20:16.567]             `<<-` <- base::`<<-`
[13:20:16.567]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:16.567]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:16.567]                   3L)]
[13:20:16.567]             }
[13:20:16.567]             function(cond) {
[13:20:16.567]                 is_error <- inherits(cond, "error")
[13:20:16.567]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:16.567]                   NULL)
[13:20:16.567]                 if (is_error) {
[13:20:16.567]                   sessionInformation <- function() {
[13:20:16.567]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:16.567]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:16.567]                       search = base::search(), system = base::Sys.info())
[13:20:16.567]                   }
[13:20:16.567]                   ...future.conditions[[length(...future.conditions) + 
[13:20:16.567]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:16.567]                     cond$call), session = sessionInformation(), 
[13:20:16.567]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:16.567]                   signalCondition(cond)
[13:20:16.567]                 }
[13:20:16.567]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:16.567]                 "immediateCondition"))) {
[13:20:16.567]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:16.567]                   ...future.conditions[[length(...future.conditions) + 
[13:20:16.567]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:16.567]                   if (TRUE && !signal) {
[13:20:16.567]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:16.567]                     {
[13:20:16.567]                       inherits <- base::inherits
[13:20:16.567]                       invokeRestart <- base::invokeRestart
[13:20:16.567]                       is.null <- base::is.null
[13:20:16.567]                       muffled <- FALSE
[13:20:16.567]                       if (inherits(cond, "message")) {
[13:20:16.567]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:16.567]                         if (muffled) 
[13:20:16.567]                           invokeRestart("muffleMessage")
[13:20:16.567]                       }
[13:20:16.567]                       else if (inherits(cond, "warning")) {
[13:20:16.567]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:16.567]                         if (muffled) 
[13:20:16.567]                           invokeRestart("muffleWarning")
[13:20:16.567]                       }
[13:20:16.567]                       else if (inherits(cond, "condition")) {
[13:20:16.567]                         if (!is.null(pattern)) {
[13:20:16.567]                           computeRestarts <- base::computeRestarts
[13:20:16.567]                           grepl <- base::grepl
[13:20:16.567]                           restarts <- computeRestarts(cond)
[13:20:16.567]                           for (restart in restarts) {
[13:20:16.567]                             name <- restart$name
[13:20:16.567]                             if (is.null(name)) 
[13:20:16.567]                               next
[13:20:16.567]                             if (!grepl(pattern, name)) 
[13:20:16.567]                               next
[13:20:16.567]                             invokeRestart(restart)
[13:20:16.567]                             muffled <- TRUE
[13:20:16.567]                             break
[13:20:16.567]                           }
[13:20:16.567]                         }
[13:20:16.567]                       }
[13:20:16.567]                       invisible(muffled)
[13:20:16.567]                     }
[13:20:16.567]                     muffleCondition(cond, pattern = "^muffle")
[13:20:16.567]                   }
[13:20:16.567]                 }
[13:20:16.567]                 else {
[13:20:16.567]                   if (TRUE) {
[13:20:16.567]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:16.567]                     {
[13:20:16.567]                       inherits <- base::inherits
[13:20:16.567]                       invokeRestart <- base::invokeRestart
[13:20:16.567]                       is.null <- base::is.null
[13:20:16.567]                       muffled <- FALSE
[13:20:16.567]                       if (inherits(cond, "message")) {
[13:20:16.567]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:16.567]                         if (muffled) 
[13:20:16.567]                           invokeRestart("muffleMessage")
[13:20:16.567]                       }
[13:20:16.567]                       else if (inherits(cond, "warning")) {
[13:20:16.567]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:16.567]                         if (muffled) 
[13:20:16.567]                           invokeRestart("muffleWarning")
[13:20:16.567]                       }
[13:20:16.567]                       else if (inherits(cond, "condition")) {
[13:20:16.567]                         if (!is.null(pattern)) {
[13:20:16.567]                           computeRestarts <- base::computeRestarts
[13:20:16.567]                           grepl <- base::grepl
[13:20:16.567]                           restarts <- computeRestarts(cond)
[13:20:16.567]                           for (restart in restarts) {
[13:20:16.567]                             name <- restart$name
[13:20:16.567]                             if (is.null(name)) 
[13:20:16.567]                               next
[13:20:16.567]                             if (!grepl(pattern, name)) 
[13:20:16.567]                               next
[13:20:16.567]                             invokeRestart(restart)
[13:20:16.567]                             muffled <- TRUE
[13:20:16.567]                             break
[13:20:16.567]                           }
[13:20:16.567]                         }
[13:20:16.567]                       }
[13:20:16.567]                       invisible(muffled)
[13:20:16.567]                     }
[13:20:16.567]                     muffleCondition(cond, pattern = "^muffle")
[13:20:16.567]                   }
[13:20:16.567]                 }
[13:20:16.567]             }
[13:20:16.567]         }))
[13:20:16.567]     }, error = function(ex) {
[13:20:16.567]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:16.567]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:16.567]                 ...future.rng), started = ...future.startTime, 
[13:20:16.567]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:16.567]             version = "1.8"), class = "FutureResult")
[13:20:16.567]     }, finally = {
[13:20:16.567]         if (!identical(...future.workdir, getwd())) 
[13:20:16.567]             setwd(...future.workdir)
[13:20:16.567]         {
[13:20:16.567]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:16.567]                 ...future.oldOptions$nwarnings <- NULL
[13:20:16.567]             }
[13:20:16.567]             base::options(...future.oldOptions)
[13:20:16.567]             if (.Platform$OS.type == "windows") {
[13:20:16.567]                 old_names <- names(...future.oldEnvVars)
[13:20:16.567]                 envs <- base::Sys.getenv()
[13:20:16.567]                 names <- names(envs)
[13:20:16.567]                 common <- intersect(names, old_names)
[13:20:16.567]                 added <- setdiff(names, old_names)
[13:20:16.567]                 removed <- setdiff(old_names, names)
[13:20:16.567]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:16.567]                   envs[common]]
[13:20:16.567]                 NAMES <- toupper(changed)
[13:20:16.567]                 args <- list()
[13:20:16.567]                 for (kk in seq_along(NAMES)) {
[13:20:16.567]                   name <- changed[[kk]]
[13:20:16.567]                   NAME <- NAMES[[kk]]
[13:20:16.567]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:16.567]                     next
[13:20:16.567]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:16.567]                 }
[13:20:16.567]                 NAMES <- toupper(added)
[13:20:16.567]                 for (kk in seq_along(NAMES)) {
[13:20:16.567]                   name <- added[[kk]]
[13:20:16.567]                   NAME <- NAMES[[kk]]
[13:20:16.567]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:16.567]                     next
[13:20:16.567]                   args[[name]] <- ""
[13:20:16.567]                 }
[13:20:16.567]                 NAMES <- toupper(removed)
[13:20:16.567]                 for (kk in seq_along(NAMES)) {
[13:20:16.567]                   name <- removed[[kk]]
[13:20:16.567]                   NAME <- NAMES[[kk]]
[13:20:16.567]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:16.567]                     next
[13:20:16.567]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:16.567]                 }
[13:20:16.567]                 if (length(args) > 0) 
[13:20:16.567]                   base::do.call(base::Sys.setenv, args = args)
[13:20:16.567]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:16.567]             }
[13:20:16.567]             else {
[13:20:16.567]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:16.567]             }
[13:20:16.567]             {
[13:20:16.567]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:16.567]                   0L) {
[13:20:16.567]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:16.567]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:16.567]                   base::options(opts)
[13:20:16.567]                 }
[13:20:16.567]                 {
[13:20:16.567]                   {
[13:20:16.567]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:16.567]                     NULL
[13:20:16.567]                   }
[13:20:16.567]                   options(future.plan = NULL)
[13:20:16.567]                   if (is.na(NA_character_)) 
[13:20:16.567]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:16.567]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:16.567]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:16.567]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:16.567]                     envir = parent.frame()) 
[13:20:16.567]                   {
[13:20:16.567]                     if (is.function(workers)) 
[13:20:16.567]                       workers <- workers()
[13:20:16.567]                     workers <- structure(as.integer(workers), 
[13:20:16.567]                       class = class(workers))
[13:20:16.567]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:16.567]                       workers >= 1)
[13:20:16.567]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:16.567]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:16.567]                     }
[13:20:16.567]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:16.567]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:16.567]                       envir = envir)
[13:20:16.567]                     if (!future$lazy) 
[13:20:16.567]                       future <- run(future)
[13:20:16.567]                     invisible(future)
[13:20:16.567]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:16.567]                 }
[13:20:16.567]             }
[13:20:16.567]         }
[13:20:16.567]     })
[13:20:16.567]     if (TRUE) {
[13:20:16.567]         base::sink(type = "output", split = FALSE)
[13:20:16.567]         if (TRUE) {
[13:20:16.567]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:16.567]         }
[13:20:16.567]         else {
[13:20:16.567]             ...future.result["stdout"] <- base::list(NULL)
[13:20:16.567]         }
[13:20:16.567]         base::close(...future.stdout)
[13:20:16.567]         ...future.stdout <- NULL
[13:20:16.567]     }
[13:20:16.567]     ...future.result$conditions <- ...future.conditions
[13:20:16.567]     ...future.result$finished <- base::Sys.time()
[13:20:16.567]     ...future.result
[13:20:16.567] }
[13:20:16.570] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[13:20:16.570] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[13:20:16.570] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[13:20:16.570] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[13:20:16.571] MultisessionFuture started
[13:20:16.571] - Launch lazy future ... done
[13:20:16.571] run() for ‘MultisessionFuture’ ... done
[13:20:16.572] result() for ClusterFuture ...
[13:20:16.572] receiveMessageFromWorker() for ClusterFuture ...
[13:20:16.572] - Validating connection of MultisessionFuture
[13:20:16.617] - received message: FutureResult
[13:20:16.618] - Received FutureResult
[13:20:16.618] - Erased future from FutureRegistry
[13:20:16.618] result() for ClusterFuture ...
[13:20:16.618] - result already collected: FutureResult
[13:20:16.618] result() for ClusterFuture ... done
[13:20:16.618] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:16.618] result() for ClusterFuture ... done
[13:20:16.619] result() for ClusterFuture ...
[13:20:16.619] - result already collected: FutureResult
[13:20:16.619] result() for ClusterFuture ... done
** Future evaluation with errors
[13:20:16.619] getGlobalsAndPackages() ...
[13:20:16.619] Searching for globals...
[13:20:16.621] - globals found: [3] ‘{’, ‘<-’, ‘stop’
[13:20:16.621] Searching for globals ... DONE
[13:20:16.622] Resolving globals: FALSE
[13:20:16.622] 
[13:20:16.622] 
[13:20:16.622] getGlobalsAndPackages() ... DONE
[13:20:16.623] run() for ‘Future’ ...
[13:20:16.623] - state: ‘created’
[13:20:16.623] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:16.638] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:16.638] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:16.638]   - Field: ‘node’
[13:20:16.638]   - Field: ‘label’
[13:20:16.638]   - Field: ‘local’
[13:20:16.638]   - Field: ‘owner’
[13:20:16.639]   - Field: ‘envir’
[13:20:16.639]   - Field: ‘workers’
[13:20:16.639]   - Field: ‘packages’
[13:20:16.639]   - Field: ‘gc’
[13:20:16.639]   - Field: ‘conditions’
[13:20:16.639]   - Field: ‘persistent’
[13:20:16.639]   - Field: ‘expr’
[13:20:16.639]   - Field: ‘uuid’
[13:20:16.639]   - Field: ‘seed’
[13:20:16.639]   - Field: ‘version’
[13:20:16.640]   - Field: ‘result’
[13:20:16.640]   - Field: ‘asynchronous’
[13:20:16.640]   - Field: ‘calls’
[13:20:16.640]   - Field: ‘globals’
[13:20:16.640]   - Field: ‘stdout’
[13:20:16.640]   - Field: ‘earlySignal’
[13:20:16.640]   - Field: ‘lazy’
[13:20:16.640]   - Field: ‘state’
[13:20:16.641] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:16.641] - Launch lazy future ...
[13:20:16.641] Packages needed by the future expression (n = 0): <none>
[13:20:16.641] Packages needed by future strategies (n = 0): <none>
[13:20:16.642] {
[13:20:16.642]     {
[13:20:16.642]         {
[13:20:16.642]             ...future.startTime <- base::Sys.time()
[13:20:16.642]             {
[13:20:16.642]                 {
[13:20:16.642]                   {
[13:20:16.642]                     {
[13:20:16.642]                       base::local({
[13:20:16.642]                         has_future <- base::requireNamespace("future", 
[13:20:16.642]                           quietly = TRUE)
[13:20:16.642]                         if (has_future) {
[13:20:16.642]                           ns <- base::getNamespace("future")
[13:20:16.642]                           version <- ns[[".package"]][["version"]]
[13:20:16.642]                           if (is.null(version)) 
[13:20:16.642]                             version <- utils::packageVersion("future")
[13:20:16.642]                         }
[13:20:16.642]                         else {
[13:20:16.642]                           version <- NULL
[13:20:16.642]                         }
[13:20:16.642]                         if (!has_future || version < "1.8.0") {
[13:20:16.642]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:16.642]                             "", base::R.version$version.string), 
[13:20:16.642]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:16.642]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:16.642]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:16.642]                               "release", "version")], collapse = " "), 
[13:20:16.642]                             hostname = base::Sys.info()[["nodename"]])
[13:20:16.642]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:16.642]                             info)
[13:20:16.642]                           info <- base::paste(info, collapse = "; ")
[13:20:16.642]                           if (!has_future) {
[13:20:16.642]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:16.642]                               info)
[13:20:16.642]                           }
[13:20:16.642]                           else {
[13:20:16.642]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:16.642]                               info, version)
[13:20:16.642]                           }
[13:20:16.642]                           base::stop(msg)
[13:20:16.642]                         }
[13:20:16.642]                       })
[13:20:16.642]                     }
[13:20:16.642]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:16.642]                     base::options(mc.cores = 1L)
[13:20:16.642]                   }
[13:20:16.642]                   options(future.plan = NULL)
[13:20:16.642]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:16.642]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:16.642]                 }
[13:20:16.642]                 ...future.workdir <- getwd()
[13:20:16.642]             }
[13:20:16.642]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:16.642]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:16.642]         }
[13:20:16.642]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:16.642]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:16.642]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:16.642]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:16.642]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:16.642]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:16.642]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:16.642]             base::names(...future.oldOptions))
[13:20:16.642]     }
[13:20:16.642]     if (FALSE) {
[13:20:16.642]     }
[13:20:16.642]     else {
[13:20:16.642]         if (TRUE) {
[13:20:16.642]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:16.642]                 open = "w")
[13:20:16.642]         }
[13:20:16.642]         else {
[13:20:16.642]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:16.642]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:16.642]         }
[13:20:16.642]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:16.642]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:16.642]             base::sink(type = "output", split = FALSE)
[13:20:16.642]             base::close(...future.stdout)
[13:20:16.642]         }, add = TRUE)
[13:20:16.642]     }
[13:20:16.642]     ...future.frame <- base::sys.nframe()
[13:20:16.642]     ...future.conditions <- base::list()
[13:20:16.642]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:16.642]     if (FALSE) {
[13:20:16.642]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:16.642]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:16.642]     }
[13:20:16.642]     ...future.result <- base::tryCatch({
[13:20:16.642]         base::withCallingHandlers({
[13:20:16.642]             ...future.value <- base::withVisible(base::local({
[13:20:16.642]                 ...future.makeSendCondition <- local({
[13:20:16.642]                   sendCondition <- NULL
[13:20:16.642]                   function(frame = 1L) {
[13:20:16.642]                     if (is.function(sendCondition)) 
[13:20:16.642]                       return(sendCondition)
[13:20:16.642]                     ns <- getNamespace("parallel")
[13:20:16.642]                     if (exists("sendData", mode = "function", 
[13:20:16.642]                       envir = ns)) {
[13:20:16.642]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:16.642]                         envir = ns)
[13:20:16.642]                       envir <- sys.frame(frame)
[13:20:16.642]                       master <- NULL
[13:20:16.642]                       while (!identical(envir, .GlobalEnv) && 
[13:20:16.642]                         !identical(envir, emptyenv())) {
[13:20:16.642]                         if (exists("master", mode = "list", envir = envir, 
[13:20:16.642]                           inherits = FALSE)) {
[13:20:16.642]                           master <- get("master", mode = "list", 
[13:20:16.642]                             envir = envir, inherits = FALSE)
[13:20:16.642]                           if (inherits(master, c("SOCKnode", 
[13:20:16.642]                             "SOCK0node"))) {
[13:20:16.642]                             sendCondition <<- function(cond) {
[13:20:16.642]                               data <- list(type = "VALUE", value = cond, 
[13:20:16.642]                                 success = TRUE)
[13:20:16.642]                               parallel_sendData(master, data)
[13:20:16.642]                             }
[13:20:16.642]                             return(sendCondition)
[13:20:16.642]                           }
[13:20:16.642]                         }
[13:20:16.642]                         frame <- frame + 1L
[13:20:16.642]                         envir <- sys.frame(frame)
[13:20:16.642]                       }
[13:20:16.642]                     }
[13:20:16.642]                     sendCondition <<- function(cond) NULL
[13:20:16.642]                   }
[13:20:16.642]                 })
[13:20:16.642]                 withCallingHandlers({
[13:20:16.642]                   {
[13:20:16.642]                     x <- 3
[13:20:16.642]                     stop("Woops!")
[13:20:16.642]                     x
[13:20:16.642]                   }
[13:20:16.642]                 }, immediateCondition = function(cond) {
[13:20:16.642]                   sendCondition <- ...future.makeSendCondition()
[13:20:16.642]                   sendCondition(cond)
[13:20:16.642]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:16.642]                   {
[13:20:16.642]                     inherits <- base::inherits
[13:20:16.642]                     invokeRestart <- base::invokeRestart
[13:20:16.642]                     is.null <- base::is.null
[13:20:16.642]                     muffled <- FALSE
[13:20:16.642]                     if (inherits(cond, "message")) {
[13:20:16.642]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:16.642]                       if (muffled) 
[13:20:16.642]                         invokeRestart("muffleMessage")
[13:20:16.642]                     }
[13:20:16.642]                     else if (inherits(cond, "warning")) {
[13:20:16.642]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:16.642]                       if (muffled) 
[13:20:16.642]                         invokeRestart("muffleWarning")
[13:20:16.642]                     }
[13:20:16.642]                     else if (inherits(cond, "condition")) {
[13:20:16.642]                       if (!is.null(pattern)) {
[13:20:16.642]                         computeRestarts <- base::computeRestarts
[13:20:16.642]                         grepl <- base::grepl
[13:20:16.642]                         restarts <- computeRestarts(cond)
[13:20:16.642]                         for (restart in restarts) {
[13:20:16.642]                           name <- restart$name
[13:20:16.642]                           if (is.null(name)) 
[13:20:16.642]                             next
[13:20:16.642]                           if (!grepl(pattern, name)) 
[13:20:16.642]                             next
[13:20:16.642]                           invokeRestart(restart)
[13:20:16.642]                           muffled <- TRUE
[13:20:16.642]                           break
[13:20:16.642]                         }
[13:20:16.642]                       }
[13:20:16.642]                     }
[13:20:16.642]                     invisible(muffled)
[13:20:16.642]                   }
[13:20:16.642]                   muffleCondition(cond)
[13:20:16.642]                 })
[13:20:16.642]             }))
[13:20:16.642]             future::FutureResult(value = ...future.value$value, 
[13:20:16.642]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:16.642]                   ...future.rng), globalenv = if (FALSE) 
[13:20:16.642]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:16.642]                     ...future.globalenv.names))
[13:20:16.642]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:16.642]         }, condition = base::local({
[13:20:16.642]             c <- base::c
[13:20:16.642]             inherits <- base::inherits
[13:20:16.642]             invokeRestart <- base::invokeRestart
[13:20:16.642]             length <- base::length
[13:20:16.642]             list <- base::list
[13:20:16.642]             seq.int <- base::seq.int
[13:20:16.642]             signalCondition <- base::signalCondition
[13:20:16.642]             sys.calls <- base::sys.calls
[13:20:16.642]             `[[` <- base::`[[`
[13:20:16.642]             `+` <- base::`+`
[13:20:16.642]             `<<-` <- base::`<<-`
[13:20:16.642]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:16.642]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:16.642]                   3L)]
[13:20:16.642]             }
[13:20:16.642]             function(cond) {
[13:20:16.642]                 is_error <- inherits(cond, "error")
[13:20:16.642]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:16.642]                   NULL)
[13:20:16.642]                 if (is_error) {
[13:20:16.642]                   sessionInformation <- function() {
[13:20:16.642]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:16.642]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:16.642]                       search = base::search(), system = base::Sys.info())
[13:20:16.642]                   }
[13:20:16.642]                   ...future.conditions[[length(...future.conditions) + 
[13:20:16.642]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:16.642]                     cond$call), session = sessionInformation(), 
[13:20:16.642]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:16.642]                   signalCondition(cond)
[13:20:16.642]                 }
[13:20:16.642]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:16.642]                 "immediateCondition"))) {
[13:20:16.642]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:16.642]                   ...future.conditions[[length(...future.conditions) + 
[13:20:16.642]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:16.642]                   if (TRUE && !signal) {
[13:20:16.642]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:16.642]                     {
[13:20:16.642]                       inherits <- base::inherits
[13:20:16.642]                       invokeRestart <- base::invokeRestart
[13:20:16.642]                       is.null <- base::is.null
[13:20:16.642]                       muffled <- FALSE
[13:20:16.642]                       if (inherits(cond, "message")) {
[13:20:16.642]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:16.642]                         if (muffled) 
[13:20:16.642]                           invokeRestart("muffleMessage")
[13:20:16.642]                       }
[13:20:16.642]                       else if (inherits(cond, "warning")) {
[13:20:16.642]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:16.642]                         if (muffled) 
[13:20:16.642]                           invokeRestart("muffleWarning")
[13:20:16.642]                       }
[13:20:16.642]                       else if (inherits(cond, "condition")) {
[13:20:16.642]                         if (!is.null(pattern)) {
[13:20:16.642]                           computeRestarts <- base::computeRestarts
[13:20:16.642]                           grepl <- base::grepl
[13:20:16.642]                           restarts <- computeRestarts(cond)
[13:20:16.642]                           for (restart in restarts) {
[13:20:16.642]                             name <- restart$name
[13:20:16.642]                             if (is.null(name)) 
[13:20:16.642]                               next
[13:20:16.642]                             if (!grepl(pattern, name)) 
[13:20:16.642]                               next
[13:20:16.642]                             invokeRestart(restart)
[13:20:16.642]                             muffled <- TRUE
[13:20:16.642]                             break
[13:20:16.642]                           }
[13:20:16.642]                         }
[13:20:16.642]                       }
[13:20:16.642]                       invisible(muffled)
[13:20:16.642]                     }
[13:20:16.642]                     muffleCondition(cond, pattern = "^muffle")
[13:20:16.642]                   }
[13:20:16.642]                 }
[13:20:16.642]                 else {
[13:20:16.642]                   if (TRUE) {
[13:20:16.642]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:16.642]                     {
[13:20:16.642]                       inherits <- base::inherits
[13:20:16.642]                       invokeRestart <- base::invokeRestart
[13:20:16.642]                       is.null <- base::is.null
[13:20:16.642]                       muffled <- FALSE
[13:20:16.642]                       if (inherits(cond, "message")) {
[13:20:16.642]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:16.642]                         if (muffled) 
[13:20:16.642]                           invokeRestart("muffleMessage")
[13:20:16.642]                       }
[13:20:16.642]                       else if (inherits(cond, "warning")) {
[13:20:16.642]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:16.642]                         if (muffled) 
[13:20:16.642]                           invokeRestart("muffleWarning")
[13:20:16.642]                       }
[13:20:16.642]                       else if (inherits(cond, "condition")) {
[13:20:16.642]                         if (!is.null(pattern)) {
[13:20:16.642]                           computeRestarts <- base::computeRestarts
[13:20:16.642]                           grepl <- base::grepl
[13:20:16.642]                           restarts <- computeRestarts(cond)
[13:20:16.642]                           for (restart in restarts) {
[13:20:16.642]                             name <- restart$name
[13:20:16.642]                             if (is.null(name)) 
[13:20:16.642]                               next
[13:20:16.642]                             if (!grepl(pattern, name)) 
[13:20:16.642]                               next
[13:20:16.642]                             invokeRestart(restart)
[13:20:16.642]                             muffled <- TRUE
[13:20:16.642]                             break
[13:20:16.642]                           }
[13:20:16.642]                         }
[13:20:16.642]                       }
[13:20:16.642]                       invisible(muffled)
[13:20:16.642]                     }
[13:20:16.642]                     muffleCondition(cond, pattern = "^muffle")
[13:20:16.642]                   }
[13:20:16.642]                 }
[13:20:16.642]             }
[13:20:16.642]         }))
[13:20:16.642]     }, error = function(ex) {
[13:20:16.642]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:16.642]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:16.642]                 ...future.rng), started = ...future.startTime, 
[13:20:16.642]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:16.642]             version = "1.8"), class = "FutureResult")
[13:20:16.642]     }, finally = {
[13:20:16.642]         if (!identical(...future.workdir, getwd())) 
[13:20:16.642]             setwd(...future.workdir)
[13:20:16.642]         {
[13:20:16.642]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:16.642]                 ...future.oldOptions$nwarnings <- NULL
[13:20:16.642]             }
[13:20:16.642]             base::options(...future.oldOptions)
[13:20:16.642]             if (.Platform$OS.type == "windows") {
[13:20:16.642]                 old_names <- names(...future.oldEnvVars)
[13:20:16.642]                 envs <- base::Sys.getenv()
[13:20:16.642]                 names <- names(envs)
[13:20:16.642]                 common <- intersect(names, old_names)
[13:20:16.642]                 added <- setdiff(names, old_names)
[13:20:16.642]                 removed <- setdiff(old_names, names)
[13:20:16.642]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:16.642]                   envs[common]]
[13:20:16.642]                 NAMES <- toupper(changed)
[13:20:16.642]                 args <- list()
[13:20:16.642]                 for (kk in seq_along(NAMES)) {
[13:20:16.642]                   name <- changed[[kk]]
[13:20:16.642]                   NAME <- NAMES[[kk]]
[13:20:16.642]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:16.642]                     next
[13:20:16.642]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:16.642]                 }
[13:20:16.642]                 NAMES <- toupper(added)
[13:20:16.642]                 for (kk in seq_along(NAMES)) {
[13:20:16.642]                   name <- added[[kk]]
[13:20:16.642]                   NAME <- NAMES[[kk]]
[13:20:16.642]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:16.642]                     next
[13:20:16.642]                   args[[name]] <- ""
[13:20:16.642]                 }
[13:20:16.642]                 NAMES <- toupper(removed)
[13:20:16.642]                 for (kk in seq_along(NAMES)) {
[13:20:16.642]                   name <- removed[[kk]]
[13:20:16.642]                   NAME <- NAMES[[kk]]
[13:20:16.642]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:16.642]                     next
[13:20:16.642]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:16.642]                 }
[13:20:16.642]                 if (length(args) > 0) 
[13:20:16.642]                   base::do.call(base::Sys.setenv, args = args)
[13:20:16.642]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:16.642]             }
[13:20:16.642]             else {
[13:20:16.642]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:16.642]             }
[13:20:16.642]             {
[13:20:16.642]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:16.642]                   0L) {
[13:20:16.642]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:16.642]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:16.642]                   base::options(opts)
[13:20:16.642]                 }
[13:20:16.642]                 {
[13:20:16.642]                   {
[13:20:16.642]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:16.642]                     NULL
[13:20:16.642]                   }
[13:20:16.642]                   options(future.plan = NULL)
[13:20:16.642]                   if (is.na(NA_character_)) 
[13:20:16.642]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:16.642]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:16.642]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:16.642]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:16.642]                     envir = parent.frame()) 
[13:20:16.642]                   {
[13:20:16.642]                     if (is.function(workers)) 
[13:20:16.642]                       workers <- workers()
[13:20:16.642]                     workers <- structure(as.integer(workers), 
[13:20:16.642]                       class = class(workers))
[13:20:16.642]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:16.642]                       workers >= 1)
[13:20:16.642]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:16.642]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:16.642]                     }
[13:20:16.642]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:16.642]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:16.642]                       envir = envir)
[13:20:16.642]                     if (!future$lazy) 
[13:20:16.642]                       future <- run(future)
[13:20:16.642]                     invisible(future)
[13:20:16.642]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:16.642]                 }
[13:20:16.642]             }
[13:20:16.642]         }
[13:20:16.642]     })
[13:20:16.642]     if (TRUE) {
[13:20:16.642]         base::sink(type = "output", split = FALSE)
[13:20:16.642]         if (TRUE) {
[13:20:16.642]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:16.642]         }
[13:20:16.642]         else {
[13:20:16.642]             ...future.result["stdout"] <- base::list(NULL)
[13:20:16.642]         }
[13:20:16.642]         base::close(...future.stdout)
[13:20:16.642]         ...future.stdout <- NULL
[13:20:16.642]     }
[13:20:16.642]     ...future.result$conditions <- ...future.conditions
[13:20:16.642]     ...future.result$finished <- base::Sys.time()
[13:20:16.642]     ...future.result
[13:20:16.642] }
[13:20:16.645] MultisessionFuture started
[13:20:16.645] - Launch lazy future ... done
[13:20:16.646] run() for ‘MultisessionFuture’ ... done
[13:20:16.646] result() for ClusterFuture ...
[13:20:16.646] receiveMessageFromWorker() for ClusterFuture ...
[13:20:16.646] - Validating connection of MultisessionFuture
[13:20:16.694] - received message: FutureResult
[13:20:16.695] - Received FutureResult
[13:20:16.695] - Erased future from FutureRegistry
[13:20:16.695] result() for ClusterFuture ...
[13:20:16.695] - result already collected: FutureResult
[13:20:16.695] result() for ClusterFuture ... done
[13:20:16.695] signalConditions() ...
[13:20:16.695]  - include = ‘immediateCondition’
[13:20:16.695]  - exclude = 
[13:20:16.696]  - resignal = FALSE
[13:20:16.696]  - Number of conditions: 1
[13:20:16.696] signalConditions() ... done
[13:20:16.696] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:16.696] result() for ClusterFuture ... done
[13:20:16.696] result() for ClusterFuture ...
[13:20:16.696] - result already collected: FutureResult
[13:20:16.696] result() for ClusterFuture ... done
[13:20:16.696] signalConditions() ...
[13:20:16.697]  - include = ‘immediateCondition’
[13:20:16.697]  - exclude = 
[13:20:16.697]  - resignal = FALSE
[13:20:16.697]  - Number of conditions: 1
[13:20:16.697] signalConditions() ... done
[13:20:16.697] Future state: ‘finished’
[13:20:16.697] result() for ClusterFuture ...
[13:20:16.697] - result already collected: FutureResult
[13:20:16.698] result() for ClusterFuture ... done
[13:20:16.698] signalConditions() ...
[13:20:16.698]  - include = ‘condition’
[13:20:16.698]  - exclude = ‘immediateCondition’
[13:20:16.698]  - resignal = TRUE
[13:20:16.698]  - Number of conditions: 1
[13:20:16.698]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:20:16.698] signalConditions() ... done
[13:20:16.699] getGlobalsAndPackages() ...
[13:20:16.699] Searching for globals...
[13:20:16.701] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[13:20:16.701] Searching for globals ... DONE
[13:20:16.701] Resolving globals: FALSE
[13:20:16.702] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:16.702] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:20:16.703] - globals: [1] ‘ii’
[13:20:16.703] 
[13:20:16.703] getGlobalsAndPackages() ... DONE
[13:20:16.703] run() for ‘Future’ ...
[13:20:16.703] - state: ‘created’
[13:20:16.703] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:16.720] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:16.721] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:16.721]   - Field: ‘node’
[13:20:16.721]   - Field: ‘label’
[13:20:16.721]   - Field: ‘local’
[13:20:16.721]   - Field: ‘owner’
[13:20:16.721]   - Field: ‘envir’
[13:20:16.721]   - Field: ‘workers’
[13:20:16.721]   - Field: ‘packages’
[13:20:16.722]   - Field: ‘gc’
[13:20:16.722]   - Field: ‘conditions’
[13:20:16.722]   - Field: ‘persistent’
[13:20:16.722]   - Field: ‘expr’
[13:20:16.722]   - Field: ‘uuid’
[13:20:16.722]   - Field: ‘seed’
[13:20:16.722]   - Field: ‘version’
[13:20:16.722]   - Field: ‘result’
[13:20:16.722]   - Field: ‘asynchronous’
[13:20:16.722]   - Field: ‘calls’
[13:20:16.722]   - Field: ‘globals’
[13:20:16.723]   - Field: ‘stdout’
[13:20:16.723]   - Field: ‘earlySignal’
[13:20:16.723]   - Field: ‘lazy’
[13:20:16.723]   - Field: ‘state’
[13:20:16.723] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:16.723] - Launch lazy future ...
[13:20:16.723] Packages needed by the future expression (n = 0): <none>
[13:20:16.723] Packages needed by future strategies (n = 0): <none>
[13:20:16.724] {
[13:20:16.724]     {
[13:20:16.724]         {
[13:20:16.724]             ...future.startTime <- base::Sys.time()
[13:20:16.724]             {
[13:20:16.724]                 {
[13:20:16.724]                   {
[13:20:16.724]                     {
[13:20:16.724]                       base::local({
[13:20:16.724]                         has_future <- base::requireNamespace("future", 
[13:20:16.724]                           quietly = TRUE)
[13:20:16.724]                         if (has_future) {
[13:20:16.724]                           ns <- base::getNamespace("future")
[13:20:16.724]                           version <- ns[[".package"]][["version"]]
[13:20:16.724]                           if (is.null(version)) 
[13:20:16.724]                             version <- utils::packageVersion("future")
[13:20:16.724]                         }
[13:20:16.724]                         else {
[13:20:16.724]                           version <- NULL
[13:20:16.724]                         }
[13:20:16.724]                         if (!has_future || version < "1.8.0") {
[13:20:16.724]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:16.724]                             "", base::R.version$version.string), 
[13:20:16.724]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:16.724]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:16.724]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:16.724]                               "release", "version")], collapse = " "), 
[13:20:16.724]                             hostname = base::Sys.info()[["nodename"]])
[13:20:16.724]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:16.724]                             info)
[13:20:16.724]                           info <- base::paste(info, collapse = "; ")
[13:20:16.724]                           if (!has_future) {
[13:20:16.724]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:16.724]                               info)
[13:20:16.724]                           }
[13:20:16.724]                           else {
[13:20:16.724]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:16.724]                               info, version)
[13:20:16.724]                           }
[13:20:16.724]                           base::stop(msg)
[13:20:16.724]                         }
[13:20:16.724]                       })
[13:20:16.724]                     }
[13:20:16.724]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:16.724]                     base::options(mc.cores = 1L)
[13:20:16.724]                   }
[13:20:16.724]                   options(future.plan = NULL)
[13:20:16.724]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:16.724]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:16.724]                 }
[13:20:16.724]                 ...future.workdir <- getwd()
[13:20:16.724]             }
[13:20:16.724]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:16.724]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:16.724]         }
[13:20:16.724]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:16.724]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:16.724]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:16.724]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:16.724]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:16.724]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:16.724]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:16.724]             base::names(...future.oldOptions))
[13:20:16.724]     }
[13:20:16.724]     if (FALSE) {
[13:20:16.724]     }
[13:20:16.724]     else {
[13:20:16.724]         if (TRUE) {
[13:20:16.724]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:16.724]                 open = "w")
[13:20:16.724]         }
[13:20:16.724]         else {
[13:20:16.724]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:16.724]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:16.724]         }
[13:20:16.724]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:16.724]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:16.724]             base::sink(type = "output", split = FALSE)
[13:20:16.724]             base::close(...future.stdout)
[13:20:16.724]         }, add = TRUE)
[13:20:16.724]     }
[13:20:16.724]     ...future.frame <- base::sys.nframe()
[13:20:16.724]     ...future.conditions <- base::list()
[13:20:16.724]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:16.724]     if (FALSE) {
[13:20:16.724]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:16.724]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:16.724]     }
[13:20:16.724]     ...future.result <- base::tryCatch({
[13:20:16.724]         base::withCallingHandlers({
[13:20:16.724]             ...future.value <- base::withVisible(base::local({
[13:20:16.724]                 ...future.makeSendCondition <- local({
[13:20:16.724]                   sendCondition <- NULL
[13:20:16.724]                   function(frame = 1L) {
[13:20:16.724]                     if (is.function(sendCondition)) 
[13:20:16.724]                       return(sendCondition)
[13:20:16.724]                     ns <- getNamespace("parallel")
[13:20:16.724]                     if (exists("sendData", mode = "function", 
[13:20:16.724]                       envir = ns)) {
[13:20:16.724]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:16.724]                         envir = ns)
[13:20:16.724]                       envir <- sys.frame(frame)
[13:20:16.724]                       master <- NULL
[13:20:16.724]                       while (!identical(envir, .GlobalEnv) && 
[13:20:16.724]                         !identical(envir, emptyenv())) {
[13:20:16.724]                         if (exists("master", mode = "list", envir = envir, 
[13:20:16.724]                           inherits = FALSE)) {
[13:20:16.724]                           master <- get("master", mode = "list", 
[13:20:16.724]                             envir = envir, inherits = FALSE)
[13:20:16.724]                           if (inherits(master, c("SOCKnode", 
[13:20:16.724]                             "SOCK0node"))) {
[13:20:16.724]                             sendCondition <<- function(cond) {
[13:20:16.724]                               data <- list(type = "VALUE", value = cond, 
[13:20:16.724]                                 success = TRUE)
[13:20:16.724]                               parallel_sendData(master, data)
[13:20:16.724]                             }
[13:20:16.724]                             return(sendCondition)
[13:20:16.724]                           }
[13:20:16.724]                         }
[13:20:16.724]                         frame <- frame + 1L
[13:20:16.724]                         envir <- sys.frame(frame)
[13:20:16.724]                       }
[13:20:16.724]                     }
[13:20:16.724]                     sendCondition <<- function(cond) NULL
[13:20:16.724]                   }
[13:20:16.724]                 })
[13:20:16.724]                 withCallingHandlers({
[13:20:16.724]                   {
[13:20:16.724]                     if (ii%%2 == 0) 
[13:20:16.724]                       stop("Woops!")
[13:20:16.724]                     ii
[13:20:16.724]                   }
[13:20:16.724]                 }, immediateCondition = function(cond) {
[13:20:16.724]                   sendCondition <- ...future.makeSendCondition()
[13:20:16.724]                   sendCondition(cond)
[13:20:16.724]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:16.724]                   {
[13:20:16.724]                     inherits <- base::inherits
[13:20:16.724]                     invokeRestart <- base::invokeRestart
[13:20:16.724]                     is.null <- base::is.null
[13:20:16.724]                     muffled <- FALSE
[13:20:16.724]                     if (inherits(cond, "message")) {
[13:20:16.724]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:16.724]                       if (muffled) 
[13:20:16.724]                         invokeRestart("muffleMessage")
[13:20:16.724]                     }
[13:20:16.724]                     else if (inherits(cond, "warning")) {
[13:20:16.724]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:16.724]                       if (muffled) 
[13:20:16.724]                         invokeRestart("muffleWarning")
[13:20:16.724]                     }
[13:20:16.724]                     else if (inherits(cond, "condition")) {
[13:20:16.724]                       if (!is.null(pattern)) {
[13:20:16.724]                         computeRestarts <- base::computeRestarts
[13:20:16.724]                         grepl <- base::grepl
[13:20:16.724]                         restarts <- computeRestarts(cond)
[13:20:16.724]                         for (restart in restarts) {
[13:20:16.724]                           name <- restart$name
[13:20:16.724]                           if (is.null(name)) 
[13:20:16.724]                             next
[13:20:16.724]                           if (!grepl(pattern, name)) 
[13:20:16.724]                             next
[13:20:16.724]                           invokeRestart(restart)
[13:20:16.724]                           muffled <- TRUE
[13:20:16.724]                           break
[13:20:16.724]                         }
[13:20:16.724]                       }
[13:20:16.724]                     }
[13:20:16.724]                     invisible(muffled)
[13:20:16.724]                   }
[13:20:16.724]                   muffleCondition(cond)
[13:20:16.724]                 })
[13:20:16.724]             }))
[13:20:16.724]             future::FutureResult(value = ...future.value$value, 
[13:20:16.724]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:16.724]                   ...future.rng), globalenv = if (FALSE) 
[13:20:16.724]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:16.724]                     ...future.globalenv.names))
[13:20:16.724]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:16.724]         }, condition = base::local({
[13:20:16.724]             c <- base::c
[13:20:16.724]             inherits <- base::inherits
[13:20:16.724]             invokeRestart <- base::invokeRestart
[13:20:16.724]             length <- base::length
[13:20:16.724]             list <- base::list
[13:20:16.724]             seq.int <- base::seq.int
[13:20:16.724]             signalCondition <- base::signalCondition
[13:20:16.724]             sys.calls <- base::sys.calls
[13:20:16.724]             `[[` <- base::`[[`
[13:20:16.724]             `+` <- base::`+`
[13:20:16.724]             `<<-` <- base::`<<-`
[13:20:16.724]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:16.724]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:16.724]                   3L)]
[13:20:16.724]             }
[13:20:16.724]             function(cond) {
[13:20:16.724]                 is_error <- inherits(cond, "error")
[13:20:16.724]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:16.724]                   NULL)
[13:20:16.724]                 if (is_error) {
[13:20:16.724]                   sessionInformation <- function() {
[13:20:16.724]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:16.724]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:16.724]                       search = base::search(), system = base::Sys.info())
[13:20:16.724]                   }
[13:20:16.724]                   ...future.conditions[[length(...future.conditions) + 
[13:20:16.724]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:16.724]                     cond$call), session = sessionInformation(), 
[13:20:16.724]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:16.724]                   signalCondition(cond)
[13:20:16.724]                 }
[13:20:16.724]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:16.724]                 "immediateCondition"))) {
[13:20:16.724]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:16.724]                   ...future.conditions[[length(...future.conditions) + 
[13:20:16.724]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:16.724]                   if (TRUE && !signal) {
[13:20:16.724]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:16.724]                     {
[13:20:16.724]                       inherits <- base::inherits
[13:20:16.724]                       invokeRestart <- base::invokeRestart
[13:20:16.724]                       is.null <- base::is.null
[13:20:16.724]                       muffled <- FALSE
[13:20:16.724]                       if (inherits(cond, "message")) {
[13:20:16.724]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:16.724]                         if (muffled) 
[13:20:16.724]                           invokeRestart("muffleMessage")
[13:20:16.724]                       }
[13:20:16.724]                       else if (inherits(cond, "warning")) {
[13:20:16.724]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:16.724]                         if (muffled) 
[13:20:16.724]                           invokeRestart("muffleWarning")
[13:20:16.724]                       }
[13:20:16.724]                       else if (inherits(cond, "condition")) {
[13:20:16.724]                         if (!is.null(pattern)) {
[13:20:16.724]                           computeRestarts <- base::computeRestarts
[13:20:16.724]                           grepl <- base::grepl
[13:20:16.724]                           restarts <- computeRestarts(cond)
[13:20:16.724]                           for (restart in restarts) {
[13:20:16.724]                             name <- restart$name
[13:20:16.724]                             if (is.null(name)) 
[13:20:16.724]                               next
[13:20:16.724]                             if (!grepl(pattern, name)) 
[13:20:16.724]                               next
[13:20:16.724]                             invokeRestart(restart)
[13:20:16.724]                             muffled <- TRUE
[13:20:16.724]                             break
[13:20:16.724]                           }
[13:20:16.724]                         }
[13:20:16.724]                       }
[13:20:16.724]                       invisible(muffled)
[13:20:16.724]                     }
[13:20:16.724]                     muffleCondition(cond, pattern = "^muffle")
[13:20:16.724]                   }
[13:20:16.724]                 }
[13:20:16.724]                 else {
[13:20:16.724]                   if (TRUE) {
[13:20:16.724]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:16.724]                     {
[13:20:16.724]                       inherits <- base::inherits
[13:20:16.724]                       invokeRestart <- base::invokeRestart
[13:20:16.724]                       is.null <- base::is.null
[13:20:16.724]                       muffled <- FALSE
[13:20:16.724]                       if (inherits(cond, "message")) {
[13:20:16.724]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:16.724]                         if (muffled) 
[13:20:16.724]                           invokeRestart("muffleMessage")
[13:20:16.724]                       }
[13:20:16.724]                       else if (inherits(cond, "warning")) {
[13:20:16.724]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:16.724]                         if (muffled) 
[13:20:16.724]                           invokeRestart("muffleWarning")
[13:20:16.724]                       }
[13:20:16.724]                       else if (inherits(cond, "condition")) {
[13:20:16.724]                         if (!is.null(pattern)) {
[13:20:16.724]                           computeRestarts <- base::computeRestarts
[13:20:16.724]                           grepl <- base::grepl
[13:20:16.724]                           restarts <- computeRestarts(cond)
[13:20:16.724]                           for (restart in restarts) {
[13:20:16.724]                             name <- restart$name
[13:20:16.724]                             if (is.null(name)) 
[13:20:16.724]                               next
[13:20:16.724]                             if (!grepl(pattern, name)) 
[13:20:16.724]                               next
[13:20:16.724]                             invokeRestart(restart)
[13:20:16.724]                             muffled <- TRUE
[13:20:16.724]                             break
[13:20:16.724]                           }
[13:20:16.724]                         }
[13:20:16.724]                       }
[13:20:16.724]                       invisible(muffled)
[13:20:16.724]                     }
[13:20:16.724]                     muffleCondition(cond, pattern = "^muffle")
[13:20:16.724]                   }
[13:20:16.724]                 }
[13:20:16.724]             }
[13:20:16.724]         }))
[13:20:16.724]     }, error = function(ex) {
[13:20:16.724]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:16.724]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:16.724]                 ...future.rng), started = ...future.startTime, 
[13:20:16.724]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:16.724]             version = "1.8"), class = "FutureResult")
[13:20:16.724]     }, finally = {
[13:20:16.724]         if (!identical(...future.workdir, getwd())) 
[13:20:16.724]             setwd(...future.workdir)
[13:20:16.724]         {
[13:20:16.724]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:16.724]                 ...future.oldOptions$nwarnings <- NULL
[13:20:16.724]             }
[13:20:16.724]             base::options(...future.oldOptions)
[13:20:16.724]             if (.Platform$OS.type == "windows") {
[13:20:16.724]                 old_names <- names(...future.oldEnvVars)
[13:20:16.724]                 envs <- base::Sys.getenv()
[13:20:16.724]                 names <- names(envs)
[13:20:16.724]                 common <- intersect(names, old_names)
[13:20:16.724]                 added <- setdiff(names, old_names)
[13:20:16.724]                 removed <- setdiff(old_names, names)
[13:20:16.724]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:16.724]                   envs[common]]
[13:20:16.724]                 NAMES <- toupper(changed)
[13:20:16.724]                 args <- list()
[13:20:16.724]                 for (kk in seq_along(NAMES)) {
[13:20:16.724]                   name <- changed[[kk]]
[13:20:16.724]                   NAME <- NAMES[[kk]]
[13:20:16.724]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:16.724]                     next
[13:20:16.724]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:16.724]                 }
[13:20:16.724]                 NAMES <- toupper(added)
[13:20:16.724]                 for (kk in seq_along(NAMES)) {
[13:20:16.724]                   name <- added[[kk]]
[13:20:16.724]                   NAME <- NAMES[[kk]]
[13:20:16.724]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:16.724]                     next
[13:20:16.724]                   args[[name]] <- ""
[13:20:16.724]                 }
[13:20:16.724]                 NAMES <- toupper(removed)
[13:20:16.724]                 for (kk in seq_along(NAMES)) {
[13:20:16.724]                   name <- removed[[kk]]
[13:20:16.724]                   NAME <- NAMES[[kk]]
[13:20:16.724]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:16.724]                     next
[13:20:16.724]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:16.724]                 }
[13:20:16.724]                 if (length(args) > 0) 
[13:20:16.724]                   base::do.call(base::Sys.setenv, args = args)
[13:20:16.724]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:16.724]             }
[13:20:16.724]             else {
[13:20:16.724]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:16.724]             }
[13:20:16.724]             {
[13:20:16.724]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:16.724]                   0L) {
[13:20:16.724]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:16.724]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:16.724]                   base::options(opts)
[13:20:16.724]                 }
[13:20:16.724]                 {
[13:20:16.724]                   {
[13:20:16.724]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:16.724]                     NULL
[13:20:16.724]                   }
[13:20:16.724]                   options(future.plan = NULL)
[13:20:16.724]                   if (is.na(NA_character_)) 
[13:20:16.724]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:16.724]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:16.724]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:16.724]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:16.724]                     envir = parent.frame()) 
[13:20:16.724]                   {
[13:20:16.724]                     if (is.function(workers)) 
[13:20:16.724]                       workers <- workers()
[13:20:16.724]                     workers <- structure(as.integer(workers), 
[13:20:16.724]                       class = class(workers))
[13:20:16.724]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:16.724]                       workers >= 1)
[13:20:16.724]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:16.724]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:16.724]                     }
[13:20:16.724]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:16.724]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:16.724]                       envir = envir)
[13:20:16.724]                     if (!future$lazy) 
[13:20:16.724]                       future <- run(future)
[13:20:16.724]                     invisible(future)
[13:20:16.724]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:16.724]                 }
[13:20:16.724]             }
[13:20:16.724]         }
[13:20:16.724]     })
[13:20:16.724]     if (TRUE) {
[13:20:16.724]         base::sink(type = "output", split = FALSE)
[13:20:16.724]         if (TRUE) {
[13:20:16.724]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:16.724]         }
[13:20:16.724]         else {
[13:20:16.724]             ...future.result["stdout"] <- base::list(NULL)
[13:20:16.724]         }
[13:20:16.724]         base::close(...future.stdout)
[13:20:16.724]         ...future.stdout <- NULL
[13:20:16.724]     }
[13:20:16.724]     ...future.result$conditions <- ...future.conditions
[13:20:16.724]     ...future.result$finished <- base::Sys.time()
[13:20:16.724]     ...future.result
[13:20:16.724] }
[13:20:16.727] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[13:20:16.727] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[13:20:16.727] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[13:20:16.727] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[13:20:16.728] MultisessionFuture started
[13:20:16.728] - Launch lazy future ... done
[13:20:16.728] run() for ‘MultisessionFuture’ ... done
[13:20:16.728] getGlobalsAndPackages() ...
[13:20:16.729] Searching for globals...
[13:20:16.730] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[13:20:16.730] Searching for globals ... DONE
[13:20:16.730] Resolving globals: FALSE
[13:20:16.731] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:16.731] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:20:16.731] - globals: [1] ‘ii’
[13:20:16.731] 
[13:20:16.732] getGlobalsAndPackages() ... DONE
[13:20:16.732] run() for ‘Future’ ...
[13:20:16.732] - state: ‘created’
[13:20:16.732] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:16.747] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:16.747] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:16.747]   - Field: ‘node’
[13:20:16.747]   - Field: ‘label’
[13:20:16.747]   - Field: ‘local’
[13:20:16.747]   - Field: ‘owner’
[13:20:16.748]   - Field: ‘envir’
[13:20:16.748]   - Field: ‘workers’
[13:20:16.748]   - Field: ‘packages’
[13:20:16.748]   - Field: ‘gc’
[13:20:16.748]   - Field: ‘conditions’
[13:20:16.748]   - Field: ‘persistent’
[13:20:16.748]   - Field: ‘expr’
[13:20:16.748]   - Field: ‘uuid’
[13:20:16.748]   - Field: ‘seed’
[13:20:16.749]   - Field: ‘version’
[13:20:16.749]   - Field: ‘result’
[13:20:16.749]   - Field: ‘asynchronous’
[13:20:16.749]   - Field: ‘calls’
[13:20:16.749]   - Field: ‘globals’
[13:20:16.749]   - Field: ‘stdout’
[13:20:16.749]   - Field: ‘earlySignal’
[13:20:16.749]   - Field: ‘lazy’
[13:20:16.749]   - Field: ‘state’
[13:20:16.750] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:16.750] - Launch lazy future ...
[13:20:16.750] Packages needed by the future expression (n = 0): <none>
[13:20:16.750] Packages needed by future strategies (n = 0): <none>
[13:20:16.751] {
[13:20:16.751]     {
[13:20:16.751]         {
[13:20:16.751]             ...future.startTime <- base::Sys.time()
[13:20:16.751]             {
[13:20:16.751]                 {
[13:20:16.751]                   {
[13:20:16.751]                     {
[13:20:16.751]                       base::local({
[13:20:16.751]                         has_future <- base::requireNamespace("future", 
[13:20:16.751]                           quietly = TRUE)
[13:20:16.751]                         if (has_future) {
[13:20:16.751]                           ns <- base::getNamespace("future")
[13:20:16.751]                           version <- ns[[".package"]][["version"]]
[13:20:16.751]                           if (is.null(version)) 
[13:20:16.751]                             version <- utils::packageVersion("future")
[13:20:16.751]                         }
[13:20:16.751]                         else {
[13:20:16.751]                           version <- NULL
[13:20:16.751]                         }
[13:20:16.751]                         if (!has_future || version < "1.8.0") {
[13:20:16.751]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:16.751]                             "", base::R.version$version.string), 
[13:20:16.751]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:16.751]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:16.751]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:16.751]                               "release", "version")], collapse = " "), 
[13:20:16.751]                             hostname = base::Sys.info()[["nodename"]])
[13:20:16.751]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:16.751]                             info)
[13:20:16.751]                           info <- base::paste(info, collapse = "; ")
[13:20:16.751]                           if (!has_future) {
[13:20:16.751]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:16.751]                               info)
[13:20:16.751]                           }
[13:20:16.751]                           else {
[13:20:16.751]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:16.751]                               info, version)
[13:20:16.751]                           }
[13:20:16.751]                           base::stop(msg)
[13:20:16.751]                         }
[13:20:16.751]                       })
[13:20:16.751]                     }
[13:20:16.751]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:16.751]                     base::options(mc.cores = 1L)
[13:20:16.751]                   }
[13:20:16.751]                   options(future.plan = NULL)
[13:20:16.751]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:16.751]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:16.751]                 }
[13:20:16.751]                 ...future.workdir <- getwd()
[13:20:16.751]             }
[13:20:16.751]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:16.751]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:16.751]         }
[13:20:16.751]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:16.751]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:16.751]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:16.751]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:16.751]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:16.751]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:16.751]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:16.751]             base::names(...future.oldOptions))
[13:20:16.751]     }
[13:20:16.751]     if (FALSE) {
[13:20:16.751]     }
[13:20:16.751]     else {
[13:20:16.751]         if (TRUE) {
[13:20:16.751]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:16.751]                 open = "w")
[13:20:16.751]         }
[13:20:16.751]         else {
[13:20:16.751]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:16.751]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:16.751]         }
[13:20:16.751]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:16.751]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:16.751]             base::sink(type = "output", split = FALSE)
[13:20:16.751]             base::close(...future.stdout)
[13:20:16.751]         }, add = TRUE)
[13:20:16.751]     }
[13:20:16.751]     ...future.frame <- base::sys.nframe()
[13:20:16.751]     ...future.conditions <- base::list()
[13:20:16.751]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:16.751]     if (FALSE) {
[13:20:16.751]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:16.751]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:16.751]     }
[13:20:16.751]     ...future.result <- base::tryCatch({
[13:20:16.751]         base::withCallingHandlers({
[13:20:16.751]             ...future.value <- base::withVisible(base::local({
[13:20:16.751]                 ...future.makeSendCondition <- local({
[13:20:16.751]                   sendCondition <- NULL
[13:20:16.751]                   function(frame = 1L) {
[13:20:16.751]                     if (is.function(sendCondition)) 
[13:20:16.751]                       return(sendCondition)
[13:20:16.751]                     ns <- getNamespace("parallel")
[13:20:16.751]                     if (exists("sendData", mode = "function", 
[13:20:16.751]                       envir = ns)) {
[13:20:16.751]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:16.751]                         envir = ns)
[13:20:16.751]                       envir <- sys.frame(frame)
[13:20:16.751]                       master <- NULL
[13:20:16.751]                       while (!identical(envir, .GlobalEnv) && 
[13:20:16.751]                         !identical(envir, emptyenv())) {
[13:20:16.751]                         if (exists("master", mode = "list", envir = envir, 
[13:20:16.751]                           inherits = FALSE)) {
[13:20:16.751]                           master <- get("master", mode = "list", 
[13:20:16.751]                             envir = envir, inherits = FALSE)
[13:20:16.751]                           if (inherits(master, c("SOCKnode", 
[13:20:16.751]                             "SOCK0node"))) {
[13:20:16.751]                             sendCondition <<- function(cond) {
[13:20:16.751]                               data <- list(type = "VALUE", value = cond, 
[13:20:16.751]                                 success = TRUE)
[13:20:16.751]                               parallel_sendData(master, data)
[13:20:16.751]                             }
[13:20:16.751]                             return(sendCondition)
[13:20:16.751]                           }
[13:20:16.751]                         }
[13:20:16.751]                         frame <- frame + 1L
[13:20:16.751]                         envir <- sys.frame(frame)
[13:20:16.751]                       }
[13:20:16.751]                     }
[13:20:16.751]                     sendCondition <<- function(cond) NULL
[13:20:16.751]                   }
[13:20:16.751]                 })
[13:20:16.751]                 withCallingHandlers({
[13:20:16.751]                   {
[13:20:16.751]                     if (ii%%2 == 0) 
[13:20:16.751]                       stop("Woops!")
[13:20:16.751]                     ii
[13:20:16.751]                   }
[13:20:16.751]                 }, immediateCondition = function(cond) {
[13:20:16.751]                   sendCondition <- ...future.makeSendCondition()
[13:20:16.751]                   sendCondition(cond)
[13:20:16.751]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:16.751]                   {
[13:20:16.751]                     inherits <- base::inherits
[13:20:16.751]                     invokeRestart <- base::invokeRestart
[13:20:16.751]                     is.null <- base::is.null
[13:20:16.751]                     muffled <- FALSE
[13:20:16.751]                     if (inherits(cond, "message")) {
[13:20:16.751]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:16.751]                       if (muffled) 
[13:20:16.751]                         invokeRestart("muffleMessage")
[13:20:16.751]                     }
[13:20:16.751]                     else if (inherits(cond, "warning")) {
[13:20:16.751]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:16.751]                       if (muffled) 
[13:20:16.751]                         invokeRestart("muffleWarning")
[13:20:16.751]                     }
[13:20:16.751]                     else if (inherits(cond, "condition")) {
[13:20:16.751]                       if (!is.null(pattern)) {
[13:20:16.751]                         computeRestarts <- base::computeRestarts
[13:20:16.751]                         grepl <- base::grepl
[13:20:16.751]                         restarts <- computeRestarts(cond)
[13:20:16.751]                         for (restart in restarts) {
[13:20:16.751]                           name <- restart$name
[13:20:16.751]                           if (is.null(name)) 
[13:20:16.751]                             next
[13:20:16.751]                           if (!grepl(pattern, name)) 
[13:20:16.751]                             next
[13:20:16.751]                           invokeRestart(restart)
[13:20:16.751]                           muffled <- TRUE
[13:20:16.751]                           break
[13:20:16.751]                         }
[13:20:16.751]                       }
[13:20:16.751]                     }
[13:20:16.751]                     invisible(muffled)
[13:20:16.751]                   }
[13:20:16.751]                   muffleCondition(cond)
[13:20:16.751]                 })
[13:20:16.751]             }))
[13:20:16.751]             future::FutureResult(value = ...future.value$value, 
[13:20:16.751]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:16.751]                   ...future.rng), globalenv = if (FALSE) 
[13:20:16.751]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:16.751]                     ...future.globalenv.names))
[13:20:16.751]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:16.751]         }, condition = base::local({
[13:20:16.751]             c <- base::c
[13:20:16.751]             inherits <- base::inherits
[13:20:16.751]             invokeRestart <- base::invokeRestart
[13:20:16.751]             length <- base::length
[13:20:16.751]             list <- base::list
[13:20:16.751]             seq.int <- base::seq.int
[13:20:16.751]             signalCondition <- base::signalCondition
[13:20:16.751]             sys.calls <- base::sys.calls
[13:20:16.751]             `[[` <- base::`[[`
[13:20:16.751]             `+` <- base::`+`
[13:20:16.751]             `<<-` <- base::`<<-`
[13:20:16.751]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:16.751]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:16.751]                   3L)]
[13:20:16.751]             }
[13:20:16.751]             function(cond) {
[13:20:16.751]                 is_error <- inherits(cond, "error")
[13:20:16.751]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:16.751]                   NULL)
[13:20:16.751]                 if (is_error) {
[13:20:16.751]                   sessionInformation <- function() {
[13:20:16.751]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:16.751]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:16.751]                       search = base::search(), system = base::Sys.info())
[13:20:16.751]                   }
[13:20:16.751]                   ...future.conditions[[length(...future.conditions) + 
[13:20:16.751]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:16.751]                     cond$call), session = sessionInformation(), 
[13:20:16.751]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:16.751]                   signalCondition(cond)
[13:20:16.751]                 }
[13:20:16.751]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:16.751]                 "immediateCondition"))) {
[13:20:16.751]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:16.751]                   ...future.conditions[[length(...future.conditions) + 
[13:20:16.751]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:16.751]                   if (TRUE && !signal) {
[13:20:16.751]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:16.751]                     {
[13:20:16.751]                       inherits <- base::inherits
[13:20:16.751]                       invokeRestart <- base::invokeRestart
[13:20:16.751]                       is.null <- base::is.null
[13:20:16.751]                       muffled <- FALSE
[13:20:16.751]                       if (inherits(cond, "message")) {
[13:20:16.751]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:16.751]                         if (muffled) 
[13:20:16.751]                           invokeRestart("muffleMessage")
[13:20:16.751]                       }
[13:20:16.751]                       else if (inherits(cond, "warning")) {
[13:20:16.751]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:16.751]                         if (muffled) 
[13:20:16.751]                           invokeRestart("muffleWarning")
[13:20:16.751]                       }
[13:20:16.751]                       else if (inherits(cond, "condition")) {
[13:20:16.751]                         if (!is.null(pattern)) {
[13:20:16.751]                           computeRestarts <- base::computeRestarts
[13:20:16.751]                           grepl <- base::grepl
[13:20:16.751]                           restarts <- computeRestarts(cond)
[13:20:16.751]                           for (restart in restarts) {
[13:20:16.751]                             name <- restart$name
[13:20:16.751]                             if (is.null(name)) 
[13:20:16.751]                               next
[13:20:16.751]                             if (!grepl(pattern, name)) 
[13:20:16.751]                               next
[13:20:16.751]                             invokeRestart(restart)
[13:20:16.751]                             muffled <- TRUE
[13:20:16.751]                             break
[13:20:16.751]                           }
[13:20:16.751]                         }
[13:20:16.751]                       }
[13:20:16.751]                       invisible(muffled)
[13:20:16.751]                     }
[13:20:16.751]                     muffleCondition(cond, pattern = "^muffle")
[13:20:16.751]                   }
[13:20:16.751]                 }
[13:20:16.751]                 else {
[13:20:16.751]                   if (TRUE) {
[13:20:16.751]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:16.751]                     {
[13:20:16.751]                       inherits <- base::inherits
[13:20:16.751]                       invokeRestart <- base::invokeRestart
[13:20:16.751]                       is.null <- base::is.null
[13:20:16.751]                       muffled <- FALSE
[13:20:16.751]                       if (inherits(cond, "message")) {
[13:20:16.751]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:16.751]                         if (muffled) 
[13:20:16.751]                           invokeRestart("muffleMessage")
[13:20:16.751]                       }
[13:20:16.751]                       else if (inherits(cond, "warning")) {
[13:20:16.751]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:16.751]                         if (muffled) 
[13:20:16.751]                           invokeRestart("muffleWarning")
[13:20:16.751]                       }
[13:20:16.751]                       else if (inherits(cond, "condition")) {
[13:20:16.751]                         if (!is.null(pattern)) {
[13:20:16.751]                           computeRestarts <- base::computeRestarts
[13:20:16.751]                           grepl <- base::grepl
[13:20:16.751]                           restarts <- computeRestarts(cond)
[13:20:16.751]                           for (restart in restarts) {
[13:20:16.751]                             name <- restart$name
[13:20:16.751]                             if (is.null(name)) 
[13:20:16.751]                               next
[13:20:16.751]                             if (!grepl(pattern, name)) 
[13:20:16.751]                               next
[13:20:16.751]                             invokeRestart(restart)
[13:20:16.751]                             muffled <- TRUE
[13:20:16.751]                             break
[13:20:16.751]                           }
[13:20:16.751]                         }
[13:20:16.751]                       }
[13:20:16.751]                       invisible(muffled)
[13:20:16.751]                     }
[13:20:16.751]                     muffleCondition(cond, pattern = "^muffle")
[13:20:16.751]                   }
[13:20:16.751]                 }
[13:20:16.751]             }
[13:20:16.751]         }))
[13:20:16.751]     }, error = function(ex) {
[13:20:16.751]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:16.751]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:16.751]                 ...future.rng), started = ...future.startTime, 
[13:20:16.751]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:16.751]             version = "1.8"), class = "FutureResult")
[13:20:16.751]     }, finally = {
[13:20:16.751]         if (!identical(...future.workdir, getwd())) 
[13:20:16.751]             setwd(...future.workdir)
[13:20:16.751]         {
[13:20:16.751]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:16.751]                 ...future.oldOptions$nwarnings <- NULL
[13:20:16.751]             }
[13:20:16.751]             base::options(...future.oldOptions)
[13:20:16.751]             if (.Platform$OS.type == "windows") {
[13:20:16.751]                 old_names <- names(...future.oldEnvVars)
[13:20:16.751]                 envs <- base::Sys.getenv()
[13:20:16.751]                 names <- names(envs)
[13:20:16.751]                 common <- intersect(names, old_names)
[13:20:16.751]                 added <- setdiff(names, old_names)
[13:20:16.751]                 removed <- setdiff(old_names, names)
[13:20:16.751]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:16.751]                   envs[common]]
[13:20:16.751]                 NAMES <- toupper(changed)
[13:20:16.751]                 args <- list()
[13:20:16.751]                 for (kk in seq_along(NAMES)) {
[13:20:16.751]                   name <- changed[[kk]]
[13:20:16.751]                   NAME <- NAMES[[kk]]
[13:20:16.751]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:16.751]                     next
[13:20:16.751]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:16.751]                 }
[13:20:16.751]                 NAMES <- toupper(added)
[13:20:16.751]                 for (kk in seq_along(NAMES)) {
[13:20:16.751]                   name <- added[[kk]]
[13:20:16.751]                   NAME <- NAMES[[kk]]
[13:20:16.751]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:16.751]                     next
[13:20:16.751]                   args[[name]] <- ""
[13:20:16.751]                 }
[13:20:16.751]                 NAMES <- toupper(removed)
[13:20:16.751]                 for (kk in seq_along(NAMES)) {
[13:20:16.751]                   name <- removed[[kk]]
[13:20:16.751]                   NAME <- NAMES[[kk]]
[13:20:16.751]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:16.751]                     next
[13:20:16.751]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:16.751]                 }
[13:20:16.751]                 if (length(args) > 0) 
[13:20:16.751]                   base::do.call(base::Sys.setenv, args = args)
[13:20:16.751]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:16.751]             }
[13:20:16.751]             else {
[13:20:16.751]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:16.751]             }
[13:20:16.751]             {
[13:20:16.751]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:16.751]                   0L) {
[13:20:16.751]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:16.751]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:16.751]                   base::options(opts)
[13:20:16.751]                 }
[13:20:16.751]                 {
[13:20:16.751]                   {
[13:20:16.751]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:16.751]                     NULL
[13:20:16.751]                   }
[13:20:16.751]                   options(future.plan = NULL)
[13:20:16.751]                   if (is.na(NA_character_)) 
[13:20:16.751]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:16.751]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:16.751]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:16.751]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:16.751]                     envir = parent.frame()) 
[13:20:16.751]                   {
[13:20:16.751]                     if (is.function(workers)) 
[13:20:16.751]                       workers <- workers()
[13:20:16.751]                     workers <- structure(as.integer(workers), 
[13:20:16.751]                       class = class(workers))
[13:20:16.751]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:16.751]                       workers >= 1)
[13:20:16.751]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:16.751]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:16.751]                     }
[13:20:16.751]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:16.751]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:16.751]                       envir = envir)
[13:20:16.751]                     if (!future$lazy) 
[13:20:16.751]                       future <- run(future)
[13:20:16.751]                     invisible(future)
[13:20:16.751]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:16.751]                 }
[13:20:16.751]             }
[13:20:16.751]         }
[13:20:16.751]     })
[13:20:16.751]     if (TRUE) {
[13:20:16.751]         base::sink(type = "output", split = FALSE)
[13:20:16.751]         if (TRUE) {
[13:20:16.751]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:16.751]         }
[13:20:16.751]         else {
[13:20:16.751]             ...future.result["stdout"] <- base::list(NULL)
[13:20:16.751]         }
[13:20:16.751]         base::close(...future.stdout)
[13:20:16.751]         ...future.stdout <- NULL
[13:20:16.751]     }
[13:20:16.751]     ...future.result$conditions <- ...future.conditions
[13:20:16.751]     ...future.result$finished <- base::Sys.time()
[13:20:16.751]     ...future.result
[13:20:16.751] }
[13:20:16.823] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[13:20:16.824] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[13:20:16.824] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[13:20:16.824] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[13:20:16.825] MultisessionFuture started
[13:20:16.825] - Launch lazy future ... done
[13:20:16.825] run() for ‘MultisessionFuture’ ... done
[13:20:16.825] getGlobalsAndPackages() ...
[13:20:16.826] Searching for globals...
[13:20:16.827] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[13:20:16.827] Searching for globals ... DONE
[13:20:16.828] Resolving globals: FALSE
[13:20:16.828] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:16.828] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:20:16.829] - globals: [1] ‘ii’
[13:20:16.829] 
[13:20:16.829] getGlobalsAndPackages() ... DONE
[13:20:16.829] run() for ‘Future’ ...
[13:20:16.829] - state: ‘created’
[13:20:16.829] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:16.846] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:16.846] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:16.846]   - Field: ‘node’
[13:20:16.846]   - Field: ‘label’
[13:20:16.846]   - Field: ‘local’
[13:20:16.846]   - Field: ‘owner’
[13:20:16.847]   - Field: ‘envir’
[13:20:16.847]   - Field: ‘workers’
[13:20:16.847]   - Field: ‘packages’
[13:20:16.847]   - Field: ‘gc’
[13:20:16.847]   - Field: ‘conditions’
[13:20:16.847]   - Field: ‘persistent’
[13:20:16.847]   - Field: ‘expr’
[13:20:16.847]   - Field: ‘uuid’
[13:20:16.847]   - Field: ‘seed’
[13:20:16.847]   - Field: ‘version’
[13:20:16.848]   - Field: ‘result’
[13:20:16.848]   - Field: ‘asynchronous’
[13:20:16.848]   - Field: ‘calls’
[13:20:16.848]   - Field: ‘globals’
[13:20:16.848]   - Field: ‘stdout’
[13:20:16.848]   - Field: ‘earlySignal’
[13:20:16.848]   - Field: ‘lazy’
[13:20:16.848]   - Field: ‘state’
[13:20:16.848] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:16.848] - Launch lazy future ...
[13:20:16.849] Packages needed by the future expression (n = 0): <none>
[13:20:16.849] Packages needed by future strategies (n = 0): <none>
[13:20:16.849] {
[13:20:16.849]     {
[13:20:16.849]         {
[13:20:16.849]             ...future.startTime <- base::Sys.time()
[13:20:16.849]             {
[13:20:16.849]                 {
[13:20:16.849]                   {
[13:20:16.849]                     {
[13:20:16.849]                       base::local({
[13:20:16.849]                         has_future <- base::requireNamespace("future", 
[13:20:16.849]                           quietly = TRUE)
[13:20:16.849]                         if (has_future) {
[13:20:16.849]                           ns <- base::getNamespace("future")
[13:20:16.849]                           version <- ns[[".package"]][["version"]]
[13:20:16.849]                           if (is.null(version)) 
[13:20:16.849]                             version <- utils::packageVersion("future")
[13:20:16.849]                         }
[13:20:16.849]                         else {
[13:20:16.849]                           version <- NULL
[13:20:16.849]                         }
[13:20:16.849]                         if (!has_future || version < "1.8.0") {
[13:20:16.849]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:16.849]                             "", base::R.version$version.string), 
[13:20:16.849]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:16.849]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:16.849]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:16.849]                               "release", "version")], collapse = " "), 
[13:20:16.849]                             hostname = base::Sys.info()[["nodename"]])
[13:20:16.849]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:16.849]                             info)
[13:20:16.849]                           info <- base::paste(info, collapse = "; ")
[13:20:16.849]                           if (!has_future) {
[13:20:16.849]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:16.849]                               info)
[13:20:16.849]                           }
[13:20:16.849]                           else {
[13:20:16.849]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:16.849]                               info, version)
[13:20:16.849]                           }
[13:20:16.849]                           base::stop(msg)
[13:20:16.849]                         }
[13:20:16.849]                       })
[13:20:16.849]                     }
[13:20:16.849]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:16.849]                     base::options(mc.cores = 1L)
[13:20:16.849]                   }
[13:20:16.849]                   options(future.plan = NULL)
[13:20:16.849]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:16.849]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:16.849]                 }
[13:20:16.849]                 ...future.workdir <- getwd()
[13:20:16.849]             }
[13:20:16.849]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:16.849]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:16.849]         }
[13:20:16.849]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:16.849]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:16.849]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:16.849]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:16.849]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:16.849]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:16.849]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:16.849]             base::names(...future.oldOptions))
[13:20:16.849]     }
[13:20:16.849]     if (FALSE) {
[13:20:16.849]     }
[13:20:16.849]     else {
[13:20:16.849]         if (TRUE) {
[13:20:16.849]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:16.849]                 open = "w")
[13:20:16.849]         }
[13:20:16.849]         else {
[13:20:16.849]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:16.849]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:16.849]         }
[13:20:16.849]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:16.849]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:16.849]             base::sink(type = "output", split = FALSE)
[13:20:16.849]             base::close(...future.stdout)
[13:20:16.849]         }, add = TRUE)
[13:20:16.849]     }
[13:20:16.849]     ...future.frame <- base::sys.nframe()
[13:20:16.849]     ...future.conditions <- base::list()
[13:20:16.849]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:16.849]     if (FALSE) {
[13:20:16.849]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:16.849]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:16.849]     }
[13:20:16.849]     ...future.result <- base::tryCatch({
[13:20:16.849]         base::withCallingHandlers({
[13:20:16.849]             ...future.value <- base::withVisible(base::local({
[13:20:16.849]                 ...future.makeSendCondition <- local({
[13:20:16.849]                   sendCondition <- NULL
[13:20:16.849]                   function(frame = 1L) {
[13:20:16.849]                     if (is.function(sendCondition)) 
[13:20:16.849]                       return(sendCondition)
[13:20:16.849]                     ns <- getNamespace("parallel")
[13:20:16.849]                     if (exists("sendData", mode = "function", 
[13:20:16.849]                       envir = ns)) {
[13:20:16.849]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:16.849]                         envir = ns)
[13:20:16.849]                       envir <- sys.frame(frame)
[13:20:16.849]                       master <- NULL
[13:20:16.849]                       while (!identical(envir, .GlobalEnv) && 
[13:20:16.849]                         !identical(envir, emptyenv())) {
[13:20:16.849]                         if (exists("master", mode = "list", envir = envir, 
[13:20:16.849]                           inherits = FALSE)) {
[13:20:16.849]                           master <- get("master", mode = "list", 
[13:20:16.849]                             envir = envir, inherits = FALSE)
[13:20:16.849]                           if (inherits(master, c("SOCKnode", 
[13:20:16.849]                             "SOCK0node"))) {
[13:20:16.849]                             sendCondition <<- function(cond) {
[13:20:16.849]                               data <- list(type = "VALUE", value = cond, 
[13:20:16.849]                                 success = TRUE)
[13:20:16.849]                               parallel_sendData(master, data)
[13:20:16.849]                             }
[13:20:16.849]                             return(sendCondition)
[13:20:16.849]                           }
[13:20:16.849]                         }
[13:20:16.849]                         frame <- frame + 1L
[13:20:16.849]                         envir <- sys.frame(frame)
[13:20:16.849]                       }
[13:20:16.849]                     }
[13:20:16.849]                     sendCondition <<- function(cond) NULL
[13:20:16.849]                   }
[13:20:16.849]                 })
[13:20:16.849]                 withCallingHandlers({
[13:20:16.849]                   {
[13:20:16.849]                     if (ii%%2 == 0) 
[13:20:16.849]                       stop("Woops!")
[13:20:16.849]                     ii
[13:20:16.849]                   }
[13:20:16.849]                 }, immediateCondition = function(cond) {
[13:20:16.849]                   sendCondition <- ...future.makeSendCondition()
[13:20:16.849]                   sendCondition(cond)
[13:20:16.849]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:16.849]                   {
[13:20:16.849]                     inherits <- base::inherits
[13:20:16.849]                     invokeRestart <- base::invokeRestart
[13:20:16.849]                     is.null <- base::is.null
[13:20:16.849]                     muffled <- FALSE
[13:20:16.849]                     if (inherits(cond, "message")) {
[13:20:16.849]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:16.849]                       if (muffled) 
[13:20:16.849]                         invokeRestart("muffleMessage")
[13:20:16.849]                     }
[13:20:16.849]                     else if (inherits(cond, "warning")) {
[13:20:16.849]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:16.849]                       if (muffled) 
[13:20:16.849]                         invokeRestart("muffleWarning")
[13:20:16.849]                     }
[13:20:16.849]                     else if (inherits(cond, "condition")) {
[13:20:16.849]                       if (!is.null(pattern)) {
[13:20:16.849]                         computeRestarts <- base::computeRestarts
[13:20:16.849]                         grepl <- base::grepl
[13:20:16.849]                         restarts <- computeRestarts(cond)
[13:20:16.849]                         for (restart in restarts) {
[13:20:16.849]                           name <- restart$name
[13:20:16.849]                           if (is.null(name)) 
[13:20:16.849]                             next
[13:20:16.849]                           if (!grepl(pattern, name)) 
[13:20:16.849]                             next
[13:20:16.849]                           invokeRestart(restart)
[13:20:16.849]                           muffled <- TRUE
[13:20:16.849]                           break
[13:20:16.849]                         }
[13:20:16.849]                       }
[13:20:16.849]                     }
[13:20:16.849]                     invisible(muffled)
[13:20:16.849]                   }
[13:20:16.849]                   muffleCondition(cond)
[13:20:16.849]                 })
[13:20:16.849]             }))
[13:20:16.849]             future::FutureResult(value = ...future.value$value, 
[13:20:16.849]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:16.849]                   ...future.rng), globalenv = if (FALSE) 
[13:20:16.849]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:16.849]                     ...future.globalenv.names))
[13:20:16.849]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:16.849]         }, condition = base::local({
[13:20:16.849]             c <- base::c
[13:20:16.849]             inherits <- base::inherits
[13:20:16.849]             invokeRestart <- base::invokeRestart
[13:20:16.849]             length <- base::length
[13:20:16.849]             list <- base::list
[13:20:16.849]             seq.int <- base::seq.int
[13:20:16.849]             signalCondition <- base::signalCondition
[13:20:16.849]             sys.calls <- base::sys.calls
[13:20:16.849]             `[[` <- base::`[[`
[13:20:16.849]             `+` <- base::`+`
[13:20:16.849]             `<<-` <- base::`<<-`
[13:20:16.849]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:16.849]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:16.849]                   3L)]
[13:20:16.849]             }
[13:20:16.849]             function(cond) {
[13:20:16.849]                 is_error <- inherits(cond, "error")
[13:20:16.849]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:16.849]                   NULL)
[13:20:16.849]                 if (is_error) {
[13:20:16.849]                   sessionInformation <- function() {
[13:20:16.849]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:16.849]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:16.849]                       search = base::search(), system = base::Sys.info())
[13:20:16.849]                   }
[13:20:16.849]                   ...future.conditions[[length(...future.conditions) + 
[13:20:16.849]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:16.849]                     cond$call), session = sessionInformation(), 
[13:20:16.849]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:16.849]                   signalCondition(cond)
[13:20:16.849]                 }
[13:20:16.849]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:16.849]                 "immediateCondition"))) {
[13:20:16.849]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:16.849]                   ...future.conditions[[length(...future.conditions) + 
[13:20:16.849]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:16.849]                   if (TRUE && !signal) {
[13:20:16.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:16.849]                     {
[13:20:16.849]                       inherits <- base::inherits
[13:20:16.849]                       invokeRestart <- base::invokeRestart
[13:20:16.849]                       is.null <- base::is.null
[13:20:16.849]                       muffled <- FALSE
[13:20:16.849]                       if (inherits(cond, "message")) {
[13:20:16.849]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:16.849]                         if (muffled) 
[13:20:16.849]                           invokeRestart("muffleMessage")
[13:20:16.849]                       }
[13:20:16.849]                       else if (inherits(cond, "warning")) {
[13:20:16.849]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:16.849]                         if (muffled) 
[13:20:16.849]                           invokeRestart("muffleWarning")
[13:20:16.849]                       }
[13:20:16.849]                       else if (inherits(cond, "condition")) {
[13:20:16.849]                         if (!is.null(pattern)) {
[13:20:16.849]                           computeRestarts <- base::computeRestarts
[13:20:16.849]                           grepl <- base::grepl
[13:20:16.849]                           restarts <- computeRestarts(cond)
[13:20:16.849]                           for (restart in restarts) {
[13:20:16.849]                             name <- restart$name
[13:20:16.849]                             if (is.null(name)) 
[13:20:16.849]                               next
[13:20:16.849]                             if (!grepl(pattern, name)) 
[13:20:16.849]                               next
[13:20:16.849]                             invokeRestart(restart)
[13:20:16.849]                             muffled <- TRUE
[13:20:16.849]                             break
[13:20:16.849]                           }
[13:20:16.849]                         }
[13:20:16.849]                       }
[13:20:16.849]                       invisible(muffled)
[13:20:16.849]                     }
[13:20:16.849]                     muffleCondition(cond, pattern = "^muffle")
[13:20:16.849]                   }
[13:20:16.849]                 }
[13:20:16.849]                 else {
[13:20:16.849]                   if (TRUE) {
[13:20:16.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:16.849]                     {
[13:20:16.849]                       inherits <- base::inherits
[13:20:16.849]                       invokeRestart <- base::invokeRestart
[13:20:16.849]                       is.null <- base::is.null
[13:20:16.849]                       muffled <- FALSE
[13:20:16.849]                       if (inherits(cond, "message")) {
[13:20:16.849]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:16.849]                         if (muffled) 
[13:20:16.849]                           invokeRestart("muffleMessage")
[13:20:16.849]                       }
[13:20:16.849]                       else if (inherits(cond, "warning")) {
[13:20:16.849]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:16.849]                         if (muffled) 
[13:20:16.849]                           invokeRestart("muffleWarning")
[13:20:16.849]                       }
[13:20:16.849]                       else if (inherits(cond, "condition")) {
[13:20:16.849]                         if (!is.null(pattern)) {
[13:20:16.849]                           computeRestarts <- base::computeRestarts
[13:20:16.849]                           grepl <- base::grepl
[13:20:16.849]                           restarts <- computeRestarts(cond)
[13:20:16.849]                           for (restart in restarts) {
[13:20:16.849]                             name <- restart$name
[13:20:16.849]                             if (is.null(name)) 
[13:20:16.849]                               next
[13:20:16.849]                             if (!grepl(pattern, name)) 
[13:20:16.849]                               next
[13:20:16.849]                             invokeRestart(restart)
[13:20:16.849]                             muffled <- TRUE
[13:20:16.849]                             break
[13:20:16.849]                           }
[13:20:16.849]                         }
[13:20:16.849]                       }
[13:20:16.849]                       invisible(muffled)
[13:20:16.849]                     }
[13:20:16.849]                     muffleCondition(cond, pattern = "^muffle")
[13:20:16.849]                   }
[13:20:16.849]                 }
[13:20:16.849]             }
[13:20:16.849]         }))
[13:20:16.849]     }, error = function(ex) {
[13:20:16.849]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:16.849]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:16.849]                 ...future.rng), started = ...future.startTime, 
[13:20:16.849]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:16.849]             version = "1.8"), class = "FutureResult")
[13:20:16.849]     }, finally = {
[13:20:16.849]         if (!identical(...future.workdir, getwd())) 
[13:20:16.849]             setwd(...future.workdir)
[13:20:16.849]         {
[13:20:16.849]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:16.849]                 ...future.oldOptions$nwarnings <- NULL
[13:20:16.849]             }
[13:20:16.849]             base::options(...future.oldOptions)
[13:20:16.849]             if (.Platform$OS.type == "windows") {
[13:20:16.849]                 old_names <- names(...future.oldEnvVars)
[13:20:16.849]                 envs <- base::Sys.getenv()
[13:20:16.849]                 names <- names(envs)
[13:20:16.849]                 common <- intersect(names, old_names)
[13:20:16.849]                 added <- setdiff(names, old_names)
[13:20:16.849]                 removed <- setdiff(old_names, names)
[13:20:16.849]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:16.849]                   envs[common]]
[13:20:16.849]                 NAMES <- toupper(changed)
[13:20:16.849]                 args <- list()
[13:20:16.849]                 for (kk in seq_along(NAMES)) {
[13:20:16.849]                   name <- changed[[kk]]
[13:20:16.849]                   NAME <- NAMES[[kk]]
[13:20:16.849]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:16.849]                     next
[13:20:16.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:16.849]                 }
[13:20:16.849]                 NAMES <- toupper(added)
[13:20:16.849]                 for (kk in seq_along(NAMES)) {
[13:20:16.849]                   name <- added[[kk]]
[13:20:16.849]                   NAME <- NAMES[[kk]]
[13:20:16.849]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:16.849]                     next
[13:20:16.849]                   args[[name]] <- ""
[13:20:16.849]                 }
[13:20:16.849]                 NAMES <- toupper(removed)
[13:20:16.849]                 for (kk in seq_along(NAMES)) {
[13:20:16.849]                   name <- removed[[kk]]
[13:20:16.849]                   NAME <- NAMES[[kk]]
[13:20:16.849]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:16.849]                     next
[13:20:16.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:16.849]                 }
[13:20:16.849]                 if (length(args) > 0) 
[13:20:16.849]                   base::do.call(base::Sys.setenv, args = args)
[13:20:16.849]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:16.849]             }
[13:20:16.849]             else {
[13:20:16.849]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:16.849]             }
[13:20:16.849]             {
[13:20:16.849]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:16.849]                   0L) {
[13:20:16.849]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:16.849]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:16.849]                   base::options(opts)
[13:20:16.849]                 }
[13:20:16.849]                 {
[13:20:16.849]                   {
[13:20:16.849]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:16.849]                     NULL
[13:20:16.849]                   }
[13:20:16.849]                   options(future.plan = NULL)
[13:20:16.849]                   if (is.na(NA_character_)) 
[13:20:16.849]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:16.849]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:16.849]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:16.849]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:16.849]                     envir = parent.frame()) 
[13:20:16.849]                   {
[13:20:16.849]                     if (is.function(workers)) 
[13:20:16.849]                       workers <- workers()
[13:20:16.849]                     workers <- structure(as.integer(workers), 
[13:20:16.849]                       class = class(workers))
[13:20:16.849]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:16.849]                       workers >= 1)
[13:20:16.849]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:16.849]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:16.849]                     }
[13:20:16.849]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:16.849]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:16.849]                       envir = envir)
[13:20:16.849]                     if (!future$lazy) 
[13:20:16.849]                       future <- run(future)
[13:20:16.849]                     invisible(future)
[13:20:16.849]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:16.849]                 }
[13:20:16.849]             }
[13:20:16.849]         }
[13:20:16.849]     })
[13:20:16.849]     if (TRUE) {
[13:20:16.849]         base::sink(type = "output", split = FALSE)
[13:20:16.849]         if (TRUE) {
[13:20:16.849]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:16.849]         }
[13:20:16.849]         else {
[13:20:16.849]             ...future.result["stdout"] <- base::list(NULL)
[13:20:16.849]         }
[13:20:16.849]         base::close(...future.stdout)
[13:20:16.849]         ...future.stdout <- NULL
[13:20:16.849]     }
[13:20:16.849]     ...future.result$conditions <- ...future.conditions
[13:20:16.849]     ...future.result$finished <- base::Sys.time()
[13:20:16.849]     ...future.result
[13:20:16.849] }
[13:20:16.851] Poll #1 (0): usedNodes() = 2, workers = 2
[13:20:16.872] receiveMessageFromWorker() for ClusterFuture ...
[13:20:16.872] - Validating connection of MultisessionFuture
[13:20:16.872] - received message: FutureResult
[13:20:16.873] - Received FutureResult
[13:20:16.873] - Erased future from FutureRegistry
[13:20:16.873] result() for ClusterFuture ...
[13:20:16.873] - result already collected: FutureResult
[13:20:16.873] result() for ClusterFuture ... done
[13:20:16.873] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:16.874] result() for ClusterFuture ...
[13:20:16.874] - result already collected: FutureResult
[13:20:16.874] result() for ClusterFuture ... done
[13:20:16.874] result() for ClusterFuture ...
[13:20:16.874] - result already collected: FutureResult
[13:20:16.874] result() for ClusterFuture ... done
[13:20:16.875] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[13:20:16.876] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[13:20:16.876] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[13:20:16.876] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[13:20:16.877] MultisessionFuture started
[13:20:16.877] - Launch lazy future ... done
[13:20:16.877] run() for ‘MultisessionFuture’ ... done
[13:20:16.878] result() for ClusterFuture ...
[13:20:16.878] - result already collected: FutureResult
[13:20:16.878] result() for ClusterFuture ... done
[13:20:16.878] result() for ClusterFuture ...
[13:20:16.878] - result already collected: FutureResult
[13:20:16.879] result() for ClusterFuture ... done
[13:20:16.879] result() for ClusterFuture ...
[13:20:16.879] receiveMessageFromWorker() for ClusterFuture ...
[13:20:16.879] - Validating connection of MultisessionFuture
[13:20:16.908] - received message: FutureResult
[13:20:16.908] - Received FutureResult
[13:20:16.908] - Erased future from FutureRegistry
[13:20:16.908] result() for ClusterFuture ...
[13:20:16.908] - result already collected: FutureResult
[13:20:16.908] result() for ClusterFuture ... done
[13:20:16.909] signalConditions() ...
[13:20:16.909]  - include = ‘immediateCondition’
[13:20:16.909]  - exclude = 
[13:20:16.909]  - resignal = FALSE
[13:20:16.909]  - Number of conditions: 1
[13:20:16.909] signalConditions() ... done
[13:20:16.909] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:16.909] result() for ClusterFuture ... done
[13:20:16.909] result() for ClusterFuture ...
[13:20:16.909] - result already collected: FutureResult
[13:20:16.910] result() for ClusterFuture ... done
[13:20:16.910] signalConditions() ...
[13:20:16.910]  - include = ‘immediateCondition’
[13:20:16.910]  - exclude = 
[13:20:16.910]  - resignal = FALSE
[13:20:16.910]  - Number of conditions: 1
[13:20:16.910] signalConditions() ... done
[13:20:16.910] Future state: ‘finished’
[13:20:16.910] result() for ClusterFuture ...
[13:20:16.910] - result already collected: FutureResult
[13:20:16.910] result() for ClusterFuture ... done
[13:20:16.911] signalConditions() ...
[13:20:16.911]  - include = ‘condition’
[13:20:16.911]  - exclude = ‘immediateCondition’
[13:20:16.911]  - resignal = TRUE
[13:20:16.911]  - Number of conditions: 1
[13:20:16.911]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:20:16.911] signalConditions() ... done
[13:20:16.911] result() for ClusterFuture ...
[13:20:16.912] receiveMessageFromWorker() for ClusterFuture ...
[13:20:16.912] - Validating connection of MultisessionFuture
[13:20:16.929] - received message: FutureResult
[13:20:16.930] - Received FutureResult
[13:20:16.930] - Erased future from FutureRegistry
[13:20:16.930] result() for ClusterFuture ...
[13:20:16.930] - result already collected: FutureResult
[13:20:16.930] result() for ClusterFuture ... done
[13:20:16.930] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:16.930] result() for ClusterFuture ... done
[13:20:16.930] result() for ClusterFuture ...
[13:20:16.930] - result already collected: FutureResult
[13:20:16.930] result() for ClusterFuture ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[13:20:16.931] result() for ClusterFuture ...
[13:20:16.931] - result already collected: FutureResult
[13:20:16.931] result() for ClusterFuture ... done
[13:20:16.931] result() for ClusterFuture ...
[13:20:16.931] - result already collected: FutureResult
[13:20:16.931] result() for ClusterFuture ... done
[13:20:16.931] signalConditions() ...
[13:20:16.931]  - include = ‘immediateCondition’
[13:20:16.932]  - exclude = 
[13:20:16.932]  - resignal = FALSE
[13:20:16.932]  - Number of conditions: 1
[13:20:16.932] signalConditions() ... done
[13:20:16.932] Future state: ‘finished’
[13:20:16.932] result() for ClusterFuture ...
[13:20:16.932] - result already collected: FutureResult
[13:20:16.932] result() for ClusterFuture ... done
[13:20:16.932] signalConditions() ...
[13:20:16.932]  - include = ‘condition’
[13:20:16.932]  - exclude = ‘immediateCondition’
[13:20:16.932]  - resignal = TRUE
[13:20:16.933]  - Number of conditions: 1
[13:20:16.933]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:20:16.933] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[13:20:16.933] result() for ClusterFuture ...
[13:20:16.933] - result already collected: FutureResult
[13:20:16.933] result() for ClusterFuture ... done
[13:20:16.933] result() for ClusterFuture ...
[13:20:16.934] - result already collected: FutureResult
[13:20:16.934] result() for ClusterFuture ... done
[13:20:16.934] signalConditions() ...
[13:20:16.934]  - include = ‘immediateCondition’
[13:20:16.934]  - exclude = 
[13:20:16.934]  - resignal = FALSE
[13:20:16.934]  - Number of conditions: 1
[13:20:16.934] signalConditions() ... done
[13:20:16.934] Future state: ‘finished’
[13:20:16.934] result() for ClusterFuture ...
[13:20:16.934] - result already collected: FutureResult
[13:20:16.934] result() for ClusterFuture ... done
[13:20:16.935] signalConditions() ...
[13:20:16.935]  - include = ‘condition’
[13:20:16.935]  - exclude = ‘immediateCondition’
[13:20:16.935]  - resignal = TRUE
[13:20:16.935]  - Number of conditions: 1
[13:20:16.935]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:20:16.935] signalConditions() ... done
** Future evaluation with a poor-man's "progress bar"
[13:20:16.935] getGlobalsAndPackages() ...
[13:20:16.936] Searching for globals...
[13:20:16.937] - globals found: [4] ‘{’, ‘cat’, ‘for’, ‘:’
[13:20:16.938] Searching for globals ... DONE
[13:20:16.938] Resolving globals: FALSE
[13:20:16.938] 
[13:20:16.938] 
[13:20:16.938] getGlobalsAndPackages() ... DONE
[13:20:16.938] run() for ‘Future’ ...
[13:20:16.939] - state: ‘created’
[13:20:16.939] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:16.953] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:16.953] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:16.953]   - Field: ‘node’
[13:20:16.953]   - Field: ‘label’
[13:20:16.953]   - Field: ‘local’
[13:20:16.954]   - Field: ‘owner’
[13:20:16.954]   - Field: ‘envir’
[13:20:16.954]   - Field: ‘workers’
[13:20:16.954]   - Field: ‘packages’
[13:20:16.954]   - Field: ‘gc’
[13:20:16.954]   - Field: ‘conditions’
[13:20:16.954]   - Field: ‘persistent’
[13:20:16.954]   - Field: ‘expr’
[13:20:16.954]   - Field: ‘uuid’
[13:20:16.954]   - Field: ‘seed’
[13:20:16.954]   - Field: ‘version’
[13:20:16.955]   - Field: ‘result’
[13:20:16.955]   - Field: ‘asynchronous’
[13:20:16.955]   - Field: ‘calls’
[13:20:16.955]   - Field: ‘globals’
[13:20:16.955]   - Field: ‘stdout’
[13:20:16.955]   - Field: ‘earlySignal’
[13:20:16.955]   - Field: ‘lazy’
[13:20:16.955]   - Field: ‘state’
[13:20:16.955] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:16.955] - Launch lazy future ...
[13:20:16.956] Packages needed by the future expression (n = 0): <none>
[13:20:16.956] Packages needed by future strategies (n = 0): <none>
[13:20:16.956] {
[13:20:16.956]     {
[13:20:16.956]         {
[13:20:16.956]             ...future.startTime <- base::Sys.time()
[13:20:16.956]             {
[13:20:16.956]                 {
[13:20:16.956]                   {
[13:20:16.956]                     {
[13:20:16.956]                       base::local({
[13:20:16.956]                         has_future <- base::requireNamespace("future", 
[13:20:16.956]                           quietly = TRUE)
[13:20:16.956]                         if (has_future) {
[13:20:16.956]                           ns <- base::getNamespace("future")
[13:20:16.956]                           version <- ns[[".package"]][["version"]]
[13:20:16.956]                           if (is.null(version)) 
[13:20:16.956]                             version <- utils::packageVersion("future")
[13:20:16.956]                         }
[13:20:16.956]                         else {
[13:20:16.956]                           version <- NULL
[13:20:16.956]                         }
[13:20:16.956]                         if (!has_future || version < "1.8.0") {
[13:20:16.956]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:16.956]                             "", base::R.version$version.string), 
[13:20:16.956]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:16.956]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:16.956]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:16.956]                               "release", "version")], collapse = " "), 
[13:20:16.956]                             hostname = base::Sys.info()[["nodename"]])
[13:20:16.956]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:16.956]                             info)
[13:20:16.956]                           info <- base::paste(info, collapse = "; ")
[13:20:16.956]                           if (!has_future) {
[13:20:16.956]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:16.956]                               info)
[13:20:16.956]                           }
[13:20:16.956]                           else {
[13:20:16.956]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:16.956]                               info, version)
[13:20:16.956]                           }
[13:20:16.956]                           base::stop(msg)
[13:20:16.956]                         }
[13:20:16.956]                       })
[13:20:16.956]                     }
[13:20:16.956]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:16.956]                     base::options(mc.cores = 1L)
[13:20:16.956]                   }
[13:20:16.956]                   options(future.plan = NULL)
[13:20:16.956]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:16.956]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:16.956]                 }
[13:20:16.956]                 ...future.workdir <- getwd()
[13:20:16.956]             }
[13:20:16.956]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:16.956]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:16.956]         }
[13:20:16.956]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:16.956]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:16.956]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:16.956]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:16.956]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:16.956]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:16.956]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:16.956]             base::names(...future.oldOptions))
[13:20:16.956]     }
[13:20:16.956]     if (FALSE) {
[13:20:16.956]     }
[13:20:16.956]     else {
[13:20:16.956]         if (TRUE) {
[13:20:16.956]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:16.956]                 open = "w")
[13:20:16.956]         }
[13:20:16.956]         else {
[13:20:16.956]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:16.956]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:16.956]         }
[13:20:16.956]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:16.956]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:16.956]             base::sink(type = "output", split = FALSE)
[13:20:16.956]             base::close(...future.stdout)
[13:20:16.956]         }, add = TRUE)
[13:20:16.956]     }
[13:20:16.956]     ...future.frame <- base::sys.nframe()
[13:20:16.956]     ...future.conditions <- base::list()
[13:20:16.956]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:16.956]     if (FALSE) {
[13:20:16.956]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:16.956]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:16.956]     }
[13:20:16.956]     ...future.result <- base::tryCatch({
[13:20:16.956]         base::withCallingHandlers({
[13:20:16.956]             ...future.value <- base::withVisible(base::local({
[13:20:16.956]                 ...future.makeSendCondition <- local({
[13:20:16.956]                   sendCondition <- NULL
[13:20:16.956]                   function(frame = 1L) {
[13:20:16.956]                     if (is.function(sendCondition)) 
[13:20:16.956]                       return(sendCondition)
[13:20:16.956]                     ns <- getNamespace("parallel")
[13:20:16.956]                     if (exists("sendData", mode = "function", 
[13:20:16.956]                       envir = ns)) {
[13:20:16.956]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:16.956]                         envir = ns)
[13:20:16.956]                       envir <- sys.frame(frame)
[13:20:16.956]                       master <- NULL
[13:20:16.956]                       while (!identical(envir, .GlobalEnv) && 
[13:20:16.956]                         !identical(envir, emptyenv())) {
[13:20:16.956]                         if (exists("master", mode = "list", envir = envir, 
[13:20:16.956]                           inherits = FALSE)) {
[13:20:16.956]                           master <- get("master", mode = "list", 
[13:20:16.956]                             envir = envir, inherits = FALSE)
[13:20:16.956]                           if (inherits(master, c("SOCKnode", 
[13:20:16.956]                             "SOCK0node"))) {
[13:20:16.956]                             sendCondition <<- function(cond) {
[13:20:16.956]                               data <- list(type = "VALUE", value = cond, 
[13:20:16.956]                                 success = TRUE)
[13:20:16.956]                               parallel_sendData(master, data)
[13:20:16.956]                             }
[13:20:16.956]                             return(sendCondition)
[13:20:16.956]                           }
[13:20:16.956]                         }
[13:20:16.956]                         frame <- frame + 1L
[13:20:16.956]                         envir <- sys.frame(frame)
[13:20:16.956]                       }
[13:20:16.956]                     }
[13:20:16.956]                     sendCondition <<- function(cond) NULL
[13:20:16.956]                   }
[13:20:16.956]                 })
[13:20:16.956]                 withCallingHandlers({
[13:20:16.956]                   {
[13:20:16.956]                     cat("Processing: ")
[13:20:16.956]                     for (ii in 1:10) {
[13:20:16.956]                       cat(".")
[13:20:16.956]                     }
[13:20:16.956]                     cat(" [100%]\n")
[13:20:16.956]                     4
[13:20:16.956]                   }
[13:20:16.956]                 }, immediateCondition = function(cond) {
[13:20:16.956]                   sendCondition <- ...future.makeSendCondition()
[13:20:16.956]                   sendCondition(cond)
[13:20:16.956]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:16.956]                   {
[13:20:16.956]                     inherits <- base::inherits
[13:20:16.956]                     invokeRestart <- base::invokeRestart
[13:20:16.956]                     is.null <- base::is.null
[13:20:16.956]                     muffled <- FALSE
[13:20:16.956]                     if (inherits(cond, "message")) {
[13:20:16.956]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:16.956]                       if (muffled) 
[13:20:16.956]                         invokeRestart("muffleMessage")
[13:20:16.956]                     }
[13:20:16.956]                     else if (inherits(cond, "warning")) {
[13:20:16.956]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:16.956]                       if (muffled) 
[13:20:16.956]                         invokeRestart("muffleWarning")
[13:20:16.956]                     }
[13:20:16.956]                     else if (inherits(cond, "condition")) {
[13:20:16.956]                       if (!is.null(pattern)) {
[13:20:16.956]                         computeRestarts <- base::computeRestarts
[13:20:16.956]                         grepl <- base::grepl
[13:20:16.956]                         restarts <- computeRestarts(cond)
[13:20:16.956]                         for (restart in restarts) {
[13:20:16.956]                           name <- restart$name
[13:20:16.956]                           if (is.null(name)) 
[13:20:16.956]                             next
[13:20:16.956]                           if (!grepl(pattern, name)) 
[13:20:16.956]                             next
[13:20:16.956]                           invokeRestart(restart)
[13:20:16.956]                           muffled <- TRUE
[13:20:16.956]                           break
[13:20:16.956]                         }
[13:20:16.956]                       }
[13:20:16.956]                     }
[13:20:16.956]                     invisible(muffled)
[13:20:16.956]                   }
[13:20:16.956]                   muffleCondition(cond)
[13:20:16.956]                 })
[13:20:16.956]             }))
[13:20:16.956]             future::FutureResult(value = ...future.value$value, 
[13:20:16.956]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:16.956]                   ...future.rng), globalenv = if (FALSE) 
[13:20:16.956]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:16.956]                     ...future.globalenv.names))
[13:20:16.956]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:16.956]         }, condition = base::local({
[13:20:16.956]             c <- base::c
[13:20:16.956]             inherits <- base::inherits
[13:20:16.956]             invokeRestart <- base::invokeRestart
[13:20:16.956]             length <- base::length
[13:20:16.956]             list <- base::list
[13:20:16.956]             seq.int <- base::seq.int
[13:20:16.956]             signalCondition <- base::signalCondition
[13:20:16.956]             sys.calls <- base::sys.calls
[13:20:16.956]             `[[` <- base::`[[`
[13:20:16.956]             `+` <- base::`+`
[13:20:16.956]             `<<-` <- base::`<<-`
[13:20:16.956]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:16.956]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:16.956]                   3L)]
[13:20:16.956]             }
[13:20:16.956]             function(cond) {
[13:20:16.956]                 is_error <- inherits(cond, "error")
[13:20:16.956]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:16.956]                   NULL)
[13:20:16.956]                 if (is_error) {
[13:20:16.956]                   sessionInformation <- function() {
[13:20:16.956]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:16.956]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:16.956]                       search = base::search(), system = base::Sys.info())
[13:20:16.956]                   }
[13:20:16.956]                   ...future.conditions[[length(...future.conditions) + 
[13:20:16.956]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:16.956]                     cond$call), session = sessionInformation(), 
[13:20:16.956]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:16.956]                   signalCondition(cond)
[13:20:16.956]                 }
[13:20:16.956]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:16.956]                 "immediateCondition"))) {
[13:20:16.956]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:16.956]                   ...future.conditions[[length(...future.conditions) + 
[13:20:16.956]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:16.956]                   if (TRUE && !signal) {
[13:20:16.956]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:16.956]                     {
[13:20:16.956]                       inherits <- base::inherits
[13:20:16.956]                       invokeRestart <- base::invokeRestart
[13:20:16.956]                       is.null <- base::is.null
[13:20:16.956]                       muffled <- FALSE
[13:20:16.956]                       if (inherits(cond, "message")) {
[13:20:16.956]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:16.956]                         if (muffled) 
[13:20:16.956]                           invokeRestart("muffleMessage")
[13:20:16.956]                       }
[13:20:16.956]                       else if (inherits(cond, "warning")) {
[13:20:16.956]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:16.956]                         if (muffled) 
[13:20:16.956]                           invokeRestart("muffleWarning")
[13:20:16.956]                       }
[13:20:16.956]                       else if (inherits(cond, "condition")) {
[13:20:16.956]                         if (!is.null(pattern)) {
[13:20:16.956]                           computeRestarts <- base::computeRestarts
[13:20:16.956]                           grepl <- base::grepl
[13:20:16.956]                           restarts <- computeRestarts(cond)
[13:20:16.956]                           for (restart in restarts) {
[13:20:16.956]                             name <- restart$name
[13:20:16.956]                             if (is.null(name)) 
[13:20:16.956]                               next
[13:20:16.956]                             if (!grepl(pattern, name)) 
[13:20:16.956]                               next
[13:20:16.956]                             invokeRestart(restart)
[13:20:16.956]                             muffled <- TRUE
[13:20:16.956]                             break
[13:20:16.956]                           }
[13:20:16.956]                         }
[13:20:16.956]                       }
[13:20:16.956]                       invisible(muffled)
[13:20:16.956]                     }
[13:20:16.956]                     muffleCondition(cond, pattern = "^muffle")
[13:20:16.956]                   }
[13:20:16.956]                 }
[13:20:16.956]                 else {
[13:20:16.956]                   if (TRUE) {
[13:20:16.956]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:16.956]                     {
[13:20:16.956]                       inherits <- base::inherits
[13:20:16.956]                       invokeRestart <- base::invokeRestart
[13:20:16.956]                       is.null <- base::is.null
[13:20:16.956]                       muffled <- FALSE
[13:20:16.956]                       if (inherits(cond, "message")) {
[13:20:16.956]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:16.956]                         if (muffled) 
[13:20:16.956]                           invokeRestart("muffleMessage")
[13:20:16.956]                       }
[13:20:16.956]                       else if (inherits(cond, "warning")) {
[13:20:16.956]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:16.956]                         if (muffled) 
[13:20:16.956]                           invokeRestart("muffleWarning")
[13:20:16.956]                       }
[13:20:16.956]                       else if (inherits(cond, "condition")) {
[13:20:16.956]                         if (!is.null(pattern)) {
[13:20:16.956]                           computeRestarts <- base::computeRestarts
[13:20:16.956]                           grepl <- base::grepl
[13:20:16.956]                           restarts <- computeRestarts(cond)
[13:20:16.956]                           for (restart in restarts) {
[13:20:16.956]                             name <- restart$name
[13:20:16.956]                             if (is.null(name)) 
[13:20:16.956]                               next
[13:20:16.956]                             if (!grepl(pattern, name)) 
[13:20:16.956]                               next
[13:20:16.956]                             invokeRestart(restart)
[13:20:16.956]                             muffled <- TRUE
[13:20:16.956]                             break
[13:20:16.956]                           }
[13:20:16.956]                         }
[13:20:16.956]                       }
[13:20:16.956]                       invisible(muffled)
[13:20:16.956]                     }
[13:20:16.956]                     muffleCondition(cond, pattern = "^muffle")
[13:20:16.956]                   }
[13:20:16.956]                 }
[13:20:16.956]             }
[13:20:16.956]         }))
[13:20:16.956]     }, error = function(ex) {
[13:20:16.956]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:16.956]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:16.956]                 ...future.rng), started = ...future.startTime, 
[13:20:16.956]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:16.956]             version = "1.8"), class = "FutureResult")
[13:20:16.956]     }, finally = {
[13:20:16.956]         if (!identical(...future.workdir, getwd())) 
[13:20:16.956]             setwd(...future.workdir)
[13:20:16.956]         {
[13:20:16.956]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:16.956]                 ...future.oldOptions$nwarnings <- NULL
[13:20:16.956]             }
[13:20:16.956]             base::options(...future.oldOptions)
[13:20:16.956]             if (.Platform$OS.type == "windows") {
[13:20:16.956]                 old_names <- names(...future.oldEnvVars)
[13:20:16.956]                 envs <- base::Sys.getenv()
[13:20:16.956]                 names <- names(envs)
[13:20:16.956]                 common <- intersect(names, old_names)
[13:20:16.956]                 added <- setdiff(names, old_names)
[13:20:16.956]                 removed <- setdiff(old_names, names)
[13:20:16.956]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:16.956]                   envs[common]]
[13:20:16.956]                 NAMES <- toupper(changed)
[13:20:16.956]                 args <- list()
[13:20:16.956]                 for (kk in seq_along(NAMES)) {
[13:20:16.956]                   name <- changed[[kk]]
[13:20:16.956]                   NAME <- NAMES[[kk]]
[13:20:16.956]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:16.956]                     next
[13:20:16.956]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:16.956]                 }
[13:20:16.956]                 NAMES <- toupper(added)
[13:20:16.956]                 for (kk in seq_along(NAMES)) {
[13:20:16.956]                   name <- added[[kk]]
[13:20:16.956]                   NAME <- NAMES[[kk]]
[13:20:16.956]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:16.956]                     next
[13:20:16.956]                   args[[name]] <- ""
[13:20:16.956]                 }
[13:20:16.956]                 NAMES <- toupper(removed)
[13:20:16.956]                 for (kk in seq_along(NAMES)) {
[13:20:16.956]                   name <- removed[[kk]]
[13:20:16.956]                   NAME <- NAMES[[kk]]
[13:20:16.956]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:16.956]                     next
[13:20:16.956]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:16.956]                 }
[13:20:16.956]                 if (length(args) > 0) 
[13:20:16.956]                   base::do.call(base::Sys.setenv, args = args)
[13:20:16.956]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:16.956]             }
[13:20:16.956]             else {
[13:20:16.956]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:16.956]             }
[13:20:16.956]             {
[13:20:16.956]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:16.956]                   0L) {
[13:20:16.956]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:16.956]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:16.956]                   base::options(opts)
[13:20:16.956]                 }
[13:20:16.956]                 {
[13:20:16.956]                   {
[13:20:16.956]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:16.956]                     NULL
[13:20:16.956]                   }
[13:20:16.956]                   options(future.plan = NULL)
[13:20:16.956]                   if (is.na(NA_character_)) 
[13:20:16.956]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:16.956]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:16.956]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:16.956]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:16.956]                     envir = parent.frame()) 
[13:20:16.956]                   {
[13:20:16.956]                     if (is.function(workers)) 
[13:20:16.956]                       workers <- workers()
[13:20:16.956]                     workers <- structure(as.integer(workers), 
[13:20:16.956]                       class = class(workers))
[13:20:16.956]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:16.956]                       workers >= 1)
[13:20:16.956]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:16.956]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:16.956]                     }
[13:20:16.956]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:16.956]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:16.956]                       envir = envir)
[13:20:16.956]                     if (!future$lazy) 
[13:20:16.956]                       future <- run(future)
[13:20:16.956]                     invisible(future)
[13:20:16.956]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:16.956]                 }
[13:20:16.956]             }
[13:20:16.956]         }
[13:20:16.956]     })
[13:20:16.956]     if (TRUE) {
[13:20:16.956]         base::sink(type = "output", split = FALSE)
[13:20:16.956]         if (TRUE) {
[13:20:16.956]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:16.956]         }
[13:20:16.956]         else {
[13:20:16.956]             ...future.result["stdout"] <- base::list(NULL)
[13:20:16.956]         }
[13:20:16.956]         base::close(...future.stdout)
[13:20:16.956]         ...future.stdout <- NULL
[13:20:16.956]     }
[13:20:16.956]     ...future.result$conditions <- ...future.conditions
[13:20:16.956]     ...future.result$finished <- base::Sys.time()
[13:20:16.956]     ...future.result
[13:20:16.956] }
[13:20:16.959] MultisessionFuture started
[13:20:16.960] - Launch lazy future ... done
[13:20:16.960] run() for ‘MultisessionFuture’ ... done
** Collecting results
v1 = 1
v2 = 2
Warning in sprintf(...) : restarting interrupted promise evaluation
[13:20:16.960] result() for ClusterFuture ...
[13:20:16.960] - result already collected: FutureResult
[13:20:16.960] result() for ClusterFuture ... done
[13:20:16.960] result() for ClusterFuture ...
[13:20:16.961] - result already collected: FutureResult
[13:20:16.961] result() for ClusterFuture ... done
[13:20:16.961] signalConditions() ...
[13:20:16.961]  - include = ‘immediateCondition’
[13:20:16.961]  - exclude = 
[13:20:16.961]  - resignal = FALSE
[13:20:16.961]  - Number of conditions: 1
[13:20:16.961] signalConditions() ... done
[13:20:16.962] Future state: ‘finished’
[13:20:16.962] result() for ClusterFuture ...
[13:20:16.962] - result already collected: FutureResult
[13:20:16.962] result() for ClusterFuture ... done
[13:20:16.962] signalConditions() ...
[13:20:16.962]  - include = ‘condition’
[13:20:16.962]  - exclude = ‘immediateCondition’
[13:20:16.962]  - resignal = TRUE
[13:20:16.962]  - Number of conditions: 1
[13:20:16.963]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:20:16.963] signalConditions() ... done
v3: <simpleError> (as expect)
[13:20:16.963] result() for ClusterFuture ...
[13:20:16.963] receiveMessageFromWorker() for ClusterFuture ...
[13:20:16.963] - Validating connection of MultisessionFuture
[13:20:17.006] - received message: FutureResult
[13:20:17.006] - Received FutureResult
[13:20:17.006] - Erased future from FutureRegistry
[13:20:17.006] result() for ClusterFuture ...
[13:20:17.007] - result already collected: FutureResult
[13:20:17.007] result() for ClusterFuture ... done
[13:20:17.007] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:17.007] result() for ClusterFuture ... done
[13:20:17.007] result() for ClusterFuture ...
[13:20:17.007] - result already collected: FutureResult
[13:20:17.007] result() for ClusterFuture ... done
Processing: .......... [100%]
v4 = 4
** Left-to-right and right-to-left future assignments
[13:20:17.008] getGlobalsAndPackages() ...
[13:20:17.008] Searching for globals...
[13:20:17.008] 
[13:20:17.008] Searching for globals ... DONE
[13:20:17.008] - globals: [0] <none>
[13:20:17.008] getGlobalsAndPackages() ... DONE
[13:20:17.009] run() for ‘Future’ ...
[13:20:17.009] - state: ‘created’
[13:20:17.009] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:17.023] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:17.024] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:17.024]   - Field: ‘node’
[13:20:17.024]   - Field: ‘label’
[13:20:17.024]   - Field: ‘local’
[13:20:17.024]   - Field: ‘owner’
[13:20:17.024]   - Field: ‘envir’
[13:20:17.024]   - Field: ‘workers’
[13:20:17.024]   - Field: ‘packages’
[13:20:17.024]   - Field: ‘gc’
[13:20:17.025]   - Field: ‘conditions’
[13:20:17.025]   - Field: ‘persistent’
[13:20:17.025]   - Field: ‘expr’
[13:20:17.025]   - Field: ‘uuid’
[13:20:17.025]   - Field: ‘seed’
[13:20:17.025]   - Field: ‘version’
[13:20:17.025]   - Field: ‘result’
[13:20:17.025]   - Field: ‘asynchronous’
[13:20:17.025]   - Field: ‘calls’
[13:20:17.025]   - Field: ‘globals’
[13:20:17.025]   - Field: ‘stdout’
[13:20:17.026]   - Field: ‘earlySignal’
[13:20:17.026]   - Field: ‘lazy’
[13:20:17.026]   - Field: ‘state’
[13:20:17.026] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:17.026] - Launch lazy future ...
[13:20:17.026] Packages needed by the future expression (n = 0): <none>
[13:20:17.026] Packages needed by future strategies (n = 0): <none>
[13:20:17.032] {
[13:20:17.032]     {
[13:20:17.032]         {
[13:20:17.032]             ...future.startTime <- base::Sys.time()
[13:20:17.032]             {
[13:20:17.032]                 {
[13:20:17.032]                   {
[13:20:17.032]                     {
[13:20:17.032]                       base::local({
[13:20:17.032]                         has_future <- base::requireNamespace("future", 
[13:20:17.032]                           quietly = TRUE)
[13:20:17.032]                         if (has_future) {
[13:20:17.032]                           ns <- base::getNamespace("future")
[13:20:17.032]                           version <- ns[[".package"]][["version"]]
[13:20:17.032]                           if (is.null(version)) 
[13:20:17.032]                             version <- utils::packageVersion("future")
[13:20:17.032]                         }
[13:20:17.032]                         else {
[13:20:17.032]                           version <- NULL
[13:20:17.032]                         }
[13:20:17.032]                         if (!has_future || version < "1.8.0") {
[13:20:17.032]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:17.032]                             "", base::R.version$version.string), 
[13:20:17.032]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:17.032]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:17.032]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:17.032]                               "release", "version")], collapse = " "), 
[13:20:17.032]                             hostname = base::Sys.info()[["nodename"]])
[13:20:17.032]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:17.032]                             info)
[13:20:17.032]                           info <- base::paste(info, collapse = "; ")
[13:20:17.032]                           if (!has_future) {
[13:20:17.032]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:17.032]                               info)
[13:20:17.032]                           }
[13:20:17.032]                           else {
[13:20:17.032]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:17.032]                               info, version)
[13:20:17.032]                           }
[13:20:17.032]                           base::stop(msg)
[13:20:17.032]                         }
[13:20:17.032]                       })
[13:20:17.032]                     }
[13:20:17.032]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:17.032]                     base::options(mc.cores = 1L)
[13:20:17.032]                   }
[13:20:17.032]                   options(future.plan = NULL)
[13:20:17.032]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:17.032]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:17.032]                 }
[13:20:17.032]                 ...future.workdir <- getwd()
[13:20:17.032]             }
[13:20:17.032]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:17.032]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:17.032]         }
[13:20:17.032]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:17.032]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:17.032]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:17.032]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:17.032]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:17.032]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:17.032]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:17.032]             base::names(...future.oldOptions))
[13:20:17.032]     }
[13:20:17.032]     if (FALSE) {
[13:20:17.032]     }
[13:20:17.032]     else {
[13:20:17.032]         if (TRUE) {
[13:20:17.032]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:17.032]                 open = "w")
[13:20:17.032]         }
[13:20:17.032]         else {
[13:20:17.032]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:17.032]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:17.032]         }
[13:20:17.032]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:17.032]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:17.032]             base::sink(type = "output", split = FALSE)
[13:20:17.032]             base::close(...future.stdout)
[13:20:17.032]         }, add = TRUE)
[13:20:17.032]     }
[13:20:17.032]     ...future.frame <- base::sys.nframe()
[13:20:17.032]     ...future.conditions <- base::list()
[13:20:17.032]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:17.032]     if (FALSE) {
[13:20:17.032]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:17.032]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:17.032]     }
[13:20:17.032]     ...future.result <- base::tryCatch({
[13:20:17.032]         base::withCallingHandlers({
[13:20:17.032]             ...future.value <- base::withVisible(base::local({
[13:20:17.032]                 ...future.makeSendCondition <- local({
[13:20:17.032]                   sendCondition <- NULL
[13:20:17.032]                   function(frame = 1L) {
[13:20:17.032]                     if (is.function(sendCondition)) 
[13:20:17.032]                       return(sendCondition)
[13:20:17.032]                     ns <- getNamespace("parallel")
[13:20:17.032]                     if (exists("sendData", mode = "function", 
[13:20:17.032]                       envir = ns)) {
[13:20:17.032]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:17.032]                         envir = ns)
[13:20:17.032]                       envir <- sys.frame(frame)
[13:20:17.032]                       master <- NULL
[13:20:17.032]                       while (!identical(envir, .GlobalEnv) && 
[13:20:17.032]                         !identical(envir, emptyenv())) {
[13:20:17.032]                         if (exists("master", mode = "list", envir = envir, 
[13:20:17.032]                           inherits = FALSE)) {
[13:20:17.032]                           master <- get("master", mode = "list", 
[13:20:17.032]                             envir = envir, inherits = FALSE)
[13:20:17.032]                           if (inherits(master, c("SOCKnode", 
[13:20:17.032]                             "SOCK0node"))) {
[13:20:17.032]                             sendCondition <<- function(cond) {
[13:20:17.032]                               data <- list(type = "VALUE", value = cond, 
[13:20:17.032]                                 success = TRUE)
[13:20:17.032]                               parallel_sendData(master, data)
[13:20:17.032]                             }
[13:20:17.032]                             return(sendCondition)
[13:20:17.032]                           }
[13:20:17.032]                         }
[13:20:17.032]                         frame <- frame + 1L
[13:20:17.032]                         envir <- sys.frame(frame)
[13:20:17.032]                       }
[13:20:17.032]                     }
[13:20:17.032]                     sendCondition <<- function(cond) NULL
[13:20:17.032]                   }
[13:20:17.032]                 })
[13:20:17.032]                 withCallingHandlers({
[13:20:17.032]                   1
[13:20:17.032]                 }, immediateCondition = function(cond) {
[13:20:17.032]                   sendCondition <- ...future.makeSendCondition()
[13:20:17.032]                   sendCondition(cond)
[13:20:17.032]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:17.032]                   {
[13:20:17.032]                     inherits <- base::inherits
[13:20:17.032]                     invokeRestart <- base::invokeRestart
[13:20:17.032]                     is.null <- base::is.null
[13:20:17.032]                     muffled <- FALSE
[13:20:17.032]                     if (inherits(cond, "message")) {
[13:20:17.032]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:17.032]                       if (muffled) 
[13:20:17.032]                         invokeRestart("muffleMessage")
[13:20:17.032]                     }
[13:20:17.032]                     else if (inherits(cond, "warning")) {
[13:20:17.032]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:17.032]                       if (muffled) 
[13:20:17.032]                         invokeRestart("muffleWarning")
[13:20:17.032]                     }
[13:20:17.032]                     else if (inherits(cond, "condition")) {
[13:20:17.032]                       if (!is.null(pattern)) {
[13:20:17.032]                         computeRestarts <- base::computeRestarts
[13:20:17.032]                         grepl <- base::grepl
[13:20:17.032]                         restarts <- computeRestarts(cond)
[13:20:17.032]                         for (restart in restarts) {
[13:20:17.032]                           name <- restart$name
[13:20:17.032]                           if (is.null(name)) 
[13:20:17.032]                             next
[13:20:17.032]                           if (!grepl(pattern, name)) 
[13:20:17.032]                             next
[13:20:17.032]                           invokeRestart(restart)
[13:20:17.032]                           muffled <- TRUE
[13:20:17.032]                           break
[13:20:17.032]                         }
[13:20:17.032]                       }
[13:20:17.032]                     }
[13:20:17.032]                     invisible(muffled)
[13:20:17.032]                   }
[13:20:17.032]                   muffleCondition(cond)
[13:20:17.032]                 })
[13:20:17.032]             }))
[13:20:17.032]             future::FutureResult(value = ...future.value$value, 
[13:20:17.032]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:17.032]                   ...future.rng), globalenv = if (FALSE) 
[13:20:17.032]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:17.032]                     ...future.globalenv.names))
[13:20:17.032]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:17.032]         }, condition = base::local({
[13:20:17.032]             c <- base::c
[13:20:17.032]             inherits <- base::inherits
[13:20:17.032]             invokeRestart <- base::invokeRestart
[13:20:17.032]             length <- base::length
[13:20:17.032]             list <- base::list
[13:20:17.032]             seq.int <- base::seq.int
[13:20:17.032]             signalCondition <- base::signalCondition
[13:20:17.032]             sys.calls <- base::sys.calls
[13:20:17.032]             `[[` <- base::`[[`
[13:20:17.032]             `+` <- base::`+`
[13:20:17.032]             `<<-` <- base::`<<-`
[13:20:17.032]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:17.032]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:17.032]                   3L)]
[13:20:17.032]             }
[13:20:17.032]             function(cond) {
[13:20:17.032]                 is_error <- inherits(cond, "error")
[13:20:17.032]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:17.032]                   NULL)
[13:20:17.032]                 if (is_error) {
[13:20:17.032]                   sessionInformation <- function() {
[13:20:17.032]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:17.032]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:17.032]                       search = base::search(), system = base::Sys.info())
[13:20:17.032]                   }
[13:20:17.032]                   ...future.conditions[[length(...future.conditions) + 
[13:20:17.032]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:17.032]                     cond$call), session = sessionInformation(), 
[13:20:17.032]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:17.032]                   signalCondition(cond)
[13:20:17.032]                 }
[13:20:17.032]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:17.032]                 "immediateCondition"))) {
[13:20:17.032]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:17.032]                   ...future.conditions[[length(...future.conditions) + 
[13:20:17.032]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:17.032]                   if (TRUE && !signal) {
[13:20:17.032]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:17.032]                     {
[13:20:17.032]                       inherits <- base::inherits
[13:20:17.032]                       invokeRestart <- base::invokeRestart
[13:20:17.032]                       is.null <- base::is.null
[13:20:17.032]                       muffled <- FALSE
[13:20:17.032]                       if (inherits(cond, "message")) {
[13:20:17.032]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:17.032]                         if (muffled) 
[13:20:17.032]                           invokeRestart("muffleMessage")
[13:20:17.032]                       }
[13:20:17.032]                       else if (inherits(cond, "warning")) {
[13:20:17.032]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:17.032]                         if (muffled) 
[13:20:17.032]                           invokeRestart("muffleWarning")
[13:20:17.032]                       }
[13:20:17.032]                       else if (inherits(cond, "condition")) {
[13:20:17.032]                         if (!is.null(pattern)) {
[13:20:17.032]                           computeRestarts <- base::computeRestarts
[13:20:17.032]                           grepl <- base::grepl
[13:20:17.032]                           restarts <- computeRestarts(cond)
[13:20:17.032]                           for (restart in restarts) {
[13:20:17.032]                             name <- restart$name
[13:20:17.032]                             if (is.null(name)) 
[13:20:17.032]                               next
[13:20:17.032]                             if (!grepl(pattern, name)) 
[13:20:17.032]                               next
[13:20:17.032]                             invokeRestart(restart)
[13:20:17.032]                             muffled <- TRUE
[13:20:17.032]                             break
[13:20:17.032]                           }
[13:20:17.032]                         }
[13:20:17.032]                       }
[13:20:17.032]                       invisible(muffled)
[13:20:17.032]                     }
[13:20:17.032]                     muffleCondition(cond, pattern = "^muffle")
[13:20:17.032]                   }
[13:20:17.032]                 }
[13:20:17.032]                 else {
[13:20:17.032]                   if (TRUE) {
[13:20:17.032]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:17.032]                     {
[13:20:17.032]                       inherits <- base::inherits
[13:20:17.032]                       invokeRestart <- base::invokeRestart
[13:20:17.032]                       is.null <- base::is.null
[13:20:17.032]                       muffled <- FALSE
[13:20:17.032]                       if (inherits(cond, "message")) {
[13:20:17.032]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:17.032]                         if (muffled) 
[13:20:17.032]                           invokeRestart("muffleMessage")
[13:20:17.032]                       }
[13:20:17.032]                       else if (inherits(cond, "warning")) {
[13:20:17.032]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:17.032]                         if (muffled) 
[13:20:17.032]                           invokeRestart("muffleWarning")
[13:20:17.032]                       }
[13:20:17.032]                       else if (inherits(cond, "condition")) {
[13:20:17.032]                         if (!is.null(pattern)) {
[13:20:17.032]                           computeRestarts <- base::computeRestarts
[13:20:17.032]                           grepl <- base::grepl
[13:20:17.032]                           restarts <- computeRestarts(cond)
[13:20:17.032]                           for (restart in restarts) {
[13:20:17.032]                             name <- restart$name
[13:20:17.032]                             if (is.null(name)) 
[13:20:17.032]                               next
[13:20:17.032]                             if (!grepl(pattern, name)) 
[13:20:17.032]                               next
[13:20:17.032]                             invokeRestart(restart)
[13:20:17.032]                             muffled <- TRUE
[13:20:17.032]                             break
[13:20:17.032]                           }
[13:20:17.032]                         }
[13:20:17.032]                       }
[13:20:17.032]                       invisible(muffled)
[13:20:17.032]                     }
[13:20:17.032]                     muffleCondition(cond, pattern = "^muffle")
[13:20:17.032]                   }
[13:20:17.032]                 }
[13:20:17.032]             }
[13:20:17.032]         }))
[13:20:17.032]     }, error = function(ex) {
[13:20:17.032]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:17.032]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:17.032]                 ...future.rng), started = ...future.startTime, 
[13:20:17.032]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:17.032]             version = "1.8"), class = "FutureResult")
[13:20:17.032]     }, finally = {
[13:20:17.032]         if (!identical(...future.workdir, getwd())) 
[13:20:17.032]             setwd(...future.workdir)
[13:20:17.032]         {
[13:20:17.032]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:17.032]                 ...future.oldOptions$nwarnings <- NULL
[13:20:17.032]             }
[13:20:17.032]             base::options(...future.oldOptions)
[13:20:17.032]             if (.Platform$OS.type == "windows") {
[13:20:17.032]                 old_names <- names(...future.oldEnvVars)
[13:20:17.032]                 envs <- base::Sys.getenv()
[13:20:17.032]                 names <- names(envs)
[13:20:17.032]                 common <- intersect(names, old_names)
[13:20:17.032]                 added <- setdiff(names, old_names)
[13:20:17.032]                 removed <- setdiff(old_names, names)
[13:20:17.032]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:17.032]                   envs[common]]
[13:20:17.032]                 NAMES <- toupper(changed)
[13:20:17.032]                 args <- list()
[13:20:17.032]                 for (kk in seq_along(NAMES)) {
[13:20:17.032]                   name <- changed[[kk]]
[13:20:17.032]                   NAME <- NAMES[[kk]]
[13:20:17.032]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:17.032]                     next
[13:20:17.032]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:17.032]                 }
[13:20:17.032]                 NAMES <- toupper(added)
[13:20:17.032]                 for (kk in seq_along(NAMES)) {
[13:20:17.032]                   name <- added[[kk]]
[13:20:17.032]                   NAME <- NAMES[[kk]]
[13:20:17.032]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:17.032]                     next
[13:20:17.032]                   args[[name]] <- ""
[13:20:17.032]                 }
[13:20:17.032]                 NAMES <- toupper(removed)
[13:20:17.032]                 for (kk in seq_along(NAMES)) {
[13:20:17.032]                   name <- removed[[kk]]
[13:20:17.032]                   NAME <- NAMES[[kk]]
[13:20:17.032]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:17.032]                     next
[13:20:17.032]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:17.032]                 }
[13:20:17.032]                 if (length(args) > 0) 
[13:20:17.032]                   base::do.call(base::Sys.setenv, args = args)
[13:20:17.032]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:17.032]             }
[13:20:17.032]             else {
[13:20:17.032]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:17.032]             }
[13:20:17.032]             {
[13:20:17.032]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:17.032]                   0L) {
[13:20:17.032]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:17.032]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:17.032]                   base::options(opts)
[13:20:17.032]                 }
[13:20:17.032]                 {
[13:20:17.032]                   {
[13:20:17.032]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:17.032]                     NULL
[13:20:17.032]                   }
[13:20:17.032]                   options(future.plan = NULL)
[13:20:17.032]                   if (is.na(NA_character_)) 
[13:20:17.032]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:17.032]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:17.032]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:17.032]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:17.032]                     envir = parent.frame()) 
[13:20:17.032]                   {
[13:20:17.032]                     if (is.function(workers)) 
[13:20:17.032]                       workers <- workers()
[13:20:17.032]                     workers <- structure(as.integer(workers), 
[13:20:17.032]                       class = class(workers))
[13:20:17.032]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:17.032]                       workers >= 1)
[13:20:17.032]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:17.032]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:17.032]                     }
[13:20:17.032]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:17.032]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:17.032]                       envir = envir)
[13:20:17.032]                     if (!future$lazy) 
[13:20:17.032]                       future <- run(future)
[13:20:17.032]                     invisible(future)
[13:20:17.032]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:17.032]                 }
[13:20:17.032]             }
[13:20:17.032]         }
[13:20:17.032]     })
[13:20:17.032]     if (TRUE) {
[13:20:17.032]         base::sink(type = "output", split = FALSE)
[13:20:17.032]         if (TRUE) {
[13:20:17.032]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:17.032]         }
[13:20:17.032]         else {
[13:20:17.032]             ...future.result["stdout"] <- base::list(NULL)
[13:20:17.032]         }
[13:20:17.032]         base::close(...future.stdout)
[13:20:17.032]         ...future.stdout <- NULL
[13:20:17.032]     }
[13:20:17.032]     ...future.result$conditions <- ...future.conditions
[13:20:17.032]     ...future.result$finished <- base::Sys.time()
[13:20:17.032]     ...future.result
[13:20:17.032] }
[13:20:17.035] MultisessionFuture started
[13:20:17.035] - Launch lazy future ... done
[13:20:17.035] run() for ‘MultisessionFuture’ ... done
[13:20:17.035] result() for ClusterFuture ...
[13:20:17.035] receiveMessageFromWorker() for ClusterFuture ...
[13:20:17.036] - Validating connection of MultisessionFuture
[13:20:17.082] - received message: FutureResult
[13:20:17.082] - Received FutureResult
[13:20:17.083] - Erased future from FutureRegistry
[13:20:17.083] result() for ClusterFuture ...
[13:20:17.083] - result already collected: FutureResult
[13:20:17.083] result() for ClusterFuture ... done
[13:20:17.083] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:17.083] result() for ClusterFuture ... done
[13:20:17.083] result() for ClusterFuture ...
[13:20:17.083] - result already collected: FutureResult
[13:20:17.083] result() for ClusterFuture ... done
c = 1
[13:20:17.084] getGlobalsAndPackages() ...
[13:20:17.084] Searching for globals...
[13:20:17.084] 
[13:20:17.084] Searching for globals ... DONE
[13:20:17.084] - globals: [0] <none>
[13:20:17.085] getGlobalsAndPackages() ... DONE
[13:20:17.085] run() for ‘Future’ ...
[13:20:17.085] - state: ‘created’
[13:20:17.085] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:17.099] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:17.100] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:17.100]   - Field: ‘node’
[13:20:17.100]   - Field: ‘label’
[13:20:17.100]   - Field: ‘local’
[13:20:17.100]   - Field: ‘owner’
[13:20:17.100]   - Field: ‘envir’
[13:20:17.100]   - Field: ‘workers’
[13:20:17.100]   - Field: ‘packages’
[13:20:17.100]   - Field: ‘gc’
[13:20:17.100]   - Field: ‘conditions’
[13:20:17.101]   - Field: ‘persistent’
[13:20:17.101]   - Field: ‘expr’
[13:20:17.101]   - Field: ‘uuid’
[13:20:17.101]   - Field: ‘seed’
[13:20:17.101]   - Field: ‘version’
[13:20:17.101]   - Field: ‘result’
[13:20:17.101]   - Field: ‘asynchronous’
[13:20:17.101]   - Field: ‘calls’
[13:20:17.101]   - Field: ‘globals’
[13:20:17.101]   - Field: ‘stdout’
[13:20:17.101]   - Field: ‘earlySignal’
[13:20:17.102]   - Field: ‘lazy’
[13:20:17.102]   - Field: ‘state’
[13:20:17.102] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:17.102] - Launch lazy future ...
[13:20:17.102] Packages needed by the future expression (n = 0): <none>
[13:20:17.102] Packages needed by future strategies (n = 0): <none>
[13:20:17.103] {
[13:20:17.103]     {
[13:20:17.103]         {
[13:20:17.103]             ...future.startTime <- base::Sys.time()
[13:20:17.103]             {
[13:20:17.103]                 {
[13:20:17.103]                   {
[13:20:17.103]                     {
[13:20:17.103]                       base::local({
[13:20:17.103]                         has_future <- base::requireNamespace("future", 
[13:20:17.103]                           quietly = TRUE)
[13:20:17.103]                         if (has_future) {
[13:20:17.103]                           ns <- base::getNamespace("future")
[13:20:17.103]                           version <- ns[[".package"]][["version"]]
[13:20:17.103]                           if (is.null(version)) 
[13:20:17.103]                             version <- utils::packageVersion("future")
[13:20:17.103]                         }
[13:20:17.103]                         else {
[13:20:17.103]                           version <- NULL
[13:20:17.103]                         }
[13:20:17.103]                         if (!has_future || version < "1.8.0") {
[13:20:17.103]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:17.103]                             "", base::R.version$version.string), 
[13:20:17.103]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:17.103]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:17.103]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:17.103]                               "release", "version")], collapse = " "), 
[13:20:17.103]                             hostname = base::Sys.info()[["nodename"]])
[13:20:17.103]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:17.103]                             info)
[13:20:17.103]                           info <- base::paste(info, collapse = "; ")
[13:20:17.103]                           if (!has_future) {
[13:20:17.103]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:17.103]                               info)
[13:20:17.103]                           }
[13:20:17.103]                           else {
[13:20:17.103]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:17.103]                               info, version)
[13:20:17.103]                           }
[13:20:17.103]                           base::stop(msg)
[13:20:17.103]                         }
[13:20:17.103]                       })
[13:20:17.103]                     }
[13:20:17.103]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:17.103]                     base::options(mc.cores = 1L)
[13:20:17.103]                   }
[13:20:17.103]                   options(future.plan = NULL)
[13:20:17.103]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:17.103]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:17.103]                 }
[13:20:17.103]                 ...future.workdir <- getwd()
[13:20:17.103]             }
[13:20:17.103]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:17.103]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:17.103]         }
[13:20:17.103]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:17.103]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:17.103]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:17.103]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:17.103]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:17.103]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:17.103]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:17.103]             base::names(...future.oldOptions))
[13:20:17.103]     }
[13:20:17.103]     if (FALSE) {
[13:20:17.103]     }
[13:20:17.103]     else {
[13:20:17.103]         if (TRUE) {
[13:20:17.103]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:17.103]                 open = "w")
[13:20:17.103]         }
[13:20:17.103]         else {
[13:20:17.103]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:17.103]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:17.103]         }
[13:20:17.103]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:17.103]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:17.103]             base::sink(type = "output", split = FALSE)
[13:20:17.103]             base::close(...future.stdout)
[13:20:17.103]         }, add = TRUE)
[13:20:17.103]     }
[13:20:17.103]     ...future.frame <- base::sys.nframe()
[13:20:17.103]     ...future.conditions <- base::list()
[13:20:17.103]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:17.103]     if (FALSE) {
[13:20:17.103]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:17.103]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:17.103]     }
[13:20:17.103]     ...future.result <- base::tryCatch({
[13:20:17.103]         base::withCallingHandlers({
[13:20:17.103]             ...future.value <- base::withVisible(base::local({
[13:20:17.103]                 ...future.makeSendCondition <- local({
[13:20:17.103]                   sendCondition <- NULL
[13:20:17.103]                   function(frame = 1L) {
[13:20:17.103]                     if (is.function(sendCondition)) 
[13:20:17.103]                       return(sendCondition)
[13:20:17.103]                     ns <- getNamespace("parallel")
[13:20:17.103]                     if (exists("sendData", mode = "function", 
[13:20:17.103]                       envir = ns)) {
[13:20:17.103]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:17.103]                         envir = ns)
[13:20:17.103]                       envir <- sys.frame(frame)
[13:20:17.103]                       master <- NULL
[13:20:17.103]                       while (!identical(envir, .GlobalEnv) && 
[13:20:17.103]                         !identical(envir, emptyenv())) {
[13:20:17.103]                         if (exists("master", mode = "list", envir = envir, 
[13:20:17.103]                           inherits = FALSE)) {
[13:20:17.103]                           master <- get("master", mode = "list", 
[13:20:17.103]                             envir = envir, inherits = FALSE)
[13:20:17.103]                           if (inherits(master, c("SOCKnode", 
[13:20:17.103]                             "SOCK0node"))) {
[13:20:17.103]                             sendCondition <<- function(cond) {
[13:20:17.103]                               data <- list(type = "VALUE", value = cond, 
[13:20:17.103]                                 success = TRUE)
[13:20:17.103]                               parallel_sendData(master, data)
[13:20:17.103]                             }
[13:20:17.103]                             return(sendCondition)
[13:20:17.103]                           }
[13:20:17.103]                         }
[13:20:17.103]                         frame <- frame + 1L
[13:20:17.103]                         envir <- sys.frame(frame)
[13:20:17.103]                       }
[13:20:17.103]                     }
[13:20:17.103]                     sendCondition <<- function(cond) NULL
[13:20:17.103]                   }
[13:20:17.103]                 })
[13:20:17.103]                 withCallingHandlers({
[13:20:17.103]                   1
[13:20:17.103]                 }, immediateCondition = function(cond) {
[13:20:17.103]                   sendCondition <- ...future.makeSendCondition()
[13:20:17.103]                   sendCondition(cond)
[13:20:17.103]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:17.103]                   {
[13:20:17.103]                     inherits <- base::inherits
[13:20:17.103]                     invokeRestart <- base::invokeRestart
[13:20:17.103]                     is.null <- base::is.null
[13:20:17.103]                     muffled <- FALSE
[13:20:17.103]                     if (inherits(cond, "message")) {
[13:20:17.103]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:17.103]                       if (muffled) 
[13:20:17.103]                         invokeRestart("muffleMessage")
[13:20:17.103]                     }
[13:20:17.103]                     else if (inherits(cond, "warning")) {
[13:20:17.103]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:17.103]                       if (muffled) 
[13:20:17.103]                         invokeRestart("muffleWarning")
[13:20:17.103]                     }
[13:20:17.103]                     else if (inherits(cond, "condition")) {
[13:20:17.103]                       if (!is.null(pattern)) {
[13:20:17.103]                         computeRestarts <- base::computeRestarts
[13:20:17.103]                         grepl <- base::grepl
[13:20:17.103]                         restarts <- computeRestarts(cond)
[13:20:17.103]                         for (restart in restarts) {
[13:20:17.103]                           name <- restart$name
[13:20:17.103]                           if (is.null(name)) 
[13:20:17.103]                             next
[13:20:17.103]                           if (!grepl(pattern, name)) 
[13:20:17.103]                             next
[13:20:17.103]                           invokeRestart(restart)
[13:20:17.103]                           muffled <- TRUE
[13:20:17.103]                           break
[13:20:17.103]                         }
[13:20:17.103]                       }
[13:20:17.103]                     }
[13:20:17.103]                     invisible(muffled)
[13:20:17.103]                   }
[13:20:17.103]                   muffleCondition(cond)
[13:20:17.103]                 })
[13:20:17.103]             }))
[13:20:17.103]             future::FutureResult(value = ...future.value$value, 
[13:20:17.103]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:17.103]                   ...future.rng), globalenv = if (FALSE) 
[13:20:17.103]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:17.103]                     ...future.globalenv.names))
[13:20:17.103]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:17.103]         }, condition = base::local({
[13:20:17.103]             c <- base::c
[13:20:17.103]             inherits <- base::inherits
[13:20:17.103]             invokeRestart <- base::invokeRestart
[13:20:17.103]             length <- base::length
[13:20:17.103]             list <- base::list
[13:20:17.103]             seq.int <- base::seq.int
[13:20:17.103]             signalCondition <- base::signalCondition
[13:20:17.103]             sys.calls <- base::sys.calls
[13:20:17.103]             `[[` <- base::`[[`
[13:20:17.103]             `+` <- base::`+`
[13:20:17.103]             `<<-` <- base::`<<-`
[13:20:17.103]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:17.103]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:17.103]                   3L)]
[13:20:17.103]             }
[13:20:17.103]             function(cond) {
[13:20:17.103]                 is_error <- inherits(cond, "error")
[13:20:17.103]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:17.103]                   NULL)
[13:20:17.103]                 if (is_error) {
[13:20:17.103]                   sessionInformation <- function() {
[13:20:17.103]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:17.103]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:17.103]                       search = base::search(), system = base::Sys.info())
[13:20:17.103]                   }
[13:20:17.103]                   ...future.conditions[[length(...future.conditions) + 
[13:20:17.103]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:17.103]                     cond$call), session = sessionInformation(), 
[13:20:17.103]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:17.103]                   signalCondition(cond)
[13:20:17.103]                 }
[13:20:17.103]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:17.103]                 "immediateCondition"))) {
[13:20:17.103]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:17.103]                   ...future.conditions[[length(...future.conditions) + 
[13:20:17.103]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:17.103]                   if (TRUE && !signal) {
[13:20:17.103]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:17.103]                     {
[13:20:17.103]                       inherits <- base::inherits
[13:20:17.103]                       invokeRestart <- base::invokeRestart
[13:20:17.103]                       is.null <- base::is.null
[13:20:17.103]                       muffled <- FALSE
[13:20:17.103]                       if (inherits(cond, "message")) {
[13:20:17.103]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:17.103]                         if (muffled) 
[13:20:17.103]                           invokeRestart("muffleMessage")
[13:20:17.103]                       }
[13:20:17.103]                       else if (inherits(cond, "warning")) {
[13:20:17.103]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:17.103]                         if (muffled) 
[13:20:17.103]                           invokeRestart("muffleWarning")
[13:20:17.103]                       }
[13:20:17.103]                       else if (inherits(cond, "condition")) {
[13:20:17.103]                         if (!is.null(pattern)) {
[13:20:17.103]                           computeRestarts <- base::computeRestarts
[13:20:17.103]                           grepl <- base::grepl
[13:20:17.103]                           restarts <- computeRestarts(cond)
[13:20:17.103]                           for (restart in restarts) {
[13:20:17.103]                             name <- restart$name
[13:20:17.103]                             if (is.null(name)) 
[13:20:17.103]                               next
[13:20:17.103]                             if (!grepl(pattern, name)) 
[13:20:17.103]                               next
[13:20:17.103]                             invokeRestart(restart)
[13:20:17.103]                             muffled <- TRUE
[13:20:17.103]                             break
[13:20:17.103]                           }
[13:20:17.103]                         }
[13:20:17.103]                       }
[13:20:17.103]                       invisible(muffled)
[13:20:17.103]                     }
[13:20:17.103]                     muffleCondition(cond, pattern = "^muffle")
[13:20:17.103]                   }
[13:20:17.103]                 }
[13:20:17.103]                 else {
[13:20:17.103]                   if (TRUE) {
[13:20:17.103]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:17.103]                     {
[13:20:17.103]                       inherits <- base::inherits
[13:20:17.103]                       invokeRestart <- base::invokeRestart
[13:20:17.103]                       is.null <- base::is.null
[13:20:17.103]                       muffled <- FALSE
[13:20:17.103]                       if (inherits(cond, "message")) {
[13:20:17.103]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:17.103]                         if (muffled) 
[13:20:17.103]                           invokeRestart("muffleMessage")
[13:20:17.103]                       }
[13:20:17.103]                       else if (inherits(cond, "warning")) {
[13:20:17.103]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:17.103]                         if (muffled) 
[13:20:17.103]                           invokeRestart("muffleWarning")
[13:20:17.103]                       }
[13:20:17.103]                       else if (inherits(cond, "condition")) {
[13:20:17.103]                         if (!is.null(pattern)) {
[13:20:17.103]                           computeRestarts <- base::computeRestarts
[13:20:17.103]                           grepl <- base::grepl
[13:20:17.103]                           restarts <- computeRestarts(cond)
[13:20:17.103]                           for (restart in restarts) {
[13:20:17.103]                             name <- restart$name
[13:20:17.103]                             if (is.null(name)) 
[13:20:17.103]                               next
[13:20:17.103]                             if (!grepl(pattern, name)) 
[13:20:17.103]                               next
[13:20:17.103]                             invokeRestart(restart)
[13:20:17.103]                             muffled <- TRUE
[13:20:17.103]                             break
[13:20:17.103]                           }
[13:20:17.103]                         }
[13:20:17.103]                       }
[13:20:17.103]                       invisible(muffled)
[13:20:17.103]                     }
[13:20:17.103]                     muffleCondition(cond, pattern = "^muffle")
[13:20:17.103]                   }
[13:20:17.103]                 }
[13:20:17.103]             }
[13:20:17.103]         }))
[13:20:17.103]     }, error = function(ex) {
[13:20:17.103]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:17.103]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:17.103]                 ...future.rng), started = ...future.startTime, 
[13:20:17.103]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:17.103]             version = "1.8"), class = "FutureResult")
[13:20:17.103]     }, finally = {
[13:20:17.103]         if (!identical(...future.workdir, getwd())) 
[13:20:17.103]             setwd(...future.workdir)
[13:20:17.103]         {
[13:20:17.103]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:17.103]                 ...future.oldOptions$nwarnings <- NULL
[13:20:17.103]             }
[13:20:17.103]             base::options(...future.oldOptions)
[13:20:17.103]             if (.Platform$OS.type == "windows") {
[13:20:17.103]                 old_names <- names(...future.oldEnvVars)
[13:20:17.103]                 envs <- base::Sys.getenv()
[13:20:17.103]                 names <- names(envs)
[13:20:17.103]                 common <- intersect(names, old_names)
[13:20:17.103]                 added <- setdiff(names, old_names)
[13:20:17.103]                 removed <- setdiff(old_names, names)
[13:20:17.103]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:17.103]                   envs[common]]
[13:20:17.103]                 NAMES <- toupper(changed)
[13:20:17.103]                 args <- list()
[13:20:17.103]                 for (kk in seq_along(NAMES)) {
[13:20:17.103]                   name <- changed[[kk]]
[13:20:17.103]                   NAME <- NAMES[[kk]]
[13:20:17.103]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:17.103]                     next
[13:20:17.103]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:17.103]                 }
[13:20:17.103]                 NAMES <- toupper(added)
[13:20:17.103]                 for (kk in seq_along(NAMES)) {
[13:20:17.103]                   name <- added[[kk]]
[13:20:17.103]                   NAME <- NAMES[[kk]]
[13:20:17.103]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:17.103]                     next
[13:20:17.103]                   args[[name]] <- ""
[13:20:17.103]                 }
[13:20:17.103]                 NAMES <- toupper(removed)
[13:20:17.103]                 for (kk in seq_along(NAMES)) {
[13:20:17.103]                   name <- removed[[kk]]
[13:20:17.103]                   NAME <- NAMES[[kk]]
[13:20:17.103]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:17.103]                     next
[13:20:17.103]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:17.103]                 }
[13:20:17.103]                 if (length(args) > 0) 
[13:20:17.103]                   base::do.call(base::Sys.setenv, args = args)
[13:20:17.103]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:17.103]             }
[13:20:17.103]             else {
[13:20:17.103]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:17.103]             }
[13:20:17.103]             {
[13:20:17.103]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:17.103]                   0L) {
[13:20:17.103]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:17.103]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:17.103]                   base::options(opts)
[13:20:17.103]                 }
[13:20:17.103]                 {
[13:20:17.103]                   {
[13:20:17.103]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:17.103]                     NULL
[13:20:17.103]                   }
[13:20:17.103]                   options(future.plan = NULL)
[13:20:17.103]                   if (is.na(NA_character_)) 
[13:20:17.103]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:17.103]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:17.103]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:17.103]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:17.103]                     envir = parent.frame()) 
[13:20:17.103]                   {
[13:20:17.103]                     if (is.function(workers)) 
[13:20:17.103]                       workers <- workers()
[13:20:17.103]                     workers <- structure(as.integer(workers), 
[13:20:17.103]                       class = class(workers))
[13:20:17.103]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:17.103]                       workers >= 1)
[13:20:17.103]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:17.103]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:17.103]                     }
[13:20:17.103]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:17.103]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:17.103]                       envir = envir)
[13:20:17.103]                     if (!future$lazy) 
[13:20:17.103]                       future <- run(future)
[13:20:17.103]                     invisible(future)
[13:20:17.103]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:17.103]                 }
[13:20:17.103]             }
[13:20:17.103]         }
[13:20:17.103]     })
[13:20:17.103]     if (TRUE) {
[13:20:17.103]         base::sink(type = "output", split = FALSE)
[13:20:17.103]         if (TRUE) {
[13:20:17.103]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:17.103]         }
[13:20:17.103]         else {
[13:20:17.103]             ...future.result["stdout"] <- base::list(NULL)
[13:20:17.103]         }
[13:20:17.103]         base::close(...future.stdout)
[13:20:17.103]         ...future.stdout <- NULL
[13:20:17.103]     }
[13:20:17.103]     ...future.result$conditions <- ...future.conditions
[13:20:17.103]     ...future.result$finished <- base::Sys.time()
[13:20:17.103]     ...future.result
[13:20:17.103] }
[13:20:17.106] MultisessionFuture started
[13:20:17.106] - Launch lazy future ... done
[13:20:17.106] run() for ‘MultisessionFuture’ ... done
[13:20:17.107] result() for ClusterFuture ...
[13:20:17.107] receiveMessageFromWorker() for ClusterFuture ...
[13:20:17.107] - Validating connection of MultisessionFuture
[13:20:17.154] - received message: FutureResult
[13:20:17.154] - Received FutureResult
[13:20:17.154] - Erased future from FutureRegistry
[13:20:17.155] result() for ClusterFuture ...
[13:20:17.155] - result already collected: FutureResult
[13:20:17.155] result() for ClusterFuture ... done
[13:20:17.155] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:17.155] result() for ClusterFuture ... done
[13:20:17.155] result() for ClusterFuture ...
[13:20:17.155] - result already collected: FutureResult
[13:20:17.155] result() for ClusterFuture ... done
d = 1
** Nested future assignments
[13:20:17.156] getGlobalsAndPackages() ...
[13:20:17.156] Searching for globals...
[13:20:17.159] - globals found: [5] ‘{’, ‘<-’, ‘%<-%’, ‘%->%’, ‘+’
[13:20:17.160] Searching for globals ... DONE
[13:20:17.160] Resolving globals: FALSE
[13:20:17.160] 
[13:20:17.160] - packages: [1] ‘future’
[13:20:17.160] getGlobalsAndPackages() ... DONE
[13:20:17.161] run() for ‘Future’ ...
[13:20:17.161] - state: ‘created’
[13:20:17.161] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:17.176] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:17.176] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:17.177]   - Field: ‘node’
[13:20:17.177]   - Field: ‘label’
[13:20:17.177]   - Field: ‘local’
[13:20:17.177]   - Field: ‘owner’
[13:20:17.177]   - Field: ‘envir’
[13:20:17.177]   - Field: ‘workers’
[13:20:17.177]   - Field: ‘packages’
[13:20:17.177]   - Field: ‘gc’
[13:20:17.177]   - Field: ‘conditions’
[13:20:17.177]   - Field: ‘persistent’
[13:20:17.178]   - Field: ‘expr’
[13:20:17.178]   - Field: ‘uuid’
[13:20:17.178]   - Field: ‘seed’
[13:20:17.178]   - Field: ‘version’
[13:20:17.178]   - Field: ‘result’
[13:20:17.178]   - Field: ‘asynchronous’
[13:20:17.178]   - Field: ‘calls’
[13:20:17.178]   - Field: ‘globals’
[13:20:17.178]   - Field: ‘stdout’
[13:20:17.178]   - Field: ‘earlySignal’
[13:20:17.179]   - Field: ‘lazy’
[13:20:17.179]   - Field: ‘state’
[13:20:17.179] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:17.179] - Launch lazy future ...
[13:20:17.179] Packages needed by the future expression (n = 1): ‘future’
[13:20:17.179] Packages needed by future strategies (n = 0): <none>
[13:20:17.180] {
[13:20:17.180]     {
[13:20:17.180]         {
[13:20:17.180]             ...future.startTime <- base::Sys.time()
[13:20:17.180]             {
[13:20:17.180]                 {
[13:20:17.180]                   {
[13:20:17.180]                     {
[13:20:17.180]                       {
[13:20:17.180]                         base::local({
[13:20:17.180]                           has_future <- base::requireNamespace("future", 
[13:20:17.180]                             quietly = TRUE)
[13:20:17.180]                           if (has_future) {
[13:20:17.180]                             ns <- base::getNamespace("future")
[13:20:17.180]                             version <- ns[[".package"]][["version"]]
[13:20:17.180]                             if (is.null(version)) 
[13:20:17.180]                               version <- utils::packageVersion("future")
[13:20:17.180]                           }
[13:20:17.180]                           else {
[13:20:17.180]                             version <- NULL
[13:20:17.180]                           }
[13:20:17.180]                           if (!has_future || version < "1.8.0") {
[13:20:17.180]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:17.180]                               "", base::R.version$version.string), 
[13:20:17.180]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:17.180]                                 base::R.version$platform, 8 * 
[13:20:17.180]                                   base::.Machine$sizeof.pointer), 
[13:20:17.180]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:17.180]                                 "release", "version")], collapse = " "), 
[13:20:17.180]                               hostname = base::Sys.info()[["nodename"]])
[13:20:17.180]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:17.180]                               info)
[13:20:17.180]                             info <- base::paste(info, collapse = "; ")
[13:20:17.180]                             if (!has_future) {
[13:20:17.180]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:17.180]                                 info)
[13:20:17.180]                             }
[13:20:17.180]                             else {
[13:20:17.180]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:17.180]                                 info, version)
[13:20:17.180]                             }
[13:20:17.180]                             base::stop(msg)
[13:20:17.180]                           }
[13:20:17.180]                         })
[13:20:17.180]                       }
[13:20:17.180]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:17.180]                       base::options(mc.cores = 1L)
[13:20:17.180]                     }
[13:20:17.180]                     base::local({
[13:20:17.180]                       for (pkg in "future") {
[13:20:17.180]                         base::loadNamespace(pkg)
[13:20:17.180]                         base::library(pkg, character.only = TRUE)
[13:20:17.180]                       }
[13:20:17.180]                     })
[13:20:17.180]                   }
[13:20:17.180]                   options(future.plan = NULL)
[13:20:17.180]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:17.180]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:17.180]                 }
[13:20:17.180]                 ...future.workdir <- getwd()
[13:20:17.180]             }
[13:20:17.180]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:17.180]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:17.180]         }
[13:20:17.180]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:17.180]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:17.180]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:17.180]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:17.180]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:17.180]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:17.180]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:17.180]             base::names(...future.oldOptions))
[13:20:17.180]     }
[13:20:17.180]     if (FALSE) {
[13:20:17.180]     }
[13:20:17.180]     else {
[13:20:17.180]         if (TRUE) {
[13:20:17.180]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:17.180]                 open = "w")
[13:20:17.180]         }
[13:20:17.180]         else {
[13:20:17.180]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:17.180]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:17.180]         }
[13:20:17.180]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:17.180]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:17.180]             base::sink(type = "output", split = FALSE)
[13:20:17.180]             base::close(...future.stdout)
[13:20:17.180]         }, add = TRUE)
[13:20:17.180]     }
[13:20:17.180]     ...future.frame <- base::sys.nframe()
[13:20:17.180]     ...future.conditions <- base::list()
[13:20:17.180]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:17.180]     if (FALSE) {
[13:20:17.180]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:17.180]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:17.180]     }
[13:20:17.180]     ...future.result <- base::tryCatch({
[13:20:17.180]         base::withCallingHandlers({
[13:20:17.180]             ...future.value <- base::withVisible(base::local({
[13:20:17.180]                 ...future.makeSendCondition <- local({
[13:20:17.180]                   sendCondition <- NULL
[13:20:17.180]                   function(frame = 1L) {
[13:20:17.180]                     if (is.function(sendCondition)) 
[13:20:17.180]                       return(sendCondition)
[13:20:17.180]                     ns <- getNamespace("parallel")
[13:20:17.180]                     if (exists("sendData", mode = "function", 
[13:20:17.180]                       envir = ns)) {
[13:20:17.180]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:17.180]                         envir = ns)
[13:20:17.180]                       envir <- sys.frame(frame)
[13:20:17.180]                       master <- NULL
[13:20:17.180]                       while (!identical(envir, .GlobalEnv) && 
[13:20:17.180]                         !identical(envir, emptyenv())) {
[13:20:17.180]                         if (exists("master", mode = "list", envir = envir, 
[13:20:17.180]                           inherits = FALSE)) {
[13:20:17.180]                           master <- get("master", mode = "list", 
[13:20:17.180]                             envir = envir, inherits = FALSE)
[13:20:17.180]                           if (inherits(master, c("SOCKnode", 
[13:20:17.180]                             "SOCK0node"))) {
[13:20:17.180]                             sendCondition <<- function(cond) {
[13:20:17.180]                               data <- list(type = "VALUE", value = cond, 
[13:20:17.180]                                 success = TRUE)
[13:20:17.180]                               parallel_sendData(master, data)
[13:20:17.180]                             }
[13:20:17.180]                             return(sendCondition)
[13:20:17.180]                           }
[13:20:17.180]                         }
[13:20:17.180]                         frame <- frame + 1L
[13:20:17.180]                         envir <- sys.frame(frame)
[13:20:17.180]                       }
[13:20:17.180]                     }
[13:20:17.180]                     sendCondition <<- function(cond) NULL
[13:20:17.180]                   }
[13:20:17.180]                 })
[13:20:17.180]                 withCallingHandlers({
[13:20:17.180]                   {
[13:20:17.180]                     b <- 1
[13:20:17.180]                     c %<-% 2
[13:20:17.180]                     d <- 3
[13:20:17.180]                     4 %->% e
[13:20:17.180]                     b + c + d + e
[13:20:17.180]                   }
[13:20:17.180]                 }, immediateCondition = function(cond) {
[13:20:17.180]                   sendCondition <- ...future.makeSendCondition()
[13:20:17.180]                   sendCondition(cond)
[13:20:17.180]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:17.180]                   {
[13:20:17.180]                     inherits <- base::inherits
[13:20:17.180]                     invokeRestart <- base::invokeRestart
[13:20:17.180]                     is.null <- base::is.null
[13:20:17.180]                     muffled <- FALSE
[13:20:17.180]                     if (inherits(cond, "message")) {
[13:20:17.180]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:17.180]                       if (muffled) 
[13:20:17.180]                         invokeRestart("muffleMessage")
[13:20:17.180]                     }
[13:20:17.180]                     else if (inherits(cond, "warning")) {
[13:20:17.180]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:17.180]                       if (muffled) 
[13:20:17.180]                         invokeRestart("muffleWarning")
[13:20:17.180]                     }
[13:20:17.180]                     else if (inherits(cond, "condition")) {
[13:20:17.180]                       if (!is.null(pattern)) {
[13:20:17.180]                         computeRestarts <- base::computeRestarts
[13:20:17.180]                         grepl <- base::grepl
[13:20:17.180]                         restarts <- computeRestarts(cond)
[13:20:17.180]                         for (restart in restarts) {
[13:20:17.180]                           name <- restart$name
[13:20:17.180]                           if (is.null(name)) 
[13:20:17.180]                             next
[13:20:17.180]                           if (!grepl(pattern, name)) 
[13:20:17.180]                             next
[13:20:17.180]                           invokeRestart(restart)
[13:20:17.180]                           muffled <- TRUE
[13:20:17.180]                           break
[13:20:17.180]                         }
[13:20:17.180]                       }
[13:20:17.180]                     }
[13:20:17.180]                     invisible(muffled)
[13:20:17.180]                   }
[13:20:17.180]                   muffleCondition(cond)
[13:20:17.180]                 })
[13:20:17.180]             }))
[13:20:17.180]             future::FutureResult(value = ...future.value$value, 
[13:20:17.180]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:17.180]                   ...future.rng), globalenv = if (FALSE) 
[13:20:17.180]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:17.180]                     ...future.globalenv.names))
[13:20:17.180]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:17.180]         }, condition = base::local({
[13:20:17.180]             c <- base::c
[13:20:17.180]             inherits <- base::inherits
[13:20:17.180]             invokeRestart <- base::invokeRestart
[13:20:17.180]             length <- base::length
[13:20:17.180]             list <- base::list
[13:20:17.180]             seq.int <- base::seq.int
[13:20:17.180]             signalCondition <- base::signalCondition
[13:20:17.180]             sys.calls <- base::sys.calls
[13:20:17.180]             `[[` <- base::`[[`
[13:20:17.180]             `+` <- base::`+`
[13:20:17.180]             `<<-` <- base::`<<-`
[13:20:17.180]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:17.180]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:17.180]                   3L)]
[13:20:17.180]             }
[13:20:17.180]             function(cond) {
[13:20:17.180]                 is_error <- inherits(cond, "error")
[13:20:17.180]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:17.180]                   NULL)
[13:20:17.180]                 if (is_error) {
[13:20:17.180]                   sessionInformation <- function() {
[13:20:17.180]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:17.180]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:17.180]                       search = base::search(), system = base::Sys.info())
[13:20:17.180]                   }
[13:20:17.180]                   ...future.conditions[[length(...future.conditions) + 
[13:20:17.180]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:17.180]                     cond$call), session = sessionInformation(), 
[13:20:17.180]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:17.180]                   signalCondition(cond)
[13:20:17.180]                 }
[13:20:17.180]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:17.180]                 "immediateCondition"))) {
[13:20:17.180]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:17.180]                   ...future.conditions[[length(...future.conditions) + 
[13:20:17.180]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:17.180]                   if (TRUE && !signal) {
[13:20:17.180]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:17.180]                     {
[13:20:17.180]                       inherits <- base::inherits
[13:20:17.180]                       invokeRestart <- base::invokeRestart
[13:20:17.180]                       is.null <- base::is.null
[13:20:17.180]                       muffled <- FALSE
[13:20:17.180]                       if (inherits(cond, "message")) {
[13:20:17.180]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:17.180]                         if (muffled) 
[13:20:17.180]                           invokeRestart("muffleMessage")
[13:20:17.180]                       }
[13:20:17.180]                       else if (inherits(cond, "warning")) {
[13:20:17.180]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:17.180]                         if (muffled) 
[13:20:17.180]                           invokeRestart("muffleWarning")
[13:20:17.180]                       }
[13:20:17.180]                       else if (inherits(cond, "condition")) {
[13:20:17.180]                         if (!is.null(pattern)) {
[13:20:17.180]                           computeRestarts <- base::computeRestarts
[13:20:17.180]                           grepl <- base::grepl
[13:20:17.180]                           restarts <- computeRestarts(cond)
[13:20:17.180]                           for (restart in restarts) {
[13:20:17.180]                             name <- restart$name
[13:20:17.180]                             if (is.null(name)) 
[13:20:17.180]                               next
[13:20:17.180]                             if (!grepl(pattern, name)) 
[13:20:17.180]                               next
[13:20:17.180]                             invokeRestart(restart)
[13:20:17.180]                             muffled <- TRUE
[13:20:17.180]                             break
[13:20:17.180]                           }
[13:20:17.180]                         }
[13:20:17.180]                       }
[13:20:17.180]                       invisible(muffled)
[13:20:17.180]                     }
[13:20:17.180]                     muffleCondition(cond, pattern = "^muffle")
[13:20:17.180]                   }
[13:20:17.180]                 }
[13:20:17.180]                 else {
[13:20:17.180]                   if (TRUE) {
[13:20:17.180]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:17.180]                     {
[13:20:17.180]                       inherits <- base::inherits
[13:20:17.180]                       invokeRestart <- base::invokeRestart
[13:20:17.180]                       is.null <- base::is.null
[13:20:17.180]                       muffled <- FALSE
[13:20:17.180]                       if (inherits(cond, "message")) {
[13:20:17.180]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:17.180]                         if (muffled) 
[13:20:17.180]                           invokeRestart("muffleMessage")
[13:20:17.180]                       }
[13:20:17.180]                       else if (inherits(cond, "warning")) {
[13:20:17.180]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:17.180]                         if (muffled) 
[13:20:17.180]                           invokeRestart("muffleWarning")
[13:20:17.180]                       }
[13:20:17.180]                       else if (inherits(cond, "condition")) {
[13:20:17.180]                         if (!is.null(pattern)) {
[13:20:17.180]                           computeRestarts <- base::computeRestarts
[13:20:17.180]                           grepl <- base::grepl
[13:20:17.180]                           restarts <- computeRestarts(cond)
[13:20:17.180]                           for (restart in restarts) {
[13:20:17.180]                             name <- restart$name
[13:20:17.180]                             if (is.null(name)) 
[13:20:17.180]                               next
[13:20:17.180]                             if (!grepl(pattern, name)) 
[13:20:17.180]                               next
[13:20:17.180]                             invokeRestart(restart)
[13:20:17.180]                             muffled <- TRUE
[13:20:17.180]                             break
[13:20:17.180]                           }
[13:20:17.180]                         }
[13:20:17.180]                       }
[13:20:17.180]                       invisible(muffled)
[13:20:17.180]                     }
[13:20:17.180]                     muffleCondition(cond, pattern = "^muffle")
[13:20:17.180]                   }
[13:20:17.180]                 }
[13:20:17.180]             }
[13:20:17.180]         }))
[13:20:17.180]     }, error = function(ex) {
[13:20:17.180]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:17.180]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:17.180]                 ...future.rng), started = ...future.startTime, 
[13:20:17.180]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:17.180]             version = "1.8"), class = "FutureResult")
[13:20:17.180]     }, finally = {
[13:20:17.180]         if (!identical(...future.workdir, getwd())) 
[13:20:17.180]             setwd(...future.workdir)
[13:20:17.180]         {
[13:20:17.180]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:17.180]                 ...future.oldOptions$nwarnings <- NULL
[13:20:17.180]             }
[13:20:17.180]             base::options(...future.oldOptions)
[13:20:17.180]             if (.Platform$OS.type == "windows") {
[13:20:17.180]                 old_names <- names(...future.oldEnvVars)
[13:20:17.180]                 envs <- base::Sys.getenv()
[13:20:17.180]                 names <- names(envs)
[13:20:17.180]                 common <- intersect(names, old_names)
[13:20:17.180]                 added <- setdiff(names, old_names)
[13:20:17.180]                 removed <- setdiff(old_names, names)
[13:20:17.180]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:17.180]                   envs[common]]
[13:20:17.180]                 NAMES <- toupper(changed)
[13:20:17.180]                 args <- list()
[13:20:17.180]                 for (kk in seq_along(NAMES)) {
[13:20:17.180]                   name <- changed[[kk]]
[13:20:17.180]                   NAME <- NAMES[[kk]]
[13:20:17.180]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:17.180]                     next
[13:20:17.180]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:17.180]                 }
[13:20:17.180]                 NAMES <- toupper(added)
[13:20:17.180]                 for (kk in seq_along(NAMES)) {
[13:20:17.180]                   name <- added[[kk]]
[13:20:17.180]                   NAME <- NAMES[[kk]]
[13:20:17.180]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:17.180]                     next
[13:20:17.180]                   args[[name]] <- ""
[13:20:17.180]                 }
[13:20:17.180]                 NAMES <- toupper(removed)
[13:20:17.180]                 for (kk in seq_along(NAMES)) {
[13:20:17.180]                   name <- removed[[kk]]
[13:20:17.180]                   NAME <- NAMES[[kk]]
[13:20:17.180]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:17.180]                     next
[13:20:17.180]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:17.180]                 }
[13:20:17.180]                 if (length(args) > 0) 
[13:20:17.180]                   base::do.call(base::Sys.setenv, args = args)
[13:20:17.180]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:17.180]             }
[13:20:17.180]             else {
[13:20:17.180]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:17.180]             }
[13:20:17.180]             {
[13:20:17.180]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:17.180]                   0L) {
[13:20:17.180]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:17.180]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:17.180]                   base::options(opts)
[13:20:17.180]                 }
[13:20:17.180]                 {
[13:20:17.180]                   {
[13:20:17.180]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:17.180]                     NULL
[13:20:17.180]                   }
[13:20:17.180]                   options(future.plan = NULL)
[13:20:17.180]                   if (is.na(NA_character_)) 
[13:20:17.180]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:17.180]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:17.180]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:17.180]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:17.180]                     envir = parent.frame()) 
[13:20:17.180]                   {
[13:20:17.180]                     if (is.function(workers)) 
[13:20:17.180]                       workers <- workers()
[13:20:17.180]                     workers <- structure(as.integer(workers), 
[13:20:17.180]                       class = class(workers))
[13:20:17.180]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:17.180]                       workers >= 1)
[13:20:17.180]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:17.180]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:17.180]                     }
[13:20:17.180]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:17.180]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:17.180]                       envir = envir)
[13:20:17.180]                     if (!future$lazy) 
[13:20:17.180]                       future <- run(future)
[13:20:17.180]                     invisible(future)
[13:20:17.180]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:17.180]                 }
[13:20:17.180]             }
[13:20:17.180]         }
[13:20:17.180]     })
[13:20:17.180]     if (TRUE) {
[13:20:17.180]         base::sink(type = "output", split = FALSE)
[13:20:17.180]         if (TRUE) {
[13:20:17.180]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:17.180]         }
[13:20:17.180]         else {
[13:20:17.180]             ...future.result["stdout"] <- base::list(NULL)
[13:20:17.180]         }
[13:20:17.180]         base::close(...future.stdout)
[13:20:17.180]         ...future.stdout <- NULL
[13:20:17.180]     }
[13:20:17.180]     ...future.result$conditions <- ...future.conditions
[13:20:17.180]     ...future.result$finished <- base::Sys.time()
[13:20:17.180]     ...future.result
[13:20:17.180] }
[13:20:17.183] MultisessionFuture started
[13:20:17.183] - Launch lazy future ... done
[13:20:17.183] run() for ‘MultisessionFuture’ ... done
[13:20:17.183] result() for ClusterFuture ...
[13:20:17.183] receiveMessageFromWorker() for ClusterFuture ...
[13:20:17.183] - Validating connection of MultisessionFuture
[13:20:17.246] - received message: FutureResult
[13:20:17.246] - Received FutureResult
[13:20:17.246] - Erased future from FutureRegistry
[13:20:17.246] result() for ClusterFuture ...
[13:20:17.246] - result already collected: FutureResult
[13:20:17.247] result() for ClusterFuture ... done
[13:20:17.247] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:17.247] result() for ClusterFuture ... done
[13:20:17.247] result() for ClusterFuture ...
[13:20:17.247] - result already collected: FutureResult
[13:20:17.247] result() for ClusterFuture ... done
a = 10
[13:20:17.247] getGlobalsAndPackages() ...
[13:20:17.248] Searching for globals...
[13:20:17.248] - globals found: [3] ‘{’, ‘+’, ‘a’
[13:20:17.249] Searching for globals ... DONE
[13:20:17.249] Resolving globals: FALSE
[13:20:17.249] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:17.249] The total size of the 1 globals exported for future expression (‘{; a + 1; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:20:17.250] - globals: [1] ‘a’
[13:20:17.250] 
[13:20:17.250] getGlobalsAndPackages() ... DONE
[13:20:17.250] run() for ‘Future’ ...
[13:20:17.250] - state: ‘created’
[13:20:17.250] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:17.265] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:17.265] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:17.265]   - Field: ‘node’
[13:20:17.265]   - Field: ‘label’
[13:20:17.265]   - Field: ‘local’
[13:20:17.266]   - Field: ‘owner’
[13:20:17.266]   - Field: ‘envir’
[13:20:17.266]   - Field: ‘workers’
[13:20:17.266]   - Field: ‘packages’
[13:20:17.266]   - Field: ‘gc’
[13:20:17.266]   - Field: ‘conditions’
[13:20:17.266]   - Field: ‘persistent’
[13:20:17.266]   - Field: ‘expr’
[13:20:17.266]   - Field: ‘uuid’
[13:20:17.266]   - Field: ‘seed’
[13:20:17.267]   - Field: ‘version’
[13:20:17.267]   - Field: ‘result’
[13:20:17.267]   - Field: ‘asynchronous’
[13:20:17.267]   - Field: ‘calls’
[13:20:17.267]   - Field: ‘globals’
[13:20:17.267]   - Field: ‘stdout’
[13:20:17.267]   - Field: ‘earlySignal’
[13:20:17.267]   - Field: ‘lazy’
[13:20:17.267]   - Field: ‘state’
[13:20:17.267] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:17.267] - Launch lazy future ...
[13:20:17.268] Packages needed by the future expression (n = 0): <none>
[13:20:17.268] Packages needed by future strategies (n = 0): <none>
[13:20:17.268] {
[13:20:17.268]     {
[13:20:17.268]         {
[13:20:17.268]             ...future.startTime <- base::Sys.time()
[13:20:17.268]             {
[13:20:17.268]                 {
[13:20:17.268]                   {
[13:20:17.268]                     {
[13:20:17.268]                       base::local({
[13:20:17.268]                         has_future <- base::requireNamespace("future", 
[13:20:17.268]                           quietly = TRUE)
[13:20:17.268]                         if (has_future) {
[13:20:17.268]                           ns <- base::getNamespace("future")
[13:20:17.268]                           version <- ns[[".package"]][["version"]]
[13:20:17.268]                           if (is.null(version)) 
[13:20:17.268]                             version <- utils::packageVersion("future")
[13:20:17.268]                         }
[13:20:17.268]                         else {
[13:20:17.268]                           version <- NULL
[13:20:17.268]                         }
[13:20:17.268]                         if (!has_future || version < "1.8.0") {
[13:20:17.268]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:17.268]                             "", base::R.version$version.string), 
[13:20:17.268]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:17.268]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:17.268]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:17.268]                               "release", "version")], collapse = " "), 
[13:20:17.268]                             hostname = base::Sys.info()[["nodename"]])
[13:20:17.268]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:17.268]                             info)
[13:20:17.268]                           info <- base::paste(info, collapse = "; ")
[13:20:17.268]                           if (!has_future) {
[13:20:17.268]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:17.268]                               info)
[13:20:17.268]                           }
[13:20:17.268]                           else {
[13:20:17.268]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:17.268]                               info, version)
[13:20:17.268]                           }
[13:20:17.268]                           base::stop(msg)
[13:20:17.268]                         }
[13:20:17.268]                       })
[13:20:17.268]                     }
[13:20:17.268]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:17.268]                     base::options(mc.cores = 1L)
[13:20:17.268]                   }
[13:20:17.268]                   options(future.plan = NULL)
[13:20:17.268]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:17.268]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:17.268]                 }
[13:20:17.268]                 ...future.workdir <- getwd()
[13:20:17.268]             }
[13:20:17.268]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:17.268]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:17.268]         }
[13:20:17.268]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:17.268]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:17.268]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:17.268]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:17.268]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:17.268]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:17.268]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:17.268]             base::names(...future.oldOptions))
[13:20:17.268]     }
[13:20:17.268]     if (FALSE) {
[13:20:17.268]     }
[13:20:17.268]     else {
[13:20:17.268]         if (TRUE) {
[13:20:17.268]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:17.268]                 open = "w")
[13:20:17.268]         }
[13:20:17.268]         else {
[13:20:17.268]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:17.268]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:17.268]         }
[13:20:17.268]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:17.268]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:17.268]             base::sink(type = "output", split = FALSE)
[13:20:17.268]             base::close(...future.stdout)
[13:20:17.268]         }, add = TRUE)
[13:20:17.268]     }
[13:20:17.268]     ...future.frame <- base::sys.nframe()
[13:20:17.268]     ...future.conditions <- base::list()
[13:20:17.268]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:17.268]     if (FALSE) {
[13:20:17.268]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:17.268]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:17.268]     }
[13:20:17.268]     ...future.result <- base::tryCatch({
[13:20:17.268]         base::withCallingHandlers({
[13:20:17.268]             ...future.value <- base::withVisible(base::local({
[13:20:17.268]                 ...future.makeSendCondition <- local({
[13:20:17.268]                   sendCondition <- NULL
[13:20:17.268]                   function(frame = 1L) {
[13:20:17.268]                     if (is.function(sendCondition)) 
[13:20:17.268]                       return(sendCondition)
[13:20:17.268]                     ns <- getNamespace("parallel")
[13:20:17.268]                     if (exists("sendData", mode = "function", 
[13:20:17.268]                       envir = ns)) {
[13:20:17.268]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:17.268]                         envir = ns)
[13:20:17.268]                       envir <- sys.frame(frame)
[13:20:17.268]                       master <- NULL
[13:20:17.268]                       while (!identical(envir, .GlobalEnv) && 
[13:20:17.268]                         !identical(envir, emptyenv())) {
[13:20:17.268]                         if (exists("master", mode = "list", envir = envir, 
[13:20:17.268]                           inherits = FALSE)) {
[13:20:17.268]                           master <- get("master", mode = "list", 
[13:20:17.268]                             envir = envir, inherits = FALSE)
[13:20:17.268]                           if (inherits(master, c("SOCKnode", 
[13:20:17.268]                             "SOCK0node"))) {
[13:20:17.268]                             sendCondition <<- function(cond) {
[13:20:17.268]                               data <- list(type = "VALUE", value = cond, 
[13:20:17.268]                                 success = TRUE)
[13:20:17.268]                               parallel_sendData(master, data)
[13:20:17.268]                             }
[13:20:17.268]                             return(sendCondition)
[13:20:17.268]                           }
[13:20:17.268]                         }
[13:20:17.268]                         frame <- frame + 1L
[13:20:17.268]                         envir <- sys.frame(frame)
[13:20:17.268]                       }
[13:20:17.268]                     }
[13:20:17.268]                     sendCondition <<- function(cond) NULL
[13:20:17.268]                   }
[13:20:17.268]                 })
[13:20:17.268]                 withCallingHandlers({
[13:20:17.268]                   {
[13:20:17.268]                     a + 1
[13:20:17.268]                   }
[13:20:17.268]                 }, immediateCondition = function(cond) {
[13:20:17.268]                   sendCondition <- ...future.makeSendCondition()
[13:20:17.268]                   sendCondition(cond)
[13:20:17.268]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:17.268]                   {
[13:20:17.268]                     inherits <- base::inherits
[13:20:17.268]                     invokeRestart <- base::invokeRestart
[13:20:17.268]                     is.null <- base::is.null
[13:20:17.268]                     muffled <- FALSE
[13:20:17.268]                     if (inherits(cond, "message")) {
[13:20:17.268]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:17.268]                       if (muffled) 
[13:20:17.268]                         invokeRestart("muffleMessage")
[13:20:17.268]                     }
[13:20:17.268]                     else if (inherits(cond, "warning")) {
[13:20:17.268]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:17.268]                       if (muffled) 
[13:20:17.268]                         invokeRestart("muffleWarning")
[13:20:17.268]                     }
[13:20:17.268]                     else if (inherits(cond, "condition")) {
[13:20:17.268]                       if (!is.null(pattern)) {
[13:20:17.268]                         computeRestarts <- base::computeRestarts
[13:20:17.268]                         grepl <- base::grepl
[13:20:17.268]                         restarts <- computeRestarts(cond)
[13:20:17.268]                         for (restart in restarts) {
[13:20:17.268]                           name <- restart$name
[13:20:17.268]                           if (is.null(name)) 
[13:20:17.268]                             next
[13:20:17.268]                           if (!grepl(pattern, name)) 
[13:20:17.268]                             next
[13:20:17.268]                           invokeRestart(restart)
[13:20:17.268]                           muffled <- TRUE
[13:20:17.268]                           break
[13:20:17.268]                         }
[13:20:17.268]                       }
[13:20:17.268]                     }
[13:20:17.268]                     invisible(muffled)
[13:20:17.268]                   }
[13:20:17.268]                   muffleCondition(cond)
[13:20:17.268]                 })
[13:20:17.268]             }))
[13:20:17.268]             future::FutureResult(value = ...future.value$value, 
[13:20:17.268]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:17.268]                   ...future.rng), globalenv = if (FALSE) 
[13:20:17.268]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:17.268]                     ...future.globalenv.names))
[13:20:17.268]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:17.268]         }, condition = base::local({
[13:20:17.268]             c <- base::c
[13:20:17.268]             inherits <- base::inherits
[13:20:17.268]             invokeRestart <- base::invokeRestart
[13:20:17.268]             length <- base::length
[13:20:17.268]             list <- base::list
[13:20:17.268]             seq.int <- base::seq.int
[13:20:17.268]             signalCondition <- base::signalCondition
[13:20:17.268]             sys.calls <- base::sys.calls
[13:20:17.268]             `[[` <- base::`[[`
[13:20:17.268]             `+` <- base::`+`
[13:20:17.268]             `<<-` <- base::`<<-`
[13:20:17.268]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:17.268]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:17.268]                   3L)]
[13:20:17.268]             }
[13:20:17.268]             function(cond) {
[13:20:17.268]                 is_error <- inherits(cond, "error")
[13:20:17.268]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:17.268]                   NULL)
[13:20:17.268]                 if (is_error) {
[13:20:17.268]                   sessionInformation <- function() {
[13:20:17.268]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:17.268]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:17.268]                       search = base::search(), system = base::Sys.info())
[13:20:17.268]                   }
[13:20:17.268]                   ...future.conditions[[length(...future.conditions) + 
[13:20:17.268]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:17.268]                     cond$call), session = sessionInformation(), 
[13:20:17.268]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:17.268]                   signalCondition(cond)
[13:20:17.268]                 }
[13:20:17.268]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:17.268]                 "immediateCondition"))) {
[13:20:17.268]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:17.268]                   ...future.conditions[[length(...future.conditions) + 
[13:20:17.268]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:17.268]                   if (TRUE && !signal) {
[13:20:17.268]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:17.268]                     {
[13:20:17.268]                       inherits <- base::inherits
[13:20:17.268]                       invokeRestart <- base::invokeRestart
[13:20:17.268]                       is.null <- base::is.null
[13:20:17.268]                       muffled <- FALSE
[13:20:17.268]                       if (inherits(cond, "message")) {
[13:20:17.268]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:17.268]                         if (muffled) 
[13:20:17.268]                           invokeRestart("muffleMessage")
[13:20:17.268]                       }
[13:20:17.268]                       else if (inherits(cond, "warning")) {
[13:20:17.268]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:17.268]                         if (muffled) 
[13:20:17.268]                           invokeRestart("muffleWarning")
[13:20:17.268]                       }
[13:20:17.268]                       else if (inherits(cond, "condition")) {
[13:20:17.268]                         if (!is.null(pattern)) {
[13:20:17.268]                           computeRestarts <- base::computeRestarts
[13:20:17.268]                           grepl <- base::grepl
[13:20:17.268]                           restarts <- computeRestarts(cond)
[13:20:17.268]                           for (restart in restarts) {
[13:20:17.268]                             name <- restart$name
[13:20:17.268]                             if (is.null(name)) 
[13:20:17.268]                               next
[13:20:17.268]                             if (!grepl(pattern, name)) 
[13:20:17.268]                               next
[13:20:17.268]                             invokeRestart(restart)
[13:20:17.268]                             muffled <- TRUE
[13:20:17.268]                             break
[13:20:17.268]                           }
[13:20:17.268]                         }
[13:20:17.268]                       }
[13:20:17.268]                       invisible(muffled)
[13:20:17.268]                     }
[13:20:17.268]                     muffleCondition(cond, pattern = "^muffle")
[13:20:17.268]                   }
[13:20:17.268]                 }
[13:20:17.268]                 else {
[13:20:17.268]                   if (TRUE) {
[13:20:17.268]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:17.268]                     {
[13:20:17.268]                       inherits <- base::inherits
[13:20:17.268]                       invokeRestart <- base::invokeRestart
[13:20:17.268]                       is.null <- base::is.null
[13:20:17.268]                       muffled <- FALSE
[13:20:17.268]                       if (inherits(cond, "message")) {
[13:20:17.268]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:17.268]                         if (muffled) 
[13:20:17.268]                           invokeRestart("muffleMessage")
[13:20:17.268]                       }
[13:20:17.268]                       else if (inherits(cond, "warning")) {
[13:20:17.268]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:17.268]                         if (muffled) 
[13:20:17.268]                           invokeRestart("muffleWarning")
[13:20:17.268]                       }
[13:20:17.268]                       else if (inherits(cond, "condition")) {
[13:20:17.268]                         if (!is.null(pattern)) {
[13:20:17.268]                           computeRestarts <- base::computeRestarts
[13:20:17.268]                           grepl <- base::grepl
[13:20:17.268]                           restarts <- computeRestarts(cond)
[13:20:17.268]                           for (restart in restarts) {
[13:20:17.268]                             name <- restart$name
[13:20:17.268]                             if (is.null(name)) 
[13:20:17.268]                               next
[13:20:17.268]                             if (!grepl(pattern, name)) 
[13:20:17.268]                               next
[13:20:17.268]                             invokeRestart(restart)
[13:20:17.268]                             muffled <- TRUE
[13:20:17.268]                             break
[13:20:17.268]                           }
[13:20:17.268]                         }
[13:20:17.268]                       }
[13:20:17.268]                       invisible(muffled)
[13:20:17.268]                     }
[13:20:17.268]                     muffleCondition(cond, pattern = "^muffle")
[13:20:17.268]                   }
[13:20:17.268]                 }
[13:20:17.268]             }
[13:20:17.268]         }))
[13:20:17.268]     }, error = function(ex) {
[13:20:17.268]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:17.268]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:17.268]                 ...future.rng), started = ...future.startTime, 
[13:20:17.268]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:17.268]             version = "1.8"), class = "FutureResult")
[13:20:17.268]     }, finally = {
[13:20:17.268]         if (!identical(...future.workdir, getwd())) 
[13:20:17.268]             setwd(...future.workdir)
[13:20:17.268]         {
[13:20:17.268]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:17.268]                 ...future.oldOptions$nwarnings <- NULL
[13:20:17.268]             }
[13:20:17.268]             base::options(...future.oldOptions)
[13:20:17.268]             if (.Platform$OS.type == "windows") {
[13:20:17.268]                 old_names <- names(...future.oldEnvVars)
[13:20:17.268]                 envs <- base::Sys.getenv()
[13:20:17.268]                 names <- names(envs)
[13:20:17.268]                 common <- intersect(names, old_names)
[13:20:17.268]                 added <- setdiff(names, old_names)
[13:20:17.268]                 removed <- setdiff(old_names, names)
[13:20:17.268]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:17.268]                   envs[common]]
[13:20:17.268]                 NAMES <- toupper(changed)
[13:20:17.268]                 args <- list()
[13:20:17.268]                 for (kk in seq_along(NAMES)) {
[13:20:17.268]                   name <- changed[[kk]]
[13:20:17.268]                   NAME <- NAMES[[kk]]
[13:20:17.268]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:17.268]                     next
[13:20:17.268]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:17.268]                 }
[13:20:17.268]                 NAMES <- toupper(added)
[13:20:17.268]                 for (kk in seq_along(NAMES)) {
[13:20:17.268]                   name <- added[[kk]]
[13:20:17.268]                   NAME <- NAMES[[kk]]
[13:20:17.268]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:17.268]                     next
[13:20:17.268]                   args[[name]] <- ""
[13:20:17.268]                 }
[13:20:17.268]                 NAMES <- toupper(removed)
[13:20:17.268]                 for (kk in seq_along(NAMES)) {
[13:20:17.268]                   name <- removed[[kk]]
[13:20:17.268]                   NAME <- NAMES[[kk]]
[13:20:17.268]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:17.268]                     next
[13:20:17.268]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:17.268]                 }
[13:20:17.268]                 if (length(args) > 0) 
[13:20:17.268]                   base::do.call(base::Sys.setenv, args = args)
[13:20:17.268]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:17.268]             }
[13:20:17.268]             else {
[13:20:17.268]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:17.268]             }
[13:20:17.268]             {
[13:20:17.268]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:17.268]                   0L) {
[13:20:17.268]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:17.268]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:17.268]                   base::options(opts)
[13:20:17.268]                 }
[13:20:17.268]                 {
[13:20:17.268]                   {
[13:20:17.268]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:17.268]                     NULL
[13:20:17.268]                   }
[13:20:17.268]                   options(future.plan = NULL)
[13:20:17.268]                   if (is.na(NA_character_)) 
[13:20:17.268]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:17.268]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:17.268]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:17.268]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:17.268]                     envir = parent.frame()) 
[13:20:17.268]                   {
[13:20:17.268]                     if (is.function(workers)) 
[13:20:17.268]                       workers <- workers()
[13:20:17.268]                     workers <- structure(as.integer(workers), 
[13:20:17.268]                       class = class(workers))
[13:20:17.268]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:17.268]                       workers >= 1)
[13:20:17.268]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:17.268]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:17.268]                     }
[13:20:17.268]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:17.268]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:17.268]                       envir = envir)
[13:20:17.268]                     if (!future$lazy) 
[13:20:17.268]                       future <- run(future)
[13:20:17.268]                     invisible(future)
[13:20:17.268]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:17.268]                 }
[13:20:17.268]             }
[13:20:17.268]         }
[13:20:17.268]     })
[13:20:17.268]     if (TRUE) {
[13:20:17.268]         base::sink(type = "output", split = FALSE)
[13:20:17.268]         if (TRUE) {
[13:20:17.268]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:17.268]         }
[13:20:17.268]         else {
[13:20:17.268]             ...future.result["stdout"] <- base::list(NULL)
[13:20:17.268]         }
[13:20:17.268]         base::close(...future.stdout)
[13:20:17.268]         ...future.stdout <- NULL
[13:20:17.268]     }
[13:20:17.268]     ...future.result$conditions <- ...future.conditions
[13:20:17.268]     ...future.result$finished <- base::Sys.time()
[13:20:17.268]     ...future.result
[13:20:17.268] }
[13:20:17.271] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[13:20:17.271] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[13:20:17.272] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[13:20:17.272] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[13:20:17.272] MultisessionFuture started
[13:20:17.272] - Launch lazy future ... done
[13:20:17.272] run() for ‘MultisessionFuture’ ... done
[13:20:17.273] result() for ClusterFuture ...
[13:20:17.273] receiveMessageFromWorker() for ClusterFuture ...
[13:20:17.273] - Validating connection of MultisessionFuture
[13:20:17.318] - received message: FutureResult
[13:20:17.318] - Received FutureResult
[13:20:17.318] - Erased future from FutureRegistry
[13:20:17.318] result() for ClusterFuture ...
[13:20:17.318] - result already collected: FutureResult
[13:20:17.318] result() for ClusterFuture ... done
[13:20:17.318] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:17.319] result() for ClusterFuture ... done
[13:20:17.319] result() for ClusterFuture ...
[13:20:17.319] - result already collected: FutureResult
[13:20:17.319] result() for ClusterFuture ... done
b = 11
*** %<-% with ‘multisession’ futures ... DONE
Testing with 2 cores ... DONE
> 
> message("*** %<-% ... DONE")
*** %<-% ... DONE
> 
> source("incl/end.R")
[13:20:17.320] plan(): Setting new future strategy stack:
[13:20:17.320] List of future strategies:
[13:20:17.320] 1. FutureStrategy:
[13:20:17.320]    - args: function (..., envir = parent.frame())
[13:20:17.320]    - tweaked: FALSE
[13:20:17.320]    - call: future::plan(oplan)
[13:20:17.321] plan(): nbrOfWorkers() = 1
> 
