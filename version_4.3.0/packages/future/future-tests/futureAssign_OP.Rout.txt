
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[17:42:09.301] plan(): Setting new future strategy stack:
[17:42:09.302] List of future strategies:
[17:42:09.302] 1. sequential:
[17:42:09.302]    - args: function (..., envir = parent.frame())
[17:42:09.302]    - tweaked: FALSE
[17:42:09.302]    - call: future::plan("sequential")
[17:42:09.316] plan(): nbrOfWorkers() = 1
> 
> message("*** %<-% ...")
*** %<-% ...
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("*** %%<-%% with %s futures ...", sQuote(strategy)))
+     plan(strategy)
+ 
+     rm(list = intersect(c("x", "y"), ls()))
+ 
+     message("** Future evaluation without globals")
+     v1 %<-% { x <- 1 }
+     stopifnot(!exists("x", inherits = FALSE), identical(v1, 1))
+ 
+     message("** Future evaluation with globals")
+     a <- 2
+     v2 %<-% { x <- a }
+     stopifnot(!exists("x", inherits = FALSE), identical(v2, a))
+ 
+     message("** Future evaluation with errors")
+     v3 %<-% {
+       x <- 3
+       stop("Woops!")
+       x
+     }
+     stopifnot(!exists("x", inherits = FALSE))
+     res <- tryCatch(identical(v3, 3), error = identity)
+     stopifnot(inherits(res, "error"))
+ 
+ 
+     y <- listenv::listenv()
+     for (ii in 1:3) {
+       y[[ii]] %<-% {
+         if (ii %% 2 == 0) stop("Woops!")
+         ii
+       }
+     }
+     res <- tryCatch(as.list(y), error = identity)
+     stopifnot(inherits(res, "error"))
+     z <- y[c(1, 3)]
+     z <- unlist(z)
+     stopifnot(all(z == c(1, 3)))
+     res <- tryCatch(y[[2]], error = identity)
+     stopifnot(inherits(res, "error"))
+     res <- tryCatch(y[1:2], error = identity)
+     stopifnot(inherits(res, "error"))
+ 
+ 
+     message("** Future evaluation with a poor-man's \"progress bar\"")
+     v4 %<-% {
+       cat("Processing: ")
+       for (ii in 1:10) { cat(".") }
+       cat(" [100%]\n")
+       4
+     }
+ 
+ 
+     message("** Collecting results")
+     printf("v1 = %s\n", v1)
+     stopifnot(v1 == 1)
+ 
+     printf("v2 = %s\n", v2)
+     stopifnot(v2 == a)
+ 
+     stopifnot(tryCatch({
+       printf("v3 = %s\n", v3)
+     }, error = function(ex) {
+       printf("v3: <%s> (as expect)\n", class(ex)[1])
+       TRUE
+     }))
+ 
+     printf("v4 = %s\n", v4)
+     #stopifnot(v4 == 4)
+ 
+ 
+     message("** Left-to-right and right-to-left future assignments")
+     c %<-% 1
+     printf("c = %s\n", c)
+     1 %->% d
+     printf("d = %s\n", d)
+     stopifnot(d == c)
+ 
+ 
+ 
+     message("** Nested future assignments")
+     a %<-% {
+       b <- 1
+       c %<-% 2
+       3 -> d
+       4 %->% e
+       b + c + d + e
+     }
+     printf("a = %s\n", a)
+     stopifnot(a == 10)
+ 
+     { a + 1 } %->% b
+     printf("b = %s\n", b)
+     stopifnot(b == a + 1)
+ 
+     message(sprintf("*** %%<-%% with %s futures ... DONE", sQuote(strategy)))
+   } # for (strategy in ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
*** %<-% with ‘sequential’ futures ...
[17:42:09.373] plan(): Setting new future strategy stack:
[17:42:09.373] List of future strategies:
[17:42:09.373] 1. sequential:
[17:42:09.373]    - args: function (..., envir = parent.frame())
[17:42:09.373]    - tweaked: FALSE
[17:42:09.373]    - call: plan(strategy)
[17:42:09.385] plan(): nbrOfWorkers() = 1
** Future evaluation without globals
[17:42:09.387] getGlobalsAndPackages() ...
[17:42:09.387] Searching for globals...
[17:42:09.392] - globals found: [2] ‘{’, ‘<-’
[17:42:09.392] Searching for globals ... DONE
[17:42:09.392] Resolving globals: FALSE
[17:42:09.393] 
[17:42:09.393] 
[17:42:09.393] getGlobalsAndPackages() ... DONE
[17:42:09.394] run() for ‘Future’ ...
[17:42:09.394] - state: ‘created’
[17:42:09.394] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:09.394] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:09.394] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:09.394]   - Field: ‘label’
[17:42:09.395]   - Field: ‘local’
[17:42:09.395]   - Field: ‘owner’
[17:42:09.395]   - Field: ‘envir’
[17:42:09.395]   - Field: ‘packages’
[17:42:09.395]   - Field: ‘gc’
[17:42:09.395]   - Field: ‘conditions’
[17:42:09.395]   - Field: ‘expr’
[17:42:09.395]   - Field: ‘uuid’
[17:42:09.395]   - Field: ‘seed’
[17:42:09.395]   - Field: ‘version’
[17:42:09.395]   - Field: ‘result’
[17:42:09.396]   - Field: ‘asynchronous’
[17:42:09.396]   - Field: ‘calls’
[17:42:09.396]   - Field: ‘globals’
[17:42:09.396]   - Field: ‘stdout’
[17:42:09.396]   - Field: ‘earlySignal’
[17:42:09.396]   - Field: ‘lazy’
[17:42:09.396]   - Field: ‘state’
[17:42:09.396] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:09.396] - Launch lazy future ...
[17:42:09.397] Packages needed by the future expression (n = 0): <none>
[17:42:09.397] Packages needed by future strategies (n = 0): <none>
[17:42:09.398] {
[17:42:09.398]     {
[17:42:09.398]         {
[17:42:09.398]             ...future.startTime <- base::Sys.time()
[17:42:09.398]             {
[17:42:09.398]                 {
[17:42:09.398]                   {
[17:42:09.398]                     base::local({
[17:42:09.398]                       has_future <- base::requireNamespace("future", 
[17:42:09.398]                         quietly = TRUE)
[17:42:09.398]                       if (has_future) {
[17:42:09.398]                         ns <- base::getNamespace("future")
[17:42:09.398]                         version <- ns[[".package"]][["version"]]
[17:42:09.398]                         if (is.null(version)) 
[17:42:09.398]                           version <- utils::packageVersion("future")
[17:42:09.398]                       }
[17:42:09.398]                       else {
[17:42:09.398]                         version <- NULL
[17:42:09.398]                       }
[17:42:09.398]                       if (!has_future || version < "1.8.0") {
[17:42:09.398]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:09.398]                           "", base::R.version$version.string), 
[17:42:09.398]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:09.398]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:09.398]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:09.398]                             "release", "version")], collapse = " "), 
[17:42:09.398]                           hostname = base::Sys.info()[["nodename"]])
[17:42:09.398]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:09.398]                           info)
[17:42:09.398]                         info <- base::paste(info, collapse = "; ")
[17:42:09.398]                         if (!has_future) {
[17:42:09.398]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:09.398]                             info)
[17:42:09.398]                         }
[17:42:09.398]                         else {
[17:42:09.398]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:09.398]                             info, version)
[17:42:09.398]                         }
[17:42:09.398]                         base::stop(msg)
[17:42:09.398]                       }
[17:42:09.398]                     })
[17:42:09.398]                   }
[17:42:09.398]                   options(future.plan = NULL)
[17:42:09.398]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.398]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:09.398]                 }
[17:42:09.398]                 ...future.workdir <- getwd()
[17:42:09.398]             }
[17:42:09.398]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:09.398]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:09.398]         }
[17:42:09.398]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:09.398]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:09.398]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:09.398]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:09.398]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:09.398]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:09.398]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:09.398]             base::names(...future.oldOptions))
[17:42:09.398]     }
[17:42:09.398]     if (FALSE) {
[17:42:09.398]     }
[17:42:09.398]     else {
[17:42:09.398]         if (TRUE) {
[17:42:09.398]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:09.398]                 open = "w")
[17:42:09.398]         }
[17:42:09.398]         else {
[17:42:09.398]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:09.398]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:09.398]         }
[17:42:09.398]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:09.398]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:09.398]             base::sink(type = "output", split = FALSE)
[17:42:09.398]             base::close(...future.stdout)
[17:42:09.398]         }, add = TRUE)
[17:42:09.398]     }
[17:42:09.398]     ...future.frame <- base::sys.nframe()
[17:42:09.398]     ...future.conditions <- base::list()
[17:42:09.398]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:09.398]     if (FALSE) {
[17:42:09.398]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:09.398]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:09.398]     }
[17:42:09.398]     ...future.result <- base::tryCatch({
[17:42:09.398]         base::withCallingHandlers({
[17:42:09.398]             ...future.value <- base::withVisible(base::local({
[17:42:09.398]                 x <- 1
[17:42:09.398]             }))
[17:42:09.398]             future::FutureResult(value = ...future.value$value, 
[17:42:09.398]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.398]                   ...future.rng), globalenv = if (FALSE) 
[17:42:09.398]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:09.398]                     ...future.globalenv.names))
[17:42:09.398]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:09.398]         }, condition = base::local({
[17:42:09.398]             c <- base::c
[17:42:09.398]             inherits <- base::inherits
[17:42:09.398]             invokeRestart <- base::invokeRestart
[17:42:09.398]             length <- base::length
[17:42:09.398]             list <- base::list
[17:42:09.398]             seq.int <- base::seq.int
[17:42:09.398]             signalCondition <- base::signalCondition
[17:42:09.398]             sys.calls <- base::sys.calls
[17:42:09.398]             `[[` <- base::`[[`
[17:42:09.398]             `+` <- base::`+`
[17:42:09.398]             `<<-` <- base::`<<-`
[17:42:09.398]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:09.398]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:09.398]                   3L)]
[17:42:09.398]             }
[17:42:09.398]             function(cond) {
[17:42:09.398]                 is_error <- inherits(cond, "error")
[17:42:09.398]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:09.398]                   NULL)
[17:42:09.398]                 if (is_error) {
[17:42:09.398]                   sessionInformation <- function() {
[17:42:09.398]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:09.398]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:09.398]                       search = base::search(), system = base::Sys.info())
[17:42:09.398]                   }
[17:42:09.398]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.398]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:09.398]                     cond$call), session = sessionInformation(), 
[17:42:09.398]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:09.398]                   signalCondition(cond)
[17:42:09.398]                 }
[17:42:09.398]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:09.398]                 "immediateCondition"))) {
[17:42:09.398]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:09.398]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.398]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:09.398]                   if (TRUE && !signal) {
[17:42:09.398]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.398]                     {
[17:42:09.398]                       inherits <- base::inherits
[17:42:09.398]                       invokeRestart <- base::invokeRestart
[17:42:09.398]                       is.null <- base::is.null
[17:42:09.398]                       muffled <- FALSE
[17:42:09.398]                       if (inherits(cond, "message")) {
[17:42:09.398]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.398]                         if (muffled) 
[17:42:09.398]                           invokeRestart("muffleMessage")
[17:42:09.398]                       }
[17:42:09.398]                       else if (inherits(cond, "warning")) {
[17:42:09.398]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.398]                         if (muffled) 
[17:42:09.398]                           invokeRestart("muffleWarning")
[17:42:09.398]                       }
[17:42:09.398]                       else if (inherits(cond, "condition")) {
[17:42:09.398]                         if (!is.null(pattern)) {
[17:42:09.398]                           computeRestarts <- base::computeRestarts
[17:42:09.398]                           grepl <- base::grepl
[17:42:09.398]                           restarts <- computeRestarts(cond)
[17:42:09.398]                           for (restart in restarts) {
[17:42:09.398]                             name <- restart$name
[17:42:09.398]                             if (is.null(name)) 
[17:42:09.398]                               next
[17:42:09.398]                             if (!grepl(pattern, name)) 
[17:42:09.398]                               next
[17:42:09.398]                             invokeRestart(restart)
[17:42:09.398]                             muffled <- TRUE
[17:42:09.398]                             break
[17:42:09.398]                           }
[17:42:09.398]                         }
[17:42:09.398]                       }
[17:42:09.398]                       invisible(muffled)
[17:42:09.398]                     }
[17:42:09.398]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.398]                   }
[17:42:09.398]                 }
[17:42:09.398]                 else {
[17:42:09.398]                   if (TRUE) {
[17:42:09.398]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.398]                     {
[17:42:09.398]                       inherits <- base::inherits
[17:42:09.398]                       invokeRestart <- base::invokeRestart
[17:42:09.398]                       is.null <- base::is.null
[17:42:09.398]                       muffled <- FALSE
[17:42:09.398]                       if (inherits(cond, "message")) {
[17:42:09.398]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.398]                         if (muffled) 
[17:42:09.398]                           invokeRestart("muffleMessage")
[17:42:09.398]                       }
[17:42:09.398]                       else if (inherits(cond, "warning")) {
[17:42:09.398]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.398]                         if (muffled) 
[17:42:09.398]                           invokeRestart("muffleWarning")
[17:42:09.398]                       }
[17:42:09.398]                       else if (inherits(cond, "condition")) {
[17:42:09.398]                         if (!is.null(pattern)) {
[17:42:09.398]                           computeRestarts <- base::computeRestarts
[17:42:09.398]                           grepl <- base::grepl
[17:42:09.398]                           restarts <- computeRestarts(cond)
[17:42:09.398]                           for (restart in restarts) {
[17:42:09.398]                             name <- restart$name
[17:42:09.398]                             if (is.null(name)) 
[17:42:09.398]                               next
[17:42:09.398]                             if (!grepl(pattern, name)) 
[17:42:09.398]                               next
[17:42:09.398]                             invokeRestart(restart)
[17:42:09.398]                             muffled <- TRUE
[17:42:09.398]                             break
[17:42:09.398]                           }
[17:42:09.398]                         }
[17:42:09.398]                       }
[17:42:09.398]                       invisible(muffled)
[17:42:09.398]                     }
[17:42:09.398]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.398]                   }
[17:42:09.398]                 }
[17:42:09.398]             }
[17:42:09.398]         }))
[17:42:09.398]     }, error = function(ex) {
[17:42:09.398]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:09.398]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.398]                 ...future.rng), started = ...future.startTime, 
[17:42:09.398]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:09.398]             version = "1.8"), class = "FutureResult")
[17:42:09.398]     }, finally = {
[17:42:09.398]         if (!identical(...future.workdir, getwd())) 
[17:42:09.398]             setwd(...future.workdir)
[17:42:09.398]         {
[17:42:09.398]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:09.398]                 ...future.oldOptions$nwarnings <- NULL
[17:42:09.398]             }
[17:42:09.398]             base::options(...future.oldOptions)
[17:42:09.398]             if (.Platform$OS.type == "windows") {
[17:42:09.398]                 old_names <- names(...future.oldEnvVars)
[17:42:09.398]                 envs <- base::Sys.getenv()
[17:42:09.398]                 names <- names(envs)
[17:42:09.398]                 common <- intersect(names, old_names)
[17:42:09.398]                 added <- setdiff(names, old_names)
[17:42:09.398]                 removed <- setdiff(old_names, names)
[17:42:09.398]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:09.398]                   envs[common]]
[17:42:09.398]                 NAMES <- toupper(changed)
[17:42:09.398]                 args <- list()
[17:42:09.398]                 for (kk in seq_along(NAMES)) {
[17:42:09.398]                   name <- changed[[kk]]
[17:42:09.398]                   NAME <- NAMES[[kk]]
[17:42:09.398]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.398]                     next
[17:42:09.398]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.398]                 }
[17:42:09.398]                 NAMES <- toupper(added)
[17:42:09.398]                 for (kk in seq_along(NAMES)) {
[17:42:09.398]                   name <- added[[kk]]
[17:42:09.398]                   NAME <- NAMES[[kk]]
[17:42:09.398]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.398]                     next
[17:42:09.398]                   args[[name]] <- ""
[17:42:09.398]                 }
[17:42:09.398]                 NAMES <- toupper(removed)
[17:42:09.398]                 for (kk in seq_along(NAMES)) {
[17:42:09.398]                   name <- removed[[kk]]
[17:42:09.398]                   NAME <- NAMES[[kk]]
[17:42:09.398]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.398]                     next
[17:42:09.398]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.398]                 }
[17:42:09.398]                 if (length(args) > 0) 
[17:42:09.398]                   base::do.call(base::Sys.setenv, args = args)
[17:42:09.398]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:09.398]             }
[17:42:09.398]             else {
[17:42:09.398]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:09.398]             }
[17:42:09.398]             {
[17:42:09.398]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:09.398]                   0L) {
[17:42:09.398]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:09.398]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:09.398]                   base::options(opts)
[17:42:09.398]                 }
[17:42:09.398]                 {
[17:42:09.398]                   {
[17:42:09.398]                     NULL
[17:42:09.398]                     RNGkind("Mersenne-Twister")
[17:42:09.398]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:09.398]                       inherits = FALSE)
[17:42:09.398]                   }
[17:42:09.398]                   options(future.plan = NULL)
[17:42:09.398]                   if (is.na(NA_character_)) 
[17:42:09.398]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.398]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:09.398]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:09.398]                   {
[17:42:09.398]                     future <- SequentialFuture(..., envir = envir)
[17:42:09.398]                     if (!future$lazy) 
[17:42:09.398]                       future <- run(future)
[17:42:09.398]                     invisible(future)
[17:42:09.398]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:09.398]                 }
[17:42:09.398]             }
[17:42:09.398]         }
[17:42:09.398]     })
[17:42:09.398]     if (TRUE) {
[17:42:09.398]         base::sink(type = "output", split = FALSE)
[17:42:09.398]         if (TRUE) {
[17:42:09.398]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:09.398]         }
[17:42:09.398]         else {
[17:42:09.398]             ...future.result["stdout"] <- base::list(NULL)
[17:42:09.398]         }
[17:42:09.398]         base::close(...future.stdout)
[17:42:09.398]         ...future.stdout <- NULL
[17:42:09.398]     }
[17:42:09.398]     ...future.result$conditions <- ...future.conditions
[17:42:09.398]     ...future.result$finished <- base::Sys.time()
[17:42:09.398]     ...future.result
[17:42:09.398] }
[17:42:09.400] plan(): Setting new future strategy stack:
[17:42:09.400] List of future strategies:
[17:42:09.400] 1. sequential:
[17:42:09.400]    - args: function (..., envir = parent.frame())
[17:42:09.400]    - tweaked: FALSE
[17:42:09.400]    - call: NULL
[17:42:09.401] plan(): nbrOfWorkers() = 1
[17:42:09.402] plan(): Setting new future strategy stack:
[17:42:09.402] List of future strategies:
[17:42:09.402] 1. sequential:
[17:42:09.402]    - args: function (..., envir = parent.frame())
[17:42:09.402]    - tweaked: FALSE
[17:42:09.402]    - call: plan(strategy)
[17:42:09.402] plan(): nbrOfWorkers() = 1
[17:42:09.403] SequentialFuture started (and completed)
[17:42:09.403] - Launch lazy future ... done
[17:42:09.403] run() for ‘SequentialFuture’ ... done
** Future evaluation with globals
[17:42:09.404] getGlobalsAndPackages() ...
[17:42:09.404] Searching for globals...
[17:42:09.405] - globals found: [3] ‘{’, ‘<-’, ‘a’
[17:42:09.405] Searching for globals ... DONE
[17:42:09.405] Resolving globals: FALSE
[17:42:09.408] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:09.409] The total size of the 1 globals exported for future expression (‘{; x <- a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[17:42:09.409] - globals: [1] ‘a’
[17:42:09.409] 
[17:42:09.409] getGlobalsAndPackages() ... DONE
[17:42:09.409] run() for ‘Future’ ...
[17:42:09.410] - state: ‘created’
[17:42:09.410] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:09.410] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:09.410] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:09.410]   - Field: ‘label’
[17:42:09.410]   - Field: ‘local’
[17:42:09.410]   - Field: ‘owner’
[17:42:09.410]   - Field: ‘envir’
[17:42:09.411]   - Field: ‘packages’
[17:42:09.411]   - Field: ‘gc’
[17:42:09.411]   - Field: ‘conditions’
[17:42:09.411]   - Field: ‘expr’
[17:42:09.411]   - Field: ‘uuid’
[17:42:09.411]   - Field: ‘seed’
[17:42:09.411]   - Field: ‘version’
[17:42:09.411]   - Field: ‘result’
[17:42:09.411]   - Field: ‘asynchronous’
[17:42:09.411]   - Field: ‘calls’
[17:42:09.412]   - Field: ‘globals’
[17:42:09.412]   - Field: ‘stdout’
[17:42:09.412]   - Field: ‘earlySignal’
[17:42:09.412]   - Field: ‘lazy’
[17:42:09.412]   - Field: ‘state’
[17:42:09.412] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:09.412] - Launch lazy future ...
[17:42:09.412] Packages needed by the future expression (n = 0): <none>
[17:42:09.412] Packages needed by future strategies (n = 0): <none>
[17:42:09.413] {
[17:42:09.413]     {
[17:42:09.413]         {
[17:42:09.413]             ...future.startTime <- base::Sys.time()
[17:42:09.413]             {
[17:42:09.413]                 {
[17:42:09.413]                   {
[17:42:09.413]                     base::local({
[17:42:09.413]                       has_future <- base::requireNamespace("future", 
[17:42:09.413]                         quietly = TRUE)
[17:42:09.413]                       if (has_future) {
[17:42:09.413]                         ns <- base::getNamespace("future")
[17:42:09.413]                         version <- ns[[".package"]][["version"]]
[17:42:09.413]                         if (is.null(version)) 
[17:42:09.413]                           version <- utils::packageVersion("future")
[17:42:09.413]                       }
[17:42:09.413]                       else {
[17:42:09.413]                         version <- NULL
[17:42:09.413]                       }
[17:42:09.413]                       if (!has_future || version < "1.8.0") {
[17:42:09.413]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:09.413]                           "", base::R.version$version.string), 
[17:42:09.413]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:09.413]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:09.413]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:09.413]                             "release", "version")], collapse = " "), 
[17:42:09.413]                           hostname = base::Sys.info()[["nodename"]])
[17:42:09.413]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:09.413]                           info)
[17:42:09.413]                         info <- base::paste(info, collapse = "; ")
[17:42:09.413]                         if (!has_future) {
[17:42:09.413]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:09.413]                             info)
[17:42:09.413]                         }
[17:42:09.413]                         else {
[17:42:09.413]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:09.413]                             info, version)
[17:42:09.413]                         }
[17:42:09.413]                         base::stop(msg)
[17:42:09.413]                       }
[17:42:09.413]                     })
[17:42:09.413]                   }
[17:42:09.413]                   options(future.plan = NULL)
[17:42:09.413]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.413]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:09.413]                 }
[17:42:09.413]                 ...future.workdir <- getwd()
[17:42:09.413]             }
[17:42:09.413]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:09.413]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:09.413]         }
[17:42:09.413]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:09.413]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:09.413]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:09.413]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:09.413]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:09.413]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:09.413]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:09.413]             base::names(...future.oldOptions))
[17:42:09.413]     }
[17:42:09.413]     if (FALSE) {
[17:42:09.413]     }
[17:42:09.413]     else {
[17:42:09.413]         if (TRUE) {
[17:42:09.413]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:09.413]                 open = "w")
[17:42:09.413]         }
[17:42:09.413]         else {
[17:42:09.413]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:09.413]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:09.413]         }
[17:42:09.413]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:09.413]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:09.413]             base::sink(type = "output", split = FALSE)
[17:42:09.413]             base::close(...future.stdout)
[17:42:09.413]         }, add = TRUE)
[17:42:09.413]     }
[17:42:09.413]     ...future.frame <- base::sys.nframe()
[17:42:09.413]     ...future.conditions <- base::list()
[17:42:09.413]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:09.413]     if (FALSE) {
[17:42:09.413]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:09.413]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:09.413]     }
[17:42:09.413]     ...future.result <- base::tryCatch({
[17:42:09.413]         base::withCallingHandlers({
[17:42:09.413]             ...future.value <- base::withVisible(base::local({
[17:42:09.413]                 x <- a
[17:42:09.413]             }))
[17:42:09.413]             future::FutureResult(value = ...future.value$value, 
[17:42:09.413]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.413]                   ...future.rng), globalenv = if (FALSE) 
[17:42:09.413]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:09.413]                     ...future.globalenv.names))
[17:42:09.413]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:09.413]         }, condition = base::local({
[17:42:09.413]             c <- base::c
[17:42:09.413]             inherits <- base::inherits
[17:42:09.413]             invokeRestart <- base::invokeRestart
[17:42:09.413]             length <- base::length
[17:42:09.413]             list <- base::list
[17:42:09.413]             seq.int <- base::seq.int
[17:42:09.413]             signalCondition <- base::signalCondition
[17:42:09.413]             sys.calls <- base::sys.calls
[17:42:09.413]             `[[` <- base::`[[`
[17:42:09.413]             `+` <- base::`+`
[17:42:09.413]             `<<-` <- base::`<<-`
[17:42:09.413]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:09.413]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:09.413]                   3L)]
[17:42:09.413]             }
[17:42:09.413]             function(cond) {
[17:42:09.413]                 is_error <- inherits(cond, "error")
[17:42:09.413]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:09.413]                   NULL)
[17:42:09.413]                 if (is_error) {
[17:42:09.413]                   sessionInformation <- function() {
[17:42:09.413]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:09.413]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:09.413]                       search = base::search(), system = base::Sys.info())
[17:42:09.413]                   }
[17:42:09.413]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.413]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:09.413]                     cond$call), session = sessionInformation(), 
[17:42:09.413]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:09.413]                   signalCondition(cond)
[17:42:09.413]                 }
[17:42:09.413]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:09.413]                 "immediateCondition"))) {
[17:42:09.413]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:09.413]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.413]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:09.413]                   if (TRUE && !signal) {
[17:42:09.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.413]                     {
[17:42:09.413]                       inherits <- base::inherits
[17:42:09.413]                       invokeRestart <- base::invokeRestart
[17:42:09.413]                       is.null <- base::is.null
[17:42:09.413]                       muffled <- FALSE
[17:42:09.413]                       if (inherits(cond, "message")) {
[17:42:09.413]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.413]                         if (muffled) 
[17:42:09.413]                           invokeRestart("muffleMessage")
[17:42:09.413]                       }
[17:42:09.413]                       else if (inherits(cond, "warning")) {
[17:42:09.413]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.413]                         if (muffled) 
[17:42:09.413]                           invokeRestart("muffleWarning")
[17:42:09.413]                       }
[17:42:09.413]                       else if (inherits(cond, "condition")) {
[17:42:09.413]                         if (!is.null(pattern)) {
[17:42:09.413]                           computeRestarts <- base::computeRestarts
[17:42:09.413]                           grepl <- base::grepl
[17:42:09.413]                           restarts <- computeRestarts(cond)
[17:42:09.413]                           for (restart in restarts) {
[17:42:09.413]                             name <- restart$name
[17:42:09.413]                             if (is.null(name)) 
[17:42:09.413]                               next
[17:42:09.413]                             if (!grepl(pattern, name)) 
[17:42:09.413]                               next
[17:42:09.413]                             invokeRestart(restart)
[17:42:09.413]                             muffled <- TRUE
[17:42:09.413]                             break
[17:42:09.413]                           }
[17:42:09.413]                         }
[17:42:09.413]                       }
[17:42:09.413]                       invisible(muffled)
[17:42:09.413]                     }
[17:42:09.413]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.413]                   }
[17:42:09.413]                 }
[17:42:09.413]                 else {
[17:42:09.413]                   if (TRUE) {
[17:42:09.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.413]                     {
[17:42:09.413]                       inherits <- base::inherits
[17:42:09.413]                       invokeRestart <- base::invokeRestart
[17:42:09.413]                       is.null <- base::is.null
[17:42:09.413]                       muffled <- FALSE
[17:42:09.413]                       if (inherits(cond, "message")) {
[17:42:09.413]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.413]                         if (muffled) 
[17:42:09.413]                           invokeRestart("muffleMessage")
[17:42:09.413]                       }
[17:42:09.413]                       else if (inherits(cond, "warning")) {
[17:42:09.413]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.413]                         if (muffled) 
[17:42:09.413]                           invokeRestart("muffleWarning")
[17:42:09.413]                       }
[17:42:09.413]                       else if (inherits(cond, "condition")) {
[17:42:09.413]                         if (!is.null(pattern)) {
[17:42:09.413]                           computeRestarts <- base::computeRestarts
[17:42:09.413]                           grepl <- base::grepl
[17:42:09.413]                           restarts <- computeRestarts(cond)
[17:42:09.413]                           for (restart in restarts) {
[17:42:09.413]                             name <- restart$name
[17:42:09.413]                             if (is.null(name)) 
[17:42:09.413]                               next
[17:42:09.413]                             if (!grepl(pattern, name)) 
[17:42:09.413]                               next
[17:42:09.413]                             invokeRestart(restart)
[17:42:09.413]                             muffled <- TRUE
[17:42:09.413]                             break
[17:42:09.413]                           }
[17:42:09.413]                         }
[17:42:09.413]                       }
[17:42:09.413]                       invisible(muffled)
[17:42:09.413]                     }
[17:42:09.413]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.413]                   }
[17:42:09.413]                 }
[17:42:09.413]             }
[17:42:09.413]         }))
[17:42:09.413]     }, error = function(ex) {
[17:42:09.413]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:09.413]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.413]                 ...future.rng), started = ...future.startTime, 
[17:42:09.413]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:09.413]             version = "1.8"), class = "FutureResult")
[17:42:09.413]     }, finally = {
[17:42:09.413]         if (!identical(...future.workdir, getwd())) 
[17:42:09.413]             setwd(...future.workdir)
[17:42:09.413]         {
[17:42:09.413]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:09.413]                 ...future.oldOptions$nwarnings <- NULL
[17:42:09.413]             }
[17:42:09.413]             base::options(...future.oldOptions)
[17:42:09.413]             if (.Platform$OS.type == "windows") {
[17:42:09.413]                 old_names <- names(...future.oldEnvVars)
[17:42:09.413]                 envs <- base::Sys.getenv()
[17:42:09.413]                 names <- names(envs)
[17:42:09.413]                 common <- intersect(names, old_names)
[17:42:09.413]                 added <- setdiff(names, old_names)
[17:42:09.413]                 removed <- setdiff(old_names, names)
[17:42:09.413]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:09.413]                   envs[common]]
[17:42:09.413]                 NAMES <- toupper(changed)
[17:42:09.413]                 args <- list()
[17:42:09.413]                 for (kk in seq_along(NAMES)) {
[17:42:09.413]                   name <- changed[[kk]]
[17:42:09.413]                   NAME <- NAMES[[kk]]
[17:42:09.413]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.413]                     next
[17:42:09.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.413]                 }
[17:42:09.413]                 NAMES <- toupper(added)
[17:42:09.413]                 for (kk in seq_along(NAMES)) {
[17:42:09.413]                   name <- added[[kk]]
[17:42:09.413]                   NAME <- NAMES[[kk]]
[17:42:09.413]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.413]                     next
[17:42:09.413]                   args[[name]] <- ""
[17:42:09.413]                 }
[17:42:09.413]                 NAMES <- toupper(removed)
[17:42:09.413]                 for (kk in seq_along(NAMES)) {
[17:42:09.413]                   name <- removed[[kk]]
[17:42:09.413]                   NAME <- NAMES[[kk]]
[17:42:09.413]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.413]                     next
[17:42:09.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.413]                 }
[17:42:09.413]                 if (length(args) > 0) 
[17:42:09.413]                   base::do.call(base::Sys.setenv, args = args)
[17:42:09.413]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:09.413]             }
[17:42:09.413]             else {
[17:42:09.413]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:09.413]             }
[17:42:09.413]             {
[17:42:09.413]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:09.413]                   0L) {
[17:42:09.413]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:09.413]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:09.413]                   base::options(opts)
[17:42:09.413]                 }
[17:42:09.413]                 {
[17:42:09.413]                   {
[17:42:09.413]                     NULL
[17:42:09.413]                     RNGkind("Mersenne-Twister")
[17:42:09.413]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:09.413]                       inherits = FALSE)
[17:42:09.413]                   }
[17:42:09.413]                   options(future.plan = NULL)
[17:42:09.413]                   if (is.na(NA_character_)) 
[17:42:09.413]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.413]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:09.413]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:09.413]                   {
[17:42:09.413]                     future <- SequentialFuture(..., envir = envir)
[17:42:09.413]                     if (!future$lazy) 
[17:42:09.413]                       future <- run(future)
[17:42:09.413]                     invisible(future)
[17:42:09.413]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:09.413]                 }
[17:42:09.413]             }
[17:42:09.413]         }
[17:42:09.413]     })
[17:42:09.413]     if (TRUE) {
[17:42:09.413]         base::sink(type = "output", split = FALSE)
[17:42:09.413]         if (TRUE) {
[17:42:09.413]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:09.413]         }
[17:42:09.413]         else {
[17:42:09.413]             ...future.result["stdout"] <- base::list(NULL)
[17:42:09.413]         }
[17:42:09.413]         base::close(...future.stdout)
[17:42:09.413]         ...future.stdout <- NULL
[17:42:09.413]     }
[17:42:09.413]     ...future.result$conditions <- ...future.conditions
[17:42:09.413]     ...future.result$finished <- base::Sys.time()
[17:42:09.413]     ...future.result
[17:42:09.413] }
[17:42:09.414] assign_globals() ...
[17:42:09.415] List of 1
[17:42:09.415]  $ a: num 2
[17:42:09.415]  - attr(*, "where")=List of 1
[17:42:09.415]   ..$ a:<environment: R_EmptyEnv> 
[17:42:09.415]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:09.415]  - attr(*, "resolved")= logi FALSE
[17:42:09.415]  - attr(*, "total_size")= num 56
[17:42:09.415]  - attr(*, "already-done")= logi TRUE
[17:42:09.419] - copied ‘a’ to environment
[17:42:09.420] assign_globals() ... done
[17:42:09.420] plan(): Setting new future strategy stack:
[17:42:09.420] List of future strategies:
[17:42:09.420] 1. sequential:
[17:42:09.420]    - args: function (..., envir = parent.frame())
[17:42:09.420]    - tweaked: FALSE
[17:42:09.420]    - call: NULL
[17:42:09.420] plan(): nbrOfWorkers() = 1
[17:42:09.421] plan(): Setting new future strategy stack:
[17:42:09.421] List of future strategies:
[17:42:09.421] 1. sequential:
[17:42:09.421]    - args: function (..., envir = parent.frame())
[17:42:09.421]    - tweaked: FALSE
[17:42:09.421]    - call: plan(strategy)
[17:42:09.421] plan(): nbrOfWorkers() = 1
[17:42:09.422] SequentialFuture started (and completed)
[17:42:09.422] - Launch lazy future ... done
[17:42:09.422] run() for ‘SequentialFuture’ ... done
** Future evaluation with errors
[17:42:09.422] getGlobalsAndPackages() ...
[17:42:09.422] Searching for globals...
[17:42:09.426] - globals found: [3] ‘{’, ‘<-’, ‘stop’
[17:42:09.426] Searching for globals ... DONE
[17:42:09.426] Resolving globals: FALSE
[17:42:09.426] 
[17:42:09.426] 
[17:42:09.426] getGlobalsAndPackages() ... DONE
[17:42:09.427] run() for ‘Future’ ...
[17:42:09.427] - state: ‘created’
[17:42:09.427] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:09.427] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:09.427] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:09.427]   - Field: ‘label’
[17:42:09.428]   - Field: ‘local’
[17:42:09.428]   - Field: ‘owner’
[17:42:09.428]   - Field: ‘envir’
[17:42:09.428]   - Field: ‘packages’
[17:42:09.428]   - Field: ‘gc’
[17:42:09.428]   - Field: ‘conditions’
[17:42:09.428]   - Field: ‘expr’
[17:42:09.428]   - Field: ‘uuid’
[17:42:09.428]   - Field: ‘seed’
[17:42:09.428]   - Field: ‘version’
[17:42:09.428]   - Field: ‘result’
[17:42:09.429]   - Field: ‘asynchronous’
[17:42:09.429]   - Field: ‘calls’
[17:42:09.429]   - Field: ‘globals’
[17:42:09.429]   - Field: ‘stdout’
[17:42:09.429]   - Field: ‘earlySignal’
[17:42:09.429]   - Field: ‘lazy’
[17:42:09.429]   - Field: ‘state’
[17:42:09.429] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:09.429] - Launch lazy future ...
[17:42:09.429] Packages needed by the future expression (n = 0): <none>
[17:42:09.430] Packages needed by future strategies (n = 0): <none>
[17:42:09.430] {
[17:42:09.430]     {
[17:42:09.430]         {
[17:42:09.430]             ...future.startTime <- base::Sys.time()
[17:42:09.430]             {
[17:42:09.430]                 {
[17:42:09.430]                   {
[17:42:09.430]                     base::local({
[17:42:09.430]                       has_future <- base::requireNamespace("future", 
[17:42:09.430]                         quietly = TRUE)
[17:42:09.430]                       if (has_future) {
[17:42:09.430]                         ns <- base::getNamespace("future")
[17:42:09.430]                         version <- ns[[".package"]][["version"]]
[17:42:09.430]                         if (is.null(version)) 
[17:42:09.430]                           version <- utils::packageVersion("future")
[17:42:09.430]                       }
[17:42:09.430]                       else {
[17:42:09.430]                         version <- NULL
[17:42:09.430]                       }
[17:42:09.430]                       if (!has_future || version < "1.8.0") {
[17:42:09.430]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:09.430]                           "", base::R.version$version.string), 
[17:42:09.430]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:09.430]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:09.430]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:09.430]                             "release", "version")], collapse = " "), 
[17:42:09.430]                           hostname = base::Sys.info()[["nodename"]])
[17:42:09.430]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:09.430]                           info)
[17:42:09.430]                         info <- base::paste(info, collapse = "; ")
[17:42:09.430]                         if (!has_future) {
[17:42:09.430]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:09.430]                             info)
[17:42:09.430]                         }
[17:42:09.430]                         else {
[17:42:09.430]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:09.430]                             info, version)
[17:42:09.430]                         }
[17:42:09.430]                         base::stop(msg)
[17:42:09.430]                       }
[17:42:09.430]                     })
[17:42:09.430]                   }
[17:42:09.430]                   options(future.plan = NULL)
[17:42:09.430]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.430]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:09.430]                 }
[17:42:09.430]                 ...future.workdir <- getwd()
[17:42:09.430]             }
[17:42:09.430]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:09.430]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:09.430]         }
[17:42:09.430]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:09.430]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:09.430]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:09.430]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:09.430]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:09.430]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:09.430]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:09.430]             base::names(...future.oldOptions))
[17:42:09.430]     }
[17:42:09.430]     if (FALSE) {
[17:42:09.430]     }
[17:42:09.430]     else {
[17:42:09.430]         if (TRUE) {
[17:42:09.430]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:09.430]                 open = "w")
[17:42:09.430]         }
[17:42:09.430]         else {
[17:42:09.430]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:09.430]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:09.430]         }
[17:42:09.430]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:09.430]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:09.430]             base::sink(type = "output", split = FALSE)
[17:42:09.430]             base::close(...future.stdout)
[17:42:09.430]         }, add = TRUE)
[17:42:09.430]     }
[17:42:09.430]     ...future.frame <- base::sys.nframe()
[17:42:09.430]     ...future.conditions <- base::list()
[17:42:09.430]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:09.430]     if (FALSE) {
[17:42:09.430]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:09.430]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:09.430]     }
[17:42:09.430]     ...future.result <- base::tryCatch({
[17:42:09.430]         base::withCallingHandlers({
[17:42:09.430]             ...future.value <- base::withVisible(base::local({
[17:42:09.430]                 x <- 3
[17:42:09.430]                 stop("Woops!")
[17:42:09.430]                 x
[17:42:09.430]             }))
[17:42:09.430]             future::FutureResult(value = ...future.value$value, 
[17:42:09.430]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.430]                   ...future.rng), globalenv = if (FALSE) 
[17:42:09.430]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:09.430]                     ...future.globalenv.names))
[17:42:09.430]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:09.430]         }, condition = base::local({
[17:42:09.430]             c <- base::c
[17:42:09.430]             inherits <- base::inherits
[17:42:09.430]             invokeRestart <- base::invokeRestart
[17:42:09.430]             length <- base::length
[17:42:09.430]             list <- base::list
[17:42:09.430]             seq.int <- base::seq.int
[17:42:09.430]             signalCondition <- base::signalCondition
[17:42:09.430]             sys.calls <- base::sys.calls
[17:42:09.430]             `[[` <- base::`[[`
[17:42:09.430]             `+` <- base::`+`
[17:42:09.430]             `<<-` <- base::`<<-`
[17:42:09.430]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:09.430]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:09.430]                   3L)]
[17:42:09.430]             }
[17:42:09.430]             function(cond) {
[17:42:09.430]                 is_error <- inherits(cond, "error")
[17:42:09.430]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:09.430]                   NULL)
[17:42:09.430]                 if (is_error) {
[17:42:09.430]                   sessionInformation <- function() {
[17:42:09.430]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:09.430]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:09.430]                       search = base::search(), system = base::Sys.info())
[17:42:09.430]                   }
[17:42:09.430]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.430]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:09.430]                     cond$call), session = sessionInformation(), 
[17:42:09.430]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:09.430]                   signalCondition(cond)
[17:42:09.430]                 }
[17:42:09.430]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:09.430]                 "immediateCondition"))) {
[17:42:09.430]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:09.430]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.430]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:09.430]                   if (TRUE && !signal) {
[17:42:09.430]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.430]                     {
[17:42:09.430]                       inherits <- base::inherits
[17:42:09.430]                       invokeRestart <- base::invokeRestart
[17:42:09.430]                       is.null <- base::is.null
[17:42:09.430]                       muffled <- FALSE
[17:42:09.430]                       if (inherits(cond, "message")) {
[17:42:09.430]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.430]                         if (muffled) 
[17:42:09.430]                           invokeRestart("muffleMessage")
[17:42:09.430]                       }
[17:42:09.430]                       else if (inherits(cond, "warning")) {
[17:42:09.430]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.430]                         if (muffled) 
[17:42:09.430]                           invokeRestart("muffleWarning")
[17:42:09.430]                       }
[17:42:09.430]                       else if (inherits(cond, "condition")) {
[17:42:09.430]                         if (!is.null(pattern)) {
[17:42:09.430]                           computeRestarts <- base::computeRestarts
[17:42:09.430]                           grepl <- base::grepl
[17:42:09.430]                           restarts <- computeRestarts(cond)
[17:42:09.430]                           for (restart in restarts) {
[17:42:09.430]                             name <- restart$name
[17:42:09.430]                             if (is.null(name)) 
[17:42:09.430]                               next
[17:42:09.430]                             if (!grepl(pattern, name)) 
[17:42:09.430]                               next
[17:42:09.430]                             invokeRestart(restart)
[17:42:09.430]                             muffled <- TRUE
[17:42:09.430]                             break
[17:42:09.430]                           }
[17:42:09.430]                         }
[17:42:09.430]                       }
[17:42:09.430]                       invisible(muffled)
[17:42:09.430]                     }
[17:42:09.430]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.430]                   }
[17:42:09.430]                 }
[17:42:09.430]                 else {
[17:42:09.430]                   if (TRUE) {
[17:42:09.430]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.430]                     {
[17:42:09.430]                       inherits <- base::inherits
[17:42:09.430]                       invokeRestart <- base::invokeRestart
[17:42:09.430]                       is.null <- base::is.null
[17:42:09.430]                       muffled <- FALSE
[17:42:09.430]                       if (inherits(cond, "message")) {
[17:42:09.430]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.430]                         if (muffled) 
[17:42:09.430]                           invokeRestart("muffleMessage")
[17:42:09.430]                       }
[17:42:09.430]                       else if (inherits(cond, "warning")) {
[17:42:09.430]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.430]                         if (muffled) 
[17:42:09.430]                           invokeRestart("muffleWarning")
[17:42:09.430]                       }
[17:42:09.430]                       else if (inherits(cond, "condition")) {
[17:42:09.430]                         if (!is.null(pattern)) {
[17:42:09.430]                           computeRestarts <- base::computeRestarts
[17:42:09.430]                           grepl <- base::grepl
[17:42:09.430]                           restarts <- computeRestarts(cond)
[17:42:09.430]                           for (restart in restarts) {
[17:42:09.430]                             name <- restart$name
[17:42:09.430]                             if (is.null(name)) 
[17:42:09.430]                               next
[17:42:09.430]                             if (!grepl(pattern, name)) 
[17:42:09.430]                               next
[17:42:09.430]                             invokeRestart(restart)
[17:42:09.430]                             muffled <- TRUE
[17:42:09.430]                             break
[17:42:09.430]                           }
[17:42:09.430]                         }
[17:42:09.430]                       }
[17:42:09.430]                       invisible(muffled)
[17:42:09.430]                     }
[17:42:09.430]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.430]                   }
[17:42:09.430]                 }
[17:42:09.430]             }
[17:42:09.430]         }))
[17:42:09.430]     }, error = function(ex) {
[17:42:09.430]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:09.430]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.430]                 ...future.rng), started = ...future.startTime, 
[17:42:09.430]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:09.430]             version = "1.8"), class = "FutureResult")
[17:42:09.430]     }, finally = {
[17:42:09.430]         if (!identical(...future.workdir, getwd())) 
[17:42:09.430]             setwd(...future.workdir)
[17:42:09.430]         {
[17:42:09.430]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:09.430]                 ...future.oldOptions$nwarnings <- NULL
[17:42:09.430]             }
[17:42:09.430]             base::options(...future.oldOptions)
[17:42:09.430]             if (.Platform$OS.type == "windows") {
[17:42:09.430]                 old_names <- names(...future.oldEnvVars)
[17:42:09.430]                 envs <- base::Sys.getenv()
[17:42:09.430]                 names <- names(envs)
[17:42:09.430]                 common <- intersect(names, old_names)
[17:42:09.430]                 added <- setdiff(names, old_names)
[17:42:09.430]                 removed <- setdiff(old_names, names)
[17:42:09.430]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:09.430]                   envs[common]]
[17:42:09.430]                 NAMES <- toupper(changed)
[17:42:09.430]                 args <- list()
[17:42:09.430]                 for (kk in seq_along(NAMES)) {
[17:42:09.430]                   name <- changed[[kk]]
[17:42:09.430]                   NAME <- NAMES[[kk]]
[17:42:09.430]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.430]                     next
[17:42:09.430]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.430]                 }
[17:42:09.430]                 NAMES <- toupper(added)
[17:42:09.430]                 for (kk in seq_along(NAMES)) {
[17:42:09.430]                   name <- added[[kk]]
[17:42:09.430]                   NAME <- NAMES[[kk]]
[17:42:09.430]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.430]                     next
[17:42:09.430]                   args[[name]] <- ""
[17:42:09.430]                 }
[17:42:09.430]                 NAMES <- toupper(removed)
[17:42:09.430]                 for (kk in seq_along(NAMES)) {
[17:42:09.430]                   name <- removed[[kk]]
[17:42:09.430]                   NAME <- NAMES[[kk]]
[17:42:09.430]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.430]                     next
[17:42:09.430]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.430]                 }
[17:42:09.430]                 if (length(args) > 0) 
[17:42:09.430]                   base::do.call(base::Sys.setenv, args = args)
[17:42:09.430]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:09.430]             }
[17:42:09.430]             else {
[17:42:09.430]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:09.430]             }
[17:42:09.430]             {
[17:42:09.430]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:09.430]                   0L) {
[17:42:09.430]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:09.430]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:09.430]                   base::options(opts)
[17:42:09.430]                 }
[17:42:09.430]                 {
[17:42:09.430]                   {
[17:42:09.430]                     NULL
[17:42:09.430]                     RNGkind("Mersenne-Twister")
[17:42:09.430]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:09.430]                       inherits = FALSE)
[17:42:09.430]                   }
[17:42:09.430]                   options(future.plan = NULL)
[17:42:09.430]                   if (is.na(NA_character_)) 
[17:42:09.430]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.430]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:09.430]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:09.430]                   {
[17:42:09.430]                     future <- SequentialFuture(..., envir = envir)
[17:42:09.430]                     if (!future$lazy) 
[17:42:09.430]                       future <- run(future)
[17:42:09.430]                     invisible(future)
[17:42:09.430]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:09.430]                 }
[17:42:09.430]             }
[17:42:09.430]         }
[17:42:09.430]     })
[17:42:09.430]     if (TRUE) {
[17:42:09.430]         base::sink(type = "output", split = FALSE)
[17:42:09.430]         if (TRUE) {
[17:42:09.430]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:09.430]         }
[17:42:09.430]         else {
[17:42:09.430]             ...future.result["stdout"] <- base::list(NULL)
[17:42:09.430]         }
[17:42:09.430]         base::close(...future.stdout)
[17:42:09.430]         ...future.stdout <- NULL
[17:42:09.430]     }
[17:42:09.430]     ...future.result$conditions <- ...future.conditions
[17:42:09.430]     ...future.result$finished <- base::Sys.time()
[17:42:09.430]     ...future.result
[17:42:09.430] }
[17:42:09.432] plan(): Setting new future strategy stack:
[17:42:09.432] List of future strategies:
[17:42:09.432] 1. sequential:
[17:42:09.432]    - args: function (..., envir = parent.frame())
[17:42:09.432]    - tweaked: FALSE
[17:42:09.432]    - call: NULL
[17:42:09.432] plan(): nbrOfWorkers() = 1
[17:42:09.433] plan(): Setting new future strategy stack:
[17:42:09.433] List of future strategies:
[17:42:09.433] 1. sequential:
[17:42:09.433]    - args: function (..., envir = parent.frame())
[17:42:09.433]    - tweaked: FALSE
[17:42:09.433]    - call: plan(strategy)
[17:42:09.434] plan(): nbrOfWorkers() = 1
[17:42:09.434] SequentialFuture started (and completed)
[17:42:09.434] signalConditions() ...
[17:42:09.434]  - include = ‘immediateCondition’
[17:42:09.434]  - exclude = 
[17:42:09.434]  - resignal = FALSE
[17:42:09.434]  - Number of conditions: 1
[17:42:09.434] signalConditions() ... done
[17:42:09.435] - Launch lazy future ... done
[17:42:09.435] run() for ‘SequentialFuture’ ... done
[17:42:09.435] signalConditions() ...
[17:42:09.435]  - include = ‘immediateCondition’
[17:42:09.435]  - exclude = 
[17:42:09.435]  - resignal = FALSE
[17:42:09.435]  - Number of conditions: 1
[17:42:09.435] signalConditions() ... done
[17:42:09.435] Future state: ‘finished’
[17:42:09.435] signalConditions() ...
[17:42:09.436]  - include = ‘condition’
[17:42:09.436]  - exclude = ‘immediateCondition’
[17:42:09.436]  - resignal = TRUE
[17:42:09.436]  - Number of conditions: 1
[17:42:09.436]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:42:09.436] signalConditions() ... done
[17:42:09.437] getGlobalsAndPackages() ...
[17:42:09.437] Searching for globals...
[17:42:09.441] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[17:42:09.441] Searching for globals ... DONE
[17:42:09.441] Resolving globals: FALSE
[17:42:09.441] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:09.442] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:42:09.442] - globals: [1] ‘ii’
[17:42:09.442] 
[17:42:09.442] getGlobalsAndPackages() ... DONE
[17:42:09.442] run() for ‘Future’ ...
[17:42:09.442] - state: ‘created’
[17:42:09.442] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:09.443] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:09.443] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:09.443]   - Field: ‘label’
[17:42:09.443]   - Field: ‘local’
[17:42:09.443]   - Field: ‘owner’
[17:42:09.443]   - Field: ‘envir’
[17:42:09.443]   - Field: ‘packages’
[17:42:09.443]   - Field: ‘gc’
[17:42:09.444]   - Field: ‘conditions’
[17:42:09.444]   - Field: ‘expr’
[17:42:09.444]   - Field: ‘uuid’
[17:42:09.444]   - Field: ‘seed’
[17:42:09.444]   - Field: ‘version’
[17:42:09.444]   - Field: ‘result’
[17:42:09.444]   - Field: ‘asynchronous’
[17:42:09.444]   - Field: ‘calls’
[17:42:09.444]   - Field: ‘globals’
[17:42:09.444]   - Field: ‘stdout’
[17:42:09.444]   - Field: ‘earlySignal’
[17:42:09.445]   - Field: ‘lazy’
[17:42:09.445]   - Field: ‘state’
[17:42:09.445] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:09.445] - Launch lazy future ...
[17:42:09.445] Packages needed by the future expression (n = 0): <none>
[17:42:09.445] Packages needed by future strategies (n = 0): <none>
[17:42:09.446] {
[17:42:09.446]     {
[17:42:09.446]         {
[17:42:09.446]             ...future.startTime <- base::Sys.time()
[17:42:09.446]             {
[17:42:09.446]                 {
[17:42:09.446]                   {
[17:42:09.446]                     base::local({
[17:42:09.446]                       has_future <- base::requireNamespace("future", 
[17:42:09.446]                         quietly = TRUE)
[17:42:09.446]                       if (has_future) {
[17:42:09.446]                         ns <- base::getNamespace("future")
[17:42:09.446]                         version <- ns[[".package"]][["version"]]
[17:42:09.446]                         if (is.null(version)) 
[17:42:09.446]                           version <- utils::packageVersion("future")
[17:42:09.446]                       }
[17:42:09.446]                       else {
[17:42:09.446]                         version <- NULL
[17:42:09.446]                       }
[17:42:09.446]                       if (!has_future || version < "1.8.0") {
[17:42:09.446]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:09.446]                           "", base::R.version$version.string), 
[17:42:09.446]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:09.446]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:09.446]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:09.446]                             "release", "version")], collapse = " "), 
[17:42:09.446]                           hostname = base::Sys.info()[["nodename"]])
[17:42:09.446]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:09.446]                           info)
[17:42:09.446]                         info <- base::paste(info, collapse = "; ")
[17:42:09.446]                         if (!has_future) {
[17:42:09.446]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:09.446]                             info)
[17:42:09.446]                         }
[17:42:09.446]                         else {
[17:42:09.446]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:09.446]                             info, version)
[17:42:09.446]                         }
[17:42:09.446]                         base::stop(msg)
[17:42:09.446]                       }
[17:42:09.446]                     })
[17:42:09.446]                   }
[17:42:09.446]                   options(future.plan = NULL)
[17:42:09.446]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.446]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:09.446]                 }
[17:42:09.446]                 ...future.workdir <- getwd()
[17:42:09.446]             }
[17:42:09.446]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:09.446]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:09.446]         }
[17:42:09.446]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:09.446]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:09.446]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:09.446]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:09.446]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:09.446]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:09.446]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:09.446]             base::names(...future.oldOptions))
[17:42:09.446]     }
[17:42:09.446]     if (FALSE) {
[17:42:09.446]     }
[17:42:09.446]     else {
[17:42:09.446]         if (TRUE) {
[17:42:09.446]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:09.446]                 open = "w")
[17:42:09.446]         }
[17:42:09.446]         else {
[17:42:09.446]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:09.446]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:09.446]         }
[17:42:09.446]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:09.446]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:09.446]             base::sink(type = "output", split = FALSE)
[17:42:09.446]             base::close(...future.stdout)
[17:42:09.446]         }, add = TRUE)
[17:42:09.446]     }
[17:42:09.446]     ...future.frame <- base::sys.nframe()
[17:42:09.446]     ...future.conditions <- base::list()
[17:42:09.446]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:09.446]     if (FALSE) {
[17:42:09.446]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:09.446]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:09.446]     }
[17:42:09.446]     ...future.result <- base::tryCatch({
[17:42:09.446]         base::withCallingHandlers({
[17:42:09.446]             ...future.value <- base::withVisible(base::local({
[17:42:09.446]                 if (ii%%2 == 0) 
[17:42:09.446]                   stop("Woops!")
[17:42:09.446]                 ii
[17:42:09.446]             }))
[17:42:09.446]             future::FutureResult(value = ...future.value$value, 
[17:42:09.446]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.446]                   ...future.rng), globalenv = if (FALSE) 
[17:42:09.446]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:09.446]                     ...future.globalenv.names))
[17:42:09.446]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:09.446]         }, condition = base::local({
[17:42:09.446]             c <- base::c
[17:42:09.446]             inherits <- base::inherits
[17:42:09.446]             invokeRestart <- base::invokeRestart
[17:42:09.446]             length <- base::length
[17:42:09.446]             list <- base::list
[17:42:09.446]             seq.int <- base::seq.int
[17:42:09.446]             signalCondition <- base::signalCondition
[17:42:09.446]             sys.calls <- base::sys.calls
[17:42:09.446]             `[[` <- base::`[[`
[17:42:09.446]             `+` <- base::`+`
[17:42:09.446]             `<<-` <- base::`<<-`
[17:42:09.446]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:09.446]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:09.446]                   3L)]
[17:42:09.446]             }
[17:42:09.446]             function(cond) {
[17:42:09.446]                 is_error <- inherits(cond, "error")
[17:42:09.446]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:09.446]                   NULL)
[17:42:09.446]                 if (is_error) {
[17:42:09.446]                   sessionInformation <- function() {
[17:42:09.446]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:09.446]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:09.446]                       search = base::search(), system = base::Sys.info())
[17:42:09.446]                   }
[17:42:09.446]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.446]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:09.446]                     cond$call), session = sessionInformation(), 
[17:42:09.446]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:09.446]                   signalCondition(cond)
[17:42:09.446]                 }
[17:42:09.446]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:09.446]                 "immediateCondition"))) {
[17:42:09.446]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:09.446]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.446]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:09.446]                   if (TRUE && !signal) {
[17:42:09.446]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.446]                     {
[17:42:09.446]                       inherits <- base::inherits
[17:42:09.446]                       invokeRestart <- base::invokeRestart
[17:42:09.446]                       is.null <- base::is.null
[17:42:09.446]                       muffled <- FALSE
[17:42:09.446]                       if (inherits(cond, "message")) {
[17:42:09.446]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.446]                         if (muffled) 
[17:42:09.446]                           invokeRestart("muffleMessage")
[17:42:09.446]                       }
[17:42:09.446]                       else if (inherits(cond, "warning")) {
[17:42:09.446]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.446]                         if (muffled) 
[17:42:09.446]                           invokeRestart("muffleWarning")
[17:42:09.446]                       }
[17:42:09.446]                       else if (inherits(cond, "condition")) {
[17:42:09.446]                         if (!is.null(pattern)) {
[17:42:09.446]                           computeRestarts <- base::computeRestarts
[17:42:09.446]                           grepl <- base::grepl
[17:42:09.446]                           restarts <- computeRestarts(cond)
[17:42:09.446]                           for (restart in restarts) {
[17:42:09.446]                             name <- restart$name
[17:42:09.446]                             if (is.null(name)) 
[17:42:09.446]                               next
[17:42:09.446]                             if (!grepl(pattern, name)) 
[17:42:09.446]                               next
[17:42:09.446]                             invokeRestart(restart)
[17:42:09.446]                             muffled <- TRUE
[17:42:09.446]                             break
[17:42:09.446]                           }
[17:42:09.446]                         }
[17:42:09.446]                       }
[17:42:09.446]                       invisible(muffled)
[17:42:09.446]                     }
[17:42:09.446]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.446]                   }
[17:42:09.446]                 }
[17:42:09.446]                 else {
[17:42:09.446]                   if (TRUE) {
[17:42:09.446]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.446]                     {
[17:42:09.446]                       inherits <- base::inherits
[17:42:09.446]                       invokeRestart <- base::invokeRestart
[17:42:09.446]                       is.null <- base::is.null
[17:42:09.446]                       muffled <- FALSE
[17:42:09.446]                       if (inherits(cond, "message")) {
[17:42:09.446]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.446]                         if (muffled) 
[17:42:09.446]                           invokeRestart("muffleMessage")
[17:42:09.446]                       }
[17:42:09.446]                       else if (inherits(cond, "warning")) {
[17:42:09.446]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.446]                         if (muffled) 
[17:42:09.446]                           invokeRestart("muffleWarning")
[17:42:09.446]                       }
[17:42:09.446]                       else if (inherits(cond, "condition")) {
[17:42:09.446]                         if (!is.null(pattern)) {
[17:42:09.446]                           computeRestarts <- base::computeRestarts
[17:42:09.446]                           grepl <- base::grepl
[17:42:09.446]                           restarts <- computeRestarts(cond)
[17:42:09.446]                           for (restart in restarts) {
[17:42:09.446]                             name <- restart$name
[17:42:09.446]                             if (is.null(name)) 
[17:42:09.446]                               next
[17:42:09.446]                             if (!grepl(pattern, name)) 
[17:42:09.446]                               next
[17:42:09.446]                             invokeRestart(restart)
[17:42:09.446]                             muffled <- TRUE
[17:42:09.446]                             break
[17:42:09.446]                           }
[17:42:09.446]                         }
[17:42:09.446]                       }
[17:42:09.446]                       invisible(muffled)
[17:42:09.446]                     }
[17:42:09.446]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.446]                   }
[17:42:09.446]                 }
[17:42:09.446]             }
[17:42:09.446]         }))
[17:42:09.446]     }, error = function(ex) {
[17:42:09.446]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:09.446]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.446]                 ...future.rng), started = ...future.startTime, 
[17:42:09.446]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:09.446]             version = "1.8"), class = "FutureResult")
[17:42:09.446]     }, finally = {
[17:42:09.446]         if (!identical(...future.workdir, getwd())) 
[17:42:09.446]             setwd(...future.workdir)
[17:42:09.446]         {
[17:42:09.446]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:09.446]                 ...future.oldOptions$nwarnings <- NULL
[17:42:09.446]             }
[17:42:09.446]             base::options(...future.oldOptions)
[17:42:09.446]             if (.Platform$OS.type == "windows") {
[17:42:09.446]                 old_names <- names(...future.oldEnvVars)
[17:42:09.446]                 envs <- base::Sys.getenv()
[17:42:09.446]                 names <- names(envs)
[17:42:09.446]                 common <- intersect(names, old_names)
[17:42:09.446]                 added <- setdiff(names, old_names)
[17:42:09.446]                 removed <- setdiff(old_names, names)
[17:42:09.446]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:09.446]                   envs[common]]
[17:42:09.446]                 NAMES <- toupper(changed)
[17:42:09.446]                 args <- list()
[17:42:09.446]                 for (kk in seq_along(NAMES)) {
[17:42:09.446]                   name <- changed[[kk]]
[17:42:09.446]                   NAME <- NAMES[[kk]]
[17:42:09.446]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.446]                     next
[17:42:09.446]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.446]                 }
[17:42:09.446]                 NAMES <- toupper(added)
[17:42:09.446]                 for (kk in seq_along(NAMES)) {
[17:42:09.446]                   name <- added[[kk]]
[17:42:09.446]                   NAME <- NAMES[[kk]]
[17:42:09.446]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.446]                     next
[17:42:09.446]                   args[[name]] <- ""
[17:42:09.446]                 }
[17:42:09.446]                 NAMES <- toupper(removed)
[17:42:09.446]                 for (kk in seq_along(NAMES)) {
[17:42:09.446]                   name <- removed[[kk]]
[17:42:09.446]                   NAME <- NAMES[[kk]]
[17:42:09.446]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.446]                     next
[17:42:09.446]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.446]                 }
[17:42:09.446]                 if (length(args) > 0) 
[17:42:09.446]                   base::do.call(base::Sys.setenv, args = args)
[17:42:09.446]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:09.446]             }
[17:42:09.446]             else {
[17:42:09.446]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:09.446]             }
[17:42:09.446]             {
[17:42:09.446]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:09.446]                   0L) {
[17:42:09.446]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:09.446]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:09.446]                   base::options(opts)
[17:42:09.446]                 }
[17:42:09.446]                 {
[17:42:09.446]                   {
[17:42:09.446]                     NULL
[17:42:09.446]                     RNGkind("Mersenne-Twister")
[17:42:09.446]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:09.446]                       inherits = FALSE)
[17:42:09.446]                   }
[17:42:09.446]                   options(future.plan = NULL)
[17:42:09.446]                   if (is.na(NA_character_)) 
[17:42:09.446]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.446]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:09.446]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:09.446]                   {
[17:42:09.446]                     future <- SequentialFuture(..., envir = envir)
[17:42:09.446]                     if (!future$lazy) 
[17:42:09.446]                       future <- run(future)
[17:42:09.446]                     invisible(future)
[17:42:09.446]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:09.446]                 }
[17:42:09.446]             }
[17:42:09.446]         }
[17:42:09.446]     })
[17:42:09.446]     if (TRUE) {
[17:42:09.446]         base::sink(type = "output", split = FALSE)
[17:42:09.446]         if (TRUE) {
[17:42:09.446]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:09.446]         }
[17:42:09.446]         else {
[17:42:09.446]             ...future.result["stdout"] <- base::list(NULL)
[17:42:09.446]         }
[17:42:09.446]         base::close(...future.stdout)
[17:42:09.446]         ...future.stdout <- NULL
[17:42:09.446]     }
[17:42:09.446]     ...future.result$conditions <- ...future.conditions
[17:42:09.446]     ...future.result$finished <- base::Sys.time()
[17:42:09.446]     ...future.result
[17:42:09.446] }
[17:42:09.447] assign_globals() ...
[17:42:09.447] List of 1
[17:42:09.447]  $ ii: int 1
[17:42:09.447]  - attr(*, "where")=List of 1
[17:42:09.447]   ..$ ii:<environment: R_EmptyEnv> 
[17:42:09.447]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:09.447]  - attr(*, "resolved")= logi FALSE
[17:42:09.447]  - attr(*, "total_size")= num 56
[17:42:09.447]  - attr(*, "already-done")= logi TRUE
[17:42:09.450] - copied ‘ii’ to environment
[17:42:09.450] assign_globals() ... done
[17:42:09.450] plan(): Setting new future strategy stack:
[17:42:09.450] List of future strategies:
[17:42:09.450] 1. sequential:
[17:42:09.450]    - args: function (..., envir = parent.frame())
[17:42:09.450]    - tweaked: FALSE
[17:42:09.450]    - call: NULL
[17:42:09.451] plan(): nbrOfWorkers() = 1
[17:42:09.451] plan(): Setting new future strategy stack:
[17:42:09.451] List of future strategies:
[17:42:09.451] 1. sequential:
[17:42:09.451]    - args: function (..., envir = parent.frame())
[17:42:09.451]    - tweaked: FALSE
[17:42:09.451]    - call: plan(strategy)
[17:42:09.452] plan(): nbrOfWorkers() = 1
[17:42:09.452] SequentialFuture started (and completed)
[17:42:09.452] - Launch lazy future ... done
[17:42:09.453] run() for ‘SequentialFuture’ ... done
[17:42:09.453] getGlobalsAndPackages() ...
[17:42:09.453] Searching for globals...
[17:42:09.455] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[17:42:09.455] Searching for globals ... DONE
[17:42:09.455] Resolving globals: FALSE
[17:42:09.455] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:09.456] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:42:09.456] - globals: [1] ‘ii’
[17:42:09.456] 
[17:42:09.456] getGlobalsAndPackages() ... DONE
[17:42:09.456] run() for ‘Future’ ...
[17:42:09.456] - state: ‘created’
[17:42:09.457] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:09.457] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:09.457] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:09.457]   - Field: ‘label’
[17:42:09.457]   - Field: ‘local’
[17:42:09.457]   - Field: ‘owner’
[17:42:09.457]   - Field: ‘envir’
[17:42:09.457]   - Field: ‘packages’
[17:42:09.458]   - Field: ‘gc’
[17:42:09.458]   - Field: ‘conditions’
[17:42:09.458]   - Field: ‘expr’
[17:42:09.458]   - Field: ‘uuid’
[17:42:09.458]   - Field: ‘seed’
[17:42:09.458]   - Field: ‘version’
[17:42:09.458]   - Field: ‘result’
[17:42:09.458]   - Field: ‘asynchronous’
[17:42:09.458]   - Field: ‘calls’
[17:42:09.458]   - Field: ‘globals’
[17:42:09.458]   - Field: ‘stdout’
[17:42:09.459]   - Field: ‘earlySignal’
[17:42:09.459]   - Field: ‘lazy’
[17:42:09.459]   - Field: ‘state’
[17:42:09.459] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:09.459] - Launch lazy future ...
[17:42:09.459] Packages needed by the future expression (n = 0): <none>
[17:42:09.459] Packages needed by future strategies (n = 0): <none>
[17:42:09.460] {
[17:42:09.460]     {
[17:42:09.460]         {
[17:42:09.460]             ...future.startTime <- base::Sys.time()
[17:42:09.460]             {
[17:42:09.460]                 {
[17:42:09.460]                   {
[17:42:09.460]                     base::local({
[17:42:09.460]                       has_future <- base::requireNamespace("future", 
[17:42:09.460]                         quietly = TRUE)
[17:42:09.460]                       if (has_future) {
[17:42:09.460]                         ns <- base::getNamespace("future")
[17:42:09.460]                         version <- ns[[".package"]][["version"]]
[17:42:09.460]                         if (is.null(version)) 
[17:42:09.460]                           version <- utils::packageVersion("future")
[17:42:09.460]                       }
[17:42:09.460]                       else {
[17:42:09.460]                         version <- NULL
[17:42:09.460]                       }
[17:42:09.460]                       if (!has_future || version < "1.8.0") {
[17:42:09.460]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:09.460]                           "", base::R.version$version.string), 
[17:42:09.460]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:09.460]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:09.460]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:09.460]                             "release", "version")], collapse = " "), 
[17:42:09.460]                           hostname = base::Sys.info()[["nodename"]])
[17:42:09.460]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:09.460]                           info)
[17:42:09.460]                         info <- base::paste(info, collapse = "; ")
[17:42:09.460]                         if (!has_future) {
[17:42:09.460]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:09.460]                             info)
[17:42:09.460]                         }
[17:42:09.460]                         else {
[17:42:09.460]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:09.460]                             info, version)
[17:42:09.460]                         }
[17:42:09.460]                         base::stop(msg)
[17:42:09.460]                       }
[17:42:09.460]                     })
[17:42:09.460]                   }
[17:42:09.460]                   options(future.plan = NULL)
[17:42:09.460]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.460]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:09.460]                 }
[17:42:09.460]                 ...future.workdir <- getwd()
[17:42:09.460]             }
[17:42:09.460]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:09.460]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:09.460]         }
[17:42:09.460]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:09.460]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:09.460]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:09.460]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:09.460]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:09.460]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:09.460]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:09.460]             base::names(...future.oldOptions))
[17:42:09.460]     }
[17:42:09.460]     if (FALSE) {
[17:42:09.460]     }
[17:42:09.460]     else {
[17:42:09.460]         if (TRUE) {
[17:42:09.460]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:09.460]                 open = "w")
[17:42:09.460]         }
[17:42:09.460]         else {
[17:42:09.460]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:09.460]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:09.460]         }
[17:42:09.460]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:09.460]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:09.460]             base::sink(type = "output", split = FALSE)
[17:42:09.460]             base::close(...future.stdout)
[17:42:09.460]         }, add = TRUE)
[17:42:09.460]     }
[17:42:09.460]     ...future.frame <- base::sys.nframe()
[17:42:09.460]     ...future.conditions <- base::list()
[17:42:09.460]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:09.460]     if (FALSE) {
[17:42:09.460]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:09.460]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:09.460]     }
[17:42:09.460]     ...future.result <- base::tryCatch({
[17:42:09.460]         base::withCallingHandlers({
[17:42:09.460]             ...future.value <- base::withVisible(base::local({
[17:42:09.460]                 if (ii%%2 == 0) 
[17:42:09.460]                   stop("Woops!")
[17:42:09.460]                 ii
[17:42:09.460]             }))
[17:42:09.460]             future::FutureResult(value = ...future.value$value, 
[17:42:09.460]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.460]                   ...future.rng), globalenv = if (FALSE) 
[17:42:09.460]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:09.460]                     ...future.globalenv.names))
[17:42:09.460]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:09.460]         }, condition = base::local({
[17:42:09.460]             c <- base::c
[17:42:09.460]             inherits <- base::inherits
[17:42:09.460]             invokeRestart <- base::invokeRestart
[17:42:09.460]             length <- base::length
[17:42:09.460]             list <- base::list
[17:42:09.460]             seq.int <- base::seq.int
[17:42:09.460]             signalCondition <- base::signalCondition
[17:42:09.460]             sys.calls <- base::sys.calls
[17:42:09.460]             `[[` <- base::`[[`
[17:42:09.460]             `+` <- base::`+`
[17:42:09.460]             `<<-` <- base::`<<-`
[17:42:09.460]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:09.460]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:09.460]                   3L)]
[17:42:09.460]             }
[17:42:09.460]             function(cond) {
[17:42:09.460]                 is_error <- inherits(cond, "error")
[17:42:09.460]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:09.460]                   NULL)
[17:42:09.460]                 if (is_error) {
[17:42:09.460]                   sessionInformation <- function() {
[17:42:09.460]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:09.460]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:09.460]                       search = base::search(), system = base::Sys.info())
[17:42:09.460]                   }
[17:42:09.460]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.460]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:09.460]                     cond$call), session = sessionInformation(), 
[17:42:09.460]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:09.460]                   signalCondition(cond)
[17:42:09.460]                 }
[17:42:09.460]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:09.460]                 "immediateCondition"))) {
[17:42:09.460]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:09.460]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.460]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:09.460]                   if (TRUE && !signal) {
[17:42:09.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.460]                     {
[17:42:09.460]                       inherits <- base::inherits
[17:42:09.460]                       invokeRestart <- base::invokeRestart
[17:42:09.460]                       is.null <- base::is.null
[17:42:09.460]                       muffled <- FALSE
[17:42:09.460]                       if (inherits(cond, "message")) {
[17:42:09.460]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.460]                         if (muffled) 
[17:42:09.460]                           invokeRestart("muffleMessage")
[17:42:09.460]                       }
[17:42:09.460]                       else if (inherits(cond, "warning")) {
[17:42:09.460]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.460]                         if (muffled) 
[17:42:09.460]                           invokeRestart("muffleWarning")
[17:42:09.460]                       }
[17:42:09.460]                       else if (inherits(cond, "condition")) {
[17:42:09.460]                         if (!is.null(pattern)) {
[17:42:09.460]                           computeRestarts <- base::computeRestarts
[17:42:09.460]                           grepl <- base::grepl
[17:42:09.460]                           restarts <- computeRestarts(cond)
[17:42:09.460]                           for (restart in restarts) {
[17:42:09.460]                             name <- restart$name
[17:42:09.460]                             if (is.null(name)) 
[17:42:09.460]                               next
[17:42:09.460]                             if (!grepl(pattern, name)) 
[17:42:09.460]                               next
[17:42:09.460]                             invokeRestart(restart)
[17:42:09.460]                             muffled <- TRUE
[17:42:09.460]                             break
[17:42:09.460]                           }
[17:42:09.460]                         }
[17:42:09.460]                       }
[17:42:09.460]                       invisible(muffled)
[17:42:09.460]                     }
[17:42:09.460]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.460]                   }
[17:42:09.460]                 }
[17:42:09.460]                 else {
[17:42:09.460]                   if (TRUE) {
[17:42:09.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.460]                     {
[17:42:09.460]                       inherits <- base::inherits
[17:42:09.460]                       invokeRestart <- base::invokeRestart
[17:42:09.460]                       is.null <- base::is.null
[17:42:09.460]                       muffled <- FALSE
[17:42:09.460]                       if (inherits(cond, "message")) {
[17:42:09.460]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.460]                         if (muffled) 
[17:42:09.460]                           invokeRestart("muffleMessage")
[17:42:09.460]                       }
[17:42:09.460]                       else if (inherits(cond, "warning")) {
[17:42:09.460]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.460]                         if (muffled) 
[17:42:09.460]                           invokeRestart("muffleWarning")
[17:42:09.460]                       }
[17:42:09.460]                       else if (inherits(cond, "condition")) {
[17:42:09.460]                         if (!is.null(pattern)) {
[17:42:09.460]                           computeRestarts <- base::computeRestarts
[17:42:09.460]                           grepl <- base::grepl
[17:42:09.460]                           restarts <- computeRestarts(cond)
[17:42:09.460]                           for (restart in restarts) {
[17:42:09.460]                             name <- restart$name
[17:42:09.460]                             if (is.null(name)) 
[17:42:09.460]                               next
[17:42:09.460]                             if (!grepl(pattern, name)) 
[17:42:09.460]                               next
[17:42:09.460]                             invokeRestart(restart)
[17:42:09.460]                             muffled <- TRUE
[17:42:09.460]                             break
[17:42:09.460]                           }
[17:42:09.460]                         }
[17:42:09.460]                       }
[17:42:09.460]                       invisible(muffled)
[17:42:09.460]                     }
[17:42:09.460]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.460]                   }
[17:42:09.460]                 }
[17:42:09.460]             }
[17:42:09.460]         }))
[17:42:09.460]     }, error = function(ex) {
[17:42:09.460]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:09.460]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.460]                 ...future.rng), started = ...future.startTime, 
[17:42:09.460]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:09.460]             version = "1.8"), class = "FutureResult")
[17:42:09.460]     }, finally = {
[17:42:09.460]         if (!identical(...future.workdir, getwd())) 
[17:42:09.460]             setwd(...future.workdir)
[17:42:09.460]         {
[17:42:09.460]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:09.460]                 ...future.oldOptions$nwarnings <- NULL
[17:42:09.460]             }
[17:42:09.460]             base::options(...future.oldOptions)
[17:42:09.460]             if (.Platform$OS.type == "windows") {
[17:42:09.460]                 old_names <- names(...future.oldEnvVars)
[17:42:09.460]                 envs <- base::Sys.getenv()
[17:42:09.460]                 names <- names(envs)
[17:42:09.460]                 common <- intersect(names, old_names)
[17:42:09.460]                 added <- setdiff(names, old_names)
[17:42:09.460]                 removed <- setdiff(old_names, names)
[17:42:09.460]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:09.460]                   envs[common]]
[17:42:09.460]                 NAMES <- toupper(changed)
[17:42:09.460]                 args <- list()
[17:42:09.460]                 for (kk in seq_along(NAMES)) {
[17:42:09.460]                   name <- changed[[kk]]
[17:42:09.460]                   NAME <- NAMES[[kk]]
[17:42:09.460]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.460]                     next
[17:42:09.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.460]                 }
[17:42:09.460]                 NAMES <- toupper(added)
[17:42:09.460]                 for (kk in seq_along(NAMES)) {
[17:42:09.460]                   name <- added[[kk]]
[17:42:09.460]                   NAME <- NAMES[[kk]]
[17:42:09.460]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.460]                     next
[17:42:09.460]                   args[[name]] <- ""
[17:42:09.460]                 }
[17:42:09.460]                 NAMES <- toupper(removed)
[17:42:09.460]                 for (kk in seq_along(NAMES)) {
[17:42:09.460]                   name <- removed[[kk]]
[17:42:09.460]                   NAME <- NAMES[[kk]]
[17:42:09.460]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.460]                     next
[17:42:09.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.460]                 }
[17:42:09.460]                 if (length(args) > 0) 
[17:42:09.460]                   base::do.call(base::Sys.setenv, args = args)
[17:42:09.460]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:09.460]             }
[17:42:09.460]             else {
[17:42:09.460]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:09.460]             }
[17:42:09.460]             {
[17:42:09.460]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:09.460]                   0L) {
[17:42:09.460]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:09.460]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:09.460]                   base::options(opts)
[17:42:09.460]                 }
[17:42:09.460]                 {
[17:42:09.460]                   {
[17:42:09.460]                     NULL
[17:42:09.460]                     RNGkind("Mersenne-Twister")
[17:42:09.460]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:09.460]                       inherits = FALSE)
[17:42:09.460]                   }
[17:42:09.460]                   options(future.plan = NULL)
[17:42:09.460]                   if (is.na(NA_character_)) 
[17:42:09.460]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.460]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:09.460]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:09.460]                   {
[17:42:09.460]                     future <- SequentialFuture(..., envir = envir)
[17:42:09.460]                     if (!future$lazy) 
[17:42:09.460]                       future <- run(future)
[17:42:09.460]                     invisible(future)
[17:42:09.460]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:09.460]                 }
[17:42:09.460]             }
[17:42:09.460]         }
[17:42:09.460]     })
[17:42:09.460]     if (TRUE) {
[17:42:09.460]         base::sink(type = "output", split = FALSE)
[17:42:09.460]         if (TRUE) {
[17:42:09.460]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:09.460]         }
[17:42:09.460]         else {
[17:42:09.460]             ...future.result["stdout"] <- base::list(NULL)
[17:42:09.460]         }
[17:42:09.460]         base::close(...future.stdout)
[17:42:09.460]         ...future.stdout <- NULL
[17:42:09.460]     }
[17:42:09.460]     ...future.result$conditions <- ...future.conditions
[17:42:09.460]     ...future.result$finished <- base::Sys.time()
[17:42:09.460]     ...future.result
[17:42:09.460] }
[17:42:09.461] assign_globals() ...
[17:42:09.461] List of 1
[17:42:09.461]  $ ii: int 2
[17:42:09.461]  - attr(*, "where")=List of 1
[17:42:09.461]   ..$ ii:<environment: R_EmptyEnv> 
[17:42:09.461]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:09.461]  - attr(*, "resolved")= logi FALSE
[17:42:09.461]  - attr(*, "total_size")= num 56
[17:42:09.461]  - attr(*, "already-done")= logi TRUE
[17:42:09.464] - copied ‘ii’ to environment
[17:42:09.464] assign_globals() ... done
[17:42:09.464] plan(): Setting new future strategy stack:
[17:42:09.464] List of future strategies:
[17:42:09.464] 1. sequential:
[17:42:09.464]    - args: function (..., envir = parent.frame())
[17:42:09.464]    - tweaked: FALSE
[17:42:09.464]    - call: NULL
[17:42:09.465] plan(): nbrOfWorkers() = 1
[17:42:09.466] plan(): Setting new future strategy stack:
[17:42:09.466] List of future strategies:
[17:42:09.466] 1. sequential:
[17:42:09.466]    - args: function (..., envir = parent.frame())
[17:42:09.466]    - tweaked: FALSE
[17:42:09.466]    - call: plan(strategy)
[17:42:09.466] plan(): nbrOfWorkers() = 1
[17:42:09.466] SequentialFuture started (and completed)
[17:42:09.466] signalConditions() ...
[17:42:09.467]  - include = ‘immediateCondition’
[17:42:09.467]  - exclude = 
[17:42:09.467]  - resignal = FALSE
[17:42:09.467]  - Number of conditions: 1
[17:42:09.467] signalConditions() ... done
[17:42:09.467] - Launch lazy future ... done
[17:42:09.467] run() for ‘SequentialFuture’ ... done
[17:42:09.468] getGlobalsAndPackages() ...
[17:42:09.468] Searching for globals...
[17:42:09.471] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[17:42:09.471] Searching for globals ... DONE
[17:42:09.471] Resolving globals: FALSE
[17:42:09.472] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:09.472] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:42:09.472] - globals: [1] ‘ii’
[17:42:09.472] 
[17:42:09.473] getGlobalsAndPackages() ... DONE
[17:42:09.473] run() for ‘Future’ ...
[17:42:09.473] - state: ‘created’
[17:42:09.473] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:09.473] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:09.473] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:09.474]   - Field: ‘label’
[17:42:09.474]   - Field: ‘local’
[17:42:09.474]   - Field: ‘owner’
[17:42:09.474]   - Field: ‘envir’
[17:42:09.474]   - Field: ‘packages’
[17:42:09.474]   - Field: ‘gc’
[17:42:09.474]   - Field: ‘conditions’
[17:42:09.474]   - Field: ‘expr’
[17:42:09.474]   - Field: ‘uuid’
[17:42:09.474]   - Field: ‘seed’
[17:42:09.475]   - Field: ‘version’
[17:42:09.475]   - Field: ‘result’
[17:42:09.475]   - Field: ‘asynchronous’
[17:42:09.475]   - Field: ‘calls’
[17:42:09.475]   - Field: ‘globals’
[17:42:09.475]   - Field: ‘stdout’
[17:42:09.475]   - Field: ‘earlySignal’
[17:42:09.475]   - Field: ‘lazy’
[17:42:09.475]   - Field: ‘state’
[17:42:09.475] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:09.476] - Launch lazy future ...
[17:42:09.476] Packages needed by the future expression (n = 0): <none>
[17:42:09.476] Packages needed by future strategies (n = 0): <none>
[17:42:09.476] {
[17:42:09.476]     {
[17:42:09.476]         {
[17:42:09.476]             ...future.startTime <- base::Sys.time()
[17:42:09.476]             {
[17:42:09.476]                 {
[17:42:09.476]                   {
[17:42:09.476]                     base::local({
[17:42:09.476]                       has_future <- base::requireNamespace("future", 
[17:42:09.476]                         quietly = TRUE)
[17:42:09.476]                       if (has_future) {
[17:42:09.476]                         ns <- base::getNamespace("future")
[17:42:09.476]                         version <- ns[[".package"]][["version"]]
[17:42:09.476]                         if (is.null(version)) 
[17:42:09.476]                           version <- utils::packageVersion("future")
[17:42:09.476]                       }
[17:42:09.476]                       else {
[17:42:09.476]                         version <- NULL
[17:42:09.476]                       }
[17:42:09.476]                       if (!has_future || version < "1.8.0") {
[17:42:09.476]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:09.476]                           "", base::R.version$version.string), 
[17:42:09.476]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:09.476]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:09.476]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:09.476]                             "release", "version")], collapse = " "), 
[17:42:09.476]                           hostname = base::Sys.info()[["nodename"]])
[17:42:09.476]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:09.476]                           info)
[17:42:09.476]                         info <- base::paste(info, collapse = "; ")
[17:42:09.476]                         if (!has_future) {
[17:42:09.476]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:09.476]                             info)
[17:42:09.476]                         }
[17:42:09.476]                         else {
[17:42:09.476]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:09.476]                             info, version)
[17:42:09.476]                         }
[17:42:09.476]                         base::stop(msg)
[17:42:09.476]                       }
[17:42:09.476]                     })
[17:42:09.476]                   }
[17:42:09.476]                   options(future.plan = NULL)
[17:42:09.476]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.476]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:09.476]                 }
[17:42:09.476]                 ...future.workdir <- getwd()
[17:42:09.476]             }
[17:42:09.476]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:09.476]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:09.476]         }
[17:42:09.476]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:09.476]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:09.476]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:09.476]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:09.476]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:09.476]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:09.476]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:09.476]             base::names(...future.oldOptions))
[17:42:09.476]     }
[17:42:09.476]     if (FALSE) {
[17:42:09.476]     }
[17:42:09.476]     else {
[17:42:09.476]         if (TRUE) {
[17:42:09.476]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:09.476]                 open = "w")
[17:42:09.476]         }
[17:42:09.476]         else {
[17:42:09.476]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:09.476]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:09.476]         }
[17:42:09.476]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:09.476]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:09.476]             base::sink(type = "output", split = FALSE)
[17:42:09.476]             base::close(...future.stdout)
[17:42:09.476]         }, add = TRUE)
[17:42:09.476]     }
[17:42:09.476]     ...future.frame <- base::sys.nframe()
[17:42:09.476]     ...future.conditions <- base::list()
[17:42:09.476]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:09.476]     if (FALSE) {
[17:42:09.476]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:09.476]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:09.476]     }
[17:42:09.476]     ...future.result <- base::tryCatch({
[17:42:09.476]         base::withCallingHandlers({
[17:42:09.476]             ...future.value <- base::withVisible(base::local({
[17:42:09.476]                 if (ii%%2 == 0) 
[17:42:09.476]                   stop("Woops!")
[17:42:09.476]                 ii
[17:42:09.476]             }))
[17:42:09.476]             future::FutureResult(value = ...future.value$value, 
[17:42:09.476]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.476]                   ...future.rng), globalenv = if (FALSE) 
[17:42:09.476]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:09.476]                     ...future.globalenv.names))
[17:42:09.476]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:09.476]         }, condition = base::local({
[17:42:09.476]             c <- base::c
[17:42:09.476]             inherits <- base::inherits
[17:42:09.476]             invokeRestart <- base::invokeRestart
[17:42:09.476]             length <- base::length
[17:42:09.476]             list <- base::list
[17:42:09.476]             seq.int <- base::seq.int
[17:42:09.476]             signalCondition <- base::signalCondition
[17:42:09.476]             sys.calls <- base::sys.calls
[17:42:09.476]             `[[` <- base::`[[`
[17:42:09.476]             `+` <- base::`+`
[17:42:09.476]             `<<-` <- base::`<<-`
[17:42:09.476]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:09.476]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:09.476]                   3L)]
[17:42:09.476]             }
[17:42:09.476]             function(cond) {
[17:42:09.476]                 is_error <- inherits(cond, "error")
[17:42:09.476]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:09.476]                   NULL)
[17:42:09.476]                 if (is_error) {
[17:42:09.476]                   sessionInformation <- function() {
[17:42:09.476]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:09.476]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:09.476]                       search = base::search(), system = base::Sys.info())
[17:42:09.476]                   }
[17:42:09.476]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.476]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:09.476]                     cond$call), session = sessionInformation(), 
[17:42:09.476]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:09.476]                   signalCondition(cond)
[17:42:09.476]                 }
[17:42:09.476]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:09.476]                 "immediateCondition"))) {
[17:42:09.476]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:09.476]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.476]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:09.476]                   if (TRUE && !signal) {
[17:42:09.476]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.476]                     {
[17:42:09.476]                       inherits <- base::inherits
[17:42:09.476]                       invokeRestart <- base::invokeRestart
[17:42:09.476]                       is.null <- base::is.null
[17:42:09.476]                       muffled <- FALSE
[17:42:09.476]                       if (inherits(cond, "message")) {
[17:42:09.476]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.476]                         if (muffled) 
[17:42:09.476]                           invokeRestart("muffleMessage")
[17:42:09.476]                       }
[17:42:09.476]                       else if (inherits(cond, "warning")) {
[17:42:09.476]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.476]                         if (muffled) 
[17:42:09.476]                           invokeRestart("muffleWarning")
[17:42:09.476]                       }
[17:42:09.476]                       else if (inherits(cond, "condition")) {
[17:42:09.476]                         if (!is.null(pattern)) {
[17:42:09.476]                           computeRestarts <- base::computeRestarts
[17:42:09.476]                           grepl <- base::grepl
[17:42:09.476]                           restarts <- computeRestarts(cond)
[17:42:09.476]                           for (restart in restarts) {
[17:42:09.476]                             name <- restart$name
[17:42:09.476]                             if (is.null(name)) 
[17:42:09.476]                               next
[17:42:09.476]                             if (!grepl(pattern, name)) 
[17:42:09.476]                               next
[17:42:09.476]                             invokeRestart(restart)
[17:42:09.476]                             muffled <- TRUE
[17:42:09.476]                             break
[17:42:09.476]                           }
[17:42:09.476]                         }
[17:42:09.476]                       }
[17:42:09.476]                       invisible(muffled)
[17:42:09.476]                     }
[17:42:09.476]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.476]                   }
[17:42:09.476]                 }
[17:42:09.476]                 else {
[17:42:09.476]                   if (TRUE) {
[17:42:09.476]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.476]                     {
[17:42:09.476]                       inherits <- base::inherits
[17:42:09.476]                       invokeRestart <- base::invokeRestart
[17:42:09.476]                       is.null <- base::is.null
[17:42:09.476]                       muffled <- FALSE
[17:42:09.476]                       if (inherits(cond, "message")) {
[17:42:09.476]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.476]                         if (muffled) 
[17:42:09.476]                           invokeRestart("muffleMessage")
[17:42:09.476]                       }
[17:42:09.476]                       else if (inherits(cond, "warning")) {
[17:42:09.476]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.476]                         if (muffled) 
[17:42:09.476]                           invokeRestart("muffleWarning")
[17:42:09.476]                       }
[17:42:09.476]                       else if (inherits(cond, "condition")) {
[17:42:09.476]                         if (!is.null(pattern)) {
[17:42:09.476]                           computeRestarts <- base::computeRestarts
[17:42:09.476]                           grepl <- base::grepl
[17:42:09.476]                           restarts <- computeRestarts(cond)
[17:42:09.476]                           for (restart in restarts) {
[17:42:09.476]                             name <- restart$name
[17:42:09.476]                             if (is.null(name)) 
[17:42:09.476]                               next
[17:42:09.476]                             if (!grepl(pattern, name)) 
[17:42:09.476]                               next
[17:42:09.476]                             invokeRestart(restart)
[17:42:09.476]                             muffled <- TRUE
[17:42:09.476]                             break
[17:42:09.476]                           }
[17:42:09.476]                         }
[17:42:09.476]                       }
[17:42:09.476]                       invisible(muffled)
[17:42:09.476]                     }
[17:42:09.476]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.476]                   }
[17:42:09.476]                 }
[17:42:09.476]             }
[17:42:09.476]         }))
[17:42:09.476]     }, error = function(ex) {
[17:42:09.476]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:09.476]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.476]                 ...future.rng), started = ...future.startTime, 
[17:42:09.476]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:09.476]             version = "1.8"), class = "FutureResult")
[17:42:09.476]     }, finally = {
[17:42:09.476]         if (!identical(...future.workdir, getwd())) 
[17:42:09.476]             setwd(...future.workdir)
[17:42:09.476]         {
[17:42:09.476]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:09.476]                 ...future.oldOptions$nwarnings <- NULL
[17:42:09.476]             }
[17:42:09.476]             base::options(...future.oldOptions)
[17:42:09.476]             if (.Platform$OS.type == "windows") {
[17:42:09.476]                 old_names <- names(...future.oldEnvVars)
[17:42:09.476]                 envs <- base::Sys.getenv()
[17:42:09.476]                 names <- names(envs)
[17:42:09.476]                 common <- intersect(names, old_names)
[17:42:09.476]                 added <- setdiff(names, old_names)
[17:42:09.476]                 removed <- setdiff(old_names, names)
[17:42:09.476]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:09.476]                   envs[common]]
[17:42:09.476]                 NAMES <- toupper(changed)
[17:42:09.476]                 args <- list()
[17:42:09.476]                 for (kk in seq_along(NAMES)) {
[17:42:09.476]                   name <- changed[[kk]]
[17:42:09.476]                   NAME <- NAMES[[kk]]
[17:42:09.476]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.476]                     next
[17:42:09.476]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.476]                 }
[17:42:09.476]                 NAMES <- toupper(added)
[17:42:09.476]                 for (kk in seq_along(NAMES)) {
[17:42:09.476]                   name <- added[[kk]]
[17:42:09.476]                   NAME <- NAMES[[kk]]
[17:42:09.476]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.476]                     next
[17:42:09.476]                   args[[name]] <- ""
[17:42:09.476]                 }
[17:42:09.476]                 NAMES <- toupper(removed)
[17:42:09.476]                 for (kk in seq_along(NAMES)) {
[17:42:09.476]                   name <- removed[[kk]]
[17:42:09.476]                   NAME <- NAMES[[kk]]
[17:42:09.476]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.476]                     next
[17:42:09.476]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.476]                 }
[17:42:09.476]                 if (length(args) > 0) 
[17:42:09.476]                   base::do.call(base::Sys.setenv, args = args)
[17:42:09.476]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:09.476]             }
[17:42:09.476]             else {
[17:42:09.476]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:09.476]             }
[17:42:09.476]             {
[17:42:09.476]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:09.476]                   0L) {
[17:42:09.476]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:09.476]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:09.476]                   base::options(opts)
[17:42:09.476]                 }
[17:42:09.476]                 {
[17:42:09.476]                   {
[17:42:09.476]                     NULL
[17:42:09.476]                     RNGkind("Mersenne-Twister")
[17:42:09.476]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:09.476]                       inherits = FALSE)
[17:42:09.476]                   }
[17:42:09.476]                   options(future.plan = NULL)
[17:42:09.476]                   if (is.na(NA_character_)) 
[17:42:09.476]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.476]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:09.476]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:09.476]                   {
[17:42:09.476]                     future <- SequentialFuture(..., envir = envir)
[17:42:09.476]                     if (!future$lazy) 
[17:42:09.476]                       future <- run(future)
[17:42:09.476]                     invisible(future)
[17:42:09.476]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:09.476]                 }
[17:42:09.476]             }
[17:42:09.476]         }
[17:42:09.476]     })
[17:42:09.476]     if (TRUE) {
[17:42:09.476]         base::sink(type = "output", split = FALSE)
[17:42:09.476]         if (TRUE) {
[17:42:09.476]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:09.476]         }
[17:42:09.476]         else {
[17:42:09.476]             ...future.result["stdout"] <- base::list(NULL)
[17:42:09.476]         }
[17:42:09.476]         base::close(...future.stdout)
[17:42:09.476]         ...future.stdout <- NULL
[17:42:09.476]     }
[17:42:09.476]     ...future.result$conditions <- ...future.conditions
[17:42:09.476]     ...future.result$finished <- base::Sys.time()
[17:42:09.476]     ...future.result
[17:42:09.476] }
[17:42:09.478] assign_globals() ...
[17:42:09.478] List of 1
[17:42:09.478]  $ ii: int 3
[17:42:09.478]  - attr(*, "where")=List of 1
[17:42:09.478]   ..$ ii:<environment: R_EmptyEnv> 
[17:42:09.478]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:09.478]  - attr(*, "resolved")= logi FALSE
[17:42:09.478]  - attr(*, "total_size")= num 56
[17:42:09.478]  - attr(*, "already-done")= logi TRUE
[17:42:09.481] - copied ‘ii’ to environment
[17:42:09.481] assign_globals() ... done
[17:42:09.481] plan(): Setting new future strategy stack:
[17:42:09.481] List of future strategies:
[17:42:09.481] 1. sequential:
[17:42:09.481]    - args: function (..., envir = parent.frame())
[17:42:09.481]    - tweaked: FALSE
[17:42:09.481]    - call: NULL
[17:42:09.481] plan(): nbrOfWorkers() = 1
[17:42:09.482] plan(): Setting new future strategy stack:
[17:42:09.482] List of future strategies:
[17:42:09.482] 1. sequential:
[17:42:09.482]    - args: function (..., envir = parent.frame())
[17:42:09.482]    - tweaked: FALSE
[17:42:09.482]    - call: plan(strategy)
[17:42:09.483] plan(): nbrOfWorkers() = 1
[17:42:09.483] SequentialFuture started (and completed)
[17:42:09.483] - Launch lazy future ... done
[17:42:09.483] run() for ‘SequentialFuture’ ... done
[17:42:09.484] signalConditions() ...
[17:42:09.484]  - include = ‘immediateCondition’
[17:42:09.484]  - exclude = 
[17:42:09.484]  - resignal = FALSE
[17:42:09.484]  - Number of conditions: 1
[17:42:09.484] signalConditions() ... done
[17:42:09.484] Future state: ‘finished’
[17:42:09.484] signalConditions() ...
[17:42:09.484]  - include = ‘condition’
[17:42:09.484]  - exclude = ‘immediateCondition’
[17:42:09.485]  - resignal = TRUE
[17:42:09.485]  - Number of conditions: 1
[17:42:09.485]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:42:09.485] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[17:42:09.486] signalConditions() ...
[17:42:09.486]  - include = ‘immediateCondition’
[17:42:09.486]  - exclude = 
[17:42:09.486]  - resignal = FALSE
[17:42:09.486]  - Number of conditions: 1
[17:42:09.487] signalConditions() ... done
[17:42:09.487] Future state: ‘finished’
[17:42:09.487] signalConditions() ...
[17:42:09.487]  - include = ‘condition’
[17:42:09.487]  - exclude = ‘immediateCondition’
[17:42:09.487]  - resignal = TRUE
[17:42:09.487]  - Number of conditions: 1
[17:42:09.488]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:42:09.488] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[17:42:09.488] signalConditions() ...
[17:42:09.488]  - include = ‘immediateCondition’
[17:42:09.488]  - exclude = 
[17:42:09.488]  - resignal = FALSE
[17:42:09.488]  - Number of conditions: 1
[17:42:09.489] signalConditions() ... done
[17:42:09.489] Future state: ‘finished’
[17:42:09.489] signalConditions() ...
[17:42:09.489]  - include = ‘condition’
[17:42:09.489]  - exclude = ‘immediateCondition’
[17:42:09.489]  - resignal = TRUE
[17:42:09.489]  - Number of conditions: 1
[17:42:09.489]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:42:09.489] signalConditions() ... done
** Future evaluation with a poor-man's "progress bar"
[17:42:09.490] getGlobalsAndPackages() ...
[17:42:09.490] Searching for globals...
[17:42:09.492] - globals found: [4] ‘{’, ‘cat’, ‘for’, ‘:’
[17:42:09.492] Searching for globals ... DONE
[17:42:09.492] Resolving globals: FALSE
[17:42:09.492] 
[17:42:09.493] 
[17:42:09.493] getGlobalsAndPackages() ... DONE
[17:42:09.493] run() for ‘Future’ ...
[17:42:09.493] - state: ‘created’
[17:42:09.493] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:09.493] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:09.494] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:09.494]   - Field: ‘label’
[17:42:09.494]   - Field: ‘local’
[17:42:09.494]   - Field: ‘owner’
[17:42:09.494]   - Field: ‘envir’
[17:42:09.494]   - Field: ‘packages’
[17:42:09.494]   - Field: ‘gc’
[17:42:09.494]   - Field: ‘conditions’
[17:42:09.494]   - Field: ‘expr’
[17:42:09.494]   - Field: ‘uuid’
[17:42:09.495]   - Field: ‘seed’
[17:42:09.495]   - Field: ‘version’
[17:42:09.495]   - Field: ‘result’
[17:42:09.495]   - Field: ‘asynchronous’
[17:42:09.495]   - Field: ‘calls’
[17:42:09.495]   - Field: ‘globals’
[17:42:09.495]   - Field: ‘stdout’
[17:42:09.495]   - Field: ‘earlySignal’
[17:42:09.495]   - Field: ‘lazy’
[17:42:09.495]   - Field: ‘state’
[17:42:09.496] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:09.496] - Launch lazy future ...
[17:42:09.496] Packages needed by the future expression (n = 0): <none>
[17:42:09.496] Packages needed by future strategies (n = 0): <none>
[17:42:09.496] {
[17:42:09.496]     {
[17:42:09.496]         {
[17:42:09.496]             ...future.startTime <- base::Sys.time()
[17:42:09.496]             {
[17:42:09.496]                 {
[17:42:09.496]                   {
[17:42:09.496]                     base::local({
[17:42:09.496]                       has_future <- base::requireNamespace("future", 
[17:42:09.496]                         quietly = TRUE)
[17:42:09.496]                       if (has_future) {
[17:42:09.496]                         ns <- base::getNamespace("future")
[17:42:09.496]                         version <- ns[[".package"]][["version"]]
[17:42:09.496]                         if (is.null(version)) 
[17:42:09.496]                           version <- utils::packageVersion("future")
[17:42:09.496]                       }
[17:42:09.496]                       else {
[17:42:09.496]                         version <- NULL
[17:42:09.496]                       }
[17:42:09.496]                       if (!has_future || version < "1.8.0") {
[17:42:09.496]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:09.496]                           "", base::R.version$version.string), 
[17:42:09.496]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:09.496]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:09.496]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:09.496]                             "release", "version")], collapse = " "), 
[17:42:09.496]                           hostname = base::Sys.info()[["nodename"]])
[17:42:09.496]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:09.496]                           info)
[17:42:09.496]                         info <- base::paste(info, collapse = "; ")
[17:42:09.496]                         if (!has_future) {
[17:42:09.496]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:09.496]                             info)
[17:42:09.496]                         }
[17:42:09.496]                         else {
[17:42:09.496]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:09.496]                             info, version)
[17:42:09.496]                         }
[17:42:09.496]                         base::stop(msg)
[17:42:09.496]                       }
[17:42:09.496]                     })
[17:42:09.496]                   }
[17:42:09.496]                   options(future.plan = NULL)
[17:42:09.496]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.496]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:09.496]                 }
[17:42:09.496]                 ...future.workdir <- getwd()
[17:42:09.496]             }
[17:42:09.496]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:09.496]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:09.496]         }
[17:42:09.496]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:09.496]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:09.496]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:09.496]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:09.496]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:09.496]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:09.496]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:09.496]             base::names(...future.oldOptions))
[17:42:09.496]     }
[17:42:09.496]     if (FALSE) {
[17:42:09.496]     }
[17:42:09.496]     else {
[17:42:09.496]         if (TRUE) {
[17:42:09.496]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:09.496]                 open = "w")
[17:42:09.496]         }
[17:42:09.496]         else {
[17:42:09.496]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:09.496]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:09.496]         }
[17:42:09.496]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:09.496]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:09.496]             base::sink(type = "output", split = FALSE)
[17:42:09.496]             base::close(...future.stdout)
[17:42:09.496]         }, add = TRUE)
[17:42:09.496]     }
[17:42:09.496]     ...future.frame <- base::sys.nframe()
[17:42:09.496]     ...future.conditions <- base::list()
[17:42:09.496]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:09.496]     if (FALSE) {
[17:42:09.496]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:09.496]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:09.496]     }
[17:42:09.496]     ...future.result <- base::tryCatch({
[17:42:09.496]         base::withCallingHandlers({
[17:42:09.496]             ...future.value <- base::withVisible(base::local({
[17:42:09.496]                 cat("Processing: ")
[17:42:09.496]                 for (ii in 1:10) {
[17:42:09.496]                   cat(".")
[17:42:09.496]                 }
[17:42:09.496]                 cat(" [100%]\n")
[17:42:09.496]                 4
[17:42:09.496]             }))
[17:42:09.496]             future::FutureResult(value = ...future.value$value, 
[17:42:09.496]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.496]                   ...future.rng), globalenv = if (FALSE) 
[17:42:09.496]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:09.496]                     ...future.globalenv.names))
[17:42:09.496]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:09.496]         }, condition = base::local({
[17:42:09.496]             c <- base::c
[17:42:09.496]             inherits <- base::inherits
[17:42:09.496]             invokeRestart <- base::invokeRestart
[17:42:09.496]             length <- base::length
[17:42:09.496]             list <- base::list
[17:42:09.496]             seq.int <- base::seq.int
[17:42:09.496]             signalCondition <- base::signalCondition
[17:42:09.496]             sys.calls <- base::sys.calls
[17:42:09.496]             `[[` <- base::`[[`
[17:42:09.496]             `+` <- base::`+`
[17:42:09.496]             `<<-` <- base::`<<-`
[17:42:09.496]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:09.496]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:09.496]                   3L)]
[17:42:09.496]             }
[17:42:09.496]             function(cond) {
[17:42:09.496]                 is_error <- inherits(cond, "error")
[17:42:09.496]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:09.496]                   NULL)
[17:42:09.496]                 if (is_error) {
[17:42:09.496]                   sessionInformation <- function() {
[17:42:09.496]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:09.496]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:09.496]                       search = base::search(), system = base::Sys.info())
[17:42:09.496]                   }
[17:42:09.496]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.496]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:09.496]                     cond$call), session = sessionInformation(), 
[17:42:09.496]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:09.496]                   signalCondition(cond)
[17:42:09.496]                 }
[17:42:09.496]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:09.496]                 "immediateCondition"))) {
[17:42:09.496]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:09.496]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.496]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:09.496]                   if (TRUE && !signal) {
[17:42:09.496]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.496]                     {
[17:42:09.496]                       inherits <- base::inherits
[17:42:09.496]                       invokeRestart <- base::invokeRestart
[17:42:09.496]                       is.null <- base::is.null
[17:42:09.496]                       muffled <- FALSE
[17:42:09.496]                       if (inherits(cond, "message")) {
[17:42:09.496]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.496]                         if (muffled) 
[17:42:09.496]                           invokeRestart("muffleMessage")
[17:42:09.496]                       }
[17:42:09.496]                       else if (inherits(cond, "warning")) {
[17:42:09.496]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.496]                         if (muffled) 
[17:42:09.496]                           invokeRestart("muffleWarning")
[17:42:09.496]                       }
[17:42:09.496]                       else if (inherits(cond, "condition")) {
[17:42:09.496]                         if (!is.null(pattern)) {
[17:42:09.496]                           computeRestarts <- base::computeRestarts
[17:42:09.496]                           grepl <- base::grepl
[17:42:09.496]                           restarts <- computeRestarts(cond)
[17:42:09.496]                           for (restart in restarts) {
[17:42:09.496]                             name <- restart$name
[17:42:09.496]                             if (is.null(name)) 
[17:42:09.496]                               next
[17:42:09.496]                             if (!grepl(pattern, name)) 
[17:42:09.496]                               next
[17:42:09.496]                             invokeRestart(restart)
[17:42:09.496]                             muffled <- TRUE
[17:42:09.496]                             break
[17:42:09.496]                           }
[17:42:09.496]                         }
[17:42:09.496]                       }
[17:42:09.496]                       invisible(muffled)
[17:42:09.496]                     }
[17:42:09.496]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.496]                   }
[17:42:09.496]                 }
[17:42:09.496]                 else {
[17:42:09.496]                   if (TRUE) {
[17:42:09.496]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.496]                     {
[17:42:09.496]                       inherits <- base::inherits
[17:42:09.496]                       invokeRestart <- base::invokeRestart
[17:42:09.496]                       is.null <- base::is.null
[17:42:09.496]                       muffled <- FALSE
[17:42:09.496]                       if (inherits(cond, "message")) {
[17:42:09.496]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.496]                         if (muffled) 
[17:42:09.496]                           invokeRestart("muffleMessage")
[17:42:09.496]                       }
[17:42:09.496]                       else if (inherits(cond, "warning")) {
[17:42:09.496]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.496]                         if (muffled) 
[17:42:09.496]                           invokeRestart("muffleWarning")
[17:42:09.496]                       }
[17:42:09.496]                       else if (inherits(cond, "condition")) {
[17:42:09.496]                         if (!is.null(pattern)) {
[17:42:09.496]                           computeRestarts <- base::computeRestarts
[17:42:09.496]                           grepl <- base::grepl
[17:42:09.496]                           restarts <- computeRestarts(cond)
[17:42:09.496]                           for (restart in restarts) {
[17:42:09.496]                             name <- restart$name
[17:42:09.496]                             if (is.null(name)) 
[17:42:09.496]                               next
[17:42:09.496]                             if (!grepl(pattern, name)) 
[17:42:09.496]                               next
[17:42:09.496]                             invokeRestart(restart)
[17:42:09.496]                             muffled <- TRUE
[17:42:09.496]                             break
[17:42:09.496]                           }
[17:42:09.496]                         }
[17:42:09.496]                       }
[17:42:09.496]                       invisible(muffled)
[17:42:09.496]                     }
[17:42:09.496]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.496]                   }
[17:42:09.496]                 }
[17:42:09.496]             }
[17:42:09.496]         }))
[17:42:09.496]     }, error = function(ex) {
[17:42:09.496]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:09.496]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.496]                 ...future.rng), started = ...future.startTime, 
[17:42:09.496]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:09.496]             version = "1.8"), class = "FutureResult")
[17:42:09.496]     }, finally = {
[17:42:09.496]         if (!identical(...future.workdir, getwd())) 
[17:42:09.496]             setwd(...future.workdir)
[17:42:09.496]         {
[17:42:09.496]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:09.496]                 ...future.oldOptions$nwarnings <- NULL
[17:42:09.496]             }
[17:42:09.496]             base::options(...future.oldOptions)
[17:42:09.496]             if (.Platform$OS.type == "windows") {
[17:42:09.496]                 old_names <- names(...future.oldEnvVars)
[17:42:09.496]                 envs <- base::Sys.getenv()
[17:42:09.496]                 names <- names(envs)
[17:42:09.496]                 common <- intersect(names, old_names)
[17:42:09.496]                 added <- setdiff(names, old_names)
[17:42:09.496]                 removed <- setdiff(old_names, names)
[17:42:09.496]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:09.496]                   envs[common]]
[17:42:09.496]                 NAMES <- toupper(changed)
[17:42:09.496]                 args <- list()
[17:42:09.496]                 for (kk in seq_along(NAMES)) {
[17:42:09.496]                   name <- changed[[kk]]
[17:42:09.496]                   NAME <- NAMES[[kk]]
[17:42:09.496]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.496]                     next
[17:42:09.496]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.496]                 }
[17:42:09.496]                 NAMES <- toupper(added)
[17:42:09.496]                 for (kk in seq_along(NAMES)) {
[17:42:09.496]                   name <- added[[kk]]
[17:42:09.496]                   NAME <- NAMES[[kk]]
[17:42:09.496]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.496]                     next
[17:42:09.496]                   args[[name]] <- ""
[17:42:09.496]                 }
[17:42:09.496]                 NAMES <- toupper(removed)
[17:42:09.496]                 for (kk in seq_along(NAMES)) {
[17:42:09.496]                   name <- removed[[kk]]
[17:42:09.496]                   NAME <- NAMES[[kk]]
[17:42:09.496]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.496]                     next
[17:42:09.496]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.496]                 }
[17:42:09.496]                 if (length(args) > 0) 
[17:42:09.496]                   base::do.call(base::Sys.setenv, args = args)
[17:42:09.496]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:09.496]             }
[17:42:09.496]             else {
[17:42:09.496]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:09.496]             }
[17:42:09.496]             {
[17:42:09.496]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:09.496]                   0L) {
[17:42:09.496]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:09.496]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:09.496]                   base::options(opts)
[17:42:09.496]                 }
[17:42:09.496]                 {
[17:42:09.496]                   {
[17:42:09.496]                     NULL
[17:42:09.496]                     RNGkind("Mersenne-Twister")
[17:42:09.496]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:09.496]                       inherits = FALSE)
[17:42:09.496]                   }
[17:42:09.496]                   options(future.plan = NULL)
[17:42:09.496]                   if (is.na(NA_character_)) 
[17:42:09.496]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.496]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:09.496]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:09.496]                   {
[17:42:09.496]                     future <- SequentialFuture(..., envir = envir)
[17:42:09.496]                     if (!future$lazy) 
[17:42:09.496]                       future <- run(future)
[17:42:09.496]                     invisible(future)
[17:42:09.496]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:09.496]                 }
[17:42:09.496]             }
[17:42:09.496]         }
[17:42:09.496]     })
[17:42:09.496]     if (TRUE) {
[17:42:09.496]         base::sink(type = "output", split = FALSE)
[17:42:09.496]         if (TRUE) {
[17:42:09.496]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:09.496]         }
[17:42:09.496]         else {
[17:42:09.496]             ...future.result["stdout"] <- base::list(NULL)
[17:42:09.496]         }
[17:42:09.496]         base::close(...future.stdout)
[17:42:09.496]         ...future.stdout <- NULL
[17:42:09.496]     }
[17:42:09.496]     ...future.result$conditions <- ...future.conditions
[17:42:09.496]     ...future.result$finished <- base::Sys.time()
[17:42:09.496]     ...future.result
[17:42:09.496] }
[17:42:09.498] plan(): Setting new future strategy stack:
[17:42:09.498] List of future strategies:
[17:42:09.498] 1. sequential:
[17:42:09.498]    - args: function (..., envir = parent.frame())
[17:42:09.498]    - tweaked: FALSE
[17:42:09.498]    - call: NULL
[17:42:09.499] plan(): nbrOfWorkers() = 1
[17:42:09.502] plan(): Setting new future strategy stack:
[17:42:09.502] List of future strategies:
[17:42:09.502] 1. sequential:
[17:42:09.502]    - args: function (..., envir = parent.frame())
[17:42:09.502]    - tweaked: FALSE
[17:42:09.502]    - call: plan(strategy)
[17:42:09.502] plan(): nbrOfWorkers() = 1
[17:42:09.502] SequentialFuture started (and completed)
[17:42:09.502] - Launch lazy future ... done
[17:42:09.503] run() for ‘SequentialFuture’ ... done
** Collecting results
v1 = 1
v2 = 2
Warning in sprintf(...) : restarting interrupted promise evaluation
[17:42:09.504] signalConditions() ...
[17:42:09.504]  - include = ‘immediateCondition’
[17:42:09.504]  - exclude = 
[17:42:09.504]  - resignal = FALSE
[17:42:09.504]  - Number of conditions: 1
[17:42:09.504] signalConditions() ... done
[17:42:09.505] Future state: ‘finished’
[17:42:09.505] signalConditions() ...
[17:42:09.505]  - include = ‘condition’
[17:42:09.505]  - exclude = ‘immediateCondition’
[17:42:09.505]  - resignal = TRUE
[17:42:09.505]  - Number of conditions: 1
[17:42:09.505]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:42:09.505] signalConditions() ... done
v3: <simpleError> (as expect)
Processing: .......... [100%]
v4 = 4
** Left-to-right and right-to-left future assignments
[17:42:09.506] getGlobalsAndPackages() ...
[17:42:09.506] Searching for globals...
[17:42:09.506] 
[17:42:09.506] Searching for globals ... DONE
[17:42:09.506] - globals: [0] <none>
[17:42:09.507] getGlobalsAndPackages() ... DONE
[17:42:09.507] run() for ‘Future’ ...
[17:42:09.507] - state: ‘created’
[17:42:09.507] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:09.507] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:09.507] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:09.508]   - Field: ‘label’
[17:42:09.508]   - Field: ‘local’
[17:42:09.508]   - Field: ‘owner’
[17:42:09.508]   - Field: ‘envir’
[17:42:09.508]   - Field: ‘packages’
[17:42:09.508]   - Field: ‘gc’
[17:42:09.508]   - Field: ‘conditions’
[17:42:09.508]   - Field: ‘expr’
[17:42:09.508]   - Field: ‘uuid’
[17:42:09.508]   - Field: ‘seed’
[17:42:09.509]   - Field: ‘version’
[17:42:09.509]   - Field: ‘result’
[17:42:09.509]   - Field: ‘asynchronous’
[17:42:09.509]   - Field: ‘calls’
[17:42:09.509]   - Field: ‘globals’
[17:42:09.509]   - Field: ‘stdout’
[17:42:09.509]   - Field: ‘earlySignal’
[17:42:09.509]   - Field: ‘lazy’
[17:42:09.509]   - Field: ‘state’
[17:42:09.509] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:09.509] - Launch lazy future ...
[17:42:09.510] Packages needed by the future expression (n = 0): <none>
[17:42:09.510] Packages needed by future strategies (n = 0): <none>
[17:42:09.510] {
[17:42:09.510]     {
[17:42:09.510]         {
[17:42:09.510]             ...future.startTime <- base::Sys.time()
[17:42:09.510]             {
[17:42:09.510]                 {
[17:42:09.510]                   {
[17:42:09.510]                     base::local({
[17:42:09.510]                       has_future <- base::requireNamespace("future", 
[17:42:09.510]                         quietly = TRUE)
[17:42:09.510]                       if (has_future) {
[17:42:09.510]                         ns <- base::getNamespace("future")
[17:42:09.510]                         version <- ns[[".package"]][["version"]]
[17:42:09.510]                         if (is.null(version)) 
[17:42:09.510]                           version <- utils::packageVersion("future")
[17:42:09.510]                       }
[17:42:09.510]                       else {
[17:42:09.510]                         version <- NULL
[17:42:09.510]                       }
[17:42:09.510]                       if (!has_future || version < "1.8.0") {
[17:42:09.510]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:09.510]                           "", base::R.version$version.string), 
[17:42:09.510]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:09.510]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:09.510]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:09.510]                             "release", "version")], collapse = " "), 
[17:42:09.510]                           hostname = base::Sys.info()[["nodename"]])
[17:42:09.510]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:09.510]                           info)
[17:42:09.510]                         info <- base::paste(info, collapse = "; ")
[17:42:09.510]                         if (!has_future) {
[17:42:09.510]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:09.510]                             info)
[17:42:09.510]                         }
[17:42:09.510]                         else {
[17:42:09.510]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:09.510]                             info, version)
[17:42:09.510]                         }
[17:42:09.510]                         base::stop(msg)
[17:42:09.510]                       }
[17:42:09.510]                     })
[17:42:09.510]                   }
[17:42:09.510]                   options(future.plan = NULL)
[17:42:09.510]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.510]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:09.510]                 }
[17:42:09.510]                 ...future.workdir <- getwd()
[17:42:09.510]             }
[17:42:09.510]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:09.510]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:09.510]         }
[17:42:09.510]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:09.510]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:09.510]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:09.510]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:09.510]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:09.510]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:09.510]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:09.510]             base::names(...future.oldOptions))
[17:42:09.510]     }
[17:42:09.510]     if (FALSE) {
[17:42:09.510]     }
[17:42:09.510]     else {
[17:42:09.510]         if (TRUE) {
[17:42:09.510]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:09.510]                 open = "w")
[17:42:09.510]         }
[17:42:09.510]         else {
[17:42:09.510]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:09.510]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:09.510]         }
[17:42:09.510]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:09.510]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:09.510]             base::sink(type = "output", split = FALSE)
[17:42:09.510]             base::close(...future.stdout)
[17:42:09.510]         }, add = TRUE)
[17:42:09.510]     }
[17:42:09.510]     ...future.frame <- base::sys.nframe()
[17:42:09.510]     ...future.conditions <- base::list()
[17:42:09.510]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:09.510]     if (FALSE) {
[17:42:09.510]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:09.510]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:09.510]     }
[17:42:09.510]     ...future.result <- base::tryCatch({
[17:42:09.510]         base::withCallingHandlers({
[17:42:09.510]             ...future.value <- base::withVisible(base::local(1))
[17:42:09.510]             future::FutureResult(value = ...future.value$value, 
[17:42:09.510]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.510]                   ...future.rng), globalenv = if (FALSE) 
[17:42:09.510]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:09.510]                     ...future.globalenv.names))
[17:42:09.510]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:09.510]         }, condition = base::local({
[17:42:09.510]             c <- base::c
[17:42:09.510]             inherits <- base::inherits
[17:42:09.510]             invokeRestart <- base::invokeRestart
[17:42:09.510]             length <- base::length
[17:42:09.510]             list <- base::list
[17:42:09.510]             seq.int <- base::seq.int
[17:42:09.510]             signalCondition <- base::signalCondition
[17:42:09.510]             sys.calls <- base::sys.calls
[17:42:09.510]             `[[` <- base::`[[`
[17:42:09.510]             `+` <- base::`+`
[17:42:09.510]             `<<-` <- base::`<<-`
[17:42:09.510]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:09.510]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:09.510]                   3L)]
[17:42:09.510]             }
[17:42:09.510]             function(cond) {
[17:42:09.510]                 is_error <- inherits(cond, "error")
[17:42:09.510]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:09.510]                   NULL)
[17:42:09.510]                 if (is_error) {
[17:42:09.510]                   sessionInformation <- function() {
[17:42:09.510]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:09.510]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:09.510]                       search = base::search(), system = base::Sys.info())
[17:42:09.510]                   }
[17:42:09.510]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.510]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:09.510]                     cond$call), session = sessionInformation(), 
[17:42:09.510]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:09.510]                   signalCondition(cond)
[17:42:09.510]                 }
[17:42:09.510]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:09.510]                 "immediateCondition"))) {
[17:42:09.510]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:09.510]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.510]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:09.510]                   if (TRUE && !signal) {
[17:42:09.510]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.510]                     {
[17:42:09.510]                       inherits <- base::inherits
[17:42:09.510]                       invokeRestart <- base::invokeRestart
[17:42:09.510]                       is.null <- base::is.null
[17:42:09.510]                       muffled <- FALSE
[17:42:09.510]                       if (inherits(cond, "message")) {
[17:42:09.510]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.510]                         if (muffled) 
[17:42:09.510]                           invokeRestart("muffleMessage")
[17:42:09.510]                       }
[17:42:09.510]                       else if (inherits(cond, "warning")) {
[17:42:09.510]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.510]                         if (muffled) 
[17:42:09.510]                           invokeRestart("muffleWarning")
[17:42:09.510]                       }
[17:42:09.510]                       else if (inherits(cond, "condition")) {
[17:42:09.510]                         if (!is.null(pattern)) {
[17:42:09.510]                           computeRestarts <- base::computeRestarts
[17:42:09.510]                           grepl <- base::grepl
[17:42:09.510]                           restarts <- computeRestarts(cond)
[17:42:09.510]                           for (restart in restarts) {
[17:42:09.510]                             name <- restart$name
[17:42:09.510]                             if (is.null(name)) 
[17:42:09.510]                               next
[17:42:09.510]                             if (!grepl(pattern, name)) 
[17:42:09.510]                               next
[17:42:09.510]                             invokeRestart(restart)
[17:42:09.510]                             muffled <- TRUE
[17:42:09.510]                             break
[17:42:09.510]                           }
[17:42:09.510]                         }
[17:42:09.510]                       }
[17:42:09.510]                       invisible(muffled)
[17:42:09.510]                     }
[17:42:09.510]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.510]                   }
[17:42:09.510]                 }
[17:42:09.510]                 else {
[17:42:09.510]                   if (TRUE) {
[17:42:09.510]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.510]                     {
[17:42:09.510]                       inherits <- base::inherits
[17:42:09.510]                       invokeRestart <- base::invokeRestart
[17:42:09.510]                       is.null <- base::is.null
[17:42:09.510]                       muffled <- FALSE
[17:42:09.510]                       if (inherits(cond, "message")) {
[17:42:09.510]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.510]                         if (muffled) 
[17:42:09.510]                           invokeRestart("muffleMessage")
[17:42:09.510]                       }
[17:42:09.510]                       else if (inherits(cond, "warning")) {
[17:42:09.510]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.510]                         if (muffled) 
[17:42:09.510]                           invokeRestart("muffleWarning")
[17:42:09.510]                       }
[17:42:09.510]                       else if (inherits(cond, "condition")) {
[17:42:09.510]                         if (!is.null(pattern)) {
[17:42:09.510]                           computeRestarts <- base::computeRestarts
[17:42:09.510]                           grepl <- base::grepl
[17:42:09.510]                           restarts <- computeRestarts(cond)
[17:42:09.510]                           for (restart in restarts) {
[17:42:09.510]                             name <- restart$name
[17:42:09.510]                             if (is.null(name)) 
[17:42:09.510]                               next
[17:42:09.510]                             if (!grepl(pattern, name)) 
[17:42:09.510]                               next
[17:42:09.510]                             invokeRestart(restart)
[17:42:09.510]                             muffled <- TRUE
[17:42:09.510]                             break
[17:42:09.510]                           }
[17:42:09.510]                         }
[17:42:09.510]                       }
[17:42:09.510]                       invisible(muffled)
[17:42:09.510]                     }
[17:42:09.510]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.510]                   }
[17:42:09.510]                 }
[17:42:09.510]             }
[17:42:09.510]         }))
[17:42:09.510]     }, error = function(ex) {
[17:42:09.510]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:09.510]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.510]                 ...future.rng), started = ...future.startTime, 
[17:42:09.510]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:09.510]             version = "1.8"), class = "FutureResult")
[17:42:09.510]     }, finally = {
[17:42:09.510]         if (!identical(...future.workdir, getwd())) 
[17:42:09.510]             setwd(...future.workdir)
[17:42:09.510]         {
[17:42:09.510]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:09.510]                 ...future.oldOptions$nwarnings <- NULL
[17:42:09.510]             }
[17:42:09.510]             base::options(...future.oldOptions)
[17:42:09.510]             if (.Platform$OS.type == "windows") {
[17:42:09.510]                 old_names <- names(...future.oldEnvVars)
[17:42:09.510]                 envs <- base::Sys.getenv()
[17:42:09.510]                 names <- names(envs)
[17:42:09.510]                 common <- intersect(names, old_names)
[17:42:09.510]                 added <- setdiff(names, old_names)
[17:42:09.510]                 removed <- setdiff(old_names, names)
[17:42:09.510]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:09.510]                   envs[common]]
[17:42:09.510]                 NAMES <- toupper(changed)
[17:42:09.510]                 args <- list()
[17:42:09.510]                 for (kk in seq_along(NAMES)) {
[17:42:09.510]                   name <- changed[[kk]]
[17:42:09.510]                   NAME <- NAMES[[kk]]
[17:42:09.510]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.510]                     next
[17:42:09.510]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.510]                 }
[17:42:09.510]                 NAMES <- toupper(added)
[17:42:09.510]                 for (kk in seq_along(NAMES)) {
[17:42:09.510]                   name <- added[[kk]]
[17:42:09.510]                   NAME <- NAMES[[kk]]
[17:42:09.510]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.510]                     next
[17:42:09.510]                   args[[name]] <- ""
[17:42:09.510]                 }
[17:42:09.510]                 NAMES <- toupper(removed)
[17:42:09.510]                 for (kk in seq_along(NAMES)) {
[17:42:09.510]                   name <- removed[[kk]]
[17:42:09.510]                   NAME <- NAMES[[kk]]
[17:42:09.510]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.510]                     next
[17:42:09.510]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.510]                 }
[17:42:09.510]                 if (length(args) > 0) 
[17:42:09.510]                   base::do.call(base::Sys.setenv, args = args)
[17:42:09.510]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:09.510]             }
[17:42:09.510]             else {
[17:42:09.510]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:09.510]             }
[17:42:09.510]             {
[17:42:09.510]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:09.510]                   0L) {
[17:42:09.510]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:09.510]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:09.510]                   base::options(opts)
[17:42:09.510]                 }
[17:42:09.510]                 {
[17:42:09.510]                   {
[17:42:09.510]                     NULL
[17:42:09.510]                     RNGkind("Mersenne-Twister")
[17:42:09.510]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:09.510]                       inherits = FALSE)
[17:42:09.510]                   }
[17:42:09.510]                   options(future.plan = NULL)
[17:42:09.510]                   if (is.na(NA_character_)) 
[17:42:09.510]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.510]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:09.510]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:09.510]                   {
[17:42:09.510]                     future <- SequentialFuture(..., envir = envir)
[17:42:09.510]                     if (!future$lazy) 
[17:42:09.510]                       future <- run(future)
[17:42:09.510]                     invisible(future)
[17:42:09.510]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:09.510]                 }
[17:42:09.510]             }
[17:42:09.510]         }
[17:42:09.510]     })
[17:42:09.510]     if (TRUE) {
[17:42:09.510]         base::sink(type = "output", split = FALSE)
[17:42:09.510]         if (TRUE) {
[17:42:09.510]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:09.510]         }
[17:42:09.510]         else {
[17:42:09.510]             ...future.result["stdout"] <- base::list(NULL)
[17:42:09.510]         }
[17:42:09.510]         base::close(...future.stdout)
[17:42:09.510]         ...future.stdout <- NULL
[17:42:09.510]     }
[17:42:09.510]     ...future.result$conditions <- ...future.conditions
[17:42:09.510]     ...future.result$finished <- base::Sys.time()
[17:42:09.510]     ...future.result
[17:42:09.510] }
[17:42:09.512] plan(): Setting new future strategy stack:
[17:42:09.512] List of future strategies:
[17:42:09.512] 1. sequential:
[17:42:09.512]    - args: function (..., envir = parent.frame())
[17:42:09.512]    - tweaked: FALSE
[17:42:09.512]    - call: NULL
[17:42:09.513] plan(): nbrOfWorkers() = 1
[17:42:09.513] plan(): Setting new future strategy stack:
[17:42:09.513] List of future strategies:
[17:42:09.513] 1. sequential:
[17:42:09.513]    - args: function (..., envir = parent.frame())
[17:42:09.513]    - tweaked: FALSE
[17:42:09.513]    - call: plan(strategy)
[17:42:09.514] plan(): nbrOfWorkers() = 1
[17:42:09.514] SequentialFuture started (and completed)
[17:42:09.514] - Launch lazy future ... done
[17:42:09.514] run() for ‘SequentialFuture’ ... done
c = 1
[17:42:09.514] getGlobalsAndPackages() ...
[17:42:09.515] Searching for globals...
[17:42:09.515] 
[17:42:09.515] Searching for globals ... DONE
[17:42:09.515] - globals: [0] <none>
[17:42:09.515] getGlobalsAndPackages() ... DONE
[17:42:09.515] run() for ‘Future’ ...
[17:42:09.516] - state: ‘created’
[17:42:09.516] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:09.516] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:09.516] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:09.516]   - Field: ‘label’
[17:42:09.516]   - Field: ‘local’
[17:42:09.516]   - Field: ‘owner’
[17:42:09.516]   - Field: ‘envir’
[17:42:09.516]   - Field: ‘packages’
[17:42:09.517]   - Field: ‘gc’
[17:42:09.517]   - Field: ‘conditions’
[17:42:09.517]   - Field: ‘expr’
[17:42:09.517]   - Field: ‘uuid’
[17:42:09.517]   - Field: ‘seed’
[17:42:09.517]   - Field: ‘version’
[17:42:09.517]   - Field: ‘result’
[17:42:09.517]   - Field: ‘asynchronous’
[17:42:09.517]   - Field: ‘calls’
[17:42:09.517]   - Field: ‘globals’
[17:42:09.518]   - Field: ‘stdout’
[17:42:09.518]   - Field: ‘earlySignal’
[17:42:09.518]   - Field: ‘lazy’
[17:42:09.518]   - Field: ‘state’
[17:42:09.518] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:09.518] - Launch lazy future ...
[17:42:09.518] Packages needed by the future expression (n = 0): <none>
[17:42:09.518] Packages needed by future strategies (n = 0): <none>
[17:42:09.519] {
[17:42:09.519]     {
[17:42:09.519]         {
[17:42:09.519]             ...future.startTime <- base::Sys.time()
[17:42:09.519]             {
[17:42:09.519]                 {
[17:42:09.519]                   {
[17:42:09.519]                     base::local({
[17:42:09.519]                       has_future <- base::requireNamespace("future", 
[17:42:09.519]                         quietly = TRUE)
[17:42:09.519]                       if (has_future) {
[17:42:09.519]                         ns <- base::getNamespace("future")
[17:42:09.519]                         version <- ns[[".package"]][["version"]]
[17:42:09.519]                         if (is.null(version)) 
[17:42:09.519]                           version <- utils::packageVersion("future")
[17:42:09.519]                       }
[17:42:09.519]                       else {
[17:42:09.519]                         version <- NULL
[17:42:09.519]                       }
[17:42:09.519]                       if (!has_future || version < "1.8.0") {
[17:42:09.519]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:09.519]                           "", base::R.version$version.string), 
[17:42:09.519]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:09.519]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:09.519]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:09.519]                             "release", "version")], collapse = " "), 
[17:42:09.519]                           hostname = base::Sys.info()[["nodename"]])
[17:42:09.519]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:09.519]                           info)
[17:42:09.519]                         info <- base::paste(info, collapse = "; ")
[17:42:09.519]                         if (!has_future) {
[17:42:09.519]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:09.519]                             info)
[17:42:09.519]                         }
[17:42:09.519]                         else {
[17:42:09.519]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:09.519]                             info, version)
[17:42:09.519]                         }
[17:42:09.519]                         base::stop(msg)
[17:42:09.519]                       }
[17:42:09.519]                     })
[17:42:09.519]                   }
[17:42:09.519]                   options(future.plan = NULL)
[17:42:09.519]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.519]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:09.519]                 }
[17:42:09.519]                 ...future.workdir <- getwd()
[17:42:09.519]             }
[17:42:09.519]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:09.519]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:09.519]         }
[17:42:09.519]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:09.519]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:09.519]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:09.519]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:09.519]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:09.519]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:09.519]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:09.519]             base::names(...future.oldOptions))
[17:42:09.519]     }
[17:42:09.519]     if (FALSE) {
[17:42:09.519]     }
[17:42:09.519]     else {
[17:42:09.519]         if (TRUE) {
[17:42:09.519]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:09.519]                 open = "w")
[17:42:09.519]         }
[17:42:09.519]         else {
[17:42:09.519]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:09.519]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:09.519]         }
[17:42:09.519]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:09.519]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:09.519]             base::sink(type = "output", split = FALSE)
[17:42:09.519]             base::close(...future.stdout)
[17:42:09.519]         }, add = TRUE)
[17:42:09.519]     }
[17:42:09.519]     ...future.frame <- base::sys.nframe()
[17:42:09.519]     ...future.conditions <- base::list()
[17:42:09.519]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:09.519]     if (FALSE) {
[17:42:09.519]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:09.519]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:09.519]     }
[17:42:09.519]     ...future.result <- base::tryCatch({
[17:42:09.519]         base::withCallingHandlers({
[17:42:09.519]             ...future.value <- base::withVisible(base::local(1))
[17:42:09.519]             future::FutureResult(value = ...future.value$value, 
[17:42:09.519]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.519]                   ...future.rng), globalenv = if (FALSE) 
[17:42:09.519]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:09.519]                     ...future.globalenv.names))
[17:42:09.519]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:09.519]         }, condition = base::local({
[17:42:09.519]             c <- base::c
[17:42:09.519]             inherits <- base::inherits
[17:42:09.519]             invokeRestart <- base::invokeRestart
[17:42:09.519]             length <- base::length
[17:42:09.519]             list <- base::list
[17:42:09.519]             seq.int <- base::seq.int
[17:42:09.519]             signalCondition <- base::signalCondition
[17:42:09.519]             sys.calls <- base::sys.calls
[17:42:09.519]             `[[` <- base::`[[`
[17:42:09.519]             `+` <- base::`+`
[17:42:09.519]             `<<-` <- base::`<<-`
[17:42:09.519]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:09.519]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:09.519]                   3L)]
[17:42:09.519]             }
[17:42:09.519]             function(cond) {
[17:42:09.519]                 is_error <- inherits(cond, "error")
[17:42:09.519]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:09.519]                   NULL)
[17:42:09.519]                 if (is_error) {
[17:42:09.519]                   sessionInformation <- function() {
[17:42:09.519]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:09.519]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:09.519]                       search = base::search(), system = base::Sys.info())
[17:42:09.519]                   }
[17:42:09.519]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.519]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:09.519]                     cond$call), session = sessionInformation(), 
[17:42:09.519]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:09.519]                   signalCondition(cond)
[17:42:09.519]                 }
[17:42:09.519]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:09.519]                 "immediateCondition"))) {
[17:42:09.519]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:09.519]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.519]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:09.519]                   if (TRUE && !signal) {
[17:42:09.519]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.519]                     {
[17:42:09.519]                       inherits <- base::inherits
[17:42:09.519]                       invokeRestart <- base::invokeRestart
[17:42:09.519]                       is.null <- base::is.null
[17:42:09.519]                       muffled <- FALSE
[17:42:09.519]                       if (inherits(cond, "message")) {
[17:42:09.519]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.519]                         if (muffled) 
[17:42:09.519]                           invokeRestart("muffleMessage")
[17:42:09.519]                       }
[17:42:09.519]                       else if (inherits(cond, "warning")) {
[17:42:09.519]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.519]                         if (muffled) 
[17:42:09.519]                           invokeRestart("muffleWarning")
[17:42:09.519]                       }
[17:42:09.519]                       else if (inherits(cond, "condition")) {
[17:42:09.519]                         if (!is.null(pattern)) {
[17:42:09.519]                           computeRestarts <- base::computeRestarts
[17:42:09.519]                           grepl <- base::grepl
[17:42:09.519]                           restarts <- computeRestarts(cond)
[17:42:09.519]                           for (restart in restarts) {
[17:42:09.519]                             name <- restart$name
[17:42:09.519]                             if (is.null(name)) 
[17:42:09.519]                               next
[17:42:09.519]                             if (!grepl(pattern, name)) 
[17:42:09.519]                               next
[17:42:09.519]                             invokeRestart(restart)
[17:42:09.519]                             muffled <- TRUE
[17:42:09.519]                             break
[17:42:09.519]                           }
[17:42:09.519]                         }
[17:42:09.519]                       }
[17:42:09.519]                       invisible(muffled)
[17:42:09.519]                     }
[17:42:09.519]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.519]                   }
[17:42:09.519]                 }
[17:42:09.519]                 else {
[17:42:09.519]                   if (TRUE) {
[17:42:09.519]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.519]                     {
[17:42:09.519]                       inherits <- base::inherits
[17:42:09.519]                       invokeRestart <- base::invokeRestart
[17:42:09.519]                       is.null <- base::is.null
[17:42:09.519]                       muffled <- FALSE
[17:42:09.519]                       if (inherits(cond, "message")) {
[17:42:09.519]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.519]                         if (muffled) 
[17:42:09.519]                           invokeRestart("muffleMessage")
[17:42:09.519]                       }
[17:42:09.519]                       else if (inherits(cond, "warning")) {
[17:42:09.519]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.519]                         if (muffled) 
[17:42:09.519]                           invokeRestart("muffleWarning")
[17:42:09.519]                       }
[17:42:09.519]                       else if (inherits(cond, "condition")) {
[17:42:09.519]                         if (!is.null(pattern)) {
[17:42:09.519]                           computeRestarts <- base::computeRestarts
[17:42:09.519]                           grepl <- base::grepl
[17:42:09.519]                           restarts <- computeRestarts(cond)
[17:42:09.519]                           for (restart in restarts) {
[17:42:09.519]                             name <- restart$name
[17:42:09.519]                             if (is.null(name)) 
[17:42:09.519]                               next
[17:42:09.519]                             if (!grepl(pattern, name)) 
[17:42:09.519]                               next
[17:42:09.519]                             invokeRestart(restart)
[17:42:09.519]                             muffled <- TRUE
[17:42:09.519]                             break
[17:42:09.519]                           }
[17:42:09.519]                         }
[17:42:09.519]                       }
[17:42:09.519]                       invisible(muffled)
[17:42:09.519]                     }
[17:42:09.519]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.519]                   }
[17:42:09.519]                 }
[17:42:09.519]             }
[17:42:09.519]         }))
[17:42:09.519]     }, error = function(ex) {
[17:42:09.519]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:09.519]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.519]                 ...future.rng), started = ...future.startTime, 
[17:42:09.519]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:09.519]             version = "1.8"), class = "FutureResult")
[17:42:09.519]     }, finally = {
[17:42:09.519]         if (!identical(...future.workdir, getwd())) 
[17:42:09.519]             setwd(...future.workdir)
[17:42:09.519]         {
[17:42:09.519]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:09.519]                 ...future.oldOptions$nwarnings <- NULL
[17:42:09.519]             }
[17:42:09.519]             base::options(...future.oldOptions)
[17:42:09.519]             if (.Platform$OS.type == "windows") {
[17:42:09.519]                 old_names <- names(...future.oldEnvVars)
[17:42:09.519]                 envs <- base::Sys.getenv()
[17:42:09.519]                 names <- names(envs)
[17:42:09.519]                 common <- intersect(names, old_names)
[17:42:09.519]                 added <- setdiff(names, old_names)
[17:42:09.519]                 removed <- setdiff(old_names, names)
[17:42:09.519]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:09.519]                   envs[common]]
[17:42:09.519]                 NAMES <- toupper(changed)
[17:42:09.519]                 args <- list()
[17:42:09.519]                 for (kk in seq_along(NAMES)) {
[17:42:09.519]                   name <- changed[[kk]]
[17:42:09.519]                   NAME <- NAMES[[kk]]
[17:42:09.519]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.519]                     next
[17:42:09.519]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.519]                 }
[17:42:09.519]                 NAMES <- toupper(added)
[17:42:09.519]                 for (kk in seq_along(NAMES)) {
[17:42:09.519]                   name <- added[[kk]]
[17:42:09.519]                   NAME <- NAMES[[kk]]
[17:42:09.519]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.519]                     next
[17:42:09.519]                   args[[name]] <- ""
[17:42:09.519]                 }
[17:42:09.519]                 NAMES <- toupper(removed)
[17:42:09.519]                 for (kk in seq_along(NAMES)) {
[17:42:09.519]                   name <- removed[[kk]]
[17:42:09.519]                   NAME <- NAMES[[kk]]
[17:42:09.519]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.519]                     next
[17:42:09.519]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.519]                 }
[17:42:09.519]                 if (length(args) > 0) 
[17:42:09.519]                   base::do.call(base::Sys.setenv, args = args)
[17:42:09.519]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:09.519]             }
[17:42:09.519]             else {
[17:42:09.519]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:09.519]             }
[17:42:09.519]             {
[17:42:09.519]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:09.519]                   0L) {
[17:42:09.519]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:09.519]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:09.519]                   base::options(opts)
[17:42:09.519]                 }
[17:42:09.519]                 {
[17:42:09.519]                   {
[17:42:09.519]                     NULL
[17:42:09.519]                     RNGkind("Mersenne-Twister")
[17:42:09.519]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:09.519]                       inherits = FALSE)
[17:42:09.519]                   }
[17:42:09.519]                   options(future.plan = NULL)
[17:42:09.519]                   if (is.na(NA_character_)) 
[17:42:09.519]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.519]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:09.519]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:09.519]                   {
[17:42:09.519]                     future <- SequentialFuture(..., envir = envir)
[17:42:09.519]                     if (!future$lazy) 
[17:42:09.519]                       future <- run(future)
[17:42:09.519]                     invisible(future)
[17:42:09.519]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:09.519]                 }
[17:42:09.519]             }
[17:42:09.519]         }
[17:42:09.519]     })
[17:42:09.519]     if (TRUE) {
[17:42:09.519]         base::sink(type = "output", split = FALSE)
[17:42:09.519]         if (TRUE) {
[17:42:09.519]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:09.519]         }
[17:42:09.519]         else {
[17:42:09.519]             ...future.result["stdout"] <- base::list(NULL)
[17:42:09.519]         }
[17:42:09.519]         base::close(...future.stdout)
[17:42:09.519]         ...future.stdout <- NULL
[17:42:09.519]     }
[17:42:09.519]     ...future.result$conditions <- ...future.conditions
[17:42:09.519]     ...future.result$finished <- base::Sys.time()
[17:42:09.519]     ...future.result
[17:42:09.519] }
[17:42:09.520] plan(): Setting new future strategy stack:
[17:42:09.521] List of future strategies:
[17:42:09.521] 1. sequential:
[17:42:09.521]    - args: function (..., envir = parent.frame())
[17:42:09.521]    - tweaked: FALSE
[17:42:09.521]    - call: NULL
[17:42:09.521] plan(): nbrOfWorkers() = 1
[17:42:09.522] plan(): Setting new future strategy stack:
[17:42:09.522] List of future strategies:
[17:42:09.522] 1. sequential:
[17:42:09.522]    - args: function (..., envir = parent.frame())
[17:42:09.522]    - tweaked: FALSE
[17:42:09.522]    - call: plan(strategy)
[17:42:09.522] plan(): nbrOfWorkers() = 1
[17:42:09.522] SequentialFuture started (and completed)
[17:42:09.522] - Launch lazy future ... done
[17:42:09.522] run() for ‘SequentialFuture’ ... done
d = 1
** Nested future assignments
[17:42:09.523] getGlobalsAndPackages() ...
[17:42:09.523] Searching for globals...
[17:42:09.526] - globals found: [5] ‘{’, ‘<-’, ‘%<-%’, ‘%->%’, ‘+’
[17:42:09.527] Searching for globals ... DONE
[17:42:09.527] Resolving globals: FALSE
[17:42:09.527] 
[17:42:09.527] - packages: [1] ‘future’
[17:42:09.527] getGlobalsAndPackages() ... DONE
[17:42:09.529] run() for ‘Future’ ...
[17:42:09.529] - state: ‘created’
[17:42:09.529] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:09.530] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:09.530] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:09.530]   - Field: ‘label’
[17:42:09.530]   - Field: ‘local’
[17:42:09.530]   - Field: ‘owner’
[17:42:09.530]   - Field: ‘envir’
[17:42:09.530]   - Field: ‘packages’
[17:42:09.530]   - Field: ‘gc’
[17:42:09.530]   - Field: ‘conditions’
[17:42:09.531]   - Field: ‘expr’
[17:42:09.531]   - Field: ‘uuid’
[17:42:09.531]   - Field: ‘seed’
[17:42:09.531]   - Field: ‘version’
[17:42:09.531]   - Field: ‘result’
[17:42:09.531]   - Field: ‘asynchronous’
[17:42:09.531]   - Field: ‘calls’
[17:42:09.531]   - Field: ‘globals’
[17:42:09.531]   - Field: ‘stdout’
[17:42:09.531]   - Field: ‘earlySignal’
[17:42:09.531]   - Field: ‘lazy’
[17:42:09.532]   - Field: ‘state’
[17:42:09.532] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:09.532] - Launch lazy future ...
[17:42:09.532] Packages needed by the future expression (n = 1): ‘future’
[17:42:09.532] Packages needed by future strategies (n = 0): <none>
[17:42:09.533] {
[17:42:09.533]     {
[17:42:09.533]         {
[17:42:09.533]             ...future.startTime <- base::Sys.time()
[17:42:09.533]             {
[17:42:09.533]                 {
[17:42:09.533]                   {
[17:42:09.533]                     {
[17:42:09.533]                       base::local({
[17:42:09.533]                         has_future <- base::requireNamespace("future", 
[17:42:09.533]                           quietly = TRUE)
[17:42:09.533]                         if (has_future) {
[17:42:09.533]                           ns <- base::getNamespace("future")
[17:42:09.533]                           version <- ns[[".package"]][["version"]]
[17:42:09.533]                           if (is.null(version)) 
[17:42:09.533]                             version <- utils::packageVersion("future")
[17:42:09.533]                         }
[17:42:09.533]                         else {
[17:42:09.533]                           version <- NULL
[17:42:09.533]                         }
[17:42:09.533]                         if (!has_future || version < "1.8.0") {
[17:42:09.533]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:09.533]                             "", base::R.version$version.string), 
[17:42:09.533]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:09.533]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:09.533]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:09.533]                               "release", "version")], collapse = " "), 
[17:42:09.533]                             hostname = base::Sys.info()[["nodename"]])
[17:42:09.533]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:09.533]                             info)
[17:42:09.533]                           info <- base::paste(info, collapse = "; ")
[17:42:09.533]                           if (!has_future) {
[17:42:09.533]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:09.533]                               info)
[17:42:09.533]                           }
[17:42:09.533]                           else {
[17:42:09.533]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:09.533]                               info, version)
[17:42:09.533]                           }
[17:42:09.533]                           base::stop(msg)
[17:42:09.533]                         }
[17:42:09.533]                       })
[17:42:09.533]                     }
[17:42:09.533]                     base::local({
[17:42:09.533]                       for (pkg in "future") {
[17:42:09.533]                         base::loadNamespace(pkg)
[17:42:09.533]                         base::library(pkg, character.only = TRUE)
[17:42:09.533]                       }
[17:42:09.533]                     })
[17:42:09.533]                   }
[17:42:09.533]                   options(future.plan = NULL)
[17:42:09.533]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.533]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:09.533]                 }
[17:42:09.533]                 ...future.workdir <- getwd()
[17:42:09.533]             }
[17:42:09.533]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:09.533]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:09.533]         }
[17:42:09.533]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:09.533]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:09.533]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:09.533]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:09.533]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:09.533]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:09.533]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:09.533]             base::names(...future.oldOptions))
[17:42:09.533]     }
[17:42:09.533]     if (FALSE) {
[17:42:09.533]     }
[17:42:09.533]     else {
[17:42:09.533]         if (TRUE) {
[17:42:09.533]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:09.533]                 open = "w")
[17:42:09.533]         }
[17:42:09.533]         else {
[17:42:09.533]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:09.533]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:09.533]         }
[17:42:09.533]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:09.533]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:09.533]             base::sink(type = "output", split = FALSE)
[17:42:09.533]             base::close(...future.stdout)
[17:42:09.533]         }, add = TRUE)
[17:42:09.533]     }
[17:42:09.533]     ...future.frame <- base::sys.nframe()
[17:42:09.533]     ...future.conditions <- base::list()
[17:42:09.533]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:09.533]     if (FALSE) {
[17:42:09.533]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:09.533]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:09.533]     }
[17:42:09.533]     ...future.result <- base::tryCatch({
[17:42:09.533]         base::withCallingHandlers({
[17:42:09.533]             ...future.value <- base::withVisible(base::local({
[17:42:09.533]                 b <- 1
[17:42:09.533]                 c %<-% 2
[17:42:09.533]                 d <- 3
[17:42:09.533]                 4 %->% e
[17:42:09.533]                 b + c + d + e
[17:42:09.533]             }))
[17:42:09.533]             future::FutureResult(value = ...future.value$value, 
[17:42:09.533]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.533]                   ...future.rng), globalenv = if (FALSE) 
[17:42:09.533]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:09.533]                     ...future.globalenv.names))
[17:42:09.533]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:09.533]         }, condition = base::local({
[17:42:09.533]             c <- base::c
[17:42:09.533]             inherits <- base::inherits
[17:42:09.533]             invokeRestart <- base::invokeRestart
[17:42:09.533]             length <- base::length
[17:42:09.533]             list <- base::list
[17:42:09.533]             seq.int <- base::seq.int
[17:42:09.533]             signalCondition <- base::signalCondition
[17:42:09.533]             sys.calls <- base::sys.calls
[17:42:09.533]             `[[` <- base::`[[`
[17:42:09.533]             `+` <- base::`+`
[17:42:09.533]             `<<-` <- base::`<<-`
[17:42:09.533]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:09.533]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:09.533]                   3L)]
[17:42:09.533]             }
[17:42:09.533]             function(cond) {
[17:42:09.533]                 is_error <- inherits(cond, "error")
[17:42:09.533]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:09.533]                   NULL)
[17:42:09.533]                 if (is_error) {
[17:42:09.533]                   sessionInformation <- function() {
[17:42:09.533]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:09.533]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:09.533]                       search = base::search(), system = base::Sys.info())
[17:42:09.533]                   }
[17:42:09.533]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.533]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:09.533]                     cond$call), session = sessionInformation(), 
[17:42:09.533]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:09.533]                   signalCondition(cond)
[17:42:09.533]                 }
[17:42:09.533]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:09.533]                 "immediateCondition"))) {
[17:42:09.533]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:09.533]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.533]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:09.533]                   if (TRUE && !signal) {
[17:42:09.533]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.533]                     {
[17:42:09.533]                       inherits <- base::inherits
[17:42:09.533]                       invokeRestart <- base::invokeRestart
[17:42:09.533]                       is.null <- base::is.null
[17:42:09.533]                       muffled <- FALSE
[17:42:09.533]                       if (inherits(cond, "message")) {
[17:42:09.533]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.533]                         if (muffled) 
[17:42:09.533]                           invokeRestart("muffleMessage")
[17:42:09.533]                       }
[17:42:09.533]                       else if (inherits(cond, "warning")) {
[17:42:09.533]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.533]                         if (muffled) 
[17:42:09.533]                           invokeRestart("muffleWarning")
[17:42:09.533]                       }
[17:42:09.533]                       else if (inherits(cond, "condition")) {
[17:42:09.533]                         if (!is.null(pattern)) {
[17:42:09.533]                           computeRestarts <- base::computeRestarts
[17:42:09.533]                           grepl <- base::grepl
[17:42:09.533]                           restarts <- computeRestarts(cond)
[17:42:09.533]                           for (restart in restarts) {
[17:42:09.533]                             name <- restart$name
[17:42:09.533]                             if (is.null(name)) 
[17:42:09.533]                               next
[17:42:09.533]                             if (!grepl(pattern, name)) 
[17:42:09.533]                               next
[17:42:09.533]                             invokeRestart(restart)
[17:42:09.533]                             muffled <- TRUE
[17:42:09.533]                             break
[17:42:09.533]                           }
[17:42:09.533]                         }
[17:42:09.533]                       }
[17:42:09.533]                       invisible(muffled)
[17:42:09.533]                     }
[17:42:09.533]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.533]                   }
[17:42:09.533]                 }
[17:42:09.533]                 else {
[17:42:09.533]                   if (TRUE) {
[17:42:09.533]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.533]                     {
[17:42:09.533]                       inherits <- base::inherits
[17:42:09.533]                       invokeRestart <- base::invokeRestart
[17:42:09.533]                       is.null <- base::is.null
[17:42:09.533]                       muffled <- FALSE
[17:42:09.533]                       if (inherits(cond, "message")) {
[17:42:09.533]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.533]                         if (muffled) 
[17:42:09.533]                           invokeRestart("muffleMessage")
[17:42:09.533]                       }
[17:42:09.533]                       else if (inherits(cond, "warning")) {
[17:42:09.533]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.533]                         if (muffled) 
[17:42:09.533]                           invokeRestart("muffleWarning")
[17:42:09.533]                       }
[17:42:09.533]                       else if (inherits(cond, "condition")) {
[17:42:09.533]                         if (!is.null(pattern)) {
[17:42:09.533]                           computeRestarts <- base::computeRestarts
[17:42:09.533]                           grepl <- base::grepl
[17:42:09.533]                           restarts <- computeRestarts(cond)
[17:42:09.533]                           for (restart in restarts) {
[17:42:09.533]                             name <- restart$name
[17:42:09.533]                             if (is.null(name)) 
[17:42:09.533]                               next
[17:42:09.533]                             if (!grepl(pattern, name)) 
[17:42:09.533]                               next
[17:42:09.533]                             invokeRestart(restart)
[17:42:09.533]                             muffled <- TRUE
[17:42:09.533]                             break
[17:42:09.533]                           }
[17:42:09.533]                         }
[17:42:09.533]                       }
[17:42:09.533]                       invisible(muffled)
[17:42:09.533]                     }
[17:42:09.533]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.533]                   }
[17:42:09.533]                 }
[17:42:09.533]             }
[17:42:09.533]         }))
[17:42:09.533]     }, error = function(ex) {
[17:42:09.533]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:09.533]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.533]                 ...future.rng), started = ...future.startTime, 
[17:42:09.533]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:09.533]             version = "1.8"), class = "FutureResult")
[17:42:09.533]     }, finally = {
[17:42:09.533]         if (!identical(...future.workdir, getwd())) 
[17:42:09.533]             setwd(...future.workdir)
[17:42:09.533]         {
[17:42:09.533]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:09.533]                 ...future.oldOptions$nwarnings <- NULL
[17:42:09.533]             }
[17:42:09.533]             base::options(...future.oldOptions)
[17:42:09.533]             if (.Platform$OS.type == "windows") {
[17:42:09.533]                 old_names <- names(...future.oldEnvVars)
[17:42:09.533]                 envs <- base::Sys.getenv()
[17:42:09.533]                 names <- names(envs)
[17:42:09.533]                 common <- intersect(names, old_names)
[17:42:09.533]                 added <- setdiff(names, old_names)
[17:42:09.533]                 removed <- setdiff(old_names, names)
[17:42:09.533]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:09.533]                   envs[common]]
[17:42:09.533]                 NAMES <- toupper(changed)
[17:42:09.533]                 args <- list()
[17:42:09.533]                 for (kk in seq_along(NAMES)) {
[17:42:09.533]                   name <- changed[[kk]]
[17:42:09.533]                   NAME <- NAMES[[kk]]
[17:42:09.533]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.533]                     next
[17:42:09.533]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.533]                 }
[17:42:09.533]                 NAMES <- toupper(added)
[17:42:09.533]                 for (kk in seq_along(NAMES)) {
[17:42:09.533]                   name <- added[[kk]]
[17:42:09.533]                   NAME <- NAMES[[kk]]
[17:42:09.533]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.533]                     next
[17:42:09.533]                   args[[name]] <- ""
[17:42:09.533]                 }
[17:42:09.533]                 NAMES <- toupper(removed)
[17:42:09.533]                 for (kk in seq_along(NAMES)) {
[17:42:09.533]                   name <- removed[[kk]]
[17:42:09.533]                   NAME <- NAMES[[kk]]
[17:42:09.533]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.533]                     next
[17:42:09.533]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.533]                 }
[17:42:09.533]                 if (length(args) > 0) 
[17:42:09.533]                   base::do.call(base::Sys.setenv, args = args)
[17:42:09.533]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:09.533]             }
[17:42:09.533]             else {
[17:42:09.533]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:09.533]             }
[17:42:09.533]             {
[17:42:09.533]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:09.533]                   0L) {
[17:42:09.533]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:09.533]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:09.533]                   base::options(opts)
[17:42:09.533]                 }
[17:42:09.533]                 {
[17:42:09.533]                   {
[17:42:09.533]                     NULL
[17:42:09.533]                     RNGkind("Mersenne-Twister")
[17:42:09.533]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:09.533]                       inherits = FALSE)
[17:42:09.533]                   }
[17:42:09.533]                   options(future.plan = NULL)
[17:42:09.533]                   if (is.na(NA_character_)) 
[17:42:09.533]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.533]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:09.533]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:09.533]                   {
[17:42:09.533]                     future <- SequentialFuture(..., envir = envir)
[17:42:09.533]                     if (!future$lazy) 
[17:42:09.533]                       future <- run(future)
[17:42:09.533]                     invisible(future)
[17:42:09.533]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:09.533]                 }
[17:42:09.533]             }
[17:42:09.533]         }
[17:42:09.533]     })
[17:42:09.533]     if (TRUE) {
[17:42:09.533]         base::sink(type = "output", split = FALSE)
[17:42:09.533]         if (TRUE) {
[17:42:09.533]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:09.533]         }
[17:42:09.533]         else {
[17:42:09.533]             ...future.result["stdout"] <- base::list(NULL)
[17:42:09.533]         }
[17:42:09.533]         base::close(...future.stdout)
[17:42:09.533]         ...future.stdout <- NULL
[17:42:09.533]     }
[17:42:09.533]     ...future.result$conditions <- ...future.conditions
[17:42:09.533]     ...future.result$finished <- base::Sys.time()
[17:42:09.533]     ...future.result
[17:42:09.533] }
[17:42:09.534] plan(): Setting new future strategy stack:
[17:42:09.535] List of future strategies:
[17:42:09.535] 1. sequential:
[17:42:09.535]    - args: function (..., envir = parent.frame())
[17:42:09.535]    - tweaked: FALSE
[17:42:09.535]    - call: NULL
[17:42:09.535] plan(): nbrOfWorkers() = 1
[17:42:09.568] plan(): Setting new future strategy stack:
[17:42:09.568] List of future strategies:
[17:42:09.568] 1. sequential:
[17:42:09.568]    - args: function (..., envir = parent.frame())
[17:42:09.568]    - tweaked: FALSE
[17:42:09.568]    - call: plan(strategy)
[17:42:09.569] plan(): nbrOfWorkers() = 1
[17:42:09.569] SequentialFuture started (and completed)
[17:42:09.569] signalConditions() ...
[17:42:09.569]  - include = ‘immediateCondition’
[17:42:09.569]  - exclude = 
[17:42:09.569]  - resignal = FALSE
[17:42:09.569]  - Number of conditions: 88
[17:42:09.570] signalConditions() ... done
[17:42:09.570] - Launch lazy future ... done
[17:42:09.570] run() for ‘SequentialFuture’ ... done
[17:42:09.570] signalConditions() ...
[17:42:09.570]  - include = ‘immediateCondition’
[17:42:09.570]  - exclude = 
[17:42:09.570]  - resignal = FALSE
[17:42:09.570]  - Number of conditions: 88
[17:42:09.570] signalConditions() ... done
[17:42:09.571] Future state: ‘finished’
[17:42:09.571] signalConditions() ...
[17:42:09.571]  - include = ‘condition’
[17:42:09.571]  - exclude = ‘immediateCondition’
[17:42:09.571]  - resignal = TRUE
[17:42:09.571]  - Number of conditions: 88
[17:42:09.571]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.535] getGlobalsAndPackages() ...
[17:42:09.571]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.536] Searching for globals...
[17:42:09.571]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.549] 
[17:42:09.572]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.549] Searching for globals ... DONE
[17:42:09.572]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.549] - globals: [0] <none>
[17:42:09.572]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.549] getGlobalsAndPackages() ... DONE
[17:42:09.572]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.551] run() for ‘Future’ ...
[17:42:09.572]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.551] - state: ‘created’
[17:42:09.572]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.552] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:09.572]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.552] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:09.573]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.552] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:09.573]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.552]   - Field: ‘label’
[17:42:09.573]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.552]   - Field: ‘local’
[17:42:09.573]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.552]   - Field: ‘owner’
[17:42:09.573]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.552]   - Field: ‘envir’
[17:42:09.573]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.553]   - Field: ‘packages’
[17:42:09.573]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.553]   - Field: ‘gc’
[17:42:09.573]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.553]   - Field: ‘conditions’
[17:42:09.574]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.553]   - Field: ‘expr’
[17:42:09.574]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.553]   - Field: ‘uuid’
[17:42:09.574]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.553]   - Field: ‘seed’
[17:42:09.574]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.553]   - Field: ‘version’
[17:42:09.574]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.553]   - Field: ‘result’
[17:42:09.574]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.553]   - Field: ‘asynchronous’
[17:42:09.574]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.554]   - Field: ‘calls’
[17:42:09.575]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.554]   - Field: ‘globals’
[17:42:09.575]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.554]   - Field: ‘stdout’
[17:42:09.575]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.554]   - Field: ‘earlySignal’
[17:42:09.575]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.554]   - Field: ‘lazy’
[17:42:09.575]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.554]   - Field: ‘state’
[17:42:09.575]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.554] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:09.575]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.554] - Launch lazy future ...
[17:42:09.575]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.554] Packages needed by the future expression (n = 0): <none>
[17:42:09.576]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.555] Packages needed by future strategies (n = 0): <none>
[17:42:09.576]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.555] {
[17:42:09.555]     {
[17:42:09.555]         {
[17:42:09.555]             ...future.startTime <- base::Sys.time()
[17:42:09.555]             {
[17:42:09.555]                 {
[17:42:09.555]                   {
[17:42:09.555]                     base::local({
[17:42:09.555]                       has_future <- base::requireNamespace("future", 
[17:42:09.555]                         quietly = TRUE)
[17:42:09.555]                       if (has_future) {
[17:42:09.555]                         ns <- base::getNamespace("future")
[17:42:09.555]                         version <- ns[[".package"]][["version"]]
[17:42:09.555]                         if (is.null(version)) 
[17:42:09.555]                           version <- utils::packageVersion("future")
[17:42:09.555]                       }
[17:42:09.555]                       else {
[17:42:09.555]                         version <- NULL
[17:42:09.555]                       }
[17:42:09.555]                       if (!has_future || version < "1.8.0") {
[17:42:09.555]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:09.555]                           "", base::R.version$version.string), 
[17:42:09.555]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:09.555]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:09.555]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:09.555]                             "release", "version")], collapse = " "), 
[17:42:09.555]                           hostname = base::Sys.info()[["nodename"]])
[17:42:09.555]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:09.555]                           info)
[17:42:09.555]                         info <- base::paste(info, collapse = "; ")
[17:42:09.555]                         if (!has_future) {
[17:42:09.555]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:09.555]                             info)
[17:42:09.555]                         }
[17:42:09.555]                         else {
[17:42:09.555]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:09.555]                             info, version)
[17:42:09.555]                         }
[17:42:09.555]                         base::stop(msg)
[17:42:09.555]                       }
[17:42:09.555]                     })
[17:42:09.555]                   }
[17:42:09.555]                   options(future.plan = NULL)
[17:42:09.555]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.555]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:09.555]                 }
[17:42:09.555]                 ...future.workdir <- getwd()
[17:42:09.555]             }
[17:42:09.555]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:09.555]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:09.555]         }
[17:42:09.555]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:09.555]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:09.555]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:09.555]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:09.555]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:09.555]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:09.555]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:09.555]             base::names(...future.oldOptions))
[17:42:09.555]     }
[17:42:09.555]     if (FALSE) {
[17:42:09.555]     }
[17:42:09.555]     else {
[17:42:09.555]         if (TRUE) {
[17:42:09.555]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:09.555]                 open = "w")
[17:42:09.555]         }
[17:42:09.555]         else {
[17:42:09.555]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:09.555]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:09.555]         }
[17:42:09.555]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:09.555]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:09.555]             base::sink(type = "output", split = FALSE)
[17:42:09.555]             base::close(...future.stdout)
[17:42:09.555]         }, add = TRUE)
[17:42:09.555]     }
[17:42:09.555]     ...future.frame <- base::sys.nframe()
[17:42:09.555]     ...future.conditions <- base::list()
[17:42:09.555]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:09.555]     if (FALSE) {
[17:42:09.555]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:09.555]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:09.555]     }
[17:42:09.555]     ...future.result <- base::tryCatch({
[17:42:09.555]         base::withCallingHandlers({
[17:42:09.555]             ...future.value <- base::withVisible(base::local(2))
[17:42:09.555]             future::FutureResult(value = ...future.value$value, 
[17:42:09.555]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.555]                   ...future.rng), globalenv = if (FALSE) 
[17:42:09.555]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:09.555]                     ...future.globalenv.names))
[17:42:09.555]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:09.555]         }, condition = base::local({
[17:42:09.555]             c <- base::c
[17:42:09.555]             inherits <- base::inherits
[17:42:09.555]             invokeRestart <- base::invokeRestart
[17:42:09.555]             length <- base::length
[17:42:09.555]             list <- base::list
[17:42:09.555]             seq.int <- base::seq.int
[17:42:09.555]             signalCondition <- base::signalCondition
[17:42:09.555]             sys.calls <- base::sys.calls
[17:42:09.555]             `[[` <- base::`[[`
[17:42:09.555]             `+` <- base::`+`
[17:42:09.555]             `<<-` <- base::`<<-`
[17:42:09.555]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:09.555]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:09.555]                   3L)]
[17:42:09.555]             }
[17:42:09.555]             function(cond) {
[17:42:09.555]                 is_error <- inherits(cond, "error")
[17:42:09.555]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:09.555]                   NULL)
[17:42:09.555]                 if (is_error) {
[17:42:09.555]                   sessionInformation <- function() {
[17:42:09.555]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:09.555]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:09.555]                       search = base::search(), system = base::Sys.info())
[17:42:09.555]                   }
[17:42:09.555]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.555]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:09.555]                     cond$call), session = sessionInformation(), 
[17:42:09.555]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:09.555]                   signalCondition(cond)
[17:42:09.555]                 }
[17:42:09.555]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:09.555]                 "immediateCondition"))) {
[17:42:09.555]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:09.555]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.555]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:09.555]                   if (TRUE && !signal) {
[17:42:09.555]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.555]                     {
[17:42:09.555]                       inherits <- base::inherits
[17:42:09.555]                       invokeRestart <- base::invokeRestart
[17:42:09.555]                       is.null <- base::is.null
[17:42:09.555]                       muffled <- FALSE
[17:42:09.555]                       if (inherits(cond, "message")) {
[17:42:09.555]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.555]                         if (muffled) 
[17:42:09.555]                           invokeRestart("muffleMessage")
[17:42:09.555]                       }
[17:42:09.555]                       else if (inherits(cond, "warning")) {
[17:42:09.555]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.555]                         if (muffled) 
[17:42:09.555]                           invokeRestart("muffleWarning")
[17:42:09.555]                       }
[17:42:09.555]                       else if (inherits(cond, "condition")) {
[17:42:09.555]                         if (!is.null(pattern)) {
[17:42:09.555]                           computeRestarts <- base::computeRestarts
[17:42:09.555]                           grepl <- base::grepl
[17:42:09.555]                           restarts <- computeRestarts(cond)
[17:42:09.555]                           for (restart in restarts) {
[17:42:09.555]                             name <- restart$name
[17:42:09.555]                             if (is.null(name)) 
[17:42:09.555]                               next
[17:42:09.555]                             if (!grepl(pattern, name)) 
[17:42:09.555]                               next
[17:42:09.555]                             invokeRestart(restart)
[17:42:09.555]                             muffled <- TRUE
[17:42:09.555]                             break
[17:42:09.555]                           }
[17:42:09.555]                         }
[17:42:09.555]                       }
[17:42:09.555]                       invisible(muffled)
[17:42:09.555]                     }
[17:42:09.555]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.555]                   }
[17:42:09.555]                 }
[17:42:09.555]                 else {
[17:42:09.555]                   if (TRUE) {
[17:42:09.555]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.555]                     {
[17:42:09.555]                       inherits <- base::inherits
[17:42:09.555]                       invokeRestart <- base::invokeRestart
[17:42:09.555]                       is.null <- base::is.null
[17:42:09.555]                       muffled <- FALSE
[17:42:09.555]                       if (inherits(cond, "message")) {
[17:42:09.555]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.555]                         if (muffled) 
[17:42:09.555]                           invokeRestart("muffleMessage")
[17:42:09.555]                       }
[17:42:09.555]                       else if (inherits(cond, "warning")) {
[17:42:09.555]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.555]                         if (muffled) 
[17:42:09.555]                           invokeRestart("muffleWarning")
[17:42:09.555]                       }
[17:42:09.555]                       else if (inherits(cond, "condition")) {
[17:42:09.555]                         if (!is.null(pattern)) {
[17:42:09.555]                           computeRestarts <- base::computeRestarts
[17:42:09.555]                           grepl <- base::grepl
[17:42:09.555]                           restarts <- computeRestarts(cond)
[17:42:09.555]                           for (restart in restarts) {
[17:42:09.555]                             name <- restart$name
[17:42:09.555]                             if (is.null(name)) 
[17:42:09.555]                               next
[17:42:09.555]                             if (!grepl(pattern, name)) 
[17:42:09.555]                               next
[17:42:09.555]                             invokeRestart(restart)
[17:42:09.555]                             muffled <- TRUE
[17:42:09.555]                             break
[17:42:09.555]                           }
[17:42:09.555]                         }
[17:42:09.555]                       }
[17:42:09.555]                       invisible(muffled)
[17:42:09.555]                     }
[17:42:09.555]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.555]                   }
[17:42:09.555]                 }
[17:42:09.555]             }
[17:42:09.555]         }))
[17:42:09.555]     }, error = function(ex) {
[17:42:09.555]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:09.555]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.555]                 ...future.rng), started = ...future.startTime, 
[17:42:09.555]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:09.555]             version = "1.8"), class = "FutureResult")
[17:42:09.555]     }, finally = {
[17:42:09.555]         if (!identical(...future.workdir, getwd())) 
[17:42:09.555]             setwd(...future.workdir)
[17:42:09.555]         {
[17:42:09.555]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:09.555]                 ...future.oldOptions$nwarnings <- NULL
[17:42:09.555]             }
[17:42:09.555]             base::options(...future.oldOptions)
[17:42:09.555]             if (.Platform$OS.type == "windows") {
[17:42:09.555]                 old_names <- names(...future.oldEnvVars)
[17:42:09.555]                 envs <- base::Sys.getenv()
[17:42:09.555]                 names <- names(envs)
[17:42:09.555]                 common <- intersect(names, old_names)
[17:42:09.555]                 added <- setdiff(names, old_names)
[17:42:09.555]                 removed <- setdiff(old_names, names)
[17:42:09.555]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:09.555]                   envs[common]]
[17:42:09.555]                 NAMES <- toupper(changed)
[17:42:09.555]                 args <- list()
[17:42:09.555]                 for (kk in seq_along(NAMES)) {
[17:42:09.555]                   name <- changed[[kk]]
[17:42:09.555]                   NAME <- NAMES[[kk]]
[17:42:09.555]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.555]                     next
[17:42:09.555]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.555]                 }
[17:42:09.555]                 NAMES <- toupper(added)
[17:42:09.555]                 for (kk in seq_along(NAMES)) {
[17:42:09.555]                   name <- added[[kk]]
[17:42:09.555]                   NAME <- NAMES[[kk]]
[17:42:09.555]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.555]                     next
[17:42:09.555]                   args[[name]] <- ""
[17:42:09.555]                 }
[17:42:09.555]                 NAMES <- toupper(removed)
[17:42:09.555]                 for (kk in seq_along(NAMES)) {
[17:42:09.555]                   name <- removed[[kk]]
[17:42:09.555]                   NAME <- NAMES[[kk]]
[17:42:09.555]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.555]                     next
[17:42:09.555]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.555]                 }
[17:42:09.555]                 if (length(args) > 0) 
[17:42:09.555]                   base::do.call(base::Sys.setenv, args = args)
[17:42:09.555]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:09.555]             }
[17:42:09.555]             else {
[17:42:09.555]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:09.555]             }
[17:42:09.555]             {
[17:42:09.555]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:09.555]                   0L) {
[17:42:09.555]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:09.555]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:09.555]                   base::options(opts)
[17:42:09.555]                 }
[17:42:09.555]                 {
[17:42:09.555]                   {
[17:42:09.555]                     NULL
[17:42:09.555]                     RNGkind("Mersenne-Twister")
[17:42:09.555]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:09.555]                       inherits = FALSE)
[17:42:09.555]                   }
[17:42:09.555]                   options(future.plan = NULL)
[17:42:09.555]                   if (is.na(NA_character_)) 
[17:42:09.555]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.555]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:09.555]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:09.555]                   {
[17:42:09.555]                     future <- SequentialFuture(..., envir = envir)
[17:42:09.555]                     if (!future$lazy) 
[17:42:09.555]                       future <- run(future)
[17:42:09.555]                     invisible(future)
[17:42:09.555]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:09.555]                 }
[17:42:09.555]             }
[17:42:09.555]         }
[17:42:09.555]     })
[17:42:09.555]     if (TRUE) {
[17:42:09.555]         base::sink(type = "output", split = FALSE)
[17:42:09.555]         if (TRUE) {
[17:42:09.555]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:09.555]         }
[17:42:09.555]         else {
[17:42:09.555]             ...future.result["stdout"] <- base::list(NULL)
[17:42:09.555]         }
[17:42:09.555]         base::close(...future.stdout)
[17:42:09.555]         ...future.stdout <- NULL
[17:42:09.555]     }
[17:42:09.555]     ...future.result$conditions <- ...future.conditions
[17:42:09.555]     ...future.result$finished <- base::Sys.time()
[17:42:09.555]     ...future.result
[17:42:09.555] }
[17:42:09.576]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.557] plan(): Setting new future strategy stack:
[17:42:09.576]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.557] List of future strategies:
[17:42:09.557] 1. sequential:
[17:42:09.557]    - args: function (..., envir = parent.frame())
[17:42:09.557]    - tweaked: FALSE
[17:42:09.557]    - call: NULL
[17:42:09.576]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.557] plan(): nbrOfWorkers() = 1
[17:42:09.576]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.558] plan(): Setting new future strategy stack:
[17:42:09.579]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.558] List of future strategies:
[17:42:09.558] 1. sequential:
[17:42:09.558]    - args: function (..., envir = parent.frame())
[17:42:09.558]    - tweaked: FALSE
[17:42:09.558]    - call: NULL
[17:42:09.579]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.558] plan(): nbrOfWorkers() = 1
[17:42:09.579]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.559] SequentialFuture started (and completed)
[17:42:09.579]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.559] - Launch lazy future ... done
[17:42:09.579]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.559] run() for ‘SequentialFuture’ ... done
[17:42:09.579]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.559] getGlobalsAndPackages() ...
[17:42:09.580]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.559] Searching for globals...
[17:42:09.580]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.560] 
[17:42:09.580]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.560] Searching for globals ... DONE
[17:42:09.580]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.560] - globals: [0] <none>
[17:42:09.580]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.560] getGlobalsAndPackages() ... DONE
[17:42:09.580]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.560] run() for ‘Future’ ...
[17:42:09.580]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.560] - state: ‘created’
[17:42:09.581]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.560] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:09.581]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.561] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:09.581]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.561] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:09.581]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.561]   - Field: ‘label’
[17:42:09.581]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.561]   - Field: ‘local’
[17:42:09.581]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.561]   - Field: ‘owner’
[17:42:09.581]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.561]   - Field: ‘envir’
[17:42:09.581]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.561]   - Field: ‘packages’
[17:42:09.582]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.561]   - Field: ‘gc’
[17:42:09.582]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.562]   - Field: ‘conditions’
[17:42:09.582]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.562]   - Field: ‘expr’
[17:42:09.582]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.562]   - Field: ‘uuid’
[17:42:09.582]  - Condition #65: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.562]   - Field: ‘seed’
[17:42:09.582]  - Condition #66: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.562]   - Field: ‘version’
[17:42:09.582]  - Condition #67: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.562]   - Field: ‘result’
[17:42:09.583]  - Condition #68: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.562]   - Field: ‘asynchronous’
[17:42:09.583]  - Condition #69: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.562]   - Field: ‘calls’
[17:42:09.583]  - Condition #70: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.562]   - Field: ‘globals’
[17:42:09.583]  - Condition #71: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.562]   - Field: ‘stdout’
[17:42:09.583]  - Condition #72: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.563]   - Field: ‘earlySignal’
[17:42:09.583]  - Condition #73: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.563]   - Field: ‘lazy’
[17:42:09.583]  - Condition #74: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.563]   - Field: ‘state’
[17:42:09.583]  - Condition #75: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.563] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:09.584]  - Condition #76: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.563] - Launch lazy future ...
[17:42:09.584]  - Condition #77: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.563] Packages needed by the future expression (n = 0): <none>
[17:42:09.584]  - Condition #78: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.563] Packages needed by future strategies (n = 0): <none>
[17:42:09.584]  - Condition #79: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.564] {
[17:42:09.564]     {
[17:42:09.564]         {
[17:42:09.564]             ...future.startTime <- base::Sys.time()
[17:42:09.564]             {
[17:42:09.564]                 {
[17:42:09.564]                   {
[17:42:09.564]                     base::local({
[17:42:09.564]                       has_future <- base::requireNamespace("future", 
[17:42:09.564]                         quietly = TRUE)
[17:42:09.564]                       if (has_future) {
[17:42:09.564]                         ns <- base::getNamespace("future")
[17:42:09.564]                         version <- ns[[".package"]][["version"]]
[17:42:09.564]                         if (is.null(version)) 
[17:42:09.564]                           version <- utils::packageVersion("future")
[17:42:09.564]                       }
[17:42:09.564]                       else {
[17:42:09.564]                         version <- NULL
[17:42:09.564]                       }
[17:42:09.564]                       if (!has_future || version < "1.8.0") {
[17:42:09.564]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:09.564]                           "", base::R.version$version.string), 
[17:42:09.564]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:09.564]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:09.564]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:09.564]                             "release", "version")], collapse = " "), 
[17:42:09.564]                           hostname = base::Sys.info()[["nodename"]])
[17:42:09.564]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:09.564]                           info)
[17:42:09.564]                         info <- base::paste(info, collapse = "; ")
[17:42:09.564]                         if (!has_future) {
[17:42:09.564]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:09.564]                             info)
[17:42:09.564]                         }
[17:42:09.564]                         else {
[17:42:09.564]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:09.564]                             info, version)
[17:42:09.564]                         }
[17:42:09.564]                         base::stop(msg)
[17:42:09.564]                       }
[17:42:09.564]                     })
[17:42:09.564]                   }
[17:42:09.564]                   options(future.plan = NULL)
[17:42:09.564]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.564]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:09.564]                 }
[17:42:09.564]                 ...future.workdir <- getwd()
[17:42:09.564]             }
[17:42:09.564]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:09.564]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:09.564]         }
[17:42:09.564]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:09.564]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:09.564]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:09.564]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:09.564]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:09.564]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:09.564]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:09.564]             base::names(...future.oldOptions))
[17:42:09.564]     }
[17:42:09.564]     if (FALSE) {
[17:42:09.564]     }
[17:42:09.564]     else {
[17:42:09.564]         if (TRUE) {
[17:42:09.564]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:09.564]                 open = "w")
[17:42:09.564]         }
[17:42:09.564]         else {
[17:42:09.564]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:09.564]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:09.564]         }
[17:42:09.564]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:09.564]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:09.564]             base::sink(type = "output", split = FALSE)
[17:42:09.564]             base::close(...future.stdout)
[17:42:09.564]         }, add = TRUE)
[17:42:09.564]     }
[17:42:09.564]     ...future.frame <- base::sys.nframe()
[17:42:09.564]     ...future.conditions <- base::list()
[17:42:09.564]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:09.564]     if (FALSE) {
[17:42:09.564]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:09.564]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:09.564]     }
[17:42:09.564]     ...future.result <- base::tryCatch({
[17:42:09.564]         base::withCallingHandlers({
[17:42:09.564]             ...future.value <- base::withVisible(base::local(4))
[17:42:09.564]             future::FutureResult(value = ...future.value$value, 
[17:42:09.564]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.564]                   ...future.rng), globalenv = if (FALSE) 
[17:42:09.564]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:09.564]                     ...future.globalenv.names))
[17:42:09.564]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:09.564]         }, condition = base::local({
[17:42:09.564]             c <- base::c
[17:42:09.564]             inherits <- base::inherits
[17:42:09.564]             invokeRestart <- base::invokeRestart
[17:42:09.564]             length <- base::length
[17:42:09.564]             list <- base::list
[17:42:09.564]             seq.int <- base::seq.int
[17:42:09.564]             signalCondition <- base::signalCondition
[17:42:09.564]             sys.calls <- base::sys.calls
[17:42:09.564]             `[[` <- base::`[[`
[17:42:09.564]             `+` <- base::`+`
[17:42:09.564]             `<<-` <- base::`<<-`
[17:42:09.564]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:09.564]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:09.564]                   3L)]
[17:42:09.564]             }
[17:42:09.564]             function(cond) {
[17:42:09.564]                 is_error <- inherits(cond, "error")
[17:42:09.564]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:09.564]                   NULL)
[17:42:09.564]                 if (is_error) {
[17:42:09.564]                   sessionInformation <- function() {
[17:42:09.564]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:09.564]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:09.564]                       search = base::search(), system = base::Sys.info())
[17:42:09.564]                   }
[17:42:09.564]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.564]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:09.564]                     cond$call), session = sessionInformation(), 
[17:42:09.564]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:09.564]                   signalCondition(cond)
[17:42:09.564]                 }
[17:42:09.564]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:09.564]                 "immediateCondition"))) {
[17:42:09.564]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:09.564]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.564]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:09.564]                   if (TRUE && !signal) {
[17:42:09.564]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.564]                     {
[17:42:09.564]                       inherits <- base::inherits
[17:42:09.564]                       invokeRestart <- base::invokeRestart
[17:42:09.564]                       is.null <- base::is.null
[17:42:09.564]                       muffled <- FALSE
[17:42:09.564]                       if (inherits(cond, "message")) {
[17:42:09.564]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.564]                         if (muffled) 
[17:42:09.564]                           invokeRestart("muffleMessage")
[17:42:09.564]                       }
[17:42:09.564]                       else if (inherits(cond, "warning")) {
[17:42:09.564]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.564]                         if (muffled) 
[17:42:09.564]                           invokeRestart("muffleWarning")
[17:42:09.564]                       }
[17:42:09.564]                       else if (inherits(cond, "condition")) {
[17:42:09.564]                         if (!is.null(pattern)) {
[17:42:09.564]                           computeRestarts <- base::computeRestarts
[17:42:09.564]                           grepl <- base::grepl
[17:42:09.564]                           restarts <- computeRestarts(cond)
[17:42:09.564]                           for (restart in restarts) {
[17:42:09.564]                             name <- restart$name
[17:42:09.564]                             if (is.null(name)) 
[17:42:09.564]                               next
[17:42:09.564]                             if (!grepl(pattern, name)) 
[17:42:09.564]                               next
[17:42:09.564]                             invokeRestart(restart)
[17:42:09.564]                             muffled <- TRUE
[17:42:09.564]                             break
[17:42:09.564]                           }
[17:42:09.564]                         }
[17:42:09.564]                       }
[17:42:09.564]                       invisible(muffled)
[17:42:09.564]                     }
[17:42:09.564]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.564]                   }
[17:42:09.564]                 }
[17:42:09.564]                 else {
[17:42:09.564]                   if (TRUE) {
[17:42:09.564]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.564]                     {
[17:42:09.564]                       inherits <- base::inherits
[17:42:09.564]                       invokeRestart <- base::invokeRestart
[17:42:09.564]                       is.null <- base::is.null
[17:42:09.564]                       muffled <- FALSE
[17:42:09.564]                       if (inherits(cond, "message")) {
[17:42:09.564]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.564]                         if (muffled) 
[17:42:09.564]                           invokeRestart("muffleMessage")
[17:42:09.564]                       }
[17:42:09.564]                       else if (inherits(cond, "warning")) {
[17:42:09.564]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.564]                         if (muffled) 
[17:42:09.564]                           invokeRestart("muffleWarning")
[17:42:09.564]                       }
[17:42:09.564]                       else if (inherits(cond, "condition")) {
[17:42:09.564]                         if (!is.null(pattern)) {
[17:42:09.564]                           computeRestarts <- base::computeRestarts
[17:42:09.564]                           grepl <- base::grepl
[17:42:09.564]                           restarts <- computeRestarts(cond)
[17:42:09.564]                           for (restart in restarts) {
[17:42:09.564]                             name <- restart$name
[17:42:09.564]                             if (is.null(name)) 
[17:42:09.564]                               next
[17:42:09.564]                             if (!grepl(pattern, name)) 
[17:42:09.564]                               next
[17:42:09.564]                             invokeRestart(restart)
[17:42:09.564]                             muffled <- TRUE
[17:42:09.564]                             break
[17:42:09.564]                           }
[17:42:09.564]                         }
[17:42:09.564]                       }
[17:42:09.564]                       invisible(muffled)
[17:42:09.564]                     }
[17:42:09.564]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.564]                   }
[17:42:09.564]                 }
[17:42:09.564]             }
[17:42:09.564]         }))
[17:42:09.564]     }, error = function(ex) {
[17:42:09.564]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:09.564]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.564]                 ...future.rng), started = ...future.startTime, 
[17:42:09.564]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:09.564]             version = "1.8"), class = "FutureResult")
[17:42:09.564]     }, finally = {
[17:42:09.564]         if (!identical(...future.workdir, getwd())) 
[17:42:09.564]             setwd(...future.workdir)
[17:42:09.564]         {
[17:42:09.564]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:09.564]                 ...future.oldOptions$nwarnings <- NULL
[17:42:09.564]             }
[17:42:09.564]             base::options(...future.oldOptions)
[17:42:09.564]             if (.Platform$OS.type == "windows") {
[17:42:09.564]                 old_names <- names(...future.oldEnvVars)
[17:42:09.564]                 envs <- base::Sys.getenv()
[17:42:09.564]                 names <- names(envs)
[17:42:09.564]                 common <- intersect(names, old_names)
[17:42:09.564]                 added <- setdiff(names, old_names)
[17:42:09.564]                 removed <- setdiff(old_names, names)
[17:42:09.564]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:09.564]                   envs[common]]
[17:42:09.564]                 NAMES <- toupper(changed)
[17:42:09.564]                 args <- list()
[17:42:09.564]                 for (kk in seq_along(NAMES)) {
[17:42:09.564]                   name <- changed[[kk]]
[17:42:09.564]                   NAME <- NAMES[[kk]]
[17:42:09.564]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.564]                     next
[17:42:09.564]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.564]                 }
[17:42:09.564]                 NAMES <- toupper(added)
[17:42:09.564]                 for (kk in seq_along(NAMES)) {
[17:42:09.564]                   name <- added[[kk]]
[17:42:09.564]                   NAME <- NAMES[[kk]]
[17:42:09.564]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.564]                     next
[17:42:09.564]                   args[[name]] <- ""
[17:42:09.564]                 }
[17:42:09.564]                 NAMES <- toupper(removed)
[17:42:09.564]                 for (kk in seq_along(NAMES)) {
[17:42:09.564]                   name <- removed[[kk]]
[17:42:09.564]                   NAME <- NAMES[[kk]]
[17:42:09.564]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.564]                     next
[17:42:09.564]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.564]                 }
[17:42:09.564]                 if (length(args) > 0) 
[17:42:09.564]                   base::do.call(base::Sys.setenv, args = args)
[17:42:09.564]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:09.564]             }
[17:42:09.564]             else {
[17:42:09.564]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:09.564]             }
[17:42:09.564]             {
[17:42:09.564]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:09.564]                   0L) {
[17:42:09.564]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:09.564]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:09.564]                   base::options(opts)
[17:42:09.564]                 }
[17:42:09.564]                 {
[17:42:09.564]                   {
[17:42:09.564]                     NULL
[17:42:09.564]                     RNGkind("Mersenne-Twister")
[17:42:09.564]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:09.564]                       inherits = FALSE)
[17:42:09.564]                   }
[17:42:09.564]                   options(future.plan = NULL)
[17:42:09.564]                   if (is.na(NA_character_)) 
[17:42:09.564]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.564]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:09.564]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:09.564]                   {
[17:42:09.564]                     future <- SequentialFuture(..., envir = envir)
[17:42:09.564]                     if (!future$lazy) 
[17:42:09.564]                       future <- run(future)
[17:42:09.564]                     invisible(future)
[17:42:09.564]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:09.564]                 }
[17:42:09.564]             }
[17:42:09.564]         }
[17:42:09.564]     })
[17:42:09.564]     if (TRUE) {
[17:42:09.564]         base::sink(type = "output", split = FALSE)
[17:42:09.564]         if (TRUE) {
[17:42:09.564]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:09.564]         }
[17:42:09.564]         else {
[17:42:09.564]             ...future.result["stdout"] <- base::list(NULL)
[17:42:09.564]         }
[17:42:09.564]         base::close(...future.stdout)
[17:42:09.564]         ...future.stdout <- NULL
[17:42:09.564]     }
[17:42:09.564]     ...future.result$conditions <- ...future.conditions
[17:42:09.564]     ...future.result$finished <- base::Sys.time()
[17:42:09.564]     ...future.result
[17:42:09.564] }
[17:42:09.584]  - Condition #80: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.565] plan(): Setting new future strategy stack:
[17:42:09.584]  - Condition #81: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.566] List of future strategies:
[17:42:09.566] 1. sequential:
[17:42:09.566]    - args: function (..., envir = parent.frame())
[17:42:09.566]    - tweaked: FALSE
[17:42:09.566]    - call: NULL
[17:42:09.584]  - Condition #82: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.566] plan(): nbrOfWorkers() = 1
[17:42:09.585]  - Condition #83: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.567] plan(): Setting new future strategy stack:
[17:42:09.585]  - Condition #84: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.567] List of future strategies:
[17:42:09.567] 1. sequential:
[17:42:09.567]    - args: function (..., envir = parent.frame())
[17:42:09.567]    - tweaked: FALSE
[17:42:09.567]    - call: NULL
[17:42:09.585]  - Condition #85: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.567] plan(): nbrOfWorkers() = 1
[17:42:09.585]  - Condition #86: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.567] SequentialFuture started (and completed)
[17:42:09.585]  - Condition #87: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.567] - Launch lazy future ... done
[17:42:09.585]  - Condition #88: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.568] run() for ‘SequentialFuture’ ... done
[17:42:09.585] signalConditions() ... done
a = 10
[17:42:09.586] getGlobalsAndPackages() ...
[17:42:09.586] Searching for globals...
[17:42:09.587] - globals found: [3] ‘{’, ‘+’, ‘a’
[17:42:09.587] Searching for globals ... DONE
[17:42:09.587] Resolving globals: FALSE
[17:42:09.587] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:09.588] The total size of the 1 globals exported for future expression (‘{; a + 1; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[17:42:09.588] - globals: [1] ‘a’
[17:42:09.588] 
[17:42:09.588] getGlobalsAndPackages() ... DONE
[17:42:09.588] run() for ‘Future’ ...
[17:42:09.588] - state: ‘created’
[17:42:09.589] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:09.589] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:09.589] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:09.589]   - Field: ‘label’
[17:42:09.589]   - Field: ‘local’
[17:42:09.589]   - Field: ‘owner’
[17:42:09.589]   - Field: ‘envir’
[17:42:09.589]   - Field: ‘packages’
[17:42:09.590]   - Field: ‘gc’
[17:42:09.590]   - Field: ‘conditions’
[17:42:09.590]   - Field: ‘expr’
[17:42:09.590]   - Field: ‘uuid’
[17:42:09.590]   - Field: ‘seed’
[17:42:09.590]   - Field: ‘version’
[17:42:09.590]   - Field: ‘result’
[17:42:09.590]   - Field: ‘asynchronous’
[17:42:09.590]   - Field: ‘calls’
[17:42:09.590]   - Field: ‘globals’
[17:42:09.590]   - Field: ‘stdout’
[17:42:09.591]   - Field: ‘earlySignal’
[17:42:09.591]   - Field: ‘lazy’
[17:42:09.591]   - Field: ‘state’
[17:42:09.591] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:09.591] - Launch lazy future ...
[17:42:09.591] Packages needed by the future expression (n = 0): <none>
[17:42:09.591] Packages needed by future strategies (n = 0): <none>
[17:42:09.592] {
[17:42:09.592]     {
[17:42:09.592]         {
[17:42:09.592]             ...future.startTime <- base::Sys.time()
[17:42:09.592]             {
[17:42:09.592]                 {
[17:42:09.592]                   {
[17:42:09.592]                     base::local({
[17:42:09.592]                       has_future <- base::requireNamespace("future", 
[17:42:09.592]                         quietly = TRUE)
[17:42:09.592]                       if (has_future) {
[17:42:09.592]                         ns <- base::getNamespace("future")
[17:42:09.592]                         version <- ns[[".package"]][["version"]]
[17:42:09.592]                         if (is.null(version)) 
[17:42:09.592]                           version <- utils::packageVersion("future")
[17:42:09.592]                       }
[17:42:09.592]                       else {
[17:42:09.592]                         version <- NULL
[17:42:09.592]                       }
[17:42:09.592]                       if (!has_future || version < "1.8.0") {
[17:42:09.592]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:09.592]                           "", base::R.version$version.string), 
[17:42:09.592]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:09.592]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:09.592]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:09.592]                             "release", "version")], collapse = " "), 
[17:42:09.592]                           hostname = base::Sys.info()[["nodename"]])
[17:42:09.592]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:09.592]                           info)
[17:42:09.592]                         info <- base::paste(info, collapse = "; ")
[17:42:09.592]                         if (!has_future) {
[17:42:09.592]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:09.592]                             info)
[17:42:09.592]                         }
[17:42:09.592]                         else {
[17:42:09.592]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:09.592]                             info, version)
[17:42:09.592]                         }
[17:42:09.592]                         base::stop(msg)
[17:42:09.592]                       }
[17:42:09.592]                     })
[17:42:09.592]                   }
[17:42:09.592]                   options(future.plan = NULL)
[17:42:09.592]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.592]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:09.592]                 }
[17:42:09.592]                 ...future.workdir <- getwd()
[17:42:09.592]             }
[17:42:09.592]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:09.592]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:09.592]         }
[17:42:09.592]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:09.592]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:09.592]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:09.592]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:09.592]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:09.592]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:09.592]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:09.592]             base::names(...future.oldOptions))
[17:42:09.592]     }
[17:42:09.592]     if (FALSE) {
[17:42:09.592]     }
[17:42:09.592]     else {
[17:42:09.592]         if (TRUE) {
[17:42:09.592]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:09.592]                 open = "w")
[17:42:09.592]         }
[17:42:09.592]         else {
[17:42:09.592]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:09.592]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:09.592]         }
[17:42:09.592]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:09.592]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:09.592]             base::sink(type = "output", split = FALSE)
[17:42:09.592]             base::close(...future.stdout)
[17:42:09.592]         }, add = TRUE)
[17:42:09.592]     }
[17:42:09.592]     ...future.frame <- base::sys.nframe()
[17:42:09.592]     ...future.conditions <- base::list()
[17:42:09.592]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:09.592]     if (FALSE) {
[17:42:09.592]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:09.592]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:09.592]     }
[17:42:09.592]     ...future.result <- base::tryCatch({
[17:42:09.592]         base::withCallingHandlers({
[17:42:09.592]             ...future.value <- base::withVisible(base::local({
[17:42:09.592]                 a + 1
[17:42:09.592]             }))
[17:42:09.592]             future::FutureResult(value = ...future.value$value, 
[17:42:09.592]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.592]                   ...future.rng), globalenv = if (FALSE) 
[17:42:09.592]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:09.592]                     ...future.globalenv.names))
[17:42:09.592]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:09.592]         }, condition = base::local({
[17:42:09.592]             c <- base::c
[17:42:09.592]             inherits <- base::inherits
[17:42:09.592]             invokeRestart <- base::invokeRestart
[17:42:09.592]             length <- base::length
[17:42:09.592]             list <- base::list
[17:42:09.592]             seq.int <- base::seq.int
[17:42:09.592]             signalCondition <- base::signalCondition
[17:42:09.592]             sys.calls <- base::sys.calls
[17:42:09.592]             `[[` <- base::`[[`
[17:42:09.592]             `+` <- base::`+`
[17:42:09.592]             `<<-` <- base::`<<-`
[17:42:09.592]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:09.592]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:09.592]                   3L)]
[17:42:09.592]             }
[17:42:09.592]             function(cond) {
[17:42:09.592]                 is_error <- inherits(cond, "error")
[17:42:09.592]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:09.592]                   NULL)
[17:42:09.592]                 if (is_error) {
[17:42:09.592]                   sessionInformation <- function() {
[17:42:09.592]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:09.592]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:09.592]                       search = base::search(), system = base::Sys.info())
[17:42:09.592]                   }
[17:42:09.592]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.592]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:09.592]                     cond$call), session = sessionInformation(), 
[17:42:09.592]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:09.592]                   signalCondition(cond)
[17:42:09.592]                 }
[17:42:09.592]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:09.592]                 "immediateCondition"))) {
[17:42:09.592]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:09.592]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.592]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:09.592]                   if (TRUE && !signal) {
[17:42:09.592]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.592]                     {
[17:42:09.592]                       inherits <- base::inherits
[17:42:09.592]                       invokeRestart <- base::invokeRestart
[17:42:09.592]                       is.null <- base::is.null
[17:42:09.592]                       muffled <- FALSE
[17:42:09.592]                       if (inherits(cond, "message")) {
[17:42:09.592]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.592]                         if (muffled) 
[17:42:09.592]                           invokeRestart("muffleMessage")
[17:42:09.592]                       }
[17:42:09.592]                       else if (inherits(cond, "warning")) {
[17:42:09.592]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.592]                         if (muffled) 
[17:42:09.592]                           invokeRestart("muffleWarning")
[17:42:09.592]                       }
[17:42:09.592]                       else if (inherits(cond, "condition")) {
[17:42:09.592]                         if (!is.null(pattern)) {
[17:42:09.592]                           computeRestarts <- base::computeRestarts
[17:42:09.592]                           grepl <- base::grepl
[17:42:09.592]                           restarts <- computeRestarts(cond)
[17:42:09.592]                           for (restart in restarts) {
[17:42:09.592]                             name <- restart$name
[17:42:09.592]                             if (is.null(name)) 
[17:42:09.592]                               next
[17:42:09.592]                             if (!grepl(pattern, name)) 
[17:42:09.592]                               next
[17:42:09.592]                             invokeRestart(restart)
[17:42:09.592]                             muffled <- TRUE
[17:42:09.592]                             break
[17:42:09.592]                           }
[17:42:09.592]                         }
[17:42:09.592]                       }
[17:42:09.592]                       invisible(muffled)
[17:42:09.592]                     }
[17:42:09.592]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.592]                   }
[17:42:09.592]                 }
[17:42:09.592]                 else {
[17:42:09.592]                   if (TRUE) {
[17:42:09.592]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.592]                     {
[17:42:09.592]                       inherits <- base::inherits
[17:42:09.592]                       invokeRestart <- base::invokeRestart
[17:42:09.592]                       is.null <- base::is.null
[17:42:09.592]                       muffled <- FALSE
[17:42:09.592]                       if (inherits(cond, "message")) {
[17:42:09.592]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.592]                         if (muffled) 
[17:42:09.592]                           invokeRestart("muffleMessage")
[17:42:09.592]                       }
[17:42:09.592]                       else if (inherits(cond, "warning")) {
[17:42:09.592]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.592]                         if (muffled) 
[17:42:09.592]                           invokeRestart("muffleWarning")
[17:42:09.592]                       }
[17:42:09.592]                       else if (inherits(cond, "condition")) {
[17:42:09.592]                         if (!is.null(pattern)) {
[17:42:09.592]                           computeRestarts <- base::computeRestarts
[17:42:09.592]                           grepl <- base::grepl
[17:42:09.592]                           restarts <- computeRestarts(cond)
[17:42:09.592]                           for (restart in restarts) {
[17:42:09.592]                             name <- restart$name
[17:42:09.592]                             if (is.null(name)) 
[17:42:09.592]                               next
[17:42:09.592]                             if (!grepl(pattern, name)) 
[17:42:09.592]                               next
[17:42:09.592]                             invokeRestart(restart)
[17:42:09.592]                             muffled <- TRUE
[17:42:09.592]                             break
[17:42:09.592]                           }
[17:42:09.592]                         }
[17:42:09.592]                       }
[17:42:09.592]                       invisible(muffled)
[17:42:09.592]                     }
[17:42:09.592]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.592]                   }
[17:42:09.592]                 }
[17:42:09.592]             }
[17:42:09.592]         }))
[17:42:09.592]     }, error = function(ex) {
[17:42:09.592]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:09.592]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.592]                 ...future.rng), started = ...future.startTime, 
[17:42:09.592]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:09.592]             version = "1.8"), class = "FutureResult")
[17:42:09.592]     }, finally = {
[17:42:09.592]         if (!identical(...future.workdir, getwd())) 
[17:42:09.592]             setwd(...future.workdir)
[17:42:09.592]         {
[17:42:09.592]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:09.592]                 ...future.oldOptions$nwarnings <- NULL
[17:42:09.592]             }
[17:42:09.592]             base::options(...future.oldOptions)
[17:42:09.592]             if (.Platform$OS.type == "windows") {
[17:42:09.592]                 old_names <- names(...future.oldEnvVars)
[17:42:09.592]                 envs <- base::Sys.getenv()
[17:42:09.592]                 names <- names(envs)
[17:42:09.592]                 common <- intersect(names, old_names)
[17:42:09.592]                 added <- setdiff(names, old_names)
[17:42:09.592]                 removed <- setdiff(old_names, names)
[17:42:09.592]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:09.592]                   envs[common]]
[17:42:09.592]                 NAMES <- toupper(changed)
[17:42:09.592]                 args <- list()
[17:42:09.592]                 for (kk in seq_along(NAMES)) {
[17:42:09.592]                   name <- changed[[kk]]
[17:42:09.592]                   NAME <- NAMES[[kk]]
[17:42:09.592]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.592]                     next
[17:42:09.592]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.592]                 }
[17:42:09.592]                 NAMES <- toupper(added)
[17:42:09.592]                 for (kk in seq_along(NAMES)) {
[17:42:09.592]                   name <- added[[kk]]
[17:42:09.592]                   NAME <- NAMES[[kk]]
[17:42:09.592]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.592]                     next
[17:42:09.592]                   args[[name]] <- ""
[17:42:09.592]                 }
[17:42:09.592]                 NAMES <- toupper(removed)
[17:42:09.592]                 for (kk in seq_along(NAMES)) {
[17:42:09.592]                   name <- removed[[kk]]
[17:42:09.592]                   NAME <- NAMES[[kk]]
[17:42:09.592]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.592]                     next
[17:42:09.592]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.592]                 }
[17:42:09.592]                 if (length(args) > 0) 
[17:42:09.592]                   base::do.call(base::Sys.setenv, args = args)
[17:42:09.592]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:09.592]             }
[17:42:09.592]             else {
[17:42:09.592]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:09.592]             }
[17:42:09.592]             {
[17:42:09.592]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:09.592]                   0L) {
[17:42:09.592]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:09.592]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:09.592]                   base::options(opts)
[17:42:09.592]                 }
[17:42:09.592]                 {
[17:42:09.592]                   {
[17:42:09.592]                     NULL
[17:42:09.592]                     RNGkind("Mersenne-Twister")
[17:42:09.592]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:09.592]                       inherits = FALSE)
[17:42:09.592]                   }
[17:42:09.592]                   options(future.plan = NULL)
[17:42:09.592]                   if (is.na(NA_character_)) 
[17:42:09.592]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.592]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:09.592]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:09.592]                   {
[17:42:09.592]                     future <- SequentialFuture(..., envir = envir)
[17:42:09.592]                     if (!future$lazy) 
[17:42:09.592]                       future <- run(future)
[17:42:09.592]                     invisible(future)
[17:42:09.592]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:09.592]                 }
[17:42:09.592]             }
[17:42:09.592]         }
[17:42:09.592]     })
[17:42:09.592]     if (TRUE) {
[17:42:09.592]         base::sink(type = "output", split = FALSE)
[17:42:09.592]         if (TRUE) {
[17:42:09.592]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:09.592]         }
[17:42:09.592]         else {
[17:42:09.592]             ...future.result["stdout"] <- base::list(NULL)
[17:42:09.592]         }
[17:42:09.592]         base::close(...future.stdout)
[17:42:09.592]         ...future.stdout <- NULL
[17:42:09.592]     }
[17:42:09.592]     ...future.result$conditions <- ...future.conditions
[17:42:09.592]     ...future.result$finished <- base::Sys.time()
[17:42:09.592]     ...future.result
[17:42:09.592] }
[17:42:09.593] assign_globals() ...
[17:42:09.593] List of 1
[17:42:09.593]  $ a: num 10
[17:42:09.593]  - attr(*, "where")=List of 1
[17:42:09.593]   ..$ a:<environment: R_EmptyEnv> 
[17:42:09.593]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:09.593]  - attr(*, "resolved")= logi FALSE
[17:42:09.593]  - attr(*, "total_size")= num 56
[17:42:09.593]  - attr(*, "already-done")= logi TRUE
[17:42:09.596] - copied ‘a’ to environment
[17:42:09.596] assign_globals() ... done
[17:42:09.596] plan(): Setting new future strategy stack:
[17:42:09.596] List of future strategies:
[17:42:09.596] 1. sequential:
[17:42:09.596]    - args: function (..., envir = parent.frame())
[17:42:09.596]    - tweaked: FALSE
[17:42:09.596]    - call: NULL
[17:42:09.597] plan(): nbrOfWorkers() = 1
[17:42:09.597] plan(): Setting new future strategy stack:
[17:42:09.598] List of future strategies:
[17:42:09.598] 1. sequential:
[17:42:09.598]    - args: function (..., envir = parent.frame())
[17:42:09.598]    - tweaked: FALSE
[17:42:09.598]    - call: plan(strategy)
[17:42:09.598] plan(): nbrOfWorkers() = 1
[17:42:09.598] SequentialFuture started (and completed)
[17:42:09.598] - Launch lazy future ... done
[17:42:09.598] run() for ‘SequentialFuture’ ... done
b = 11
*** %<-% with ‘sequential’ futures ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
*** %<-% with ‘multicore’ futures ...
[17:42:09.607] plan(): Setting new future strategy stack:
[17:42:09.607] List of future strategies:
[17:42:09.607] 1. multicore:
[17:42:09.607]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:09.607]    - tweaked: FALSE
[17:42:09.607]    - call: plan(strategy)
[17:42:09.611] plan(): nbrOfWorkers() = 2
** Future evaluation without globals
[17:42:09.611] getGlobalsAndPackages() ...
[17:42:09.612] Searching for globals...
[17:42:09.613] - globals found: [2] ‘{’, ‘<-’
[17:42:09.613] Searching for globals ... DONE
[17:42:09.613] Resolving globals: FALSE
[17:42:09.613] 
[17:42:09.613] 
[17:42:09.613] getGlobalsAndPackages() ... DONE
[17:42:09.614] run() for ‘Future’ ...
[17:42:09.614] - state: ‘created’
[17:42:09.614] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:09.617] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:09.618] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:09.618]   - Field: ‘label’
[17:42:09.618]   - Field: ‘local’
[17:42:09.618]   - Field: ‘owner’
[17:42:09.618]   - Field: ‘envir’
[17:42:09.618]   - Field: ‘workers’
[17:42:09.618]   - Field: ‘packages’
[17:42:09.618]   - Field: ‘gc’
[17:42:09.618]   - Field: ‘job’
[17:42:09.618]   - Field: ‘conditions’
[17:42:09.619]   - Field: ‘expr’
[17:42:09.619]   - Field: ‘uuid’
[17:42:09.619]   - Field: ‘seed’
[17:42:09.619]   - Field: ‘version’
[17:42:09.619]   - Field: ‘result’
[17:42:09.619]   - Field: ‘asynchronous’
[17:42:09.619]   - Field: ‘calls’
[17:42:09.619]   - Field: ‘globals’
[17:42:09.619]   - Field: ‘stdout’
[17:42:09.619]   - Field: ‘earlySignal’
[17:42:09.620]   - Field: ‘lazy’
[17:42:09.620]   - Field: ‘state’
[17:42:09.620] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:09.620] - Launch lazy future ...
[17:42:09.621] Packages needed by the future expression (n = 0): <none>
[17:42:09.621] Packages needed by future strategies (n = 0): <none>
[17:42:09.621] {
[17:42:09.621]     {
[17:42:09.621]         {
[17:42:09.621]             ...future.startTime <- base::Sys.time()
[17:42:09.621]             {
[17:42:09.621]                 {
[17:42:09.621]                   {
[17:42:09.621]                     {
[17:42:09.621]                       base::local({
[17:42:09.621]                         has_future <- base::requireNamespace("future", 
[17:42:09.621]                           quietly = TRUE)
[17:42:09.621]                         if (has_future) {
[17:42:09.621]                           ns <- base::getNamespace("future")
[17:42:09.621]                           version <- ns[[".package"]][["version"]]
[17:42:09.621]                           if (is.null(version)) 
[17:42:09.621]                             version <- utils::packageVersion("future")
[17:42:09.621]                         }
[17:42:09.621]                         else {
[17:42:09.621]                           version <- NULL
[17:42:09.621]                         }
[17:42:09.621]                         if (!has_future || version < "1.8.0") {
[17:42:09.621]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:09.621]                             "", base::R.version$version.string), 
[17:42:09.621]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:09.621]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:09.621]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:09.621]                               "release", "version")], collapse = " "), 
[17:42:09.621]                             hostname = base::Sys.info()[["nodename"]])
[17:42:09.621]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:09.621]                             info)
[17:42:09.621]                           info <- base::paste(info, collapse = "; ")
[17:42:09.621]                           if (!has_future) {
[17:42:09.621]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:09.621]                               info)
[17:42:09.621]                           }
[17:42:09.621]                           else {
[17:42:09.621]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:09.621]                               info, version)
[17:42:09.621]                           }
[17:42:09.621]                           base::stop(msg)
[17:42:09.621]                         }
[17:42:09.621]                       })
[17:42:09.621]                     }
[17:42:09.621]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:09.621]                     base::options(mc.cores = 1L)
[17:42:09.621]                   }
[17:42:09.621]                   options(future.plan = NULL)
[17:42:09.621]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.621]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:09.621]                 }
[17:42:09.621]                 ...future.workdir <- getwd()
[17:42:09.621]             }
[17:42:09.621]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:09.621]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:09.621]         }
[17:42:09.621]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:09.621]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:09.621]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:09.621]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:09.621]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:09.621]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:09.621]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:09.621]             base::names(...future.oldOptions))
[17:42:09.621]     }
[17:42:09.621]     if (FALSE) {
[17:42:09.621]     }
[17:42:09.621]     else {
[17:42:09.621]         if (TRUE) {
[17:42:09.621]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:09.621]                 open = "w")
[17:42:09.621]         }
[17:42:09.621]         else {
[17:42:09.621]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:09.621]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:09.621]         }
[17:42:09.621]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:09.621]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:09.621]             base::sink(type = "output", split = FALSE)
[17:42:09.621]             base::close(...future.stdout)
[17:42:09.621]         }, add = TRUE)
[17:42:09.621]     }
[17:42:09.621]     ...future.frame <- base::sys.nframe()
[17:42:09.621]     ...future.conditions <- base::list()
[17:42:09.621]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:09.621]     if (FALSE) {
[17:42:09.621]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:09.621]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:09.621]     }
[17:42:09.621]     ...future.result <- base::tryCatch({
[17:42:09.621]         base::withCallingHandlers({
[17:42:09.621]             ...future.value <- base::withVisible(base::local({
[17:42:09.621]                 withCallingHandlers({
[17:42:09.621]                   {
[17:42:09.621]                     x <- 1
[17:42:09.621]                   }
[17:42:09.621]                 }, immediateCondition = function(cond) {
[17:42:09.621]                   save_rds <- function (object, pathname, ...) 
[17:42:09.621]                   {
[17:42:09.621]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:09.621]                     if (file_test("-f", pathname_tmp)) {
[17:42:09.621]                       fi_tmp <- file.info(pathname_tmp)
[17:42:09.621]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:09.621]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:09.621]                         fi_tmp[["mtime"]])
[17:42:09.621]                     }
[17:42:09.621]                     tryCatch({
[17:42:09.621]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:09.621]                     }, error = function(ex) {
[17:42:09.621]                       msg <- conditionMessage(ex)
[17:42:09.621]                       fi_tmp <- file.info(pathname_tmp)
[17:42:09.621]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:09.621]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:09.621]                         fi_tmp[["mtime"]], msg)
[17:42:09.621]                       ex$message <- msg
[17:42:09.621]                       stop(ex)
[17:42:09.621]                     })
[17:42:09.621]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:09.621]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:09.621]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:09.621]                       fi_tmp <- file.info(pathname_tmp)
[17:42:09.621]                       fi <- file.info(pathname)
[17:42:09.621]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:09.621]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:09.621]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:09.621]                         fi[["size"]], fi[["mtime"]])
[17:42:09.621]                       stop(msg)
[17:42:09.621]                     }
[17:42:09.621]                     invisible(pathname)
[17:42:09.621]                   }
[17:42:09.621]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:09.621]                     rootPath = tempdir()) 
[17:42:09.621]                   {
[17:42:09.621]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:09.621]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:09.621]                       tmpdir = path, fileext = ".rds")
[17:42:09.621]                     save_rds(obj, file)
[17:42:09.621]                   }
[17:42:09.621]                   saveImmediateCondition(cond, path = "/tmp/RtmpZwB2Ue/.future/immediateConditions")
[17:42:09.621]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.621]                   {
[17:42:09.621]                     inherits <- base::inherits
[17:42:09.621]                     invokeRestart <- base::invokeRestart
[17:42:09.621]                     is.null <- base::is.null
[17:42:09.621]                     muffled <- FALSE
[17:42:09.621]                     if (inherits(cond, "message")) {
[17:42:09.621]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:09.621]                       if (muffled) 
[17:42:09.621]                         invokeRestart("muffleMessage")
[17:42:09.621]                     }
[17:42:09.621]                     else if (inherits(cond, "warning")) {
[17:42:09.621]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:09.621]                       if (muffled) 
[17:42:09.621]                         invokeRestart("muffleWarning")
[17:42:09.621]                     }
[17:42:09.621]                     else if (inherits(cond, "condition")) {
[17:42:09.621]                       if (!is.null(pattern)) {
[17:42:09.621]                         computeRestarts <- base::computeRestarts
[17:42:09.621]                         grepl <- base::grepl
[17:42:09.621]                         restarts <- computeRestarts(cond)
[17:42:09.621]                         for (restart in restarts) {
[17:42:09.621]                           name <- restart$name
[17:42:09.621]                           if (is.null(name)) 
[17:42:09.621]                             next
[17:42:09.621]                           if (!grepl(pattern, name)) 
[17:42:09.621]                             next
[17:42:09.621]                           invokeRestart(restart)
[17:42:09.621]                           muffled <- TRUE
[17:42:09.621]                           break
[17:42:09.621]                         }
[17:42:09.621]                       }
[17:42:09.621]                     }
[17:42:09.621]                     invisible(muffled)
[17:42:09.621]                   }
[17:42:09.621]                   muffleCondition(cond)
[17:42:09.621]                 })
[17:42:09.621]             }))
[17:42:09.621]             future::FutureResult(value = ...future.value$value, 
[17:42:09.621]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.621]                   ...future.rng), globalenv = if (FALSE) 
[17:42:09.621]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:09.621]                     ...future.globalenv.names))
[17:42:09.621]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:09.621]         }, condition = base::local({
[17:42:09.621]             c <- base::c
[17:42:09.621]             inherits <- base::inherits
[17:42:09.621]             invokeRestart <- base::invokeRestart
[17:42:09.621]             length <- base::length
[17:42:09.621]             list <- base::list
[17:42:09.621]             seq.int <- base::seq.int
[17:42:09.621]             signalCondition <- base::signalCondition
[17:42:09.621]             sys.calls <- base::sys.calls
[17:42:09.621]             `[[` <- base::`[[`
[17:42:09.621]             `+` <- base::`+`
[17:42:09.621]             `<<-` <- base::`<<-`
[17:42:09.621]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:09.621]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:09.621]                   3L)]
[17:42:09.621]             }
[17:42:09.621]             function(cond) {
[17:42:09.621]                 is_error <- inherits(cond, "error")
[17:42:09.621]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:09.621]                   NULL)
[17:42:09.621]                 if (is_error) {
[17:42:09.621]                   sessionInformation <- function() {
[17:42:09.621]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:09.621]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:09.621]                       search = base::search(), system = base::Sys.info())
[17:42:09.621]                   }
[17:42:09.621]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.621]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:09.621]                     cond$call), session = sessionInformation(), 
[17:42:09.621]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:09.621]                   signalCondition(cond)
[17:42:09.621]                 }
[17:42:09.621]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:09.621]                 "immediateCondition"))) {
[17:42:09.621]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:09.621]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.621]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:09.621]                   if (TRUE && !signal) {
[17:42:09.621]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.621]                     {
[17:42:09.621]                       inherits <- base::inherits
[17:42:09.621]                       invokeRestart <- base::invokeRestart
[17:42:09.621]                       is.null <- base::is.null
[17:42:09.621]                       muffled <- FALSE
[17:42:09.621]                       if (inherits(cond, "message")) {
[17:42:09.621]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.621]                         if (muffled) 
[17:42:09.621]                           invokeRestart("muffleMessage")
[17:42:09.621]                       }
[17:42:09.621]                       else if (inherits(cond, "warning")) {
[17:42:09.621]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.621]                         if (muffled) 
[17:42:09.621]                           invokeRestart("muffleWarning")
[17:42:09.621]                       }
[17:42:09.621]                       else if (inherits(cond, "condition")) {
[17:42:09.621]                         if (!is.null(pattern)) {
[17:42:09.621]                           computeRestarts <- base::computeRestarts
[17:42:09.621]                           grepl <- base::grepl
[17:42:09.621]                           restarts <- computeRestarts(cond)
[17:42:09.621]                           for (restart in restarts) {
[17:42:09.621]                             name <- restart$name
[17:42:09.621]                             if (is.null(name)) 
[17:42:09.621]                               next
[17:42:09.621]                             if (!grepl(pattern, name)) 
[17:42:09.621]                               next
[17:42:09.621]                             invokeRestart(restart)
[17:42:09.621]                             muffled <- TRUE
[17:42:09.621]                             break
[17:42:09.621]                           }
[17:42:09.621]                         }
[17:42:09.621]                       }
[17:42:09.621]                       invisible(muffled)
[17:42:09.621]                     }
[17:42:09.621]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.621]                   }
[17:42:09.621]                 }
[17:42:09.621]                 else {
[17:42:09.621]                   if (TRUE) {
[17:42:09.621]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.621]                     {
[17:42:09.621]                       inherits <- base::inherits
[17:42:09.621]                       invokeRestart <- base::invokeRestart
[17:42:09.621]                       is.null <- base::is.null
[17:42:09.621]                       muffled <- FALSE
[17:42:09.621]                       if (inherits(cond, "message")) {
[17:42:09.621]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.621]                         if (muffled) 
[17:42:09.621]                           invokeRestart("muffleMessage")
[17:42:09.621]                       }
[17:42:09.621]                       else if (inherits(cond, "warning")) {
[17:42:09.621]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.621]                         if (muffled) 
[17:42:09.621]                           invokeRestart("muffleWarning")
[17:42:09.621]                       }
[17:42:09.621]                       else if (inherits(cond, "condition")) {
[17:42:09.621]                         if (!is.null(pattern)) {
[17:42:09.621]                           computeRestarts <- base::computeRestarts
[17:42:09.621]                           grepl <- base::grepl
[17:42:09.621]                           restarts <- computeRestarts(cond)
[17:42:09.621]                           for (restart in restarts) {
[17:42:09.621]                             name <- restart$name
[17:42:09.621]                             if (is.null(name)) 
[17:42:09.621]                               next
[17:42:09.621]                             if (!grepl(pattern, name)) 
[17:42:09.621]                               next
[17:42:09.621]                             invokeRestart(restart)
[17:42:09.621]                             muffled <- TRUE
[17:42:09.621]                             break
[17:42:09.621]                           }
[17:42:09.621]                         }
[17:42:09.621]                       }
[17:42:09.621]                       invisible(muffled)
[17:42:09.621]                     }
[17:42:09.621]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.621]                   }
[17:42:09.621]                 }
[17:42:09.621]             }
[17:42:09.621]         }))
[17:42:09.621]     }, error = function(ex) {
[17:42:09.621]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:09.621]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.621]                 ...future.rng), started = ...future.startTime, 
[17:42:09.621]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:09.621]             version = "1.8"), class = "FutureResult")
[17:42:09.621]     }, finally = {
[17:42:09.621]         if (!identical(...future.workdir, getwd())) 
[17:42:09.621]             setwd(...future.workdir)
[17:42:09.621]         {
[17:42:09.621]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:09.621]                 ...future.oldOptions$nwarnings <- NULL
[17:42:09.621]             }
[17:42:09.621]             base::options(...future.oldOptions)
[17:42:09.621]             if (.Platform$OS.type == "windows") {
[17:42:09.621]                 old_names <- names(...future.oldEnvVars)
[17:42:09.621]                 envs <- base::Sys.getenv()
[17:42:09.621]                 names <- names(envs)
[17:42:09.621]                 common <- intersect(names, old_names)
[17:42:09.621]                 added <- setdiff(names, old_names)
[17:42:09.621]                 removed <- setdiff(old_names, names)
[17:42:09.621]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:09.621]                   envs[common]]
[17:42:09.621]                 NAMES <- toupper(changed)
[17:42:09.621]                 args <- list()
[17:42:09.621]                 for (kk in seq_along(NAMES)) {
[17:42:09.621]                   name <- changed[[kk]]
[17:42:09.621]                   NAME <- NAMES[[kk]]
[17:42:09.621]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.621]                     next
[17:42:09.621]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.621]                 }
[17:42:09.621]                 NAMES <- toupper(added)
[17:42:09.621]                 for (kk in seq_along(NAMES)) {
[17:42:09.621]                   name <- added[[kk]]
[17:42:09.621]                   NAME <- NAMES[[kk]]
[17:42:09.621]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.621]                     next
[17:42:09.621]                   args[[name]] <- ""
[17:42:09.621]                 }
[17:42:09.621]                 NAMES <- toupper(removed)
[17:42:09.621]                 for (kk in seq_along(NAMES)) {
[17:42:09.621]                   name <- removed[[kk]]
[17:42:09.621]                   NAME <- NAMES[[kk]]
[17:42:09.621]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.621]                     next
[17:42:09.621]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.621]                 }
[17:42:09.621]                 if (length(args) > 0) 
[17:42:09.621]                   base::do.call(base::Sys.setenv, args = args)
[17:42:09.621]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:09.621]             }
[17:42:09.621]             else {
[17:42:09.621]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:09.621]             }
[17:42:09.621]             {
[17:42:09.621]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:09.621]                   0L) {
[17:42:09.621]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:09.621]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:09.621]                   base::options(opts)
[17:42:09.621]                 }
[17:42:09.621]                 {
[17:42:09.621]                   {
[17:42:09.621]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:09.621]                     NULL
[17:42:09.621]                   }
[17:42:09.621]                   options(future.plan = NULL)
[17:42:09.621]                   if (is.na(NA_character_)) 
[17:42:09.621]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.621]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:09.621]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:09.621]                     envir = parent.frame()) 
[17:42:09.621]                   {
[17:42:09.621]                     default_workers <- missing(workers)
[17:42:09.621]                     if (is.function(workers)) 
[17:42:09.621]                       workers <- workers()
[17:42:09.621]                     workers <- structure(as.integer(workers), 
[17:42:09.621]                       class = class(workers))
[17:42:09.621]                     stop_if_not(is.finite(workers), workers >= 
[17:42:09.621]                       1L)
[17:42:09.621]                     if ((workers == 1L && !inherits(workers, 
[17:42:09.621]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:09.621]                       if (default_workers) 
[17:42:09.621]                         supportsMulticore(warn = TRUE)
[17:42:09.621]                       return(sequential(..., envir = envir))
[17:42:09.621]                     }
[17:42:09.621]                     oopts <- options(mc.cores = workers)
[17:42:09.621]                     on.exit(options(oopts))
[17:42:09.621]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:09.621]                       envir = envir)
[17:42:09.621]                     if (!future$lazy) 
[17:42:09.621]                       future <- run(future)
[17:42:09.621]                     invisible(future)
[17:42:09.621]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:09.621]                 }
[17:42:09.621]             }
[17:42:09.621]         }
[17:42:09.621]     })
[17:42:09.621]     if (TRUE) {
[17:42:09.621]         base::sink(type = "output", split = FALSE)
[17:42:09.621]         if (TRUE) {
[17:42:09.621]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:09.621]         }
[17:42:09.621]         else {
[17:42:09.621]             ...future.result["stdout"] <- base::list(NULL)
[17:42:09.621]         }
[17:42:09.621]         base::close(...future.stdout)
[17:42:09.621]         ...future.stdout <- NULL
[17:42:09.621]     }
[17:42:09.621]     ...future.result$conditions <- ...future.conditions
[17:42:09.621]     ...future.result$finished <- base::Sys.time()
[17:42:09.621]     ...future.result
[17:42:09.621] }
[17:42:09.624] requestCore(): workers = 2
[17:42:09.627] MulticoreFuture started
[17:42:09.627] - Launch lazy future ... done
[17:42:09.627] run() for ‘MulticoreFuture’ ... done
[17:42:09.627] plan(): Setting new future strategy stack:
[17:42:09.628] List of future strategies:
[17:42:09.628] 1. sequential:
[17:42:09.628]    - args: function (..., envir = parent.frame())
[17:42:09.628]    - tweaked: FALSE
[17:42:09.628]    - call: NULL
[17:42:09.629] plan(): nbrOfWorkers() = 1
[17:42:09.631] plan(): Setting new future strategy stack:
[17:42:09.631] List of future strategies:
[17:42:09.631] 1. multicore:
[17:42:09.631]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:09.631]    - tweaked: FALSE
[17:42:09.631]    - call: plan(strategy)
[17:42:09.636] plan(): nbrOfWorkers() = 2
** Future evaluation with globals
[17:42:09.641] getGlobalsAndPackages() ...
[17:42:09.641] Searching for globals...
[17:42:09.642] - globals found: [3] ‘{’, ‘<-’, ‘a’
[17:42:09.642] Searching for globals ... DONE
[17:42:09.642] Resolving globals: FALSE
[17:42:09.643] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:09.643] The total size of the 1 globals exported for future expression (‘{; x <- a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[17:42:09.644] - globals: [1] ‘a’
[17:42:09.644] 
[17:42:09.644] getGlobalsAndPackages() ... DONE
[17:42:09.644] run() for ‘Future’ ...
[17:42:09.644] - state: ‘created’
[17:42:09.644] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:09.649] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:09.649] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:09.649]   - Field: ‘label’
[17:42:09.649]   - Field: ‘local’
[17:42:09.649]   - Field: ‘owner’
[17:42:09.649]   - Field: ‘envir’
[17:42:09.649]   - Field: ‘workers’
[17:42:09.650]   - Field: ‘packages’
[17:42:09.650]   - Field: ‘gc’
[17:42:09.650]   - Field: ‘job’
[17:42:09.650]   - Field: ‘conditions’
[17:42:09.650]   - Field: ‘expr’
[17:42:09.650]   - Field: ‘uuid’
[17:42:09.650]   - Field: ‘seed’
[17:42:09.650]   - Field: ‘version’
[17:42:09.650]   - Field: ‘result’
[17:42:09.651]   - Field: ‘asynchronous’
[17:42:09.651]   - Field: ‘calls’
[17:42:09.651]   - Field: ‘globals’
[17:42:09.651]   - Field: ‘stdout’
[17:42:09.651]   - Field: ‘earlySignal’
[17:42:09.651]   - Field: ‘lazy’
[17:42:09.651]   - Field: ‘state’
[17:42:09.651] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:09.652] - Launch lazy future ...
[17:42:09.654] Packages needed by the future expression (n = 0): <none>
[17:42:09.654] Packages needed by future strategies (n = 0): <none>
[17:42:09.655] {
[17:42:09.655]     {
[17:42:09.655]         {
[17:42:09.655]             ...future.startTime <- base::Sys.time()
[17:42:09.655]             {
[17:42:09.655]                 {
[17:42:09.655]                   {
[17:42:09.655]                     {
[17:42:09.655]                       base::local({
[17:42:09.655]                         has_future <- base::requireNamespace("future", 
[17:42:09.655]                           quietly = TRUE)
[17:42:09.655]                         if (has_future) {
[17:42:09.655]                           ns <- base::getNamespace("future")
[17:42:09.655]                           version <- ns[[".package"]][["version"]]
[17:42:09.655]                           if (is.null(version)) 
[17:42:09.655]                             version <- utils::packageVersion("future")
[17:42:09.655]                         }
[17:42:09.655]                         else {
[17:42:09.655]                           version <- NULL
[17:42:09.655]                         }
[17:42:09.655]                         if (!has_future || version < "1.8.0") {
[17:42:09.655]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:09.655]                             "", base::R.version$version.string), 
[17:42:09.655]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:09.655]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:09.655]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:09.655]                               "release", "version")], collapse = " "), 
[17:42:09.655]                             hostname = base::Sys.info()[["nodename"]])
[17:42:09.655]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:09.655]                             info)
[17:42:09.655]                           info <- base::paste(info, collapse = "; ")
[17:42:09.655]                           if (!has_future) {
[17:42:09.655]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:09.655]                               info)
[17:42:09.655]                           }
[17:42:09.655]                           else {
[17:42:09.655]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:09.655]                               info, version)
[17:42:09.655]                           }
[17:42:09.655]                           base::stop(msg)
[17:42:09.655]                         }
[17:42:09.655]                       })
[17:42:09.655]                     }
[17:42:09.655]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:09.655]                     base::options(mc.cores = 1L)
[17:42:09.655]                   }
[17:42:09.655]                   options(future.plan = NULL)
[17:42:09.655]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.655]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:09.655]                 }
[17:42:09.655]                 ...future.workdir <- getwd()
[17:42:09.655]             }
[17:42:09.655]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:09.655]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:09.655]         }
[17:42:09.655]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:09.655]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:09.655]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:09.655]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:09.655]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:09.655]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:09.655]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:09.655]             base::names(...future.oldOptions))
[17:42:09.655]     }
[17:42:09.655]     if (FALSE) {
[17:42:09.655]     }
[17:42:09.655]     else {
[17:42:09.655]         if (TRUE) {
[17:42:09.655]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:09.655]                 open = "w")
[17:42:09.655]         }
[17:42:09.655]         else {
[17:42:09.655]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:09.655]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:09.655]         }
[17:42:09.655]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:09.655]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:09.655]             base::sink(type = "output", split = FALSE)
[17:42:09.655]             base::close(...future.stdout)
[17:42:09.655]         }, add = TRUE)
[17:42:09.655]     }
[17:42:09.655]     ...future.frame <- base::sys.nframe()
[17:42:09.655]     ...future.conditions <- base::list()
[17:42:09.655]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:09.655]     if (FALSE) {
[17:42:09.655]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:09.655]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:09.655]     }
[17:42:09.655]     ...future.result <- base::tryCatch({
[17:42:09.655]         base::withCallingHandlers({
[17:42:09.655]             ...future.value <- base::withVisible(base::local({
[17:42:09.655]                 withCallingHandlers({
[17:42:09.655]                   {
[17:42:09.655]                     x <- a
[17:42:09.655]                   }
[17:42:09.655]                 }, immediateCondition = function(cond) {
[17:42:09.655]                   save_rds <- function (object, pathname, ...) 
[17:42:09.655]                   {
[17:42:09.655]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:09.655]                     if (file_test("-f", pathname_tmp)) {
[17:42:09.655]                       fi_tmp <- file.info(pathname_tmp)
[17:42:09.655]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:09.655]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:09.655]                         fi_tmp[["mtime"]])
[17:42:09.655]                     }
[17:42:09.655]                     tryCatch({
[17:42:09.655]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:09.655]                     }, error = function(ex) {
[17:42:09.655]                       msg <- conditionMessage(ex)
[17:42:09.655]                       fi_tmp <- file.info(pathname_tmp)
[17:42:09.655]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:09.655]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:09.655]                         fi_tmp[["mtime"]], msg)
[17:42:09.655]                       ex$message <- msg
[17:42:09.655]                       stop(ex)
[17:42:09.655]                     })
[17:42:09.655]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:09.655]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:09.655]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:09.655]                       fi_tmp <- file.info(pathname_tmp)
[17:42:09.655]                       fi <- file.info(pathname)
[17:42:09.655]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:09.655]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:09.655]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:09.655]                         fi[["size"]], fi[["mtime"]])
[17:42:09.655]                       stop(msg)
[17:42:09.655]                     }
[17:42:09.655]                     invisible(pathname)
[17:42:09.655]                   }
[17:42:09.655]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:09.655]                     rootPath = tempdir()) 
[17:42:09.655]                   {
[17:42:09.655]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:09.655]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:09.655]                       tmpdir = path, fileext = ".rds")
[17:42:09.655]                     save_rds(obj, file)
[17:42:09.655]                   }
[17:42:09.655]                   saveImmediateCondition(cond, path = "/tmp/RtmpZwB2Ue/.future/immediateConditions")
[17:42:09.655]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.655]                   {
[17:42:09.655]                     inherits <- base::inherits
[17:42:09.655]                     invokeRestart <- base::invokeRestart
[17:42:09.655]                     is.null <- base::is.null
[17:42:09.655]                     muffled <- FALSE
[17:42:09.655]                     if (inherits(cond, "message")) {
[17:42:09.655]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:09.655]                       if (muffled) 
[17:42:09.655]                         invokeRestart("muffleMessage")
[17:42:09.655]                     }
[17:42:09.655]                     else if (inherits(cond, "warning")) {
[17:42:09.655]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:09.655]                       if (muffled) 
[17:42:09.655]                         invokeRestart("muffleWarning")
[17:42:09.655]                     }
[17:42:09.655]                     else if (inherits(cond, "condition")) {
[17:42:09.655]                       if (!is.null(pattern)) {
[17:42:09.655]                         computeRestarts <- base::computeRestarts
[17:42:09.655]                         grepl <- base::grepl
[17:42:09.655]                         restarts <- computeRestarts(cond)
[17:42:09.655]                         for (restart in restarts) {
[17:42:09.655]                           name <- restart$name
[17:42:09.655]                           if (is.null(name)) 
[17:42:09.655]                             next
[17:42:09.655]                           if (!grepl(pattern, name)) 
[17:42:09.655]                             next
[17:42:09.655]                           invokeRestart(restart)
[17:42:09.655]                           muffled <- TRUE
[17:42:09.655]                           break
[17:42:09.655]                         }
[17:42:09.655]                       }
[17:42:09.655]                     }
[17:42:09.655]                     invisible(muffled)
[17:42:09.655]                   }
[17:42:09.655]                   muffleCondition(cond)
[17:42:09.655]                 })
[17:42:09.655]             }))
[17:42:09.655]             future::FutureResult(value = ...future.value$value, 
[17:42:09.655]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.655]                   ...future.rng), globalenv = if (FALSE) 
[17:42:09.655]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:09.655]                     ...future.globalenv.names))
[17:42:09.655]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:09.655]         }, condition = base::local({
[17:42:09.655]             c <- base::c
[17:42:09.655]             inherits <- base::inherits
[17:42:09.655]             invokeRestart <- base::invokeRestart
[17:42:09.655]             length <- base::length
[17:42:09.655]             list <- base::list
[17:42:09.655]             seq.int <- base::seq.int
[17:42:09.655]             signalCondition <- base::signalCondition
[17:42:09.655]             sys.calls <- base::sys.calls
[17:42:09.655]             `[[` <- base::`[[`
[17:42:09.655]             `+` <- base::`+`
[17:42:09.655]             `<<-` <- base::`<<-`
[17:42:09.655]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:09.655]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:09.655]                   3L)]
[17:42:09.655]             }
[17:42:09.655]             function(cond) {
[17:42:09.655]                 is_error <- inherits(cond, "error")
[17:42:09.655]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:09.655]                   NULL)
[17:42:09.655]                 if (is_error) {
[17:42:09.655]                   sessionInformation <- function() {
[17:42:09.655]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:09.655]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:09.655]                       search = base::search(), system = base::Sys.info())
[17:42:09.655]                   }
[17:42:09.655]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.655]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:09.655]                     cond$call), session = sessionInformation(), 
[17:42:09.655]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:09.655]                   signalCondition(cond)
[17:42:09.655]                 }
[17:42:09.655]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:09.655]                 "immediateCondition"))) {
[17:42:09.655]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:09.655]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.655]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:09.655]                   if (TRUE && !signal) {
[17:42:09.655]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.655]                     {
[17:42:09.655]                       inherits <- base::inherits
[17:42:09.655]                       invokeRestart <- base::invokeRestart
[17:42:09.655]                       is.null <- base::is.null
[17:42:09.655]                       muffled <- FALSE
[17:42:09.655]                       if (inherits(cond, "message")) {
[17:42:09.655]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.655]                         if (muffled) 
[17:42:09.655]                           invokeRestart("muffleMessage")
[17:42:09.655]                       }
[17:42:09.655]                       else if (inherits(cond, "warning")) {
[17:42:09.655]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.655]                         if (muffled) 
[17:42:09.655]                           invokeRestart("muffleWarning")
[17:42:09.655]                       }
[17:42:09.655]                       else if (inherits(cond, "condition")) {
[17:42:09.655]                         if (!is.null(pattern)) {
[17:42:09.655]                           computeRestarts <- base::computeRestarts
[17:42:09.655]                           grepl <- base::grepl
[17:42:09.655]                           restarts <- computeRestarts(cond)
[17:42:09.655]                           for (restart in restarts) {
[17:42:09.655]                             name <- restart$name
[17:42:09.655]                             if (is.null(name)) 
[17:42:09.655]                               next
[17:42:09.655]                             if (!grepl(pattern, name)) 
[17:42:09.655]                               next
[17:42:09.655]                             invokeRestart(restart)
[17:42:09.655]                             muffled <- TRUE
[17:42:09.655]                             break
[17:42:09.655]                           }
[17:42:09.655]                         }
[17:42:09.655]                       }
[17:42:09.655]                       invisible(muffled)
[17:42:09.655]                     }
[17:42:09.655]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.655]                   }
[17:42:09.655]                 }
[17:42:09.655]                 else {
[17:42:09.655]                   if (TRUE) {
[17:42:09.655]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.655]                     {
[17:42:09.655]                       inherits <- base::inherits
[17:42:09.655]                       invokeRestart <- base::invokeRestart
[17:42:09.655]                       is.null <- base::is.null
[17:42:09.655]                       muffled <- FALSE
[17:42:09.655]                       if (inherits(cond, "message")) {
[17:42:09.655]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.655]                         if (muffled) 
[17:42:09.655]                           invokeRestart("muffleMessage")
[17:42:09.655]                       }
[17:42:09.655]                       else if (inherits(cond, "warning")) {
[17:42:09.655]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.655]                         if (muffled) 
[17:42:09.655]                           invokeRestart("muffleWarning")
[17:42:09.655]                       }
[17:42:09.655]                       else if (inherits(cond, "condition")) {
[17:42:09.655]                         if (!is.null(pattern)) {
[17:42:09.655]                           computeRestarts <- base::computeRestarts
[17:42:09.655]                           grepl <- base::grepl
[17:42:09.655]                           restarts <- computeRestarts(cond)
[17:42:09.655]                           for (restart in restarts) {
[17:42:09.655]                             name <- restart$name
[17:42:09.655]                             if (is.null(name)) 
[17:42:09.655]                               next
[17:42:09.655]                             if (!grepl(pattern, name)) 
[17:42:09.655]                               next
[17:42:09.655]                             invokeRestart(restart)
[17:42:09.655]                             muffled <- TRUE
[17:42:09.655]                             break
[17:42:09.655]                           }
[17:42:09.655]                         }
[17:42:09.655]                       }
[17:42:09.655]                       invisible(muffled)
[17:42:09.655]                     }
[17:42:09.655]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.655]                   }
[17:42:09.655]                 }
[17:42:09.655]             }
[17:42:09.655]         }))
[17:42:09.655]     }, error = function(ex) {
[17:42:09.655]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:09.655]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.655]                 ...future.rng), started = ...future.startTime, 
[17:42:09.655]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:09.655]             version = "1.8"), class = "FutureResult")
[17:42:09.655]     }, finally = {
[17:42:09.655]         if (!identical(...future.workdir, getwd())) 
[17:42:09.655]             setwd(...future.workdir)
[17:42:09.655]         {
[17:42:09.655]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:09.655]                 ...future.oldOptions$nwarnings <- NULL
[17:42:09.655]             }
[17:42:09.655]             base::options(...future.oldOptions)
[17:42:09.655]             if (.Platform$OS.type == "windows") {
[17:42:09.655]                 old_names <- names(...future.oldEnvVars)
[17:42:09.655]                 envs <- base::Sys.getenv()
[17:42:09.655]                 names <- names(envs)
[17:42:09.655]                 common <- intersect(names, old_names)
[17:42:09.655]                 added <- setdiff(names, old_names)
[17:42:09.655]                 removed <- setdiff(old_names, names)
[17:42:09.655]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:09.655]                   envs[common]]
[17:42:09.655]                 NAMES <- toupper(changed)
[17:42:09.655]                 args <- list()
[17:42:09.655]                 for (kk in seq_along(NAMES)) {
[17:42:09.655]                   name <- changed[[kk]]
[17:42:09.655]                   NAME <- NAMES[[kk]]
[17:42:09.655]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.655]                     next
[17:42:09.655]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.655]                 }
[17:42:09.655]                 NAMES <- toupper(added)
[17:42:09.655]                 for (kk in seq_along(NAMES)) {
[17:42:09.655]                   name <- added[[kk]]
[17:42:09.655]                   NAME <- NAMES[[kk]]
[17:42:09.655]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.655]                     next
[17:42:09.655]                   args[[name]] <- ""
[17:42:09.655]                 }
[17:42:09.655]                 NAMES <- toupper(removed)
[17:42:09.655]                 for (kk in seq_along(NAMES)) {
[17:42:09.655]                   name <- removed[[kk]]
[17:42:09.655]                   NAME <- NAMES[[kk]]
[17:42:09.655]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.655]                     next
[17:42:09.655]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.655]                 }
[17:42:09.655]                 if (length(args) > 0) 
[17:42:09.655]                   base::do.call(base::Sys.setenv, args = args)
[17:42:09.655]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:09.655]             }
[17:42:09.655]             else {
[17:42:09.655]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:09.655]             }
[17:42:09.655]             {
[17:42:09.655]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:09.655]                   0L) {
[17:42:09.655]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:09.655]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:09.655]                   base::options(opts)
[17:42:09.655]                 }
[17:42:09.655]                 {
[17:42:09.655]                   {
[17:42:09.655]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:09.655]                     NULL
[17:42:09.655]                   }
[17:42:09.655]                   options(future.plan = NULL)
[17:42:09.655]                   if (is.na(NA_character_)) 
[17:42:09.655]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.655]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:09.655]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:09.655]                     envir = parent.frame()) 
[17:42:09.655]                   {
[17:42:09.655]                     default_workers <- missing(workers)
[17:42:09.655]                     if (is.function(workers)) 
[17:42:09.655]                       workers <- workers()
[17:42:09.655]                     workers <- structure(as.integer(workers), 
[17:42:09.655]                       class = class(workers))
[17:42:09.655]                     stop_if_not(is.finite(workers), workers >= 
[17:42:09.655]                       1L)
[17:42:09.655]                     if ((workers == 1L && !inherits(workers, 
[17:42:09.655]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:09.655]                       if (default_workers) 
[17:42:09.655]                         supportsMulticore(warn = TRUE)
[17:42:09.655]                       return(sequential(..., envir = envir))
[17:42:09.655]                     }
[17:42:09.655]                     oopts <- options(mc.cores = workers)
[17:42:09.655]                     on.exit(options(oopts))
[17:42:09.655]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:09.655]                       envir = envir)
[17:42:09.655]                     if (!future$lazy) 
[17:42:09.655]                       future <- run(future)
[17:42:09.655]                     invisible(future)
[17:42:09.655]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:09.655]                 }
[17:42:09.655]             }
[17:42:09.655]         }
[17:42:09.655]     })
[17:42:09.655]     if (TRUE) {
[17:42:09.655]         base::sink(type = "output", split = FALSE)
[17:42:09.655]         if (TRUE) {
[17:42:09.655]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:09.655]         }
[17:42:09.655]         else {
[17:42:09.655]             ...future.result["stdout"] <- base::list(NULL)
[17:42:09.655]         }
[17:42:09.655]         base::close(...future.stdout)
[17:42:09.655]         ...future.stdout <- NULL
[17:42:09.655]     }
[17:42:09.655]     ...future.result$conditions <- ...future.conditions
[17:42:09.655]     ...future.result$finished <- base::Sys.time()
[17:42:09.655]     ...future.result
[17:42:09.655] }
[17:42:09.658] assign_globals() ...
[17:42:09.658] List of 1
[17:42:09.658]  $ a: num 2
[17:42:09.658]  - attr(*, "where")=List of 1
[17:42:09.658]   ..$ a:<environment: R_EmptyEnv> 
[17:42:09.658]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:09.658]  - attr(*, "resolved")= logi FALSE
[17:42:09.658]  - attr(*, "total_size")= num 56
[17:42:09.658]  - attr(*, "already-done")= logi TRUE
[17:42:09.661] - copied ‘a’ to environment
[17:42:09.661] assign_globals() ... done
[17:42:09.661] requestCore(): workers = 2
[17:42:09.664] MulticoreFuture started
[17:42:09.664] - Launch lazy future ... done
[17:42:09.664] run() for ‘MulticoreFuture’ ... done
[17:42:09.665] plan(): Setting new future strategy stack:
[17:42:09.665] List of future strategies:
[17:42:09.665] 1. sequential:
[17:42:09.665]    - args: function (..., envir = parent.frame())
[17:42:09.665]    - tweaked: FALSE
[17:42:09.665]    - call: NULL
[17:42:09.666] plan(): nbrOfWorkers() = 1
[17:42:09.668] plan(): Setting new future strategy stack:
[17:42:09.669] List of future strategies:
[17:42:09.669] 1. multicore:
[17:42:09.669]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:09.669]    - tweaked: FALSE
[17:42:09.669]    - call: plan(strategy)
[17:42:09.674] plan(): nbrOfWorkers() = 2
** Future evaluation with errors
[17:42:09.675] getGlobalsAndPackages() ...
[17:42:09.676] Searching for globals...
[17:42:09.678] - globals found: [3] ‘{’, ‘<-’, ‘stop’
[17:42:09.678] Searching for globals ... DONE
[17:42:09.678] Resolving globals: FALSE
[17:42:09.678] 
[17:42:09.678] 
[17:42:09.679] getGlobalsAndPackages() ... DONE
[17:42:09.679] run() for ‘Future’ ...
[17:42:09.679] - state: ‘created’
[17:42:09.679] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:09.683] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:09.683] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:09.684]   - Field: ‘label’
[17:42:09.684]   - Field: ‘local’
[17:42:09.684]   - Field: ‘owner’
[17:42:09.684]   - Field: ‘envir’
[17:42:09.684]   - Field: ‘workers’
[17:42:09.684]   - Field: ‘packages’
[17:42:09.684]   - Field: ‘gc’
[17:42:09.684]   - Field: ‘job’
[17:42:09.685]   - Field: ‘conditions’
[17:42:09.685]   - Field: ‘expr’
[17:42:09.685]   - Field: ‘uuid’
[17:42:09.685]   - Field: ‘seed’
[17:42:09.685]   - Field: ‘version’
[17:42:09.685]   - Field: ‘result’
[17:42:09.685]   - Field: ‘asynchronous’
[17:42:09.685]   - Field: ‘calls’
[17:42:09.685]   - Field: ‘globals’
[17:42:09.686]   - Field: ‘stdout’
[17:42:09.686]   - Field: ‘earlySignal’
[17:42:09.686]   - Field: ‘lazy’
[17:42:09.686]   - Field: ‘state’
[17:42:09.686] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:09.686] - Launch lazy future ...
[17:42:09.687] Packages needed by the future expression (n = 0): <none>
[17:42:09.687] Packages needed by future strategies (n = 0): <none>
[17:42:09.687] {
[17:42:09.687]     {
[17:42:09.687]         {
[17:42:09.687]             ...future.startTime <- base::Sys.time()
[17:42:09.687]             {
[17:42:09.687]                 {
[17:42:09.687]                   {
[17:42:09.687]                     {
[17:42:09.687]                       base::local({
[17:42:09.687]                         has_future <- base::requireNamespace("future", 
[17:42:09.687]                           quietly = TRUE)
[17:42:09.687]                         if (has_future) {
[17:42:09.687]                           ns <- base::getNamespace("future")
[17:42:09.687]                           version <- ns[[".package"]][["version"]]
[17:42:09.687]                           if (is.null(version)) 
[17:42:09.687]                             version <- utils::packageVersion("future")
[17:42:09.687]                         }
[17:42:09.687]                         else {
[17:42:09.687]                           version <- NULL
[17:42:09.687]                         }
[17:42:09.687]                         if (!has_future || version < "1.8.0") {
[17:42:09.687]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:09.687]                             "", base::R.version$version.string), 
[17:42:09.687]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:09.687]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:09.687]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:09.687]                               "release", "version")], collapse = " "), 
[17:42:09.687]                             hostname = base::Sys.info()[["nodename"]])
[17:42:09.687]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:09.687]                             info)
[17:42:09.687]                           info <- base::paste(info, collapse = "; ")
[17:42:09.687]                           if (!has_future) {
[17:42:09.687]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:09.687]                               info)
[17:42:09.687]                           }
[17:42:09.687]                           else {
[17:42:09.687]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:09.687]                               info, version)
[17:42:09.687]                           }
[17:42:09.687]                           base::stop(msg)
[17:42:09.687]                         }
[17:42:09.687]                       })
[17:42:09.687]                     }
[17:42:09.687]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:09.687]                     base::options(mc.cores = 1L)
[17:42:09.687]                   }
[17:42:09.687]                   options(future.plan = NULL)
[17:42:09.687]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.687]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:09.687]                 }
[17:42:09.687]                 ...future.workdir <- getwd()
[17:42:09.687]             }
[17:42:09.687]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:09.687]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:09.687]         }
[17:42:09.687]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:09.687]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:09.687]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:09.687]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:09.687]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:09.687]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:09.687]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:09.687]             base::names(...future.oldOptions))
[17:42:09.687]     }
[17:42:09.687]     if (FALSE) {
[17:42:09.687]     }
[17:42:09.687]     else {
[17:42:09.687]         if (TRUE) {
[17:42:09.687]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:09.687]                 open = "w")
[17:42:09.687]         }
[17:42:09.687]         else {
[17:42:09.687]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:09.687]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:09.687]         }
[17:42:09.687]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:09.687]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:09.687]             base::sink(type = "output", split = FALSE)
[17:42:09.687]             base::close(...future.stdout)
[17:42:09.687]         }, add = TRUE)
[17:42:09.687]     }
[17:42:09.687]     ...future.frame <- base::sys.nframe()
[17:42:09.687]     ...future.conditions <- base::list()
[17:42:09.687]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:09.687]     if (FALSE) {
[17:42:09.687]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:09.687]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:09.687]     }
[17:42:09.687]     ...future.result <- base::tryCatch({
[17:42:09.687]         base::withCallingHandlers({
[17:42:09.687]             ...future.value <- base::withVisible(base::local({
[17:42:09.687]                 withCallingHandlers({
[17:42:09.687]                   {
[17:42:09.687]                     x <- 3
[17:42:09.687]                     stop("Woops!")
[17:42:09.687]                     x
[17:42:09.687]                   }
[17:42:09.687]                 }, immediateCondition = function(cond) {
[17:42:09.687]                   save_rds <- function (object, pathname, ...) 
[17:42:09.687]                   {
[17:42:09.687]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:09.687]                     if (file_test("-f", pathname_tmp)) {
[17:42:09.687]                       fi_tmp <- file.info(pathname_tmp)
[17:42:09.687]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:09.687]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:09.687]                         fi_tmp[["mtime"]])
[17:42:09.687]                     }
[17:42:09.687]                     tryCatch({
[17:42:09.687]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:09.687]                     }, error = function(ex) {
[17:42:09.687]                       msg <- conditionMessage(ex)
[17:42:09.687]                       fi_tmp <- file.info(pathname_tmp)
[17:42:09.687]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:09.687]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:09.687]                         fi_tmp[["mtime"]], msg)
[17:42:09.687]                       ex$message <- msg
[17:42:09.687]                       stop(ex)
[17:42:09.687]                     })
[17:42:09.687]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:09.687]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:09.687]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:09.687]                       fi_tmp <- file.info(pathname_tmp)
[17:42:09.687]                       fi <- file.info(pathname)
[17:42:09.687]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:09.687]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:09.687]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:09.687]                         fi[["size"]], fi[["mtime"]])
[17:42:09.687]                       stop(msg)
[17:42:09.687]                     }
[17:42:09.687]                     invisible(pathname)
[17:42:09.687]                   }
[17:42:09.687]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:09.687]                     rootPath = tempdir()) 
[17:42:09.687]                   {
[17:42:09.687]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:09.687]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:09.687]                       tmpdir = path, fileext = ".rds")
[17:42:09.687]                     save_rds(obj, file)
[17:42:09.687]                   }
[17:42:09.687]                   saveImmediateCondition(cond, path = "/tmp/RtmpZwB2Ue/.future/immediateConditions")
[17:42:09.687]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.687]                   {
[17:42:09.687]                     inherits <- base::inherits
[17:42:09.687]                     invokeRestart <- base::invokeRestart
[17:42:09.687]                     is.null <- base::is.null
[17:42:09.687]                     muffled <- FALSE
[17:42:09.687]                     if (inherits(cond, "message")) {
[17:42:09.687]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:09.687]                       if (muffled) 
[17:42:09.687]                         invokeRestart("muffleMessage")
[17:42:09.687]                     }
[17:42:09.687]                     else if (inherits(cond, "warning")) {
[17:42:09.687]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:09.687]                       if (muffled) 
[17:42:09.687]                         invokeRestart("muffleWarning")
[17:42:09.687]                     }
[17:42:09.687]                     else if (inherits(cond, "condition")) {
[17:42:09.687]                       if (!is.null(pattern)) {
[17:42:09.687]                         computeRestarts <- base::computeRestarts
[17:42:09.687]                         grepl <- base::grepl
[17:42:09.687]                         restarts <- computeRestarts(cond)
[17:42:09.687]                         for (restart in restarts) {
[17:42:09.687]                           name <- restart$name
[17:42:09.687]                           if (is.null(name)) 
[17:42:09.687]                             next
[17:42:09.687]                           if (!grepl(pattern, name)) 
[17:42:09.687]                             next
[17:42:09.687]                           invokeRestart(restart)
[17:42:09.687]                           muffled <- TRUE
[17:42:09.687]                           break
[17:42:09.687]                         }
[17:42:09.687]                       }
[17:42:09.687]                     }
[17:42:09.687]                     invisible(muffled)
[17:42:09.687]                   }
[17:42:09.687]                   muffleCondition(cond)
[17:42:09.687]                 })
[17:42:09.687]             }))
[17:42:09.687]             future::FutureResult(value = ...future.value$value, 
[17:42:09.687]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.687]                   ...future.rng), globalenv = if (FALSE) 
[17:42:09.687]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:09.687]                     ...future.globalenv.names))
[17:42:09.687]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:09.687]         }, condition = base::local({
[17:42:09.687]             c <- base::c
[17:42:09.687]             inherits <- base::inherits
[17:42:09.687]             invokeRestart <- base::invokeRestart
[17:42:09.687]             length <- base::length
[17:42:09.687]             list <- base::list
[17:42:09.687]             seq.int <- base::seq.int
[17:42:09.687]             signalCondition <- base::signalCondition
[17:42:09.687]             sys.calls <- base::sys.calls
[17:42:09.687]             `[[` <- base::`[[`
[17:42:09.687]             `+` <- base::`+`
[17:42:09.687]             `<<-` <- base::`<<-`
[17:42:09.687]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:09.687]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:09.687]                   3L)]
[17:42:09.687]             }
[17:42:09.687]             function(cond) {
[17:42:09.687]                 is_error <- inherits(cond, "error")
[17:42:09.687]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:09.687]                   NULL)
[17:42:09.687]                 if (is_error) {
[17:42:09.687]                   sessionInformation <- function() {
[17:42:09.687]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:09.687]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:09.687]                       search = base::search(), system = base::Sys.info())
[17:42:09.687]                   }
[17:42:09.687]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.687]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:09.687]                     cond$call), session = sessionInformation(), 
[17:42:09.687]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:09.687]                   signalCondition(cond)
[17:42:09.687]                 }
[17:42:09.687]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:09.687]                 "immediateCondition"))) {
[17:42:09.687]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:09.687]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.687]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:09.687]                   if (TRUE && !signal) {
[17:42:09.687]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.687]                     {
[17:42:09.687]                       inherits <- base::inherits
[17:42:09.687]                       invokeRestart <- base::invokeRestart
[17:42:09.687]                       is.null <- base::is.null
[17:42:09.687]                       muffled <- FALSE
[17:42:09.687]                       if (inherits(cond, "message")) {
[17:42:09.687]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.687]                         if (muffled) 
[17:42:09.687]                           invokeRestart("muffleMessage")
[17:42:09.687]                       }
[17:42:09.687]                       else if (inherits(cond, "warning")) {
[17:42:09.687]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.687]                         if (muffled) 
[17:42:09.687]                           invokeRestart("muffleWarning")
[17:42:09.687]                       }
[17:42:09.687]                       else if (inherits(cond, "condition")) {
[17:42:09.687]                         if (!is.null(pattern)) {
[17:42:09.687]                           computeRestarts <- base::computeRestarts
[17:42:09.687]                           grepl <- base::grepl
[17:42:09.687]                           restarts <- computeRestarts(cond)
[17:42:09.687]                           for (restart in restarts) {
[17:42:09.687]                             name <- restart$name
[17:42:09.687]                             if (is.null(name)) 
[17:42:09.687]                               next
[17:42:09.687]                             if (!grepl(pattern, name)) 
[17:42:09.687]                               next
[17:42:09.687]                             invokeRestart(restart)
[17:42:09.687]                             muffled <- TRUE
[17:42:09.687]                             break
[17:42:09.687]                           }
[17:42:09.687]                         }
[17:42:09.687]                       }
[17:42:09.687]                       invisible(muffled)
[17:42:09.687]                     }
[17:42:09.687]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.687]                   }
[17:42:09.687]                 }
[17:42:09.687]                 else {
[17:42:09.687]                   if (TRUE) {
[17:42:09.687]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.687]                     {
[17:42:09.687]                       inherits <- base::inherits
[17:42:09.687]                       invokeRestart <- base::invokeRestart
[17:42:09.687]                       is.null <- base::is.null
[17:42:09.687]                       muffled <- FALSE
[17:42:09.687]                       if (inherits(cond, "message")) {
[17:42:09.687]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.687]                         if (muffled) 
[17:42:09.687]                           invokeRestart("muffleMessage")
[17:42:09.687]                       }
[17:42:09.687]                       else if (inherits(cond, "warning")) {
[17:42:09.687]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.687]                         if (muffled) 
[17:42:09.687]                           invokeRestart("muffleWarning")
[17:42:09.687]                       }
[17:42:09.687]                       else if (inherits(cond, "condition")) {
[17:42:09.687]                         if (!is.null(pattern)) {
[17:42:09.687]                           computeRestarts <- base::computeRestarts
[17:42:09.687]                           grepl <- base::grepl
[17:42:09.687]                           restarts <- computeRestarts(cond)
[17:42:09.687]                           for (restart in restarts) {
[17:42:09.687]                             name <- restart$name
[17:42:09.687]                             if (is.null(name)) 
[17:42:09.687]                               next
[17:42:09.687]                             if (!grepl(pattern, name)) 
[17:42:09.687]                               next
[17:42:09.687]                             invokeRestart(restart)
[17:42:09.687]                             muffled <- TRUE
[17:42:09.687]                             break
[17:42:09.687]                           }
[17:42:09.687]                         }
[17:42:09.687]                       }
[17:42:09.687]                       invisible(muffled)
[17:42:09.687]                     }
[17:42:09.687]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.687]                   }
[17:42:09.687]                 }
[17:42:09.687]             }
[17:42:09.687]         }))
[17:42:09.687]     }, error = function(ex) {
[17:42:09.687]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:09.687]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.687]                 ...future.rng), started = ...future.startTime, 
[17:42:09.687]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:09.687]             version = "1.8"), class = "FutureResult")
[17:42:09.687]     }, finally = {
[17:42:09.687]         if (!identical(...future.workdir, getwd())) 
[17:42:09.687]             setwd(...future.workdir)
[17:42:09.687]         {
[17:42:09.687]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:09.687]                 ...future.oldOptions$nwarnings <- NULL
[17:42:09.687]             }
[17:42:09.687]             base::options(...future.oldOptions)
[17:42:09.687]             if (.Platform$OS.type == "windows") {
[17:42:09.687]                 old_names <- names(...future.oldEnvVars)
[17:42:09.687]                 envs <- base::Sys.getenv()
[17:42:09.687]                 names <- names(envs)
[17:42:09.687]                 common <- intersect(names, old_names)
[17:42:09.687]                 added <- setdiff(names, old_names)
[17:42:09.687]                 removed <- setdiff(old_names, names)
[17:42:09.687]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:09.687]                   envs[common]]
[17:42:09.687]                 NAMES <- toupper(changed)
[17:42:09.687]                 args <- list()
[17:42:09.687]                 for (kk in seq_along(NAMES)) {
[17:42:09.687]                   name <- changed[[kk]]
[17:42:09.687]                   NAME <- NAMES[[kk]]
[17:42:09.687]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.687]                     next
[17:42:09.687]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.687]                 }
[17:42:09.687]                 NAMES <- toupper(added)
[17:42:09.687]                 for (kk in seq_along(NAMES)) {
[17:42:09.687]                   name <- added[[kk]]
[17:42:09.687]                   NAME <- NAMES[[kk]]
[17:42:09.687]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.687]                     next
[17:42:09.687]                   args[[name]] <- ""
[17:42:09.687]                 }
[17:42:09.687]                 NAMES <- toupper(removed)
[17:42:09.687]                 for (kk in seq_along(NAMES)) {
[17:42:09.687]                   name <- removed[[kk]]
[17:42:09.687]                   NAME <- NAMES[[kk]]
[17:42:09.687]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.687]                     next
[17:42:09.687]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.687]                 }
[17:42:09.687]                 if (length(args) > 0) 
[17:42:09.687]                   base::do.call(base::Sys.setenv, args = args)
[17:42:09.687]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:09.687]             }
[17:42:09.687]             else {
[17:42:09.687]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:09.687]             }
[17:42:09.687]             {
[17:42:09.687]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:09.687]                   0L) {
[17:42:09.687]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:09.687]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:09.687]                   base::options(opts)
[17:42:09.687]                 }
[17:42:09.687]                 {
[17:42:09.687]                   {
[17:42:09.687]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:09.687]                     NULL
[17:42:09.687]                   }
[17:42:09.687]                   options(future.plan = NULL)
[17:42:09.687]                   if (is.na(NA_character_)) 
[17:42:09.687]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.687]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:09.687]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:09.687]                     envir = parent.frame()) 
[17:42:09.687]                   {
[17:42:09.687]                     default_workers <- missing(workers)
[17:42:09.687]                     if (is.function(workers)) 
[17:42:09.687]                       workers <- workers()
[17:42:09.687]                     workers <- structure(as.integer(workers), 
[17:42:09.687]                       class = class(workers))
[17:42:09.687]                     stop_if_not(is.finite(workers), workers >= 
[17:42:09.687]                       1L)
[17:42:09.687]                     if ((workers == 1L && !inherits(workers, 
[17:42:09.687]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:09.687]                       if (default_workers) 
[17:42:09.687]                         supportsMulticore(warn = TRUE)
[17:42:09.687]                       return(sequential(..., envir = envir))
[17:42:09.687]                     }
[17:42:09.687]                     oopts <- options(mc.cores = workers)
[17:42:09.687]                     on.exit(options(oopts))
[17:42:09.687]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:09.687]                       envir = envir)
[17:42:09.687]                     if (!future$lazy) 
[17:42:09.687]                       future <- run(future)
[17:42:09.687]                     invisible(future)
[17:42:09.687]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:09.687]                 }
[17:42:09.687]             }
[17:42:09.687]         }
[17:42:09.687]     })
[17:42:09.687]     if (TRUE) {
[17:42:09.687]         base::sink(type = "output", split = FALSE)
[17:42:09.687]         if (TRUE) {
[17:42:09.687]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:09.687]         }
[17:42:09.687]         else {
[17:42:09.687]             ...future.result["stdout"] <- base::list(NULL)
[17:42:09.687]         }
[17:42:09.687]         base::close(...future.stdout)
[17:42:09.687]         ...future.stdout <- NULL
[17:42:09.687]     }
[17:42:09.687]     ...future.result$conditions <- ...future.conditions
[17:42:09.687]     ...future.result$finished <- base::Sys.time()
[17:42:09.687]     ...future.result
[17:42:09.687] }
[17:42:09.690] requestCore(): workers = 2
[17:42:09.692] MulticoreFuture started
[17:42:09.692] - Launch lazy future ... done
[17:42:09.692] run() for ‘MulticoreFuture’ ... done
[17:42:09.693] plan(): Setting new future strategy stack:
[17:42:09.693] List of future strategies:
[17:42:09.693] 1. sequential:
[17:42:09.693]    - args: function (..., envir = parent.frame())
[17:42:09.693]    - tweaked: FALSE
[17:42:09.693]    - call: NULL
[17:42:09.694] plan(): nbrOfWorkers() = 1
[17:42:09.696] plan(): Setting new future strategy stack:
[17:42:09.696] List of future strategies:
[17:42:09.696] 1. multicore:
[17:42:09.696]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:09.696]    - tweaked: FALSE
[17:42:09.696]    - call: plan(strategy)
[17:42:09.701] plan(): nbrOfWorkers() = 2
[17:42:09.706] signalConditions() ...
[17:42:09.706]  - include = ‘immediateCondition’
[17:42:09.706]  - exclude = 
[17:42:09.706]  - resignal = FALSE
[17:42:09.707]  - Number of conditions: 1
[17:42:09.707] signalConditions() ... done
[17:42:09.707] signalConditions() ...
[17:42:09.707]  - include = ‘immediateCondition’
[17:42:09.707]  - exclude = 
[17:42:09.707]  - resignal = FALSE
[17:42:09.707]  - Number of conditions: 1
[17:42:09.708] signalConditions() ... done
[17:42:09.708] Future state: ‘finished’
[17:42:09.708] signalConditions() ...
[17:42:09.708]  - include = ‘condition’
[17:42:09.708]  - exclude = ‘immediateCondition’
[17:42:09.708]  - resignal = TRUE
[17:42:09.708]  - Number of conditions: 1
[17:42:09.708]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:42:09.709] signalConditions() ... done
[17:42:09.709] getGlobalsAndPackages() ...
[17:42:09.709] Searching for globals...
[17:42:09.711] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[17:42:09.711] Searching for globals ... DONE
[17:42:09.712] Resolving globals: FALSE
[17:42:09.712] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:09.713] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:42:09.713] - globals: [1] ‘ii’
[17:42:09.713] 
[17:42:09.713] getGlobalsAndPackages() ... DONE
[17:42:09.713] run() for ‘Future’ ...
[17:42:09.714] - state: ‘created’
[17:42:09.714] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:09.718] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:09.718] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:09.721]   - Field: ‘label’
[17:42:09.721]   - Field: ‘local’
[17:42:09.721]   - Field: ‘owner’
[17:42:09.721]   - Field: ‘envir’
[17:42:09.721]   - Field: ‘workers’
[17:42:09.721]   - Field: ‘packages’
[17:42:09.721]   - Field: ‘gc’
[17:42:09.721]   - Field: ‘job’
[17:42:09.721]   - Field: ‘conditions’
[17:42:09.722]   - Field: ‘expr’
[17:42:09.722]   - Field: ‘uuid’
[17:42:09.722]   - Field: ‘seed’
[17:42:09.722]   - Field: ‘version’
[17:42:09.722]   - Field: ‘result’
[17:42:09.722]   - Field: ‘asynchronous’
[17:42:09.723]   - Field: ‘calls’
[17:42:09.723]   - Field: ‘globals’
[17:42:09.723]   - Field: ‘stdout’
[17:42:09.723]   - Field: ‘earlySignal’
[17:42:09.723]   - Field: ‘lazy’
[17:42:09.723]   - Field: ‘state’
[17:42:09.723] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:09.723] - Launch lazy future ...
[17:42:09.724] Packages needed by the future expression (n = 0): <none>
[17:42:09.724] Packages needed by future strategies (n = 0): <none>
[17:42:09.725] {
[17:42:09.725]     {
[17:42:09.725]         {
[17:42:09.725]             ...future.startTime <- base::Sys.time()
[17:42:09.725]             {
[17:42:09.725]                 {
[17:42:09.725]                   {
[17:42:09.725]                     {
[17:42:09.725]                       base::local({
[17:42:09.725]                         has_future <- base::requireNamespace("future", 
[17:42:09.725]                           quietly = TRUE)
[17:42:09.725]                         if (has_future) {
[17:42:09.725]                           ns <- base::getNamespace("future")
[17:42:09.725]                           version <- ns[[".package"]][["version"]]
[17:42:09.725]                           if (is.null(version)) 
[17:42:09.725]                             version <- utils::packageVersion("future")
[17:42:09.725]                         }
[17:42:09.725]                         else {
[17:42:09.725]                           version <- NULL
[17:42:09.725]                         }
[17:42:09.725]                         if (!has_future || version < "1.8.0") {
[17:42:09.725]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:09.725]                             "", base::R.version$version.string), 
[17:42:09.725]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:09.725]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:09.725]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:09.725]                               "release", "version")], collapse = " "), 
[17:42:09.725]                             hostname = base::Sys.info()[["nodename"]])
[17:42:09.725]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:09.725]                             info)
[17:42:09.725]                           info <- base::paste(info, collapse = "; ")
[17:42:09.725]                           if (!has_future) {
[17:42:09.725]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:09.725]                               info)
[17:42:09.725]                           }
[17:42:09.725]                           else {
[17:42:09.725]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:09.725]                               info, version)
[17:42:09.725]                           }
[17:42:09.725]                           base::stop(msg)
[17:42:09.725]                         }
[17:42:09.725]                       })
[17:42:09.725]                     }
[17:42:09.725]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:09.725]                     base::options(mc.cores = 1L)
[17:42:09.725]                   }
[17:42:09.725]                   options(future.plan = NULL)
[17:42:09.725]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.725]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:09.725]                 }
[17:42:09.725]                 ...future.workdir <- getwd()
[17:42:09.725]             }
[17:42:09.725]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:09.725]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:09.725]         }
[17:42:09.725]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:09.725]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:09.725]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:09.725]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:09.725]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:09.725]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:09.725]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:09.725]             base::names(...future.oldOptions))
[17:42:09.725]     }
[17:42:09.725]     if (FALSE) {
[17:42:09.725]     }
[17:42:09.725]     else {
[17:42:09.725]         if (TRUE) {
[17:42:09.725]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:09.725]                 open = "w")
[17:42:09.725]         }
[17:42:09.725]         else {
[17:42:09.725]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:09.725]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:09.725]         }
[17:42:09.725]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:09.725]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:09.725]             base::sink(type = "output", split = FALSE)
[17:42:09.725]             base::close(...future.stdout)
[17:42:09.725]         }, add = TRUE)
[17:42:09.725]     }
[17:42:09.725]     ...future.frame <- base::sys.nframe()
[17:42:09.725]     ...future.conditions <- base::list()
[17:42:09.725]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:09.725]     if (FALSE) {
[17:42:09.725]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:09.725]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:09.725]     }
[17:42:09.725]     ...future.result <- base::tryCatch({
[17:42:09.725]         base::withCallingHandlers({
[17:42:09.725]             ...future.value <- base::withVisible(base::local({
[17:42:09.725]                 withCallingHandlers({
[17:42:09.725]                   {
[17:42:09.725]                     if (ii%%2 == 0) 
[17:42:09.725]                       stop("Woops!")
[17:42:09.725]                     ii
[17:42:09.725]                   }
[17:42:09.725]                 }, immediateCondition = function(cond) {
[17:42:09.725]                   save_rds <- function (object, pathname, ...) 
[17:42:09.725]                   {
[17:42:09.725]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:09.725]                     if (file_test("-f", pathname_tmp)) {
[17:42:09.725]                       fi_tmp <- file.info(pathname_tmp)
[17:42:09.725]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:09.725]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:09.725]                         fi_tmp[["mtime"]])
[17:42:09.725]                     }
[17:42:09.725]                     tryCatch({
[17:42:09.725]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:09.725]                     }, error = function(ex) {
[17:42:09.725]                       msg <- conditionMessage(ex)
[17:42:09.725]                       fi_tmp <- file.info(pathname_tmp)
[17:42:09.725]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:09.725]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:09.725]                         fi_tmp[["mtime"]], msg)
[17:42:09.725]                       ex$message <- msg
[17:42:09.725]                       stop(ex)
[17:42:09.725]                     })
[17:42:09.725]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:09.725]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:09.725]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:09.725]                       fi_tmp <- file.info(pathname_tmp)
[17:42:09.725]                       fi <- file.info(pathname)
[17:42:09.725]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:09.725]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:09.725]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:09.725]                         fi[["size"]], fi[["mtime"]])
[17:42:09.725]                       stop(msg)
[17:42:09.725]                     }
[17:42:09.725]                     invisible(pathname)
[17:42:09.725]                   }
[17:42:09.725]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:09.725]                     rootPath = tempdir()) 
[17:42:09.725]                   {
[17:42:09.725]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:09.725]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:09.725]                       tmpdir = path, fileext = ".rds")
[17:42:09.725]                     save_rds(obj, file)
[17:42:09.725]                   }
[17:42:09.725]                   saveImmediateCondition(cond, path = "/tmp/RtmpZwB2Ue/.future/immediateConditions")
[17:42:09.725]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.725]                   {
[17:42:09.725]                     inherits <- base::inherits
[17:42:09.725]                     invokeRestart <- base::invokeRestart
[17:42:09.725]                     is.null <- base::is.null
[17:42:09.725]                     muffled <- FALSE
[17:42:09.725]                     if (inherits(cond, "message")) {
[17:42:09.725]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:09.725]                       if (muffled) 
[17:42:09.725]                         invokeRestart("muffleMessage")
[17:42:09.725]                     }
[17:42:09.725]                     else if (inherits(cond, "warning")) {
[17:42:09.725]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:09.725]                       if (muffled) 
[17:42:09.725]                         invokeRestart("muffleWarning")
[17:42:09.725]                     }
[17:42:09.725]                     else if (inherits(cond, "condition")) {
[17:42:09.725]                       if (!is.null(pattern)) {
[17:42:09.725]                         computeRestarts <- base::computeRestarts
[17:42:09.725]                         grepl <- base::grepl
[17:42:09.725]                         restarts <- computeRestarts(cond)
[17:42:09.725]                         for (restart in restarts) {
[17:42:09.725]                           name <- restart$name
[17:42:09.725]                           if (is.null(name)) 
[17:42:09.725]                             next
[17:42:09.725]                           if (!grepl(pattern, name)) 
[17:42:09.725]                             next
[17:42:09.725]                           invokeRestart(restart)
[17:42:09.725]                           muffled <- TRUE
[17:42:09.725]                           break
[17:42:09.725]                         }
[17:42:09.725]                       }
[17:42:09.725]                     }
[17:42:09.725]                     invisible(muffled)
[17:42:09.725]                   }
[17:42:09.725]                   muffleCondition(cond)
[17:42:09.725]                 })
[17:42:09.725]             }))
[17:42:09.725]             future::FutureResult(value = ...future.value$value, 
[17:42:09.725]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.725]                   ...future.rng), globalenv = if (FALSE) 
[17:42:09.725]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:09.725]                     ...future.globalenv.names))
[17:42:09.725]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:09.725]         }, condition = base::local({
[17:42:09.725]             c <- base::c
[17:42:09.725]             inherits <- base::inherits
[17:42:09.725]             invokeRestart <- base::invokeRestart
[17:42:09.725]             length <- base::length
[17:42:09.725]             list <- base::list
[17:42:09.725]             seq.int <- base::seq.int
[17:42:09.725]             signalCondition <- base::signalCondition
[17:42:09.725]             sys.calls <- base::sys.calls
[17:42:09.725]             `[[` <- base::`[[`
[17:42:09.725]             `+` <- base::`+`
[17:42:09.725]             `<<-` <- base::`<<-`
[17:42:09.725]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:09.725]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:09.725]                   3L)]
[17:42:09.725]             }
[17:42:09.725]             function(cond) {
[17:42:09.725]                 is_error <- inherits(cond, "error")
[17:42:09.725]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:09.725]                   NULL)
[17:42:09.725]                 if (is_error) {
[17:42:09.725]                   sessionInformation <- function() {
[17:42:09.725]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:09.725]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:09.725]                       search = base::search(), system = base::Sys.info())
[17:42:09.725]                   }
[17:42:09.725]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.725]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:09.725]                     cond$call), session = sessionInformation(), 
[17:42:09.725]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:09.725]                   signalCondition(cond)
[17:42:09.725]                 }
[17:42:09.725]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:09.725]                 "immediateCondition"))) {
[17:42:09.725]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:09.725]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.725]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:09.725]                   if (TRUE && !signal) {
[17:42:09.725]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.725]                     {
[17:42:09.725]                       inherits <- base::inherits
[17:42:09.725]                       invokeRestart <- base::invokeRestart
[17:42:09.725]                       is.null <- base::is.null
[17:42:09.725]                       muffled <- FALSE
[17:42:09.725]                       if (inherits(cond, "message")) {
[17:42:09.725]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.725]                         if (muffled) 
[17:42:09.725]                           invokeRestart("muffleMessage")
[17:42:09.725]                       }
[17:42:09.725]                       else if (inherits(cond, "warning")) {
[17:42:09.725]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.725]                         if (muffled) 
[17:42:09.725]                           invokeRestart("muffleWarning")
[17:42:09.725]                       }
[17:42:09.725]                       else if (inherits(cond, "condition")) {
[17:42:09.725]                         if (!is.null(pattern)) {
[17:42:09.725]                           computeRestarts <- base::computeRestarts
[17:42:09.725]                           grepl <- base::grepl
[17:42:09.725]                           restarts <- computeRestarts(cond)
[17:42:09.725]                           for (restart in restarts) {
[17:42:09.725]                             name <- restart$name
[17:42:09.725]                             if (is.null(name)) 
[17:42:09.725]                               next
[17:42:09.725]                             if (!grepl(pattern, name)) 
[17:42:09.725]                               next
[17:42:09.725]                             invokeRestart(restart)
[17:42:09.725]                             muffled <- TRUE
[17:42:09.725]                             break
[17:42:09.725]                           }
[17:42:09.725]                         }
[17:42:09.725]                       }
[17:42:09.725]                       invisible(muffled)
[17:42:09.725]                     }
[17:42:09.725]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.725]                   }
[17:42:09.725]                 }
[17:42:09.725]                 else {
[17:42:09.725]                   if (TRUE) {
[17:42:09.725]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.725]                     {
[17:42:09.725]                       inherits <- base::inherits
[17:42:09.725]                       invokeRestart <- base::invokeRestart
[17:42:09.725]                       is.null <- base::is.null
[17:42:09.725]                       muffled <- FALSE
[17:42:09.725]                       if (inherits(cond, "message")) {
[17:42:09.725]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.725]                         if (muffled) 
[17:42:09.725]                           invokeRestart("muffleMessage")
[17:42:09.725]                       }
[17:42:09.725]                       else if (inherits(cond, "warning")) {
[17:42:09.725]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.725]                         if (muffled) 
[17:42:09.725]                           invokeRestart("muffleWarning")
[17:42:09.725]                       }
[17:42:09.725]                       else if (inherits(cond, "condition")) {
[17:42:09.725]                         if (!is.null(pattern)) {
[17:42:09.725]                           computeRestarts <- base::computeRestarts
[17:42:09.725]                           grepl <- base::grepl
[17:42:09.725]                           restarts <- computeRestarts(cond)
[17:42:09.725]                           for (restart in restarts) {
[17:42:09.725]                             name <- restart$name
[17:42:09.725]                             if (is.null(name)) 
[17:42:09.725]                               next
[17:42:09.725]                             if (!grepl(pattern, name)) 
[17:42:09.725]                               next
[17:42:09.725]                             invokeRestart(restart)
[17:42:09.725]                             muffled <- TRUE
[17:42:09.725]                             break
[17:42:09.725]                           }
[17:42:09.725]                         }
[17:42:09.725]                       }
[17:42:09.725]                       invisible(muffled)
[17:42:09.725]                     }
[17:42:09.725]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.725]                   }
[17:42:09.725]                 }
[17:42:09.725]             }
[17:42:09.725]         }))
[17:42:09.725]     }, error = function(ex) {
[17:42:09.725]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:09.725]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.725]                 ...future.rng), started = ...future.startTime, 
[17:42:09.725]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:09.725]             version = "1.8"), class = "FutureResult")
[17:42:09.725]     }, finally = {
[17:42:09.725]         if (!identical(...future.workdir, getwd())) 
[17:42:09.725]             setwd(...future.workdir)
[17:42:09.725]         {
[17:42:09.725]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:09.725]                 ...future.oldOptions$nwarnings <- NULL
[17:42:09.725]             }
[17:42:09.725]             base::options(...future.oldOptions)
[17:42:09.725]             if (.Platform$OS.type == "windows") {
[17:42:09.725]                 old_names <- names(...future.oldEnvVars)
[17:42:09.725]                 envs <- base::Sys.getenv()
[17:42:09.725]                 names <- names(envs)
[17:42:09.725]                 common <- intersect(names, old_names)
[17:42:09.725]                 added <- setdiff(names, old_names)
[17:42:09.725]                 removed <- setdiff(old_names, names)
[17:42:09.725]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:09.725]                   envs[common]]
[17:42:09.725]                 NAMES <- toupper(changed)
[17:42:09.725]                 args <- list()
[17:42:09.725]                 for (kk in seq_along(NAMES)) {
[17:42:09.725]                   name <- changed[[kk]]
[17:42:09.725]                   NAME <- NAMES[[kk]]
[17:42:09.725]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.725]                     next
[17:42:09.725]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.725]                 }
[17:42:09.725]                 NAMES <- toupper(added)
[17:42:09.725]                 for (kk in seq_along(NAMES)) {
[17:42:09.725]                   name <- added[[kk]]
[17:42:09.725]                   NAME <- NAMES[[kk]]
[17:42:09.725]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.725]                     next
[17:42:09.725]                   args[[name]] <- ""
[17:42:09.725]                 }
[17:42:09.725]                 NAMES <- toupper(removed)
[17:42:09.725]                 for (kk in seq_along(NAMES)) {
[17:42:09.725]                   name <- removed[[kk]]
[17:42:09.725]                   NAME <- NAMES[[kk]]
[17:42:09.725]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.725]                     next
[17:42:09.725]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.725]                 }
[17:42:09.725]                 if (length(args) > 0) 
[17:42:09.725]                   base::do.call(base::Sys.setenv, args = args)
[17:42:09.725]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:09.725]             }
[17:42:09.725]             else {
[17:42:09.725]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:09.725]             }
[17:42:09.725]             {
[17:42:09.725]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:09.725]                   0L) {
[17:42:09.725]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:09.725]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:09.725]                   base::options(opts)
[17:42:09.725]                 }
[17:42:09.725]                 {
[17:42:09.725]                   {
[17:42:09.725]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:09.725]                     NULL
[17:42:09.725]                   }
[17:42:09.725]                   options(future.plan = NULL)
[17:42:09.725]                   if (is.na(NA_character_)) 
[17:42:09.725]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.725]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:09.725]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:09.725]                     envir = parent.frame()) 
[17:42:09.725]                   {
[17:42:09.725]                     default_workers <- missing(workers)
[17:42:09.725]                     if (is.function(workers)) 
[17:42:09.725]                       workers <- workers()
[17:42:09.725]                     workers <- structure(as.integer(workers), 
[17:42:09.725]                       class = class(workers))
[17:42:09.725]                     stop_if_not(is.finite(workers), workers >= 
[17:42:09.725]                       1L)
[17:42:09.725]                     if ((workers == 1L && !inherits(workers, 
[17:42:09.725]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:09.725]                       if (default_workers) 
[17:42:09.725]                         supportsMulticore(warn = TRUE)
[17:42:09.725]                       return(sequential(..., envir = envir))
[17:42:09.725]                     }
[17:42:09.725]                     oopts <- options(mc.cores = workers)
[17:42:09.725]                     on.exit(options(oopts))
[17:42:09.725]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:09.725]                       envir = envir)
[17:42:09.725]                     if (!future$lazy) 
[17:42:09.725]                       future <- run(future)
[17:42:09.725]                     invisible(future)
[17:42:09.725]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:09.725]                 }
[17:42:09.725]             }
[17:42:09.725]         }
[17:42:09.725]     })
[17:42:09.725]     if (TRUE) {
[17:42:09.725]         base::sink(type = "output", split = FALSE)
[17:42:09.725]         if (TRUE) {
[17:42:09.725]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:09.725]         }
[17:42:09.725]         else {
[17:42:09.725]             ...future.result["stdout"] <- base::list(NULL)
[17:42:09.725]         }
[17:42:09.725]         base::close(...future.stdout)
[17:42:09.725]         ...future.stdout <- NULL
[17:42:09.725]     }
[17:42:09.725]     ...future.result$conditions <- ...future.conditions
[17:42:09.725]     ...future.result$finished <- base::Sys.time()
[17:42:09.725]     ...future.result
[17:42:09.725] }
[17:42:09.727] assign_globals() ...
[17:42:09.727] List of 1
[17:42:09.727]  $ ii: int 1
[17:42:09.727]  - attr(*, "where")=List of 1
[17:42:09.727]   ..$ ii:<environment: R_EmptyEnv> 
[17:42:09.727]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:09.727]  - attr(*, "resolved")= logi FALSE
[17:42:09.727]  - attr(*, "total_size")= num 56
[17:42:09.727]  - attr(*, "already-done")= logi TRUE
[17:42:09.730] - copied ‘ii’ to environment
[17:42:09.730] assign_globals() ... done
[17:42:09.730] requestCore(): workers = 2
[17:42:09.732] MulticoreFuture started
[17:42:09.733] - Launch lazy future ... done
[17:42:09.733] run() for ‘MulticoreFuture’ ... done
[17:42:09.733] plan(): Setting new future strategy stack:
[17:42:09.734] getGlobalsAndPackages() ...
[17:42:09.733] List of future strategies:
[17:42:09.733] 1. sequential:
[17:42:09.733]    - args: function (..., envir = parent.frame())
[17:42:09.733]    - tweaked: FALSE
[17:42:09.733]    - call: NULL
[17:42:09.734] Searching for globals...
[17:42:09.734] plan(): nbrOfWorkers() = 1
[17:42:09.736] plan(): Setting new future strategy stack:
[17:42:09.736] List of future strategies:
[17:42:09.736] 1. multicore:
[17:42:09.736]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:09.736]    - tweaked: FALSE
[17:42:09.736]    - call: plan(strategy)
[17:42:09.737] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[17:42:09.738] Searching for globals ... DONE
[17:42:09.738] Resolving globals: FALSE
[17:42:09.739] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:09.739] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:42:09.740] - globals: [1] ‘ii’
[17:42:09.740] 
[17:42:09.740] getGlobalsAndPackages() ... DONE
[17:42:09.741] run() for ‘Future’ ...
[17:42:09.741] - state: ‘created’
[17:42:09.741] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:09.742] plan(): nbrOfWorkers() = 2
[17:42:09.746] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:09.746] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:09.746]   - Field: ‘label’
[17:42:09.746]   - Field: ‘local’
[17:42:09.747]   - Field: ‘owner’
[17:42:09.747]   - Field: ‘envir’
[17:42:09.747]   - Field: ‘workers’
[17:42:09.747]   - Field: ‘packages’
[17:42:09.747]   - Field: ‘gc’
[17:42:09.747]   - Field: ‘job’
[17:42:09.748]   - Field: ‘conditions’
[17:42:09.748]   - Field: ‘expr’
[17:42:09.748]   - Field: ‘uuid’
[17:42:09.748]   - Field: ‘seed’
[17:42:09.748]   - Field: ‘version’
[17:42:09.748]   - Field: ‘result’
[17:42:09.748]   - Field: ‘asynchronous’
[17:42:09.749]   - Field: ‘calls’
[17:42:09.749]   - Field: ‘globals’
[17:42:09.749]   - Field: ‘stdout’
[17:42:09.749]   - Field: ‘earlySignal’
[17:42:09.749]   - Field: ‘lazy’
[17:42:09.749]   - Field: ‘state’
[17:42:09.749] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:09.750] - Launch lazy future ...
[17:42:09.750] Packages needed by the future expression (n = 0): <none>
[17:42:09.750] Packages needed by future strategies (n = 0): <none>
[17:42:09.751] {
[17:42:09.751]     {
[17:42:09.751]         {
[17:42:09.751]             ...future.startTime <- base::Sys.time()
[17:42:09.751]             {
[17:42:09.751]                 {
[17:42:09.751]                   {
[17:42:09.751]                     {
[17:42:09.751]                       base::local({
[17:42:09.751]                         has_future <- base::requireNamespace("future", 
[17:42:09.751]                           quietly = TRUE)
[17:42:09.751]                         if (has_future) {
[17:42:09.751]                           ns <- base::getNamespace("future")
[17:42:09.751]                           version <- ns[[".package"]][["version"]]
[17:42:09.751]                           if (is.null(version)) 
[17:42:09.751]                             version <- utils::packageVersion("future")
[17:42:09.751]                         }
[17:42:09.751]                         else {
[17:42:09.751]                           version <- NULL
[17:42:09.751]                         }
[17:42:09.751]                         if (!has_future || version < "1.8.0") {
[17:42:09.751]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:09.751]                             "", base::R.version$version.string), 
[17:42:09.751]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:09.751]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:09.751]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:09.751]                               "release", "version")], collapse = " "), 
[17:42:09.751]                             hostname = base::Sys.info()[["nodename"]])
[17:42:09.751]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:09.751]                             info)
[17:42:09.751]                           info <- base::paste(info, collapse = "; ")
[17:42:09.751]                           if (!has_future) {
[17:42:09.751]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:09.751]                               info)
[17:42:09.751]                           }
[17:42:09.751]                           else {
[17:42:09.751]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:09.751]                               info, version)
[17:42:09.751]                           }
[17:42:09.751]                           base::stop(msg)
[17:42:09.751]                         }
[17:42:09.751]                       })
[17:42:09.751]                     }
[17:42:09.751]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:09.751]                     base::options(mc.cores = 1L)
[17:42:09.751]                   }
[17:42:09.751]                   options(future.plan = NULL)
[17:42:09.751]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.751]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:09.751]                 }
[17:42:09.751]                 ...future.workdir <- getwd()
[17:42:09.751]             }
[17:42:09.751]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:09.751]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:09.751]         }
[17:42:09.751]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:09.751]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:09.751]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:09.751]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:09.751]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:09.751]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:09.751]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:09.751]             base::names(...future.oldOptions))
[17:42:09.751]     }
[17:42:09.751]     if (FALSE) {
[17:42:09.751]     }
[17:42:09.751]     else {
[17:42:09.751]         if (TRUE) {
[17:42:09.751]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:09.751]                 open = "w")
[17:42:09.751]         }
[17:42:09.751]         else {
[17:42:09.751]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:09.751]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:09.751]         }
[17:42:09.751]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:09.751]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:09.751]             base::sink(type = "output", split = FALSE)
[17:42:09.751]             base::close(...future.stdout)
[17:42:09.751]         }, add = TRUE)
[17:42:09.751]     }
[17:42:09.751]     ...future.frame <- base::sys.nframe()
[17:42:09.751]     ...future.conditions <- base::list()
[17:42:09.751]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:09.751]     if (FALSE) {
[17:42:09.751]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:09.751]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:09.751]     }
[17:42:09.751]     ...future.result <- base::tryCatch({
[17:42:09.751]         base::withCallingHandlers({
[17:42:09.751]             ...future.value <- base::withVisible(base::local({
[17:42:09.751]                 withCallingHandlers({
[17:42:09.751]                   {
[17:42:09.751]                     if (ii%%2 == 0) 
[17:42:09.751]                       stop("Woops!")
[17:42:09.751]                     ii
[17:42:09.751]                   }
[17:42:09.751]                 }, immediateCondition = function(cond) {
[17:42:09.751]                   save_rds <- function (object, pathname, ...) 
[17:42:09.751]                   {
[17:42:09.751]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:09.751]                     if (file_test("-f", pathname_tmp)) {
[17:42:09.751]                       fi_tmp <- file.info(pathname_tmp)
[17:42:09.751]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:09.751]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:09.751]                         fi_tmp[["mtime"]])
[17:42:09.751]                     }
[17:42:09.751]                     tryCatch({
[17:42:09.751]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:09.751]                     }, error = function(ex) {
[17:42:09.751]                       msg <- conditionMessage(ex)
[17:42:09.751]                       fi_tmp <- file.info(pathname_tmp)
[17:42:09.751]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:09.751]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:09.751]                         fi_tmp[["mtime"]], msg)
[17:42:09.751]                       ex$message <- msg
[17:42:09.751]                       stop(ex)
[17:42:09.751]                     })
[17:42:09.751]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:09.751]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:09.751]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:09.751]                       fi_tmp <- file.info(pathname_tmp)
[17:42:09.751]                       fi <- file.info(pathname)
[17:42:09.751]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:09.751]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:09.751]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:09.751]                         fi[["size"]], fi[["mtime"]])
[17:42:09.751]                       stop(msg)
[17:42:09.751]                     }
[17:42:09.751]                     invisible(pathname)
[17:42:09.751]                   }
[17:42:09.751]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:09.751]                     rootPath = tempdir()) 
[17:42:09.751]                   {
[17:42:09.751]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:09.751]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:09.751]                       tmpdir = path, fileext = ".rds")
[17:42:09.751]                     save_rds(obj, file)
[17:42:09.751]                   }
[17:42:09.751]                   saveImmediateCondition(cond, path = "/tmp/RtmpZwB2Ue/.future/immediateConditions")
[17:42:09.751]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.751]                   {
[17:42:09.751]                     inherits <- base::inherits
[17:42:09.751]                     invokeRestart <- base::invokeRestart
[17:42:09.751]                     is.null <- base::is.null
[17:42:09.751]                     muffled <- FALSE
[17:42:09.751]                     if (inherits(cond, "message")) {
[17:42:09.751]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:09.751]                       if (muffled) 
[17:42:09.751]                         invokeRestart("muffleMessage")
[17:42:09.751]                     }
[17:42:09.751]                     else if (inherits(cond, "warning")) {
[17:42:09.751]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:09.751]                       if (muffled) 
[17:42:09.751]                         invokeRestart("muffleWarning")
[17:42:09.751]                     }
[17:42:09.751]                     else if (inherits(cond, "condition")) {
[17:42:09.751]                       if (!is.null(pattern)) {
[17:42:09.751]                         computeRestarts <- base::computeRestarts
[17:42:09.751]                         grepl <- base::grepl
[17:42:09.751]                         restarts <- computeRestarts(cond)
[17:42:09.751]                         for (restart in restarts) {
[17:42:09.751]                           name <- restart$name
[17:42:09.751]                           if (is.null(name)) 
[17:42:09.751]                             next
[17:42:09.751]                           if (!grepl(pattern, name)) 
[17:42:09.751]                             next
[17:42:09.751]                           invokeRestart(restart)
[17:42:09.751]                           muffled <- TRUE
[17:42:09.751]                           break
[17:42:09.751]                         }
[17:42:09.751]                       }
[17:42:09.751]                     }
[17:42:09.751]                     invisible(muffled)
[17:42:09.751]                   }
[17:42:09.751]                   muffleCondition(cond)
[17:42:09.751]                 })
[17:42:09.751]             }))
[17:42:09.751]             future::FutureResult(value = ...future.value$value, 
[17:42:09.751]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.751]                   ...future.rng), globalenv = if (FALSE) 
[17:42:09.751]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:09.751]                     ...future.globalenv.names))
[17:42:09.751]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:09.751]         }, condition = base::local({
[17:42:09.751]             c <- base::c
[17:42:09.751]             inherits <- base::inherits
[17:42:09.751]             invokeRestart <- base::invokeRestart
[17:42:09.751]             length <- base::length
[17:42:09.751]             list <- base::list
[17:42:09.751]             seq.int <- base::seq.int
[17:42:09.751]             signalCondition <- base::signalCondition
[17:42:09.751]             sys.calls <- base::sys.calls
[17:42:09.751]             `[[` <- base::`[[`
[17:42:09.751]             `+` <- base::`+`
[17:42:09.751]             `<<-` <- base::`<<-`
[17:42:09.751]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:09.751]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:09.751]                   3L)]
[17:42:09.751]             }
[17:42:09.751]             function(cond) {
[17:42:09.751]                 is_error <- inherits(cond, "error")
[17:42:09.751]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:09.751]                   NULL)
[17:42:09.751]                 if (is_error) {
[17:42:09.751]                   sessionInformation <- function() {
[17:42:09.751]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:09.751]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:09.751]                       search = base::search(), system = base::Sys.info())
[17:42:09.751]                   }
[17:42:09.751]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.751]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:09.751]                     cond$call), session = sessionInformation(), 
[17:42:09.751]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:09.751]                   signalCondition(cond)
[17:42:09.751]                 }
[17:42:09.751]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:09.751]                 "immediateCondition"))) {
[17:42:09.751]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:09.751]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.751]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:09.751]                   if (TRUE && !signal) {
[17:42:09.751]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.751]                     {
[17:42:09.751]                       inherits <- base::inherits
[17:42:09.751]                       invokeRestart <- base::invokeRestart
[17:42:09.751]                       is.null <- base::is.null
[17:42:09.751]                       muffled <- FALSE
[17:42:09.751]                       if (inherits(cond, "message")) {
[17:42:09.751]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.751]                         if (muffled) 
[17:42:09.751]                           invokeRestart("muffleMessage")
[17:42:09.751]                       }
[17:42:09.751]                       else if (inherits(cond, "warning")) {
[17:42:09.751]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.751]                         if (muffled) 
[17:42:09.751]                           invokeRestart("muffleWarning")
[17:42:09.751]                       }
[17:42:09.751]                       else if (inherits(cond, "condition")) {
[17:42:09.751]                         if (!is.null(pattern)) {
[17:42:09.751]                           computeRestarts <- base::computeRestarts
[17:42:09.751]                           grepl <- base::grepl
[17:42:09.751]                           restarts <- computeRestarts(cond)
[17:42:09.751]                           for (restart in restarts) {
[17:42:09.751]                             name <- restart$name
[17:42:09.751]                             if (is.null(name)) 
[17:42:09.751]                               next
[17:42:09.751]                             if (!grepl(pattern, name)) 
[17:42:09.751]                               next
[17:42:09.751]                             invokeRestart(restart)
[17:42:09.751]                             muffled <- TRUE
[17:42:09.751]                             break
[17:42:09.751]                           }
[17:42:09.751]                         }
[17:42:09.751]                       }
[17:42:09.751]                       invisible(muffled)
[17:42:09.751]                     }
[17:42:09.751]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.751]                   }
[17:42:09.751]                 }
[17:42:09.751]                 else {
[17:42:09.751]                   if (TRUE) {
[17:42:09.751]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.751]                     {
[17:42:09.751]                       inherits <- base::inherits
[17:42:09.751]                       invokeRestart <- base::invokeRestart
[17:42:09.751]                       is.null <- base::is.null
[17:42:09.751]                       muffled <- FALSE
[17:42:09.751]                       if (inherits(cond, "message")) {
[17:42:09.751]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.751]                         if (muffled) 
[17:42:09.751]                           invokeRestart("muffleMessage")
[17:42:09.751]                       }
[17:42:09.751]                       else if (inherits(cond, "warning")) {
[17:42:09.751]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.751]                         if (muffled) 
[17:42:09.751]                           invokeRestart("muffleWarning")
[17:42:09.751]                       }
[17:42:09.751]                       else if (inherits(cond, "condition")) {
[17:42:09.751]                         if (!is.null(pattern)) {
[17:42:09.751]                           computeRestarts <- base::computeRestarts
[17:42:09.751]                           grepl <- base::grepl
[17:42:09.751]                           restarts <- computeRestarts(cond)
[17:42:09.751]                           for (restart in restarts) {
[17:42:09.751]                             name <- restart$name
[17:42:09.751]                             if (is.null(name)) 
[17:42:09.751]                               next
[17:42:09.751]                             if (!grepl(pattern, name)) 
[17:42:09.751]                               next
[17:42:09.751]                             invokeRestart(restart)
[17:42:09.751]                             muffled <- TRUE
[17:42:09.751]                             break
[17:42:09.751]                           }
[17:42:09.751]                         }
[17:42:09.751]                       }
[17:42:09.751]                       invisible(muffled)
[17:42:09.751]                     }
[17:42:09.751]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.751]                   }
[17:42:09.751]                 }
[17:42:09.751]             }
[17:42:09.751]         }))
[17:42:09.751]     }, error = function(ex) {
[17:42:09.751]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:09.751]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.751]                 ...future.rng), started = ...future.startTime, 
[17:42:09.751]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:09.751]             version = "1.8"), class = "FutureResult")
[17:42:09.751]     }, finally = {
[17:42:09.751]         if (!identical(...future.workdir, getwd())) 
[17:42:09.751]             setwd(...future.workdir)
[17:42:09.751]         {
[17:42:09.751]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:09.751]                 ...future.oldOptions$nwarnings <- NULL
[17:42:09.751]             }
[17:42:09.751]             base::options(...future.oldOptions)
[17:42:09.751]             if (.Platform$OS.type == "windows") {
[17:42:09.751]                 old_names <- names(...future.oldEnvVars)
[17:42:09.751]                 envs <- base::Sys.getenv()
[17:42:09.751]                 names <- names(envs)
[17:42:09.751]                 common <- intersect(names, old_names)
[17:42:09.751]                 added <- setdiff(names, old_names)
[17:42:09.751]                 removed <- setdiff(old_names, names)
[17:42:09.751]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:09.751]                   envs[common]]
[17:42:09.751]                 NAMES <- toupper(changed)
[17:42:09.751]                 args <- list()
[17:42:09.751]                 for (kk in seq_along(NAMES)) {
[17:42:09.751]                   name <- changed[[kk]]
[17:42:09.751]                   NAME <- NAMES[[kk]]
[17:42:09.751]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.751]                     next
[17:42:09.751]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.751]                 }
[17:42:09.751]                 NAMES <- toupper(added)
[17:42:09.751]                 for (kk in seq_along(NAMES)) {
[17:42:09.751]                   name <- added[[kk]]
[17:42:09.751]                   NAME <- NAMES[[kk]]
[17:42:09.751]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.751]                     next
[17:42:09.751]                   args[[name]] <- ""
[17:42:09.751]                 }
[17:42:09.751]                 NAMES <- toupper(removed)
[17:42:09.751]                 for (kk in seq_along(NAMES)) {
[17:42:09.751]                   name <- removed[[kk]]
[17:42:09.751]                   NAME <- NAMES[[kk]]
[17:42:09.751]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.751]                     next
[17:42:09.751]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.751]                 }
[17:42:09.751]                 if (length(args) > 0) 
[17:42:09.751]                   base::do.call(base::Sys.setenv, args = args)
[17:42:09.751]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:09.751]             }
[17:42:09.751]             else {
[17:42:09.751]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:09.751]             }
[17:42:09.751]             {
[17:42:09.751]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:09.751]                   0L) {
[17:42:09.751]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:09.751]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:09.751]                   base::options(opts)
[17:42:09.751]                 }
[17:42:09.751]                 {
[17:42:09.751]                   {
[17:42:09.751]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:09.751]                     NULL
[17:42:09.751]                   }
[17:42:09.751]                   options(future.plan = NULL)
[17:42:09.751]                   if (is.na(NA_character_)) 
[17:42:09.751]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.751]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:09.751]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:09.751]                     envir = parent.frame()) 
[17:42:09.751]                   {
[17:42:09.751]                     default_workers <- missing(workers)
[17:42:09.751]                     if (is.function(workers)) 
[17:42:09.751]                       workers <- workers()
[17:42:09.751]                     workers <- structure(as.integer(workers), 
[17:42:09.751]                       class = class(workers))
[17:42:09.751]                     stop_if_not(is.finite(workers), workers >= 
[17:42:09.751]                       1L)
[17:42:09.751]                     if ((workers == 1L && !inherits(workers, 
[17:42:09.751]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:09.751]                       if (default_workers) 
[17:42:09.751]                         supportsMulticore(warn = TRUE)
[17:42:09.751]                       return(sequential(..., envir = envir))
[17:42:09.751]                     }
[17:42:09.751]                     oopts <- options(mc.cores = workers)
[17:42:09.751]                     on.exit(options(oopts))
[17:42:09.751]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:09.751]                       envir = envir)
[17:42:09.751]                     if (!future$lazy) 
[17:42:09.751]                       future <- run(future)
[17:42:09.751]                     invisible(future)
[17:42:09.751]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:09.751]                 }
[17:42:09.751]             }
[17:42:09.751]         }
[17:42:09.751]     })
[17:42:09.751]     if (TRUE) {
[17:42:09.751]         base::sink(type = "output", split = FALSE)
[17:42:09.751]         if (TRUE) {
[17:42:09.751]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:09.751]         }
[17:42:09.751]         else {
[17:42:09.751]             ...future.result["stdout"] <- base::list(NULL)
[17:42:09.751]         }
[17:42:09.751]         base::close(...future.stdout)
[17:42:09.751]         ...future.stdout <- NULL
[17:42:09.751]     }
[17:42:09.751]     ...future.result$conditions <- ...future.conditions
[17:42:09.751]     ...future.result$finished <- base::Sys.time()
[17:42:09.751]     ...future.result
[17:42:09.751] }
[17:42:09.754] assign_globals() ...
[17:42:09.754] List of 1
[17:42:09.754]  $ ii: int 2
[17:42:09.754]  - attr(*, "where")=List of 1
[17:42:09.754]   ..$ ii:<environment: R_EmptyEnv> 
[17:42:09.754]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:09.754]  - attr(*, "resolved")= logi FALSE
[17:42:09.754]  - attr(*, "total_size")= num 56
[17:42:09.754]  - attr(*, "already-done")= logi TRUE
[17:42:09.758] - copied ‘ii’ to environment
[17:42:09.758] assign_globals() ... done
[17:42:09.758] requestCore(): workers = 2
[17:42:09.761] MulticoreFuture started
[17:42:09.761] - Launch lazy future ... done
[17:42:09.761] run() for ‘MulticoreFuture’ ... done
[17:42:09.762] plan(): Setting new future strategy stack:
[17:42:09.762] getGlobalsAndPackages() ...
[17:42:09.763] Searching for globals...
[17:42:09.762] List of future strategies:
[17:42:09.762] 1. sequential:
[17:42:09.762]    - args: function (..., envir = parent.frame())
[17:42:09.762]    - tweaked: FALSE
[17:42:09.762]    - call: NULL
[17:42:09.763] plan(): nbrOfWorkers() = 1
[17:42:09.765] plan(): Setting new future strategy stack:
[17:42:09.765] List of future strategies:
[17:42:09.765] 1. multicore:
[17:42:09.765]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:09.765]    - tweaked: FALSE
[17:42:09.765]    - call: plan(strategy)
[17:42:09.771] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[17:42:09.771] Searching for globals ... DONE
[17:42:09.772] Resolving globals: FALSE
[17:42:09.773] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:09.774] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:42:09.775] - globals: [1] ‘ii’
[17:42:09.775] 
[17:42:09.775] getGlobalsAndPackages() ... DONE
[17:42:09.776] run() for ‘Future’ ...
[17:42:09.776] - state: ‘created’
[17:42:09.776] plan(): nbrOfWorkers() = 2
[17:42:09.777] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:09.782] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:09.782] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:09.782]   - Field: ‘label’
[17:42:09.783]   - Field: ‘local’
[17:42:09.783]   - Field: ‘owner’
[17:42:09.783]   - Field: ‘envir’
[17:42:09.783]   - Field: ‘workers’
[17:42:09.783]   - Field: ‘packages’
[17:42:09.783]   - Field: ‘gc’
[17:42:09.784]   - Field: ‘job’
[17:42:09.784]   - Field: ‘conditions’
[17:42:09.784]   - Field: ‘expr’
[17:42:09.784]   - Field: ‘uuid’
[17:42:09.784]   - Field: ‘seed’
[17:42:09.784]   - Field: ‘version’
[17:42:09.785]   - Field: ‘result’
[17:42:09.785]   - Field: ‘asynchronous’
[17:42:09.785]   - Field: ‘calls’
[17:42:09.785]   - Field: ‘globals’
[17:42:09.785]   - Field: ‘stdout’
[17:42:09.785]   - Field: ‘earlySignal’
[17:42:09.785]   - Field: ‘lazy’
[17:42:09.786]   - Field: ‘state’
[17:42:09.786] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:09.786] - Launch lazy future ...
[17:42:09.786] Packages needed by the future expression (n = 0): <none>
[17:42:09.786] Packages needed by future strategies (n = 0): <none>
[17:42:09.787] {
[17:42:09.787]     {
[17:42:09.787]         {
[17:42:09.787]             ...future.startTime <- base::Sys.time()
[17:42:09.787]             {
[17:42:09.787]                 {
[17:42:09.787]                   {
[17:42:09.787]                     {
[17:42:09.787]                       base::local({
[17:42:09.787]                         has_future <- base::requireNamespace("future", 
[17:42:09.787]                           quietly = TRUE)
[17:42:09.787]                         if (has_future) {
[17:42:09.787]                           ns <- base::getNamespace("future")
[17:42:09.787]                           version <- ns[[".package"]][["version"]]
[17:42:09.787]                           if (is.null(version)) 
[17:42:09.787]                             version <- utils::packageVersion("future")
[17:42:09.787]                         }
[17:42:09.787]                         else {
[17:42:09.787]                           version <- NULL
[17:42:09.787]                         }
[17:42:09.787]                         if (!has_future || version < "1.8.0") {
[17:42:09.787]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:09.787]                             "", base::R.version$version.string), 
[17:42:09.787]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:09.787]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:09.787]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:09.787]                               "release", "version")], collapse = " "), 
[17:42:09.787]                             hostname = base::Sys.info()[["nodename"]])
[17:42:09.787]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:09.787]                             info)
[17:42:09.787]                           info <- base::paste(info, collapse = "; ")
[17:42:09.787]                           if (!has_future) {
[17:42:09.787]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:09.787]                               info)
[17:42:09.787]                           }
[17:42:09.787]                           else {
[17:42:09.787]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:09.787]                               info, version)
[17:42:09.787]                           }
[17:42:09.787]                           base::stop(msg)
[17:42:09.787]                         }
[17:42:09.787]                       })
[17:42:09.787]                     }
[17:42:09.787]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:09.787]                     base::options(mc.cores = 1L)
[17:42:09.787]                   }
[17:42:09.787]                   options(future.plan = NULL)
[17:42:09.787]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.787]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:09.787]                 }
[17:42:09.787]                 ...future.workdir <- getwd()
[17:42:09.787]             }
[17:42:09.787]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:09.787]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:09.787]         }
[17:42:09.787]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:09.787]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:09.787]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:09.787]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:09.787]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:09.787]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:09.787]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:09.787]             base::names(...future.oldOptions))
[17:42:09.787]     }
[17:42:09.787]     if (FALSE) {
[17:42:09.787]     }
[17:42:09.787]     else {
[17:42:09.787]         if (TRUE) {
[17:42:09.787]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:09.787]                 open = "w")
[17:42:09.787]         }
[17:42:09.787]         else {
[17:42:09.787]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:09.787]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:09.787]         }
[17:42:09.787]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:09.787]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:09.787]             base::sink(type = "output", split = FALSE)
[17:42:09.787]             base::close(...future.stdout)
[17:42:09.787]         }, add = TRUE)
[17:42:09.787]     }
[17:42:09.787]     ...future.frame <- base::sys.nframe()
[17:42:09.787]     ...future.conditions <- base::list()
[17:42:09.787]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:09.787]     if (FALSE) {
[17:42:09.787]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:09.787]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:09.787]     }
[17:42:09.787]     ...future.result <- base::tryCatch({
[17:42:09.787]         base::withCallingHandlers({
[17:42:09.787]             ...future.value <- base::withVisible(base::local({
[17:42:09.787]                 withCallingHandlers({
[17:42:09.787]                   {
[17:42:09.787]                     if (ii%%2 == 0) 
[17:42:09.787]                       stop("Woops!")
[17:42:09.787]                     ii
[17:42:09.787]                   }
[17:42:09.787]                 }, immediateCondition = function(cond) {
[17:42:09.787]                   save_rds <- function (object, pathname, ...) 
[17:42:09.787]                   {
[17:42:09.787]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:09.787]                     if (file_test("-f", pathname_tmp)) {
[17:42:09.787]                       fi_tmp <- file.info(pathname_tmp)
[17:42:09.787]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:09.787]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:09.787]                         fi_tmp[["mtime"]])
[17:42:09.787]                     }
[17:42:09.787]                     tryCatch({
[17:42:09.787]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:09.787]                     }, error = function(ex) {
[17:42:09.787]                       msg <- conditionMessage(ex)
[17:42:09.787]                       fi_tmp <- file.info(pathname_tmp)
[17:42:09.787]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:09.787]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:09.787]                         fi_tmp[["mtime"]], msg)
[17:42:09.787]                       ex$message <- msg
[17:42:09.787]                       stop(ex)
[17:42:09.787]                     })
[17:42:09.787]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:09.787]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:09.787]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:09.787]                       fi_tmp <- file.info(pathname_tmp)
[17:42:09.787]                       fi <- file.info(pathname)
[17:42:09.787]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:09.787]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:09.787]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:09.787]                         fi[["size"]], fi[["mtime"]])
[17:42:09.787]                       stop(msg)
[17:42:09.787]                     }
[17:42:09.787]                     invisible(pathname)
[17:42:09.787]                   }
[17:42:09.787]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:09.787]                     rootPath = tempdir()) 
[17:42:09.787]                   {
[17:42:09.787]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:09.787]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:09.787]                       tmpdir = path, fileext = ".rds")
[17:42:09.787]                     save_rds(obj, file)
[17:42:09.787]                   }
[17:42:09.787]                   saveImmediateCondition(cond, path = "/tmp/RtmpZwB2Ue/.future/immediateConditions")
[17:42:09.787]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.787]                   {
[17:42:09.787]                     inherits <- base::inherits
[17:42:09.787]                     invokeRestart <- base::invokeRestart
[17:42:09.787]                     is.null <- base::is.null
[17:42:09.787]                     muffled <- FALSE
[17:42:09.787]                     if (inherits(cond, "message")) {
[17:42:09.787]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:09.787]                       if (muffled) 
[17:42:09.787]                         invokeRestart("muffleMessage")
[17:42:09.787]                     }
[17:42:09.787]                     else if (inherits(cond, "warning")) {
[17:42:09.787]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:09.787]                       if (muffled) 
[17:42:09.787]                         invokeRestart("muffleWarning")
[17:42:09.787]                     }
[17:42:09.787]                     else if (inherits(cond, "condition")) {
[17:42:09.787]                       if (!is.null(pattern)) {
[17:42:09.787]                         computeRestarts <- base::computeRestarts
[17:42:09.787]                         grepl <- base::grepl
[17:42:09.787]                         restarts <- computeRestarts(cond)
[17:42:09.787]                         for (restart in restarts) {
[17:42:09.787]                           name <- restart$name
[17:42:09.787]                           if (is.null(name)) 
[17:42:09.787]                             next
[17:42:09.787]                           if (!grepl(pattern, name)) 
[17:42:09.787]                             next
[17:42:09.787]                           invokeRestart(restart)
[17:42:09.787]                           muffled <- TRUE
[17:42:09.787]                           break
[17:42:09.787]                         }
[17:42:09.787]                       }
[17:42:09.787]                     }
[17:42:09.787]                     invisible(muffled)
[17:42:09.787]                   }
[17:42:09.787]                   muffleCondition(cond)
[17:42:09.787]                 })
[17:42:09.787]             }))
[17:42:09.787]             future::FutureResult(value = ...future.value$value, 
[17:42:09.787]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.787]                   ...future.rng), globalenv = if (FALSE) 
[17:42:09.787]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:09.787]                     ...future.globalenv.names))
[17:42:09.787]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:09.787]         }, condition = base::local({
[17:42:09.787]             c <- base::c
[17:42:09.787]             inherits <- base::inherits
[17:42:09.787]             invokeRestart <- base::invokeRestart
[17:42:09.787]             length <- base::length
[17:42:09.787]             list <- base::list
[17:42:09.787]             seq.int <- base::seq.int
[17:42:09.787]             signalCondition <- base::signalCondition
[17:42:09.787]             sys.calls <- base::sys.calls
[17:42:09.787]             `[[` <- base::`[[`
[17:42:09.787]             `+` <- base::`+`
[17:42:09.787]             `<<-` <- base::`<<-`
[17:42:09.787]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:09.787]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:09.787]                   3L)]
[17:42:09.787]             }
[17:42:09.787]             function(cond) {
[17:42:09.787]                 is_error <- inherits(cond, "error")
[17:42:09.787]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:09.787]                   NULL)
[17:42:09.787]                 if (is_error) {
[17:42:09.787]                   sessionInformation <- function() {
[17:42:09.787]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:09.787]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:09.787]                       search = base::search(), system = base::Sys.info())
[17:42:09.787]                   }
[17:42:09.787]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.787]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:09.787]                     cond$call), session = sessionInformation(), 
[17:42:09.787]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:09.787]                   signalCondition(cond)
[17:42:09.787]                 }
[17:42:09.787]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:09.787]                 "immediateCondition"))) {
[17:42:09.787]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:09.787]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.787]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:09.787]                   if (TRUE && !signal) {
[17:42:09.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.787]                     {
[17:42:09.787]                       inherits <- base::inherits
[17:42:09.787]                       invokeRestart <- base::invokeRestart
[17:42:09.787]                       is.null <- base::is.null
[17:42:09.787]                       muffled <- FALSE
[17:42:09.787]                       if (inherits(cond, "message")) {
[17:42:09.787]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.787]                         if (muffled) 
[17:42:09.787]                           invokeRestart("muffleMessage")
[17:42:09.787]                       }
[17:42:09.787]                       else if (inherits(cond, "warning")) {
[17:42:09.787]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.787]                         if (muffled) 
[17:42:09.787]                           invokeRestart("muffleWarning")
[17:42:09.787]                       }
[17:42:09.787]                       else if (inherits(cond, "condition")) {
[17:42:09.787]                         if (!is.null(pattern)) {
[17:42:09.787]                           computeRestarts <- base::computeRestarts
[17:42:09.787]                           grepl <- base::grepl
[17:42:09.787]                           restarts <- computeRestarts(cond)
[17:42:09.787]                           for (restart in restarts) {
[17:42:09.787]                             name <- restart$name
[17:42:09.787]                             if (is.null(name)) 
[17:42:09.787]                               next
[17:42:09.787]                             if (!grepl(pattern, name)) 
[17:42:09.787]                               next
[17:42:09.787]                             invokeRestart(restart)
[17:42:09.787]                             muffled <- TRUE
[17:42:09.787]                             break
[17:42:09.787]                           }
[17:42:09.787]                         }
[17:42:09.787]                       }
[17:42:09.787]                       invisible(muffled)
[17:42:09.787]                     }
[17:42:09.787]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.787]                   }
[17:42:09.787]                 }
[17:42:09.787]                 else {
[17:42:09.787]                   if (TRUE) {
[17:42:09.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.787]                     {
[17:42:09.787]                       inherits <- base::inherits
[17:42:09.787]                       invokeRestart <- base::invokeRestart
[17:42:09.787]                       is.null <- base::is.null
[17:42:09.787]                       muffled <- FALSE
[17:42:09.787]                       if (inherits(cond, "message")) {
[17:42:09.787]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.787]                         if (muffled) 
[17:42:09.787]                           invokeRestart("muffleMessage")
[17:42:09.787]                       }
[17:42:09.787]                       else if (inherits(cond, "warning")) {
[17:42:09.787]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.787]                         if (muffled) 
[17:42:09.787]                           invokeRestart("muffleWarning")
[17:42:09.787]                       }
[17:42:09.787]                       else if (inherits(cond, "condition")) {
[17:42:09.787]                         if (!is.null(pattern)) {
[17:42:09.787]                           computeRestarts <- base::computeRestarts
[17:42:09.787]                           grepl <- base::grepl
[17:42:09.787]                           restarts <- computeRestarts(cond)
[17:42:09.787]                           for (restart in restarts) {
[17:42:09.787]                             name <- restart$name
[17:42:09.787]                             if (is.null(name)) 
[17:42:09.787]                               next
[17:42:09.787]                             if (!grepl(pattern, name)) 
[17:42:09.787]                               next
[17:42:09.787]                             invokeRestart(restart)
[17:42:09.787]                             muffled <- TRUE
[17:42:09.787]                             break
[17:42:09.787]                           }
[17:42:09.787]                         }
[17:42:09.787]                       }
[17:42:09.787]                       invisible(muffled)
[17:42:09.787]                     }
[17:42:09.787]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.787]                   }
[17:42:09.787]                 }
[17:42:09.787]             }
[17:42:09.787]         }))
[17:42:09.787]     }, error = function(ex) {
[17:42:09.787]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:09.787]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.787]                 ...future.rng), started = ...future.startTime, 
[17:42:09.787]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:09.787]             version = "1.8"), class = "FutureResult")
[17:42:09.787]     }, finally = {
[17:42:09.787]         if (!identical(...future.workdir, getwd())) 
[17:42:09.787]             setwd(...future.workdir)
[17:42:09.787]         {
[17:42:09.787]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:09.787]                 ...future.oldOptions$nwarnings <- NULL
[17:42:09.787]             }
[17:42:09.787]             base::options(...future.oldOptions)
[17:42:09.787]             if (.Platform$OS.type == "windows") {
[17:42:09.787]                 old_names <- names(...future.oldEnvVars)
[17:42:09.787]                 envs <- base::Sys.getenv()
[17:42:09.787]                 names <- names(envs)
[17:42:09.787]                 common <- intersect(names, old_names)
[17:42:09.787]                 added <- setdiff(names, old_names)
[17:42:09.787]                 removed <- setdiff(old_names, names)
[17:42:09.787]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:09.787]                   envs[common]]
[17:42:09.787]                 NAMES <- toupper(changed)
[17:42:09.787]                 args <- list()
[17:42:09.787]                 for (kk in seq_along(NAMES)) {
[17:42:09.787]                   name <- changed[[kk]]
[17:42:09.787]                   NAME <- NAMES[[kk]]
[17:42:09.787]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.787]                     next
[17:42:09.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.787]                 }
[17:42:09.787]                 NAMES <- toupper(added)
[17:42:09.787]                 for (kk in seq_along(NAMES)) {
[17:42:09.787]                   name <- added[[kk]]
[17:42:09.787]                   NAME <- NAMES[[kk]]
[17:42:09.787]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.787]                     next
[17:42:09.787]                   args[[name]] <- ""
[17:42:09.787]                 }
[17:42:09.787]                 NAMES <- toupper(removed)
[17:42:09.787]                 for (kk in seq_along(NAMES)) {
[17:42:09.787]                   name <- removed[[kk]]
[17:42:09.787]                   NAME <- NAMES[[kk]]
[17:42:09.787]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.787]                     next
[17:42:09.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.787]                 }
[17:42:09.787]                 if (length(args) > 0) 
[17:42:09.787]                   base::do.call(base::Sys.setenv, args = args)
[17:42:09.787]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:09.787]             }
[17:42:09.787]             else {
[17:42:09.787]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:09.787]             }
[17:42:09.787]             {
[17:42:09.787]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:09.787]                   0L) {
[17:42:09.787]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:09.787]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:09.787]                   base::options(opts)
[17:42:09.787]                 }
[17:42:09.787]                 {
[17:42:09.787]                   {
[17:42:09.787]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:09.787]                     NULL
[17:42:09.787]                   }
[17:42:09.787]                   options(future.plan = NULL)
[17:42:09.787]                   if (is.na(NA_character_)) 
[17:42:09.787]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.787]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:09.787]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:09.787]                     envir = parent.frame()) 
[17:42:09.787]                   {
[17:42:09.787]                     default_workers <- missing(workers)
[17:42:09.787]                     if (is.function(workers)) 
[17:42:09.787]                       workers <- workers()
[17:42:09.787]                     workers <- structure(as.integer(workers), 
[17:42:09.787]                       class = class(workers))
[17:42:09.787]                     stop_if_not(is.finite(workers), workers >= 
[17:42:09.787]                       1L)
[17:42:09.787]                     if ((workers == 1L && !inherits(workers, 
[17:42:09.787]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:09.787]                       if (default_workers) 
[17:42:09.787]                         supportsMulticore(warn = TRUE)
[17:42:09.787]                       return(sequential(..., envir = envir))
[17:42:09.787]                     }
[17:42:09.787]                     oopts <- options(mc.cores = workers)
[17:42:09.787]                     on.exit(options(oopts))
[17:42:09.787]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:09.787]                       envir = envir)
[17:42:09.787]                     if (!future$lazy) 
[17:42:09.787]                       future <- run(future)
[17:42:09.787]                     invisible(future)
[17:42:09.787]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:09.787]                 }
[17:42:09.787]             }
[17:42:09.787]         }
[17:42:09.787]     })
[17:42:09.787]     if (TRUE) {
[17:42:09.787]         base::sink(type = "output", split = FALSE)
[17:42:09.787]         if (TRUE) {
[17:42:09.787]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:09.787]         }
[17:42:09.787]         else {
[17:42:09.787]             ...future.result["stdout"] <- base::list(NULL)
[17:42:09.787]         }
[17:42:09.787]         base::close(...future.stdout)
[17:42:09.787]         ...future.stdout <- NULL
[17:42:09.787]     }
[17:42:09.787]     ...future.result$conditions <- ...future.conditions
[17:42:09.787]     ...future.result$finished <- base::Sys.time()
[17:42:09.787]     ...future.result
[17:42:09.787] }
[17:42:09.790] assign_globals() ...
[17:42:09.790] List of 1
[17:42:09.790]  $ ii: int 3
[17:42:09.790]  - attr(*, "where")=List of 1
[17:42:09.790]   ..$ ii:<environment: R_EmptyEnv> 
[17:42:09.790]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:09.790]  - attr(*, "resolved")= logi FALSE
[17:42:09.790]  - attr(*, "total_size")= num 56
[17:42:09.790]  - attr(*, "already-done")= logi TRUE
[17:42:09.794] - copied ‘ii’ to environment
[17:42:09.794] assign_globals() ... done
[17:42:09.795] requestCore(): workers = 2
[17:42:09.795] Poll #1 (0): usedCores() = 2, workers = 2
[17:42:09.811] MulticoreFuture started
[17:42:09.811] - Launch lazy future ... done
[17:42:09.812] run() for ‘MulticoreFuture’ ... done
[17:42:09.812] plan(): Setting new future strategy stack:
[17:42:09.812] List of future strategies:
[17:42:09.812] 1. sequential:
[17:42:09.812]    - args: function (..., envir = parent.frame())
[17:42:09.812]    - tweaked: FALSE
[17:42:09.812]    - call: NULL
[17:42:09.813] plan(): nbrOfWorkers() = 1
[17:42:09.815] plan(): Setting new future strategy stack:
[17:42:09.815] List of future strategies:
[17:42:09.815] 1. multicore:
[17:42:09.815]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:09.815]    - tweaked: FALSE
[17:42:09.815]    - call: plan(strategy)
[17:42:09.816] signalConditions() ...
[17:42:09.816]  - include = ‘immediateCondition’
[17:42:09.817]  - exclude = 
[17:42:09.817]  - resignal = FALSE
[17:42:09.817]  - Number of conditions: 1
[17:42:09.817] signalConditions() ... done
[17:42:09.817] signalConditions() ...
[17:42:09.818]  - include = ‘immediateCondition’
[17:42:09.818]  - exclude = 
[17:42:09.818]  - resignal = FALSE
[17:42:09.818]  - Number of conditions: 1
[17:42:09.818] signalConditions() ... done
[17:42:09.819] Future state: ‘finished’
[17:42:09.819] signalConditions() ...
[17:42:09.819]  - include = ‘condition’
[17:42:09.819]  - exclude = ‘immediateCondition’
[17:42:09.819]  - resignal = TRUE
[17:42:09.820]  - Number of conditions: 1
[17:42:09.820]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:42:09.820] signalConditions() ... done
[17:42:09.821] plan(): nbrOfWorkers() = 2
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[17:42:09.822] signalConditions() ...
[17:42:09.822]  - include = ‘immediateCondition’
[17:42:09.822]  - exclude = 
[17:42:09.822]  - resignal = FALSE
[17:42:09.822]  - Number of conditions: 1
[17:42:09.822] signalConditions() ... done
[17:42:09.822] Future state: ‘finished’
[17:42:09.823] signalConditions() ...
[17:42:09.823]  - include = ‘condition’
[17:42:09.823]  - exclude = ‘immediateCondition’
[17:42:09.823]  - resignal = TRUE
[17:42:09.823]  - Number of conditions: 1
[17:42:09.823]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:42:09.823] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[17:42:09.824] signalConditions() ...
[17:42:09.824]  - include = ‘immediateCondition’
[17:42:09.824]  - exclude = 
[17:42:09.824]  - resignal = FALSE
[17:42:09.824]  - Number of conditions: 1
[17:42:09.824] signalConditions() ... done
[17:42:09.824] Future state: ‘finished’
[17:42:09.825] signalConditions() ...
[17:42:09.825]  - include = ‘condition’
[17:42:09.825]  - exclude = ‘immediateCondition’
[17:42:09.825]  - resignal = TRUE
[17:42:09.825]  - Number of conditions: 1
[17:42:09.825]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:42:09.825] signalConditions() ... done
** Future evaluation with a poor-man's "progress bar"
[17:42:09.826] getGlobalsAndPackages() ...
[17:42:09.826] Searching for globals...
[17:42:09.832] - globals found: [4] ‘{’, ‘cat’, ‘for’, ‘:’
[17:42:09.832] Searching for globals ... DONE
[17:42:09.832] Resolving globals: FALSE
[17:42:09.832] 
[17:42:09.833] 
[17:42:09.833] getGlobalsAndPackages() ... DONE
[17:42:09.833] run() for ‘Future’ ...
[17:42:09.833] - state: ‘created’
[17:42:09.833] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:09.838] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:09.838] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:09.838]   - Field: ‘label’
[17:42:09.838]   - Field: ‘local’
[17:42:09.838]   - Field: ‘owner’
[17:42:09.839]   - Field: ‘envir’
[17:42:09.839]   - Field: ‘workers’
[17:42:09.839]   - Field: ‘packages’
[17:42:09.839]   - Field: ‘gc’
[17:42:09.839]   - Field: ‘job’
[17:42:09.839]   - Field: ‘conditions’
[17:42:09.839]   - Field: ‘expr’
[17:42:09.840]   - Field: ‘uuid’
[17:42:09.840]   - Field: ‘seed’
[17:42:09.840]   - Field: ‘version’
[17:42:09.840]   - Field: ‘result’
[17:42:09.840]   - Field: ‘asynchronous’
[17:42:09.840]   - Field: ‘calls’
[17:42:09.840]   - Field: ‘globals’
[17:42:09.840]   - Field: ‘stdout’
[17:42:09.840]   - Field: ‘earlySignal’
[17:42:09.841]   - Field: ‘lazy’
[17:42:09.841]   - Field: ‘state’
[17:42:09.841] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:09.841] - Launch lazy future ...
[17:42:09.841] Packages needed by the future expression (n = 0): <none>
[17:42:09.841] Packages needed by future strategies (n = 0): <none>
[17:42:09.842] {
[17:42:09.842]     {
[17:42:09.842]         {
[17:42:09.842]             ...future.startTime <- base::Sys.time()
[17:42:09.842]             {
[17:42:09.842]                 {
[17:42:09.842]                   {
[17:42:09.842]                     {
[17:42:09.842]                       base::local({
[17:42:09.842]                         has_future <- base::requireNamespace("future", 
[17:42:09.842]                           quietly = TRUE)
[17:42:09.842]                         if (has_future) {
[17:42:09.842]                           ns <- base::getNamespace("future")
[17:42:09.842]                           version <- ns[[".package"]][["version"]]
[17:42:09.842]                           if (is.null(version)) 
[17:42:09.842]                             version <- utils::packageVersion("future")
[17:42:09.842]                         }
[17:42:09.842]                         else {
[17:42:09.842]                           version <- NULL
[17:42:09.842]                         }
[17:42:09.842]                         if (!has_future || version < "1.8.0") {
[17:42:09.842]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:09.842]                             "", base::R.version$version.string), 
[17:42:09.842]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:09.842]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:09.842]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:09.842]                               "release", "version")], collapse = " "), 
[17:42:09.842]                             hostname = base::Sys.info()[["nodename"]])
[17:42:09.842]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:09.842]                             info)
[17:42:09.842]                           info <- base::paste(info, collapse = "; ")
[17:42:09.842]                           if (!has_future) {
[17:42:09.842]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:09.842]                               info)
[17:42:09.842]                           }
[17:42:09.842]                           else {
[17:42:09.842]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:09.842]                               info, version)
[17:42:09.842]                           }
[17:42:09.842]                           base::stop(msg)
[17:42:09.842]                         }
[17:42:09.842]                       })
[17:42:09.842]                     }
[17:42:09.842]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:09.842]                     base::options(mc.cores = 1L)
[17:42:09.842]                   }
[17:42:09.842]                   options(future.plan = NULL)
[17:42:09.842]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.842]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:09.842]                 }
[17:42:09.842]                 ...future.workdir <- getwd()
[17:42:09.842]             }
[17:42:09.842]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:09.842]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:09.842]         }
[17:42:09.842]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:09.842]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:09.842]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:09.842]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:09.842]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:09.842]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:09.842]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:09.842]             base::names(...future.oldOptions))
[17:42:09.842]     }
[17:42:09.842]     if (FALSE) {
[17:42:09.842]     }
[17:42:09.842]     else {
[17:42:09.842]         if (TRUE) {
[17:42:09.842]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:09.842]                 open = "w")
[17:42:09.842]         }
[17:42:09.842]         else {
[17:42:09.842]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:09.842]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:09.842]         }
[17:42:09.842]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:09.842]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:09.842]             base::sink(type = "output", split = FALSE)
[17:42:09.842]             base::close(...future.stdout)
[17:42:09.842]         }, add = TRUE)
[17:42:09.842]     }
[17:42:09.842]     ...future.frame <- base::sys.nframe()
[17:42:09.842]     ...future.conditions <- base::list()
[17:42:09.842]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:09.842]     if (FALSE) {
[17:42:09.842]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:09.842]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:09.842]     }
[17:42:09.842]     ...future.result <- base::tryCatch({
[17:42:09.842]         base::withCallingHandlers({
[17:42:09.842]             ...future.value <- base::withVisible(base::local({
[17:42:09.842]                 withCallingHandlers({
[17:42:09.842]                   {
[17:42:09.842]                     cat("Processing: ")
[17:42:09.842]                     for (ii in 1:10) {
[17:42:09.842]                       cat(".")
[17:42:09.842]                     }
[17:42:09.842]                     cat(" [100%]\n")
[17:42:09.842]                     4
[17:42:09.842]                   }
[17:42:09.842]                 }, immediateCondition = function(cond) {
[17:42:09.842]                   save_rds <- function (object, pathname, ...) 
[17:42:09.842]                   {
[17:42:09.842]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:09.842]                     if (file_test("-f", pathname_tmp)) {
[17:42:09.842]                       fi_tmp <- file.info(pathname_tmp)
[17:42:09.842]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:09.842]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:09.842]                         fi_tmp[["mtime"]])
[17:42:09.842]                     }
[17:42:09.842]                     tryCatch({
[17:42:09.842]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:09.842]                     }, error = function(ex) {
[17:42:09.842]                       msg <- conditionMessage(ex)
[17:42:09.842]                       fi_tmp <- file.info(pathname_tmp)
[17:42:09.842]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:09.842]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:09.842]                         fi_tmp[["mtime"]], msg)
[17:42:09.842]                       ex$message <- msg
[17:42:09.842]                       stop(ex)
[17:42:09.842]                     })
[17:42:09.842]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:09.842]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:09.842]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:09.842]                       fi_tmp <- file.info(pathname_tmp)
[17:42:09.842]                       fi <- file.info(pathname)
[17:42:09.842]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:09.842]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:09.842]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:09.842]                         fi[["size"]], fi[["mtime"]])
[17:42:09.842]                       stop(msg)
[17:42:09.842]                     }
[17:42:09.842]                     invisible(pathname)
[17:42:09.842]                   }
[17:42:09.842]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:09.842]                     rootPath = tempdir()) 
[17:42:09.842]                   {
[17:42:09.842]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:09.842]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:09.842]                       tmpdir = path, fileext = ".rds")
[17:42:09.842]                     save_rds(obj, file)
[17:42:09.842]                   }
[17:42:09.842]                   saveImmediateCondition(cond, path = "/tmp/RtmpZwB2Ue/.future/immediateConditions")
[17:42:09.842]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.842]                   {
[17:42:09.842]                     inherits <- base::inherits
[17:42:09.842]                     invokeRestart <- base::invokeRestart
[17:42:09.842]                     is.null <- base::is.null
[17:42:09.842]                     muffled <- FALSE
[17:42:09.842]                     if (inherits(cond, "message")) {
[17:42:09.842]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:09.842]                       if (muffled) 
[17:42:09.842]                         invokeRestart("muffleMessage")
[17:42:09.842]                     }
[17:42:09.842]                     else if (inherits(cond, "warning")) {
[17:42:09.842]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:09.842]                       if (muffled) 
[17:42:09.842]                         invokeRestart("muffleWarning")
[17:42:09.842]                     }
[17:42:09.842]                     else if (inherits(cond, "condition")) {
[17:42:09.842]                       if (!is.null(pattern)) {
[17:42:09.842]                         computeRestarts <- base::computeRestarts
[17:42:09.842]                         grepl <- base::grepl
[17:42:09.842]                         restarts <- computeRestarts(cond)
[17:42:09.842]                         for (restart in restarts) {
[17:42:09.842]                           name <- restart$name
[17:42:09.842]                           if (is.null(name)) 
[17:42:09.842]                             next
[17:42:09.842]                           if (!grepl(pattern, name)) 
[17:42:09.842]                             next
[17:42:09.842]                           invokeRestart(restart)
[17:42:09.842]                           muffled <- TRUE
[17:42:09.842]                           break
[17:42:09.842]                         }
[17:42:09.842]                       }
[17:42:09.842]                     }
[17:42:09.842]                     invisible(muffled)
[17:42:09.842]                   }
[17:42:09.842]                   muffleCondition(cond)
[17:42:09.842]                 })
[17:42:09.842]             }))
[17:42:09.842]             future::FutureResult(value = ...future.value$value, 
[17:42:09.842]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.842]                   ...future.rng), globalenv = if (FALSE) 
[17:42:09.842]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:09.842]                     ...future.globalenv.names))
[17:42:09.842]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:09.842]         }, condition = base::local({
[17:42:09.842]             c <- base::c
[17:42:09.842]             inherits <- base::inherits
[17:42:09.842]             invokeRestart <- base::invokeRestart
[17:42:09.842]             length <- base::length
[17:42:09.842]             list <- base::list
[17:42:09.842]             seq.int <- base::seq.int
[17:42:09.842]             signalCondition <- base::signalCondition
[17:42:09.842]             sys.calls <- base::sys.calls
[17:42:09.842]             `[[` <- base::`[[`
[17:42:09.842]             `+` <- base::`+`
[17:42:09.842]             `<<-` <- base::`<<-`
[17:42:09.842]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:09.842]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:09.842]                   3L)]
[17:42:09.842]             }
[17:42:09.842]             function(cond) {
[17:42:09.842]                 is_error <- inherits(cond, "error")
[17:42:09.842]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:09.842]                   NULL)
[17:42:09.842]                 if (is_error) {
[17:42:09.842]                   sessionInformation <- function() {
[17:42:09.842]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:09.842]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:09.842]                       search = base::search(), system = base::Sys.info())
[17:42:09.842]                   }
[17:42:09.842]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.842]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:09.842]                     cond$call), session = sessionInformation(), 
[17:42:09.842]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:09.842]                   signalCondition(cond)
[17:42:09.842]                 }
[17:42:09.842]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:09.842]                 "immediateCondition"))) {
[17:42:09.842]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:09.842]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.842]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:09.842]                   if (TRUE && !signal) {
[17:42:09.842]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.842]                     {
[17:42:09.842]                       inherits <- base::inherits
[17:42:09.842]                       invokeRestart <- base::invokeRestart
[17:42:09.842]                       is.null <- base::is.null
[17:42:09.842]                       muffled <- FALSE
[17:42:09.842]                       if (inherits(cond, "message")) {
[17:42:09.842]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.842]                         if (muffled) 
[17:42:09.842]                           invokeRestart("muffleMessage")
[17:42:09.842]                       }
[17:42:09.842]                       else if (inherits(cond, "warning")) {
[17:42:09.842]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.842]                         if (muffled) 
[17:42:09.842]                           invokeRestart("muffleWarning")
[17:42:09.842]                       }
[17:42:09.842]                       else if (inherits(cond, "condition")) {
[17:42:09.842]                         if (!is.null(pattern)) {
[17:42:09.842]                           computeRestarts <- base::computeRestarts
[17:42:09.842]                           grepl <- base::grepl
[17:42:09.842]                           restarts <- computeRestarts(cond)
[17:42:09.842]                           for (restart in restarts) {
[17:42:09.842]                             name <- restart$name
[17:42:09.842]                             if (is.null(name)) 
[17:42:09.842]                               next
[17:42:09.842]                             if (!grepl(pattern, name)) 
[17:42:09.842]                               next
[17:42:09.842]                             invokeRestart(restart)
[17:42:09.842]                             muffled <- TRUE
[17:42:09.842]                             break
[17:42:09.842]                           }
[17:42:09.842]                         }
[17:42:09.842]                       }
[17:42:09.842]                       invisible(muffled)
[17:42:09.842]                     }
[17:42:09.842]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.842]                   }
[17:42:09.842]                 }
[17:42:09.842]                 else {
[17:42:09.842]                   if (TRUE) {
[17:42:09.842]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.842]                     {
[17:42:09.842]                       inherits <- base::inherits
[17:42:09.842]                       invokeRestart <- base::invokeRestart
[17:42:09.842]                       is.null <- base::is.null
[17:42:09.842]                       muffled <- FALSE
[17:42:09.842]                       if (inherits(cond, "message")) {
[17:42:09.842]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.842]                         if (muffled) 
[17:42:09.842]                           invokeRestart("muffleMessage")
[17:42:09.842]                       }
[17:42:09.842]                       else if (inherits(cond, "warning")) {
[17:42:09.842]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.842]                         if (muffled) 
[17:42:09.842]                           invokeRestart("muffleWarning")
[17:42:09.842]                       }
[17:42:09.842]                       else if (inherits(cond, "condition")) {
[17:42:09.842]                         if (!is.null(pattern)) {
[17:42:09.842]                           computeRestarts <- base::computeRestarts
[17:42:09.842]                           grepl <- base::grepl
[17:42:09.842]                           restarts <- computeRestarts(cond)
[17:42:09.842]                           for (restart in restarts) {
[17:42:09.842]                             name <- restart$name
[17:42:09.842]                             if (is.null(name)) 
[17:42:09.842]                               next
[17:42:09.842]                             if (!grepl(pattern, name)) 
[17:42:09.842]                               next
[17:42:09.842]                             invokeRestart(restart)
[17:42:09.842]                             muffled <- TRUE
[17:42:09.842]                             break
[17:42:09.842]                           }
[17:42:09.842]                         }
[17:42:09.842]                       }
[17:42:09.842]                       invisible(muffled)
[17:42:09.842]                     }
[17:42:09.842]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.842]                   }
[17:42:09.842]                 }
[17:42:09.842]             }
[17:42:09.842]         }))
[17:42:09.842]     }, error = function(ex) {
[17:42:09.842]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:09.842]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.842]                 ...future.rng), started = ...future.startTime, 
[17:42:09.842]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:09.842]             version = "1.8"), class = "FutureResult")
[17:42:09.842]     }, finally = {
[17:42:09.842]         if (!identical(...future.workdir, getwd())) 
[17:42:09.842]             setwd(...future.workdir)
[17:42:09.842]         {
[17:42:09.842]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:09.842]                 ...future.oldOptions$nwarnings <- NULL
[17:42:09.842]             }
[17:42:09.842]             base::options(...future.oldOptions)
[17:42:09.842]             if (.Platform$OS.type == "windows") {
[17:42:09.842]                 old_names <- names(...future.oldEnvVars)
[17:42:09.842]                 envs <- base::Sys.getenv()
[17:42:09.842]                 names <- names(envs)
[17:42:09.842]                 common <- intersect(names, old_names)
[17:42:09.842]                 added <- setdiff(names, old_names)
[17:42:09.842]                 removed <- setdiff(old_names, names)
[17:42:09.842]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:09.842]                   envs[common]]
[17:42:09.842]                 NAMES <- toupper(changed)
[17:42:09.842]                 args <- list()
[17:42:09.842]                 for (kk in seq_along(NAMES)) {
[17:42:09.842]                   name <- changed[[kk]]
[17:42:09.842]                   NAME <- NAMES[[kk]]
[17:42:09.842]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.842]                     next
[17:42:09.842]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.842]                 }
[17:42:09.842]                 NAMES <- toupper(added)
[17:42:09.842]                 for (kk in seq_along(NAMES)) {
[17:42:09.842]                   name <- added[[kk]]
[17:42:09.842]                   NAME <- NAMES[[kk]]
[17:42:09.842]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.842]                     next
[17:42:09.842]                   args[[name]] <- ""
[17:42:09.842]                 }
[17:42:09.842]                 NAMES <- toupper(removed)
[17:42:09.842]                 for (kk in seq_along(NAMES)) {
[17:42:09.842]                   name <- removed[[kk]]
[17:42:09.842]                   NAME <- NAMES[[kk]]
[17:42:09.842]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.842]                     next
[17:42:09.842]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.842]                 }
[17:42:09.842]                 if (length(args) > 0) 
[17:42:09.842]                   base::do.call(base::Sys.setenv, args = args)
[17:42:09.842]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:09.842]             }
[17:42:09.842]             else {
[17:42:09.842]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:09.842]             }
[17:42:09.842]             {
[17:42:09.842]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:09.842]                   0L) {
[17:42:09.842]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:09.842]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:09.842]                   base::options(opts)
[17:42:09.842]                 }
[17:42:09.842]                 {
[17:42:09.842]                   {
[17:42:09.842]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:09.842]                     NULL
[17:42:09.842]                   }
[17:42:09.842]                   options(future.plan = NULL)
[17:42:09.842]                   if (is.na(NA_character_)) 
[17:42:09.842]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.842]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:09.842]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:09.842]                     envir = parent.frame()) 
[17:42:09.842]                   {
[17:42:09.842]                     default_workers <- missing(workers)
[17:42:09.842]                     if (is.function(workers)) 
[17:42:09.842]                       workers <- workers()
[17:42:09.842]                     workers <- structure(as.integer(workers), 
[17:42:09.842]                       class = class(workers))
[17:42:09.842]                     stop_if_not(is.finite(workers), workers >= 
[17:42:09.842]                       1L)
[17:42:09.842]                     if ((workers == 1L && !inherits(workers, 
[17:42:09.842]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:09.842]                       if (default_workers) 
[17:42:09.842]                         supportsMulticore(warn = TRUE)
[17:42:09.842]                       return(sequential(..., envir = envir))
[17:42:09.842]                     }
[17:42:09.842]                     oopts <- options(mc.cores = workers)
[17:42:09.842]                     on.exit(options(oopts))
[17:42:09.842]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:09.842]                       envir = envir)
[17:42:09.842]                     if (!future$lazy) 
[17:42:09.842]                       future <- run(future)
[17:42:09.842]                     invisible(future)
[17:42:09.842]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:09.842]                 }
[17:42:09.842]             }
[17:42:09.842]         }
[17:42:09.842]     })
[17:42:09.842]     if (TRUE) {
[17:42:09.842]         base::sink(type = "output", split = FALSE)
[17:42:09.842]         if (TRUE) {
[17:42:09.842]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:09.842]         }
[17:42:09.842]         else {
[17:42:09.842]             ...future.result["stdout"] <- base::list(NULL)
[17:42:09.842]         }
[17:42:09.842]         base::close(...future.stdout)
[17:42:09.842]         ...future.stdout <- NULL
[17:42:09.842]     }
[17:42:09.842]     ...future.result$conditions <- ...future.conditions
[17:42:09.842]     ...future.result$finished <- base::Sys.time()
[17:42:09.842]     ...future.result
[17:42:09.842] }
[17:42:09.845] requestCore(): workers = 2
[17:42:09.847] MulticoreFuture started
[17:42:09.847] - Launch lazy future ... done
[17:42:09.847] run() for ‘MulticoreFuture’ ... done
** Collecting results
v1 = 1
v2 = 2
Warning in sprintf(...) : restarting interrupted promise evaluation
[17:42:09.848] plan(): Setting new future strategy stack:
[17:42:09.848] signalConditions() ...
[17:42:09.848]  - include = ‘immediateCondition’
[17:42:09.849]  - exclude = 
[17:42:09.848] List of future strategies:
[17:42:09.848] 1. sequential:
[17:42:09.848]    - args: function (..., envir = parent.frame())
[17:42:09.848]    - tweaked: FALSE
[17:42:09.848]    - call: NULL
[17:42:09.849]  - resignal = FALSE
[17:42:09.849]  - Number of conditions: 1
[17:42:09.849] plan(): nbrOfWorkers() = 1
[17:42:09.849] signalConditions() ... done
[17:42:09.849] Future state: ‘finished’
[17:42:09.850] signalConditions() ...
[17:42:09.850]  - include = ‘condition’
[17:42:09.850]  - exclude = ‘immediateCondition’
[17:42:09.850]  - resignal = TRUE
[17:42:09.850]  - Number of conditions: 1
[17:42:09.850]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:42:09.851] signalConditions() ... done
v3: <simpleError> (as expect)
[17:42:09.851] plan(): Setting new future strategy stack:
[17:42:09.851] List of future strategies:
[17:42:09.851] 1. multicore:
[17:42:09.851]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:09.851]    - tweaked: FALSE
[17:42:09.851]    - call: plan(strategy)
[17:42:09.856] plan(): nbrOfWorkers() = 2
Processing: .......... [100%]
v4 = 4
** Left-to-right and right-to-left future assignments
[17:42:09.858] getGlobalsAndPackages() ...
[17:42:09.858] Searching for globals...
[17:42:09.858] 
[17:42:09.858] Searching for globals ... DONE
[17:42:09.859] - globals: [0] <none>
[17:42:09.859] getGlobalsAndPackages() ... DONE
[17:42:09.859] run() for ‘Future’ ...
[17:42:09.859] - state: ‘created’
[17:42:09.859] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:09.863] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:09.864] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:09.864]   - Field: ‘label’
[17:42:09.864]   - Field: ‘local’
[17:42:09.864]   - Field: ‘owner’
[17:42:09.864]   - Field: ‘envir’
[17:42:09.864]   - Field: ‘workers’
[17:42:09.864]   - Field: ‘packages’
[17:42:09.864]   - Field: ‘gc’
[17:42:09.864]   - Field: ‘job’
[17:42:09.865]   - Field: ‘conditions’
[17:42:09.865]   - Field: ‘expr’
[17:42:09.865]   - Field: ‘uuid’
[17:42:09.865]   - Field: ‘seed’
[17:42:09.865]   - Field: ‘version’
[17:42:09.865]   - Field: ‘result’
[17:42:09.865]   - Field: ‘asynchronous’
[17:42:09.865]   - Field: ‘calls’
[17:42:09.865]   - Field: ‘globals’
[17:42:09.866]   - Field: ‘stdout’
[17:42:09.866]   - Field: ‘earlySignal’
[17:42:09.866]   - Field: ‘lazy’
[17:42:09.866]   - Field: ‘state’
[17:42:09.866] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:09.866] - Launch lazy future ...
[17:42:09.866] Packages needed by the future expression (n = 0): <none>
[17:42:09.867] Packages needed by future strategies (n = 0): <none>
[17:42:09.867] {
[17:42:09.867]     {
[17:42:09.867]         {
[17:42:09.867]             ...future.startTime <- base::Sys.time()
[17:42:09.867]             {
[17:42:09.867]                 {
[17:42:09.867]                   {
[17:42:09.867]                     {
[17:42:09.867]                       base::local({
[17:42:09.867]                         has_future <- base::requireNamespace("future", 
[17:42:09.867]                           quietly = TRUE)
[17:42:09.867]                         if (has_future) {
[17:42:09.867]                           ns <- base::getNamespace("future")
[17:42:09.867]                           version <- ns[[".package"]][["version"]]
[17:42:09.867]                           if (is.null(version)) 
[17:42:09.867]                             version <- utils::packageVersion("future")
[17:42:09.867]                         }
[17:42:09.867]                         else {
[17:42:09.867]                           version <- NULL
[17:42:09.867]                         }
[17:42:09.867]                         if (!has_future || version < "1.8.0") {
[17:42:09.867]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:09.867]                             "", base::R.version$version.string), 
[17:42:09.867]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:09.867]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:09.867]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:09.867]                               "release", "version")], collapse = " "), 
[17:42:09.867]                             hostname = base::Sys.info()[["nodename"]])
[17:42:09.867]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:09.867]                             info)
[17:42:09.867]                           info <- base::paste(info, collapse = "; ")
[17:42:09.867]                           if (!has_future) {
[17:42:09.867]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:09.867]                               info)
[17:42:09.867]                           }
[17:42:09.867]                           else {
[17:42:09.867]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:09.867]                               info, version)
[17:42:09.867]                           }
[17:42:09.867]                           base::stop(msg)
[17:42:09.867]                         }
[17:42:09.867]                       })
[17:42:09.867]                     }
[17:42:09.867]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:09.867]                     base::options(mc.cores = 1L)
[17:42:09.867]                   }
[17:42:09.867]                   options(future.plan = NULL)
[17:42:09.867]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.867]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:09.867]                 }
[17:42:09.867]                 ...future.workdir <- getwd()
[17:42:09.867]             }
[17:42:09.867]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:09.867]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:09.867]         }
[17:42:09.867]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:09.867]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:09.867]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:09.867]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:09.867]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:09.867]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:09.867]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:09.867]             base::names(...future.oldOptions))
[17:42:09.867]     }
[17:42:09.867]     if (FALSE) {
[17:42:09.867]     }
[17:42:09.867]     else {
[17:42:09.867]         if (TRUE) {
[17:42:09.867]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:09.867]                 open = "w")
[17:42:09.867]         }
[17:42:09.867]         else {
[17:42:09.867]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:09.867]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:09.867]         }
[17:42:09.867]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:09.867]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:09.867]             base::sink(type = "output", split = FALSE)
[17:42:09.867]             base::close(...future.stdout)
[17:42:09.867]         }, add = TRUE)
[17:42:09.867]     }
[17:42:09.867]     ...future.frame <- base::sys.nframe()
[17:42:09.867]     ...future.conditions <- base::list()
[17:42:09.867]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:09.867]     if (FALSE) {
[17:42:09.867]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:09.867]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:09.867]     }
[17:42:09.867]     ...future.result <- base::tryCatch({
[17:42:09.867]         base::withCallingHandlers({
[17:42:09.867]             ...future.value <- base::withVisible(base::local({
[17:42:09.867]                 withCallingHandlers({
[17:42:09.867]                   1
[17:42:09.867]                 }, immediateCondition = function(cond) {
[17:42:09.867]                   save_rds <- function (object, pathname, ...) 
[17:42:09.867]                   {
[17:42:09.867]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:09.867]                     if (file_test("-f", pathname_tmp)) {
[17:42:09.867]                       fi_tmp <- file.info(pathname_tmp)
[17:42:09.867]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:09.867]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:09.867]                         fi_tmp[["mtime"]])
[17:42:09.867]                     }
[17:42:09.867]                     tryCatch({
[17:42:09.867]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:09.867]                     }, error = function(ex) {
[17:42:09.867]                       msg <- conditionMessage(ex)
[17:42:09.867]                       fi_tmp <- file.info(pathname_tmp)
[17:42:09.867]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:09.867]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:09.867]                         fi_tmp[["mtime"]], msg)
[17:42:09.867]                       ex$message <- msg
[17:42:09.867]                       stop(ex)
[17:42:09.867]                     })
[17:42:09.867]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:09.867]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:09.867]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:09.867]                       fi_tmp <- file.info(pathname_tmp)
[17:42:09.867]                       fi <- file.info(pathname)
[17:42:09.867]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:09.867]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:09.867]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:09.867]                         fi[["size"]], fi[["mtime"]])
[17:42:09.867]                       stop(msg)
[17:42:09.867]                     }
[17:42:09.867]                     invisible(pathname)
[17:42:09.867]                   }
[17:42:09.867]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:09.867]                     rootPath = tempdir()) 
[17:42:09.867]                   {
[17:42:09.867]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:09.867]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:09.867]                       tmpdir = path, fileext = ".rds")
[17:42:09.867]                     save_rds(obj, file)
[17:42:09.867]                   }
[17:42:09.867]                   saveImmediateCondition(cond, path = "/tmp/RtmpZwB2Ue/.future/immediateConditions")
[17:42:09.867]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.867]                   {
[17:42:09.867]                     inherits <- base::inherits
[17:42:09.867]                     invokeRestart <- base::invokeRestart
[17:42:09.867]                     is.null <- base::is.null
[17:42:09.867]                     muffled <- FALSE
[17:42:09.867]                     if (inherits(cond, "message")) {
[17:42:09.867]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:09.867]                       if (muffled) 
[17:42:09.867]                         invokeRestart("muffleMessage")
[17:42:09.867]                     }
[17:42:09.867]                     else if (inherits(cond, "warning")) {
[17:42:09.867]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:09.867]                       if (muffled) 
[17:42:09.867]                         invokeRestart("muffleWarning")
[17:42:09.867]                     }
[17:42:09.867]                     else if (inherits(cond, "condition")) {
[17:42:09.867]                       if (!is.null(pattern)) {
[17:42:09.867]                         computeRestarts <- base::computeRestarts
[17:42:09.867]                         grepl <- base::grepl
[17:42:09.867]                         restarts <- computeRestarts(cond)
[17:42:09.867]                         for (restart in restarts) {
[17:42:09.867]                           name <- restart$name
[17:42:09.867]                           if (is.null(name)) 
[17:42:09.867]                             next
[17:42:09.867]                           if (!grepl(pattern, name)) 
[17:42:09.867]                             next
[17:42:09.867]                           invokeRestart(restart)
[17:42:09.867]                           muffled <- TRUE
[17:42:09.867]                           break
[17:42:09.867]                         }
[17:42:09.867]                       }
[17:42:09.867]                     }
[17:42:09.867]                     invisible(muffled)
[17:42:09.867]                   }
[17:42:09.867]                   muffleCondition(cond)
[17:42:09.867]                 })
[17:42:09.867]             }))
[17:42:09.867]             future::FutureResult(value = ...future.value$value, 
[17:42:09.867]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.867]                   ...future.rng), globalenv = if (FALSE) 
[17:42:09.867]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:09.867]                     ...future.globalenv.names))
[17:42:09.867]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:09.867]         }, condition = base::local({
[17:42:09.867]             c <- base::c
[17:42:09.867]             inherits <- base::inherits
[17:42:09.867]             invokeRestart <- base::invokeRestart
[17:42:09.867]             length <- base::length
[17:42:09.867]             list <- base::list
[17:42:09.867]             seq.int <- base::seq.int
[17:42:09.867]             signalCondition <- base::signalCondition
[17:42:09.867]             sys.calls <- base::sys.calls
[17:42:09.867]             `[[` <- base::`[[`
[17:42:09.867]             `+` <- base::`+`
[17:42:09.867]             `<<-` <- base::`<<-`
[17:42:09.867]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:09.867]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:09.867]                   3L)]
[17:42:09.867]             }
[17:42:09.867]             function(cond) {
[17:42:09.867]                 is_error <- inherits(cond, "error")
[17:42:09.867]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:09.867]                   NULL)
[17:42:09.867]                 if (is_error) {
[17:42:09.867]                   sessionInformation <- function() {
[17:42:09.867]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:09.867]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:09.867]                       search = base::search(), system = base::Sys.info())
[17:42:09.867]                   }
[17:42:09.867]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.867]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:09.867]                     cond$call), session = sessionInformation(), 
[17:42:09.867]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:09.867]                   signalCondition(cond)
[17:42:09.867]                 }
[17:42:09.867]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:09.867]                 "immediateCondition"))) {
[17:42:09.867]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:09.867]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.867]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:09.867]                   if (TRUE && !signal) {
[17:42:09.867]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.867]                     {
[17:42:09.867]                       inherits <- base::inherits
[17:42:09.867]                       invokeRestart <- base::invokeRestart
[17:42:09.867]                       is.null <- base::is.null
[17:42:09.867]                       muffled <- FALSE
[17:42:09.867]                       if (inherits(cond, "message")) {
[17:42:09.867]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.867]                         if (muffled) 
[17:42:09.867]                           invokeRestart("muffleMessage")
[17:42:09.867]                       }
[17:42:09.867]                       else if (inherits(cond, "warning")) {
[17:42:09.867]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.867]                         if (muffled) 
[17:42:09.867]                           invokeRestart("muffleWarning")
[17:42:09.867]                       }
[17:42:09.867]                       else if (inherits(cond, "condition")) {
[17:42:09.867]                         if (!is.null(pattern)) {
[17:42:09.867]                           computeRestarts <- base::computeRestarts
[17:42:09.867]                           grepl <- base::grepl
[17:42:09.867]                           restarts <- computeRestarts(cond)
[17:42:09.867]                           for (restart in restarts) {
[17:42:09.867]                             name <- restart$name
[17:42:09.867]                             if (is.null(name)) 
[17:42:09.867]                               next
[17:42:09.867]                             if (!grepl(pattern, name)) 
[17:42:09.867]                               next
[17:42:09.867]                             invokeRestart(restart)
[17:42:09.867]                             muffled <- TRUE
[17:42:09.867]                             break
[17:42:09.867]                           }
[17:42:09.867]                         }
[17:42:09.867]                       }
[17:42:09.867]                       invisible(muffled)
[17:42:09.867]                     }
[17:42:09.867]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.867]                   }
[17:42:09.867]                 }
[17:42:09.867]                 else {
[17:42:09.867]                   if (TRUE) {
[17:42:09.867]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.867]                     {
[17:42:09.867]                       inherits <- base::inherits
[17:42:09.867]                       invokeRestart <- base::invokeRestart
[17:42:09.867]                       is.null <- base::is.null
[17:42:09.867]                       muffled <- FALSE
[17:42:09.867]                       if (inherits(cond, "message")) {
[17:42:09.867]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.867]                         if (muffled) 
[17:42:09.867]                           invokeRestart("muffleMessage")
[17:42:09.867]                       }
[17:42:09.867]                       else if (inherits(cond, "warning")) {
[17:42:09.867]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.867]                         if (muffled) 
[17:42:09.867]                           invokeRestart("muffleWarning")
[17:42:09.867]                       }
[17:42:09.867]                       else if (inherits(cond, "condition")) {
[17:42:09.867]                         if (!is.null(pattern)) {
[17:42:09.867]                           computeRestarts <- base::computeRestarts
[17:42:09.867]                           grepl <- base::grepl
[17:42:09.867]                           restarts <- computeRestarts(cond)
[17:42:09.867]                           for (restart in restarts) {
[17:42:09.867]                             name <- restart$name
[17:42:09.867]                             if (is.null(name)) 
[17:42:09.867]                               next
[17:42:09.867]                             if (!grepl(pattern, name)) 
[17:42:09.867]                               next
[17:42:09.867]                             invokeRestart(restart)
[17:42:09.867]                             muffled <- TRUE
[17:42:09.867]                             break
[17:42:09.867]                           }
[17:42:09.867]                         }
[17:42:09.867]                       }
[17:42:09.867]                       invisible(muffled)
[17:42:09.867]                     }
[17:42:09.867]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.867]                   }
[17:42:09.867]                 }
[17:42:09.867]             }
[17:42:09.867]         }))
[17:42:09.867]     }, error = function(ex) {
[17:42:09.867]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:09.867]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.867]                 ...future.rng), started = ...future.startTime, 
[17:42:09.867]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:09.867]             version = "1.8"), class = "FutureResult")
[17:42:09.867]     }, finally = {
[17:42:09.867]         if (!identical(...future.workdir, getwd())) 
[17:42:09.867]             setwd(...future.workdir)
[17:42:09.867]         {
[17:42:09.867]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:09.867]                 ...future.oldOptions$nwarnings <- NULL
[17:42:09.867]             }
[17:42:09.867]             base::options(...future.oldOptions)
[17:42:09.867]             if (.Platform$OS.type == "windows") {
[17:42:09.867]                 old_names <- names(...future.oldEnvVars)
[17:42:09.867]                 envs <- base::Sys.getenv()
[17:42:09.867]                 names <- names(envs)
[17:42:09.867]                 common <- intersect(names, old_names)
[17:42:09.867]                 added <- setdiff(names, old_names)
[17:42:09.867]                 removed <- setdiff(old_names, names)
[17:42:09.867]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:09.867]                   envs[common]]
[17:42:09.867]                 NAMES <- toupper(changed)
[17:42:09.867]                 args <- list()
[17:42:09.867]                 for (kk in seq_along(NAMES)) {
[17:42:09.867]                   name <- changed[[kk]]
[17:42:09.867]                   NAME <- NAMES[[kk]]
[17:42:09.867]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.867]                     next
[17:42:09.867]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.867]                 }
[17:42:09.867]                 NAMES <- toupper(added)
[17:42:09.867]                 for (kk in seq_along(NAMES)) {
[17:42:09.867]                   name <- added[[kk]]
[17:42:09.867]                   NAME <- NAMES[[kk]]
[17:42:09.867]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.867]                     next
[17:42:09.867]                   args[[name]] <- ""
[17:42:09.867]                 }
[17:42:09.867]                 NAMES <- toupper(removed)
[17:42:09.867]                 for (kk in seq_along(NAMES)) {
[17:42:09.867]                   name <- removed[[kk]]
[17:42:09.867]                   NAME <- NAMES[[kk]]
[17:42:09.867]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.867]                     next
[17:42:09.867]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.867]                 }
[17:42:09.867]                 if (length(args) > 0) 
[17:42:09.867]                   base::do.call(base::Sys.setenv, args = args)
[17:42:09.867]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:09.867]             }
[17:42:09.867]             else {
[17:42:09.867]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:09.867]             }
[17:42:09.867]             {
[17:42:09.867]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:09.867]                   0L) {
[17:42:09.867]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:09.867]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:09.867]                   base::options(opts)
[17:42:09.867]                 }
[17:42:09.867]                 {
[17:42:09.867]                   {
[17:42:09.867]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:09.867]                     NULL
[17:42:09.867]                   }
[17:42:09.867]                   options(future.plan = NULL)
[17:42:09.867]                   if (is.na(NA_character_)) 
[17:42:09.867]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.867]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:09.867]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:09.867]                     envir = parent.frame()) 
[17:42:09.867]                   {
[17:42:09.867]                     default_workers <- missing(workers)
[17:42:09.867]                     if (is.function(workers)) 
[17:42:09.867]                       workers <- workers()
[17:42:09.867]                     workers <- structure(as.integer(workers), 
[17:42:09.867]                       class = class(workers))
[17:42:09.867]                     stop_if_not(is.finite(workers), workers >= 
[17:42:09.867]                       1L)
[17:42:09.867]                     if ((workers == 1L && !inherits(workers, 
[17:42:09.867]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:09.867]                       if (default_workers) 
[17:42:09.867]                         supportsMulticore(warn = TRUE)
[17:42:09.867]                       return(sequential(..., envir = envir))
[17:42:09.867]                     }
[17:42:09.867]                     oopts <- options(mc.cores = workers)
[17:42:09.867]                     on.exit(options(oopts))
[17:42:09.867]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:09.867]                       envir = envir)
[17:42:09.867]                     if (!future$lazy) 
[17:42:09.867]                       future <- run(future)
[17:42:09.867]                     invisible(future)
[17:42:09.867]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:09.867]                 }
[17:42:09.867]             }
[17:42:09.867]         }
[17:42:09.867]     })
[17:42:09.867]     if (TRUE) {
[17:42:09.867]         base::sink(type = "output", split = FALSE)
[17:42:09.867]         if (TRUE) {
[17:42:09.867]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:09.867]         }
[17:42:09.867]         else {
[17:42:09.867]             ...future.result["stdout"] <- base::list(NULL)
[17:42:09.867]         }
[17:42:09.867]         base::close(...future.stdout)
[17:42:09.867]         ...future.stdout <- NULL
[17:42:09.867]     }
[17:42:09.867]     ...future.result$conditions <- ...future.conditions
[17:42:09.867]     ...future.result$finished <- base::Sys.time()
[17:42:09.867]     ...future.result
[17:42:09.867] }
[17:42:09.870] requestCore(): workers = 2
[17:42:09.872] MulticoreFuture started
[17:42:09.872] - Launch lazy future ... done
[17:42:09.872] run() for ‘MulticoreFuture’ ... done
[17:42:09.873] plan(): Setting new future strategy stack:
[17:42:09.873] List of future strategies:
[17:42:09.873] 1. sequential:
[17:42:09.873]    - args: function (..., envir = parent.frame())
[17:42:09.873]    - tweaked: FALSE
[17:42:09.873]    - call: NULL
[17:42:09.874] plan(): nbrOfWorkers() = 1
[17:42:09.876] plan(): Setting new future strategy stack:
[17:42:09.876] List of future strategies:
[17:42:09.876] 1. multicore:
[17:42:09.876]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:09.876]    - tweaked: FALSE
[17:42:09.876]    - call: plan(strategy)
[17:42:09.881] plan(): nbrOfWorkers() = 2
c = 1
[17:42:09.882] getGlobalsAndPackages() ...
[17:42:09.882] Searching for globals...
[17:42:09.883] 
[17:42:09.883] Searching for globals ... DONE
[17:42:09.883] - globals: [0] <none>
[17:42:09.884] getGlobalsAndPackages() ... DONE
[17:42:09.884] run() for ‘Future’ ...
[17:42:09.884] - state: ‘created’
[17:42:09.884] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:09.891] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:09.891] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:09.891]   - Field: ‘label’
[17:42:09.891]   - Field: ‘local’
[17:42:09.892]   - Field: ‘owner’
[17:42:09.892]   - Field: ‘envir’
[17:42:09.892]   - Field: ‘workers’
[17:42:09.892]   - Field: ‘packages’
[17:42:09.892]   - Field: ‘gc’
[17:42:09.892]   - Field: ‘job’
[17:42:09.893]   - Field: ‘conditions’
[17:42:09.893]   - Field: ‘expr’
[17:42:09.893]   - Field: ‘uuid’
[17:42:09.893]   - Field: ‘seed’
[17:42:09.893]   - Field: ‘version’
[17:42:09.893]   - Field: ‘result’
[17:42:09.893]   - Field: ‘asynchronous’
[17:42:09.893]   - Field: ‘calls’
[17:42:09.894]   - Field: ‘globals’
[17:42:09.894]   - Field: ‘stdout’
[17:42:09.894]   - Field: ‘earlySignal’
[17:42:09.894]   - Field: ‘lazy’
[17:42:09.894]   - Field: ‘state’
[17:42:09.894] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:09.894] - Launch lazy future ...
[17:42:09.895] Packages needed by the future expression (n = 0): <none>
[17:42:09.895] Packages needed by future strategies (n = 0): <none>
[17:42:09.896] {
[17:42:09.896]     {
[17:42:09.896]         {
[17:42:09.896]             ...future.startTime <- base::Sys.time()
[17:42:09.896]             {
[17:42:09.896]                 {
[17:42:09.896]                   {
[17:42:09.896]                     {
[17:42:09.896]                       base::local({
[17:42:09.896]                         has_future <- base::requireNamespace("future", 
[17:42:09.896]                           quietly = TRUE)
[17:42:09.896]                         if (has_future) {
[17:42:09.896]                           ns <- base::getNamespace("future")
[17:42:09.896]                           version <- ns[[".package"]][["version"]]
[17:42:09.896]                           if (is.null(version)) 
[17:42:09.896]                             version <- utils::packageVersion("future")
[17:42:09.896]                         }
[17:42:09.896]                         else {
[17:42:09.896]                           version <- NULL
[17:42:09.896]                         }
[17:42:09.896]                         if (!has_future || version < "1.8.0") {
[17:42:09.896]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:09.896]                             "", base::R.version$version.string), 
[17:42:09.896]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:09.896]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:09.896]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:09.896]                               "release", "version")], collapse = " "), 
[17:42:09.896]                             hostname = base::Sys.info()[["nodename"]])
[17:42:09.896]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:09.896]                             info)
[17:42:09.896]                           info <- base::paste(info, collapse = "; ")
[17:42:09.896]                           if (!has_future) {
[17:42:09.896]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:09.896]                               info)
[17:42:09.896]                           }
[17:42:09.896]                           else {
[17:42:09.896]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:09.896]                               info, version)
[17:42:09.896]                           }
[17:42:09.896]                           base::stop(msg)
[17:42:09.896]                         }
[17:42:09.896]                       })
[17:42:09.896]                     }
[17:42:09.896]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:09.896]                     base::options(mc.cores = 1L)
[17:42:09.896]                   }
[17:42:09.896]                   options(future.plan = NULL)
[17:42:09.896]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.896]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:09.896]                 }
[17:42:09.896]                 ...future.workdir <- getwd()
[17:42:09.896]             }
[17:42:09.896]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:09.896]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:09.896]         }
[17:42:09.896]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:09.896]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:09.896]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:09.896]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:09.896]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:09.896]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:09.896]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:09.896]             base::names(...future.oldOptions))
[17:42:09.896]     }
[17:42:09.896]     if (FALSE) {
[17:42:09.896]     }
[17:42:09.896]     else {
[17:42:09.896]         if (TRUE) {
[17:42:09.896]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:09.896]                 open = "w")
[17:42:09.896]         }
[17:42:09.896]         else {
[17:42:09.896]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:09.896]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:09.896]         }
[17:42:09.896]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:09.896]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:09.896]             base::sink(type = "output", split = FALSE)
[17:42:09.896]             base::close(...future.stdout)
[17:42:09.896]         }, add = TRUE)
[17:42:09.896]     }
[17:42:09.896]     ...future.frame <- base::sys.nframe()
[17:42:09.896]     ...future.conditions <- base::list()
[17:42:09.896]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:09.896]     if (FALSE) {
[17:42:09.896]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:09.896]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:09.896]     }
[17:42:09.896]     ...future.result <- base::tryCatch({
[17:42:09.896]         base::withCallingHandlers({
[17:42:09.896]             ...future.value <- base::withVisible(base::local({
[17:42:09.896]                 withCallingHandlers({
[17:42:09.896]                   1
[17:42:09.896]                 }, immediateCondition = function(cond) {
[17:42:09.896]                   save_rds <- function (object, pathname, ...) 
[17:42:09.896]                   {
[17:42:09.896]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:09.896]                     if (file_test("-f", pathname_tmp)) {
[17:42:09.896]                       fi_tmp <- file.info(pathname_tmp)
[17:42:09.896]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:09.896]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:09.896]                         fi_tmp[["mtime"]])
[17:42:09.896]                     }
[17:42:09.896]                     tryCatch({
[17:42:09.896]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:09.896]                     }, error = function(ex) {
[17:42:09.896]                       msg <- conditionMessage(ex)
[17:42:09.896]                       fi_tmp <- file.info(pathname_tmp)
[17:42:09.896]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:09.896]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:09.896]                         fi_tmp[["mtime"]], msg)
[17:42:09.896]                       ex$message <- msg
[17:42:09.896]                       stop(ex)
[17:42:09.896]                     })
[17:42:09.896]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:09.896]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:09.896]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:09.896]                       fi_tmp <- file.info(pathname_tmp)
[17:42:09.896]                       fi <- file.info(pathname)
[17:42:09.896]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:09.896]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:09.896]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:09.896]                         fi[["size"]], fi[["mtime"]])
[17:42:09.896]                       stop(msg)
[17:42:09.896]                     }
[17:42:09.896]                     invisible(pathname)
[17:42:09.896]                   }
[17:42:09.896]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:09.896]                     rootPath = tempdir()) 
[17:42:09.896]                   {
[17:42:09.896]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:09.896]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:09.896]                       tmpdir = path, fileext = ".rds")
[17:42:09.896]                     save_rds(obj, file)
[17:42:09.896]                   }
[17:42:09.896]                   saveImmediateCondition(cond, path = "/tmp/RtmpZwB2Ue/.future/immediateConditions")
[17:42:09.896]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.896]                   {
[17:42:09.896]                     inherits <- base::inherits
[17:42:09.896]                     invokeRestart <- base::invokeRestart
[17:42:09.896]                     is.null <- base::is.null
[17:42:09.896]                     muffled <- FALSE
[17:42:09.896]                     if (inherits(cond, "message")) {
[17:42:09.896]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:09.896]                       if (muffled) 
[17:42:09.896]                         invokeRestart("muffleMessage")
[17:42:09.896]                     }
[17:42:09.896]                     else if (inherits(cond, "warning")) {
[17:42:09.896]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:09.896]                       if (muffled) 
[17:42:09.896]                         invokeRestart("muffleWarning")
[17:42:09.896]                     }
[17:42:09.896]                     else if (inherits(cond, "condition")) {
[17:42:09.896]                       if (!is.null(pattern)) {
[17:42:09.896]                         computeRestarts <- base::computeRestarts
[17:42:09.896]                         grepl <- base::grepl
[17:42:09.896]                         restarts <- computeRestarts(cond)
[17:42:09.896]                         for (restart in restarts) {
[17:42:09.896]                           name <- restart$name
[17:42:09.896]                           if (is.null(name)) 
[17:42:09.896]                             next
[17:42:09.896]                           if (!grepl(pattern, name)) 
[17:42:09.896]                             next
[17:42:09.896]                           invokeRestart(restart)
[17:42:09.896]                           muffled <- TRUE
[17:42:09.896]                           break
[17:42:09.896]                         }
[17:42:09.896]                       }
[17:42:09.896]                     }
[17:42:09.896]                     invisible(muffled)
[17:42:09.896]                   }
[17:42:09.896]                   muffleCondition(cond)
[17:42:09.896]                 })
[17:42:09.896]             }))
[17:42:09.896]             future::FutureResult(value = ...future.value$value, 
[17:42:09.896]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.896]                   ...future.rng), globalenv = if (FALSE) 
[17:42:09.896]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:09.896]                     ...future.globalenv.names))
[17:42:09.896]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:09.896]         }, condition = base::local({
[17:42:09.896]             c <- base::c
[17:42:09.896]             inherits <- base::inherits
[17:42:09.896]             invokeRestart <- base::invokeRestart
[17:42:09.896]             length <- base::length
[17:42:09.896]             list <- base::list
[17:42:09.896]             seq.int <- base::seq.int
[17:42:09.896]             signalCondition <- base::signalCondition
[17:42:09.896]             sys.calls <- base::sys.calls
[17:42:09.896]             `[[` <- base::`[[`
[17:42:09.896]             `+` <- base::`+`
[17:42:09.896]             `<<-` <- base::`<<-`
[17:42:09.896]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:09.896]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:09.896]                   3L)]
[17:42:09.896]             }
[17:42:09.896]             function(cond) {
[17:42:09.896]                 is_error <- inherits(cond, "error")
[17:42:09.896]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:09.896]                   NULL)
[17:42:09.896]                 if (is_error) {
[17:42:09.896]                   sessionInformation <- function() {
[17:42:09.896]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:09.896]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:09.896]                       search = base::search(), system = base::Sys.info())
[17:42:09.896]                   }
[17:42:09.896]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.896]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:09.896]                     cond$call), session = sessionInformation(), 
[17:42:09.896]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:09.896]                   signalCondition(cond)
[17:42:09.896]                 }
[17:42:09.896]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:09.896]                 "immediateCondition"))) {
[17:42:09.896]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:09.896]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.896]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:09.896]                   if (TRUE && !signal) {
[17:42:09.896]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.896]                     {
[17:42:09.896]                       inherits <- base::inherits
[17:42:09.896]                       invokeRestart <- base::invokeRestart
[17:42:09.896]                       is.null <- base::is.null
[17:42:09.896]                       muffled <- FALSE
[17:42:09.896]                       if (inherits(cond, "message")) {
[17:42:09.896]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.896]                         if (muffled) 
[17:42:09.896]                           invokeRestart("muffleMessage")
[17:42:09.896]                       }
[17:42:09.896]                       else if (inherits(cond, "warning")) {
[17:42:09.896]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.896]                         if (muffled) 
[17:42:09.896]                           invokeRestart("muffleWarning")
[17:42:09.896]                       }
[17:42:09.896]                       else if (inherits(cond, "condition")) {
[17:42:09.896]                         if (!is.null(pattern)) {
[17:42:09.896]                           computeRestarts <- base::computeRestarts
[17:42:09.896]                           grepl <- base::grepl
[17:42:09.896]                           restarts <- computeRestarts(cond)
[17:42:09.896]                           for (restart in restarts) {
[17:42:09.896]                             name <- restart$name
[17:42:09.896]                             if (is.null(name)) 
[17:42:09.896]                               next
[17:42:09.896]                             if (!grepl(pattern, name)) 
[17:42:09.896]                               next
[17:42:09.896]                             invokeRestart(restart)
[17:42:09.896]                             muffled <- TRUE
[17:42:09.896]                             break
[17:42:09.896]                           }
[17:42:09.896]                         }
[17:42:09.896]                       }
[17:42:09.896]                       invisible(muffled)
[17:42:09.896]                     }
[17:42:09.896]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.896]                   }
[17:42:09.896]                 }
[17:42:09.896]                 else {
[17:42:09.896]                   if (TRUE) {
[17:42:09.896]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.896]                     {
[17:42:09.896]                       inherits <- base::inherits
[17:42:09.896]                       invokeRestart <- base::invokeRestart
[17:42:09.896]                       is.null <- base::is.null
[17:42:09.896]                       muffled <- FALSE
[17:42:09.896]                       if (inherits(cond, "message")) {
[17:42:09.896]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.896]                         if (muffled) 
[17:42:09.896]                           invokeRestart("muffleMessage")
[17:42:09.896]                       }
[17:42:09.896]                       else if (inherits(cond, "warning")) {
[17:42:09.896]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.896]                         if (muffled) 
[17:42:09.896]                           invokeRestart("muffleWarning")
[17:42:09.896]                       }
[17:42:09.896]                       else if (inherits(cond, "condition")) {
[17:42:09.896]                         if (!is.null(pattern)) {
[17:42:09.896]                           computeRestarts <- base::computeRestarts
[17:42:09.896]                           grepl <- base::grepl
[17:42:09.896]                           restarts <- computeRestarts(cond)
[17:42:09.896]                           for (restart in restarts) {
[17:42:09.896]                             name <- restart$name
[17:42:09.896]                             if (is.null(name)) 
[17:42:09.896]                               next
[17:42:09.896]                             if (!grepl(pattern, name)) 
[17:42:09.896]                               next
[17:42:09.896]                             invokeRestart(restart)
[17:42:09.896]                             muffled <- TRUE
[17:42:09.896]                             break
[17:42:09.896]                           }
[17:42:09.896]                         }
[17:42:09.896]                       }
[17:42:09.896]                       invisible(muffled)
[17:42:09.896]                     }
[17:42:09.896]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.896]                   }
[17:42:09.896]                 }
[17:42:09.896]             }
[17:42:09.896]         }))
[17:42:09.896]     }, error = function(ex) {
[17:42:09.896]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:09.896]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.896]                 ...future.rng), started = ...future.startTime, 
[17:42:09.896]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:09.896]             version = "1.8"), class = "FutureResult")
[17:42:09.896]     }, finally = {
[17:42:09.896]         if (!identical(...future.workdir, getwd())) 
[17:42:09.896]             setwd(...future.workdir)
[17:42:09.896]         {
[17:42:09.896]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:09.896]                 ...future.oldOptions$nwarnings <- NULL
[17:42:09.896]             }
[17:42:09.896]             base::options(...future.oldOptions)
[17:42:09.896]             if (.Platform$OS.type == "windows") {
[17:42:09.896]                 old_names <- names(...future.oldEnvVars)
[17:42:09.896]                 envs <- base::Sys.getenv()
[17:42:09.896]                 names <- names(envs)
[17:42:09.896]                 common <- intersect(names, old_names)
[17:42:09.896]                 added <- setdiff(names, old_names)
[17:42:09.896]                 removed <- setdiff(old_names, names)
[17:42:09.896]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:09.896]                   envs[common]]
[17:42:09.896]                 NAMES <- toupper(changed)
[17:42:09.896]                 args <- list()
[17:42:09.896]                 for (kk in seq_along(NAMES)) {
[17:42:09.896]                   name <- changed[[kk]]
[17:42:09.896]                   NAME <- NAMES[[kk]]
[17:42:09.896]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.896]                     next
[17:42:09.896]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.896]                 }
[17:42:09.896]                 NAMES <- toupper(added)
[17:42:09.896]                 for (kk in seq_along(NAMES)) {
[17:42:09.896]                   name <- added[[kk]]
[17:42:09.896]                   NAME <- NAMES[[kk]]
[17:42:09.896]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.896]                     next
[17:42:09.896]                   args[[name]] <- ""
[17:42:09.896]                 }
[17:42:09.896]                 NAMES <- toupper(removed)
[17:42:09.896]                 for (kk in seq_along(NAMES)) {
[17:42:09.896]                   name <- removed[[kk]]
[17:42:09.896]                   NAME <- NAMES[[kk]]
[17:42:09.896]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.896]                     next
[17:42:09.896]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.896]                 }
[17:42:09.896]                 if (length(args) > 0) 
[17:42:09.896]                   base::do.call(base::Sys.setenv, args = args)
[17:42:09.896]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:09.896]             }
[17:42:09.896]             else {
[17:42:09.896]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:09.896]             }
[17:42:09.896]             {
[17:42:09.896]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:09.896]                   0L) {
[17:42:09.896]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:09.896]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:09.896]                   base::options(opts)
[17:42:09.896]                 }
[17:42:09.896]                 {
[17:42:09.896]                   {
[17:42:09.896]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:09.896]                     NULL
[17:42:09.896]                   }
[17:42:09.896]                   options(future.plan = NULL)
[17:42:09.896]                   if (is.na(NA_character_)) 
[17:42:09.896]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.896]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:09.896]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:09.896]                     envir = parent.frame()) 
[17:42:09.896]                   {
[17:42:09.896]                     default_workers <- missing(workers)
[17:42:09.896]                     if (is.function(workers)) 
[17:42:09.896]                       workers <- workers()
[17:42:09.896]                     workers <- structure(as.integer(workers), 
[17:42:09.896]                       class = class(workers))
[17:42:09.896]                     stop_if_not(is.finite(workers), workers >= 
[17:42:09.896]                       1L)
[17:42:09.896]                     if ((workers == 1L && !inherits(workers, 
[17:42:09.896]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:09.896]                       if (default_workers) 
[17:42:09.896]                         supportsMulticore(warn = TRUE)
[17:42:09.896]                       return(sequential(..., envir = envir))
[17:42:09.896]                     }
[17:42:09.896]                     oopts <- options(mc.cores = workers)
[17:42:09.896]                     on.exit(options(oopts))
[17:42:09.896]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:09.896]                       envir = envir)
[17:42:09.896]                     if (!future$lazy) 
[17:42:09.896]                       future <- run(future)
[17:42:09.896]                     invisible(future)
[17:42:09.896]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:09.896]                 }
[17:42:09.896]             }
[17:42:09.896]         }
[17:42:09.896]     })
[17:42:09.896]     if (TRUE) {
[17:42:09.896]         base::sink(type = "output", split = FALSE)
[17:42:09.896]         if (TRUE) {
[17:42:09.896]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:09.896]         }
[17:42:09.896]         else {
[17:42:09.896]             ...future.result["stdout"] <- base::list(NULL)
[17:42:09.896]         }
[17:42:09.896]         base::close(...future.stdout)
[17:42:09.896]         ...future.stdout <- NULL
[17:42:09.896]     }
[17:42:09.896]     ...future.result$conditions <- ...future.conditions
[17:42:09.896]     ...future.result$finished <- base::Sys.time()
[17:42:09.896]     ...future.result
[17:42:09.896] }
[17:42:09.898] requestCore(): workers = 2
[17:42:09.900] MulticoreFuture started
[17:42:09.901] - Launch lazy future ... done
[17:42:09.901] run() for ‘MulticoreFuture’ ... done
[17:42:09.901] plan(): Setting new future strategy stack:
[17:42:09.902] List of future strategies:
[17:42:09.902] 1. sequential:
[17:42:09.902]    - args: function (..., envir = parent.frame())
[17:42:09.902]    - tweaked: FALSE
[17:42:09.902]    - call: NULL
[17:42:09.903] plan(): nbrOfWorkers() = 1
[17:42:09.905] plan(): Setting new future strategy stack:
[17:42:09.905] List of future strategies:
[17:42:09.905] 1. multicore:
[17:42:09.905]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:09.905]    - tweaked: FALSE
[17:42:09.905]    - call: plan(strategy)
[17:42:09.910] plan(): nbrOfWorkers() = 2
d = 1
** Nested future assignments
[17:42:09.912] getGlobalsAndPackages() ...
[17:42:09.912] Searching for globals...
[17:42:09.917] - globals found: [5] ‘{’, ‘<-’, ‘%<-%’, ‘%->%’, ‘+’
[17:42:09.917] Searching for globals ... DONE
[17:42:09.917] Resolving globals: FALSE
[17:42:09.918] 
[17:42:09.918] - packages: [1] ‘future’
[17:42:09.918] getGlobalsAndPackages() ... DONE
[17:42:09.919] run() for ‘Future’ ...
[17:42:09.919] - state: ‘created’
[17:42:09.919] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:09.923] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:09.923] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:09.923]   - Field: ‘label’
[17:42:09.923]   - Field: ‘local’
[17:42:09.924]   - Field: ‘owner’
[17:42:09.924]   - Field: ‘envir’
[17:42:09.924]   - Field: ‘workers’
[17:42:09.924]   - Field: ‘packages’
[17:42:09.924]   - Field: ‘gc’
[17:42:09.924]   - Field: ‘job’
[17:42:09.924]   - Field: ‘conditions’
[17:42:09.924]   - Field: ‘expr’
[17:42:09.925]   - Field: ‘uuid’
[17:42:09.925]   - Field: ‘seed’
[17:42:09.925]   - Field: ‘version’
[17:42:09.925]   - Field: ‘result’
[17:42:09.925]   - Field: ‘asynchronous’
[17:42:09.925]   - Field: ‘calls’
[17:42:09.925]   - Field: ‘globals’
[17:42:09.925]   - Field: ‘stdout’
[17:42:09.925]   - Field: ‘earlySignal’
[17:42:09.926]   - Field: ‘lazy’
[17:42:09.926]   - Field: ‘state’
[17:42:09.926] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:09.926] - Launch lazy future ...
[17:42:09.926] Packages needed by the future expression (n = 1): ‘future’
[17:42:09.926] Packages needed by future strategies (n = 0): <none>
[17:42:09.927] {
[17:42:09.927]     {
[17:42:09.927]         {
[17:42:09.927]             ...future.startTime <- base::Sys.time()
[17:42:09.927]             {
[17:42:09.927]                 {
[17:42:09.927]                   {
[17:42:09.927]                     {
[17:42:09.927]                       {
[17:42:09.927]                         base::local({
[17:42:09.927]                           has_future <- base::requireNamespace("future", 
[17:42:09.927]                             quietly = TRUE)
[17:42:09.927]                           if (has_future) {
[17:42:09.927]                             ns <- base::getNamespace("future")
[17:42:09.927]                             version <- ns[[".package"]][["version"]]
[17:42:09.927]                             if (is.null(version)) 
[17:42:09.927]                               version <- utils::packageVersion("future")
[17:42:09.927]                           }
[17:42:09.927]                           else {
[17:42:09.927]                             version <- NULL
[17:42:09.927]                           }
[17:42:09.927]                           if (!has_future || version < "1.8.0") {
[17:42:09.927]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:09.927]                               "", base::R.version$version.string), 
[17:42:09.927]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:09.927]                                 base::R.version$platform, 8 * 
[17:42:09.927]                                   base::.Machine$sizeof.pointer), 
[17:42:09.927]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:09.927]                                 "release", "version")], collapse = " "), 
[17:42:09.927]                               hostname = base::Sys.info()[["nodename"]])
[17:42:09.927]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:09.927]                               info)
[17:42:09.927]                             info <- base::paste(info, collapse = "; ")
[17:42:09.927]                             if (!has_future) {
[17:42:09.927]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:09.927]                                 info)
[17:42:09.927]                             }
[17:42:09.927]                             else {
[17:42:09.927]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:09.927]                                 info, version)
[17:42:09.927]                             }
[17:42:09.927]                             base::stop(msg)
[17:42:09.927]                           }
[17:42:09.927]                         })
[17:42:09.927]                       }
[17:42:09.927]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:09.927]                       base::options(mc.cores = 1L)
[17:42:09.927]                     }
[17:42:09.927]                     base::local({
[17:42:09.927]                       for (pkg in "future") {
[17:42:09.927]                         base::loadNamespace(pkg)
[17:42:09.927]                         base::library(pkg, character.only = TRUE)
[17:42:09.927]                       }
[17:42:09.927]                     })
[17:42:09.927]                   }
[17:42:09.927]                   options(future.plan = NULL)
[17:42:09.927]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.927]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:09.927]                 }
[17:42:09.927]                 ...future.workdir <- getwd()
[17:42:09.927]             }
[17:42:09.927]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:09.927]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:09.927]         }
[17:42:09.927]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:09.927]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:09.927]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:09.927]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:09.927]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:09.927]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:09.927]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:09.927]             base::names(...future.oldOptions))
[17:42:09.927]     }
[17:42:09.927]     if (FALSE) {
[17:42:09.927]     }
[17:42:09.927]     else {
[17:42:09.927]         if (TRUE) {
[17:42:09.927]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:09.927]                 open = "w")
[17:42:09.927]         }
[17:42:09.927]         else {
[17:42:09.927]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:09.927]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:09.927]         }
[17:42:09.927]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:09.927]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:09.927]             base::sink(type = "output", split = FALSE)
[17:42:09.927]             base::close(...future.stdout)
[17:42:09.927]         }, add = TRUE)
[17:42:09.927]     }
[17:42:09.927]     ...future.frame <- base::sys.nframe()
[17:42:09.927]     ...future.conditions <- base::list()
[17:42:09.927]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:09.927]     if (FALSE) {
[17:42:09.927]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:09.927]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:09.927]     }
[17:42:09.927]     ...future.result <- base::tryCatch({
[17:42:09.927]         base::withCallingHandlers({
[17:42:09.927]             ...future.value <- base::withVisible(base::local({
[17:42:09.927]                 withCallingHandlers({
[17:42:09.927]                   {
[17:42:09.927]                     b <- 1
[17:42:09.927]                     c %<-% 2
[17:42:09.927]                     d <- 3
[17:42:09.927]                     4 %->% e
[17:42:09.927]                     b + c + d + e
[17:42:09.927]                   }
[17:42:09.927]                 }, immediateCondition = function(cond) {
[17:42:09.927]                   save_rds <- function (object, pathname, ...) 
[17:42:09.927]                   {
[17:42:09.927]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:09.927]                     if (file_test("-f", pathname_tmp)) {
[17:42:09.927]                       fi_tmp <- file.info(pathname_tmp)
[17:42:09.927]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:09.927]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:09.927]                         fi_tmp[["mtime"]])
[17:42:09.927]                     }
[17:42:09.927]                     tryCatch({
[17:42:09.927]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:09.927]                     }, error = function(ex) {
[17:42:09.927]                       msg <- conditionMessage(ex)
[17:42:09.927]                       fi_tmp <- file.info(pathname_tmp)
[17:42:09.927]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:09.927]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:09.927]                         fi_tmp[["mtime"]], msg)
[17:42:09.927]                       ex$message <- msg
[17:42:09.927]                       stop(ex)
[17:42:09.927]                     })
[17:42:09.927]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:09.927]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:09.927]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:09.927]                       fi_tmp <- file.info(pathname_tmp)
[17:42:09.927]                       fi <- file.info(pathname)
[17:42:09.927]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:09.927]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:09.927]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:09.927]                         fi[["size"]], fi[["mtime"]])
[17:42:09.927]                       stop(msg)
[17:42:09.927]                     }
[17:42:09.927]                     invisible(pathname)
[17:42:09.927]                   }
[17:42:09.927]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:09.927]                     rootPath = tempdir()) 
[17:42:09.927]                   {
[17:42:09.927]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:09.927]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:09.927]                       tmpdir = path, fileext = ".rds")
[17:42:09.927]                     save_rds(obj, file)
[17:42:09.927]                   }
[17:42:09.927]                   saveImmediateCondition(cond, path = "/tmp/RtmpZwB2Ue/.future/immediateConditions")
[17:42:09.927]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.927]                   {
[17:42:09.927]                     inherits <- base::inherits
[17:42:09.927]                     invokeRestart <- base::invokeRestart
[17:42:09.927]                     is.null <- base::is.null
[17:42:09.927]                     muffled <- FALSE
[17:42:09.927]                     if (inherits(cond, "message")) {
[17:42:09.927]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:09.927]                       if (muffled) 
[17:42:09.927]                         invokeRestart("muffleMessage")
[17:42:09.927]                     }
[17:42:09.927]                     else if (inherits(cond, "warning")) {
[17:42:09.927]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:09.927]                       if (muffled) 
[17:42:09.927]                         invokeRestart("muffleWarning")
[17:42:09.927]                     }
[17:42:09.927]                     else if (inherits(cond, "condition")) {
[17:42:09.927]                       if (!is.null(pattern)) {
[17:42:09.927]                         computeRestarts <- base::computeRestarts
[17:42:09.927]                         grepl <- base::grepl
[17:42:09.927]                         restarts <- computeRestarts(cond)
[17:42:09.927]                         for (restart in restarts) {
[17:42:09.927]                           name <- restart$name
[17:42:09.927]                           if (is.null(name)) 
[17:42:09.927]                             next
[17:42:09.927]                           if (!grepl(pattern, name)) 
[17:42:09.927]                             next
[17:42:09.927]                           invokeRestart(restart)
[17:42:09.927]                           muffled <- TRUE
[17:42:09.927]                           break
[17:42:09.927]                         }
[17:42:09.927]                       }
[17:42:09.927]                     }
[17:42:09.927]                     invisible(muffled)
[17:42:09.927]                   }
[17:42:09.927]                   muffleCondition(cond)
[17:42:09.927]                 })
[17:42:09.927]             }))
[17:42:09.927]             future::FutureResult(value = ...future.value$value, 
[17:42:09.927]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.927]                   ...future.rng), globalenv = if (FALSE) 
[17:42:09.927]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:09.927]                     ...future.globalenv.names))
[17:42:09.927]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:09.927]         }, condition = base::local({
[17:42:09.927]             c <- base::c
[17:42:09.927]             inherits <- base::inherits
[17:42:09.927]             invokeRestart <- base::invokeRestart
[17:42:09.927]             length <- base::length
[17:42:09.927]             list <- base::list
[17:42:09.927]             seq.int <- base::seq.int
[17:42:09.927]             signalCondition <- base::signalCondition
[17:42:09.927]             sys.calls <- base::sys.calls
[17:42:09.927]             `[[` <- base::`[[`
[17:42:09.927]             `+` <- base::`+`
[17:42:09.927]             `<<-` <- base::`<<-`
[17:42:09.927]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:09.927]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:09.927]                   3L)]
[17:42:09.927]             }
[17:42:09.927]             function(cond) {
[17:42:09.927]                 is_error <- inherits(cond, "error")
[17:42:09.927]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:09.927]                   NULL)
[17:42:09.927]                 if (is_error) {
[17:42:09.927]                   sessionInformation <- function() {
[17:42:09.927]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:09.927]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:09.927]                       search = base::search(), system = base::Sys.info())
[17:42:09.927]                   }
[17:42:09.927]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.927]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:09.927]                     cond$call), session = sessionInformation(), 
[17:42:09.927]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:09.927]                   signalCondition(cond)
[17:42:09.927]                 }
[17:42:09.927]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:09.927]                 "immediateCondition"))) {
[17:42:09.927]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:09.927]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.927]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:09.927]                   if (TRUE && !signal) {
[17:42:09.927]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.927]                     {
[17:42:09.927]                       inherits <- base::inherits
[17:42:09.927]                       invokeRestart <- base::invokeRestart
[17:42:09.927]                       is.null <- base::is.null
[17:42:09.927]                       muffled <- FALSE
[17:42:09.927]                       if (inherits(cond, "message")) {
[17:42:09.927]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.927]                         if (muffled) 
[17:42:09.927]                           invokeRestart("muffleMessage")
[17:42:09.927]                       }
[17:42:09.927]                       else if (inherits(cond, "warning")) {
[17:42:09.927]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.927]                         if (muffled) 
[17:42:09.927]                           invokeRestart("muffleWarning")
[17:42:09.927]                       }
[17:42:09.927]                       else if (inherits(cond, "condition")) {
[17:42:09.927]                         if (!is.null(pattern)) {
[17:42:09.927]                           computeRestarts <- base::computeRestarts
[17:42:09.927]                           grepl <- base::grepl
[17:42:09.927]                           restarts <- computeRestarts(cond)
[17:42:09.927]                           for (restart in restarts) {
[17:42:09.927]                             name <- restart$name
[17:42:09.927]                             if (is.null(name)) 
[17:42:09.927]                               next
[17:42:09.927]                             if (!grepl(pattern, name)) 
[17:42:09.927]                               next
[17:42:09.927]                             invokeRestart(restart)
[17:42:09.927]                             muffled <- TRUE
[17:42:09.927]                             break
[17:42:09.927]                           }
[17:42:09.927]                         }
[17:42:09.927]                       }
[17:42:09.927]                       invisible(muffled)
[17:42:09.927]                     }
[17:42:09.927]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.927]                   }
[17:42:09.927]                 }
[17:42:09.927]                 else {
[17:42:09.927]                   if (TRUE) {
[17:42:09.927]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.927]                     {
[17:42:09.927]                       inherits <- base::inherits
[17:42:09.927]                       invokeRestart <- base::invokeRestart
[17:42:09.927]                       is.null <- base::is.null
[17:42:09.927]                       muffled <- FALSE
[17:42:09.927]                       if (inherits(cond, "message")) {
[17:42:09.927]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.927]                         if (muffled) 
[17:42:09.927]                           invokeRestart("muffleMessage")
[17:42:09.927]                       }
[17:42:09.927]                       else if (inherits(cond, "warning")) {
[17:42:09.927]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.927]                         if (muffled) 
[17:42:09.927]                           invokeRestart("muffleWarning")
[17:42:09.927]                       }
[17:42:09.927]                       else if (inherits(cond, "condition")) {
[17:42:09.927]                         if (!is.null(pattern)) {
[17:42:09.927]                           computeRestarts <- base::computeRestarts
[17:42:09.927]                           grepl <- base::grepl
[17:42:09.927]                           restarts <- computeRestarts(cond)
[17:42:09.927]                           for (restart in restarts) {
[17:42:09.927]                             name <- restart$name
[17:42:09.927]                             if (is.null(name)) 
[17:42:09.927]                               next
[17:42:09.927]                             if (!grepl(pattern, name)) 
[17:42:09.927]                               next
[17:42:09.927]                             invokeRestart(restart)
[17:42:09.927]                             muffled <- TRUE
[17:42:09.927]                             break
[17:42:09.927]                           }
[17:42:09.927]                         }
[17:42:09.927]                       }
[17:42:09.927]                       invisible(muffled)
[17:42:09.927]                     }
[17:42:09.927]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.927]                   }
[17:42:09.927]                 }
[17:42:09.927]             }
[17:42:09.927]         }))
[17:42:09.927]     }, error = function(ex) {
[17:42:09.927]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:09.927]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.927]                 ...future.rng), started = ...future.startTime, 
[17:42:09.927]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:09.927]             version = "1.8"), class = "FutureResult")
[17:42:09.927]     }, finally = {
[17:42:09.927]         if (!identical(...future.workdir, getwd())) 
[17:42:09.927]             setwd(...future.workdir)
[17:42:09.927]         {
[17:42:09.927]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:09.927]                 ...future.oldOptions$nwarnings <- NULL
[17:42:09.927]             }
[17:42:09.927]             base::options(...future.oldOptions)
[17:42:09.927]             if (.Platform$OS.type == "windows") {
[17:42:09.927]                 old_names <- names(...future.oldEnvVars)
[17:42:09.927]                 envs <- base::Sys.getenv()
[17:42:09.927]                 names <- names(envs)
[17:42:09.927]                 common <- intersect(names, old_names)
[17:42:09.927]                 added <- setdiff(names, old_names)
[17:42:09.927]                 removed <- setdiff(old_names, names)
[17:42:09.927]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:09.927]                   envs[common]]
[17:42:09.927]                 NAMES <- toupper(changed)
[17:42:09.927]                 args <- list()
[17:42:09.927]                 for (kk in seq_along(NAMES)) {
[17:42:09.927]                   name <- changed[[kk]]
[17:42:09.927]                   NAME <- NAMES[[kk]]
[17:42:09.927]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.927]                     next
[17:42:09.927]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.927]                 }
[17:42:09.927]                 NAMES <- toupper(added)
[17:42:09.927]                 for (kk in seq_along(NAMES)) {
[17:42:09.927]                   name <- added[[kk]]
[17:42:09.927]                   NAME <- NAMES[[kk]]
[17:42:09.927]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.927]                     next
[17:42:09.927]                   args[[name]] <- ""
[17:42:09.927]                 }
[17:42:09.927]                 NAMES <- toupper(removed)
[17:42:09.927]                 for (kk in seq_along(NAMES)) {
[17:42:09.927]                   name <- removed[[kk]]
[17:42:09.927]                   NAME <- NAMES[[kk]]
[17:42:09.927]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.927]                     next
[17:42:09.927]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.927]                 }
[17:42:09.927]                 if (length(args) > 0) 
[17:42:09.927]                   base::do.call(base::Sys.setenv, args = args)
[17:42:09.927]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:09.927]             }
[17:42:09.927]             else {
[17:42:09.927]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:09.927]             }
[17:42:09.927]             {
[17:42:09.927]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:09.927]                   0L) {
[17:42:09.927]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:09.927]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:09.927]                   base::options(opts)
[17:42:09.927]                 }
[17:42:09.927]                 {
[17:42:09.927]                   {
[17:42:09.927]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:09.927]                     NULL
[17:42:09.927]                   }
[17:42:09.927]                   options(future.plan = NULL)
[17:42:09.927]                   if (is.na(NA_character_)) 
[17:42:09.927]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.927]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:09.927]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:09.927]                     envir = parent.frame()) 
[17:42:09.927]                   {
[17:42:09.927]                     default_workers <- missing(workers)
[17:42:09.927]                     if (is.function(workers)) 
[17:42:09.927]                       workers <- workers()
[17:42:09.927]                     workers <- structure(as.integer(workers), 
[17:42:09.927]                       class = class(workers))
[17:42:09.927]                     stop_if_not(is.finite(workers), workers >= 
[17:42:09.927]                       1L)
[17:42:09.927]                     if ((workers == 1L && !inherits(workers, 
[17:42:09.927]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:09.927]                       if (default_workers) 
[17:42:09.927]                         supportsMulticore(warn = TRUE)
[17:42:09.927]                       return(sequential(..., envir = envir))
[17:42:09.927]                     }
[17:42:09.927]                     oopts <- options(mc.cores = workers)
[17:42:09.927]                     on.exit(options(oopts))
[17:42:09.927]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:09.927]                       envir = envir)
[17:42:09.927]                     if (!future$lazy) 
[17:42:09.927]                       future <- run(future)
[17:42:09.927]                     invisible(future)
[17:42:09.927]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:09.927]                 }
[17:42:09.927]             }
[17:42:09.927]         }
[17:42:09.927]     })
[17:42:09.927]     if (TRUE) {
[17:42:09.927]         base::sink(type = "output", split = FALSE)
[17:42:09.927]         if (TRUE) {
[17:42:09.927]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:09.927]         }
[17:42:09.927]         else {
[17:42:09.927]             ...future.result["stdout"] <- base::list(NULL)
[17:42:09.927]         }
[17:42:09.927]         base::close(...future.stdout)
[17:42:09.927]         ...future.stdout <- NULL
[17:42:09.927]     }
[17:42:09.927]     ...future.result$conditions <- ...future.conditions
[17:42:09.927]     ...future.result$finished <- base::Sys.time()
[17:42:09.927]     ...future.result
[17:42:09.927] }
[17:42:09.930] requestCore(): workers = 2
[17:42:09.932] MulticoreFuture started
[17:42:09.932] - Launch lazy future ... done
[17:42:09.932] run() for ‘MulticoreFuture’ ... done
[17:42:09.933] plan(): Setting new future strategy stack:
[17:42:09.933] List of future strategies:
[17:42:09.933] 1. sequential:
[17:42:09.933]    - args: function (..., envir = parent.frame())
[17:42:09.933]    - tweaked: FALSE
[17:42:09.933]    - call: NULL
[17:42:09.934] plan(): nbrOfWorkers() = 1
[17:42:09.970] plan(): Setting new future strategy stack:
[17:42:09.970] List of future strategies:
[17:42:09.970] 1. multicore:
[17:42:09.970]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:09.970]    - tweaked: FALSE
[17:42:09.970]    - call: plan(strategy)
[17:42:09.975] plan(): nbrOfWorkers() = 2
[17:42:09.976] signalConditions() ...
[17:42:09.976]  - include = ‘immediateCondition’
[17:42:09.977]  - exclude = 
[17:42:09.977]  - resignal = FALSE
[17:42:09.977]  - Number of conditions: 88
[17:42:09.977] signalConditions() ... done
[17:42:09.977] signalConditions() ...
[17:42:09.977]  - include = ‘immediateCondition’
[17:42:09.977]  - exclude = 
[17:42:09.978]  - resignal = FALSE
[17:42:09.978]  - Number of conditions: 88
[17:42:09.981] signalConditions() ... done
[17:42:09.981] Future state: ‘finished’
[17:42:09.981] signalConditions() ...
[17:42:09.981]  - include = ‘condition’
[17:42:09.981]  - exclude = ‘immediateCondition’
[17:42:09.981]  - resignal = TRUE
[17:42:09.982]  - Number of conditions: 88
[17:42:09.982]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.936] getGlobalsAndPackages() ...
[17:42:09.982]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.936] Searching for globals...
[17:42:09.982]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.937] 
[17:42:09.982]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.937] Searching for globals ... DONE
[17:42:09.983]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.937] - globals: [0] <none>
[17:42:09.983]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.937] getGlobalsAndPackages() ... DONE
[17:42:09.983]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.943] run() for ‘Future’ ...
[17:42:09.983]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.943] - state: ‘created’
[17:42:09.983]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.944] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:09.984]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.944] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:09.984]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.944] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:09.984]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.945]   - Field: ‘label’
[17:42:09.984]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.945]   - Field: ‘local’
[17:42:09.984]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.945]   - Field: ‘owner’
[17:42:09.985]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.946]   - Field: ‘envir’
[17:42:09.985]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.946]   - Field: ‘packages’
[17:42:09.985]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.946]   - Field: ‘gc’
[17:42:09.985]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.946]   - Field: ‘conditions’
[17:42:09.985]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.947]   - Field: ‘expr’
[17:42:09.985]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.947]   - Field: ‘uuid’
[17:42:09.986]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.947]   - Field: ‘seed’
[17:42:09.986]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.947]   - Field: ‘version’
[17:42:09.986]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.948]   - Field: ‘result’
[17:42:09.986]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.948]   - Field: ‘asynchronous’
[17:42:09.986]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.948]   - Field: ‘calls’
[17:42:09.987]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.948]   - Field: ‘globals’
[17:42:09.987]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.948]   - Field: ‘stdout’
[17:42:09.987]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.949]   - Field: ‘earlySignal’
[17:42:09.987]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.949]   - Field: ‘lazy’
[17:42:09.987]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.949]   - Field: ‘state’
[17:42:09.987]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.950] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:09.988]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.950] - Launch lazy future ...
[17:42:09.988]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.950] Packages needed by the future expression (n = 0): <none>
[17:42:09.988]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.950] Packages needed by future strategies (n = 0): <none>
[17:42:09.988]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.951] {
[17:42:09.951]     {
[17:42:09.951]         {
[17:42:09.951]             ...future.startTime <- base::Sys.time()
[17:42:09.951]             {
[17:42:09.951]                 {
[17:42:09.951]                   {
[17:42:09.951]                     base::local({
[17:42:09.951]                       has_future <- base::requireNamespace("future", 
[17:42:09.951]                         quietly = TRUE)
[17:42:09.951]                       if (has_future) {
[17:42:09.951]                         ns <- base::getNamespace("future")
[17:42:09.951]                         version <- ns[[".package"]][["version"]]
[17:42:09.951]                         if (is.null(version)) 
[17:42:09.951]                           version <- utils::packageVersion("future")
[17:42:09.951]                       }
[17:42:09.951]                       else {
[17:42:09.951]                         version <- NULL
[17:42:09.951]                       }
[17:42:09.951]                       if (!has_future || version < "1.8.0") {
[17:42:09.951]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:09.951]                           "", base::R.version$version.string), 
[17:42:09.951]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:09.951]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:09.951]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:09.951]                             "release", "version")], collapse = " "), 
[17:42:09.951]                           hostname = base::Sys.info()[["nodename"]])
[17:42:09.951]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:09.951]                           info)
[17:42:09.951]                         info <- base::paste(info, collapse = "; ")
[17:42:09.951]                         if (!has_future) {
[17:42:09.951]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:09.951]                             info)
[17:42:09.951]                         }
[17:42:09.951]                         else {
[17:42:09.951]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:09.951]                             info, version)
[17:42:09.951]                         }
[17:42:09.951]                         base::stop(msg)
[17:42:09.951]                       }
[17:42:09.951]                     })
[17:42:09.951]                   }
[17:42:09.951]                   options(future.plan = NULL)
[17:42:09.951]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.951]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:09.951]                 }
[17:42:09.951]                 ...future.workdir <- getwd()
[17:42:09.951]             }
[17:42:09.951]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:09.951]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:09.951]         }
[17:42:09.951]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:09.951]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:09.951]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:09.951]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:09.951]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:09.951]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:09.951]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:09.951]             base::names(...future.oldOptions))
[17:42:09.951]     }
[17:42:09.951]     if (FALSE) {
[17:42:09.951]     }
[17:42:09.951]     else {
[17:42:09.951]         if (TRUE) {
[17:42:09.951]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:09.951]                 open = "w")
[17:42:09.951]         }
[17:42:09.951]         else {
[17:42:09.951]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:09.951]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:09.951]         }
[17:42:09.951]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:09.951]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:09.951]             base::sink(type = "output", split = FALSE)
[17:42:09.951]             base::close(...future.stdout)
[17:42:09.951]         }, add = TRUE)
[17:42:09.951]     }
[17:42:09.951]     ...future.frame <- base::sys.nframe()
[17:42:09.951]     ...future.conditions <- base::list()
[17:42:09.951]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:09.951]     if (FALSE) {
[17:42:09.951]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:09.951]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:09.951]     }
[17:42:09.951]     ...future.result <- base::tryCatch({
[17:42:09.951]         base::withCallingHandlers({
[17:42:09.951]             ...future.value <- base::withVisible(base::local(2))
[17:42:09.951]             future::FutureResult(value = ...future.value$value, 
[17:42:09.951]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.951]                   ...future.rng), globalenv = if (FALSE) 
[17:42:09.951]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:09.951]                     ...future.globalenv.names))
[17:42:09.951]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:09.951]         }, condition = base::local({
[17:42:09.951]             c <- base::c
[17:42:09.951]             inherits <- base::inherits
[17:42:09.951]             invokeRestart <- base::invokeRestart
[17:42:09.951]             length <- base::length
[17:42:09.951]             list <- base::list
[17:42:09.951]             seq.int <- base::seq.int
[17:42:09.951]             signalCondition <- base::signalCondition
[17:42:09.951]             sys.calls <- base::sys.calls
[17:42:09.951]             `[[` <- base::`[[`
[17:42:09.951]             `+` <- base::`+`
[17:42:09.951]             `<<-` <- base::`<<-`
[17:42:09.951]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:09.951]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:09.951]                   3L)]
[17:42:09.951]             }
[17:42:09.951]             function(cond) {
[17:42:09.951]                 is_error <- inherits(cond, "error")
[17:42:09.951]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:09.951]                   NULL)
[17:42:09.951]                 if (is_error) {
[17:42:09.951]                   sessionInformation <- function() {
[17:42:09.951]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:09.951]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:09.951]                       search = base::search(), system = base::Sys.info())
[17:42:09.951]                   }
[17:42:09.951]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.951]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:09.951]                     cond$call), session = sessionInformation(), 
[17:42:09.951]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:09.951]                   signalCondition(cond)
[17:42:09.951]                 }
[17:42:09.951]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:09.951]                 "immediateCondition"))) {
[17:42:09.951]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:09.951]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.951]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:09.951]                   if (TRUE && !signal) {
[17:42:09.951]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.951]                     {
[17:42:09.951]                       inherits <- base::inherits
[17:42:09.951]                       invokeRestart <- base::invokeRestart
[17:42:09.951]                       is.null <- base::is.null
[17:42:09.951]                       muffled <- FALSE
[17:42:09.951]                       if (inherits(cond, "message")) {
[17:42:09.951]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.951]                         if (muffled) 
[17:42:09.951]                           invokeRestart("muffleMessage")
[17:42:09.951]                       }
[17:42:09.951]                       else if (inherits(cond, "warning")) {
[17:42:09.951]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.951]                         if (muffled) 
[17:42:09.951]                           invokeRestart("muffleWarning")
[17:42:09.951]                       }
[17:42:09.951]                       else if (inherits(cond, "condition")) {
[17:42:09.951]                         if (!is.null(pattern)) {
[17:42:09.951]                           computeRestarts <- base::computeRestarts
[17:42:09.951]                           grepl <- base::grepl
[17:42:09.951]                           restarts <- computeRestarts(cond)
[17:42:09.951]                           for (restart in restarts) {
[17:42:09.951]                             name <- restart$name
[17:42:09.951]                             if (is.null(name)) 
[17:42:09.951]                               next
[17:42:09.951]                             if (!grepl(pattern, name)) 
[17:42:09.951]                               next
[17:42:09.951]                             invokeRestart(restart)
[17:42:09.951]                             muffled <- TRUE
[17:42:09.951]                             break
[17:42:09.951]                           }
[17:42:09.951]                         }
[17:42:09.951]                       }
[17:42:09.951]                       invisible(muffled)
[17:42:09.951]                     }
[17:42:09.951]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.951]                   }
[17:42:09.951]                 }
[17:42:09.951]                 else {
[17:42:09.951]                   if (TRUE) {
[17:42:09.951]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.951]                     {
[17:42:09.951]                       inherits <- base::inherits
[17:42:09.951]                       invokeRestart <- base::invokeRestart
[17:42:09.951]                       is.null <- base::is.null
[17:42:09.951]                       muffled <- FALSE
[17:42:09.951]                       if (inherits(cond, "message")) {
[17:42:09.951]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.951]                         if (muffled) 
[17:42:09.951]                           invokeRestart("muffleMessage")
[17:42:09.951]                       }
[17:42:09.951]                       else if (inherits(cond, "warning")) {
[17:42:09.951]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.951]                         if (muffled) 
[17:42:09.951]                           invokeRestart("muffleWarning")
[17:42:09.951]                       }
[17:42:09.951]                       else if (inherits(cond, "condition")) {
[17:42:09.951]                         if (!is.null(pattern)) {
[17:42:09.951]                           computeRestarts <- base::computeRestarts
[17:42:09.951]                           grepl <- base::grepl
[17:42:09.951]                           restarts <- computeRestarts(cond)
[17:42:09.951]                           for (restart in restarts) {
[17:42:09.951]                             name <- restart$name
[17:42:09.951]                             if (is.null(name)) 
[17:42:09.951]                               next
[17:42:09.951]                             if (!grepl(pattern, name)) 
[17:42:09.951]                               next
[17:42:09.951]                             invokeRestart(restart)
[17:42:09.951]                             muffled <- TRUE
[17:42:09.951]                             break
[17:42:09.951]                           }
[17:42:09.951]                         }
[17:42:09.951]                       }
[17:42:09.951]                       invisible(muffled)
[17:42:09.951]                     }
[17:42:09.951]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.951]                   }
[17:42:09.951]                 }
[17:42:09.951]             }
[17:42:09.951]         }))
[17:42:09.951]     }, error = function(ex) {
[17:42:09.951]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:09.951]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.951]                 ...future.rng), started = ...future.startTime, 
[17:42:09.951]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:09.951]             version = "1.8"), class = "FutureResult")
[17:42:09.951]     }, finally = {
[17:42:09.951]         if (!identical(...future.workdir, getwd())) 
[17:42:09.951]             setwd(...future.workdir)
[17:42:09.951]         {
[17:42:09.951]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:09.951]                 ...future.oldOptions$nwarnings <- NULL
[17:42:09.951]             }
[17:42:09.951]             base::options(...future.oldOptions)
[17:42:09.951]             if (.Platform$OS.type == "windows") {
[17:42:09.951]                 old_names <- names(...future.oldEnvVars)
[17:42:09.951]                 envs <- base::Sys.getenv()
[17:42:09.951]                 names <- names(envs)
[17:42:09.951]                 common <- intersect(names, old_names)
[17:42:09.951]                 added <- setdiff(names, old_names)
[17:42:09.951]                 removed <- setdiff(old_names, names)
[17:42:09.951]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:09.951]                   envs[common]]
[17:42:09.951]                 NAMES <- toupper(changed)
[17:42:09.951]                 args <- list()
[17:42:09.951]                 for (kk in seq_along(NAMES)) {
[17:42:09.951]                   name <- changed[[kk]]
[17:42:09.951]                   NAME <- NAMES[[kk]]
[17:42:09.951]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.951]                     next
[17:42:09.951]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.951]                 }
[17:42:09.951]                 NAMES <- toupper(added)
[17:42:09.951]                 for (kk in seq_along(NAMES)) {
[17:42:09.951]                   name <- added[[kk]]
[17:42:09.951]                   NAME <- NAMES[[kk]]
[17:42:09.951]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.951]                     next
[17:42:09.951]                   args[[name]] <- ""
[17:42:09.951]                 }
[17:42:09.951]                 NAMES <- toupper(removed)
[17:42:09.951]                 for (kk in seq_along(NAMES)) {
[17:42:09.951]                   name <- removed[[kk]]
[17:42:09.951]                   NAME <- NAMES[[kk]]
[17:42:09.951]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.951]                     next
[17:42:09.951]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.951]                 }
[17:42:09.951]                 if (length(args) > 0) 
[17:42:09.951]                   base::do.call(base::Sys.setenv, args = args)
[17:42:09.951]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:09.951]             }
[17:42:09.951]             else {
[17:42:09.951]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:09.951]             }
[17:42:09.951]             {
[17:42:09.951]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:09.951]                   0L) {
[17:42:09.951]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:09.951]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:09.951]                   base::options(opts)
[17:42:09.951]                 }
[17:42:09.951]                 {
[17:42:09.951]                   {
[17:42:09.951]                     NULL
[17:42:09.951]                     RNGkind("Mersenne-Twister")
[17:42:09.951]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:09.951]                       inherits = FALSE)
[17:42:09.951]                   }
[17:42:09.951]                   options(future.plan = NULL)
[17:42:09.951]                   if (is.na(NA_character_)) 
[17:42:09.951]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.951]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:09.951]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:09.951]                   {
[17:42:09.951]                     future <- SequentialFuture(..., envir = envir)
[17:42:09.951]                     if (!future$lazy) 
[17:42:09.951]                       future <- run(future)
[17:42:09.951]                     invisible(future)
[17:42:09.951]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:09.951]                 }
[17:42:09.951]             }
[17:42:09.951]         }
[17:42:09.951]     })
[17:42:09.951]     if (TRUE) {
[17:42:09.951]         base::sink(type = "output", split = FALSE)
[17:42:09.951]         if (TRUE) {
[17:42:09.951]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:09.951]         }
[17:42:09.951]         else {
[17:42:09.951]             ...future.result["stdout"] <- base::list(NULL)
[17:42:09.951]         }
[17:42:09.951]         base::close(...future.stdout)
[17:42:09.951]         ...future.stdout <- NULL
[17:42:09.951]     }
[17:42:09.951]     ...future.result$conditions <- ...future.conditions
[17:42:09.951]     ...future.result$finished <- base::Sys.time()
[17:42:09.951]     ...future.result
[17:42:09.951] }
[17:42:09.988]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.954] plan(): Setting new future strategy stack:
[17:42:09.988]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.954] List of future strategies:
[17:42:09.954] 1. sequential:
[17:42:09.954]    - args: function (..., envir = parent.frame())
[17:42:09.954]    - tweaked: FALSE
[17:42:09.954]    - call: NULL
[17:42:09.989]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.954] plan(): nbrOfWorkers() = 1
[17:42:09.989]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.955] plan(): Setting new future strategy stack:
[17:42:09.989]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.956] List of future strategies:
[17:42:09.956] 1. sequential:
[17:42:09.956]    - args: function (..., envir = parent.frame())
[17:42:09.956]    - tweaked: FALSE
[17:42:09.956]    - call: NULL
[17:42:09.989]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.956] plan(): nbrOfWorkers() = 1
[17:42:09.989]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.956] SequentialFuture started (and completed)
[17:42:09.989]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.957] - Launch lazy future ... done
[17:42:09.990]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.957] run() for ‘SequentialFuture’ ... done
[17:42:09.990]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.957] getGlobalsAndPackages() ...
[17:42:09.990]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.957] Searching for globals...
[17:42:09.990]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.958] 
[17:42:09.990]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.958] Searching for globals ... DONE
[17:42:09.990]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.958] - globals: [0] <none>
[17:42:09.991]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.958] getGlobalsAndPackages() ... DONE
[17:42:09.991]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.959] run() for ‘Future’ ...
[17:42:09.991]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.959] - state: ‘created’
[17:42:09.991]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.959] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:09.991]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.960] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:09.991]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.960] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:09.992]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.960]   - Field: ‘label’
[17:42:09.992]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.960]   - Field: ‘local’
[17:42:09.992]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.960]   - Field: ‘owner’
[17:42:09.992]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.960]   - Field: ‘envir’
[17:42:09.992]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.961]   - Field: ‘packages’
[17:42:09.992]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.961]   - Field: ‘gc’
[17:42:09.993]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.961]   - Field: ‘conditions’
[17:42:09.993]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.961]   - Field: ‘expr’
[17:42:09.993]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.961]   - Field: ‘uuid’
[17:42:09.993]  - Condition #65: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.962]   - Field: ‘seed’
[17:42:09.993]  - Condition #66: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.962]   - Field: ‘version’
[17:42:09.993]  - Condition #67: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.962]   - Field: ‘result’
[17:42:09.994]  - Condition #68: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.962]   - Field: ‘asynchronous’
[17:42:09.994]  - Condition #69: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.962]   - Field: ‘calls’
[17:42:09.994]  - Condition #70: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.962]   - Field: ‘globals’
[17:42:09.994]  - Condition #71: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.962]   - Field: ‘stdout’
[17:42:09.994]  - Condition #72: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.963]   - Field: ‘earlySignal’
[17:42:09.994]  - Condition #73: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.963]   - Field: ‘lazy’
[17:42:09.995]  - Condition #74: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.963]   - Field: ‘state’
[17:42:09.995]  - Condition #75: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.963] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:09.995]  - Condition #76: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.963] - Launch lazy future ...
[17:42:09.995]  - Condition #77: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.964] Packages needed by the future expression (n = 0): <none>
[17:42:09.995]  - Condition #78: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.964] Packages needed by future strategies (n = 0): <none>
[17:42:09.995]  - Condition #79: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.964] {
[17:42:09.964]     {
[17:42:09.964]         {
[17:42:09.964]             ...future.startTime <- base::Sys.time()
[17:42:09.964]             {
[17:42:09.964]                 {
[17:42:09.964]                   {
[17:42:09.964]                     base::local({
[17:42:09.964]                       has_future <- base::requireNamespace("future", 
[17:42:09.964]                         quietly = TRUE)
[17:42:09.964]                       if (has_future) {
[17:42:09.964]                         ns <- base::getNamespace("future")
[17:42:09.964]                         version <- ns[[".package"]][["version"]]
[17:42:09.964]                         if (is.null(version)) 
[17:42:09.964]                           version <- utils::packageVersion("future")
[17:42:09.964]                       }
[17:42:09.964]                       else {
[17:42:09.964]                         version <- NULL
[17:42:09.964]                       }
[17:42:09.964]                       if (!has_future || version < "1.8.0") {
[17:42:09.964]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:09.964]                           "", base::R.version$version.string), 
[17:42:09.964]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:09.964]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:09.964]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:09.964]                             "release", "version")], collapse = " "), 
[17:42:09.964]                           hostname = base::Sys.info()[["nodename"]])
[17:42:09.964]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:09.964]                           info)
[17:42:09.964]                         info <- base::paste(info, collapse = "; ")
[17:42:09.964]                         if (!has_future) {
[17:42:09.964]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:09.964]                             info)
[17:42:09.964]                         }
[17:42:09.964]                         else {
[17:42:09.964]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:09.964]                             info, version)
[17:42:09.964]                         }
[17:42:09.964]                         base::stop(msg)
[17:42:09.964]                       }
[17:42:09.964]                     })
[17:42:09.964]                   }
[17:42:09.964]                   options(future.plan = NULL)
[17:42:09.964]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.964]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:09.964]                 }
[17:42:09.964]                 ...future.workdir <- getwd()
[17:42:09.964]             }
[17:42:09.964]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:09.964]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:09.964]         }
[17:42:09.964]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:09.964]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:09.964]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:09.964]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:09.964]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:09.964]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:09.964]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:09.964]             base::names(...future.oldOptions))
[17:42:09.964]     }
[17:42:09.964]     if (FALSE) {
[17:42:09.964]     }
[17:42:09.964]     else {
[17:42:09.964]         if (TRUE) {
[17:42:09.964]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:09.964]                 open = "w")
[17:42:09.964]         }
[17:42:09.964]         else {
[17:42:09.964]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:09.964]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:09.964]         }
[17:42:09.964]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:09.964]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:09.964]             base::sink(type = "output", split = FALSE)
[17:42:09.964]             base::close(...future.stdout)
[17:42:09.964]         }, add = TRUE)
[17:42:09.964]     }
[17:42:09.964]     ...future.frame <- base::sys.nframe()
[17:42:09.964]     ...future.conditions <- base::list()
[17:42:09.964]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:09.964]     if (FALSE) {
[17:42:09.964]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:09.964]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:09.964]     }
[17:42:09.964]     ...future.result <- base::tryCatch({
[17:42:09.964]         base::withCallingHandlers({
[17:42:09.964]             ...future.value <- base::withVisible(base::local(4))
[17:42:09.964]             future::FutureResult(value = ...future.value$value, 
[17:42:09.964]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.964]                   ...future.rng), globalenv = if (FALSE) 
[17:42:09.964]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:09.964]                     ...future.globalenv.names))
[17:42:09.964]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:09.964]         }, condition = base::local({
[17:42:09.964]             c <- base::c
[17:42:09.964]             inherits <- base::inherits
[17:42:09.964]             invokeRestart <- base::invokeRestart
[17:42:09.964]             length <- base::length
[17:42:09.964]             list <- base::list
[17:42:09.964]             seq.int <- base::seq.int
[17:42:09.964]             signalCondition <- base::signalCondition
[17:42:09.964]             sys.calls <- base::sys.calls
[17:42:09.964]             `[[` <- base::`[[`
[17:42:09.964]             `+` <- base::`+`
[17:42:09.964]             `<<-` <- base::`<<-`
[17:42:09.964]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:09.964]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:09.964]                   3L)]
[17:42:09.964]             }
[17:42:09.964]             function(cond) {
[17:42:09.964]                 is_error <- inherits(cond, "error")
[17:42:09.964]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:09.964]                   NULL)
[17:42:09.964]                 if (is_error) {
[17:42:09.964]                   sessionInformation <- function() {
[17:42:09.964]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:09.964]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:09.964]                       search = base::search(), system = base::Sys.info())
[17:42:09.964]                   }
[17:42:09.964]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.964]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:09.964]                     cond$call), session = sessionInformation(), 
[17:42:09.964]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:09.964]                   signalCondition(cond)
[17:42:09.964]                 }
[17:42:09.964]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:09.964]                 "immediateCondition"))) {
[17:42:09.964]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:09.964]                   ...future.conditions[[length(...future.conditions) + 
[17:42:09.964]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:09.964]                   if (TRUE && !signal) {
[17:42:09.964]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.964]                     {
[17:42:09.964]                       inherits <- base::inherits
[17:42:09.964]                       invokeRestart <- base::invokeRestart
[17:42:09.964]                       is.null <- base::is.null
[17:42:09.964]                       muffled <- FALSE
[17:42:09.964]                       if (inherits(cond, "message")) {
[17:42:09.964]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.964]                         if (muffled) 
[17:42:09.964]                           invokeRestart("muffleMessage")
[17:42:09.964]                       }
[17:42:09.964]                       else if (inherits(cond, "warning")) {
[17:42:09.964]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.964]                         if (muffled) 
[17:42:09.964]                           invokeRestart("muffleWarning")
[17:42:09.964]                       }
[17:42:09.964]                       else if (inherits(cond, "condition")) {
[17:42:09.964]                         if (!is.null(pattern)) {
[17:42:09.964]                           computeRestarts <- base::computeRestarts
[17:42:09.964]                           grepl <- base::grepl
[17:42:09.964]                           restarts <- computeRestarts(cond)
[17:42:09.964]                           for (restart in restarts) {
[17:42:09.964]                             name <- restart$name
[17:42:09.964]                             if (is.null(name)) 
[17:42:09.964]                               next
[17:42:09.964]                             if (!grepl(pattern, name)) 
[17:42:09.964]                               next
[17:42:09.964]                             invokeRestart(restart)
[17:42:09.964]                             muffled <- TRUE
[17:42:09.964]                             break
[17:42:09.964]                           }
[17:42:09.964]                         }
[17:42:09.964]                       }
[17:42:09.964]                       invisible(muffled)
[17:42:09.964]                     }
[17:42:09.964]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.964]                   }
[17:42:09.964]                 }
[17:42:09.964]                 else {
[17:42:09.964]                   if (TRUE) {
[17:42:09.964]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:09.964]                     {
[17:42:09.964]                       inherits <- base::inherits
[17:42:09.964]                       invokeRestart <- base::invokeRestart
[17:42:09.964]                       is.null <- base::is.null
[17:42:09.964]                       muffled <- FALSE
[17:42:09.964]                       if (inherits(cond, "message")) {
[17:42:09.964]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:09.964]                         if (muffled) 
[17:42:09.964]                           invokeRestart("muffleMessage")
[17:42:09.964]                       }
[17:42:09.964]                       else if (inherits(cond, "warning")) {
[17:42:09.964]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:09.964]                         if (muffled) 
[17:42:09.964]                           invokeRestart("muffleWarning")
[17:42:09.964]                       }
[17:42:09.964]                       else if (inherits(cond, "condition")) {
[17:42:09.964]                         if (!is.null(pattern)) {
[17:42:09.964]                           computeRestarts <- base::computeRestarts
[17:42:09.964]                           grepl <- base::grepl
[17:42:09.964]                           restarts <- computeRestarts(cond)
[17:42:09.964]                           for (restart in restarts) {
[17:42:09.964]                             name <- restart$name
[17:42:09.964]                             if (is.null(name)) 
[17:42:09.964]                               next
[17:42:09.964]                             if (!grepl(pattern, name)) 
[17:42:09.964]                               next
[17:42:09.964]                             invokeRestart(restart)
[17:42:09.964]                             muffled <- TRUE
[17:42:09.964]                             break
[17:42:09.964]                           }
[17:42:09.964]                         }
[17:42:09.964]                       }
[17:42:09.964]                       invisible(muffled)
[17:42:09.964]                     }
[17:42:09.964]                     muffleCondition(cond, pattern = "^muffle")
[17:42:09.964]                   }
[17:42:09.964]                 }
[17:42:09.964]             }
[17:42:09.964]         }))
[17:42:09.964]     }, error = function(ex) {
[17:42:09.964]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:09.964]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:09.964]                 ...future.rng), started = ...future.startTime, 
[17:42:09.964]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:09.964]             version = "1.8"), class = "FutureResult")
[17:42:09.964]     }, finally = {
[17:42:09.964]         if (!identical(...future.workdir, getwd())) 
[17:42:09.964]             setwd(...future.workdir)
[17:42:09.964]         {
[17:42:09.964]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:09.964]                 ...future.oldOptions$nwarnings <- NULL
[17:42:09.964]             }
[17:42:09.964]             base::options(...future.oldOptions)
[17:42:09.964]             if (.Platform$OS.type == "windows") {
[17:42:09.964]                 old_names <- names(...future.oldEnvVars)
[17:42:09.964]                 envs <- base::Sys.getenv()
[17:42:09.964]                 names <- names(envs)
[17:42:09.964]                 common <- intersect(names, old_names)
[17:42:09.964]                 added <- setdiff(names, old_names)
[17:42:09.964]                 removed <- setdiff(old_names, names)
[17:42:09.964]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:09.964]                   envs[common]]
[17:42:09.964]                 NAMES <- toupper(changed)
[17:42:09.964]                 args <- list()
[17:42:09.964]                 for (kk in seq_along(NAMES)) {
[17:42:09.964]                   name <- changed[[kk]]
[17:42:09.964]                   NAME <- NAMES[[kk]]
[17:42:09.964]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.964]                     next
[17:42:09.964]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.964]                 }
[17:42:09.964]                 NAMES <- toupper(added)
[17:42:09.964]                 for (kk in seq_along(NAMES)) {
[17:42:09.964]                   name <- added[[kk]]
[17:42:09.964]                   NAME <- NAMES[[kk]]
[17:42:09.964]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.964]                     next
[17:42:09.964]                   args[[name]] <- ""
[17:42:09.964]                 }
[17:42:09.964]                 NAMES <- toupper(removed)
[17:42:09.964]                 for (kk in seq_along(NAMES)) {
[17:42:09.964]                   name <- removed[[kk]]
[17:42:09.964]                   NAME <- NAMES[[kk]]
[17:42:09.964]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:09.964]                     next
[17:42:09.964]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:09.964]                 }
[17:42:09.964]                 if (length(args) > 0) 
[17:42:09.964]                   base::do.call(base::Sys.setenv, args = args)
[17:42:09.964]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:09.964]             }
[17:42:09.964]             else {
[17:42:09.964]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:09.964]             }
[17:42:09.964]             {
[17:42:09.964]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:09.964]                   0L) {
[17:42:09.964]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:09.964]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:09.964]                   base::options(opts)
[17:42:09.964]                 }
[17:42:09.964]                 {
[17:42:09.964]                   {
[17:42:09.964]                     NULL
[17:42:09.964]                     RNGkind("Mersenne-Twister")
[17:42:09.964]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:09.964]                       inherits = FALSE)
[17:42:09.964]                   }
[17:42:09.964]                   options(future.plan = NULL)
[17:42:09.964]                   if (is.na(NA_character_)) 
[17:42:09.964]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:09.964]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:09.964]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:09.964]                   {
[17:42:09.964]                     future <- SequentialFuture(..., envir = envir)
[17:42:09.964]                     if (!future$lazy) 
[17:42:09.964]                       future <- run(future)
[17:42:09.964]                     invisible(future)
[17:42:09.964]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:09.964]                 }
[17:42:09.964]             }
[17:42:09.964]         }
[17:42:09.964]     })
[17:42:09.964]     if (TRUE) {
[17:42:09.964]         base::sink(type = "output", split = FALSE)
[17:42:09.964]         if (TRUE) {
[17:42:09.964]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:09.964]         }
[17:42:09.964]         else {
[17:42:09.964]             ...future.result["stdout"] <- base::list(NULL)
[17:42:09.964]         }
[17:42:09.964]         base::close(...future.stdout)
[17:42:09.964]         ...future.stdout <- NULL
[17:42:09.964]     }
[17:42:09.964]     ...future.result$conditions <- ...future.conditions
[17:42:09.964]     ...future.result$finished <- base::Sys.time()
[17:42:09.964]     ...future.result
[17:42:09.964] }
[17:42:09.996]  - Condition #80: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.967] plan(): Setting new future strategy stack:
[17:42:09.996]  - Condition #81: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.967] List of future strategies:
[17:42:09.967] 1. sequential:
[17:42:09.967]    - args: function (..., envir = parent.frame())
[17:42:09.967]    - tweaked: FALSE
[17:42:09.967]    - call: NULL
[17:42:09.996]  - Condition #82: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.967] plan(): nbrOfWorkers() = 1
[17:42:09.996]  - Condition #83: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.968] plan(): Setting new future strategy stack:
[17:42:09.996]  - Condition #84: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.968] List of future strategies:
[17:42:09.968] 1. sequential:
[17:42:09.968]    - args: function (..., envir = parent.frame())
[17:42:09.968]    - tweaked: FALSE
[17:42:09.968]    - call: NULL
[17:42:09.996]  - Condition #85: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.969] plan(): nbrOfWorkers() = 1
[17:42:09.997]  - Condition #86: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.969] SequentialFuture started (and completed)
[17:42:09.997]  - Condition #87: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.969] - Launch lazy future ... done
[17:42:09.997]  - Condition #88: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:09.970] run() for ‘SequentialFuture’ ... done
[17:42:09.997] signalConditions() ... done
a = 10
[17:42:09.997] getGlobalsAndPackages() ...
[17:42:09.998] Searching for globals...
[17:42:09.999] - globals found: [3] ‘{’, ‘+’, ‘a’
[17:42:09.999] Searching for globals ... DONE
[17:42:09.999] Resolving globals: FALSE
[17:42:10.000] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:10.000] The total size of the 1 globals exported for future expression (‘{; a + 1; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[17:42:10.000] - globals: [1] ‘a’
[17:42:10.000] 
[17:42:10.000] getGlobalsAndPackages() ... DONE
[17:42:10.001] run() for ‘Future’ ...
[17:42:10.001] - state: ‘created’
[17:42:10.001] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:10.005] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:10.005] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:10.005]   - Field: ‘label’
[17:42:10.005]   - Field: ‘local’
[17:42:10.008]   - Field: ‘owner’
[17:42:10.008]   - Field: ‘envir’
[17:42:10.008]   - Field: ‘workers’
[17:42:10.008]   - Field: ‘packages’
[17:42:10.008]   - Field: ‘gc’
[17:42:10.008]   - Field: ‘job’
[17:42:10.008]   - Field: ‘conditions’
[17:42:10.008]   - Field: ‘expr’
[17:42:10.008]   - Field: ‘uuid’
[17:42:10.009]   - Field: ‘seed’
[17:42:10.009]   - Field: ‘version’
[17:42:10.009]   - Field: ‘result’
[17:42:10.009]   - Field: ‘asynchronous’
[17:42:10.009]   - Field: ‘calls’
[17:42:10.009]   - Field: ‘globals’
[17:42:10.009]   - Field: ‘stdout’
[17:42:10.009]   - Field: ‘earlySignal’
[17:42:10.009]   - Field: ‘lazy’
[17:42:10.009]   - Field: ‘state’
[17:42:10.010] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:10.010] - Launch lazy future ...
[17:42:10.010] Packages needed by the future expression (n = 0): <none>
[17:42:10.010] Packages needed by future strategies (n = 0): <none>
[17:42:10.011] {
[17:42:10.011]     {
[17:42:10.011]         {
[17:42:10.011]             ...future.startTime <- base::Sys.time()
[17:42:10.011]             {
[17:42:10.011]                 {
[17:42:10.011]                   {
[17:42:10.011]                     {
[17:42:10.011]                       base::local({
[17:42:10.011]                         has_future <- base::requireNamespace("future", 
[17:42:10.011]                           quietly = TRUE)
[17:42:10.011]                         if (has_future) {
[17:42:10.011]                           ns <- base::getNamespace("future")
[17:42:10.011]                           version <- ns[[".package"]][["version"]]
[17:42:10.011]                           if (is.null(version)) 
[17:42:10.011]                             version <- utils::packageVersion("future")
[17:42:10.011]                         }
[17:42:10.011]                         else {
[17:42:10.011]                           version <- NULL
[17:42:10.011]                         }
[17:42:10.011]                         if (!has_future || version < "1.8.0") {
[17:42:10.011]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:10.011]                             "", base::R.version$version.string), 
[17:42:10.011]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:10.011]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:10.011]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:10.011]                               "release", "version")], collapse = " "), 
[17:42:10.011]                             hostname = base::Sys.info()[["nodename"]])
[17:42:10.011]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:10.011]                             info)
[17:42:10.011]                           info <- base::paste(info, collapse = "; ")
[17:42:10.011]                           if (!has_future) {
[17:42:10.011]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:10.011]                               info)
[17:42:10.011]                           }
[17:42:10.011]                           else {
[17:42:10.011]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:10.011]                               info, version)
[17:42:10.011]                           }
[17:42:10.011]                           base::stop(msg)
[17:42:10.011]                         }
[17:42:10.011]                       })
[17:42:10.011]                     }
[17:42:10.011]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:10.011]                     base::options(mc.cores = 1L)
[17:42:10.011]                   }
[17:42:10.011]                   options(future.plan = NULL)
[17:42:10.011]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:10.011]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:10.011]                 }
[17:42:10.011]                 ...future.workdir <- getwd()
[17:42:10.011]             }
[17:42:10.011]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:10.011]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:10.011]         }
[17:42:10.011]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:10.011]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:10.011]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:10.011]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:10.011]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:10.011]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:10.011]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:10.011]             base::names(...future.oldOptions))
[17:42:10.011]     }
[17:42:10.011]     if (FALSE) {
[17:42:10.011]     }
[17:42:10.011]     else {
[17:42:10.011]         if (TRUE) {
[17:42:10.011]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:10.011]                 open = "w")
[17:42:10.011]         }
[17:42:10.011]         else {
[17:42:10.011]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:10.011]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:10.011]         }
[17:42:10.011]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:10.011]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:10.011]             base::sink(type = "output", split = FALSE)
[17:42:10.011]             base::close(...future.stdout)
[17:42:10.011]         }, add = TRUE)
[17:42:10.011]     }
[17:42:10.011]     ...future.frame <- base::sys.nframe()
[17:42:10.011]     ...future.conditions <- base::list()
[17:42:10.011]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:10.011]     if (FALSE) {
[17:42:10.011]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:10.011]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:10.011]     }
[17:42:10.011]     ...future.result <- base::tryCatch({
[17:42:10.011]         base::withCallingHandlers({
[17:42:10.011]             ...future.value <- base::withVisible(base::local({
[17:42:10.011]                 withCallingHandlers({
[17:42:10.011]                   {
[17:42:10.011]                     a + 1
[17:42:10.011]                   }
[17:42:10.011]                 }, immediateCondition = function(cond) {
[17:42:10.011]                   save_rds <- function (object, pathname, ...) 
[17:42:10.011]                   {
[17:42:10.011]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:10.011]                     if (file_test("-f", pathname_tmp)) {
[17:42:10.011]                       fi_tmp <- file.info(pathname_tmp)
[17:42:10.011]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:10.011]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:10.011]                         fi_tmp[["mtime"]])
[17:42:10.011]                     }
[17:42:10.011]                     tryCatch({
[17:42:10.011]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:10.011]                     }, error = function(ex) {
[17:42:10.011]                       msg <- conditionMessage(ex)
[17:42:10.011]                       fi_tmp <- file.info(pathname_tmp)
[17:42:10.011]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:10.011]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:10.011]                         fi_tmp[["mtime"]], msg)
[17:42:10.011]                       ex$message <- msg
[17:42:10.011]                       stop(ex)
[17:42:10.011]                     })
[17:42:10.011]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:10.011]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:10.011]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:10.011]                       fi_tmp <- file.info(pathname_tmp)
[17:42:10.011]                       fi <- file.info(pathname)
[17:42:10.011]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:10.011]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:10.011]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:10.011]                         fi[["size"]], fi[["mtime"]])
[17:42:10.011]                       stop(msg)
[17:42:10.011]                     }
[17:42:10.011]                     invisible(pathname)
[17:42:10.011]                   }
[17:42:10.011]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:10.011]                     rootPath = tempdir()) 
[17:42:10.011]                   {
[17:42:10.011]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:10.011]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:10.011]                       tmpdir = path, fileext = ".rds")
[17:42:10.011]                     save_rds(obj, file)
[17:42:10.011]                   }
[17:42:10.011]                   saveImmediateCondition(cond, path = "/tmp/RtmpZwB2Ue/.future/immediateConditions")
[17:42:10.011]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:10.011]                   {
[17:42:10.011]                     inherits <- base::inherits
[17:42:10.011]                     invokeRestart <- base::invokeRestart
[17:42:10.011]                     is.null <- base::is.null
[17:42:10.011]                     muffled <- FALSE
[17:42:10.011]                     if (inherits(cond, "message")) {
[17:42:10.011]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:10.011]                       if (muffled) 
[17:42:10.011]                         invokeRestart("muffleMessage")
[17:42:10.011]                     }
[17:42:10.011]                     else if (inherits(cond, "warning")) {
[17:42:10.011]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:10.011]                       if (muffled) 
[17:42:10.011]                         invokeRestart("muffleWarning")
[17:42:10.011]                     }
[17:42:10.011]                     else if (inherits(cond, "condition")) {
[17:42:10.011]                       if (!is.null(pattern)) {
[17:42:10.011]                         computeRestarts <- base::computeRestarts
[17:42:10.011]                         grepl <- base::grepl
[17:42:10.011]                         restarts <- computeRestarts(cond)
[17:42:10.011]                         for (restart in restarts) {
[17:42:10.011]                           name <- restart$name
[17:42:10.011]                           if (is.null(name)) 
[17:42:10.011]                             next
[17:42:10.011]                           if (!grepl(pattern, name)) 
[17:42:10.011]                             next
[17:42:10.011]                           invokeRestart(restart)
[17:42:10.011]                           muffled <- TRUE
[17:42:10.011]                           break
[17:42:10.011]                         }
[17:42:10.011]                       }
[17:42:10.011]                     }
[17:42:10.011]                     invisible(muffled)
[17:42:10.011]                   }
[17:42:10.011]                   muffleCondition(cond)
[17:42:10.011]                 })
[17:42:10.011]             }))
[17:42:10.011]             future::FutureResult(value = ...future.value$value, 
[17:42:10.011]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:10.011]                   ...future.rng), globalenv = if (FALSE) 
[17:42:10.011]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:10.011]                     ...future.globalenv.names))
[17:42:10.011]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:10.011]         }, condition = base::local({
[17:42:10.011]             c <- base::c
[17:42:10.011]             inherits <- base::inherits
[17:42:10.011]             invokeRestart <- base::invokeRestart
[17:42:10.011]             length <- base::length
[17:42:10.011]             list <- base::list
[17:42:10.011]             seq.int <- base::seq.int
[17:42:10.011]             signalCondition <- base::signalCondition
[17:42:10.011]             sys.calls <- base::sys.calls
[17:42:10.011]             `[[` <- base::`[[`
[17:42:10.011]             `+` <- base::`+`
[17:42:10.011]             `<<-` <- base::`<<-`
[17:42:10.011]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:10.011]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:10.011]                   3L)]
[17:42:10.011]             }
[17:42:10.011]             function(cond) {
[17:42:10.011]                 is_error <- inherits(cond, "error")
[17:42:10.011]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:10.011]                   NULL)
[17:42:10.011]                 if (is_error) {
[17:42:10.011]                   sessionInformation <- function() {
[17:42:10.011]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:10.011]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:10.011]                       search = base::search(), system = base::Sys.info())
[17:42:10.011]                   }
[17:42:10.011]                   ...future.conditions[[length(...future.conditions) + 
[17:42:10.011]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:10.011]                     cond$call), session = sessionInformation(), 
[17:42:10.011]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:10.011]                   signalCondition(cond)
[17:42:10.011]                 }
[17:42:10.011]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:10.011]                 "immediateCondition"))) {
[17:42:10.011]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:10.011]                   ...future.conditions[[length(...future.conditions) + 
[17:42:10.011]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:10.011]                   if (TRUE && !signal) {
[17:42:10.011]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:10.011]                     {
[17:42:10.011]                       inherits <- base::inherits
[17:42:10.011]                       invokeRestart <- base::invokeRestart
[17:42:10.011]                       is.null <- base::is.null
[17:42:10.011]                       muffled <- FALSE
[17:42:10.011]                       if (inherits(cond, "message")) {
[17:42:10.011]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:10.011]                         if (muffled) 
[17:42:10.011]                           invokeRestart("muffleMessage")
[17:42:10.011]                       }
[17:42:10.011]                       else if (inherits(cond, "warning")) {
[17:42:10.011]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:10.011]                         if (muffled) 
[17:42:10.011]                           invokeRestart("muffleWarning")
[17:42:10.011]                       }
[17:42:10.011]                       else if (inherits(cond, "condition")) {
[17:42:10.011]                         if (!is.null(pattern)) {
[17:42:10.011]                           computeRestarts <- base::computeRestarts
[17:42:10.011]                           grepl <- base::grepl
[17:42:10.011]                           restarts <- computeRestarts(cond)
[17:42:10.011]                           for (restart in restarts) {
[17:42:10.011]                             name <- restart$name
[17:42:10.011]                             if (is.null(name)) 
[17:42:10.011]                               next
[17:42:10.011]                             if (!grepl(pattern, name)) 
[17:42:10.011]                               next
[17:42:10.011]                             invokeRestart(restart)
[17:42:10.011]                             muffled <- TRUE
[17:42:10.011]                             break
[17:42:10.011]                           }
[17:42:10.011]                         }
[17:42:10.011]                       }
[17:42:10.011]                       invisible(muffled)
[17:42:10.011]                     }
[17:42:10.011]                     muffleCondition(cond, pattern = "^muffle")
[17:42:10.011]                   }
[17:42:10.011]                 }
[17:42:10.011]                 else {
[17:42:10.011]                   if (TRUE) {
[17:42:10.011]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:10.011]                     {
[17:42:10.011]                       inherits <- base::inherits
[17:42:10.011]                       invokeRestart <- base::invokeRestart
[17:42:10.011]                       is.null <- base::is.null
[17:42:10.011]                       muffled <- FALSE
[17:42:10.011]                       if (inherits(cond, "message")) {
[17:42:10.011]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:10.011]                         if (muffled) 
[17:42:10.011]                           invokeRestart("muffleMessage")
[17:42:10.011]                       }
[17:42:10.011]                       else if (inherits(cond, "warning")) {
[17:42:10.011]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:10.011]                         if (muffled) 
[17:42:10.011]                           invokeRestart("muffleWarning")
[17:42:10.011]                       }
[17:42:10.011]                       else if (inherits(cond, "condition")) {
[17:42:10.011]                         if (!is.null(pattern)) {
[17:42:10.011]                           computeRestarts <- base::computeRestarts
[17:42:10.011]                           grepl <- base::grepl
[17:42:10.011]                           restarts <- computeRestarts(cond)
[17:42:10.011]                           for (restart in restarts) {
[17:42:10.011]                             name <- restart$name
[17:42:10.011]                             if (is.null(name)) 
[17:42:10.011]                               next
[17:42:10.011]                             if (!grepl(pattern, name)) 
[17:42:10.011]                               next
[17:42:10.011]                             invokeRestart(restart)
[17:42:10.011]                             muffled <- TRUE
[17:42:10.011]                             break
[17:42:10.011]                           }
[17:42:10.011]                         }
[17:42:10.011]                       }
[17:42:10.011]                       invisible(muffled)
[17:42:10.011]                     }
[17:42:10.011]                     muffleCondition(cond, pattern = "^muffle")
[17:42:10.011]                   }
[17:42:10.011]                 }
[17:42:10.011]             }
[17:42:10.011]         }))
[17:42:10.011]     }, error = function(ex) {
[17:42:10.011]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:10.011]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:10.011]                 ...future.rng), started = ...future.startTime, 
[17:42:10.011]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:10.011]             version = "1.8"), class = "FutureResult")
[17:42:10.011]     }, finally = {
[17:42:10.011]         if (!identical(...future.workdir, getwd())) 
[17:42:10.011]             setwd(...future.workdir)
[17:42:10.011]         {
[17:42:10.011]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:10.011]                 ...future.oldOptions$nwarnings <- NULL
[17:42:10.011]             }
[17:42:10.011]             base::options(...future.oldOptions)
[17:42:10.011]             if (.Platform$OS.type == "windows") {
[17:42:10.011]                 old_names <- names(...future.oldEnvVars)
[17:42:10.011]                 envs <- base::Sys.getenv()
[17:42:10.011]                 names <- names(envs)
[17:42:10.011]                 common <- intersect(names, old_names)
[17:42:10.011]                 added <- setdiff(names, old_names)
[17:42:10.011]                 removed <- setdiff(old_names, names)
[17:42:10.011]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:10.011]                   envs[common]]
[17:42:10.011]                 NAMES <- toupper(changed)
[17:42:10.011]                 args <- list()
[17:42:10.011]                 for (kk in seq_along(NAMES)) {
[17:42:10.011]                   name <- changed[[kk]]
[17:42:10.011]                   NAME <- NAMES[[kk]]
[17:42:10.011]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:10.011]                     next
[17:42:10.011]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:10.011]                 }
[17:42:10.011]                 NAMES <- toupper(added)
[17:42:10.011]                 for (kk in seq_along(NAMES)) {
[17:42:10.011]                   name <- added[[kk]]
[17:42:10.011]                   NAME <- NAMES[[kk]]
[17:42:10.011]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:10.011]                     next
[17:42:10.011]                   args[[name]] <- ""
[17:42:10.011]                 }
[17:42:10.011]                 NAMES <- toupper(removed)
[17:42:10.011]                 for (kk in seq_along(NAMES)) {
[17:42:10.011]                   name <- removed[[kk]]
[17:42:10.011]                   NAME <- NAMES[[kk]]
[17:42:10.011]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:10.011]                     next
[17:42:10.011]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:10.011]                 }
[17:42:10.011]                 if (length(args) > 0) 
[17:42:10.011]                   base::do.call(base::Sys.setenv, args = args)
[17:42:10.011]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:10.011]             }
[17:42:10.011]             else {
[17:42:10.011]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:10.011]             }
[17:42:10.011]             {
[17:42:10.011]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:10.011]                   0L) {
[17:42:10.011]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:10.011]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:10.011]                   base::options(opts)
[17:42:10.011]                 }
[17:42:10.011]                 {
[17:42:10.011]                   {
[17:42:10.011]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:10.011]                     NULL
[17:42:10.011]                   }
[17:42:10.011]                   options(future.plan = NULL)
[17:42:10.011]                   if (is.na(NA_character_)) 
[17:42:10.011]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:10.011]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:10.011]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:10.011]                     envir = parent.frame()) 
[17:42:10.011]                   {
[17:42:10.011]                     default_workers <- missing(workers)
[17:42:10.011]                     if (is.function(workers)) 
[17:42:10.011]                       workers <- workers()
[17:42:10.011]                     workers <- structure(as.integer(workers), 
[17:42:10.011]                       class = class(workers))
[17:42:10.011]                     stop_if_not(is.finite(workers), workers >= 
[17:42:10.011]                       1L)
[17:42:10.011]                     if ((workers == 1L && !inherits(workers, 
[17:42:10.011]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:10.011]                       if (default_workers) 
[17:42:10.011]                         supportsMulticore(warn = TRUE)
[17:42:10.011]                       return(sequential(..., envir = envir))
[17:42:10.011]                     }
[17:42:10.011]                     oopts <- options(mc.cores = workers)
[17:42:10.011]                     on.exit(options(oopts))
[17:42:10.011]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:10.011]                       envir = envir)
[17:42:10.011]                     if (!future$lazy) 
[17:42:10.011]                       future <- run(future)
[17:42:10.011]                     invisible(future)
[17:42:10.011]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:10.011]                 }
[17:42:10.011]             }
[17:42:10.011]         }
[17:42:10.011]     })
[17:42:10.011]     if (TRUE) {
[17:42:10.011]         base::sink(type = "output", split = FALSE)
[17:42:10.011]         if (TRUE) {
[17:42:10.011]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:10.011]         }
[17:42:10.011]         else {
[17:42:10.011]             ...future.result["stdout"] <- base::list(NULL)
[17:42:10.011]         }
[17:42:10.011]         base::close(...future.stdout)
[17:42:10.011]         ...future.stdout <- NULL
[17:42:10.011]     }
[17:42:10.011]     ...future.result$conditions <- ...future.conditions
[17:42:10.011]     ...future.result$finished <- base::Sys.time()
[17:42:10.011]     ...future.result
[17:42:10.011] }
[17:42:10.013] assign_globals() ...
[17:42:10.013] List of 1
[17:42:10.013]  $ a: num 10
[17:42:10.013]  - attr(*, "where")=List of 1
[17:42:10.013]   ..$ a:<environment: R_EmptyEnv> 
[17:42:10.013]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:10.013]  - attr(*, "resolved")= logi FALSE
[17:42:10.013]  - attr(*, "total_size")= num 56
[17:42:10.013]  - attr(*, "already-done")= logi TRUE
[17:42:10.016] - copied ‘a’ to environment
[17:42:10.016] assign_globals() ... done
[17:42:10.016] requestCore(): workers = 2
[17:42:10.018] MulticoreFuture started
[17:42:10.019] - Launch lazy future ... done
[17:42:10.019] run() for ‘MulticoreFuture’ ... done
[17:42:10.019] plan(): Setting new future strategy stack:
[17:42:10.020] List of future strategies:
[17:42:10.020] 1. sequential:
[17:42:10.020]    - args: function (..., envir = parent.frame())
[17:42:10.020]    - tweaked: FALSE
[17:42:10.020]    - call: NULL
[17:42:10.021] plan(): nbrOfWorkers() = 1
[17:42:10.023] plan(): Setting new future strategy stack:
[17:42:10.023] List of future strategies:
[17:42:10.023] 1. multicore:
[17:42:10.023]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:10.023]    - tweaked: FALSE
[17:42:10.023]    - call: plan(strategy)
[17:42:10.028] plan(): nbrOfWorkers() = 2
b = 11
*** %<-% with ‘multicore’ futures ... DONE
*** %<-% with ‘multisession’ futures ...
[17:42:10.030] plan(): Setting new future strategy stack:
[17:42:10.030] List of future strategies:
[17:42:10.030] 1. multisession:
[17:42:10.030]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:42:10.030]    - tweaked: FALSE
[17:42:10.030]    - call: plan(strategy)
[17:42:10.030] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:42:10.031] multisession:
[17:42:10.031] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:42:10.031] - tweaked: FALSE
[17:42:10.031] - call: plan(strategy)
[17:42:10.038] getGlobalsAndPackages() ...
[17:42:10.038] Not searching for globals
[17:42:10.038] - globals: [0] <none>
[17:42:10.038] getGlobalsAndPackages() ... DONE
[17:42:10.039] [local output] makeClusterPSOCK() ...
[17:42:10.084] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:42:10.089] [local output] Base port: 11976
[17:42:10.090] [local output] Getting setup options for 2 cluster nodes ...
[17:42:10.090] [local output]  - Node 1 of 2 ...
[17:42:10.090] [local output] localMachine=TRUE => revtunnel=FALSE

[17:42:10.091] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpZwB2Ue/worker.rank=1.parallelly.parent=43768.aaf81a20e370.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpZwB2Ue/worker.rank=1.parallelly.parent=43768.aaf81a20e370.pid")'’
[17:42:10.282] - Possible to infer worker's PID: TRUE
[17:42:10.283] [local output] Rscript port: 11976

[17:42:10.283] [local output]  - Node 2 of 2 ...
[17:42:10.284] [local output] localMachine=TRUE => revtunnel=FALSE

[17:42:10.284] [local output] Rscript port: 11976

[17:42:10.284] [local output] Getting setup options for 2 cluster nodes ... done
[17:42:10.285] [local output]  - Parallel setup requested for some PSOCK nodes
[17:42:10.285] [local output] Setting up PSOCK nodes in parallel
[17:42:10.285] List of 36
[17:42:10.285]  $ worker          : chr "localhost"
[17:42:10.285]   ..- attr(*, "localhost")= logi TRUE
[17:42:10.285]  $ master          : chr "localhost"
[17:42:10.285]  $ port            : int 11976
[17:42:10.285]  $ connectTimeout  : num 120
[17:42:10.285]  $ timeout         : num 2592000
[17:42:10.285]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:42:10.285]  $ homogeneous     : logi TRUE
[17:42:10.285]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:42:10.285]  $ rscript_envs    : NULL
[17:42:10.285]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:42:10.285]  $ rscript_startup : NULL
[17:42:10.285]  $ rscript_sh      : chr "sh"
[17:42:10.285]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:42:10.285]  $ methods         : logi TRUE
[17:42:10.285]  $ socketOptions   : chr "no-delay"
[17:42:10.285]  $ useXDR          : logi FALSE
[17:42:10.285]  $ outfile         : chr "/dev/null"
[17:42:10.285]  $ renice          : int NA
[17:42:10.285]  $ rshcmd          : NULL
[17:42:10.285]  $ user            : chr(0) 
[17:42:10.285]  $ revtunnel       : logi FALSE
[17:42:10.285]  $ rshlogfile      : NULL
[17:42:10.285]  $ rshopts         : chr(0) 
[17:42:10.285]  $ rank            : int 1
[17:42:10.285]  $ manual          : logi FALSE
[17:42:10.285]  $ dryrun          : logi FALSE
[17:42:10.285]  $ quiet           : logi FALSE
[17:42:10.285]  $ setup_strategy  : chr "parallel"
[17:42:10.285]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:42:10.285]  $ pidfile         : chr "/tmp/RtmpZwB2Ue/worker.rank=1.parallelly.parent=43768.aaf81a20e370.pid"
[17:42:10.285]  $ rshcmd_label    : NULL
[17:42:10.285]  $ rsh_call        : NULL
[17:42:10.285]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:42:10.285]  $ localMachine    : logi TRUE
[17:42:10.285]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:42:10.285]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:42:10.285]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:42:10.285]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:42:10.285]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:42:10.285]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:42:10.285]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:42:10.285]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:42:10.285]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:42:10.285]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:42:10.285]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:42:10.285]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:42:10.285]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:42:10.285]  $ arguments       :List of 28
[17:42:10.285]   ..$ worker          : chr "localhost"
[17:42:10.285]   ..$ master          : NULL
[17:42:10.285]   ..$ port            : int 11976
[17:42:10.285]   ..$ connectTimeout  : num 120
[17:42:10.285]   ..$ timeout         : num 2592000
[17:42:10.285]   ..$ rscript         : NULL
[17:42:10.285]   ..$ homogeneous     : NULL
[17:42:10.285]   ..$ rscript_args    : NULL
[17:42:10.285]   ..$ rscript_envs    : NULL
[17:42:10.285]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:42:10.285]   ..$ rscript_startup : NULL
[17:42:10.285]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:42:10.285]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:42:10.285]   ..$ methods         : logi TRUE
[17:42:10.285]   ..$ socketOptions   : chr "no-delay"
[17:42:10.285]   ..$ useXDR          : logi FALSE
[17:42:10.285]   ..$ outfile         : chr "/dev/null"
[17:42:10.285]   ..$ renice          : int NA
[17:42:10.285]   ..$ rshcmd          : NULL
[17:42:10.285]   ..$ user            : NULL
[17:42:10.285]   ..$ revtunnel       : logi NA
[17:42:10.285]   ..$ rshlogfile      : NULL
[17:42:10.285]   ..$ rshopts         : NULL
[17:42:10.285]   ..$ rank            : int 1
[17:42:10.285]   ..$ manual          : logi FALSE
[17:42:10.285]   ..$ dryrun          : logi FALSE
[17:42:10.285]   ..$ quiet           : logi FALSE
[17:42:10.285]   ..$ setup_strategy  : chr "parallel"
[17:42:10.285]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:42:10.303] [local output] System call to launch all workers:
[17:42:10.303] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpZwB2Ue/worker.rank=1.parallelly.parent=43768.aaf81a20e370.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11976 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:42:10.303] [local output] Starting PSOCK main server
[17:42:10.305] [local output] Workers launched
[17:42:10.305] [local output] Waiting for workers to connect back
[17:42:10.305]  - [local output] 0 workers out of 2 ready
[17:42:10.549]  - [local output] 0 workers out of 2 ready
[17:42:10.550]  - [local output] 1 workers out of 2 ready
[17:42:10.550]  - [local output] 2 workers out of 2 ready
[17:42:10.550] [local output] Launching of workers completed
[17:42:10.551] [local output] Collecting session information from workers
[17:42:10.551] [local output]  - Worker #1 of 2
[17:42:10.552] [local output]  - Worker #2 of 2
[17:42:10.552] [local output] makeClusterPSOCK() ... done
[17:42:10.564] Packages needed by the future expression (n = 0): <none>
[17:42:10.564] Packages needed by future strategies (n = 0): <none>
[17:42:10.565] {
[17:42:10.565]     {
[17:42:10.565]         {
[17:42:10.565]             ...future.startTime <- base::Sys.time()
[17:42:10.565]             {
[17:42:10.565]                 {
[17:42:10.565]                   {
[17:42:10.565]                     {
[17:42:10.565]                       base::local({
[17:42:10.565]                         has_future <- base::requireNamespace("future", 
[17:42:10.565]                           quietly = TRUE)
[17:42:10.565]                         if (has_future) {
[17:42:10.565]                           ns <- base::getNamespace("future")
[17:42:10.565]                           version <- ns[[".package"]][["version"]]
[17:42:10.565]                           if (is.null(version)) 
[17:42:10.565]                             version <- utils::packageVersion("future")
[17:42:10.565]                         }
[17:42:10.565]                         else {
[17:42:10.565]                           version <- NULL
[17:42:10.565]                         }
[17:42:10.565]                         if (!has_future || version < "1.8.0") {
[17:42:10.565]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:10.565]                             "", base::R.version$version.string), 
[17:42:10.565]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:10.565]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:10.565]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:10.565]                               "release", "version")], collapse = " "), 
[17:42:10.565]                             hostname = base::Sys.info()[["nodename"]])
[17:42:10.565]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:10.565]                             info)
[17:42:10.565]                           info <- base::paste(info, collapse = "; ")
[17:42:10.565]                           if (!has_future) {
[17:42:10.565]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:10.565]                               info)
[17:42:10.565]                           }
[17:42:10.565]                           else {
[17:42:10.565]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:10.565]                               info, version)
[17:42:10.565]                           }
[17:42:10.565]                           base::stop(msg)
[17:42:10.565]                         }
[17:42:10.565]                       })
[17:42:10.565]                     }
[17:42:10.565]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:10.565]                     base::options(mc.cores = 1L)
[17:42:10.565]                   }
[17:42:10.565]                   options(future.plan = NULL)
[17:42:10.565]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:10.565]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:10.565]                 }
[17:42:10.565]                 ...future.workdir <- getwd()
[17:42:10.565]             }
[17:42:10.565]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:10.565]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:10.565]         }
[17:42:10.565]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:10.565]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:10.565]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:10.565]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:10.565]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:10.565]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:10.565]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:10.565]             base::names(...future.oldOptions))
[17:42:10.565]     }
[17:42:10.565]     if (FALSE) {
[17:42:10.565]     }
[17:42:10.565]     else {
[17:42:10.565]         if (TRUE) {
[17:42:10.565]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:10.565]                 open = "w")
[17:42:10.565]         }
[17:42:10.565]         else {
[17:42:10.565]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:10.565]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:10.565]         }
[17:42:10.565]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:10.565]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:10.565]             base::sink(type = "output", split = FALSE)
[17:42:10.565]             base::close(...future.stdout)
[17:42:10.565]         }, add = TRUE)
[17:42:10.565]     }
[17:42:10.565]     ...future.frame <- base::sys.nframe()
[17:42:10.565]     ...future.conditions <- base::list()
[17:42:10.565]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:10.565]     if (FALSE) {
[17:42:10.565]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:10.565]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:10.565]     }
[17:42:10.565]     ...future.result <- base::tryCatch({
[17:42:10.565]         base::withCallingHandlers({
[17:42:10.565]             ...future.value <- base::withVisible(base::local({
[17:42:10.565]                 ...future.makeSendCondition <- local({
[17:42:10.565]                   sendCondition <- NULL
[17:42:10.565]                   function(frame = 1L) {
[17:42:10.565]                     if (is.function(sendCondition)) 
[17:42:10.565]                       return(sendCondition)
[17:42:10.565]                     ns <- getNamespace("parallel")
[17:42:10.565]                     if (exists("sendData", mode = "function", 
[17:42:10.565]                       envir = ns)) {
[17:42:10.565]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:10.565]                         envir = ns)
[17:42:10.565]                       envir <- sys.frame(frame)
[17:42:10.565]                       master <- NULL
[17:42:10.565]                       while (!identical(envir, .GlobalEnv) && 
[17:42:10.565]                         !identical(envir, emptyenv())) {
[17:42:10.565]                         if (exists("master", mode = "list", envir = envir, 
[17:42:10.565]                           inherits = FALSE)) {
[17:42:10.565]                           master <- get("master", mode = "list", 
[17:42:10.565]                             envir = envir, inherits = FALSE)
[17:42:10.565]                           if (inherits(master, c("SOCKnode", 
[17:42:10.565]                             "SOCK0node"))) {
[17:42:10.565]                             sendCondition <<- function(cond) {
[17:42:10.565]                               data <- list(type = "VALUE", value = cond, 
[17:42:10.565]                                 success = TRUE)
[17:42:10.565]                               parallel_sendData(master, data)
[17:42:10.565]                             }
[17:42:10.565]                             return(sendCondition)
[17:42:10.565]                           }
[17:42:10.565]                         }
[17:42:10.565]                         frame <- frame + 1L
[17:42:10.565]                         envir <- sys.frame(frame)
[17:42:10.565]                       }
[17:42:10.565]                     }
[17:42:10.565]                     sendCondition <<- function(cond) NULL
[17:42:10.565]                   }
[17:42:10.565]                 })
[17:42:10.565]                 withCallingHandlers({
[17:42:10.565]                   NA
[17:42:10.565]                 }, immediateCondition = function(cond) {
[17:42:10.565]                   sendCondition <- ...future.makeSendCondition()
[17:42:10.565]                   sendCondition(cond)
[17:42:10.565]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:10.565]                   {
[17:42:10.565]                     inherits <- base::inherits
[17:42:10.565]                     invokeRestart <- base::invokeRestart
[17:42:10.565]                     is.null <- base::is.null
[17:42:10.565]                     muffled <- FALSE
[17:42:10.565]                     if (inherits(cond, "message")) {
[17:42:10.565]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:10.565]                       if (muffled) 
[17:42:10.565]                         invokeRestart("muffleMessage")
[17:42:10.565]                     }
[17:42:10.565]                     else if (inherits(cond, "warning")) {
[17:42:10.565]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:10.565]                       if (muffled) 
[17:42:10.565]                         invokeRestart("muffleWarning")
[17:42:10.565]                     }
[17:42:10.565]                     else if (inherits(cond, "condition")) {
[17:42:10.565]                       if (!is.null(pattern)) {
[17:42:10.565]                         computeRestarts <- base::computeRestarts
[17:42:10.565]                         grepl <- base::grepl
[17:42:10.565]                         restarts <- computeRestarts(cond)
[17:42:10.565]                         for (restart in restarts) {
[17:42:10.565]                           name <- restart$name
[17:42:10.565]                           if (is.null(name)) 
[17:42:10.565]                             next
[17:42:10.565]                           if (!grepl(pattern, name)) 
[17:42:10.565]                             next
[17:42:10.565]                           invokeRestart(restart)
[17:42:10.565]                           muffled <- TRUE
[17:42:10.565]                           break
[17:42:10.565]                         }
[17:42:10.565]                       }
[17:42:10.565]                     }
[17:42:10.565]                     invisible(muffled)
[17:42:10.565]                   }
[17:42:10.565]                   muffleCondition(cond)
[17:42:10.565]                 })
[17:42:10.565]             }))
[17:42:10.565]             future::FutureResult(value = ...future.value$value, 
[17:42:10.565]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:10.565]                   ...future.rng), globalenv = if (FALSE) 
[17:42:10.565]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:10.565]                     ...future.globalenv.names))
[17:42:10.565]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:10.565]         }, condition = base::local({
[17:42:10.565]             c <- base::c
[17:42:10.565]             inherits <- base::inherits
[17:42:10.565]             invokeRestart <- base::invokeRestart
[17:42:10.565]             length <- base::length
[17:42:10.565]             list <- base::list
[17:42:10.565]             seq.int <- base::seq.int
[17:42:10.565]             signalCondition <- base::signalCondition
[17:42:10.565]             sys.calls <- base::sys.calls
[17:42:10.565]             `[[` <- base::`[[`
[17:42:10.565]             `+` <- base::`+`
[17:42:10.565]             `<<-` <- base::`<<-`
[17:42:10.565]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:10.565]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:10.565]                   3L)]
[17:42:10.565]             }
[17:42:10.565]             function(cond) {
[17:42:10.565]                 is_error <- inherits(cond, "error")
[17:42:10.565]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:10.565]                   NULL)
[17:42:10.565]                 if (is_error) {
[17:42:10.565]                   sessionInformation <- function() {
[17:42:10.565]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:10.565]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:10.565]                       search = base::search(), system = base::Sys.info())
[17:42:10.565]                   }
[17:42:10.565]                   ...future.conditions[[length(...future.conditions) + 
[17:42:10.565]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:10.565]                     cond$call), session = sessionInformation(), 
[17:42:10.565]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:10.565]                   signalCondition(cond)
[17:42:10.565]                 }
[17:42:10.565]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:10.565]                 "immediateCondition"))) {
[17:42:10.565]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:10.565]                   ...future.conditions[[length(...future.conditions) + 
[17:42:10.565]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:10.565]                   if (TRUE && !signal) {
[17:42:10.565]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:10.565]                     {
[17:42:10.565]                       inherits <- base::inherits
[17:42:10.565]                       invokeRestart <- base::invokeRestart
[17:42:10.565]                       is.null <- base::is.null
[17:42:10.565]                       muffled <- FALSE
[17:42:10.565]                       if (inherits(cond, "message")) {
[17:42:10.565]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:10.565]                         if (muffled) 
[17:42:10.565]                           invokeRestart("muffleMessage")
[17:42:10.565]                       }
[17:42:10.565]                       else if (inherits(cond, "warning")) {
[17:42:10.565]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:10.565]                         if (muffled) 
[17:42:10.565]                           invokeRestart("muffleWarning")
[17:42:10.565]                       }
[17:42:10.565]                       else if (inherits(cond, "condition")) {
[17:42:10.565]                         if (!is.null(pattern)) {
[17:42:10.565]                           computeRestarts <- base::computeRestarts
[17:42:10.565]                           grepl <- base::grepl
[17:42:10.565]                           restarts <- computeRestarts(cond)
[17:42:10.565]                           for (restart in restarts) {
[17:42:10.565]                             name <- restart$name
[17:42:10.565]                             if (is.null(name)) 
[17:42:10.565]                               next
[17:42:10.565]                             if (!grepl(pattern, name)) 
[17:42:10.565]                               next
[17:42:10.565]                             invokeRestart(restart)
[17:42:10.565]                             muffled <- TRUE
[17:42:10.565]                             break
[17:42:10.565]                           }
[17:42:10.565]                         }
[17:42:10.565]                       }
[17:42:10.565]                       invisible(muffled)
[17:42:10.565]                     }
[17:42:10.565]                     muffleCondition(cond, pattern = "^muffle")
[17:42:10.565]                   }
[17:42:10.565]                 }
[17:42:10.565]                 else {
[17:42:10.565]                   if (TRUE) {
[17:42:10.565]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:10.565]                     {
[17:42:10.565]                       inherits <- base::inherits
[17:42:10.565]                       invokeRestart <- base::invokeRestart
[17:42:10.565]                       is.null <- base::is.null
[17:42:10.565]                       muffled <- FALSE
[17:42:10.565]                       if (inherits(cond, "message")) {
[17:42:10.565]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:10.565]                         if (muffled) 
[17:42:10.565]                           invokeRestart("muffleMessage")
[17:42:10.565]                       }
[17:42:10.565]                       else if (inherits(cond, "warning")) {
[17:42:10.565]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:10.565]                         if (muffled) 
[17:42:10.565]                           invokeRestart("muffleWarning")
[17:42:10.565]                       }
[17:42:10.565]                       else if (inherits(cond, "condition")) {
[17:42:10.565]                         if (!is.null(pattern)) {
[17:42:10.565]                           computeRestarts <- base::computeRestarts
[17:42:10.565]                           grepl <- base::grepl
[17:42:10.565]                           restarts <- computeRestarts(cond)
[17:42:10.565]                           for (restart in restarts) {
[17:42:10.565]                             name <- restart$name
[17:42:10.565]                             if (is.null(name)) 
[17:42:10.565]                               next
[17:42:10.565]                             if (!grepl(pattern, name)) 
[17:42:10.565]                               next
[17:42:10.565]                             invokeRestart(restart)
[17:42:10.565]                             muffled <- TRUE
[17:42:10.565]                             break
[17:42:10.565]                           }
[17:42:10.565]                         }
[17:42:10.565]                       }
[17:42:10.565]                       invisible(muffled)
[17:42:10.565]                     }
[17:42:10.565]                     muffleCondition(cond, pattern = "^muffle")
[17:42:10.565]                   }
[17:42:10.565]                 }
[17:42:10.565]             }
[17:42:10.565]         }))
[17:42:10.565]     }, error = function(ex) {
[17:42:10.565]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:10.565]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:10.565]                 ...future.rng), started = ...future.startTime, 
[17:42:10.565]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:10.565]             version = "1.8"), class = "FutureResult")
[17:42:10.565]     }, finally = {
[17:42:10.565]         if (!identical(...future.workdir, getwd())) 
[17:42:10.565]             setwd(...future.workdir)
[17:42:10.565]         {
[17:42:10.565]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:10.565]                 ...future.oldOptions$nwarnings <- NULL
[17:42:10.565]             }
[17:42:10.565]             base::options(...future.oldOptions)
[17:42:10.565]             if (.Platform$OS.type == "windows") {
[17:42:10.565]                 old_names <- names(...future.oldEnvVars)
[17:42:10.565]                 envs <- base::Sys.getenv()
[17:42:10.565]                 names <- names(envs)
[17:42:10.565]                 common <- intersect(names, old_names)
[17:42:10.565]                 added <- setdiff(names, old_names)
[17:42:10.565]                 removed <- setdiff(old_names, names)
[17:42:10.565]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:10.565]                   envs[common]]
[17:42:10.565]                 NAMES <- toupper(changed)
[17:42:10.565]                 args <- list()
[17:42:10.565]                 for (kk in seq_along(NAMES)) {
[17:42:10.565]                   name <- changed[[kk]]
[17:42:10.565]                   NAME <- NAMES[[kk]]
[17:42:10.565]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:10.565]                     next
[17:42:10.565]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:10.565]                 }
[17:42:10.565]                 NAMES <- toupper(added)
[17:42:10.565]                 for (kk in seq_along(NAMES)) {
[17:42:10.565]                   name <- added[[kk]]
[17:42:10.565]                   NAME <- NAMES[[kk]]
[17:42:10.565]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:10.565]                     next
[17:42:10.565]                   args[[name]] <- ""
[17:42:10.565]                 }
[17:42:10.565]                 NAMES <- toupper(removed)
[17:42:10.565]                 for (kk in seq_along(NAMES)) {
[17:42:10.565]                   name <- removed[[kk]]
[17:42:10.565]                   NAME <- NAMES[[kk]]
[17:42:10.565]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:10.565]                     next
[17:42:10.565]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:10.565]                 }
[17:42:10.565]                 if (length(args) > 0) 
[17:42:10.565]                   base::do.call(base::Sys.setenv, args = args)
[17:42:10.565]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:10.565]             }
[17:42:10.565]             else {
[17:42:10.565]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:10.565]             }
[17:42:10.565]             {
[17:42:10.565]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:10.565]                   0L) {
[17:42:10.565]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:10.565]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:10.565]                   base::options(opts)
[17:42:10.565]                 }
[17:42:10.565]                 {
[17:42:10.565]                   {
[17:42:10.565]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:10.565]                     NULL
[17:42:10.565]                   }
[17:42:10.565]                   options(future.plan = NULL)
[17:42:10.565]                   if (is.na(NA_character_)) 
[17:42:10.565]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:10.565]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:10.565]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:10.565]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:10.565]                     envir = parent.frame()) 
[17:42:10.565]                   {
[17:42:10.565]                     if (is.function(workers)) 
[17:42:10.565]                       workers <- workers()
[17:42:10.565]                     workers <- structure(as.integer(workers), 
[17:42:10.565]                       class = class(workers))
[17:42:10.565]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:10.565]                       workers >= 1)
[17:42:10.565]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:10.565]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:10.565]                     }
[17:42:10.565]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:10.565]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:10.565]                       envir = envir)
[17:42:10.565]                     if (!future$lazy) 
[17:42:10.565]                       future <- run(future)
[17:42:10.565]                     invisible(future)
[17:42:10.565]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:10.565]                 }
[17:42:10.565]             }
[17:42:10.565]         }
[17:42:10.565]     })
[17:42:10.565]     if (TRUE) {
[17:42:10.565]         base::sink(type = "output", split = FALSE)
[17:42:10.565]         if (TRUE) {
[17:42:10.565]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:10.565]         }
[17:42:10.565]         else {
[17:42:10.565]             ...future.result["stdout"] <- base::list(NULL)
[17:42:10.565]         }
[17:42:10.565]         base::close(...future.stdout)
[17:42:10.565]         ...future.stdout <- NULL
[17:42:10.565]     }
[17:42:10.565]     ...future.result$conditions <- ...future.conditions
[17:42:10.565]     ...future.result$finished <- base::Sys.time()
[17:42:10.565]     ...future.result
[17:42:10.565] }
[17:42:10.638] MultisessionFuture started
[17:42:10.638] result() for ClusterFuture ...
[17:42:10.639] receiveMessageFromWorker() for ClusterFuture ...
[17:42:10.639] - Validating connection of MultisessionFuture
[17:42:10.671] - received message: FutureResult
[17:42:10.672] - Received FutureResult
[17:42:10.672] - Erased future from FutureRegistry
[17:42:10.672] result() for ClusterFuture ...
[17:42:10.672] - result already collected: FutureResult
[17:42:10.672] result() for ClusterFuture ... done
[17:42:10.672] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:10.672] result() for ClusterFuture ... done
[17:42:10.672] result() for ClusterFuture ...
[17:42:10.673] - result already collected: FutureResult
[17:42:10.673] result() for ClusterFuture ... done
[17:42:10.673] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:42:10.677] plan(): nbrOfWorkers() = 2
** Future evaluation without globals
[17:42:10.677] getGlobalsAndPackages() ...
[17:42:10.677] Searching for globals...
[17:42:10.678] - globals found: [2] ‘{’, ‘<-’
[17:42:10.679] Searching for globals ... DONE
[17:42:10.679] Resolving globals: FALSE
[17:42:10.679] 
[17:42:10.679] 
[17:42:10.679] getGlobalsAndPackages() ... DONE
[17:42:10.680] run() for ‘Future’ ...
[17:42:10.680] - state: ‘created’
[17:42:10.680] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:10.695] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:10.695] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:10.695]   - Field: ‘node’
[17:42:10.695]   - Field: ‘label’
[17:42:10.695]   - Field: ‘local’
[17:42:10.696]   - Field: ‘owner’
[17:42:10.696]   - Field: ‘envir’
[17:42:10.696]   - Field: ‘workers’
[17:42:10.696]   - Field: ‘packages’
[17:42:10.696]   - Field: ‘gc’
[17:42:10.696]   - Field: ‘conditions’
[17:42:10.696]   - Field: ‘persistent’
[17:42:10.696]   - Field: ‘expr’
[17:42:10.696]   - Field: ‘uuid’
[17:42:10.697]   - Field: ‘seed’
[17:42:10.697]   - Field: ‘version’
[17:42:10.697]   - Field: ‘result’
[17:42:10.697]   - Field: ‘asynchronous’
[17:42:10.697]   - Field: ‘calls’
[17:42:10.697]   - Field: ‘globals’
[17:42:10.697]   - Field: ‘stdout’
[17:42:10.697]   - Field: ‘earlySignal’
[17:42:10.697]   - Field: ‘lazy’
[17:42:10.698]   - Field: ‘state’
[17:42:10.698] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:10.698] - Launch lazy future ...
[17:42:10.698] Packages needed by the future expression (n = 0): <none>
[17:42:10.698] Packages needed by future strategies (n = 0): <none>
[17:42:10.699] {
[17:42:10.699]     {
[17:42:10.699]         {
[17:42:10.699]             ...future.startTime <- base::Sys.time()
[17:42:10.699]             {
[17:42:10.699]                 {
[17:42:10.699]                   {
[17:42:10.699]                     {
[17:42:10.699]                       base::local({
[17:42:10.699]                         has_future <- base::requireNamespace("future", 
[17:42:10.699]                           quietly = TRUE)
[17:42:10.699]                         if (has_future) {
[17:42:10.699]                           ns <- base::getNamespace("future")
[17:42:10.699]                           version <- ns[[".package"]][["version"]]
[17:42:10.699]                           if (is.null(version)) 
[17:42:10.699]                             version <- utils::packageVersion("future")
[17:42:10.699]                         }
[17:42:10.699]                         else {
[17:42:10.699]                           version <- NULL
[17:42:10.699]                         }
[17:42:10.699]                         if (!has_future || version < "1.8.0") {
[17:42:10.699]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:10.699]                             "", base::R.version$version.string), 
[17:42:10.699]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:10.699]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:10.699]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:10.699]                               "release", "version")], collapse = " "), 
[17:42:10.699]                             hostname = base::Sys.info()[["nodename"]])
[17:42:10.699]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:10.699]                             info)
[17:42:10.699]                           info <- base::paste(info, collapse = "; ")
[17:42:10.699]                           if (!has_future) {
[17:42:10.699]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:10.699]                               info)
[17:42:10.699]                           }
[17:42:10.699]                           else {
[17:42:10.699]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:10.699]                               info, version)
[17:42:10.699]                           }
[17:42:10.699]                           base::stop(msg)
[17:42:10.699]                         }
[17:42:10.699]                       })
[17:42:10.699]                     }
[17:42:10.699]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:10.699]                     base::options(mc.cores = 1L)
[17:42:10.699]                   }
[17:42:10.699]                   options(future.plan = NULL)
[17:42:10.699]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:10.699]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:10.699]                 }
[17:42:10.699]                 ...future.workdir <- getwd()
[17:42:10.699]             }
[17:42:10.699]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:10.699]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:10.699]         }
[17:42:10.699]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:10.699]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:10.699]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:10.699]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:10.699]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:10.699]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:10.699]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:10.699]             base::names(...future.oldOptions))
[17:42:10.699]     }
[17:42:10.699]     if (FALSE) {
[17:42:10.699]     }
[17:42:10.699]     else {
[17:42:10.699]         if (TRUE) {
[17:42:10.699]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:10.699]                 open = "w")
[17:42:10.699]         }
[17:42:10.699]         else {
[17:42:10.699]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:10.699]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:10.699]         }
[17:42:10.699]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:10.699]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:10.699]             base::sink(type = "output", split = FALSE)
[17:42:10.699]             base::close(...future.stdout)
[17:42:10.699]         }, add = TRUE)
[17:42:10.699]     }
[17:42:10.699]     ...future.frame <- base::sys.nframe()
[17:42:10.699]     ...future.conditions <- base::list()
[17:42:10.699]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:10.699]     if (FALSE) {
[17:42:10.699]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:10.699]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:10.699]     }
[17:42:10.699]     ...future.result <- base::tryCatch({
[17:42:10.699]         base::withCallingHandlers({
[17:42:10.699]             ...future.value <- base::withVisible(base::local({
[17:42:10.699]                 ...future.makeSendCondition <- local({
[17:42:10.699]                   sendCondition <- NULL
[17:42:10.699]                   function(frame = 1L) {
[17:42:10.699]                     if (is.function(sendCondition)) 
[17:42:10.699]                       return(sendCondition)
[17:42:10.699]                     ns <- getNamespace("parallel")
[17:42:10.699]                     if (exists("sendData", mode = "function", 
[17:42:10.699]                       envir = ns)) {
[17:42:10.699]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:10.699]                         envir = ns)
[17:42:10.699]                       envir <- sys.frame(frame)
[17:42:10.699]                       master <- NULL
[17:42:10.699]                       while (!identical(envir, .GlobalEnv) && 
[17:42:10.699]                         !identical(envir, emptyenv())) {
[17:42:10.699]                         if (exists("master", mode = "list", envir = envir, 
[17:42:10.699]                           inherits = FALSE)) {
[17:42:10.699]                           master <- get("master", mode = "list", 
[17:42:10.699]                             envir = envir, inherits = FALSE)
[17:42:10.699]                           if (inherits(master, c("SOCKnode", 
[17:42:10.699]                             "SOCK0node"))) {
[17:42:10.699]                             sendCondition <<- function(cond) {
[17:42:10.699]                               data <- list(type = "VALUE", value = cond, 
[17:42:10.699]                                 success = TRUE)
[17:42:10.699]                               parallel_sendData(master, data)
[17:42:10.699]                             }
[17:42:10.699]                             return(sendCondition)
[17:42:10.699]                           }
[17:42:10.699]                         }
[17:42:10.699]                         frame <- frame + 1L
[17:42:10.699]                         envir <- sys.frame(frame)
[17:42:10.699]                       }
[17:42:10.699]                     }
[17:42:10.699]                     sendCondition <<- function(cond) NULL
[17:42:10.699]                   }
[17:42:10.699]                 })
[17:42:10.699]                 withCallingHandlers({
[17:42:10.699]                   {
[17:42:10.699]                     x <- 1
[17:42:10.699]                   }
[17:42:10.699]                 }, immediateCondition = function(cond) {
[17:42:10.699]                   sendCondition <- ...future.makeSendCondition()
[17:42:10.699]                   sendCondition(cond)
[17:42:10.699]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:10.699]                   {
[17:42:10.699]                     inherits <- base::inherits
[17:42:10.699]                     invokeRestart <- base::invokeRestart
[17:42:10.699]                     is.null <- base::is.null
[17:42:10.699]                     muffled <- FALSE
[17:42:10.699]                     if (inherits(cond, "message")) {
[17:42:10.699]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:10.699]                       if (muffled) 
[17:42:10.699]                         invokeRestart("muffleMessage")
[17:42:10.699]                     }
[17:42:10.699]                     else if (inherits(cond, "warning")) {
[17:42:10.699]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:10.699]                       if (muffled) 
[17:42:10.699]                         invokeRestart("muffleWarning")
[17:42:10.699]                     }
[17:42:10.699]                     else if (inherits(cond, "condition")) {
[17:42:10.699]                       if (!is.null(pattern)) {
[17:42:10.699]                         computeRestarts <- base::computeRestarts
[17:42:10.699]                         grepl <- base::grepl
[17:42:10.699]                         restarts <- computeRestarts(cond)
[17:42:10.699]                         for (restart in restarts) {
[17:42:10.699]                           name <- restart$name
[17:42:10.699]                           if (is.null(name)) 
[17:42:10.699]                             next
[17:42:10.699]                           if (!grepl(pattern, name)) 
[17:42:10.699]                             next
[17:42:10.699]                           invokeRestart(restart)
[17:42:10.699]                           muffled <- TRUE
[17:42:10.699]                           break
[17:42:10.699]                         }
[17:42:10.699]                       }
[17:42:10.699]                     }
[17:42:10.699]                     invisible(muffled)
[17:42:10.699]                   }
[17:42:10.699]                   muffleCondition(cond)
[17:42:10.699]                 })
[17:42:10.699]             }))
[17:42:10.699]             future::FutureResult(value = ...future.value$value, 
[17:42:10.699]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:10.699]                   ...future.rng), globalenv = if (FALSE) 
[17:42:10.699]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:10.699]                     ...future.globalenv.names))
[17:42:10.699]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:10.699]         }, condition = base::local({
[17:42:10.699]             c <- base::c
[17:42:10.699]             inherits <- base::inherits
[17:42:10.699]             invokeRestart <- base::invokeRestart
[17:42:10.699]             length <- base::length
[17:42:10.699]             list <- base::list
[17:42:10.699]             seq.int <- base::seq.int
[17:42:10.699]             signalCondition <- base::signalCondition
[17:42:10.699]             sys.calls <- base::sys.calls
[17:42:10.699]             `[[` <- base::`[[`
[17:42:10.699]             `+` <- base::`+`
[17:42:10.699]             `<<-` <- base::`<<-`
[17:42:10.699]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:10.699]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:10.699]                   3L)]
[17:42:10.699]             }
[17:42:10.699]             function(cond) {
[17:42:10.699]                 is_error <- inherits(cond, "error")
[17:42:10.699]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:10.699]                   NULL)
[17:42:10.699]                 if (is_error) {
[17:42:10.699]                   sessionInformation <- function() {
[17:42:10.699]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:10.699]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:10.699]                       search = base::search(), system = base::Sys.info())
[17:42:10.699]                   }
[17:42:10.699]                   ...future.conditions[[length(...future.conditions) + 
[17:42:10.699]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:10.699]                     cond$call), session = sessionInformation(), 
[17:42:10.699]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:10.699]                   signalCondition(cond)
[17:42:10.699]                 }
[17:42:10.699]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:10.699]                 "immediateCondition"))) {
[17:42:10.699]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:10.699]                   ...future.conditions[[length(...future.conditions) + 
[17:42:10.699]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:10.699]                   if (TRUE && !signal) {
[17:42:10.699]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:10.699]                     {
[17:42:10.699]                       inherits <- base::inherits
[17:42:10.699]                       invokeRestart <- base::invokeRestart
[17:42:10.699]                       is.null <- base::is.null
[17:42:10.699]                       muffled <- FALSE
[17:42:10.699]                       if (inherits(cond, "message")) {
[17:42:10.699]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:10.699]                         if (muffled) 
[17:42:10.699]                           invokeRestart("muffleMessage")
[17:42:10.699]                       }
[17:42:10.699]                       else if (inherits(cond, "warning")) {
[17:42:10.699]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:10.699]                         if (muffled) 
[17:42:10.699]                           invokeRestart("muffleWarning")
[17:42:10.699]                       }
[17:42:10.699]                       else if (inherits(cond, "condition")) {
[17:42:10.699]                         if (!is.null(pattern)) {
[17:42:10.699]                           computeRestarts <- base::computeRestarts
[17:42:10.699]                           grepl <- base::grepl
[17:42:10.699]                           restarts <- computeRestarts(cond)
[17:42:10.699]                           for (restart in restarts) {
[17:42:10.699]                             name <- restart$name
[17:42:10.699]                             if (is.null(name)) 
[17:42:10.699]                               next
[17:42:10.699]                             if (!grepl(pattern, name)) 
[17:42:10.699]                               next
[17:42:10.699]                             invokeRestart(restart)
[17:42:10.699]                             muffled <- TRUE
[17:42:10.699]                             break
[17:42:10.699]                           }
[17:42:10.699]                         }
[17:42:10.699]                       }
[17:42:10.699]                       invisible(muffled)
[17:42:10.699]                     }
[17:42:10.699]                     muffleCondition(cond, pattern = "^muffle")
[17:42:10.699]                   }
[17:42:10.699]                 }
[17:42:10.699]                 else {
[17:42:10.699]                   if (TRUE) {
[17:42:10.699]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:10.699]                     {
[17:42:10.699]                       inherits <- base::inherits
[17:42:10.699]                       invokeRestart <- base::invokeRestart
[17:42:10.699]                       is.null <- base::is.null
[17:42:10.699]                       muffled <- FALSE
[17:42:10.699]                       if (inherits(cond, "message")) {
[17:42:10.699]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:10.699]                         if (muffled) 
[17:42:10.699]                           invokeRestart("muffleMessage")
[17:42:10.699]                       }
[17:42:10.699]                       else if (inherits(cond, "warning")) {
[17:42:10.699]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:10.699]                         if (muffled) 
[17:42:10.699]                           invokeRestart("muffleWarning")
[17:42:10.699]                       }
[17:42:10.699]                       else if (inherits(cond, "condition")) {
[17:42:10.699]                         if (!is.null(pattern)) {
[17:42:10.699]                           computeRestarts <- base::computeRestarts
[17:42:10.699]                           grepl <- base::grepl
[17:42:10.699]                           restarts <- computeRestarts(cond)
[17:42:10.699]                           for (restart in restarts) {
[17:42:10.699]                             name <- restart$name
[17:42:10.699]                             if (is.null(name)) 
[17:42:10.699]                               next
[17:42:10.699]                             if (!grepl(pattern, name)) 
[17:42:10.699]                               next
[17:42:10.699]                             invokeRestart(restart)
[17:42:10.699]                             muffled <- TRUE
[17:42:10.699]                             break
[17:42:10.699]                           }
[17:42:10.699]                         }
[17:42:10.699]                       }
[17:42:10.699]                       invisible(muffled)
[17:42:10.699]                     }
[17:42:10.699]                     muffleCondition(cond, pattern = "^muffle")
[17:42:10.699]                   }
[17:42:10.699]                 }
[17:42:10.699]             }
[17:42:10.699]         }))
[17:42:10.699]     }, error = function(ex) {
[17:42:10.699]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:10.699]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:10.699]                 ...future.rng), started = ...future.startTime, 
[17:42:10.699]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:10.699]             version = "1.8"), class = "FutureResult")
[17:42:10.699]     }, finally = {
[17:42:10.699]         if (!identical(...future.workdir, getwd())) 
[17:42:10.699]             setwd(...future.workdir)
[17:42:10.699]         {
[17:42:10.699]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:10.699]                 ...future.oldOptions$nwarnings <- NULL
[17:42:10.699]             }
[17:42:10.699]             base::options(...future.oldOptions)
[17:42:10.699]             if (.Platform$OS.type == "windows") {
[17:42:10.699]                 old_names <- names(...future.oldEnvVars)
[17:42:10.699]                 envs <- base::Sys.getenv()
[17:42:10.699]                 names <- names(envs)
[17:42:10.699]                 common <- intersect(names, old_names)
[17:42:10.699]                 added <- setdiff(names, old_names)
[17:42:10.699]                 removed <- setdiff(old_names, names)
[17:42:10.699]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:10.699]                   envs[common]]
[17:42:10.699]                 NAMES <- toupper(changed)
[17:42:10.699]                 args <- list()
[17:42:10.699]                 for (kk in seq_along(NAMES)) {
[17:42:10.699]                   name <- changed[[kk]]
[17:42:10.699]                   NAME <- NAMES[[kk]]
[17:42:10.699]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:10.699]                     next
[17:42:10.699]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:10.699]                 }
[17:42:10.699]                 NAMES <- toupper(added)
[17:42:10.699]                 for (kk in seq_along(NAMES)) {
[17:42:10.699]                   name <- added[[kk]]
[17:42:10.699]                   NAME <- NAMES[[kk]]
[17:42:10.699]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:10.699]                     next
[17:42:10.699]                   args[[name]] <- ""
[17:42:10.699]                 }
[17:42:10.699]                 NAMES <- toupper(removed)
[17:42:10.699]                 for (kk in seq_along(NAMES)) {
[17:42:10.699]                   name <- removed[[kk]]
[17:42:10.699]                   NAME <- NAMES[[kk]]
[17:42:10.699]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:10.699]                     next
[17:42:10.699]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:10.699]                 }
[17:42:10.699]                 if (length(args) > 0) 
[17:42:10.699]                   base::do.call(base::Sys.setenv, args = args)
[17:42:10.699]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:10.699]             }
[17:42:10.699]             else {
[17:42:10.699]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:10.699]             }
[17:42:10.699]             {
[17:42:10.699]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:10.699]                   0L) {
[17:42:10.699]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:10.699]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:10.699]                   base::options(opts)
[17:42:10.699]                 }
[17:42:10.699]                 {
[17:42:10.699]                   {
[17:42:10.699]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:10.699]                     NULL
[17:42:10.699]                   }
[17:42:10.699]                   options(future.plan = NULL)
[17:42:10.699]                   if (is.na(NA_character_)) 
[17:42:10.699]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:10.699]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:10.699]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:10.699]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:10.699]                     envir = parent.frame()) 
[17:42:10.699]                   {
[17:42:10.699]                     if (is.function(workers)) 
[17:42:10.699]                       workers <- workers()
[17:42:10.699]                     workers <- structure(as.integer(workers), 
[17:42:10.699]                       class = class(workers))
[17:42:10.699]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:10.699]                       workers >= 1)
[17:42:10.699]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:10.699]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:10.699]                     }
[17:42:10.699]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:10.699]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:10.699]                       envir = envir)
[17:42:10.699]                     if (!future$lazy) 
[17:42:10.699]                       future <- run(future)
[17:42:10.699]                     invisible(future)
[17:42:10.699]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:10.699]                 }
[17:42:10.699]             }
[17:42:10.699]         }
[17:42:10.699]     })
[17:42:10.699]     if (TRUE) {
[17:42:10.699]         base::sink(type = "output", split = FALSE)
[17:42:10.699]         if (TRUE) {
[17:42:10.699]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:10.699]         }
[17:42:10.699]         else {
[17:42:10.699]             ...future.result["stdout"] <- base::list(NULL)
[17:42:10.699]         }
[17:42:10.699]         base::close(...future.stdout)
[17:42:10.699]         ...future.stdout <- NULL
[17:42:10.699]     }
[17:42:10.699]     ...future.result$conditions <- ...future.conditions
[17:42:10.699]     ...future.result$finished <- base::Sys.time()
[17:42:10.699]     ...future.result
[17:42:10.699] }
[17:42:10.702] MultisessionFuture started
[17:42:10.703] - Launch lazy future ... done
[17:42:10.703] run() for ‘MultisessionFuture’ ... done
[17:42:10.703] result() for ClusterFuture ...
[17:42:10.703] receiveMessageFromWorker() for ClusterFuture ...
[17:42:10.703] - Validating connection of MultisessionFuture
[17:42:10.748] - received message: FutureResult
[17:42:10.749] - Received FutureResult
[17:42:10.749] - Erased future from FutureRegistry
[17:42:10.749] result() for ClusterFuture ...
[17:42:10.749] - result already collected: FutureResult
[17:42:10.749] result() for ClusterFuture ... done
[17:42:10.749] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:10.749] result() for ClusterFuture ... done
[17:42:10.749] result() for ClusterFuture ...
[17:42:10.750] - result already collected: FutureResult
[17:42:10.750] result() for ClusterFuture ... done
** Future evaluation with globals
[17:42:10.750] getGlobalsAndPackages() ...
[17:42:10.750] Searching for globals...
[17:42:10.752] - globals found: [3] ‘{’, ‘<-’, ‘a’
[17:42:10.752] Searching for globals ... DONE
[17:42:10.752] Resolving globals: FALSE
[17:42:10.752] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:10.753] The total size of the 1 globals exported for future expression (‘{; x <- a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[17:42:10.753] - globals: [1] ‘a’
[17:42:10.753] 
[17:42:10.753] getGlobalsAndPackages() ... DONE
[17:42:10.754] run() for ‘Future’ ...
[17:42:10.754] - state: ‘created’
[17:42:10.754] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:10.769] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:10.769] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:10.770]   - Field: ‘node’
[17:42:10.770]   - Field: ‘label’
[17:42:10.770]   - Field: ‘local’
[17:42:10.770]   - Field: ‘owner’
[17:42:10.770]   - Field: ‘envir’
[17:42:10.770]   - Field: ‘workers’
[17:42:10.770]   - Field: ‘packages’
[17:42:10.770]   - Field: ‘gc’
[17:42:10.770]   - Field: ‘conditions’
[17:42:10.771]   - Field: ‘persistent’
[17:42:10.771]   - Field: ‘expr’
[17:42:10.771]   - Field: ‘uuid’
[17:42:10.771]   - Field: ‘seed’
[17:42:10.771]   - Field: ‘version’
[17:42:10.771]   - Field: ‘result’
[17:42:10.771]   - Field: ‘asynchronous’
[17:42:10.771]   - Field: ‘calls’
[17:42:10.772]   - Field: ‘globals’
[17:42:10.772]   - Field: ‘stdout’
[17:42:10.772]   - Field: ‘earlySignal’
[17:42:10.772]   - Field: ‘lazy’
[17:42:10.772]   - Field: ‘state’
[17:42:10.772] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:10.772] - Launch lazy future ...
[17:42:10.773] Packages needed by the future expression (n = 0): <none>
[17:42:10.773] Packages needed by future strategies (n = 0): <none>
[17:42:10.773] {
[17:42:10.773]     {
[17:42:10.773]         {
[17:42:10.773]             ...future.startTime <- base::Sys.time()
[17:42:10.773]             {
[17:42:10.773]                 {
[17:42:10.773]                   {
[17:42:10.773]                     {
[17:42:10.773]                       base::local({
[17:42:10.773]                         has_future <- base::requireNamespace("future", 
[17:42:10.773]                           quietly = TRUE)
[17:42:10.773]                         if (has_future) {
[17:42:10.773]                           ns <- base::getNamespace("future")
[17:42:10.773]                           version <- ns[[".package"]][["version"]]
[17:42:10.773]                           if (is.null(version)) 
[17:42:10.773]                             version <- utils::packageVersion("future")
[17:42:10.773]                         }
[17:42:10.773]                         else {
[17:42:10.773]                           version <- NULL
[17:42:10.773]                         }
[17:42:10.773]                         if (!has_future || version < "1.8.0") {
[17:42:10.773]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:10.773]                             "", base::R.version$version.string), 
[17:42:10.773]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:10.773]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:10.773]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:10.773]                               "release", "version")], collapse = " "), 
[17:42:10.773]                             hostname = base::Sys.info()[["nodename"]])
[17:42:10.773]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:10.773]                             info)
[17:42:10.773]                           info <- base::paste(info, collapse = "; ")
[17:42:10.773]                           if (!has_future) {
[17:42:10.773]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:10.773]                               info)
[17:42:10.773]                           }
[17:42:10.773]                           else {
[17:42:10.773]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:10.773]                               info, version)
[17:42:10.773]                           }
[17:42:10.773]                           base::stop(msg)
[17:42:10.773]                         }
[17:42:10.773]                       })
[17:42:10.773]                     }
[17:42:10.773]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:10.773]                     base::options(mc.cores = 1L)
[17:42:10.773]                   }
[17:42:10.773]                   options(future.plan = NULL)
[17:42:10.773]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:10.773]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:10.773]                 }
[17:42:10.773]                 ...future.workdir <- getwd()
[17:42:10.773]             }
[17:42:10.773]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:10.773]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:10.773]         }
[17:42:10.773]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:10.773]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:10.773]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:10.773]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:10.773]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:10.773]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:10.773]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:10.773]             base::names(...future.oldOptions))
[17:42:10.773]     }
[17:42:10.773]     if (FALSE) {
[17:42:10.773]     }
[17:42:10.773]     else {
[17:42:10.773]         if (TRUE) {
[17:42:10.773]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:10.773]                 open = "w")
[17:42:10.773]         }
[17:42:10.773]         else {
[17:42:10.773]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:10.773]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:10.773]         }
[17:42:10.773]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:10.773]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:10.773]             base::sink(type = "output", split = FALSE)
[17:42:10.773]             base::close(...future.stdout)
[17:42:10.773]         }, add = TRUE)
[17:42:10.773]     }
[17:42:10.773]     ...future.frame <- base::sys.nframe()
[17:42:10.773]     ...future.conditions <- base::list()
[17:42:10.773]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:10.773]     if (FALSE) {
[17:42:10.773]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:10.773]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:10.773]     }
[17:42:10.773]     ...future.result <- base::tryCatch({
[17:42:10.773]         base::withCallingHandlers({
[17:42:10.773]             ...future.value <- base::withVisible(base::local({
[17:42:10.773]                 ...future.makeSendCondition <- local({
[17:42:10.773]                   sendCondition <- NULL
[17:42:10.773]                   function(frame = 1L) {
[17:42:10.773]                     if (is.function(sendCondition)) 
[17:42:10.773]                       return(sendCondition)
[17:42:10.773]                     ns <- getNamespace("parallel")
[17:42:10.773]                     if (exists("sendData", mode = "function", 
[17:42:10.773]                       envir = ns)) {
[17:42:10.773]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:10.773]                         envir = ns)
[17:42:10.773]                       envir <- sys.frame(frame)
[17:42:10.773]                       master <- NULL
[17:42:10.773]                       while (!identical(envir, .GlobalEnv) && 
[17:42:10.773]                         !identical(envir, emptyenv())) {
[17:42:10.773]                         if (exists("master", mode = "list", envir = envir, 
[17:42:10.773]                           inherits = FALSE)) {
[17:42:10.773]                           master <- get("master", mode = "list", 
[17:42:10.773]                             envir = envir, inherits = FALSE)
[17:42:10.773]                           if (inherits(master, c("SOCKnode", 
[17:42:10.773]                             "SOCK0node"))) {
[17:42:10.773]                             sendCondition <<- function(cond) {
[17:42:10.773]                               data <- list(type = "VALUE", value = cond, 
[17:42:10.773]                                 success = TRUE)
[17:42:10.773]                               parallel_sendData(master, data)
[17:42:10.773]                             }
[17:42:10.773]                             return(sendCondition)
[17:42:10.773]                           }
[17:42:10.773]                         }
[17:42:10.773]                         frame <- frame + 1L
[17:42:10.773]                         envir <- sys.frame(frame)
[17:42:10.773]                       }
[17:42:10.773]                     }
[17:42:10.773]                     sendCondition <<- function(cond) NULL
[17:42:10.773]                   }
[17:42:10.773]                 })
[17:42:10.773]                 withCallingHandlers({
[17:42:10.773]                   {
[17:42:10.773]                     x <- a
[17:42:10.773]                   }
[17:42:10.773]                 }, immediateCondition = function(cond) {
[17:42:10.773]                   sendCondition <- ...future.makeSendCondition()
[17:42:10.773]                   sendCondition(cond)
[17:42:10.773]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:10.773]                   {
[17:42:10.773]                     inherits <- base::inherits
[17:42:10.773]                     invokeRestart <- base::invokeRestart
[17:42:10.773]                     is.null <- base::is.null
[17:42:10.773]                     muffled <- FALSE
[17:42:10.773]                     if (inherits(cond, "message")) {
[17:42:10.773]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:10.773]                       if (muffled) 
[17:42:10.773]                         invokeRestart("muffleMessage")
[17:42:10.773]                     }
[17:42:10.773]                     else if (inherits(cond, "warning")) {
[17:42:10.773]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:10.773]                       if (muffled) 
[17:42:10.773]                         invokeRestart("muffleWarning")
[17:42:10.773]                     }
[17:42:10.773]                     else if (inherits(cond, "condition")) {
[17:42:10.773]                       if (!is.null(pattern)) {
[17:42:10.773]                         computeRestarts <- base::computeRestarts
[17:42:10.773]                         grepl <- base::grepl
[17:42:10.773]                         restarts <- computeRestarts(cond)
[17:42:10.773]                         for (restart in restarts) {
[17:42:10.773]                           name <- restart$name
[17:42:10.773]                           if (is.null(name)) 
[17:42:10.773]                             next
[17:42:10.773]                           if (!grepl(pattern, name)) 
[17:42:10.773]                             next
[17:42:10.773]                           invokeRestart(restart)
[17:42:10.773]                           muffled <- TRUE
[17:42:10.773]                           break
[17:42:10.773]                         }
[17:42:10.773]                       }
[17:42:10.773]                     }
[17:42:10.773]                     invisible(muffled)
[17:42:10.773]                   }
[17:42:10.773]                   muffleCondition(cond)
[17:42:10.773]                 })
[17:42:10.773]             }))
[17:42:10.773]             future::FutureResult(value = ...future.value$value, 
[17:42:10.773]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:10.773]                   ...future.rng), globalenv = if (FALSE) 
[17:42:10.773]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:10.773]                     ...future.globalenv.names))
[17:42:10.773]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:10.773]         }, condition = base::local({
[17:42:10.773]             c <- base::c
[17:42:10.773]             inherits <- base::inherits
[17:42:10.773]             invokeRestart <- base::invokeRestart
[17:42:10.773]             length <- base::length
[17:42:10.773]             list <- base::list
[17:42:10.773]             seq.int <- base::seq.int
[17:42:10.773]             signalCondition <- base::signalCondition
[17:42:10.773]             sys.calls <- base::sys.calls
[17:42:10.773]             `[[` <- base::`[[`
[17:42:10.773]             `+` <- base::`+`
[17:42:10.773]             `<<-` <- base::`<<-`
[17:42:10.773]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:10.773]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:10.773]                   3L)]
[17:42:10.773]             }
[17:42:10.773]             function(cond) {
[17:42:10.773]                 is_error <- inherits(cond, "error")
[17:42:10.773]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:10.773]                   NULL)
[17:42:10.773]                 if (is_error) {
[17:42:10.773]                   sessionInformation <- function() {
[17:42:10.773]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:10.773]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:10.773]                       search = base::search(), system = base::Sys.info())
[17:42:10.773]                   }
[17:42:10.773]                   ...future.conditions[[length(...future.conditions) + 
[17:42:10.773]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:10.773]                     cond$call), session = sessionInformation(), 
[17:42:10.773]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:10.773]                   signalCondition(cond)
[17:42:10.773]                 }
[17:42:10.773]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:10.773]                 "immediateCondition"))) {
[17:42:10.773]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:10.773]                   ...future.conditions[[length(...future.conditions) + 
[17:42:10.773]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:10.773]                   if (TRUE && !signal) {
[17:42:10.773]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:10.773]                     {
[17:42:10.773]                       inherits <- base::inherits
[17:42:10.773]                       invokeRestart <- base::invokeRestart
[17:42:10.773]                       is.null <- base::is.null
[17:42:10.773]                       muffled <- FALSE
[17:42:10.773]                       if (inherits(cond, "message")) {
[17:42:10.773]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:10.773]                         if (muffled) 
[17:42:10.773]                           invokeRestart("muffleMessage")
[17:42:10.773]                       }
[17:42:10.773]                       else if (inherits(cond, "warning")) {
[17:42:10.773]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:10.773]                         if (muffled) 
[17:42:10.773]                           invokeRestart("muffleWarning")
[17:42:10.773]                       }
[17:42:10.773]                       else if (inherits(cond, "condition")) {
[17:42:10.773]                         if (!is.null(pattern)) {
[17:42:10.773]                           computeRestarts <- base::computeRestarts
[17:42:10.773]                           grepl <- base::grepl
[17:42:10.773]                           restarts <- computeRestarts(cond)
[17:42:10.773]                           for (restart in restarts) {
[17:42:10.773]                             name <- restart$name
[17:42:10.773]                             if (is.null(name)) 
[17:42:10.773]                               next
[17:42:10.773]                             if (!grepl(pattern, name)) 
[17:42:10.773]                               next
[17:42:10.773]                             invokeRestart(restart)
[17:42:10.773]                             muffled <- TRUE
[17:42:10.773]                             break
[17:42:10.773]                           }
[17:42:10.773]                         }
[17:42:10.773]                       }
[17:42:10.773]                       invisible(muffled)
[17:42:10.773]                     }
[17:42:10.773]                     muffleCondition(cond, pattern = "^muffle")
[17:42:10.773]                   }
[17:42:10.773]                 }
[17:42:10.773]                 else {
[17:42:10.773]                   if (TRUE) {
[17:42:10.773]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:10.773]                     {
[17:42:10.773]                       inherits <- base::inherits
[17:42:10.773]                       invokeRestart <- base::invokeRestart
[17:42:10.773]                       is.null <- base::is.null
[17:42:10.773]                       muffled <- FALSE
[17:42:10.773]                       if (inherits(cond, "message")) {
[17:42:10.773]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:10.773]                         if (muffled) 
[17:42:10.773]                           invokeRestart("muffleMessage")
[17:42:10.773]                       }
[17:42:10.773]                       else if (inherits(cond, "warning")) {
[17:42:10.773]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:10.773]                         if (muffled) 
[17:42:10.773]                           invokeRestart("muffleWarning")
[17:42:10.773]                       }
[17:42:10.773]                       else if (inherits(cond, "condition")) {
[17:42:10.773]                         if (!is.null(pattern)) {
[17:42:10.773]                           computeRestarts <- base::computeRestarts
[17:42:10.773]                           grepl <- base::grepl
[17:42:10.773]                           restarts <- computeRestarts(cond)
[17:42:10.773]                           for (restart in restarts) {
[17:42:10.773]                             name <- restart$name
[17:42:10.773]                             if (is.null(name)) 
[17:42:10.773]                               next
[17:42:10.773]                             if (!grepl(pattern, name)) 
[17:42:10.773]                               next
[17:42:10.773]                             invokeRestart(restart)
[17:42:10.773]                             muffled <- TRUE
[17:42:10.773]                             break
[17:42:10.773]                           }
[17:42:10.773]                         }
[17:42:10.773]                       }
[17:42:10.773]                       invisible(muffled)
[17:42:10.773]                     }
[17:42:10.773]                     muffleCondition(cond, pattern = "^muffle")
[17:42:10.773]                   }
[17:42:10.773]                 }
[17:42:10.773]             }
[17:42:10.773]         }))
[17:42:10.773]     }, error = function(ex) {
[17:42:10.773]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:10.773]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:10.773]                 ...future.rng), started = ...future.startTime, 
[17:42:10.773]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:10.773]             version = "1.8"), class = "FutureResult")
[17:42:10.773]     }, finally = {
[17:42:10.773]         if (!identical(...future.workdir, getwd())) 
[17:42:10.773]             setwd(...future.workdir)
[17:42:10.773]         {
[17:42:10.773]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:10.773]                 ...future.oldOptions$nwarnings <- NULL
[17:42:10.773]             }
[17:42:10.773]             base::options(...future.oldOptions)
[17:42:10.773]             if (.Platform$OS.type == "windows") {
[17:42:10.773]                 old_names <- names(...future.oldEnvVars)
[17:42:10.773]                 envs <- base::Sys.getenv()
[17:42:10.773]                 names <- names(envs)
[17:42:10.773]                 common <- intersect(names, old_names)
[17:42:10.773]                 added <- setdiff(names, old_names)
[17:42:10.773]                 removed <- setdiff(old_names, names)
[17:42:10.773]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:10.773]                   envs[common]]
[17:42:10.773]                 NAMES <- toupper(changed)
[17:42:10.773]                 args <- list()
[17:42:10.773]                 for (kk in seq_along(NAMES)) {
[17:42:10.773]                   name <- changed[[kk]]
[17:42:10.773]                   NAME <- NAMES[[kk]]
[17:42:10.773]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:10.773]                     next
[17:42:10.773]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:10.773]                 }
[17:42:10.773]                 NAMES <- toupper(added)
[17:42:10.773]                 for (kk in seq_along(NAMES)) {
[17:42:10.773]                   name <- added[[kk]]
[17:42:10.773]                   NAME <- NAMES[[kk]]
[17:42:10.773]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:10.773]                     next
[17:42:10.773]                   args[[name]] <- ""
[17:42:10.773]                 }
[17:42:10.773]                 NAMES <- toupper(removed)
[17:42:10.773]                 for (kk in seq_along(NAMES)) {
[17:42:10.773]                   name <- removed[[kk]]
[17:42:10.773]                   NAME <- NAMES[[kk]]
[17:42:10.773]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:10.773]                     next
[17:42:10.773]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:10.773]                 }
[17:42:10.773]                 if (length(args) > 0) 
[17:42:10.773]                   base::do.call(base::Sys.setenv, args = args)
[17:42:10.773]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:10.773]             }
[17:42:10.773]             else {
[17:42:10.773]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:10.773]             }
[17:42:10.773]             {
[17:42:10.773]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:10.773]                   0L) {
[17:42:10.773]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:10.773]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:10.773]                   base::options(opts)
[17:42:10.773]                 }
[17:42:10.773]                 {
[17:42:10.773]                   {
[17:42:10.773]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:10.773]                     NULL
[17:42:10.773]                   }
[17:42:10.773]                   options(future.plan = NULL)
[17:42:10.773]                   if (is.na(NA_character_)) 
[17:42:10.773]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:10.773]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:10.773]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:10.773]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:10.773]                     envir = parent.frame()) 
[17:42:10.773]                   {
[17:42:10.773]                     if (is.function(workers)) 
[17:42:10.773]                       workers <- workers()
[17:42:10.773]                     workers <- structure(as.integer(workers), 
[17:42:10.773]                       class = class(workers))
[17:42:10.773]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:10.773]                       workers >= 1)
[17:42:10.773]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:10.773]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:10.773]                     }
[17:42:10.773]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:10.773]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:10.773]                       envir = envir)
[17:42:10.773]                     if (!future$lazy) 
[17:42:10.773]                       future <- run(future)
[17:42:10.773]                     invisible(future)
[17:42:10.773]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:10.773]                 }
[17:42:10.773]             }
[17:42:10.773]         }
[17:42:10.773]     })
[17:42:10.773]     if (TRUE) {
[17:42:10.773]         base::sink(type = "output", split = FALSE)
[17:42:10.773]         if (TRUE) {
[17:42:10.773]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:10.773]         }
[17:42:10.773]         else {
[17:42:10.773]             ...future.result["stdout"] <- base::list(NULL)
[17:42:10.773]         }
[17:42:10.773]         base::close(...future.stdout)
[17:42:10.773]         ...future.stdout <- NULL
[17:42:10.773]     }
[17:42:10.773]     ...future.result$conditions <- ...future.conditions
[17:42:10.773]     ...future.result$finished <- base::Sys.time()
[17:42:10.773]     ...future.result
[17:42:10.773] }
[17:42:10.776] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[17:42:10.777] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[17:42:10.777] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[17:42:10.777] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[17:42:10.778] MultisessionFuture started
[17:42:10.778] - Launch lazy future ... done
[17:42:10.778] run() for ‘MultisessionFuture’ ... done
[17:42:10.778] result() for ClusterFuture ...
[17:42:10.778] receiveMessageFromWorker() for ClusterFuture ...
[17:42:10.779] - Validating connection of MultisessionFuture
[17:42:10.824] - received message: FutureResult
[17:42:10.824] - Received FutureResult
[17:42:10.824] - Erased future from FutureRegistry
[17:42:10.824] result() for ClusterFuture ...
[17:42:10.824] - result already collected: FutureResult
[17:42:10.824] result() for ClusterFuture ... done
[17:42:10.825] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:10.825] result() for ClusterFuture ... done
[17:42:10.825] result() for ClusterFuture ...
[17:42:10.825] - result already collected: FutureResult
[17:42:10.825] result() for ClusterFuture ... done
** Future evaluation with errors
[17:42:10.826] getGlobalsAndPackages() ...
[17:42:10.826] Searching for globals...
[17:42:10.828] - globals found: [3] ‘{’, ‘<-’, ‘stop’
[17:42:10.828] Searching for globals ... DONE
[17:42:10.828] Resolving globals: FALSE
[17:42:10.828] 
[17:42:10.828] 
[17:42:10.829] getGlobalsAndPackages() ... DONE
[17:42:10.829] run() for ‘Future’ ...
[17:42:10.829] - state: ‘created’
[17:42:10.829] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:10.845] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:10.845] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:10.845]   - Field: ‘node’
[17:42:10.845]   - Field: ‘label’
[17:42:10.845]   - Field: ‘local’
[17:42:10.845]   - Field: ‘owner’
[17:42:10.845]   - Field: ‘envir’
[17:42:10.845]   - Field: ‘workers’
[17:42:10.846]   - Field: ‘packages’
[17:42:10.846]   - Field: ‘gc’
[17:42:10.846]   - Field: ‘conditions’
[17:42:10.846]   - Field: ‘persistent’
[17:42:10.846]   - Field: ‘expr’
[17:42:10.846]   - Field: ‘uuid’
[17:42:10.846]   - Field: ‘seed’
[17:42:10.846]   - Field: ‘version’
[17:42:10.846]   - Field: ‘result’
[17:42:10.847]   - Field: ‘asynchronous’
[17:42:10.847]   - Field: ‘calls’
[17:42:10.847]   - Field: ‘globals’
[17:42:10.847]   - Field: ‘stdout’
[17:42:10.847]   - Field: ‘earlySignal’
[17:42:10.847]   - Field: ‘lazy’
[17:42:10.847]   - Field: ‘state’
[17:42:10.847] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:10.848] - Launch lazy future ...
[17:42:10.848] Packages needed by the future expression (n = 0): <none>
[17:42:10.848] Packages needed by future strategies (n = 0): <none>
[17:42:10.849] {
[17:42:10.849]     {
[17:42:10.849]         {
[17:42:10.849]             ...future.startTime <- base::Sys.time()
[17:42:10.849]             {
[17:42:10.849]                 {
[17:42:10.849]                   {
[17:42:10.849]                     {
[17:42:10.849]                       base::local({
[17:42:10.849]                         has_future <- base::requireNamespace("future", 
[17:42:10.849]                           quietly = TRUE)
[17:42:10.849]                         if (has_future) {
[17:42:10.849]                           ns <- base::getNamespace("future")
[17:42:10.849]                           version <- ns[[".package"]][["version"]]
[17:42:10.849]                           if (is.null(version)) 
[17:42:10.849]                             version <- utils::packageVersion("future")
[17:42:10.849]                         }
[17:42:10.849]                         else {
[17:42:10.849]                           version <- NULL
[17:42:10.849]                         }
[17:42:10.849]                         if (!has_future || version < "1.8.0") {
[17:42:10.849]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:10.849]                             "", base::R.version$version.string), 
[17:42:10.849]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:10.849]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:10.849]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:10.849]                               "release", "version")], collapse = " "), 
[17:42:10.849]                             hostname = base::Sys.info()[["nodename"]])
[17:42:10.849]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:10.849]                             info)
[17:42:10.849]                           info <- base::paste(info, collapse = "; ")
[17:42:10.849]                           if (!has_future) {
[17:42:10.849]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:10.849]                               info)
[17:42:10.849]                           }
[17:42:10.849]                           else {
[17:42:10.849]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:10.849]                               info, version)
[17:42:10.849]                           }
[17:42:10.849]                           base::stop(msg)
[17:42:10.849]                         }
[17:42:10.849]                       })
[17:42:10.849]                     }
[17:42:10.849]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:10.849]                     base::options(mc.cores = 1L)
[17:42:10.849]                   }
[17:42:10.849]                   options(future.plan = NULL)
[17:42:10.849]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:10.849]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:10.849]                 }
[17:42:10.849]                 ...future.workdir <- getwd()
[17:42:10.849]             }
[17:42:10.849]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:10.849]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:10.849]         }
[17:42:10.849]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:10.849]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:10.849]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:10.849]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:10.849]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:10.849]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:10.849]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:10.849]             base::names(...future.oldOptions))
[17:42:10.849]     }
[17:42:10.849]     if (FALSE) {
[17:42:10.849]     }
[17:42:10.849]     else {
[17:42:10.849]         if (TRUE) {
[17:42:10.849]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:10.849]                 open = "w")
[17:42:10.849]         }
[17:42:10.849]         else {
[17:42:10.849]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:10.849]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:10.849]         }
[17:42:10.849]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:10.849]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:10.849]             base::sink(type = "output", split = FALSE)
[17:42:10.849]             base::close(...future.stdout)
[17:42:10.849]         }, add = TRUE)
[17:42:10.849]     }
[17:42:10.849]     ...future.frame <- base::sys.nframe()
[17:42:10.849]     ...future.conditions <- base::list()
[17:42:10.849]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:10.849]     if (FALSE) {
[17:42:10.849]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:10.849]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:10.849]     }
[17:42:10.849]     ...future.result <- base::tryCatch({
[17:42:10.849]         base::withCallingHandlers({
[17:42:10.849]             ...future.value <- base::withVisible(base::local({
[17:42:10.849]                 ...future.makeSendCondition <- local({
[17:42:10.849]                   sendCondition <- NULL
[17:42:10.849]                   function(frame = 1L) {
[17:42:10.849]                     if (is.function(sendCondition)) 
[17:42:10.849]                       return(sendCondition)
[17:42:10.849]                     ns <- getNamespace("parallel")
[17:42:10.849]                     if (exists("sendData", mode = "function", 
[17:42:10.849]                       envir = ns)) {
[17:42:10.849]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:10.849]                         envir = ns)
[17:42:10.849]                       envir <- sys.frame(frame)
[17:42:10.849]                       master <- NULL
[17:42:10.849]                       while (!identical(envir, .GlobalEnv) && 
[17:42:10.849]                         !identical(envir, emptyenv())) {
[17:42:10.849]                         if (exists("master", mode = "list", envir = envir, 
[17:42:10.849]                           inherits = FALSE)) {
[17:42:10.849]                           master <- get("master", mode = "list", 
[17:42:10.849]                             envir = envir, inherits = FALSE)
[17:42:10.849]                           if (inherits(master, c("SOCKnode", 
[17:42:10.849]                             "SOCK0node"))) {
[17:42:10.849]                             sendCondition <<- function(cond) {
[17:42:10.849]                               data <- list(type = "VALUE", value = cond, 
[17:42:10.849]                                 success = TRUE)
[17:42:10.849]                               parallel_sendData(master, data)
[17:42:10.849]                             }
[17:42:10.849]                             return(sendCondition)
[17:42:10.849]                           }
[17:42:10.849]                         }
[17:42:10.849]                         frame <- frame + 1L
[17:42:10.849]                         envir <- sys.frame(frame)
[17:42:10.849]                       }
[17:42:10.849]                     }
[17:42:10.849]                     sendCondition <<- function(cond) NULL
[17:42:10.849]                   }
[17:42:10.849]                 })
[17:42:10.849]                 withCallingHandlers({
[17:42:10.849]                   {
[17:42:10.849]                     x <- 3
[17:42:10.849]                     stop("Woops!")
[17:42:10.849]                     x
[17:42:10.849]                   }
[17:42:10.849]                 }, immediateCondition = function(cond) {
[17:42:10.849]                   sendCondition <- ...future.makeSendCondition()
[17:42:10.849]                   sendCondition(cond)
[17:42:10.849]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:10.849]                   {
[17:42:10.849]                     inherits <- base::inherits
[17:42:10.849]                     invokeRestart <- base::invokeRestart
[17:42:10.849]                     is.null <- base::is.null
[17:42:10.849]                     muffled <- FALSE
[17:42:10.849]                     if (inherits(cond, "message")) {
[17:42:10.849]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:10.849]                       if (muffled) 
[17:42:10.849]                         invokeRestart("muffleMessage")
[17:42:10.849]                     }
[17:42:10.849]                     else if (inherits(cond, "warning")) {
[17:42:10.849]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:10.849]                       if (muffled) 
[17:42:10.849]                         invokeRestart("muffleWarning")
[17:42:10.849]                     }
[17:42:10.849]                     else if (inherits(cond, "condition")) {
[17:42:10.849]                       if (!is.null(pattern)) {
[17:42:10.849]                         computeRestarts <- base::computeRestarts
[17:42:10.849]                         grepl <- base::grepl
[17:42:10.849]                         restarts <- computeRestarts(cond)
[17:42:10.849]                         for (restart in restarts) {
[17:42:10.849]                           name <- restart$name
[17:42:10.849]                           if (is.null(name)) 
[17:42:10.849]                             next
[17:42:10.849]                           if (!grepl(pattern, name)) 
[17:42:10.849]                             next
[17:42:10.849]                           invokeRestart(restart)
[17:42:10.849]                           muffled <- TRUE
[17:42:10.849]                           break
[17:42:10.849]                         }
[17:42:10.849]                       }
[17:42:10.849]                     }
[17:42:10.849]                     invisible(muffled)
[17:42:10.849]                   }
[17:42:10.849]                   muffleCondition(cond)
[17:42:10.849]                 })
[17:42:10.849]             }))
[17:42:10.849]             future::FutureResult(value = ...future.value$value, 
[17:42:10.849]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:10.849]                   ...future.rng), globalenv = if (FALSE) 
[17:42:10.849]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:10.849]                     ...future.globalenv.names))
[17:42:10.849]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:10.849]         }, condition = base::local({
[17:42:10.849]             c <- base::c
[17:42:10.849]             inherits <- base::inherits
[17:42:10.849]             invokeRestart <- base::invokeRestart
[17:42:10.849]             length <- base::length
[17:42:10.849]             list <- base::list
[17:42:10.849]             seq.int <- base::seq.int
[17:42:10.849]             signalCondition <- base::signalCondition
[17:42:10.849]             sys.calls <- base::sys.calls
[17:42:10.849]             `[[` <- base::`[[`
[17:42:10.849]             `+` <- base::`+`
[17:42:10.849]             `<<-` <- base::`<<-`
[17:42:10.849]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:10.849]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:10.849]                   3L)]
[17:42:10.849]             }
[17:42:10.849]             function(cond) {
[17:42:10.849]                 is_error <- inherits(cond, "error")
[17:42:10.849]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:10.849]                   NULL)
[17:42:10.849]                 if (is_error) {
[17:42:10.849]                   sessionInformation <- function() {
[17:42:10.849]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:10.849]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:10.849]                       search = base::search(), system = base::Sys.info())
[17:42:10.849]                   }
[17:42:10.849]                   ...future.conditions[[length(...future.conditions) + 
[17:42:10.849]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:10.849]                     cond$call), session = sessionInformation(), 
[17:42:10.849]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:10.849]                   signalCondition(cond)
[17:42:10.849]                 }
[17:42:10.849]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:10.849]                 "immediateCondition"))) {
[17:42:10.849]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:10.849]                   ...future.conditions[[length(...future.conditions) + 
[17:42:10.849]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:10.849]                   if (TRUE && !signal) {
[17:42:10.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:10.849]                     {
[17:42:10.849]                       inherits <- base::inherits
[17:42:10.849]                       invokeRestart <- base::invokeRestart
[17:42:10.849]                       is.null <- base::is.null
[17:42:10.849]                       muffled <- FALSE
[17:42:10.849]                       if (inherits(cond, "message")) {
[17:42:10.849]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:10.849]                         if (muffled) 
[17:42:10.849]                           invokeRestart("muffleMessage")
[17:42:10.849]                       }
[17:42:10.849]                       else if (inherits(cond, "warning")) {
[17:42:10.849]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:10.849]                         if (muffled) 
[17:42:10.849]                           invokeRestart("muffleWarning")
[17:42:10.849]                       }
[17:42:10.849]                       else if (inherits(cond, "condition")) {
[17:42:10.849]                         if (!is.null(pattern)) {
[17:42:10.849]                           computeRestarts <- base::computeRestarts
[17:42:10.849]                           grepl <- base::grepl
[17:42:10.849]                           restarts <- computeRestarts(cond)
[17:42:10.849]                           for (restart in restarts) {
[17:42:10.849]                             name <- restart$name
[17:42:10.849]                             if (is.null(name)) 
[17:42:10.849]                               next
[17:42:10.849]                             if (!grepl(pattern, name)) 
[17:42:10.849]                               next
[17:42:10.849]                             invokeRestart(restart)
[17:42:10.849]                             muffled <- TRUE
[17:42:10.849]                             break
[17:42:10.849]                           }
[17:42:10.849]                         }
[17:42:10.849]                       }
[17:42:10.849]                       invisible(muffled)
[17:42:10.849]                     }
[17:42:10.849]                     muffleCondition(cond, pattern = "^muffle")
[17:42:10.849]                   }
[17:42:10.849]                 }
[17:42:10.849]                 else {
[17:42:10.849]                   if (TRUE) {
[17:42:10.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:10.849]                     {
[17:42:10.849]                       inherits <- base::inherits
[17:42:10.849]                       invokeRestart <- base::invokeRestart
[17:42:10.849]                       is.null <- base::is.null
[17:42:10.849]                       muffled <- FALSE
[17:42:10.849]                       if (inherits(cond, "message")) {
[17:42:10.849]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:10.849]                         if (muffled) 
[17:42:10.849]                           invokeRestart("muffleMessage")
[17:42:10.849]                       }
[17:42:10.849]                       else if (inherits(cond, "warning")) {
[17:42:10.849]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:10.849]                         if (muffled) 
[17:42:10.849]                           invokeRestart("muffleWarning")
[17:42:10.849]                       }
[17:42:10.849]                       else if (inherits(cond, "condition")) {
[17:42:10.849]                         if (!is.null(pattern)) {
[17:42:10.849]                           computeRestarts <- base::computeRestarts
[17:42:10.849]                           grepl <- base::grepl
[17:42:10.849]                           restarts <- computeRestarts(cond)
[17:42:10.849]                           for (restart in restarts) {
[17:42:10.849]                             name <- restart$name
[17:42:10.849]                             if (is.null(name)) 
[17:42:10.849]                               next
[17:42:10.849]                             if (!grepl(pattern, name)) 
[17:42:10.849]                               next
[17:42:10.849]                             invokeRestart(restart)
[17:42:10.849]                             muffled <- TRUE
[17:42:10.849]                             break
[17:42:10.849]                           }
[17:42:10.849]                         }
[17:42:10.849]                       }
[17:42:10.849]                       invisible(muffled)
[17:42:10.849]                     }
[17:42:10.849]                     muffleCondition(cond, pattern = "^muffle")
[17:42:10.849]                   }
[17:42:10.849]                 }
[17:42:10.849]             }
[17:42:10.849]         }))
[17:42:10.849]     }, error = function(ex) {
[17:42:10.849]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:10.849]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:10.849]                 ...future.rng), started = ...future.startTime, 
[17:42:10.849]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:10.849]             version = "1.8"), class = "FutureResult")
[17:42:10.849]     }, finally = {
[17:42:10.849]         if (!identical(...future.workdir, getwd())) 
[17:42:10.849]             setwd(...future.workdir)
[17:42:10.849]         {
[17:42:10.849]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:10.849]                 ...future.oldOptions$nwarnings <- NULL
[17:42:10.849]             }
[17:42:10.849]             base::options(...future.oldOptions)
[17:42:10.849]             if (.Platform$OS.type == "windows") {
[17:42:10.849]                 old_names <- names(...future.oldEnvVars)
[17:42:10.849]                 envs <- base::Sys.getenv()
[17:42:10.849]                 names <- names(envs)
[17:42:10.849]                 common <- intersect(names, old_names)
[17:42:10.849]                 added <- setdiff(names, old_names)
[17:42:10.849]                 removed <- setdiff(old_names, names)
[17:42:10.849]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:10.849]                   envs[common]]
[17:42:10.849]                 NAMES <- toupper(changed)
[17:42:10.849]                 args <- list()
[17:42:10.849]                 for (kk in seq_along(NAMES)) {
[17:42:10.849]                   name <- changed[[kk]]
[17:42:10.849]                   NAME <- NAMES[[kk]]
[17:42:10.849]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:10.849]                     next
[17:42:10.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:10.849]                 }
[17:42:10.849]                 NAMES <- toupper(added)
[17:42:10.849]                 for (kk in seq_along(NAMES)) {
[17:42:10.849]                   name <- added[[kk]]
[17:42:10.849]                   NAME <- NAMES[[kk]]
[17:42:10.849]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:10.849]                     next
[17:42:10.849]                   args[[name]] <- ""
[17:42:10.849]                 }
[17:42:10.849]                 NAMES <- toupper(removed)
[17:42:10.849]                 for (kk in seq_along(NAMES)) {
[17:42:10.849]                   name <- removed[[kk]]
[17:42:10.849]                   NAME <- NAMES[[kk]]
[17:42:10.849]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:10.849]                     next
[17:42:10.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:10.849]                 }
[17:42:10.849]                 if (length(args) > 0) 
[17:42:10.849]                   base::do.call(base::Sys.setenv, args = args)
[17:42:10.849]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:10.849]             }
[17:42:10.849]             else {
[17:42:10.849]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:10.849]             }
[17:42:10.849]             {
[17:42:10.849]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:10.849]                   0L) {
[17:42:10.849]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:10.849]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:10.849]                   base::options(opts)
[17:42:10.849]                 }
[17:42:10.849]                 {
[17:42:10.849]                   {
[17:42:10.849]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:10.849]                     NULL
[17:42:10.849]                   }
[17:42:10.849]                   options(future.plan = NULL)
[17:42:10.849]                   if (is.na(NA_character_)) 
[17:42:10.849]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:10.849]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:10.849]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:10.849]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:10.849]                     envir = parent.frame()) 
[17:42:10.849]                   {
[17:42:10.849]                     if (is.function(workers)) 
[17:42:10.849]                       workers <- workers()
[17:42:10.849]                     workers <- structure(as.integer(workers), 
[17:42:10.849]                       class = class(workers))
[17:42:10.849]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:10.849]                       workers >= 1)
[17:42:10.849]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:10.849]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:10.849]                     }
[17:42:10.849]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:10.849]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:10.849]                       envir = envir)
[17:42:10.849]                     if (!future$lazy) 
[17:42:10.849]                       future <- run(future)
[17:42:10.849]                     invisible(future)
[17:42:10.849]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:10.849]                 }
[17:42:10.849]             }
[17:42:10.849]         }
[17:42:10.849]     })
[17:42:10.849]     if (TRUE) {
[17:42:10.849]         base::sink(type = "output", split = FALSE)
[17:42:10.849]         if (TRUE) {
[17:42:10.849]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:10.849]         }
[17:42:10.849]         else {
[17:42:10.849]             ...future.result["stdout"] <- base::list(NULL)
[17:42:10.849]         }
[17:42:10.849]         base::close(...future.stdout)
[17:42:10.849]         ...future.stdout <- NULL
[17:42:10.849]     }
[17:42:10.849]     ...future.result$conditions <- ...future.conditions
[17:42:10.849]     ...future.result$finished <- base::Sys.time()
[17:42:10.849]     ...future.result
[17:42:10.849] }
[17:42:10.852] MultisessionFuture started
[17:42:10.852] - Launch lazy future ... done
[17:42:10.853] run() for ‘MultisessionFuture’ ... done
[17:42:10.853] result() for ClusterFuture ...
[17:42:10.853] receiveMessageFromWorker() for ClusterFuture ...
[17:42:10.853] - Validating connection of MultisessionFuture
[17:42:10.900] - received message: FutureResult
[17:42:10.901] - Received FutureResult
[17:42:10.901] - Erased future from FutureRegistry
[17:42:10.901] result() for ClusterFuture ...
[17:42:10.901] - result already collected: FutureResult
[17:42:10.901] result() for ClusterFuture ... done
[17:42:10.901] signalConditions() ...
[17:42:10.902]  - include = ‘immediateCondition’
[17:42:10.902]  - exclude = 
[17:42:10.902]  - resignal = FALSE
[17:42:10.902]  - Number of conditions: 1
[17:42:10.902] signalConditions() ... done
[17:42:10.902] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:10.902] result() for ClusterFuture ... done
[17:42:10.902] result() for ClusterFuture ...
[17:42:10.903] - result already collected: FutureResult
[17:42:10.903] result() for ClusterFuture ... done
[17:42:10.903] signalConditions() ...
[17:42:10.903]  - include = ‘immediateCondition’
[17:42:10.903]  - exclude = 
[17:42:10.903]  - resignal = FALSE
[17:42:10.903]  - Number of conditions: 1
[17:42:10.904] signalConditions() ... done
[17:42:10.904] Future state: ‘finished’
[17:42:10.904] result() for ClusterFuture ...
[17:42:10.904] - result already collected: FutureResult
[17:42:10.904] result() for ClusterFuture ... done
[17:42:10.904] signalConditions() ...
[17:42:10.905]  - include = ‘condition’
[17:42:10.905]  - exclude = ‘immediateCondition’
[17:42:10.905]  - resignal = TRUE
[17:42:10.905]  - Number of conditions: 1
[17:42:10.905]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:42:10.905] signalConditions() ... done
[17:42:10.906] getGlobalsAndPackages() ...
[17:42:10.906] Searching for globals...
[17:42:10.908] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[17:42:10.908] Searching for globals ... DONE
[17:42:10.908] Resolving globals: FALSE
[17:42:10.909] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:10.909] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:42:10.909] - globals: [1] ‘ii’
[17:42:10.910] 
[17:42:10.910] getGlobalsAndPackages() ... DONE
[17:42:10.910] run() for ‘Future’ ...
[17:42:10.910] - state: ‘created’
[17:42:10.910] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:10.927] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:10.928] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:10.928]   - Field: ‘node’
[17:42:10.928]   - Field: ‘label’
[17:42:10.928]   - Field: ‘local’
[17:42:10.928]   - Field: ‘owner’
[17:42:10.928]   - Field: ‘envir’
[17:42:10.928]   - Field: ‘workers’
[17:42:10.928]   - Field: ‘packages’
[17:42:10.928]   - Field: ‘gc’
[17:42:10.929]   - Field: ‘conditions’
[17:42:10.929]   - Field: ‘persistent’
[17:42:10.929]   - Field: ‘expr’
[17:42:10.929]   - Field: ‘uuid’
[17:42:10.929]   - Field: ‘seed’
[17:42:10.929]   - Field: ‘version’
[17:42:10.929]   - Field: ‘result’
[17:42:10.929]   - Field: ‘asynchronous’
[17:42:10.929]   - Field: ‘calls’
[17:42:10.929]   - Field: ‘globals’
[17:42:10.929]   - Field: ‘stdout’
[17:42:10.929]   - Field: ‘earlySignal’
[17:42:10.930]   - Field: ‘lazy’
[17:42:10.930]   - Field: ‘state’
[17:42:10.930] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:10.930] - Launch lazy future ...
[17:42:10.930] Packages needed by the future expression (n = 0): <none>
[17:42:10.930] Packages needed by future strategies (n = 0): <none>
[17:42:10.931] {
[17:42:10.931]     {
[17:42:10.931]         {
[17:42:10.931]             ...future.startTime <- base::Sys.time()
[17:42:10.931]             {
[17:42:10.931]                 {
[17:42:10.931]                   {
[17:42:10.931]                     {
[17:42:10.931]                       base::local({
[17:42:10.931]                         has_future <- base::requireNamespace("future", 
[17:42:10.931]                           quietly = TRUE)
[17:42:10.931]                         if (has_future) {
[17:42:10.931]                           ns <- base::getNamespace("future")
[17:42:10.931]                           version <- ns[[".package"]][["version"]]
[17:42:10.931]                           if (is.null(version)) 
[17:42:10.931]                             version <- utils::packageVersion("future")
[17:42:10.931]                         }
[17:42:10.931]                         else {
[17:42:10.931]                           version <- NULL
[17:42:10.931]                         }
[17:42:10.931]                         if (!has_future || version < "1.8.0") {
[17:42:10.931]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:10.931]                             "", base::R.version$version.string), 
[17:42:10.931]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:10.931]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:10.931]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:10.931]                               "release", "version")], collapse = " "), 
[17:42:10.931]                             hostname = base::Sys.info()[["nodename"]])
[17:42:10.931]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:10.931]                             info)
[17:42:10.931]                           info <- base::paste(info, collapse = "; ")
[17:42:10.931]                           if (!has_future) {
[17:42:10.931]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:10.931]                               info)
[17:42:10.931]                           }
[17:42:10.931]                           else {
[17:42:10.931]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:10.931]                               info, version)
[17:42:10.931]                           }
[17:42:10.931]                           base::stop(msg)
[17:42:10.931]                         }
[17:42:10.931]                       })
[17:42:10.931]                     }
[17:42:10.931]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:10.931]                     base::options(mc.cores = 1L)
[17:42:10.931]                   }
[17:42:10.931]                   options(future.plan = NULL)
[17:42:10.931]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:10.931]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:10.931]                 }
[17:42:10.931]                 ...future.workdir <- getwd()
[17:42:10.931]             }
[17:42:10.931]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:10.931]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:10.931]         }
[17:42:10.931]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:10.931]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:10.931]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:10.931]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:10.931]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:10.931]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:10.931]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:10.931]             base::names(...future.oldOptions))
[17:42:10.931]     }
[17:42:10.931]     if (FALSE) {
[17:42:10.931]     }
[17:42:10.931]     else {
[17:42:10.931]         if (TRUE) {
[17:42:10.931]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:10.931]                 open = "w")
[17:42:10.931]         }
[17:42:10.931]         else {
[17:42:10.931]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:10.931]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:10.931]         }
[17:42:10.931]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:10.931]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:10.931]             base::sink(type = "output", split = FALSE)
[17:42:10.931]             base::close(...future.stdout)
[17:42:10.931]         }, add = TRUE)
[17:42:10.931]     }
[17:42:10.931]     ...future.frame <- base::sys.nframe()
[17:42:10.931]     ...future.conditions <- base::list()
[17:42:10.931]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:10.931]     if (FALSE) {
[17:42:10.931]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:10.931]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:10.931]     }
[17:42:10.931]     ...future.result <- base::tryCatch({
[17:42:10.931]         base::withCallingHandlers({
[17:42:10.931]             ...future.value <- base::withVisible(base::local({
[17:42:10.931]                 ...future.makeSendCondition <- local({
[17:42:10.931]                   sendCondition <- NULL
[17:42:10.931]                   function(frame = 1L) {
[17:42:10.931]                     if (is.function(sendCondition)) 
[17:42:10.931]                       return(sendCondition)
[17:42:10.931]                     ns <- getNamespace("parallel")
[17:42:10.931]                     if (exists("sendData", mode = "function", 
[17:42:10.931]                       envir = ns)) {
[17:42:10.931]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:10.931]                         envir = ns)
[17:42:10.931]                       envir <- sys.frame(frame)
[17:42:10.931]                       master <- NULL
[17:42:10.931]                       while (!identical(envir, .GlobalEnv) && 
[17:42:10.931]                         !identical(envir, emptyenv())) {
[17:42:10.931]                         if (exists("master", mode = "list", envir = envir, 
[17:42:10.931]                           inherits = FALSE)) {
[17:42:10.931]                           master <- get("master", mode = "list", 
[17:42:10.931]                             envir = envir, inherits = FALSE)
[17:42:10.931]                           if (inherits(master, c("SOCKnode", 
[17:42:10.931]                             "SOCK0node"))) {
[17:42:10.931]                             sendCondition <<- function(cond) {
[17:42:10.931]                               data <- list(type = "VALUE", value = cond, 
[17:42:10.931]                                 success = TRUE)
[17:42:10.931]                               parallel_sendData(master, data)
[17:42:10.931]                             }
[17:42:10.931]                             return(sendCondition)
[17:42:10.931]                           }
[17:42:10.931]                         }
[17:42:10.931]                         frame <- frame + 1L
[17:42:10.931]                         envir <- sys.frame(frame)
[17:42:10.931]                       }
[17:42:10.931]                     }
[17:42:10.931]                     sendCondition <<- function(cond) NULL
[17:42:10.931]                   }
[17:42:10.931]                 })
[17:42:10.931]                 withCallingHandlers({
[17:42:10.931]                   {
[17:42:10.931]                     if (ii%%2 == 0) 
[17:42:10.931]                       stop("Woops!")
[17:42:10.931]                     ii
[17:42:10.931]                   }
[17:42:10.931]                 }, immediateCondition = function(cond) {
[17:42:10.931]                   sendCondition <- ...future.makeSendCondition()
[17:42:10.931]                   sendCondition(cond)
[17:42:10.931]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:10.931]                   {
[17:42:10.931]                     inherits <- base::inherits
[17:42:10.931]                     invokeRestart <- base::invokeRestart
[17:42:10.931]                     is.null <- base::is.null
[17:42:10.931]                     muffled <- FALSE
[17:42:10.931]                     if (inherits(cond, "message")) {
[17:42:10.931]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:10.931]                       if (muffled) 
[17:42:10.931]                         invokeRestart("muffleMessage")
[17:42:10.931]                     }
[17:42:10.931]                     else if (inherits(cond, "warning")) {
[17:42:10.931]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:10.931]                       if (muffled) 
[17:42:10.931]                         invokeRestart("muffleWarning")
[17:42:10.931]                     }
[17:42:10.931]                     else if (inherits(cond, "condition")) {
[17:42:10.931]                       if (!is.null(pattern)) {
[17:42:10.931]                         computeRestarts <- base::computeRestarts
[17:42:10.931]                         grepl <- base::grepl
[17:42:10.931]                         restarts <- computeRestarts(cond)
[17:42:10.931]                         for (restart in restarts) {
[17:42:10.931]                           name <- restart$name
[17:42:10.931]                           if (is.null(name)) 
[17:42:10.931]                             next
[17:42:10.931]                           if (!grepl(pattern, name)) 
[17:42:10.931]                             next
[17:42:10.931]                           invokeRestart(restart)
[17:42:10.931]                           muffled <- TRUE
[17:42:10.931]                           break
[17:42:10.931]                         }
[17:42:10.931]                       }
[17:42:10.931]                     }
[17:42:10.931]                     invisible(muffled)
[17:42:10.931]                   }
[17:42:10.931]                   muffleCondition(cond)
[17:42:10.931]                 })
[17:42:10.931]             }))
[17:42:10.931]             future::FutureResult(value = ...future.value$value, 
[17:42:10.931]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:10.931]                   ...future.rng), globalenv = if (FALSE) 
[17:42:10.931]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:10.931]                     ...future.globalenv.names))
[17:42:10.931]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:10.931]         }, condition = base::local({
[17:42:10.931]             c <- base::c
[17:42:10.931]             inherits <- base::inherits
[17:42:10.931]             invokeRestart <- base::invokeRestart
[17:42:10.931]             length <- base::length
[17:42:10.931]             list <- base::list
[17:42:10.931]             seq.int <- base::seq.int
[17:42:10.931]             signalCondition <- base::signalCondition
[17:42:10.931]             sys.calls <- base::sys.calls
[17:42:10.931]             `[[` <- base::`[[`
[17:42:10.931]             `+` <- base::`+`
[17:42:10.931]             `<<-` <- base::`<<-`
[17:42:10.931]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:10.931]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:10.931]                   3L)]
[17:42:10.931]             }
[17:42:10.931]             function(cond) {
[17:42:10.931]                 is_error <- inherits(cond, "error")
[17:42:10.931]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:10.931]                   NULL)
[17:42:10.931]                 if (is_error) {
[17:42:10.931]                   sessionInformation <- function() {
[17:42:10.931]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:10.931]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:10.931]                       search = base::search(), system = base::Sys.info())
[17:42:10.931]                   }
[17:42:10.931]                   ...future.conditions[[length(...future.conditions) + 
[17:42:10.931]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:10.931]                     cond$call), session = sessionInformation(), 
[17:42:10.931]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:10.931]                   signalCondition(cond)
[17:42:10.931]                 }
[17:42:10.931]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:10.931]                 "immediateCondition"))) {
[17:42:10.931]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:10.931]                   ...future.conditions[[length(...future.conditions) + 
[17:42:10.931]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:10.931]                   if (TRUE && !signal) {
[17:42:10.931]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:10.931]                     {
[17:42:10.931]                       inherits <- base::inherits
[17:42:10.931]                       invokeRestart <- base::invokeRestart
[17:42:10.931]                       is.null <- base::is.null
[17:42:10.931]                       muffled <- FALSE
[17:42:10.931]                       if (inherits(cond, "message")) {
[17:42:10.931]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:10.931]                         if (muffled) 
[17:42:10.931]                           invokeRestart("muffleMessage")
[17:42:10.931]                       }
[17:42:10.931]                       else if (inherits(cond, "warning")) {
[17:42:10.931]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:10.931]                         if (muffled) 
[17:42:10.931]                           invokeRestart("muffleWarning")
[17:42:10.931]                       }
[17:42:10.931]                       else if (inherits(cond, "condition")) {
[17:42:10.931]                         if (!is.null(pattern)) {
[17:42:10.931]                           computeRestarts <- base::computeRestarts
[17:42:10.931]                           grepl <- base::grepl
[17:42:10.931]                           restarts <- computeRestarts(cond)
[17:42:10.931]                           for (restart in restarts) {
[17:42:10.931]                             name <- restart$name
[17:42:10.931]                             if (is.null(name)) 
[17:42:10.931]                               next
[17:42:10.931]                             if (!grepl(pattern, name)) 
[17:42:10.931]                               next
[17:42:10.931]                             invokeRestart(restart)
[17:42:10.931]                             muffled <- TRUE
[17:42:10.931]                             break
[17:42:10.931]                           }
[17:42:10.931]                         }
[17:42:10.931]                       }
[17:42:10.931]                       invisible(muffled)
[17:42:10.931]                     }
[17:42:10.931]                     muffleCondition(cond, pattern = "^muffle")
[17:42:10.931]                   }
[17:42:10.931]                 }
[17:42:10.931]                 else {
[17:42:10.931]                   if (TRUE) {
[17:42:10.931]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:10.931]                     {
[17:42:10.931]                       inherits <- base::inherits
[17:42:10.931]                       invokeRestart <- base::invokeRestart
[17:42:10.931]                       is.null <- base::is.null
[17:42:10.931]                       muffled <- FALSE
[17:42:10.931]                       if (inherits(cond, "message")) {
[17:42:10.931]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:10.931]                         if (muffled) 
[17:42:10.931]                           invokeRestart("muffleMessage")
[17:42:10.931]                       }
[17:42:10.931]                       else if (inherits(cond, "warning")) {
[17:42:10.931]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:10.931]                         if (muffled) 
[17:42:10.931]                           invokeRestart("muffleWarning")
[17:42:10.931]                       }
[17:42:10.931]                       else if (inherits(cond, "condition")) {
[17:42:10.931]                         if (!is.null(pattern)) {
[17:42:10.931]                           computeRestarts <- base::computeRestarts
[17:42:10.931]                           grepl <- base::grepl
[17:42:10.931]                           restarts <- computeRestarts(cond)
[17:42:10.931]                           for (restart in restarts) {
[17:42:10.931]                             name <- restart$name
[17:42:10.931]                             if (is.null(name)) 
[17:42:10.931]                               next
[17:42:10.931]                             if (!grepl(pattern, name)) 
[17:42:10.931]                               next
[17:42:10.931]                             invokeRestart(restart)
[17:42:10.931]                             muffled <- TRUE
[17:42:10.931]                             break
[17:42:10.931]                           }
[17:42:10.931]                         }
[17:42:10.931]                       }
[17:42:10.931]                       invisible(muffled)
[17:42:10.931]                     }
[17:42:10.931]                     muffleCondition(cond, pattern = "^muffle")
[17:42:10.931]                   }
[17:42:10.931]                 }
[17:42:10.931]             }
[17:42:10.931]         }))
[17:42:10.931]     }, error = function(ex) {
[17:42:10.931]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:10.931]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:10.931]                 ...future.rng), started = ...future.startTime, 
[17:42:10.931]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:10.931]             version = "1.8"), class = "FutureResult")
[17:42:10.931]     }, finally = {
[17:42:10.931]         if (!identical(...future.workdir, getwd())) 
[17:42:10.931]             setwd(...future.workdir)
[17:42:10.931]         {
[17:42:10.931]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:10.931]                 ...future.oldOptions$nwarnings <- NULL
[17:42:10.931]             }
[17:42:10.931]             base::options(...future.oldOptions)
[17:42:10.931]             if (.Platform$OS.type == "windows") {
[17:42:10.931]                 old_names <- names(...future.oldEnvVars)
[17:42:10.931]                 envs <- base::Sys.getenv()
[17:42:10.931]                 names <- names(envs)
[17:42:10.931]                 common <- intersect(names, old_names)
[17:42:10.931]                 added <- setdiff(names, old_names)
[17:42:10.931]                 removed <- setdiff(old_names, names)
[17:42:10.931]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:10.931]                   envs[common]]
[17:42:10.931]                 NAMES <- toupper(changed)
[17:42:10.931]                 args <- list()
[17:42:10.931]                 for (kk in seq_along(NAMES)) {
[17:42:10.931]                   name <- changed[[kk]]
[17:42:10.931]                   NAME <- NAMES[[kk]]
[17:42:10.931]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:10.931]                     next
[17:42:10.931]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:10.931]                 }
[17:42:10.931]                 NAMES <- toupper(added)
[17:42:10.931]                 for (kk in seq_along(NAMES)) {
[17:42:10.931]                   name <- added[[kk]]
[17:42:10.931]                   NAME <- NAMES[[kk]]
[17:42:10.931]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:10.931]                     next
[17:42:10.931]                   args[[name]] <- ""
[17:42:10.931]                 }
[17:42:10.931]                 NAMES <- toupper(removed)
[17:42:10.931]                 for (kk in seq_along(NAMES)) {
[17:42:10.931]                   name <- removed[[kk]]
[17:42:10.931]                   NAME <- NAMES[[kk]]
[17:42:10.931]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:10.931]                     next
[17:42:10.931]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:10.931]                 }
[17:42:10.931]                 if (length(args) > 0) 
[17:42:10.931]                   base::do.call(base::Sys.setenv, args = args)
[17:42:10.931]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:10.931]             }
[17:42:10.931]             else {
[17:42:10.931]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:10.931]             }
[17:42:10.931]             {
[17:42:10.931]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:10.931]                   0L) {
[17:42:10.931]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:10.931]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:10.931]                   base::options(opts)
[17:42:10.931]                 }
[17:42:10.931]                 {
[17:42:10.931]                   {
[17:42:10.931]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:10.931]                     NULL
[17:42:10.931]                   }
[17:42:10.931]                   options(future.plan = NULL)
[17:42:10.931]                   if (is.na(NA_character_)) 
[17:42:10.931]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:10.931]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:10.931]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:10.931]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:10.931]                     envir = parent.frame()) 
[17:42:10.931]                   {
[17:42:10.931]                     if (is.function(workers)) 
[17:42:10.931]                       workers <- workers()
[17:42:10.931]                     workers <- structure(as.integer(workers), 
[17:42:10.931]                       class = class(workers))
[17:42:10.931]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:10.931]                       workers >= 1)
[17:42:10.931]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:10.931]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:10.931]                     }
[17:42:10.931]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:10.931]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:10.931]                       envir = envir)
[17:42:10.931]                     if (!future$lazy) 
[17:42:10.931]                       future <- run(future)
[17:42:10.931]                     invisible(future)
[17:42:10.931]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:10.931]                 }
[17:42:10.931]             }
[17:42:10.931]         }
[17:42:10.931]     })
[17:42:10.931]     if (TRUE) {
[17:42:10.931]         base::sink(type = "output", split = FALSE)
[17:42:10.931]         if (TRUE) {
[17:42:10.931]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:10.931]         }
[17:42:10.931]         else {
[17:42:10.931]             ...future.result["stdout"] <- base::list(NULL)
[17:42:10.931]         }
[17:42:10.931]         base::close(...future.stdout)
[17:42:10.931]         ...future.stdout <- NULL
[17:42:10.931]     }
[17:42:10.931]     ...future.result$conditions <- ...future.conditions
[17:42:10.931]     ...future.result$finished <- base::Sys.time()
[17:42:10.931]     ...future.result
[17:42:10.931] }
[17:42:10.933] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[17:42:10.933] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[17:42:10.934] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[17:42:10.934] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[17:42:10.935] MultisessionFuture started
[17:42:10.935] - Launch lazy future ... done
[17:42:10.935] run() for ‘MultisessionFuture’ ... done
[17:42:10.935] getGlobalsAndPackages() ...
[17:42:10.936] Searching for globals...
[17:42:10.937] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[17:42:10.937] Searching for globals ... DONE
[17:42:10.937] Resolving globals: FALSE
[17:42:10.938] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:10.938] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:42:10.938] - globals: [1] ‘ii’
[17:42:10.938] 
[17:42:10.938] getGlobalsAndPackages() ... DONE
[17:42:10.939] run() for ‘Future’ ...
[17:42:10.939] - state: ‘created’
[17:42:10.939] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:10.953] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:10.954] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:10.954]   - Field: ‘node’
[17:42:10.954]   - Field: ‘label’
[17:42:10.954]   - Field: ‘local’
[17:42:10.954]   - Field: ‘owner’
[17:42:10.954]   - Field: ‘envir’
[17:42:10.954]   - Field: ‘workers’
[17:42:10.954]   - Field: ‘packages’
[17:42:10.954]   - Field: ‘gc’
[17:42:10.955]   - Field: ‘conditions’
[17:42:10.955]   - Field: ‘persistent’
[17:42:10.955]   - Field: ‘expr’
[17:42:10.955]   - Field: ‘uuid’
[17:42:10.955]   - Field: ‘seed’
[17:42:10.955]   - Field: ‘version’
[17:42:10.955]   - Field: ‘result’
[17:42:10.955]   - Field: ‘asynchronous’
[17:42:10.955]   - Field: ‘calls’
[17:42:10.955]   - Field: ‘globals’
[17:42:10.956]   - Field: ‘stdout’
[17:42:10.956]   - Field: ‘earlySignal’
[17:42:10.956]   - Field: ‘lazy’
[17:42:10.956]   - Field: ‘state’
[17:42:10.956] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:10.956] - Launch lazy future ...
[17:42:10.956] Packages needed by the future expression (n = 0): <none>
[17:42:10.956] Packages needed by future strategies (n = 0): <none>
[17:42:10.957] {
[17:42:10.957]     {
[17:42:10.957]         {
[17:42:10.957]             ...future.startTime <- base::Sys.time()
[17:42:10.957]             {
[17:42:10.957]                 {
[17:42:10.957]                   {
[17:42:10.957]                     {
[17:42:10.957]                       base::local({
[17:42:10.957]                         has_future <- base::requireNamespace("future", 
[17:42:10.957]                           quietly = TRUE)
[17:42:10.957]                         if (has_future) {
[17:42:10.957]                           ns <- base::getNamespace("future")
[17:42:10.957]                           version <- ns[[".package"]][["version"]]
[17:42:10.957]                           if (is.null(version)) 
[17:42:10.957]                             version <- utils::packageVersion("future")
[17:42:10.957]                         }
[17:42:10.957]                         else {
[17:42:10.957]                           version <- NULL
[17:42:10.957]                         }
[17:42:10.957]                         if (!has_future || version < "1.8.0") {
[17:42:10.957]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:10.957]                             "", base::R.version$version.string), 
[17:42:10.957]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:10.957]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:10.957]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:10.957]                               "release", "version")], collapse = " "), 
[17:42:10.957]                             hostname = base::Sys.info()[["nodename"]])
[17:42:10.957]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:10.957]                             info)
[17:42:10.957]                           info <- base::paste(info, collapse = "; ")
[17:42:10.957]                           if (!has_future) {
[17:42:10.957]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:10.957]                               info)
[17:42:10.957]                           }
[17:42:10.957]                           else {
[17:42:10.957]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:10.957]                               info, version)
[17:42:10.957]                           }
[17:42:10.957]                           base::stop(msg)
[17:42:10.957]                         }
[17:42:10.957]                       })
[17:42:10.957]                     }
[17:42:10.957]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:10.957]                     base::options(mc.cores = 1L)
[17:42:10.957]                   }
[17:42:10.957]                   options(future.plan = NULL)
[17:42:10.957]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:10.957]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:10.957]                 }
[17:42:10.957]                 ...future.workdir <- getwd()
[17:42:10.957]             }
[17:42:10.957]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:10.957]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:10.957]         }
[17:42:10.957]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:10.957]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:10.957]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:10.957]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:10.957]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:10.957]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:10.957]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:10.957]             base::names(...future.oldOptions))
[17:42:10.957]     }
[17:42:10.957]     if (FALSE) {
[17:42:10.957]     }
[17:42:10.957]     else {
[17:42:10.957]         if (TRUE) {
[17:42:10.957]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:10.957]                 open = "w")
[17:42:10.957]         }
[17:42:10.957]         else {
[17:42:10.957]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:10.957]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:10.957]         }
[17:42:10.957]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:10.957]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:10.957]             base::sink(type = "output", split = FALSE)
[17:42:10.957]             base::close(...future.stdout)
[17:42:10.957]         }, add = TRUE)
[17:42:10.957]     }
[17:42:10.957]     ...future.frame <- base::sys.nframe()
[17:42:10.957]     ...future.conditions <- base::list()
[17:42:10.957]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:10.957]     if (FALSE) {
[17:42:10.957]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:10.957]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:10.957]     }
[17:42:10.957]     ...future.result <- base::tryCatch({
[17:42:10.957]         base::withCallingHandlers({
[17:42:10.957]             ...future.value <- base::withVisible(base::local({
[17:42:10.957]                 ...future.makeSendCondition <- local({
[17:42:10.957]                   sendCondition <- NULL
[17:42:10.957]                   function(frame = 1L) {
[17:42:10.957]                     if (is.function(sendCondition)) 
[17:42:10.957]                       return(sendCondition)
[17:42:10.957]                     ns <- getNamespace("parallel")
[17:42:10.957]                     if (exists("sendData", mode = "function", 
[17:42:10.957]                       envir = ns)) {
[17:42:10.957]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:10.957]                         envir = ns)
[17:42:10.957]                       envir <- sys.frame(frame)
[17:42:10.957]                       master <- NULL
[17:42:10.957]                       while (!identical(envir, .GlobalEnv) && 
[17:42:10.957]                         !identical(envir, emptyenv())) {
[17:42:10.957]                         if (exists("master", mode = "list", envir = envir, 
[17:42:10.957]                           inherits = FALSE)) {
[17:42:10.957]                           master <- get("master", mode = "list", 
[17:42:10.957]                             envir = envir, inherits = FALSE)
[17:42:10.957]                           if (inherits(master, c("SOCKnode", 
[17:42:10.957]                             "SOCK0node"))) {
[17:42:10.957]                             sendCondition <<- function(cond) {
[17:42:10.957]                               data <- list(type = "VALUE", value = cond, 
[17:42:10.957]                                 success = TRUE)
[17:42:10.957]                               parallel_sendData(master, data)
[17:42:10.957]                             }
[17:42:10.957]                             return(sendCondition)
[17:42:10.957]                           }
[17:42:10.957]                         }
[17:42:10.957]                         frame <- frame + 1L
[17:42:10.957]                         envir <- sys.frame(frame)
[17:42:10.957]                       }
[17:42:10.957]                     }
[17:42:10.957]                     sendCondition <<- function(cond) NULL
[17:42:10.957]                   }
[17:42:10.957]                 })
[17:42:10.957]                 withCallingHandlers({
[17:42:10.957]                   {
[17:42:10.957]                     if (ii%%2 == 0) 
[17:42:10.957]                       stop("Woops!")
[17:42:10.957]                     ii
[17:42:10.957]                   }
[17:42:10.957]                 }, immediateCondition = function(cond) {
[17:42:10.957]                   sendCondition <- ...future.makeSendCondition()
[17:42:10.957]                   sendCondition(cond)
[17:42:10.957]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:10.957]                   {
[17:42:10.957]                     inherits <- base::inherits
[17:42:10.957]                     invokeRestart <- base::invokeRestart
[17:42:10.957]                     is.null <- base::is.null
[17:42:10.957]                     muffled <- FALSE
[17:42:10.957]                     if (inherits(cond, "message")) {
[17:42:10.957]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:10.957]                       if (muffled) 
[17:42:10.957]                         invokeRestart("muffleMessage")
[17:42:10.957]                     }
[17:42:10.957]                     else if (inherits(cond, "warning")) {
[17:42:10.957]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:10.957]                       if (muffled) 
[17:42:10.957]                         invokeRestart("muffleWarning")
[17:42:10.957]                     }
[17:42:10.957]                     else if (inherits(cond, "condition")) {
[17:42:10.957]                       if (!is.null(pattern)) {
[17:42:10.957]                         computeRestarts <- base::computeRestarts
[17:42:10.957]                         grepl <- base::grepl
[17:42:10.957]                         restarts <- computeRestarts(cond)
[17:42:10.957]                         for (restart in restarts) {
[17:42:10.957]                           name <- restart$name
[17:42:10.957]                           if (is.null(name)) 
[17:42:10.957]                             next
[17:42:10.957]                           if (!grepl(pattern, name)) 
[17:42:10.957]                             next
[17:42:10.957]                           invokeRestart(restart)
[17:42:10.957]                           muffled <- TRUE
[17:42:10.957]                           break
[17:42:10.957]                         }
[17:42:10.957]                       }
[17:42:10.957]                     }
[17:42:10.957]                     invisible(muffled)
[17:42:10.957]                   }
[17:42:10.957]                   muffleCondition(cond)
[17:42:10.957]                 })
[17:42:10.957]             }))
[17:42:10.957]             future::FutureResult(value = ...future.value$value, 
[17:42:10.957]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:10.957]                   ...future.rng), globalenv = if (FALSE) 
[17:42:10.957]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:10.957]                     ...future.globalenv.names))
[17:42:10.957]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:10.957]         }, condition = base::local({
[17:42:10.957]             c <- base::c
[17:42:10.957]             inherits <- base::inherits
[17:42:10.957]             invokeRestart <- base::invokeRestart
[17:42:10.957]             length <- base::length
[17:42:10.957]             list <- base::list
[17:42:10.957]             seq.int <- base::seq.int
[17:42:10.957]             signalCondition <- base::signalCondition
[17:42:10.957]             sys.calls <- base::sys.calls
[17:42:10.957]             `[[` <- base::`[[`
[17:42:10.957]             `+` <- base::`+`
[17:42:10.957]             `<<-` <- base::`<<-`
[17:42:10.957]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:10.957]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:10.957]                   3L)]
[17:42:10.957]             }
[17:42:10.957]             function(cond) {
[17:42:10.957]                 is_error <- inherits(cond, "error")
[17:42:10.957]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:10.957]                   NULL)
[17:42:10.957]                 if (is_error) {
[17:42:10.957]                   sessionInformation <- function() {
[17:42:10.957]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:10.957]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:10.957]                       search = base::search(), system = base::Sys.info())
[17:42:10.957]                   }
[17:42:10.957]                   ...future.conditions[[length(...future.conditions) + 
[17:42:10.957]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:10.957]                     cond$call), session = sessionInformation(), 
[17:42:10.957]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:10.957]                   signalCondition(cond)
[17:42:10.957]                 }
[17:42:10.957]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:10.957]                 "immediateCondition"))) {
[17:42:10.957]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:10.957]                   ...future.conditions[[length(...future.conditions) + 
[17:42:10.957]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:10.957]                   if (TRUE && !signal) {
[17:42:10.957]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:10.957]                     {
[17:42:10.957]                       inherits <- base::inherits
[17:42:10.957]                       invokeRestart <- base::invokeRestart
[17:42:10.957]                       is.null <- base::is.null
[17:42:10.957]                       muffled <- FALSE
[17:42:10.957]                       if (inherits(cond, "message")) {
[17:42:10.957]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:10.957]                         if (muffled) 
[17:42:10.957]                           invokeRestart("muffleMessage")
[17:42:10.957]                       }
[17:42:10.957]                       else if (inherits(cond, "warning")) {
[17:42:10.957]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:10.957]                         if (muffled) 
[17:42:10.957]                           invokeRestart("muffleWarning")
[17:42:10.957]                       }
[17:42:10.957]                       else if (inherits(cond, "condition")) {
[17:42:10.957]                         if (!is.null(pattern)) {
[17:42:10.957]                           computeRestarts <- base::computeRestarts
[17:42:10.957]                           grepl <- base::grepl
[17:42:10.957]                           restarts <- computeRestarts(cond)
[17:42:10.957]                           for (restart in restarts) {
[17:42:10.957]                             name <- restart$name
[17:42:10.957]                             if (is.null(name)) 
[17:42:10.957]                               next
[17:42:10.957]                             if (!grepl(pattern, name)) 
[17:42:10.957]                               next
[17:42:10.957]                             invokeRestart(restart)
[17:42:10.957]                             muffled <- TRUE
[17:42:10.957]                             break
[17:42:10.957]                           }
[17:42:10.957]                         }
[17:42:10.957]                       }
[17:42:10.957]                       invisible(muffled)
[17:42:10.957]                     }
[17:42:10.957]                     muffleCondition(cond, pattern = "^muffle")
[17:42:10.957]                   }
[17:42:10.957]                 }
[17:42:10.957]                 else {
[17:42:10.957]                   if (TRUE) {
[17:42:10.957]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:10.957]                     {
[17:42:10.957]                       inherits <- base::inherits
[17:42:10.957]                       invokeRestart <- base::invokeRestart
[17:42:10.957]                       is.null <- base::is.null
[17:42:10.957]                       muffled <- FALSE
[17:42:10.957]                       if (inherits(cond, "message")) {
[17:42:10.957]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:10.957]                         if (muffled) 
[17:42:10.957]                           invokeRestart("muffleMessage")
[17:42:10.957]                       }
[17:42:10.957]                       else if (inherits(cond, "warning")) {
[17:42:10.957]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:10.957]                         if (muffled) 
[17:42:10.957]                           invokeRestart("muffleWarning")
[17:42:10.957]                       }
[17:42:10.957]                       else if (inherits(cond, "condition")) {
[17:42:10.957]                         if (!is.null(pattern)) {
[17:42:10.957]                           computeRestarts <- base::computeRestarts
[17:42:10.957]                           grepl <- base::grepl
[17:42:10.957]                           restarts <- computeRestarts(cond)
[17:42:10.957]                           for (restart in restarts) {
[17:42:10.957]                             name <- restart$name
[17:42:10.957]                             if (is.null(name)) 
[17:42:10.957]                               next
[17:42:10.957]                             if (!grepl(pattern, name)) 
[17:42:10.957]                               next
[17:42:10.957]                             invokeRestart(restart)
[17:42:10.957]                             muffled <- TRUE
[17:42:10.957]                             break
[17:42:10.957]                           }
[17:42:10.957]                         }
[17:42:10.957]                       }
[17:42:10.957]                       invisible(muffled)
[17:42:10.957]                     }
[17:42:10.957]                     muffleCondition(cond, pattern = "^muffle")
[17:42:10.957]                   }
[17:42:10.957]                 }
[17:42:10.957]             }
[17:42:10.957]         }))
[17:42:10.957]     }, error = function(ex) {
[17:42:10.957]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:10.957]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:10.957]                 ...future.rng), started = ...future.startTime, 
[17:42:10.957]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:10.957]             version = "1.8"), class = "FutureResult")
[17:42:10.957]     }, finally = {
[17:42:10.957]         if (!identical(...future.workdir, getwd())) 
[17:42:10.957]             setwd(...future.workdir)
[17:42:10.957]         {
[17:42:10.957]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:10.957]                 ...future.oldOptions$nwarnings <- NULL
[17:42:10.957]             }
[17:42:10.957]             base::options(...future.oldOptions)
[17:42:10.957]             if (.Platform$OS.type == "windows") {
[17:42:10.957]                 old_names <- names(...future.oldEnvVars)
[17:42:10.957]                 envs <- base::Sys.getenv()
[17:42:10.957]                 names <- names(envs)
[17:42:10.957]                 common <- intersect(names, old_names)
[17:42:10.957]                 added <- setdiff(names, old_names)
[17:42:10.957]                 removed <- setdiff(old_names, names)
[17:42:10.957]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:10.957]                   envs[common]]
[17:42:10.957]                 NAMES <- toupper(changed)
[17:42:10.957]                 args <- list()
[17:42:10.957]                 for (kk in seq_along(NAMES)) {
[17:42:10.957]                   name <- changed[[kk]]
[17:42:10.957]                   NAME <- NAMES[[kk]]
[17:42:10.957]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:10.957]                     next
[17:42:10.957]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:10.957]                 }
[17:42:10.957]                 NAMES <- toupper(added)
[17:42:10.957]                 for (kk in seq_along(NAMES)) {
[17:42:10.957]                   name <- added[[kk]]
[17:42:10.957]                   NAME <- NAMES[[kk]]
[17:42:10.957]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:10.957]                     next
[17:42:10.957]                   args[[name]] <- ""
[17:42:10.957]                 }
[17:42:10.957]                 NAMES <- toupper(removed)
[17:42:10.957]                 for (kk in seq_along(NAMES)) {
[17:42:10.957]                   name <- removed[[kk]]
[17:42:10.957]                   NAME <- NAMES[[kk]]
[17:42:10.957]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:10.957]                     next
[17:42:10.957]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:10.957]                 }
[17:42:10.957]                 if (length(args) > 0) 
[17:42:10.957]                   base::do.call(base::Sys.setenv, args = args)
[17:42:10.957]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:10.957]             }
[17:42:10.957]             else {
[17:42:10.957]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:10.957]             }
[17:42:10.957]             {
[17:42:10.957]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:10.957]                   0L) {
[17:42:10.957]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:10.957]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:10.957]                   base::options(opts)
[17:42:10.957]                 }
[17:42:10.957]                 {
[17:42:10.957]                   {
[17:42:10.957]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:10.957]                     NULL
[17:42:10.957]                   }
[17:42:10.957]                   options(future.plan = NULL)
[17:42:10.957]                   if (is.na(NA_character_)) 
[17:42:10.957]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:10.957]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:10.957]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:10.957]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:10.957]                     envir = parent.frame()) 
[17:42:10.957]                   {
[17:42:10.957]                     if (is.function(workers)) 
[17:42:10.957]                       workers <- workers()
[17:42:10.957]                     workers <- structure(as.integer(workers), 
[17:42:10.957]                       class = class(workers))
[17:42:10.957]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:10.957]                       workers >= 1)
[17:42:10.957]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:10.957]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:10.957]                     }
[17:42:10.957]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:10.957]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:10.957]                       envir = envir)
[17:42:10.957]                     if (!future$lazy) 
[17:42:10.957]                       future <- run(future)
[17:42:10.957]                     invisible(future)
[17:42:10.957]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:10.957]                 }
[17:42:10.957]             }
[17:42:10.957]         }
[17:42:10.957]     })
[17:42:10.957]     if (TRUE) {
[17:42:10.957]         base::sink(type = "output", split = FALSE)
[17:42:10.957]         if (TRUE) {
[17:42:10.957]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:10.957]         }
[17:42:10.957]         else {
[17:42:10.957]             ...future.result["stdout"] <- base::list(NULL)
[17:42:10.957]         }
[17:42:10.957]         base::close(...future.stdout)
[17:42:10.957]         ...future.stdout <- NULL
[17:42:10.957]     }
[17:42:10.957]     ...future.result$conditions <- ...future.conditions
[17:42:10.957]     ...future.result$finished <- base::Sys.time()
[17:42:10.957]     ...future.result
[17:42:10.957] }
[17:42:11.030] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[17:42:11.030] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[17:42:11.030] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[17:42:11.030] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[17:42:11.031] MultisessionFuture started
[17:42:11.031] - Launch lazy future ... done
[17:42:11.031] run() for ‘MultisessionFuture’ ... done
[17:42:11.032] getGlobalsAndPackages() ...
[17:42:11.032] Searching for globals...
[17:42:11.033] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[17:42:11.033] Searching for globals ... DONE
[17:42:11.034] Resolving globals: FALSE
[17:42:11.034] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:11.034] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:42:11.034] - globals: [1] ‘ii’
[17:42:11.035] 
[17:42:11.035] getGlobalsAndPackages() ... DONE
[17:42:11.035] run() for ‘Future’ ...
[17:42:11.035] - state: ‘created’
[17:42:11.035] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:11.050] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:11.050] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:11.050]   - Field: ‘node’
[17:42:11.050]   - Field: ‘label’
[17:42:11.050]   - Field: ‘local’
[17:42:11.051]   - Field: ‘owner’
[17:42:11.051]   - Field: ‘envir’
[17:42:11.051]   - Field: ‘workers’
[17:42:11.051]   - Field: ‘packages’
[17:42:11.051]   - Field: ‘gc’
[17:42:11.051]   - Field: ‘conditions’
[17:42:11.051]   - Field: ‘persistent’
[17:42:11.051]   - Field: ‘expr’
[17:42:11.051]   - Field: ‘uuid’
[17:42:11.052]   - Field: ‘seed’
[17:42:11.052]   - Field: ‘version’
[17:42:11.052]   - Field: ‘result’
[17:42:11.052]   - Field: ‘asynchronous’
[17:42:11.052]   - Field: ‘calls’
[17:42:11.052]   - Field: ‘globals’
[17:42:11.052]   - Field: ‘stdout’
[17:42:11.052]   - Field: ‘earlySignal’
[17:42:11.052]   - Field: ‘lazy’
[17:42:11.052]   - Field: ‘state’
[17:42:11.052] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:11.053] - Launch lazy future ...
[17:42:11.053] Packages needed by the future expression (n = 0): <none>
[17:42:11.053] Packages needed by future strategies (n = 0): <none>
[17:42:11.053] {
[17:42:11.053]     {
[17:42:11.053]         {
[17:42:11.053]             ...future.startTime <- base::Sys.time()
[17:42:11.053]             {
[17:42:11.053]                 {
[17:42:11.053]                   {
[17:42:11.053]                     {
[17:42:11.053]                       base::local({
[17:42:11.053]                         has_future <- base::requireNamespace("future", 
[17:42:11.053]                           quietly = TRUE)
[17:42:11.053]                         if (has_future) {
[17:42:11.053]                           ns <- base::getNamespace("future")
[17:42:11.053]                           version <- ns[[".package"]][["version"]]
[17:42:11.053]                           if (is.null(version)) 
[17:42:11.053]                             version <- utils::packageVersion("future")
[17:42:11.053]                         }
[17:42:11.053]                         else {
[17:42:11.053]                           version <- NULL
[17:42:11.053]                         }
[17:42:11.053]                         if (!has_future || version < "1.8.0") {
[17:42:11.053]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:11.053]                             "", base::R.version$version.string), 
[17:42:11.053]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:11.053]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:11.053]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:11.053]                               "release", "version")], collapse = " "), 
[17:42:11.053]                             hostname = base::Sys.info()[["nodename"]])
[17:42:11.053]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:11.053]                             info)
[17:42:11.053]                           info <- base::paste(info, collapse = "; ")
[17:42:11.053]                           if (!has_future) {
[17:42:11.053]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:11.053]                               info)
[17:42:11.053]                           }
[17:42:11.053]                           else {
[17:42:11.053]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:11.053]                               info, version)
[17:42:11.053]                           }
[17:42:11.053]                           base::stop(msg)
[17:42:11.053]                         }
[17:42:11.053]                       })
[17:42:11.053]                     }
[17:42:11.053]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:11.053]                     base::options(mc.cores = 1L)
[17:42:11.053]                   }
[17:42:11.053]                   options(future.plan = NULL)
[17:42:11.053]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:11.053]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:11.053]                 }
[17:42:11.053]                 ...future.workdir <- getwd()
[17:42:11.053]             }
[17:42:11.053]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:11.053]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:11.053]         }
[17:42:11.053]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:11.053]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:11.053]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:11.053]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:11.053]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:11.053]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:11.053]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:11.053]             base::names(...future.oldOptions))
[17:42:11.053]     }
[17:42:11.053]     if (FALSE) {
[17:42:11.053]     }
[17:42:11.053]     else {
[17:42:11.053]         if (TRUE) {
[17:42:11.053]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:11.053]                 open = "w")
[17:42:11.053]         }
[17:42:11.053]         else {
[17:42:11.053]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:11.053]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:11.053]         }
[17:42:11.053]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:11.053]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:11.053]             base::sink(type = "output", split = FALSE)
[17:42:11.053]             base::close(...future.stdout)
[17:42:11.053]         }, add = TRUE)
[17:42:11.053]     }
[17:42:11.053]     ...future.frame <- base::sys.nframe()
[17:42:11.053]     ...future.conditions <- base::list()
[17:42:11.053]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:11.053]     if (FALSE) {
[17:42:11.053]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:11.053]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:11.053]     }
[17:42:11.053]     ...future.result <- base::tryCatch({
[17:42:11.053]         base::withCallingHandlers({
[17:42:11.053]             ...future.value <- base::withVisible(base::local({
[17:42:11.053]                 ...future.makeSendCondition <- local({
[17:42:11.053]                   sendCondition <- NULL
[17:42:11.053]                   function(frame = 1L) {
[17:42:11.053]                     if (is.function(sendCondition)) 
[17:42:11.053]                       return(sendCondition)
[17:42:11.053]                     ns <- getNamespace("parallel")
[17:42:11.053]                     if (exists("sendData", mode = "function", 
[17:42:11.053]                       envir = ns)) {
[17:42:11.053]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:11.053]                         envir = ns)
[17:42:11.053]                       envir <- sys.frame(frame)
[17:42:11.053]                       master <- NULL
[17:42:11.053]                       while (!identical(envir, .GlobalEnv) && 
[17:42:11.053]                         !identical(envir, emptyenv())) {
[17:42:11.053]                         if (exists("master", mode = "list", envir = envir, 
[17:42:11.053]                           inherits = FALSE)) {
[17:42:11.053]                           master <- get("master", mode = "list", 
[17:42:11.053]                             envir = envir, inherits = FALSE)
[17:42:11.053]                           if (inherits(master, c("SOCKnode", 
[17:42:11.053]                             "SOCK0node"))) {
[17:42:11.053]                             sendCondition <<- function(cond) {
[17:42:11.053]                               data <- list(type = "VALUE", value = cond, 
[17:42:11.053]                                 success = TRUE)
[17:42:11.053]                               parallel_sendData(master, data)
[17:42:11.053]                             }
[17:42:11.053]                             return(sendCondition)
[17:42:11.053]                           }
[17:42:11.053]                         }
[17:42:11.053]                         frame <- frame + 1L
[17:42:11.053]                         envir <- sys.frame(frame)
[17:42:11.053]                       }
[17:42:11.053]                     }
[17:42:11.053]                     sendCondition <<- function(cond) NULL
[17:42:11.053]                   }
[17:42:11.053]                 })
[17:42:11.053]                 withCallingHandlers({
[17:42:11.053]                   {
[17:42:11.053]                     if (ii%%2 == 0) 
[17:42:11.053]                       stop("Woops!")
[17:42:11.053]                     ii
[17:42:11.053]                   }
[17:42:11.053]                 }, immediateCondition = function(cond) {
[17:42:11.053]                   sendCondition <- ...future.makeSendCondition()
[17:42:11.053]                   sendCondition(cond)
[17:42:11.053]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:11.053]                   {
[17:42:11.053]                     inherits <- base::inherits
[17:42:11.053]                     invokeRestart <- base::invokeRestart
[17:42:11.053]                     is.null <- base::is.null
[17:42:11.053]                     muffled <- FALSE
[17:42:11.053]                     if (inherits(cond, "message")) {
[17:42:11.053]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:11.053]                       if (muffled) 
[17:42:11.053]                         invokeRestart("muffleMessage")
[17:42:11.053]                     }
[17:42:11.053]                     else if (inherits(cond, "warning")) {
[17:42:11.053]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:11.053]                       if (muffled) 
[17:42:11.053]                         invokeRestart("muffleWarning")
[17:42:11.053]                     }
[17:42:11.053]                     else if (inherits(cond, "condition")) {
[17:42:11.053]                       if (!is.null(pattern)) {
[17:42:11.053]                         computeRestarts <- base::computeRestarts
[17:42:11.053]                         grepl <- base::grepl
[17:42:11.053]                         restarts <- computeRestarts(cond)
[17:42:11.053]                         for (restart in restarts) {
[17:42:11.053]                           name <- restart$name
[17:42:11.053]                           if (is.null(name)) 
[17:42:11.053]                             next
[17:42:11.053]                           if (!grepl(pattern, name)) 
[17:42:11.053]                             next
[17:42:11.053]                           invokeRestart(restart)
[17:42:11.053]                           muffled <- TRUE
[17:42:11.053]                           break
[17:42:11.053]                         }
[17:42:11.053]                       }
[17:42:11.053]                     }
[17:42:11.053]                     invisible(muffled)
[17:42:11.053]                   }
[17:42:11.053]                   muffleCondition(cond)
[17:42:11.053]                 })
[17:42:11.053]             }))
[17:42:11.053]             future::FutureResult(value = ...future.value$value, 
[17:42:11.053]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:11.053]                   ...future.rng), globalenv = if (FALSE) 
[17:42:11.053]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:11.053]                     ...future.globalenv.names))
[17:42:11.053]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:11.053]         }, condition = base::local({
[17:42:11.053]             c <- base::c
[17:42:11.053]             inherits <- base::inherits
[17:42:11.053]             invokeRestart <- base::invokeRestart
[17:42:11.053]             length <- base::length
[17:42:11.053]             list <- base::list
[17:42:11.053]             seq.int <- base::seq.int
[17:42:11.053]             signalCondition <- base::signalCondition
[17:42:11.053]             sys.calls <- base::sys.calls
[17:42:11.053]             `[[` <- base::`[[`
[17:42:11.053]             `+` <- base::`+`
[17:42:11.053]             `<<-` <- base::`<<-`
[17:42:11.053]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:11.053]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:11.053]                   3L)]
[17:42:11.053]             }
[17:42:11.053]             function(cond) {
[17:42:11.053]                 is_error <- inherits(cond, "error")
[17:42:11.053]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:11.053]                   NULL)
[17:42:11.053]                 if (is_error) {
[17:42:11.053]                   sessionInformation <- function() {
[17:42:11.053]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:11.053]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:11.053]                       search = base::search(), system = base::Sys.info())
[17:42:11.053]                   }
[17:42:11.053]                   ...future.conditions[[length(...future.conditions) + 
[17:42:11.053]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:11.053]                     cond$call), session = sessionInformation(), 
[17:42:11.053]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:11.053]                   signalCondition(cond)
[17:42:11.053]                 }
[17:42:11.053]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:11.053]                 "immediateCondition"))) {
[17:42:11.053]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:11.053]                   ...future.conditions[[length(...future.conditions) + 
[17:42:11.053]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:11.053]                   if (TRUE && !signal) {
[17:42:11.053]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:11.053]                     {
[17:42:11.053]                       inherits <- base::inherits
[17:42:11.053]                       invokeRestart <- base::invokeRestart
[17:42:11.053]                       is.null <- base::is.null
[17:42:11.053]                       muffled <- FALSE
[17:42:11.053]                       if (inherits(cond, "message")) {
[17:42:11.053]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:11.053]                         if (muffled) 
[17:42:11.053]                           invokeRestart("muffleMessage")
[17:42:11.053]                       }
[17:42:11.053]                       else if (inherits(cond, "warning")) {
[17:42:11.053]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:11.053]                         if (muffled) 
[17:42:11.053]                           invokeRestart("muffleWarning")
[17:42:11.053]                       }
[17:42:11.053]                       else if (inherits(cond, "condition")) {
[17:42:11.053]                         if (!is.null(pattern)) {
[17:42:11.053]                           computeRestarts <- base::computeRestarts
[17:42:11.053]                           grepl <- base::grepl
[17:42:11.053]                           restarts <- computeRestarts(cond)
[17:42:11.053]                           for (restart in restarts) {
[17:42:11.053]                             name <- restart$name
[17:42:11.053]                             if (is.null(name)) 
[17:42:11.053]                               next
[17:42:11.053]                             if (!grepl(pattern, name)) 
[17:42:11.053]                               next
[17:42:11.053]                             invokeRestart(restart)
[17:42:11.053]                             muffled <- TRUE
[17:42:11.053]                             break
[17:42:11.053]                           }
[17:42:11.053]                         }
[17:42:11.053]                       }
[17:42:11.053]                       invisible(muffled)
[17:42:11.053]                     }
[17:42:11.053]                     muffleCondition(cond, pattern = "^muffle")
[17:42:11.053]                   }
[17:42:11.053]                 }
[17:42:11.053]                 else {
[17:42:11.053]                   if (TRUE) {
[17:42:11.053]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:11.053]                     {
[17:42:11.053]                       inherits <- base::inherits
[17:42:11.053]                       invokeRestart <- base::invokeRestart
[17:42:11.053]                       is.null <- base::is.null
[17:42:11.053]                       muffled <- FALSE
[17:42:11.053]                       if (inherits(cond, "message")) {
[17:42:11.053]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:11.053]                         if (muffled) 
[17:42:11.053]                           invokeRestart("muffleMessage")
[17:42:11.053]                       }
[17:42:11.053]                       else if (inherits(cond, "warning")) {
[17:42:11.053]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:11.053]                         if (muffled) 
[17:42:11.053]                           invokeRestart("muffleWarning")
[17:42:11.053]                       }
[17:42:11.053]                       else if (inherits(cond, "condition")) {
[17:42:11.053]                         if (!is.null(pattern)) {
[17:42:11.053]                           computeRestarts <- base::computeRestarts
[17:42:11.053]                           grepl <- base::grepl
[17:42:11.053]                           restarts <- computeRestarts(cond)
[17:42:11.053]                           for (restart in restarts) {
[17:42:11.053]                             name <- restart$name
[17:42:11.053]                             if (is.null(name)) 
[17:42:11.053]                               next
[17:42:11.053]                             if (!grepl(pattern, name)) 
[17:42:11.053]                               next
[17:42:11.053]                             invokeRestart(restart)
[17:42:11.053]                             muffled <- TRUE
[17:42:11.053]                             break
[17:42:11.053]                           }
[17:42:11.053]                         }
[17:42:11.053]                       }
[17:42:11.053]                       invisible(muffled)
[17:42:11.053]                     }
[17:42:11.053]                     muffleCondition(cond, pattern = "^muffle")
[17:42:11.053]                   }
[17:42:11.053]                 }
[17:42:11.053]             }
[17:42:11.053]         }))
[17:42:11.053]     }, error = function(ex) {
[17:42:11.053]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:11.053]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:11.053]                 ...future.rng), started = ...future.startTime, 
[17:42:11.053]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:11.053]             version = "1.8"), class = "FutureResult")
[17:42:11.053]     }, finally = {
[17:42:11.053]         if (!identical(...future.workdir, getwd())) 
[17:42:11.053]             setwd(...future.workdir)
[17:42:11.053]         {
[17:42:11.053]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:11.053]                 ...future.oldOptions$nwarnings <- NULL
[17:42:11.053]             }
[17:42:11.053]             base::options(...future.oldOptions)
[17:42:11.053]             if (.Platform$OS.type == "windows") {
[17:42:11.053]                 old_names <- names(...future.oldEnvVars)
[17:42:11.053]                 envs <- base::Sys.getenv()
[17:42:11.053]                 names <- names(envs)
[17:42:11.053]                 common <- intersect(names, old_names)
[17:42:11.053]                 added <- setdiff(names, old_names)
[17:42:11.053]                 removed <- setdiff(old_names, names)
[17:42:11.053]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:11.053]                   envs[common]]
[17:42:11.053]                 NAMES <- toupper(changed)
[17:42:11.053]                 args <- list()
[17:42:11.053]                 for (kk in seq_along(NAMES)) {
[17:42:11.053]                   name <- changed[[kk]]
[17:42:11.053]                   NAME <- NAMES[[kk]]
[17:42:11.053]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:11.053]                     next
[17:42:11.053]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:11.053]                 }
[17:42:11.053]                 NAMES <- toupper(added)
[17:42:11.053]                 for (kk in seq_along(NAMES)) {
[17:42:11.053]                   name <- added[[kk]]
[17:42:11.053]                   NAME <- NAMES[[kk]]
[17:42:11.053]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:11.053]                     next
[17:42:11.053]                   args[[name]] <- ""
[17:42:11.053]                 }
[17:42:11.053]                 NAMES <- toupper(removed)
[17:42:11.053]                 for (kk in seq_along(NAMES)) {
[17:42:11.053]                   name <- removed[[kk]]
[17:42:11.053]                   NAME <- NAMES[[kk]]
[17:42:11.053]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:11.053]                     next
[17:42:11.053]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:11.053]                 }
[17:42:11.053]                 if (length(args) > 0) 
[17:42:11.053]                   base::do.call(base::Sys.setenv, args = args)
[17:42:11.053]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:11.053]             }
[17:42:11.053]             else {
[17:42:11.053]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:11.053]             }
[17:42:11.053]             {
[17:42:11.053]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:11.053]                   0L) {
[17:42:11.053]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:11.053]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:11.053]                   base::options(opts)
[17:42:11.053]                 }
[17:42:11.053]                 {
[17:42:11.053]                   {
[17:42:11.053]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:11.053]                     NULL
[17:42:11.053]                   }
[17:42:11.053]                   options(future.plan = NULL)
[17:42:11.053]                   if (is.na(NA_character_)) 
[17:42:11.053]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:11.053]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:11.053]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:11.053]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:11.053]                     envir = parent.frame()) 
[17:42:11.053]                   {
[17:42:11.053]                     if (is.function(workers)) 
[17:42:11.053]                       workers <- workers()
[17:42:11.053]                     workers <- structure(as.integer(workers), 
[17:42:11.053]                       class = class(workers))
[17:42:11.053]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:11.053]                       workers >= 1)
[17:42:11.053]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:11.053]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:11.053]                     }
[17:42:11.053]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:11.053]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:11.053]                       envir = envir)
[17:42:11.053]                     if (!future$lazy) 
[17:42:11.053]                       future <- run(future)
[17:42:11.053]                     invisible(future)
[17:42:11.053]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:11.053]                 }
[17:42:11.053]             }
[17:42:11.053]         }
[17:42:11.053]     })
[17:42:11.053]     if (TRUE) {
[17:42:11.053]         base::sink(type = "output", split = FALSE)
[17:42:11.053]         if (TRUE) {
[17:42:11.053]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:11.053]         }
[17:42:11.053]         else {
[17:42:11.053]             ...future.result["stdout"] <- base::list(NULL)
[17:42:11.053]         }
[17:42:11.053]         base::close(...future.stdout)
[17:42:11.053]         ...future.stdout <- NULL
[17:42:11.053]     }
[17:42:11.053]     ...future.result$conditions <- ...future.conditions
[17:42:11.053]     ...future.result$finished <- base::Sys.time()
[17:42:11.053]     ...future.result
[17:42:11.053] }
[17:42:11.056] Poll #1 (0): usedNodes() = 2, workers = 2
[17:42:11.075] receiveMessageFromWorker() for ClusterFuture ...
[17:42:11.075] - Validating connection of MultisessionFuture
[17:42:11.075] - received message: FutureResult
[17:42:11.075] - Received FutureResult
[17:42:11.076] - Erased future from FutureRegistry
[17:42:11.076] result() for ClusterFuture ...
[17:42:11.076] - result already collected: FutureResult
[17:42:11.076] result() for ClusterFuture ... done
[17:42:11.076] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:11.076] result() for ClusterFuture ...
[17:42:11.076] - result already collected: FutureResult
[17:42:11.076] result() for ClusterFuture ... done
[17:42:11.076] result() for ClusterFuture ...
[17:42:11.076] - result already collected: FutureResult
[17:42:11.076] result() for ClusterFuture ... done
[17:42:11.077] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[17:42:11.077] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[17:42:11.078] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[17:42:11.078] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[17:42:11.079] MultisessionFuture started
[17:42:11.079] - Launch lazy future ... done
[17:42:11.079] run() for ‘MultisessionFuture’ ... done
[17:42:11.079] result() for ClusterFuture ...
[17:42:11.079] - result already collected: FutureResult
[17:42:11.079] result() for ClusterFuture ... done
[17:42:11.079] result() for ClusterFuture ...
[17:42:11.080] - result already collected: FutureResult
[17:42:11.080] result() for ClusterFuture ... done
[17:42:11.080] result() for ClusterFuture ...
[17:42:11.080] receiveMessageFromWorker() for ClusterFuture ...
[17:42:11.080] - Validating connection of MultisessionFuture
[17:42:11.109] - received message: FutureResult
[17:42:11.109] - Received FutureResult
[17:42:11.109] - Erased future from FutureRegistry
[17:42:11.109] result() for ClusterFuture ...
[17:42:11.110] - result already collected: FutureResult
[17:42:11.110] result() for ClusterFuture ... done
[17:42:11.110] signalConditions() ...
[17:42:11.110]  - include = ‘immediateCondition’
[17:42:11.110]  - exclude = 
[17:42:11.110]  - resignal = FALSE
[17:42:11.110]  - Number of conditions: 1
[17:42:11.110] signalConditions() ... done
[17:42:11.110] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:11.110] result() for ClusterFuture ... done
[17:42:11.111] result() for ClusterFuture ...
[17:42:11.111] - result already collected: FutureResult
[17:42:11.111] result() for ClusterFuture ... done
[17:42:11.111] signalConditions() ...
[17:42:11.111]  - include = ‘immediateCondition’
[17:42:11.111]  - exclude = 
[17:42:11.111]  - resignal = FALSE
[17:42:11.111]  - Number of conditions: 1
[17:42:11.111] signalConditions() ... done
[17:42:11.111] Future state: ‘finished’
[17:42:11.111] result() for ClusterFuture ...
[17:42:11.112] - result already collected: FutureResult
[17:42:11.112] result() for ClusterFuture ... done
[17:42:11.112] signalConditions() ...
[17:42:11.112]  - include = ‘condition’
[17:42:11.112]  - exclude = ‘immediateCondition’
[17:42:11.112]  - resignal = TRUE
[17:42:11.112]  - Number of conditions: 1
[17:42:11.112]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:42:11.112] signalConditions() ... done
[17:42:11.113] result() for ClusterFuture ...
[17:42:11.113] receiveMessageFromWorker() for ClusterFuture ...
[17:42:11.113] - Validating connection of MultisessionFuture
[17:42:11.128] - received message: FutureResult
[17:42:11.128] - Received FutureResult
[17:42:11.128] - Erased future from FutureRegistry
[17:42:11.128] result() for ClusterFuture ...
[17:42:11.129] - result already collected: FutureResult
[17:42:11.129] result() for ClusterFuture ... done
[17:42:11.129] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:11.129] result() for ClusterFuture ... done
[17:42:11.129] result() for ClusterFuture ...
[17:42:11.129] - result already collected: FutureResult
[17:42:11.129] result() for ClusterFuture ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[17:42:11.130] result() for ClusterFuture ...
[17:42:11.130] - result already collected: FutureResult
[17:42:11.130] result() for ClusterFuture ... done
[17:42:11.130] result() for ClusterFuture ...
[17:42:11.130] - result already collected: FutureResult
[17:42:11.130] result() for ClusterFuture ... done
[17:42:11.130] signalConditions() ...
[17:42:11.130]  - include = ‘immediateCondition’
[17:42:11.130]  - exclude = 
[17:42:11.130]  - resignal = FALSE
[17:42:11.130]  - Number of conditions: 1
[17:42:11.131] signalConditions() ... done
[17:42:11.131] Future state: ‘finished’
[17:42:11.131] result() for ClusterFuture ...
[17:42:11.131] - result already collected: FutureResult
[17:42:11.131] result() for ClusterFuture ... done
[17:42:11.131] signalConditions() ...
[17:42:11.131]  - include = ‘condition’
[17:42:11.131]  - exclude = ‘immediateCondition’
[17:42:11.131]  - resignal = TRUE
[17:42:11.131]  - Number of conditions: 1
[17:42:11.131]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:42:11.132] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[17:42:11.132] result() for ClusterFuture ...
[17:42:11.132] - result already collected: FutureResult
[17:42:11.132] result() for ClusterFuture ... done
[17:42:11.132] result() for ClusterFuture ...
[17:42:11.132] - result already collected: FutureResult
[17:42:11.132] result() for ClusterFuture ... done
[17:42:11.132] signalConditions() ...
[17:42:11.133]  - include = ‘immediateCondition’
[17:42:11.133]  - exclude = 
[17:42:11.133]  - resignal = FALSE
[17:42:11.133]  - Number of conditions: 1
[17:42:11.133] signalConditions() ... done
[17:42:11.133] Future state: ‘finished’
[17:42:11.133] result() for ClusterFuture ...
[17:42:11.133] - result already collected: FutureResult
[17:42:11.133] result() for ClusterFuture ... done
[17:42:11.133] signalConditions() ...
[17:42:11.133]  - include = ‘condition’
[17:42:11.134]  - exclude = ‘immediateCondition’
[17:42:11.134]  - resignal = TRUE
[17:42:11.134]  - Number of conditions: 1
[17:42:11.134]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:42:11.134] signalConditions() ... done
** Future evaluation with a poor-man's "progress bar"
[17:42:11.134] getGlobalsAndPackages() ...
[17:42:11.134] Searching for globals...
[17:42:11.136] - globals found: [4] ‘{’, ‘cat’, ‘for’, ‘:’
[17:42:11.136] Searching for globals ... DONE
[17:42:11.137] Resolving globals: FALSE
[17:42:11.137] 
[17:42:11.137] 
[17:42:11.137] getGlobalsAndPackages() ... DONE
[17:42:11.137] run() for ‘Future’ ...
[17:42:11.137] - state: ‘created’
[17:42:11.138] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:11.152] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:11.152] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:11.152]   - Field: ‘node’
[17:42:11.152]   - Field: ‘label’
[17:42:11.152]   - Field: ‘local’
[17:42:11.153]   - Field: ‘owner’
[17:42:11.153]   - Field: ‘envir’
[17:42:11.153]   - Field: ‘workers’
[17:42:11.153]   - Field: ‘packages’
[17:42:11.153]   - Field: ‘gc’
[17:42:11.153]   - Field: ‘conditions’
[17:42:11.153]   - Field: ‘persistent’
[17:42:11.153]   - Field: ‘expr’
[17:42:11.153]   - Field: ‘uuid’
[17:42:11.153]   - Field: ‘seed’
[17:42:11.154]   - Field: ‘version’
[17:42:11.154]   - Field: ‘result’
[17:42:11.154]   - Field: ‘asynchronous’
[17:42:11.154]   - Field: ‘calls’
[17:42:11.154]   - Field: ‘globals’
[17:42:11.154]   - Field: ‘stdout’
[17:42:11.154]   - Field: ‘earlySignal’
[17:42:11.154]   - Field: ‘lazy’
[17:42:11.154]   - Field: ‘state’
[17:42:11.154] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:11.154] - Launch lazy future ...
[17:42:11.155] Packages needed by the future expression (n = 0): <none>
[17:42:11.155] Packages needed by future strategies (n = 0): <none>
[17:42:11.155] {
[17:42:11.155]     {
[17:42:11.155]         {
[17:42:11.155]             ...future.startTime <- base::Sys.time()
[17:42:11.155]             {
[17:42:11.155]                 {
[17:42:11.155]                   {
[17:42:11.155]                     {
[17:42:11.155]                       base::local({
[17:42:11.155]                         has_future <- base::requireNamespace("future", 
[17:42:11.155]                           quietly = TRUE)
[17:42:11.155]                         if (has_future) {
[17:42:11.155]                           ns <- base::getNamespace("future")
[17:42:11.155]                           version <- ns[[".package"]][["version"]]
[17:42:11.155]                           if (is.null(version)) 
[17:42:11.155]                             version <- utils::packageVersion("future")
[17:42:11.155]                         }
[17:42:11.155]                         else {
[17:42:11.155]                           version <- NULL
[17:42:11.155]                         }
[17:42:11.155]                         if (!has_future || version < "1.8.0") {
[17:42:11.155]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:11.155]                             "", base::R.version$version.string), 
[17:42:11.155]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:11.155]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:11.155]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:11.155]                               "release", "version")], collapse = " "), 
[17:42:11.155]                             hostname = base::Sys.info()[["nodename"]])
[17:42:11.155]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:11.155]                             info)
[17:42:11.155]                           info <- base::paste(info, collapse = "; ")
[17:42:11.155]                           if (!has_future) {
[17:42:11.155]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:11.155]                               info)
[17:42:11.155]                           }
[17:42:11.155]                           else {
[17:42:11.155]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:11.155]                               info, version)
[17:42:11.155]                           }
[17:42:11.155]                           base::stop(msg)
[17:42:11.155]                         }
[17:42:11.155]                       })
[17:42:11.155]                     }
[17:42:11.155]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:11.155]                     base::options(mc.cores = 1L)
[17:42:11.155]                   }
[17:42:11.155]                   options(future.plan = NULL)
[17:42:11.155]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:11.155]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:11.155]                 }
[17:42:11.155]                 ...future.workdir <- getwd()
[17:42:11.155]             }
[17:42:11.155]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:11.155]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:11.155]         }
[17:42:11.155]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:11.155]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:11.155]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:11.155]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:11.155]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:11.155]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:11.155]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:11.155]             base::names(...future.oldOptions))
[17:42:11.155]     }
[17:42:11.155]     if (FALSE) {
[17:42:11.155]     }
[17:42:11.155]     else {
[17:42:11.155]         if (TRUE) {
[17:42:11.155]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:11.155]                 open = "w")
[17:42:11.155]         }
[17:42:11.155]         else {
[17:42:11.155]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:11.155]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:11.155]         }
[17:42:11.155]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:11.155]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:11.155]             base::sink(type = "output", split = FALSE)
[17:42:11.155]             base::close(...future.stdout)
[17:42:11.155]         }, add = TRUE)
[17:42:11.155]     }
[17:42:11.155]     ...future.frame <- base::sys.nframe()
[17:42:11.155]     ...future.conditions <- base::list()
[17:42:11.155]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:11.155]     if (FALSE) {
[17:42:11.155]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:11.155]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:11.155]     }
[17:42:11.155]     ...future.result <- base::tryCatch({
[17:42:11.155]         base::withCallingHandlers({
[17:42:11.155]             ...future.value <- base::withVisible(base::local({
[17:42:11.155]                 ...future.makeSendCondition <- local({
[17:42:11.155]                   sendCondition <- NULL
[17:42:11.155]                   function(frame = 1L) {
[17:42:11.155]                     if (is.function(sendCondition)) 
[17:42:11.155]                       return(sendCondition)
[17:42:11.155]                     ns <- getNamespace("parallel")
[17:42:11.155]                     if (exists("sendData", mode = "function", 
[17:42:11.155]                       envir = ns)) {
[17:42:11.155]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:11.155]                         envir = ns)
[17:42:11.155]                       envir <- sys.frame(frame)
[17:42:11.155]                       master <- NULL
[17:42:11.155]                       while (!identical(envir, .GlobalEnv) && 
[17:42:11.155]                         !identical(envir, emptyenv())) {
[17:42:11.155]                         if (exists("master", mode = "list", envir = envir, 
[17:42:11.155]                           inherits = FALSE)) {
[17:42:11.155]                           master <- get("master", mode = "list", 
[17:42:11.155]                             envir = envir, inherits = FALSE)
[17:42:11.155]                           if (inherits(master, c("SOCKnode", 
[17:42:11.155]                             "SOCK0node"))) {
[17:42:11.155]                             sendCondition <<- function(cond) {
[17:42:11.155]                               data <- list(type = "VALUE", value = cond, 
[17:42:11.155]                                 success = TRUE)
[17:42:11.155]                               parallel_sendData(master, data)
[17:42:11.155]                             }
[17:42:11.155]                             return(sendCondition)
[17:42:11.155]                           }
[17:42:11.155]                         }
[17:42:11.155]                         frame <- frame + 1L
[17:42:11.155]                         envir <- sys.frame(frame)
[17:42:11.155]                       }
[17:42:11.155]                     }
[17:42:11.155]                     sendCondition <<- function(cond) NULL
[17:42:11.155]                   }
[17:42:11.155]                 })
[17:42:11.155]                 withCallingHandlers({
[17:42:11.155]                   {
[17:42:11.155]                     cat("Processing: ")
[17:42:11.155]                     for (ii in 1:10) {
[17:42:11.155]                       cat(".")
[17:42:11.155]                     }
[17:42:11.155]                     cat(" [100%]\n")
[17:42:11.155]                     4
[17:42:11.155]                   }
[17:42:11.155]                 }, immediateCondition = function(cond) {
[17:42:11.155]                   sendCondition <- ...future.makeSendCondition()
[17:42:11.155]                   sendCondition(cond)
[17:42:11.155]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:11.155]                   {
[17:42:11.155]                     inherits <- base::inherits
[17:42:11.155]                     invokeRestart <- base::invokeRestart
[17:42:11.155]                     is.null <- base::is.null
[17:42:11.155]                     muffled <- FALSE
[17:42:11.155]                     if (inherits(cond, "message")) {
[17:42:11.155]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:11.155]                       if (muffled) 
[17:42:11.155]                         invokeRestart("muffleMessage")
[17:42:11.155]                     }
[17:42:11.155]                     else if (inherits(cond, "warning")) {
[17:42:11.155]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:11.155]                       if (muffled) 
[17:42:11.155]                         invokeRestart("muffleWarning")
[17:42:11.155]                     }
[17:42:11.155]                     else if (inherits(cond, "condition")) {
[17:42:11.155]                       if (!is.null(pattern)) {
[17:42:11.155]                         computeRestarts <- base::computeRestarts
[17:42:11.155]                         grepl <- base::grepl
[17:42:11.155]                         restarts <- computeRestarts(cond)
[17:42:11.155]                         for (restart in restarts) {
[17:42:11.155]                           name <- restart$name
[17:42:11.155]                           if (is.null(name)) 
[17:42:11.155]                             next
[17:42:11.155]                           if (!grepl(pattern, name)) 
[17:42:11.155]                             next
[17:42:11.155]                           invokeRestart(restart)
[17:42:11.155]                           muffled <- TRUE
[17:42:11.155]                           break
[17:42:11.155]                         }
[17:42:11.155]                       }
[17:42:11.155]                     }
[17:42:11.155]                     invisible(muffled)
[17:42:11.155]                   }
[17:42:11.155]                   muffleCondition(cond)
[17:42:11.155]                 })
[17:42:11.155]             }))
[17:42:11.155]             future::FutureResult(value = ...future.value$value, 
[17:42:11.155]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:11.155]                   ...future.rng), globalenv = if (FALSE) 
[17:42:11.155]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:11.155]                     ...future.globalenv.names))
[17:42:11.155]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:11.155]         }, condition = base::local({
[17:42:11.155]             c <- base::c
[17:42:11.155]             inherits <- base::inherits
[17:42:11.155]             invokeRestart <- base::invokeRestart
[17:42:11.155]             length <- base::length
[17:42:11.155]             list <- base::list
[17:42:11.155]             seq.int <- base::seq.int
[17:42:11.155]             signalCondition <- base::signalCondition
[17:42:11.155]             sys.calls <- base::sys.calls
[17:42:11.155]             `[[` <- base::`[[`
[17:42:11.155]             `+` <- base::`+`
[17:42:11.155]             `<<-` <- base::`<<-`
[17:42:11.155]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:11.155]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:11.155]                   3L)]
[17:42:11.155]             }
[17:42:11.155]             function(cond) {
[17:42:11.155]                 is_error <- inherits(cond, "error")
[17:42:11.155]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:11.155]                   NULL)
[17:42:11.155]                 if (is_error) {
[17:42:11.155]                   sessionInformation <- function() {
[17:42:11.155]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:11.155]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:11.155]                       search = base::search(), system = base::Sys.info())
[17:42:11.155]                   }
[17:42:11.155]                   ...future.conditions[[length(...future.conditions) + 
[17:42:11.155]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:11.155]                     cond$call), session = sessionInformation(), 
[17:42:11.155]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:11.155]                   signalCondition(cond)
[17:42:11.155]                 }
[17:42:11.155]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:11.155]                 "immediateCondition"))) {
[17:42:11.155]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:11.155]                   ...future.conditions[[length(...future.conditions) + 
[17:42:11.155]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:11.155]                   if (TRUE && !signal) {
[17:42:11.155]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:11.155]                     {
[17:42:11.155]                       inherits <- base::inherits
[17:42:11.155]                       invokeRestart <- base::invokeRestart
[17:42:11.155]                       is.null <- base::is.null
[17:42:11.155]                       muffled <- FALSE
[17:42:11.155]                       if (inherits(cond, "message")) {
[17:42:11.155]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:11.155]                         if (muffled) 
[17:42:11.155]                           invokeRestart("muffleMessage")
[17:42:11.155]                       }
[17:42:11.155]                       else if (inherits(cond, "warning")) {
[17:42:11.155]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:11.155]                         if (muffled) 
[17:42:11.155]                           invokeRestart("muffleWarning")
[17:42:11.155]                       }
[17:42:11.155]                       else if (inherits(cond, "condition")) {
[17:42:11.155]                         if (!is.null(pattern)) {
[17:42:11.155]                           computeRestarts <- base::computeRestarts
[17:42:11.155]                           grepl <- base::grepl
[17:42:11.155]                           restarts <- computeRestarts(cond)
[17:42:11.155]                           for (restart in restarts) {
[17:42:11.155]                             name <- restart$name
[17:42:11.155]                             if (is.null(name)) 
[17:42:11.155]                               next
[17:42:11.155]                             if (!grepl(pattern, name)) 
[17:42:11.155]                               next
[17:42:11.155]                             invokeRestart(restart)
[17:42:11.155]                             muffled <- TRUE
[17:42:11.155]                             break
[17:42:11.155]                           }
[17:42:11.155]                         }
[17:42:11.155]                       }
[17:42:11.155]                       invisible(muffled)
[17:42:11.155]                     }
[17:42:11.155]                     muffleCondition(cond, pattern = "^muffle")
[17:42:11.155]                   }
[17:42:11.155]                 }
[17:42:11.155]                 else {
[17:42:11.155]                   if (TRUE) {
[17:42:11.155]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:11.155]                     {
[17:42:11.155]                       inherits <- base::inherits
[17:42:11.155]                       invokeRestart <- base::invokeRestart
[17:42:11.155]                       is.null <- base::is.null
[17:42:11.155]                       muffled <- FALSE
[17:42:11.155]                       if (inherits(cond, "message")) {
[17:42:11.155]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:11.155]                         if (muffled) 
[17:42:11.155]                           invokeRestart("muffleMessage")
[17:42:11.155]                       }
[17:42:11.155]                       else if (inherits(cond, "warning")) {
[17:42:11.155]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:11.155]                         if (muffled) 
[17:42:11.155]                           invokeRestart("muffleWarning")
[17:42:11.155]                       }
[17:42:11.155]                       else if (inherits(cond, "condition")) {
[17:42:11.155]                         if (!is.null(pattern)) {
[17:42:11.155]                           computeRestarts <- base::computeRestarts
[17:42:11.155]                           grepl <- base::grepl
[17:42:11.155]                           restarts <- computeRestarts(cond)
[17:42:11.155]                           for (restart in restarts) {
[17:42:11.155]                             name <- restart$name
[17:42:11.155]                             if (is.null(name)) 
[17:42:11.155]                               next
[17:42:11.155]                             if (!grepl(pattern, name)) 
[17:42:11.155]                               next
[17:42:11.155]                             invokeRestart(restart)
[17:42:11.155]                             muffled <- TRUE
[17:42:11.155]                             break
[17:42:11.155]                           }
[17:42:11.155]                         }
[17:42:11.155]                       }
[17:42:11.155]                       invisible(muffled)
[17:42:11.155]                     }
[17:42:11.155]                     muffleCondition(cond, pattern = "^muffle")
[17:42:11.155]                   }
[17:42:11.155]                 }
[17:42:11.155]             }
[17:42:11.155]         }))
[17:42:11.155]     }, error = function(ex) {
[17:42:11.155]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:11.155]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:11.155]                 ...future.rng), started = ...future.startTime, 
[17:42:11.155]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:11.155]             version = "1.8"), class = "FutureResult")
[17:42:11.155]     }, finally = {
[17:42:11.155]         if (!identical(...future.workdir, getwd())) 
[17:42:11.155]             setwd(...future.workdir)
[17:42:11.155]         {
[17:42:11.155]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:11.155]                 ...future.oldOptions$nwarnings <- NULL
[17:42:11.155]             }
[17:42:11.155]             base::options(...future.oldOptions)
[17:42:11.155]             if (.Platform$OS.type == "windows") {
[17:42:11.155]                 old_names <- names(...future.oldEnvVars)
[17:42:11.155]                 envs <- base::Sys.getenv()
[17:42:11.155]                 names <- names(envs)
[17:42:11.155]                 common <- intersect(names, old_names)
[17:42:11.155]                 added <- setdiff(names, old_names)
[17:42:11.155]                 removed <- setdiff(old_names, names)
[17:42:11.155]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:11.155]                   envs[common]]
[17:42:11.155]                 NAMES <- toupper(changed)
[17:42:11.155]                 args <- list()
[17:42:11.155]                 for (kk in seq_along(NAMES)) {
[17:42:11.155]                   name <- changed[[kk]]
[17:42:11.155]                   NAME <- NAMES[[kk]]
[17:42:11.155]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:11.155]                     next
[17:42:11.155]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:11.155]                 }
[17:42:11.155]                 NAMES <- toupper(added)
[17:42:11.155]                 for (kk in seq_along(NAMES)) {
[17:42:11.155]                   name <- added[[kk]]
[17:42:11.155]                   NAME <- NAMES[[kk]]
[17:42:11.155]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:11.155]                     next
[17:42:11.155]                   args[[name]] <- ""
[17:42:11.155]                 }
[17:42:11.155]                 NAMES <- toupper(removed)
[17:42:11.155]                 for (kk in seq_along(NAMES)) {
[17:42:11.155]                   name <- removed[[kk]]
[17:42:11.155]                   NAME <- NAMES[[kk]]
[17:42:11.155]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:11.155]                     next
[17:42:11.155]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:11.155]                 }
[17:42:11.155]                 if (length(args) > 0) 
[17:42:11.155]                   base::do.call(base::Sys.setenv, args = args)
[17:42:11.155]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:11.155]             }
[17:42:11.155]             else {
[17:42:11.155]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:11.155]             }
[17:42:11.155]             {
[17:42:11.155]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:11.155]                   0L) {
[17:42:11.155]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:11.155]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:11.155]                   base::options(opts)
[17:42:11.155]                 }
[17:42:11.155]                 {
[17:42:11.155]                   {
[17:42:11.155]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:11.155]                     NULL
[17:42:11.155]                   }
[17:42:11.155]                   options(future.plan = NULL)
[17:42:11.155]                   if (is.na(NA_character_)) 
[17:42:11.155]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:11.155]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:11.155]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:11.155]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:11.155]                     envir = parent.frame()) 
[17:42:11.155]                   {
[17:42:11.155]                     if (is.function(workers)) 
[17:42:11.155]                       workers <- workers()
[17:42:11.155]                     workers <- structure(as.integer(workers), 
[17:42:11.155]                       class = class(workers))
[17:42:11.155]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:11.155]                       workers >= 1)
[17:42:11.155]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:11.155]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:11.155]                     }
[17:42:11.155]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:11.155]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:11.155]                       envir = envir)
[17:42:11.155]                     if (!future$lazy) 
[17:42:11.155]                       future <- run(future)
[17:42:11.155]                     invisible(future)
[17:42:11.155]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:11.155]                 }
[17:42:11.155]             }
[17:42:11.155]         }
[17:42:11.155]     })
[17:42:11.155]     if (TRUE) {
[17:42:11.155]         base::sink(type = "output", split = FALSE)
[17:42:11.155]         if (TRUE) {
[17:42:11.155]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:11.155]         }
[17:42:11.155]         else {
[17:42:11.155]             ...future.result["stdout"] <- base::list(NULL)
[17:42:11.155]         }
[17:42:11.155]         base::close(...future.stdout)
[17:42:11.155]         ...future.stdout <- NULL
[17:42:11.155]     }
[17:42:11.155]     ...future.result$conditions <- ...future.conditions
[17:42:11.155]     ...future.result$finished <- base::Sys.time()
[17:42:11.155]     ...future.result
[17:42:11.155] }
[17:42:11.158] MultisessionFuture started
[17:42:11.159] - Launch lazy future ... done
[17:42:11.159] run() for ‘MultisessionFuture’ ... done
** Collecting results
v1 = 1
v2 = 2
Warning in sprintf(...) : restarting interrupted promise evaluation
[17:42:11.159] result() for ClusterFuture ...
[17:42:11.159] - result already collected: FutureResult
[17:42:11.159] result() for ClusterFuture ... done
[17:42:11.160] result() for ClusterFuture ...
[17:42:11.160] - result already collected: FutureResult
[17:42:11.160] result() for ClusterFuture ... done
[17:42:11.160] signalConditions() ...
[17:42:11.160]  - include = ‘immediateCondition’
[17:42:11.160]  - exclude = 
[17:42:11.160]  - resignal = FALSE
[17:42:11.160]  - Number of conditions: 1
[17:42:11.160] signalConditions() ... done
[17:42:11.160] Future state: ‘finished’
[17:42:11.161] result() for ClusterFuture ...
[17:42:11.161] - result already collected: FutureResult
[17:42:11.161] result() for ClusterFuture ... done
[17:42:11.161] signalConditions() ...
[17:42:11.161]  - include = ‘condition’
[17:42:11.161]  - exclude = ‘immediateCondition’
[17:42:11.161]  - resignal = TRUE
[17:42:11.161]  - Number of conditions: 1
[17:42:11.161]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:42:11.161] signalConditions() ... done
v3: <simpleError> (as expect)
[17:42:11.161] result() for ClusterFuture ...
[17:42:11.162] receiveMessageFromWorker() for ClusterFuture ...
[17:42:11.162] - Validating connection of MultisessionFuture
[17:42:11.204] - received message: FutureResult
[17:42:11.204] - Received FutureResult
[17:42:11.204] - Erased future from FutureRegistry
[17:42:11.205] result() for ClusterFuture ...
[17:42:11.205] - result already collected: FutureResult
[17:42:11.205] result() for ClusterFuture ... done
[17:42:11.205] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:11.205] result() for ClusterFuture ... done
[17:42:11.205] result() for ClusterFuture ...
[17:42:11.205] - result already collected: FutureResult
[17:42:11.205] result() for ClusterFuture ... done
Processing: .......... [100%]
v4 = 4
** Left-to-right and right-to-left future assignments
[17:42:11.206] getGlobalsAndPackages() ...
[17:42:11.206] Searching for globals...
[17:42:11.206] 
[17:42:11.206] Searching for globals ... DONE
[17:42:11.206] - globals: [0] <none>
[17:42:11.206] getGlobalsAndPackages() ... DONE
[17:42:11.207] run() for ‘Future’ ...
[17:42:11.207] - state: ‘created’
[17:42:11.207] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:11.221] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:11.222] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:11.222]   - Field: ‘node’
[17:42:11.222]   - Field: ‘label’
[17:42:11.222]   - Field: ‘local’
[17:42:11.222]   - Field: ‘owner’
[17:42:11.222]   - Field: ‘envir’
[17:42:11.222]   - Field: ‘workers’
[17:42:11.222]   - Field: ‘packages’
[17:42:11.222]   - Field: ‘gc’
[17:42:11.222]   - Field: ‘conditions’
[17:42:11.223]   - Field: ‘persistent’
[17:42:11.223]   - Field: ‘expr’
[17:42:11.223]   - Field: ‘uuid’
[17:42:11.223]   - Field: ‘seed’
[17:42:11.223]   - Field: ‘version’
[17:42:11.223]   - Field: ‘result’
[17:42:11.223]   - Field: ‘asynchronous’
[17:42:11.223]   - Field: ‘calls’
[17:42:11.223]   - Field: ‘globals’
[17:42:11.223]   - Field: ‘stdout’
[17:42:11.224]   - Field: ‘earlySignal’
[17:42:11.224]   - Field: ‘lazy’
[17:42:11.224]   - Field: ‘state’
[17:42:11.224] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:11.224] - Launch lazy future ...
[17:42:11.224] Packages needed by the future expression (n = 0): <none>
[17:42:11.224] Packages needed by future strategies (n = 0): <none>
[17:42:11.230] {
[17:42:11.230]     {
[17:42:11.230]         {
[17:42:11.230]             ...future.startTime <- base::Sys.time()
[17:42:11.230]             {
[17:42:11.230]                 {
[17:42:11.230]                   {
[17:42:11.230]                     {
[17:42:11.230]                       base::local({
[17:42:11.230]                         has_future <- base::requireNamespace("future", 
[17:42:11.230]                           quietly = TRUE)
[17:42:11.230]                         if (has_future) {
[17:42:11.230]                           ns <- base::getNamespace("future")
[17:42:11.230]                           version <- ns[[".package"]][["version"]]
[17:42:11.230]                           if (is.null(version)) 
[17:42:11.230]                             version <- utils::packageVersion("future")
[17:42:11.230]                         }
[17:42:11.230]                         else {
[17:42:11.230]                           version <- NULL
[17:42:11.230]                         }
[17:42:11.230]                         if (!has_future || version < "1.8.0") {
[17:42:11.230]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:11.230]                             "", base::R.version$version.string), 
[17:42:11.230]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:11.230]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:11.230]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:11.230]                               "release", "version")], collapse = " "), 
[17:42:11.230]                             hostname = base::Sys.info()[["nodename"]])
[17:42:11.230]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:11.230]                             info)
[17:42:11.230]                           info <- base::paste(info, collapse = "; ")
[17:42:11.230]                           if (!has_future) {
[17:42:11.230]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:11.230]                               info)
[17:42:11.230]                           }
[17:42:11.230]                           else {
[17:42:11.230]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:11.230]                               info, version)
[17:42:11.230]                           }
[17:42:11.230]                           base::stop(msg)
[17:42:11.230]                         }
[17:42:11.230]                       })
[17:42:11.230]                     }
[17:42:11.230]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:11.230]                     base::options(mc.cores = 1L)
[17:42:11.230]                   }
[17:42:11.230]                   options(future.plan = NULL)
[17:42:11.230]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:11.230]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:11.230]                 }
[17:42:11.230]                 ...future.workdir <- getwd()
[17:42:11.230]             }
[17:42:11.230]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:11.230]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:11.230]         }
[17:42:11.230]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:11.230]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:11.230]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:11.230]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:11.230]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:11.230]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:11.230]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:11.230]             base::names(...future.oldOptions))
[17:42:11.230]     }
[17:42:11.230]     if (FALSE) {
[17:42:11.230]     }
[17:42:11.230]     else {
[17:42:11.230]         if (TRUE) {
[17:42:11.230]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:11.230]                 open = "w")
[17:42:11.230]         }
[17:42:11.230]         else {
[17:42:11.230]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:11.230]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:11.230]         }
[17:42:11.230]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:11.230]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:11.230]             base::sink(type = "output", split = FALSE)
[17:42:11.230]             base::close(...future.stdout)
[17:42:11.230]         }, add = TRUE)
[17:42:11.230]     }
[17:42:11.230]     ...future.frame <- base::sys.nframe()
[17:42:11.230]     ...future.conditions <- base::list()
[17:42:11.230]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:11.230]     if (FALSE) {
[17:42:11.230]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:11.230]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:11.230]     }
[17:42:11.230]     ...future.result <- base::tryCatch({
[17:42:11.230]         base::withCallingHandlers({
[17:42:11.230]             ...future.value <- base::withVisible(base::local({
[17:42:11.230]                 ...future.makeSendCondition <- local({
[17:42:11.230]                   sendCondition <- NULL
[17:42:11.230]                   function(frame = 1L) {
[17:42:11.230]                     if (is.function(sendCondition)) 
[17:42:11.230]                       return(sendCondition)
[17:42:11.230]                     ns <- getNamespace("parallel")
[17:42:11.230]                     if (exists("sendData", mode = "function", 
[17:42:11.230]                       envir = ns)) {
[17:42:11.230]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:11.230]                         envir = ns)
[17:42:11.230]                       envir <- sys.frame(frame)
[17:42:11.230]                       master <- NULL
[17:42:11.230]                       while (!identical(envir, .GlobalEnv) && 
[17:42:11.230]                         !identical(envir, emptyenv())) {
[17:42:11.230]                         if (exists("master", mode = "list", envir = envir, 
[17:42:11.230]                           inherits = FALSE)) {
[17:42:11.230]                           master <- get("master", mode = "list", 
[17:42:11.230]                             envir = envir, inherits = FALSE)
[17:42:11.230]                           if (inherits(master, c("SOCKnode", 
[17:42:11.230]                             "SOCK0node"))) {
[17:42:11.230]                             sendCondition <<- function(cond) {
[17:42:11.230]                               data <- list(type = "VALUE", value = cond, 
[17:42:11.230]                                 success = TRUE)
[17:42:11.230]                               parallel_sendData(master, data)
[17:42:11.230]                             }
[17:42:11.230]                             return(sendCondition)
[17:42:11.230]                           }
[17:42:11.230]                         }
[17:42:11.230]                         frame <- frame + 1L
[17:42:11.230]                         envir <- sys.frame(frame)
[17:42:11.230]                       }
[17:42:11.230]                     }
[17:42:11.230]                     sendCondition <<- function(cond) NULL
[17:42:11.230]                   }
[17:42:11.230]                 })
[17:42:11.230]                 withCallingHandlers({
[17:42:11.230]                   1
[17:42:11.230]                 }, immediateCondition = function(cond) {
[17:42:11.230]                   sendCondition <- ...future.makeSendCondition()
[17:42:11.230]                   sendCondition(cond)
[17:42:11.230]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:11.230]                   {
[17:42:11.230]                     inherits <- base::inherits
[17:42:11.230]                     invokeRestart <- base::invokeRestart
[17:42:11.230]                     is.null <- base::is.null
[17:42:11.230]                     muffled <- FALSE
[17:42:11.230]                     if (inherits(cond, "message")) {
[17:42:11.230]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:11.230]                       if (muffled) 
[17:42:11.230]                         invokeRestart("muffleMessage")
[17:42:11.230]                     }
[17:42:11.230]                     else if (inherits(cond, "warning")) {
[17:42:11.230]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:11.230]                       if (muffled) 
[17:42:11.230]                         invokeRestart("muffleWarning")
[17:42:11.230]                     }
[17:42:11.230]                     else if (inherits(cond, "condition")) {
[17:42:11.230]                       if (!is.null(pattern)) {
[17:42:11.230]                         computeRestarts <- base::computeRestarts
[17:42:11.230]                         grepl <- base::grepl
[17:42:11.230]                         restarts <- computeRestarts(cond)
[17:42:11.230]                         for (restart in restarts) {
[17:42:11.230]                           name <- restart$name
[17:42:11.230]                           if (is.null(name)) 
[17:42:11.230]                             next
[17:42:11.230]                           if (!grepl(pattern, name)) 
[17:42:11.230]                             next
[17:42:11.230]                           invokeRestart(restart)
[17:42:11.230]                           muffled <- TRUE
[17:42:11.230]                           break
[17:42:11.230]                         }
[17:42:11.230]                       }
[17:42:11.230]                     }
[17:42:11.230]                     invisible(muffled)
[17:42:11.230]                   }
[17:42:11.230]                   muffleCondition(cond)
[17:42:11.230]                 })
[17:42:11.230]             }))
[17:42:11.230]             future::FutureResult(value = ...future.value$value, 
[17:42:11.230]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:11.230]                   ...future.rng), globalenv = if (FALSE) 
[17:42:11.230]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:11.230]                     ...future.globalenv.names))
[17:42:11.230]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:11.230]         }, condition = base::local({
[17:42:11.230]             c <- base::c
[17:42:11.230]             inherits <- base::inherits
[17:42:11.230]             invokeRestart <- base::invokeRestart
[17:42:11.230]             length <- base::length
[17:42:11.230]             list <- base::list
[17:42:11.230]             seq.int <- base::seq.int
[17:42:11.230]             signalCondition <- base::signalCondition
[17:42:11.230]             sys.calls <- base::sys.calls
[17:42:11.230]             `[[` <- base::`[[`
[17:42:11.230]             `+` <- base::`+`
[17:42:11.230]             `<<-` <- base::`<<-`
[17:42:11.230]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:11.230]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:11.230]                   3L)]
[17:42:11.230]             }
[17:42:11.230]             function(cond) {
[17:42:11.230]                 is_error <- inherits(cond, "error")
[17:42:11.230]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:11.230]                   NULL)
[17:42:11.230]                 if (is_error) {
[17:42:11.230]                   sessionInformation <- function() {
[17:42:11.230]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:11.230]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:11.230]                       search = base::search(), system = base::Sys.info())
[17:42:11.230]                   }
[17:42:11.230]                   ...future.conditions[[length(...future.conditions) + 
[17:42:11.230]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:11.230]                     cond$call), session = sessionInformation(), 
[17:42:11.230]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:11.230]                   signalCondition(cond)
[17:42:11.230]                 }
[17:42:11.230]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:11.230]                 "immediateCondition"))) {
[17:42:11.230]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:11.230]                   ...future.conditions[[length(...future.conditions) + 
[17:42:11.230]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:11.230]                   if (TRUE && !signal) {
[17:42:11.230]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:11.230]                     {
[17:42:11.230]                       inherits <- base::inherits
[17:42:11.230]                       invokeRestart <- base::invokeRestart
[17:42:11.230]                       is.null <- base::is.null
[17:42:11.230]                       muffled <- FALSE
[17:42:11.230]                       if (inherits(cond, "message")) {
[17:42:11.230]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:11.230]                         if (muffled) 
[17:42:11.230]                           invokeRestart("muffleMessage")
[17:42:11.230]                       }
[17:42:11.230]                       else if (inherits(cond, "warning")) {
[17:42:11.230]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:11.230]                         if (muffled) 
[17:42:11.230]                           invokeRestart("muffleWarning")
[17:42:11.230]                       }
[17:42:11.230]                       else if (inherits(cond, "condition")) {
[17:42:11.230]                         if (!is.null(pattern)) {
[17:42:11.230]                           computeRestarts <- base::computeRestarts
[17:42:11.230]                           grepl <- base::grepl
[17:42:11.230]                           restarts <- computeRestarts(cond)
[17:42:11.230]                           for (restart in restarts) {
[17:42:11.230]                             name <- restart$name
[17:42:11.230]                             if (is.null(name)) 
[17:42:11.230]                               next
[17:42:11.230]                             if (!grepl(pattern, name)) 
[17:42:11.230]                               next
[17:42:11.230]                             invokeRestart(restart)
[17:42:11.230]                             muffled <- TRUE
[17:42:11.230]                             break
[17:42:11.230]                           }
[17:42:11.230]                         }
[17:42:11.230]                       }
[17:42:11.230]                       invisible(muffled)
[17:42:11.230]                     }
[17:42:11.230]                     muffleCondition(cond, pattern = "^muffle")
[17:42:11.230]                   }
[17:42:11.230]                 }
[17:42:11.230]                 else {
[17:42:11.230]                   if (TRUE) {
[17:42:11.230]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:11.230]                     {
[17:42:11.230]                       inherits <- base::inherits
[17:42:11.230]                       invokeRestart <- base::invokeRestart
[17:42:11.230]                       is.null <- base::is.null
[17:42:11.230]                       muffled <- FALSE
[17:42:11.230]                       if (inherits(cond, "message")) {
[17:42:11.230]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:11.230]                         if (muffled) 
[17:42:11.230]                           invokeRestart("muffleMessage")
[17:42:11.230]                       }
[17:42:11.230]                       else if (inherits(cond, "warning")) {
[17:42:11.230]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:11.230]                         if (muffled) 
[17:42:11.230]                           invokeRestart("muffleWarning")
[17:42:11.230]                       }
[17:42:11.230]                       else if (inherits(cond, "condition")) {
[17:42:11.230]                         if (!is.null(pattern)) {
[17:42:11.230]                           computeRestarts <- base::computeRestarts
[17:42:11.230]                           grepl <- base::grepl
[17:42:11.230]                           restarts <- computeRestarts(cond)
[17:42:11.230]                           for (restart in restarts) {
[17:42:11.230]                             name <- restart$name
[17:42:11.230]                             if (is.null(name)) 
[17:42:11.230]                               next
[17:42:11.230]                             if (!grepl(pattern, name)) 
[17:42:11.230]                               next
[17:42:11.230]                             invokeRestart(restart)
[17:42:11.230]                             muffled <- TRUE
[17:42:11.230]                             break
[17:42:11.230]                           }
[17:42:11.230]                         }
[17:42:11.230]                       }
[17:42:11.230]                       invisible(muffled)
[17:42:11.230]                     }
[17:42:11.230]                     muffleCondition(cond, pattern = "^muffle")
[17:42:11.230]                   }
[17:42:11.230]                 }
[17:42:11.230]             }
[17:42:11.230]         }))
[17:42:11.230]     }, error = function(ex) {
[17:42:11.230]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:11.230]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:11.230]                 ...future.rng), started = ...future.startTime, 
[17:42:11.230]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:11.230]             version = "1.8"), class = "FutureResult")
[17:42:11.230]     }, finally = {
[17:42:11.230]         if (!identical(...future.workdir, getwd())) 
[17:42:11.230]             setwd(...future.workdir)
[17:42:11.230]         {
[17:42:11.230]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:11.230]                 ...future.oldOptions$nwarnings <- NULL
[17:42:11.230]             }
[17:42:11.230]             base::options(...future.oldOptions)
[17:42:11.230]             if (.Platform$OS.type == "windows") {
[17:42:11.230]                 old_names <- names(...future.oldEnvVars)
[17:42:11.230]                 envs <- base::Sys.getenv()
[17:42:11.230]                 names <- names(envs)
[17:42:11.230]                 common <- intersect(names, old_names)
[17:42:11.230]                 added <- setdiff(names, old_names)
[17:42:11.230]                 removed <- setdiff(old_names, names)
[17:42:11.230]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:11.230]                   envs[common]]
[17:42:11.230]                 NAMES <- toupper(changed)
[17:42:11.230]                 args <- list()
[17:42:11.230]                 for (kk in seq_along(NAMES)) {
[17:42:11.230]                   name <- changed[[kk]]
[17:42:11.230]                   NAME <- NAMES[[kk]]
[17:42:11.230]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:11.230]                     next
[17:42:11.230]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:11.230]                 }
[17:42:11.230]                 NAMES <- toupper(added)
[17:42:11.230]                 for (kk in seq_along(NAMES)) {
[17:42:11.230]                   name <- added[[kk]]
[17:42:11.230]                   NAME <- NAMES[[kk]]
[17:42:11.230]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:11.230]                     next
[17:42:11.230]                   args[[name]] <- ""
[17:42:11.230]                 }
[17:42:11.230]                 NAMES <- toupper(removed)
[17:42:11.230]                 for (kk in seq_along(NAMES)) {
[17:42:11.230]                   name <- removed[[kk]]
[17:42:11.230]                   NAME <- NAMES[[kk]]
[17:42:11.230]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:11.230]                     next
[17:42:11.230]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:11.230]                 }
[17:42:11.230]                 if (length(args) > 0) 
[17:42:11.230]                   base::do.call(base::Sys.setenv, args = args)
[17:42:11.230]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:11.230]             }
[17:42:11.230]             else {
[17:42:11.230]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:11.230]             }
[17:42:11.230]             {
[17:42:11.230]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:11.230]                   0L) {
[17:42:11.230]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:11.230]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:11.230]                   base::options(opts)
[17:42:11.230]                 }
[17:42:11.230]                 {
[17:42:11.230]                   {
[17:42:11.230]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:11.230]                     NULL
[17:42:11.230]                   }
[17:42:11.230]                   options(future.plan = NULL)
[17:42:11.230]                   if (is.na(NA_character_)) 
[17:42:11.230]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:11.230]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:11.230]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:11.230]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:11.230]                     envir = parent.frame()) 
[17:42:11.230]                   {
[17:42:11.230]                     if (is.function(workers)) 
[17:42:11.230]                       workers <- workers()
[17:42:11.230]                     workers <- structure(as.integer(workers), 
[17:42:11.230]                       class = class(workers))
[17:42:11.230]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:11.230]                       workers >= 1)
[17:42:11.230]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:11.230]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:11.230]                     }
[17:42:11.230]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:11.230]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:11.230]                       envir = envir)
[17:42:11.230]                     if (!future$lazy) 
[17:42:11.230]                       future <- run(future)
[17:42:11.230]                     invisible(future)
[17:42:11.230]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:11.230]                 }
[17:42:11.230]             }
[17:42:11.230]         }
[17:42:11.230]     })
[17:42:11.230]     if (TRUE) {
[17:42:11.230]         base::sink(type = "output", split = FALSE)
[17:42:11.230]         if (TRUE) {
[17:42:11.230]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:11.230]         }
[17:42:11.230]         else {
[17:42:11.230]             ...future.result["stdout"] <- base::list(NULL)
[17:42:11.230]         }
[17:42:11.230]         base::close(...future.stdout)
[17:42:11.230]         ...future.stdout <- NULL
[17:42:11.230]     }
[17:42:11.230]     ...future.result$conditions <- ...future.conditions
[17:42:11.230]     ...future.result$finished <- base::Sys.time()
[17:42:11.230]     ...future.result
[17:42:11.230] }
[17:42:11.233] MultisessionFuture started
[17:42:11.233] - Launch lazy future ... done
[17:42:11.234] run() for ‘MultisessionFuture’ ... done
[17:42:11.234] result() for ClusterFuture ...
[17:42:11.234] receiveMessageFromWorker() for ClusterFuture ...
[17:42:11.234] - Validating connection of MultisessionFuture
[17:42:11.280] - received message: FutureResult
[17:42:11.280] - Received FutureResult
[17:42:11.281] - Erased future from FutureRegistry
[17:42:11.281] result() for ClusterFuture ...
[17:42:11.281] - result already collected: FutureResult
[17:42:11.281] result() for ClusterFuture ... done
[17:42:11.281] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:11.281] result() for ClusterFuture ... done
[17:42:11.281] result() for ClusterFuture ...
[17:42:11.281] - result already collected: FutureResult
[17:42:11.281] result() for ClusterFuture ... done
c = 1
[17:42:11.282] getGlobalsAndPackages() ...
[17:42:11.282] Searching for globals...
[17:42:11.282] 
[17:42:11.282] Searching for globals ... DONE
[17:42:11.282] - globals: [0] <none>
[17:42:11.282] getGlobalsAndPackages() ... DONE
[17:42:11.283] run() for ‘Future’ ...
[17:42:11.283] - state: ‘created’
[17:42:11.283] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:11.297] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:11.297] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:11.297]   - Field: ‘node’
[17:42:11.297]   - Field: ‘label’
[17:42:11.298]   - Field: ‘local’
[17:42:11.298]   - Field: ‘owner’
[17:42:11.298]   - Field: ‘envir’
[17:42:11.298]   - Field: ‘workers’
[17:42:11.298]   - Field: ‘packages’
[17:42:11.298]   - Field: ‘gc’
[17:42:11.298]   - Field: ‘conditions’
[17:42:11.298]   - Field: ‘persistent’
[17:42:11.298]   - Field: ‘expr’
[17:42:11.298]   - Field: ‘uuid’
[17:42:11.298]   - Field: ‘seed’
[17:42:11.299]   - Field: ‘version’
[17:42:11.299]   - Field: ‘result’
[17:42:11.299]   - Field: ‘asynchronous’
[17:42:11.299]   - Field: ‘calls’
[17:42:11.299]   - Field: ‘globals’
[17:42:11.299]   - Field: ‘stdout’
[17:42:11.299]   - Field: ‘earlySignal’
[17:42:11.299]   - Field: ‘lazy’
[17:42:11.299]   - Field: ‘state’
[17:42:11.299] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:11.299] - Launch lazy future ...
[17:42:11.300] Packages needed by the future expression (n = 0): <none>
[17:42:11.300] Packages needed by future strategies (n = 0): <none>
[17:42:11.300] {
[17:42:11.300]     {
[17:42:11.300]         {
[17:42:11.300]             ...future.startTime <- base::Sys.time()
[17:42:11.300]             {
[17:42:11.300]                 {
[17:42:11.300]                   {
[17:42:11.300]                     {
[17:42:11.300]                       base::local({
[17:42:11.300]                         has_future <- base::requireNamespace("future", 
[17:42:11.300]                           quietly = TRUE)
[17:42:11.300]                         if (has_future) {
[17:42:11.300]                           ns <- base::getNamespace("future")
[17:42:11.300]                           version <- ns[[".package"]][["version"]]
[17:42:11.300]                           if (is.null(version)) 
[17:42:11.300]                             version <- utils::packageVersion("future")
[17:42:11.300]                         }
[17:42:11.300]                         else {
[17:42:11.300]                           version <- NULL
[17:42:11.300]                         }
[17:42:11.300]                         if (!has_future || version < "1.8.0") {
[17:42:11.300]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:11.300]                             "", base::R.version$version.string), 
[17:42:11.300]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:11.300]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:11.300]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:11.300]                               "release", "version")], collapse = " "), 
[17:42:11.300]                             hostname = base::Sys.info()[["nodename"]])
[17:42:11.300]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:11.300]                             info)
[17:42:11.300]                           info <- base::paste(info, collapse = "; ")
[17:42:11.300]                           if (!has_future) {
[17:42:11.300]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:11.300]                               info)
[17:42:11.300]                           }
[17:42:11.300]                           else {
[17:42:11.300]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:11.300]                               info, version)
[17:42:11.300]                           }
[17:42:11.300]                           base::stop(msg)
[17:42:11.300]                         }
[17:42:11.300]                       })
[17:42:11.300]                     }
[17:42:11.300]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:11.300]                     base::options(mc.cores = 1L)
[17:42:11.300]                   }
[17:42:11.300]                   options(future.plan = NULL)
[17:42:11.300]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:11.300]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:11.300]                 }
[17:42:11.300]                 ...future.workdir <- getwd()
[17:42:11.300]             }
[17:42:11.300]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:11.300]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:11.300]         }
[17:42:11.300]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:11.300]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:11.300]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:11.300]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:11.300]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:11.300]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:11.300]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:11.300]             base::names(...future.oldOptions))
[17:42:11.300]     }
[17:42:11.300]     if (FALSE) {
[17:42:11.300]     }
[17:42:11.300]     else {
[17:42:11.300]         if (TRUE) {
[17:42:11.300]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:11.300]                 open = "w")
[17:42:11.300]         }
[17:42:11.300]         else {
[17:42:11.300]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:11.300]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:11.300]         }
[17:42:11.300]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:11.300]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:11.300]             base::sink(type = "output", split = FALSE)
[17:42:11.300]             base::close(...future.stdout)
[17:42:11.300]         }, add = TRUE)
[17:42:11.300]     }
[17:42:11.300]     ...future.frame <- base::sys.nframe()
[17:42:11.300]     ...future.conditions <- base::list()
[17:42:11.300]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:11.300]     if (FALSE) {
[17:42:11.300]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:11.300]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:11.300]     }
[17:42:11.300]     ...future.result <- base::tryCatch({
[17:42:11.300]         base::withCallingHandlers({
[17:42:11.300]             ...future.value <- base::withVisible(base::local({
[17:42:11.300]                 ...future.makeSendCondition <- local({
[17:42:11.300]                   sendCondition <- NULL
[17:42:11.300]                   function(frame = 1L) {
[17:42:11.300]                     if (is.function(sendCondition)) 
[17:42:11.300]                       return(sendCondition)
[17:42:11.300]                     ns <- getNamespace("parallel")
[17:42:11.300]                     if (exists("sendData", mode = "function", 
[17:42:11.300]                       envir = ns)) {
[17:42:11.300]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:11.300]                         envir = ns)
[17:42:11.300]                       envir <- sys.frame(frame)
[17:42:11.300]                       master <- NULL
[17:42:11.300]                       while (!identical(envir, .GlobalEnv) && 
[17:42:11.300]                         !identical(envir, emptyenv())) {
[17:42:11.300]                         if (exists("master", mode = "list", envir = envir, 
[17:42:11.300]                           inherits = FALSE)) {
[17:42:11.300]                           master <- get("master", mode = "list", 
[17:42:11.300]                             envir = envir, inherits = FALSE)
[17:42:11.300]                           if (inherits(master, c("SOCKnode", 
[17:42:11.300]                             "SOCK0node"))) {
[17:42:11.300]                             sendCondition <<- function(cond) {
[17:42:11.300]                               data <- list(type = "VALUE", value = cond, 
[17:42:11.300]                                 success = TRUE)
[17:42:11.300]                               parallel_sendData(master, data)
[17:42:11.300]                             }
[17:42:11.300]                             return(sendCondition)
[17:42:11.300]                           }
[17:42:11.300]                         }
[17:42:11.300]                         frame <- frame + 1L
[17:42:11.300]                         envir <- sys.frame(frame)
[17:42:11.300]                       }
[17:42:11.300]                     }
[17:42:11.300]                     sendCondition <<- function(cond) NULL
[17:42:11.300]                   }
[17:42:11.300]                 })
[17:42:11.300]                 withCallingHandlers({
[17:42:11.300]                   1
[17:42:11.300]                 }, immediateCondition = function(cond) {
[17:42:11.300]                   sendCondition <- ...future.makeSendCondition()
[17:42:11.300]                   sendCondition(cond)
[17:42:11.300]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:11.300]                   {
[17:42:11.300]                     inherits <- base::inherits
[17:42:11.300]                     invokeRestart <- base::invokeRestart
[17:42:11.300]                     is.null <- base::is.null
[17:42:11.300]                     muffled <- FALSE
[17:42:11.300]                     if (inherits(cond, "message")) {
[17:42:11.300]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:11.300]                       if (muffled) 
[17:42:11.300]                         invokeRestart("muffleMessage")
[17:42:11.300]                     }
[17:42:11.300]                     else if (inherits(cond, "warning")) {
[17:42:11.300]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:11.300]                       if (muffled) 
[17:42:11.300]                         invokeRestart("muffleWarning")
[17:42:11.300]                     }
[17:42:11.300]                     else if (inherits(cond, "condition")) {
[17:42:11.300]                       if (!is.null(pattern)) {
[17:42:11.300]                         computeRestarts <- base::computeRestarts
[17:42:11.300]                         grepl <- base::grepl
[17:42:11.300]                         restarts <- computeRestarts(cond)
[17:42:11.300]                         for (restart in restarts) {
[17:42:11.300]                           name <- restart$name
[17:42:11.300]                           if (is.null(name)) 
[17:42:11.300]                             next
[17:42:11.300]                           if (!grepl(pattern, name)) 
[17:42:11.300]                             next
[17:42:11.300]                           invokeRestart(restart)
[17:42:11.300]                           muffled <- TRUE
[17:42:11.300]                           break
[17:42:11.300]                         }
[17:42:11.300]                       }
[17:42:11.300]                     }
[17:42:11.300]                     invisible(muffled)
[17:42:11.300]                   }
[17:42:11.300]                   muffleCondition(cond)
[17:42:11.300]                 })
[17:42:11.300]             }))
[17:42:11.300]             future::FutureResult(value = ...future.value$value, 
[17:42:11.300]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:11.300]                   ...future.rng), globalenv = if (FALSE) 
[17:42:11.300]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:11.300]                     ...future.globalenv.names))
[17:42:11.300]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:11.300]         }, condition = base::local({
[17:42:11.300]             c <- base::c
[17:42:11.300]             inherits <- base::inherits
[17:42:11.300]             invokeRestart <- base::invokeRestart
[17:42:11.300]             length <- base::length
[17:42:11.300]             list <- base::list
[17:42:11.300]             seq.int <- base::seq.int
[17:42:11.300]             signalCondition <- base::signalCondition
[17:42:11.300]             sys.calls <- base::sys.calls
[17:42:11.300]             `[[` <- base::`[[`
[17:42:11.300]             `+` <- base::`+`
[17:42:11.300]             `<<-` <- base::`<<-`
[17:42:11.300]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:11.300]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:11.300]                   3L)]
[17:42:11.300]             }
[17:42:11.300]             function(cond) {
[17:42:11.300]                 is_error <- inherits(cond, "error")
[17:42:11.300]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:11.300]                   NULL)
[17:42:11.300]                 if (is_error) {
[17:42:11.300]                   sessionInformation <- function() {
[17:42:11.300]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:11.300]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:11.300]                       search = base::search(), system = base::Sys.info())
[17:42:11.300]                   }
[17:42:11.300]                   ...future.conditions[[length(...future.conditions) + 
[17:42:11.300]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:11.300]                     cond$call), session = sessionInformation(), 
[17:42:11.300]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:11.300]                   signalCondition(cond)
[17:42:11.300]                 }
[17:42:11.300]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:11.300]                 "immediateCondition"))) {
[17:42:11.300]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:11.300]                   ...future.conditions[[length(...future.conditions) + 
[17:42:11.300]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:11.300]                   if (TRUE && !signal) {
[17:42:11.300]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:11.300]                     {
[17:42:11.300]                       inherits <- base::inherits
[17:42:11.300]                       invokeRestart <- base::invokeRestart
[17:42:11.300]                       is.null <- base::is.null
[17:42:11.300]                       muffled <- FALSE
[17:42:11.300]                       if (inherits(cond, "message")) {
[17:42:11.300]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:11.300]                         if (muffled) 
[17:42:11.300]                           invokeRestart("muffleMessage")
[17:42:11.300]                       }
[17:42:11.300]                       else if (inherits(cond, "warning")) {
[17:42:11.300]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:11.300]                         if (muffled) 
[17:42:11.300]                           invokeRestart("muffleWarning")
[17:42:11.300]                       }
[17:42:11.300]                       else if (inherits(cond, "condition")) {
[17:42:11.300]                         if (!is.null(pattern)) {
[17:42:11.300]                           computeRestarts <- base::computeRestarts
[17:42:11.300]                           grepl <- base::grepl
[17:42:11.300]                           restarts <- computeRestarts(cond)
[17:42:11.300]                           for (restart in restarts) {
[17:42:11.300]                             name <- restart$name
[17:42:11.300]                             if (is.null(name)) 
[17:42:11.300]                               next
[17:42:11.300]                             if (!grepl(pattern, name)) 
[17:42:11.300]                               next
[17:42:11.300]                             invokeRestart(restart)
[17:42:11.300]                             muffled <- TRUE
[17:42:11.300]                             break
[17:42:11.300]                           }
[17:42:11.300]                         }
[17:42:11.300]                       }
[17:42:11.300]                       invisible(muffled)
[17:42:11.300]                     }
[17:42:11.300]                     muffleCondition(cond, pattern = "^muffle")
[17:42:11.300]                   }
[17:42:11.300]                 }
[17:42:11.300]                 else {
[17:42:11.300]                   if (TRUE) {
[17:42:11.300]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:11.300]                     {
[17:42:11.300]                       inherits <- base::inherits
[17:42:11.300]                       invokeRestart <- base::invokeRestart
[17:42:11.300]                       is.null <- base::is.null
[17:42:11.300]                       muffled <- FALSE
[17:42:11.300]                       if (inherits(cond, "message")) {
[17:42:11.300]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:11.300]                         if (muffled) 
[17:42:11.300]                           invokeRestart("muffleMessage")
[17:42:11.300]                       }
[17:42:11.300]                       else if (inherits(cond, "warning")) {
[17:42:11.300]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:11.300]                         if (muffled) 
[17:42:11.300]                           invokeRestart("muffleWarning")
[17:42:11.300]                       }
[17:42:11.300]                       else if (inherits(cond, "condition")) {
[17:42:11.300]                         if (!is.null(pattern)) {
[17:42:11.300]                           computeRestarts <- base::computeRestarts
[17:42:11.300]                           grepl <- base::grepl
[17:42:11.300]                           restarts <- computeRestarts(cond)
[17:42:11.300]                           for (restart in restarts) {
[17:42:11.300]                             name <- restart$name
[17:42:11.300]                             if (is.null(name)) 
[17:42:11.300]                               next
[17:42:11.300]                             if (!grepl(pattern, name)) 
[17:42:11.300]                               next
[17:42:11.300]                             invokeRestart(restart)
[17:42:11.300]                             muffled <- TRUE
[17:42:11.300]                             break
[17:42:11.300]                           }
[17:42:11.300]                         }
[17:42:11.300]                       }
[17:42:11.300]                       invisible(muffled)
[17:42:11.300]                     }
[17:42:11.300]                     muffleCondition(cond, pattern = "^muffle")
[17:42:11.300]                   }
[17:42:11.300]                 }
[17:42:11.300]             }
[17:42:11.300]         }))
[17:42:11.300]     }, error = function(ex) {
[17:42:11.300]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:11.300]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:11.300]                 ...future.rng), started = ...future.startTime, 
[17:42:11.300]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:11.300]             version = "1.8"), class = "FutureResult")
[17:42:11.300]     }, finally = {
[17:42:11.300]         if (!identical(...future.workdir, getwd())) 
[17:42:11.300]             setwd(...future.workdir)
[17:42:11.300]         {
[17:42:11.300]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:11.300]                 ...future.oldOptions$nwarnings <- NULL
[17:42:11.300]             }
[17:42:11.300]             base::options(...future.oldOptions)
[17:42:11.300]             if (.Platform$OS.type == "windows") {
[17:42:11.300]                 old_names <- names(...future.oldEnvVars)
[17:42:11.300]                 envs <- base::Sys.getenv()
[17:42:11.300]                 names <- names(envs)
[17:42:11.300]                 common <- intersect(names, old_names)
[17:42:11.300]                 added <- setdiff(names, old_names)
[17:42:11.300]                 removed <- setdiff(old_names, names)
[17:42:11.300]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:11.300]                   envs[common]]
[17:42:11.300]                 NAMES <- toupper(changed)
[17:42:11.300]                 args <- list()
[17:42:11.300]                 for (kk in seq_along(NAMES)) {
[17:42:11.300]                   name <- changed[[kk]]
[17:42:11.300]                   NAME <- NAMES[[kk]]
[17:42:11.300]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:11.300]                     next
[17:42:11.300]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:11.300]                 }
[17:42:11.300]                 NAMES <- toupper(added)
[17:42:11.300]                 for (kk in seq_along(NAMES)) {
[17:42:11.300]                   name <- added[[kk]]
[17:42:11.300]                   NAME <- NAMES[[kk]]
[17:42:11.300]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:11.300]                     next
[17:42:11.300]                   args[[name]] <- ""
[17:42:11.300]                 }
[17:42:11.300]                 NAMES <- toupper(removed)
[17:42:11.300]                 for (kk in seq_along(NAMES)) {
[17:42:11.300]                   name <- removed[[kk]]
[17:42:11.300]                   NAME <- NAMES[[kk]]
[17:42:11.300]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:11.300]                     next
[17:42:11.300]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:11.300]                 }
[17:42:11.300]                 if (length(args) > 0) 
[17:42:11.300]                   base::do.call(base::Sys.setenv, args = args)
[17:42:11.300]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:11.300]             }
[17:42:11.300]             else {
[17:42:11.300]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:11.300]             }
[17:42:11.300]             {
[17:42:11.300]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:11.300]                   0L) {
[17:42:11.300]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:11.300]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:11.300]                   base::options(opts)
[17:42:11.300]                 }
[17:42:11.300]                 {
[17:42:11.300]                   {
[17:42:11.300]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:11.300]                     NULL
[17:42:11.300]                   }
[17:42:11.300]                   options(future.plan = NULL)
[17:42:11.300]                   if (is.na(NA_character_)) 
[17:42:11.300]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:11.300]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:11.300]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:11.300]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:11.300]                     envir = parent.frame()) 
[17:42:11.300]                   {
[17:42:11.300]                     if (is.function(workers)) 
[17:42:11.300]                       workers <- workers()
[17:42:11.300]                     workers <- structure(as.integer(workers), 
[17:42:11.300]                       class = class(workers))
[17:42:11.300]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:11.300]                       workers >= 1)
[17:42:11.300]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:11.300]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:11.300]                     }
[17:42:11.300]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:11.300]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:11.300]                       envir = envir)
[17:42:11.300]                     if (!future$lazy) 
[17:42:11.300]                       future <- run(future)
[17:42:11.300]                     invisible(future)
[17:42:11.300]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:11.300]                 }
[17:42:11.300]             }
[17:42:11.300]         }
[17:42:11.300]     })
[17:42:11.300]     if (TRUE) {
[17:42:11.300]         base::sink(type = "output", split = FALSE)
[17:42:11.300]         if (TRUE) {
[17:42:11.300]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:11.300]         }
[17:42:11.300]         else {
[17:42:11.300]             ...future.result["stdout"] <- base::list(NULL)
[17:42:11.300]         }
[17:42:11.300]         base::close(...future.stdout)
[17:42:11.300]         ...future.stdout <- NULL
[17:42:11.300]     }
[17:42:11.300]     ...future.result$conditions <- ...future.conditions
[17:42:11.300]     ...future.result$finished <- base::Sys.time()
[17:42:11.300]     ...future.result
[17:42:11.300] }
[17:42:11.304] MultisessionFuture started
[17:42:11.304] - Launch lazy future ... done
[17:42:11.304] run() for ‘MultisessionFuture’ ... done
[17:42:11.304] result() for ClusterFuture ...
[17:42:11.304] receiveMessageFromWorker() for ClusterFuture ...
[17:42:11.304] - Validating connection of MultisessionFuture
[17:42:11.352] - received message: FutureResult
[17:42:11.352] - Received FutureResult
[17:42:11.352] - Erased future from FutureRegistry
[17:42:11.352] result() for ClusterFuture ...
[17:42:11.352] - result already collected: FutureResult
[17:42:11.352] result() for ClusterFuture ... done
[17:42:11.352] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:11.352] result() for ClusterFuture ... done
[17:42:11.353] result() for ClusterFuture ...
[17:42:11.353] - result already collected: FutureResult
[17:42:11.353] result() for ClusterFuture ... done
d = 1
** Nested future assignments
[17:42:11.353] getGlobalsAndPackages() ...
[17:42:11.353] Searching for globals...
[17:42:11.357] - globals found: [5] ‘{’, ‘<-’, ‘%<-%’, ‘%->%’, ‘+’
[17:42:11.357] Searching for globals ... DONE
[17:42:11.357] Resolving globals: FALSE
[17:42:11.358] 
[17:42:11.358] - packages: [1] ‘future’
[17:42:11.358] getGlobalsAndPackages() ... DONE
[17:42:11.358] run() for ‘Future’ ...
[17:42:11.358] - state: ‘created’
[17:42:11.358] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:11.373] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:11.373] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:11.373]   - Field: ‘node’
[17:42:11.373]   - Field: ‘label’
[17:42:11.373]   - Field: ‘local’
[17:42:11.374]   - Field: ‘owner’
[17:42:11.374]   - Field: ‘envir’
[17:42:11.374]   - Field: ‘workers’
[17:42:11.374]   - Field: ‘packages’
[17:42:11.374]   - Field: ‘gc’
[17:42:11.374]   - Field: ‘conditions’
[17:42:11.374]   - Field: ‘persistent’
[17:42:11.374]   - Field: ‘expr’
[17:42:11.374]   - Field: ‘uuid’
[17:42:11.374]   - Field: ‘seed’
[17:42:11.374]   - Field: ‘version’
[17:42:11.375]   - Field: ‘result’
[17:42:11.375]   - Field: ‘asynchronous’
[17:42:11.375]   - Field: ‘calls’
[17:42:11.375]   - Field: ‘globals’
[17:42:11.375]   - Field: ‘stdout’
[17:42:11.375]   - Field: ‘earlySignal’
[17:42:11.375]   - Field: ‘lazy’
[17:42:11.375]   - Field: ‘state’
[17:42:11.375] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:11.376] - Launch lazy future ...
[17:42:11.376] Packages needed by the future expression (n = 1): ‘future’
[17:42:11.376] Packages needed by future strategies (n = 0): <none>
[17:42:11.377] {
[17:42:11.377]     {
[17:42:11.377]         {
[17:42:11.377]             ...future.startTime <- base::Sys.time()
[17:42:11.377]             {
[17:42:11.377]                 {
[17:42:11.377]                   {
[17:42:11.377]                     {
[17:42:11.377]                       {
[17:42:11.377]                         base::local({
[17:42:11.377]                           has_future <- base::requireNamespace("future", 
[17:42:11.377]                             quietly = TRUE)
[17:42:11.377]                           if (has_future) {
[17:42:11.377]                             ns <- base::getNamespace("future")
[17:42:11.377]                             version <- ns[[".package"]][["version"]]
[17:42:11.377]                             if (is.null(version)) 
[17:42:11.377]                               version <- utils::packageVersion("future")
[17:42:11.377]                           }
[17:42:11.377]                           else {
[17:42:11.377]                             version <- NULL
[17:42:11.377]                           }
[17:42:11.377]                           if (!has_future || version < "1.8.0") {
[17:42:11.377]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:11.377]                               "", base::R.version$version.string), 
[17:42:11.377]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:11.377]                                 base::R.version$platform, 8 * 
[17:42:11.377]                                   base::.Machine$sizeof.pointer), 
[17:42:11.377]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:11.377]                                 "release", "version")], collapse = " "), 
[17:42:11.377]                               hostname = base::Sys.info()[["nodename"]])
[17:42:11.377]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:11.377]                               info)
[17:42:11.377]                             info <- base::paste(info, collapse = "; ")
[17:42:11.377]                             if (!has_future) {
[17:42:11.377]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:11.377]                                 info)
[17:42:11.377]                             }
[17:42:11.377]                             else {
[17:42:11.377]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:11.377]                                 info, version)
[17:42:11.377]                             }
[17:42:11.377]                             base::stop(msg)
[17:42:11.377]                           }
[17:42:11.377]                         })
[17:42:11.377]                       }
[17:42:11.377]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:11.377]                       base::options(mc.cores = 1L)
[17:42:11.377]                     }
[17:42:11.377]                     base::local({
[17:42:11.377]                       for (pkg in "future") {
[17:42:11.377]                         base::loadNamespace(pkg)
[17:42:11.377]                         base::library(pkg, character.only = TRUE)
[17:42:11.377]                       }
[17:42:11.377]                     })
[17:42:11.377]                   }
[17:42:11.377]                   options(future.plan = NULL)
[17:42:11.377]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:11.377]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:11.377]                 }
[17:42:11.377]                 ...future.workdir <- getwd()
[17:42:11.377]             }
[17:42:11.377]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:11.377]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:11.377]         }
[17:42:11.377]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:11.377]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:11.377]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:11.377]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:11.377]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:11.377]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:11.377]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:11.377]             base::names(...future.oldOptions))
[17:42:11.377]     }
[17:42:11.377]     if (FALSE) {
[17:42:11.377]     }
[17:42:11.377]     else {
[17:42:11.377]         if (TRUE) {
[17:42:11.377]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:11.377]                 open = "w")
[17:42:11.377]         }
[17:42:11.377]         else {
[17:42:11.377]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:11.377]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:11.377]         }
[17:42:11.377]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:11.377]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:11.377]             base::sink(type = "output", split = FALSE)
[17:42:11.377]             base::close(...future.stdout)
[17:42:11.377]         }, add = TRUE)
[17:42:11.377]     }
[17:42:11.377]     ...future.frame <- base::sys.nframe()
[17:42:11.377]     ...future.conditions <- base::list()
[17:42:11.377]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:11.377]     if (FALSE) {
[17:42:11.377]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:11.377]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:11.377]     }
[17:42:11.377]     ...future.result <- base::tryCatch({
[17:42:11.377]         base::withCallingHandlers({
[17:42:11.377]             ...future.value <- base::withVisible(base::local({
[17:42:11.377]                 ...future.makeSendCondition <- local({
[17:42:11.377]                   sendCondition <- NULL
[17:42:11.377]                   function(frame = 1L) {
[17:42:11.377]                     if (is.function(sendCondition)) 
[17:42:11.377]                       return(sendCondition)
[17:42:11.377]                     ns <- getNamespace("parallel")
[17:42:11.377]                     if (exists("sendData", mode = "function", 
[17:42:11.377]                       envir = ns)) {
[17:42:11.377]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:11.377]                         envir = ns)
[17:42:11.377]                       envir <- sys.frame(frame)
[17:42:11.377]                       master <- NULL
[17:42:11.377]                       while (!identical(envir, .GlobalEnv) && 
[17:42:11.377]                         !identical(envir, emptyenv())) {
[17:42:11.377]                         if (exists("master", mode = "list", envir = envir, 
[17:42:11.377]                           inherits = FALSE)) {
[17:42:11.377]                           master <- get("master", mode = "list", 
[17:42:11.377]                             envir = envir, inherits = FALSE)
[17:42:11.377]                           if (inherits(master, c("SOCKnode", 
[17:42:11.377]                             "SOCK0node"))) {
[17:42:11.377]                             sendCondition <<- function(cond) {
[17:42:11.377]                               data <- list(type = "VALUE", value = cond, 
[17:42:11.377]                                 success = TRUE)
[17:42:11.377]                               parallel_sendData(master, data)
[17:42:11.377]                             }
[17:42:11.377]                             return(sendCondition)
[17:42:11.377]                           }
[17:42:11.377]                         }
[17:42:11.377]                         frame <- frame + 1L
[17:42:11.377]                         envir <- sys.frame(frame)
[17:42:11.377]                       }
[17:42:11.377]                     }
[17:42:11.377]                     sendCondition <<- function(cond) NULL
[17:42:11.377]                   }
[17:42:11.377]                 })
[17:42:11.377]                 withCallingHandlers({
[17:42:11.377]                   {
[17:42:11.377]                     b <- 1
[17:42:11.377]                     c %<-% 2
[17:42:11.377]                     d <- 3
[17:42:11.377]                     4 %->% e
[17:42:11.377]                     b + c + d + e
[17:42:11.377]                   }
[17:42:11.377]                 }, immediateCondition = function(cond) {
[17:42:11.377]                   sendCondition <- ...future.makeSendCondition()
[17:42:11.377]                   sendCondition(cond)
[17:42:11.377]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:11.377]                   {
[17:42:11.377]                     inherits <- base::inherits
[17:42:11.377]                     invokeRestart <- base::invokeRestart
[17:42:11.377]                     is.null <- base::is.null
[17:42:11.377]                     muffled <- FALSE
[17:42:11.377]                     if (inherits(cond, "message")) {
[17:42:11.377]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:11.377]                       if (muffled) 
[17:42:11.377]                         invokeRestart("muffleMessage")
[17:42:11.377]                     }
[17:42:11.377]                     else if (inherits(cond, "warning")) {
[17:42:11.377]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:11.377]                       if (muffled) 
[17:42:11.377]                         invokeRestart("muffleWarning")
[17:42:11.377]                     }
[17:42:11.377]                     else if (inherits(cond, "condition")) {
[17:42:11.377]                       if (!is.null(pattern)) {
[17:42:11.377]                         computeRestarts <- base::computeRestarts
[17:42:11.377]                         grepl <- base::grepl
[17:42:11.377]                         restarts <- computeRestarts(cond)
[17:42:11.377]                         for (restart in restarts) {
[17:42:11.377]                           name <- restart$name
[17:42:11.377]                           if (is.null(name)) 
[17:42:11.377]                             next
[17:42:11.377]                           if (!grepl(pattern, name)) 
[17:42:11.377]                             next
[17:42:11.377]                           invokeRestart(restart)
[17:42:11.377]                           muffled <- TRUE
[17:42:11.377]                           break
[17:42:11.377]                         }
[17:42:11.377]                       }
[17:42:11.377]                     }
[17:42:11.377]                     invisible(muffled)
[17:42:11.377]                   }
[17:42:11.377]                   muffleCondition(cond)
[17:42:11.377]                 })
[17:42:11.377]             }))
[17:42:11.377]             future::FutureResult(value = ...future.value$value, 
[17:42:11.377]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:11.377]                   ...future.rng), globalenv = if (FALSE) 
[17:42:11.377]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:11.377]                     ...future.globalenv.names))
[17:42:11.377]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:11.377]         }, condition = base::local({
[17:42:11.377]             c <- base::c
[17:42:11.377]             inherits <- base::inherits
[17:42:11.377]             invokeRestart <- base::invokeRestart
[17:42:11.377]             length <- base::length
[17:42:11.377]             list <- base::list
[17:42:11.377]             seq.int <- base::seq.int
[17:42:11.377]             signalCondition <- base::signalCondition
[17:42:11.377]             sys.calls <- base::sys.calls
[17:42:11.377]             `[[` <- base::`[[`
[17:42:11.377]             `+` <- base::`+`
[17:42:11.377]             `<<-` <- base::`<<-`
[17:42:11.377]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:11.377]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:11.377]                   3L)]
[17:42:11.377]             }
[17:42:11.377]             function(cond) {
[17:42:11.377]                 is_error <- inherits(cond, "error")
[17:42:11.377]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:11.377]                   NULL)
[17:42:11.377]                 if (is_error) {
[17:42:11.377]                   sessionInformation <- function() {
[17:42:11.377]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:11.377]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:11.377]                       search = base::search(), system = base::Sys.info())
[17:42:11.377]                   }
[17:42:11.377]                   ...future.conditions[[length(...future.conditions) + 
[17:42:11.377]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:11.377]                     cond$call), session = sessionInformation(), 
[17:42:11.377]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:11.377]                   signalCondition(cond)
[17:42:11.377]                 }
[17:42:11.377]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:11.377]                 "immediateCondition"))) {
[17:42:11.377]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:11.377]                   ...future.conditions[[length(...future.conditions) + 
[17:42:11.377]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:11.377]                   if (TRUE && !signal) {
[17:42:11.377]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:11.377]                     {
[17:42:11.377]                       inherits <- base::inherits
[17:42:11.377]                       invokeRestart <- base::invokeRestart
[17:42:11.377]                       is.null <- base::is.null
[17:42:11.377]                       muffled <- FALSE
[17:42:11.377]                       if (inherits(cond, "message")) {
[17:42:11.377]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:11.377]                         if (muffled) 
[17:42:11.377]                           invokeRestart("muffleMessage")
[17:42:11.377]                       }
[17:42:11.377]                       else if (inherits(cond, "warning")) {
[17:42:11.377]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:11.377]                         if (muffled) 
[17:42:11.377]                           invokeRestart("muffleWarning")
[17:42:11.377]                       }
[17:42:11.377]                       else if (inherits(cond, "condition")) {
[17:42:11.377]                         if (!is.null(pattern)) {
[17:42:11.377]                           computeRestarts <- base::computeRestarts
[17:42:11.377]                           grepl <- base::grepl
[17:42:11.377]                           restarts <- computeRestarts(cond)
[17:42:11.377]                           for (restart in restarts) {
[17:42:11.377]                             name <- restart$name
[17:42:11.377]                             if (is.null(name)) 
[17:42:11.377]                               next
[17:42:11.377]                             if (!grepl(pattern, name)) 
[17:42:11.377]                               next
[17:42:11.377]                             invokeRestart(restart)
[17:42:11.377]                             muffled <- TRUE
[17:42:11.377]                             break
[17:42:11.377]                           }
[17:42:11.377]                         }
[17:42:11.377]                       }
[17:42:11.377]                       invisible(muffled)
[17:42:11.377]                     }
[17:42:11.377]                     muffleCondition(cond, pattern = "^muffle")
[17:42:11.377]                   }
[17:42:11.377]                 }
[17:42:11.377]                 else {
[17:42:11.377]                   if (TRUE) {
[17:42:11.377]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:11.377]                     {
[17:42:11.377]                       inherits <- base::inherits
[17:42:11.377]                       invokeRestart <- base::invokeRestart
[17:42:11.377]                       is.null <- base::is.null
[17:42:11.377]                       muffled <- FALSE
[17:42:11.377]                       if (inherits(cond, "message")) {
[17:42:11.377]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:11.377]                         if (muffled) 
[17:42:11.377]                           invokeRestart("muffleMessage")
[17:42:11.377]                       }
[17:42:11.377]                       else if (inherits(cond, "warning")) {
[17:42:11.377]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:11.377]                         if (muffled) 
[17:42:11.377]                           invokeRestart("muffleWarning")
[17:42:11.377]                       }
[17:42:11.377]                       else if (inherits(cond, "condition")) {
[17:42:11.377]                         if (!is.null(pattern)) {
[17:42:11.377]                           computeRestarts <- base::computeRestarts
[17:42:11.377]                           grepl <- base::grepl
[17:42:11.377]                           restarts <- computeRestarts(cond)
[17:42:11.377]                           for (restart in restarts) {
[17:42:11.377]                             name <- restart$name
[17:42:11.377]                             if (is.null(name)) 
[17:42:11.377]                               next
[17:42:11.377]                             if (!grepl(pattern, name)) 
[17:42:11.377]                               next
[17:42:11.377]                             invokeRestart(restart)
[17:42:11.377]                             muffled <- TRUE
[17:42:11.377]                             break
[17:42:11.377]                           }
[17:42:11.377]                         }
[17:42:11.377]                       }
[17:42:11.377]                       invisible(muffled)
[17:42:11.377]                     }
[17:42:11.377]                     muffleCondition(cond, pattern = "^muffle")
[17:42:11.377]                   }
[17:42:11.377]                 }
[17:42:11.377]             }
[17:42:11.377]         }))
[17:42:11.377]     }, error = function(ex) {
[17:42:11.377]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:11.377]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:11.377]                 ...future.rng), started = ...future.startTime, 
[17:42:11.377]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:11.377]             version = "1.8"), class = "FutureResult")
[17:42:11.377]     }, finally = {
[17:42:11.377]         if (!identical(...future.workdir, getwd())) 
[17:42:11.377]             setwd(...future.workdir)
[17:42:11.377]         {
[17:42:11.377]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:11.377]                 ...future.oldOptions$nwarnings <- NULL
[17:42:11.377]             }
[17:42:11.377]             base::options(...future.oldOptions)
[17:42:11.377]             if (.Platform$OS.type == "windows") {
[17:42:11.377]                 old_names <- names(...future.oldEnvVars)
[17:42:11.377]                 envs <- base::Sys.getenv()
[17:42:11.377]                 names <- names(envs)
[17:42:11.377]                 common <- intersect(names, old_names)
[17:42:11.377]                 added <- setdiff(names, old_names)
[17:42:11.377]                 removed <- setdiff(old_names, names)
[17:42:11.377]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:11.377]                   envs[common]]
[17:42:11.377]                 NAMES <- toupper(changed)
[17:42:11.377]                 args <- list()
[17:42:11.377]                 for (kk in seq_along(NAMES)) {
[17:42:11.377]                   name <- changed[[kk]]
[17:42:11.377]                   NAME <- NAMES[[kk]]
[17:42:11.377]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:11.377]                     next
[17:42:11.377]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:11.377]                 }
[17:42:11.377]                 NAMES <- toupper(added)
[17:42:11.377]                 for (kk in seq_along(NAMES)) {
[17:42:11.377]                   name <- added[[kk]]
[17:42:11.377]                   NAME <- NAMES[[kk]]
[17:42:11.377]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:11.377]                     next
[17:42:11.377]                   args[[name]] <- ""
[17:42:11.377]                 }
[17:42:11.377]                 NAMES <- toupper(removed)
[17:42:11.377]                 for (kk in seq_along(NAMES)) {
[17:42:11.377]                   name <- removed[[kk]]
[17:42:11.377]                   NAME <- NAMES[[kk]]
[17:42:11.377]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:11.377]                     next
[17:42:11.377]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:11.377]                 }
[17:42:11.377]                 if (length(args) > 0) 
[17:42:11.377]                   base::do.call(base::Sys.setenv, args = args)
[17:42:11.377]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:11.377]             }
[17:42:11.377]             else {
[17:42:11.377]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:11.377]             }
[17:42:11.377]             {
[17:42:11.377]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:11.377]                   0L) {
[17:42:11.377]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:11.377]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:11.377]                   base::options(opts)
[17:42:11.377]                 }
[17:42:11.377]                 {
[17:42:11.377]                   {
[17:42:11.377]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:11.377]                     NULL
[17:42:11.377]                   }
[17:42:11.377]                   options(future.plan = NULL)
[17:42:11.377]                   if (is.na(NA_character_)) 
[17:42:11.377]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:11.377]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:11.377]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:11.377]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:11.377]                     envir = parent.frame()) 
[17:42:11.377]                   {
[17:42:11.377]                     if (is.function(workers)) 
[17:42:11.377]                       workers <- workers()
[17:42:11.377]                     workers <- structure(as.integer(workers), 
[17:42:11.377]                       class = class(workers))
[17:42:11.377]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:11.377]                       workers >= 1)
[17:42:11.377]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:11.377]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:11.377]                     }
[17:42:11.377]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:11.377]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:11.377]                       envir = envir)
[17:42:11.377]                     if (!future$lazy) 
[17:42:11.377]                       future <- run(future)
[17:42:11.377]                     invisible(future)
[17:42:11.377]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:11.377]                 }
[17:42:11.377]             }
[17:42:11.377]         }
[17:42:11.377]     })
[17:42:11.377]     if (TRUE) {
[17:42:11.377]         base::sink(type = "output", split = FALSE)
[17:42:11.377]         if (TRUE) {
[17:42:11.377]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:11.377]         }
[17:42:11.377]         else {
[17:42:11.377]             ...future.result["stdout"] <- base::list(NULL)
[17:42:11.377]         }
[17:42:11.377]         base::close(...future.stdout)
[17:42:11.377]         ...future.stdout <- NULL
[17:42:11.377]     }
[17:42:11.377]     ...future.result$conditions <- ...future.conditions
[17:42:11.377]     ...future.result$finished <- base::Sys.time()
[17:42:11.377]     ...future.result
[17:42:11.377] }
[17:42:11.380] MultisessionFuture started
[17:42:11.380] - Launch lazy future ... done
[17:42:11.380] run() for ‘MultisessionFuture’ ... done
[17:42:11.380] result() for ClusterFuture ...
[17:42:11.380] receiveMessageFromWorker() for ClusterFuture ...
[17:42:11.380] - Validating connection of MultisessionFuture
[17:42:11.443] - received message: FutureResult
[17:42:11.443] - Received FutureResult
[17:42:11.443] - Erased future from FutureRegistry
[17:42:11.443] result() for ClusterFuture ...
[17:42:11.443] - result already collected: FutureResult
[17:42:11.443] result() for ClusterFuture ... done
[17:42:11.444] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:11.444] result() for ClusterFuture ... done
[17:42:11.444] result() for ClusterFuture ...
[17:42:11.444] - result already collected: FutureResult
[17:42:11.444] result() for ClusterFuture ... done
a = 10
[17:42:11.444] getGlobalsAndPackages() ...
[17:42:11.444] Searching for globals...
[17:42:11.445] - globals found: [3] ‘{’, ‘+’, ‘a’
[17:42:11.445] Searching for globals ... DONE
[17:42:11.446] Resolving globals: FALSE
[17:42:11.446] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:11.446] The total size of the 1 globals exported for future expression (‘{; a + 1; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[17:42:11.446] - globals: [1] ‘a’
[17:42:11.447] 
[17:42:11.447] getGlobalsAndPackages() ... DONE
[17:42:11.447] run() for ‘Future’ ...
[17:42:11.447] - state: ‘created’
[17:42:11.447] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:11.462] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:11.462] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:11.462]   - Field: ‘node’
[17:42:11.462]   - Field: ‘label’
[17:42:11.462]   - Field: ‘local’
[17:42:11.462]   - Field: ‘owner’
[17:42:11.462]   - Field: ‘envir’
[17:42:11.462]   - Field: ‘workers’
[17:42:11.463]   - Field: ‘packages’
[17:42:11.463]   - Field: ‘gc’
[17:42:11.463]   - Field: ‘conditions’
[17:42:11.463]   - Field: ‘persistent’
[17:42:11.463]   - Field: ‘expr’
[17:42:11.463]   - Field: ‘uuid’
[17:42:11.463]   - Field: ‘seed’
[17:42:11.463]   - Field: ‘version’
[17:42:11.463]   - Field: ‘result’
[17:42:11.463]   - Field: ‘asynchronous’
[17:42:11.464]   - Field: ‘calls’
[17:42:11.464]   - Field: ‘globals’
[17:42:11.464]   - Field: ‘stdout’
[17:42:11.464]   - Field: ‘earlySignal’
[17:42:11.464]   - Field: ‘lazy’
[17:42:11.464]   - Field: ‘state’
[17:42:11.464] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:11.464] - Launch lazy future ...
[17:42:11.464] Packages needed by the future expression (n = 0): <none>
[17:42:11.465] Packages needed by future strategies (n = 0): <none>
[17:42:11.465] {
[17:42:11.465]     {
[17:42:11.465]         {
[17:42:11.465]             ...future.startTime <- base::Sys.time()
[17:42:11.465]             {
[17:42:11.465]                 {
[17:42:11.465]                   {
[17:42:11.465]                     {
[17:42:11.465]                       base::local({
[17:42:11.465]                         has_future <- base::requireNamespace("future", 
[17:42:11.465]                           quietly = TRUE)
[17:42:11.465]                         if (has_future) {
[17:42:11.465]                           ns <- base::getNamespace("future")
[17:42:11.465]                           version <- ns[[".package"]][["version"]]
[17:42:11.465]                           if (is.null(version)) 
[17:42:11.465]                             version <- utils::packageVersion("future")
[17:42:11.465]                         }
[17:42:11.465]                         else {
[17:42:11.465]                           version <- NULL
[17:42:11.465]                         }
[17:42:11.465]                         if (!has_future || version < "1.8.0") {
[17:42:11.465]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:11.465]                             "", base::R.version$version.string), 
[17:42:11.465]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:11.465]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:11.465]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:11.465]                               "release", "version")], collapse = " "), 
[17:42:11.465]                             hostname = base::Sys.info()[["nodename"]])
[17:42:11.465]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:11.465]                             info)
[17:42:11.465]                           info <- base::paste(info, collapse = "; ")
[17:42:11.465]                           if (!has_future) {
[17:42:11.465]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:11.465]                               info)
[17:42:11.465]                           }
[17:42:11.465]                           else {
[17:42:11.465]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:11.465]                               info, version)
[17:42:11.465]                           }
[17:42:11.465]                           base::stop(msg)
[17:42:11.465]                         }
[17:42:11.465]                       })
[17:42:11.465]                     }
[17:42:11.465]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:11.465]                     base::options(mc.cores = 1L)
[17:42:11.465]                   }
[17:42:11.465]                   options(future.plan = NULL)
[17:42:11.465]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:11.465]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:11.465]                 }
[17:42:11.465]                 ...future.workdir <- getwd()
[17:42:11.465]             }
[17:42:11.465]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:11.465]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:11.465]         }
[17:42:11.465]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:11.465]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:11.465]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:11.465]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:11.465]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:11.465]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:11.465]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:11.465]             base::names(...future.oldOptions))
[17:42:11.465]     }
[17:42:11.465]     if (FALSE) {
[17:42:11.465]     }
[17:42:11.465]     else {
[17:42:11.465]         if (TRUE) {
[17:42:11.465]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:11.465]                 open = "w")
[17:42:11.465]         }
[17:42:11.465]         else {
[17:42:11.465]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:11.465]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:11.465]         }
[17:42:11.465]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:11.465]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:11.465]             base::sink(type = "output", split = FALSE)
[17:42:11.465]             base::close(...future.stdout)
[17:42:11.465]         }, add = TRUE)
[17:42:11.465]     }
[17:42:11.465]     ...future.frame <- base::sys.nframe()
[17:42:11.465]     ...future.conditions <- base::list()
[17:42:11.465]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:11.465]     if (FALSE) {
[17:42:11.465]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:11.465]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:11.465]     }
[17:42:11.465]     ...future.result <- base::tryCatch({
[17:42:11.465]         base::withCallingHandlers({
[17:42:11.465]             ...future.value <- base::withVisible(base::local({
[17:42:11.465]                 ...future.makeSendCondition <- local({
[17:42:11.465]                   sendCondition <- NULL
[17:42:11.465]                   function(frame = 1L) {
[17:42:11.465]                     if (is.function(sendCondition)) 
[17:42:11.465]                       return(sendCondition)
[17:42:11.465]                     ns <- getNamespace("parallel")
[17:42:11.465]                     if (exists("sendData", mode = "function", 
[17:42:11.465]                       envir = ns)) {
[17:42:11.465]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:11.465]                         envir = ns)
[17:42:11.465]                       envir <- sys.frame(frame)
[17:42:11.465]                       master <- NULL
[17:42:11.465]                       while (!identical(envir, .GlobalEnv) && 
[17:42:11.465]                         !identical(envir, emptyenv())) {
[17:42:11.465]                         if (exists("master", mode = "list", envir = envir, 
[17:42:11.465]                           inherits = FALSE)) {
[17:42:11.465]                           master <- get("master", mode = "list", 
[17:42:11.465]                             envir = envir, inherits = FALSE)
[17:42:11.465]                           if (inherits(master, c("SOCKnode", 
[17:42:11.465]                             "SOCK0node"))) {
[17:42:11.465]                             sendCondition <<- function(cond) {
[17:42:11.465]                               data <- list(type = "VALUE", value = cond, 
[17:42:11.465]                                 success = TRUE)
[17:42:11.465]                               parallel_sendData(master, data)
[17:42:11.465]                             }
[17:42:11.465]                             return(sendCondition)
[17:42:11.465]                           }
[17:42:11.465]                         }
[17:42:11.465]                         frame <- frame + 1L
[17:42:11.465]                         envir <- sys.frame(frame)
[17:42:11.465]                       }
[17:42:11.465]                     }
[17:42:11.465]                     sendCondition <<- function(cond) NULL
[17:42:11.465]                   }
[17:42:11.465]                 })
[17:42:11.465]                 withCallingHandlers({
[17:42:11.465]                   {
[17:42:11.465]                     a + 1
[17:42:11.465]                   }
[17:42:11.465]                 }, immediateCondition = function(cond) {
[17:42:11.465]                   sendCondition <- ...future.makeSendCondition()
[17:42:11.465]                   sendCondition(cond)
[17:42:11.465]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:11.465]                   {
[17:42:11.465]                     inherits <- base::inherits
[17:42:11.465]                     invokeRestart <- base::invokeRestart
[17:42:11.465]                     is.null <- base::is.null
[17:42:11.465]                     muffled <- FALSE
[17:42:11.465]                     if (inherits(cond, "message")) {
[17:42:11.465]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:11.465]                       if (muffled) 
[17:42:11.465]                         invokeRestart("muffleMessage")
[17:42:11.465]                     }
[17:42:11.465]                     else if (inherits(cond, "warning")) {
[17:42:11.465]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:11.465]                       if (muffled) 
[17:42:11.465]                         invokeRestart("muffleWarning")
[17:42:11.465]                     }
[17:42:11.465]                     else if (inherits(cond, "condition")) {
[17:42:11.465]                       if (!is.null(pattern)) {
[17:42:11.465]                         computeRestarts <- base::computeRestarts
[17:42:11.465]                         grepl <- base::grepl
[17:42:11.465]                         restarts <- computeRestarts(cond)
[17:42:11.465]                         for (restart in restarts) {
[17:42:11.465]                           name <- restart$name
[17:42:11.465]                           if (is.null(name)) 
[17:42:11.465]                             next
[17:42:11.465]                           if (!grepl(pattern, name)) 
[17:42:11.465]                             next
[17:42:11.465]                           invokeRestart(restart)
[17:42:11.465]                           muffled <- TRUE
[17:42:11.465]                           break
[17:42:11.465]                         }
[17:42:11.465]                       }
[17:42:11.465]                     }
[17:42:11.465]                     invisible(muffled)
[17:42:11.465]                   }
[17:42:11.465]                   muffleCondition(cond)
[17:42:11.465]                 })
[17:42:11.465]             }))
[17:42:11.465]             future::FutureResult(value = ...future.value$value, 
[17:42:11.465]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:11.465]                   ...future.rng), globalenv = if (FALSE) 
[17:42:11.465]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:11.465]                     ...future.globalenv.names))
[17:42:11.465]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:11.465]         }, condition = base::local({
[17:42:11.465]             c <- base::c
[17:42:11.465]             inherits <- base::inherits
[17:42:11.465]             invokeRestart <- base::invokeRestart
[17:42:11.465]             length <- base::length
[17:42:11.465]             list <- base::list
[17:42:11.465]             seq.int <- base::seq.int
[17:42:11.465]             signalCondition <- base::signalCondition
[17:42:11.465]             sys.calls <- base::sys.calls
[17:42:11.465]             `[[` <- base::`[[`
[17:42:11.465]             `+` <- base::`+`
[17:42:11.465]             `<<-` <- base::`<<-`
[17:42:11.465]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:11.465]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:11.465]                   3L)]
[17:42:11.465]             }
[17:42:11.465]             function(cond) {
[17:42:11.465]                 is_error <- inherits(cond, "error")
[17:42:11.465]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:11.465]                   NULL)
[17:42:11.465]                 if (is_error) {
[17:42:11.465]                   sessionInformation <- function() {
[17:42:11.465]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:11.465]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:11.465]                       search = base::search(), system = base::Sys.info())
[17:42:11.465]                   }
[17:42:11.465]                   ...future.conditions[[length(...future.conditions) + 
[17:42:11.465]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:11.465]                     cond$call), session = sessionInformation(), 
[17:42:11.465]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:11.465]                   signalCondition(cond)
[17:42:11.465]                 }
[17:42:11.465]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:11.465]                 "immediateCondition"))) {
[17:42:11.465]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:11.465]                   ...future.conditions[[length(...future.conditions) + 
[17:42:11.465]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:11.465]                   if (TRUE && !signal) {
[17:42:11.465]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:11.465]                     {
[17:42:11.465]                       inherits <- base::inherits
[17:42:11.465]                       invokeRestart <- base::invokeRestart
[17:42:11.465]                       is.null <- base::is.null
[17:42:11.465]                       muffled <- FALSE
[17:42:11.465]                       if (inherits(cond, "message")) {
[17:42:11.465]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:11.465]                         if (muffled) 
[17:42:11.465]                           invokeRestart("muffleMessage")
[17:42:11.465]                       }
[17:42:11.465]                       else if (inherits(cond, "warning")) {
[17:42:11.465]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:11.465]                         if (muffled) 
[17:42:11.465]                           invokeRestart("muffleWarning")
[17:42:11.465]                       }
[17:42:11.465]                       else if (inherits(cond, "condition")) {
[17:42:11.465]                         if (!is.null(pattern)) {
[17:42:11.465]                           computeRestarts <- base::computeRestarts
[17:42:11.465]                           grepl <- base::grepl
[17:42:11.465]                           restarts <- computeRestarts(cond)
[17:42:11.465]                           for (restart in restarts) {
[17:42:11.465]                             name <- restart$name
[17:42:11.465]                             if (is.null(name)) 
[17:42:11.465]                               next
[17:42:11.465]                             if (!grepl(pattern, name)) 
[17:42:11.465]                               next
[17:42:11.465]                             invokeRestart(restart)
[17:42:11.465]                             muffled <- TRUE
[17:42:11.465]                             break
[17:42:11.465]                           }
[17:42:11.465]                         }
[17:42:11.465]                       }
[17:42:11.465]                       invisible(muffled)
[17:42:11.465]                     }
[17:42:11.465]                     muffleCondition(cond, pattern = "^muffle")
[17:42:11.465]                   }
[17:42:11.465]                 }
[17:42:11.465]                 else {
[17:42:11.465]                   if (TRUE) {
[17:42:11.465]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:11.465]                     {
[17:42:11.465]                       inherits <- base::inherits
[17:42:11.465]                       invokeRestart <- base::invokeRestart
[17:42:11.465]                       is.null <- base::is.null
[17:42:11.465]                       muffled <- FALSE
[17:42:11.465]                       if (inherits(cond, "message")) {
[17:42:11.465]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:11.465]                         if (muffled) 
[17:42:11.465]                           invokeRestart("muffleMessage")
[17:42:11.465]                       }
[17:42:11.465]                       else if (inherits(cond, "warning")) {
[17:42:11.465]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:11.465]                         if (muffled) 
[17:42:11.465]                           invokeRestart("muffleWarning")
[17:42:11.465]                       }
[17:42:11.465]                       else if (inherits(cond, "condition")) {
[17:42:11.465]                         if (!is.null(pattern)) {
[17:42:11.465]                           computeRestarts <- base::computeRestarts
[17:42:11.465]                           grepl <- base::grepl
[17:42:11.465]                           restarts <- computeRestarts(cond)
[17:42:11.465]                           for (restart in restarts) {
[17:42:11.465]                             name <- restart$name
[17:42:11.465]                             if (is.null(name)) 
[17:42:11.465]                               next
[17:42:11.465]                             if (!grepl(pattern, name)) 
[17:42:11.465]                               next
[17:42:11.465]                             invokeRestart(restart)
[17:42:11.465]                             muffled <- TRUE
[17:42:11.465]                             break
[17:42:11.465]                           }
[17:42:11.465]                         }
[17:42:11.465]                       }
[17:42:11.465]                       invisible(muffled)
[17:42:11.465]                     }
[17:42:11.465]                     muffleCondition(cond, pattern = "^muffle")
[17:42:11.465]                   }
[17:42:11.465]                 }
[17:42:11.465]             }
[17:42:11.465]         }))
[17:42:11.465]     }, error = function(ex) {
[17:42:11.465]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:11.465]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:11.465]                 ...future.rng), started = ...future.startTime, 
[17:42:11.465]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:11.465]             version = "1.8"), class = "FutureResult")
[17:42:11.465]     }, finally = {
[17:42:11.465]         if (!identical(...future.workdir, getwd())) 
[17:42:11.465]             setwd(...future.workdir)
[17:42:11.465]         {
[17:42:11.465]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:11.465]                 ...future.oldOptions$nwarnings <- NULL
[17:42:11.465]             }
[17:42:11.465]             base::options(...future.oldOptions)
[17:42:11.465]             if (.Platform$OS.type == "windows") {
[17:42:11.465]                 old_names <- names(...future.oldEnvVars)
[17:42:11.465]                 envs <- base::Sys.getenv()
[17:42:11.465]                 names <- names(envs)
[17:42:11.465]                 common <- intersect(names, old_names)
[17:42:11.465]                 added <- setdiff(names, old_names)
[17:42:11.465]                 removed <- setdiff(old_names, names)
[17:42:11.465]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:11.465]                   envs[common]]
[17:42:11.465]                 NAMES <- toupper(changed)
[17:42:11.465]                 args <- list()
[17:42:11.465]                 for (kk in seq_along(NAMES)) {
[17:42:11.465]                   name <- changed[[kk]]
[17:42:11.465]                   NAME <- NAMES[[kk]]
[17:42:11.465]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:11.465]                     next
[17:42:11.465]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:11.465]                 }
[17:42:11.465]                 NAMES <- toupper(added)
[17:42:11.465]                 for (kk in seq_along(NAMES)) {
[17:42:11.465]                   name <- added[[kk]]
[17:42:11.465]                   NAME <- NAMES[[kk]]
[17:42:11.465]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:11.465]                     next
[17:42:11.465]                   args[[name]] <- ""
[17:42:11.465]                 }
[17:42:11.465]                 NAMES <- toupper(removed)
[17:42:11.465]                 for (kk in seq_along(NAMES)) {
[17:42:11.465]                   name <- removed[[kk]]
[17:42:11.465]                   NAME <- NAMES[[kk]]
[17:42:11.465]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:11.465]                     next
[17:42:11.465]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:11.465]                 }
[17:42:11.465]                 if (length(args) > 0) 
[17:42:11.465]                   base::do.call(base::Sys.setenv, args = args)
[17:42:11.465]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:11.465]             }
[17:42:11.465]             else {
[17:42:11.465]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:11.465]             }
[17:42:11.465]             {
[17:42:11.465]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:11.465]                   0L) {
[17:42:11.465]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:11.465]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:11.465]                   base::options(opts)
[17:42:11.465]                 }
[17:42:11.465]                 {
[17:42:11.465]                   {
[17:42:11.465]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:11.465]                     NULL
[17:42:11.465]                   }
[17:42:11.465]                   options(future.plan = NULL)
[17:42:11.465]                   if (is.na(NA_character_)) 
[17:42:11.465]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:11.465]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:11.465]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:11.465]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:11.465]                     envir = parent.frame()) 
[17:42:11.465]                   {
[17:42:11.465]                     if (is.function(workers)) 
[17:42:11.465]                       workers <- workers()
[17:42:11.465]                     workers <- structure(as.integer(workers), 
[17:42:11.465]                       class = class(workers))
[17:42:11.465]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:11.465]                       workers >= 1)
[17:42:11.465]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:11.465]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:11.465]                     }
[17:42:11.465]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:11.465]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:11.465]                       envir = envir)
[17:42:11.465]                     if (!future$lazy) 
[17:42:11.465]                       future <- run(future)
[17:42:11.465]                     invisible(future)
[17:42:11.465]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:11.465]                 }
[17:42:11.465]             }
[17:42:11.465]         }
[17:42:11.465]     })
[17:42:11.465]     if (TRUE) {
[17:42:11.465]         base::sink(type = "output", split = FALSE)
[17:42:11.465]         if (TRUE) {
[17:42:11.465]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:11.465]         }
[17:42:11.465]         else {
[17:42:11.465]             ...future.result["stdout"] <- base::list(NULL)
[17:42:11.465]         }
[17:42:11.465]         base::close(...future.stdout)
[17:42:11.465]         ...future.stdout <- NULL
[17:42:11.465]     }
[17:42:11.465]     ...future.result$conditions <- ...future.conditions
[17:42:11.465]     ...future.result$finished <- base::Sys.time()
[17:42:11.465]     ...future.result
[17:42:11.465] }
[17:42:11.468] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[17:42:11.468] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[17:42:11.468] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[17:42:11.468] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[17:42:11.469] MultisessionFuture started
[17:42:11.469] - Launch lazy future ... done
[17:42:11.469] run() for ‘MultisessionFuture’ ... done
[17:42:11.470] result() for ClusterFuture ...
[17:42:11.470] receiveMessageFromWorker() for ClusterFuture ...
[17:42:11.470] - Validating connection of MultisessionFuture
[17:42:11.516] - received message: FutureResult
[17:42:11.516] - Received FutureResult
[17:42:11.517] - Erased future from FutureRegistry
[17:42:11.517] result() for ClusterFuture ...
[17:42:11.517] - result already collected: FutureResult
[17:42:11.517] result() for ClusterFuture ... done
[17:42:11.517] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:11.517] result() for ClusterFuture ... done
[17:42:11.517] result() for ClusterFuture ...
[17:42:11.518] - result already collected: FutureResult
[17:42:11.518] result() for ClusterFuture ... done
b = 11
*** %<-% with ‘multisession’ futures ... DONE
Testing with 2 cores ... DONE
> 
> message("*** %<-% ... DONE")
*** %<-% ... DONE
> 
> source("incl/end.R")
[17:42:11.519] plan(): Setting new future strategy stack:
[17:42:11.519] List of future strategies:
[17:42:11.519] 1. FutureStrategy:
[17:42:11.519]    - args: function (..., envir = parent.frame())
[17:42:11.519]    - tweaked: FALSE
[17:42:11.519]    - call: future::plan(oplan)
[17:42:11.520] plan(): nbrOfWorkers() = 1
> 
