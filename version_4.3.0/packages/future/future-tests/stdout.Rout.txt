
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[13:22:29.090] plan(): Setting new future strategy stack:
[13:22:29.091] List of future strategies:
[13:22:29.091] 1. sequential:
[13:22:29.091]    - args: function (..., envir = parent.frame())
[13:22:29.091]    - tweaked: FALSE
[13:22:29.091]    - call: future::plan("sequential")
[13:22:29.105] plan(): nbrOfWorkers() = 1
> 
> message("*** Standard output ...")
*** Standard output ...
> 
> truth_rows <- utils::capture.output({
+   print(1:50)
+   str(1:50)
+   cat(letters, sep = "-")
+   cat(1:6, collapse = "\n")
+   write.table(datasets::iris[1:10,], sep = "\t")
+ })
> truth <- paste0(paste(truth_rows, collapse = "\n"), "\n")
> print(truth)
[1] " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50\n int [1:50] 1 2 3 4 5 6 7 8 9 10 ...\na-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 \n\"Sepal.Length\"\t\"Sepal.Width\"\t\"Petal.Length\"\t\"Petal.Width\"\t\"Species\"\n\"1\"\t5.1\t3.5\t1.4\t0.2\t\"setosa\"\n\"2\"\t4.9\t3\t1.4\t0.2\t\"setosa\"\n\"3\"\t4.7\t3.2\t1.3\t0.2\t\"setosa\"\n\"4\"\t4.6\t3.1\t1.5\t0.2\t\"setosa\"\n\"5\"\t5\t3.6\t1.4\t0.2\t\"setosa\"\n\"6\"\t5.4\t3.9\t1.7\t0.4\t\"setosa\"\n\"7\"\t4.6\t3.4\t1.4\t0.3\t\"setosa\"\n\"8\"\t5\t3.4\t1.5\t0.2\t\"setosa\"\n\"9\"\t4.4\t2.9\t1.4\t0.2\t\"setosa\"\n\"10\"\t4.9\t3.1\t1.5\t0.1\t\"setosa\"\n"
> 
> for (cores in seq_len(min(2L, availCores))) {
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("%s ...", strategy))
+     plan(strategy)
+ 
+     for (stdout in c(TRUE, FALSE, NA)) {
+       message(sprintf("- stdout = %s", stdout))
+ 
+       f <- future({
+         print(1:50)
+         str(1:50)
+         cat(letters, sep = "-")
+         cat(1:6, collapse = "\n")
+         write.table(datasets::iris[1:10,], sep = "\t")
+         42L
+       }, stdout = stdout)
+       r <- result(f)
+       str(r)
+       stopifnot(value(f) == 42L)
+       if (is.na(stdout)) {
+         stopifnot(is.null(r$stdout) || r$stdout == "")
+       } else if (stdout) {
+         print(r)
+         stopifnot(identical(r$stdout, truth))
+       } else {
+         stopifnot(is.null(r$stdout))
+       }
+ 
+       v %<-% {
+         print(1:50)
+         str(1:50)
+         cat(letters, sep = "-")
+         cat(1:6, collapse = "\n")
+         write.table(datasets::iris[1:10,], sep = "\t")
+         42L
+       } %stdout% stdout
+       out <- utils::capture.output(y <- v)
+       stopifnot(y == 42L)
+       if (is.na(stdout)) {
+         ## Single-core multisession => sequential
+         if (cores > 1L || strategy != "multisession") {
+           stopifnot(out == "")
+         }
+       } else if (stdout) {
+         print(out)
+         stopifnot(identical(out, truth_rows))
+       } else {
+         stopifnot(out == "")
+       }
+ 
+       message("- stdout = structure(TRUE, drop = TRUE)")
+       f <- future(print(42), stdout = structure(TRUE, drop = TRUE))
+       r <- result(f)
+       stopifnot(inherits(r$stdout, "character"))
+       v <- value(f)
+       r <- result(f)
+       stopifnot(is.null(r$stdout))
+     } ## for (stdout ...)
+ 
+     message(sprintf("%s ... done", strategy))
+   } ## for (strategy ...)
+ 
+   message(sprintf("Testing with %d cores ... done", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
sequential ...
[13:22:29.153] plan(): Setting new future strategy stack:
[13:22:29.153] List of future strategies:
[13:22:29.153] 1. sequential:
[13:22:29.153]    - args: function (..., envir = parent.frame())
[13:22:29.153]    - tweaked: FALSE
[13:22:29.153]    - call: plan(strategy)
[13:22:29.165] plan(): nbrOfWorkers() = 1
- stdout = TRUE
[13:22:29.166] getGlobalsAndPackages() ...
[13:22:29.166] Searching for globals...
[13:22:29.175] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[13:22:29.175] Searching for globals ... DONE
[13:22:29.175] Resolving globals: FALSE
[13:22:29.176] 
[13:22:29.176] - packages: [1] ‘utils’
[13:22:29.176] getGlobalsAndPackages() ... DONE
[13:22:29.177] run() for ‘Future’ ...
[13:22:29.177] - state: ‘created’
[13:22:29.177] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:22:29.178] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:22:29.178] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:22:29.178]   - Field: ‘label’
[13:22:29.178]   - Field: ‘local’
[13:22:29.178]   - Field: ‘owner’
[13:22:29.178]   - Field: ‘envir’
[13:22:29.178]   - Field: ‘packages’
[13:22:29.178]   - Field: ‘gc’
[13:22:29.178]   - Field: ‘conditions’
[13:22:29.179]   - Field: ‘expr’
[13:22:29.179]   - Field: ‘uuid’
[13:22:29.179]   - Field: ‘seed’
[13:22:29.179]   - Field: ‘version’
[13:22:29.179]   - Field: ‘result’
[13:22:29.179]   - Field: ‘asynchronous’
[13:22:29.179]   - Field: ‘calls’
[13:22:29.179]   - Field: ‘globals’
[13:22:29.179]   - Field: ‘stdout’
[13:22:29.179]   - Field: ‘earlySignal’
[13:22:29.179]   - Field: ‘lazy’
[13:22:29.180]   - Field: ‘state’
[13:22:29.180] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:22:29.180] - Launch lazy future ...
[13:22:29.181] Packages needed by the future expression (n = 1): ‘utils’
[13:22:29.181] Packages needed by future strategies (n = 0): <none>
[13:22:29.182] {
[13:22:29.182]     {
[13:22:29.182]         {
[13:22:29.182]             ...future.startTime <- base::Sys.time()
[13:22:29.182]             {
[13:22:29.182]                 {
[13:22:29.182]                   {
[13:22:29.182]                     {
[13:22:29.182]                       base::local({
[13:22:29.182]                         has_future <- base::requireNamespace("future", 
[13:22:29.182]                           quietly = TRUE)
[13:22:29.182]                         if (has_future) {
[13:22:29.182]                           ns <- base::getNamespace("future")
[13:22:29.182]                           version <- ns[[".package"]][["version"]]
[13:22:29.182]                           if (is.null(version)) 
[13:22:29.182]                             version <- utils::packageVersion("future")
[13:22:29.182]                         }
[13:22:29.182]                         else {
[13:22:29.182]                           version <- NULL
[13:22:29.182]                         }
[13:22:29.182]                         if (!has_future || version < "1.8.0") {
[13:22:29.182]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:29.182]                             "", base::R.version$version.string), 
[13:22:29.182]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:29.182]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:29.182]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:29.182]                               "release", "version")], collapse = " "), 
[13:22:29.182]                             hostname = base::Sys.info()[["nodename"]])
[13:22:29.182]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:29.182]                             info)
[13:22:29.182]                           info <- base::paste(info, collapse = "; ")
[13:22:29.182]                           if (!has_future) {
[13:22:29.182]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:29.182]                               info)
[13:22:29.182]                           }
[13:22:29.182]                           else {
[13:22:29.182]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:29.182]                               info, version)
[13:22:29.182]                           }
[13:22:29.182]                           base::stop(msg)
[13:22:29.182]                         }
[13:22:29.182]                       })
[13:22:29.182]                     }
[13:22:29.182]                     base::local({
[13:22:29.182]                       for (pkg in "utils") {
[13:22:29.182]                         base::loadNamespace(pkg)
[13:22:29.182]                         base::library(pkg, character.only = TRUE)
[13:22:29.182]                       }
[13:22:29.182]                     })
[13:22:29.182]                   }
[13:22:29.182]                   options(future.plan = NULL)
[13:22:29.182]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:29.182]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:29.182]                 }
[13:22:29.182]                 ...future.workdir <- getwd()
[13:22:29.182]             }
[13:22:29.182]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:29.182]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:29.182]         }
[13:22:29.182]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:29.182]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:29.182]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:29.182]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:29.182]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:29.182]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:29.182]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:29.182]             base::names(...future.oldOptions))
[13:22:29.182]     }
[13:22:29.182]     if (FALSE) {
[13:22:29.182]     }
[13:22:29.182]     else {
[13:22:29.182]         if (TRUE) {
[13:22:29.182]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:29.182]                 open = "w")
[13:22:29.182]         }
[13:22:29.182]         else {
[13:22:29.182]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:29.182]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:29.182]         }
[13:22:29.182]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:29.182]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:29.182]             base::sink(type = "output", split = FALSE)
[13:22:29.182]             base::close(...future.stdout)
[13:22:29.182]         }, add = TRUE)
[13:22:29.182]     }
[13:22:29.182]     ...future.frame <- base::sys.nframe()
[13:22:29.182]     ...future.conditions <- base::list()
[13:22:29.182]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:29.182]     if (FALSE) {
[13:22:29.182]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:29.182]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:29.182]     }
[13:22:29.182]     ...future.result <- base::tryCatch({
[13:22:29.182]         base::withCallingHandlers({
[13:22:29.182]             ...future.value <- base::withVisible(base::local({
[13:22:29.182]                 print(1:50)
[13:22:29.182]                 str(1:50)
[13:22:29.182]                 cat(letters, sep = "-")
[13:22:29.182]                 cat(1:6, collapse = "\n")
[13:22:29.182]                 write.table(datasets::iris[1:10, ], sep = "\t")
[13:22:29.182]                 42L
[13:22:29.182]             }))
[13:22:29.182]             future::FutureResult(value = ...future.value$value, 
[13:22:29.182]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:29.182]                   ...future.rng), globalenv = if (FALSE) 
[13:22:29.182]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:29.182]                     ...future.globalenv.names))
[13:22:29.182]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:29.182]         }, condition = base::local({
[13:22:29.182]             c <- base::c
[13:22:29.182]             inherits <- base::inherits
[13:22:29.182]             invokeRestart <- base::invokeRestart
[13:22:29.182]             length <- base::length
[13:22:29.182]             list <- base::list
[13:22:29.182]             seq.int <- base::seq.int
[13:22:29.182]             signalCondition <- base::signalCondition
[13:22:29.182]             sys.calls <- base::sys.calls
[13:22:29.182]             `[[` <- base::`[[`
[13:22:29.182]             `+` <- base::`+`
[13:22:29.182]             `<<-` <- base::`<<-`
[13:22:29.182]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:29.182]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:29.182]                   3L)]
[13:22:29.182]             }
[13:22:29.182]             function(cond) {
[13:22:29.182]                 is_error <- inherits(cond, "error")
[13:22:29.182]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:29.182]                   NULL)
[13:22:29.182]                 if (is_error) {
[13:22:29.182]                   sessionInformation <- function() {
[13:22:29.182]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:29.182]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:29.182]                       search = base::search(), system = base::Sys.info())
[13:22:29.182]                   }
[13:22:29.182]                   ...future.conditions[[length(...future.conditions) + 
[13:22:29.182]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:29.182]                     cond$call), session = sessionInformation(), 
[13:22:29.182]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:29.182]                   signalCondition(cond)
[13:22:29.182]                 }
[13:22:29.182]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:29.182]                 "immediateCondition"))) {
[13:22:29.182]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:29.182]                   ...future.conditions[[length(...future.conditions) + 
[13:22:29.182]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:29.182]                   if (TRUE && !signal) {
[13:22:29.182]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.182]                     {
[13:22:29.182]                       inherits <- base::inherits
[13:22:29.182]                       invokeRestart <- base::invokeRestart
[13:22:29.182]                       is.null <- base::is.null
[13:22:29.182]                       muffled <- FALSE
[13:22:29.182]                       if (inherits(cond, "message")) {
[13:22:29.182]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:29.182]                         if (muffled) 
[13:22:29.182]                           invokeRestart("muffleMessage")
[13:22:29.182]                       }
[13:22:29.182]                       else if (inherits(cond, "warning")) {
[13:22:29.182]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:29.182]                         if (muffled) 
[13:22:29.182]                           invokeRestart("muffleWarning")
[13:22:29.182]                       }
[13:22:29.182]                       else if (inherits(cond, "condition")) {
[13:22:29.182]                         if (!is.null(pattern)) {
[13:22:29.182]                           computeRestarts <- base::computeRestarts
[13:22:29.182]                           grepl <- base::grepl
[13:22:29.182]                           restarts <- computeRestarts(cond)
[13:22:29.182]                           for (restart in restarts) {
[13:22:29.182]                             name <- restart$name
[13:22:29.182]                             if (is.null(name)) 
[13:22:29.182]                               next
[13:22:29.182]                             if (!grepl(pattern, name)) 
[13:22:29.182]                               next
[13:22:29.182]                             invokeRestart(restart)
[13:22:29.182]                             muffled <- TRUE
[13:22:29.182]                             break
[13:22:29.182]                           }
[13:22:29.182]                         }
[13:22:29.182]                       }
[13:22:29.182]                       invisible(muffled)
[13:22:29.182]                     }
[13:22:29.182]                     muffleCondition(cond, pattern = "^muffle")
[13:22:29.182]                   }
[13:22:29.182]                 }
[13:22:29.182]                 else {
[13:22:29.182]                   if (TRUE) {
[13:22:29.182]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.182]                     {
[13:22:29.182]                       inherits <- base::inherits
[13:22:29.182]                       invokeRestart <- base::invokeRestart
[13:22:29.182]                       is.null <- base::is.null
[13:22:29.182]                       muffled <- FALSE
[13:22:29.182]                       if (inherits(cond, "message")) {
[13:22:29.182]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:29.182]                         if (muffled) 
[13:22:29.182]                           invokeRestart("muffleMessage")
[13:22:29.182]                       }
[13:22:29.182]                       else if (inherits(cond, "warning")) {
[13:22:29.182]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:29.182]                         if (muffled) 
[13:22:29.182]                           invokeRestart("muffleWarning")
[13:22:29.182]                       }
[13:22:29.182]                       else if (inherits(cond, "condition")) {
[13:22:29.182]                         if (!is.null(pattern)) {
[13:22:29.182]                           computeRestarts <- base::computeRestarts
[13:22:29.182]                           grepl <- base::grepl
[13:22:29.182]                           restarts <- computeRestarts(cond)
[13:22:29.182]                           for (restart in restarts) {
[13:22:29.182]                             name <- restart$name
[13:22:29.182]                             if (is.null(name)) 
[13:22:29.182]                               next
[13:22:29.182]                             if (!grepl(pattern, name)) 
[13:22:29.182]                               next
[13:22:29.182]                             invokeRestart(restart)
[13:22:29.182]                             muffled <- TRUE
[13:22:29.182]                             break
[13:22:29.182]                           }
[13:22:29.182]                         }
[13:22:29.182]                       }
[13:22:29.182]                       invisible(muffled)
[13:22:29.182]                     }
[13:22:29.182]                     muffleCondition(cond, pattern = "^muffle")
[13:22:29.182]                   }
[13:22:29.182]                 }
[13:22:29.182]             }
[13:22:29.182]         }))
[13:22:29.182]     }, error = function(ex) {
[13:22:29.182]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:29.182]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:29.182]                 ...future.rng), started = ...future.startTime, 
[13:22:29.182]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:29.182]             version = "1.8"), class = "FutureResult")
[13:22:29.182]     }, finally = {
[13:22:29.182]         if (!identical(...future.workdir, getwd())) 
[13:22:29.182]             setwd(...future.workdir)
[13:22:29.182]         {
[13:22:29.182]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:29.182]                 ...future.oldOptions$nwarnings <- NULL
[13:22:29.182]             }
[13:22:29.182]             base::options(...future.oldOptions)
[13:22:29.182]             if (.Platform$OS.type == "windows") {
[13:22:29.182]                 old_names <- names(...future.oldEnvVars)
[13:22:29.182]                 envs <- base::Sys.getenv()
[13:22:29.182]                 names <- names(envs)
[13:22:29.182]                 common <- intersect(names, old_names)
[13:22:29.182]                 added <- setdiff(names, old_names)
[13:22:29.182]                 removed <- setdiff(old_names, names)
[13:22:29.182]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:29.182]                   envs[common]]
[13:22:29.182]                 NAMES <- toupper(changed)
[13:22:29.182]                 args <- list()
[13:22:29.182]                 for (kk in seq_along(NAMES)) {
[13:22:29.182]                   name <- changed[[kk]]
[13:22:29.182]                   NAME <- NAMES[[kk]]
[13:22:29.182]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.182]                     next
[13:22:29.182]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:29.182]                 }
[13:22:29.182]                 NAMES <- toupper(added)
[13:22:29.182]                 for (kk in seq_along(NAMES)) {
[13:22:29.182]                   name <- added[[kk]]
[13:22:29.182]                   NAME <- NAMES[[kk]]
[13:22:29.182]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.182]                     next
[13:22:29.182]                   args[[name]] <- ""
[13:22:29.182]                 }
[13:22:29.182]                 NAMES <- toupper(removed)
[13:22:29.182]                 for (kk in seq_along(NAMES)) {
[13:22:29.182]                   name <- removed[[kk]]
[13:22:29.182]                   NAME <- NAMES[[kk]]
[13:22:29.182]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.182]                     next
[13:22:29.182]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:29.182]                 }
[13:22:29.182]                 if (length(args) > 0) 
[13:22:29.182]                   base::do.call(base::Sys.setenv, args = args)
[13:22:29.182]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:29.182]             }
[13:22:29.182]             else {
[13:22:29.182]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:29.182]             }
[13:22:29.182]             {
[13:22:29.182]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:29.182]                   0L) {
[13:22:29.182]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:29.182]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:29.182]                   base::options(opts)
[13:22:29.182]                 }
[13:22:29.182]                 {
[13:22:29.182]                   {
[13:22:29.182]                     NULL
[13:22:29.182]                     RNGkind("Mersenne-Twister")
[13:22:29.182]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:22:29.182]                       inherits = FALSE)
[13:22:29.182]                   }
[13:22:29.182]                   options(future.plan = NULL)
[13:22:29.182]                   if (is.na(NA_character_)) 
[13:22:29.182]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:29.182]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:29.182]                   future::plan(list(function (..., envir = parent.frame()) 
[13:22:29.182]                   {
[13:22:29.182]                     future <- SequentialFuture(..., envir = envir)
[13:22:29.182]                     if (!future$lazy) 
[13:22:29.182]                       future <- run(future)
[13:22:29.182]                     invisible(future)
[13:22:29.182]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:29.182]                 }
[13:22:29.182]             }
[13:22:29.182]         }
[13:22:29.182]     })
[13:22:29.182]     if (TRUE) {
[13:22:29.182]         base::sink(type = "output", split = FALSE)
[13:22:29.182]         if (TRUE) {
[13:22:29.182]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:29.182]         }
[13:22:29.182]         else {
[13:22:29.182]             ...future.result["stdout"] <- base::list(NULL)
[13:22:29.182]         }
[13:22:29.182]         base::close(...future.stdout)
[13:22:29.182]         ...future.stdout <- NULL
[13:22:29.182]     }
[13:22:29.182]     ...future.result$conditions <- ...future.conditions
[13:22:29.182]     ...future.result$finished <- base::Sys.time()
[13:22:29.182]     ...future.result
[13:22:29.182] }
[13:22:29.184] plan(): Setting new future strategy stack:
[13:22:29.184] List of future strategies:
[13:22:29.184] 1. sequential:
[13:22:29.184]    - args: function (..., envir = parent.frame())
[13:22:29.184]    - tweaked: FALSE
[13:22:29.184]    - call: NULL
[13:22:29.184] plan(): nbrOfWorkers() = 1
[13:22:29.186] plan(): Setting new future strategy stack:
[13:22:29.186] List of future strategies:
[13:22:29.186] 1. sequential:
[13:22:29.186]    - args: function (..., envir = parent.frame())
[13:22:29.186]    - tweaked: FALSE
[13:22:29.186]    - call: plan(strategy)
[13:22:29.187] plan(): nbrOfWorkers() = 1
[13:22:29.187] SequentialFuture started (and completed)
[13:22:29.187] - Launch lazy future ... done
[13:22:29.187] run() for ‘SequentialFuture’ ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : chr " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 3"| __truncated__
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-01-07 13:22:29"
 $ finished    : POSIXct[1:1], format: "2025-01-07 13:22:29"
 $ session_uuid: chr "3cc83afd-53db-40eb-3db7-60d73dc7b598"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "5853cd8d1af0"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "5853cd8d1af0" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 93426
  .. ..$ time  : POSIXct[1:1], format: "2025-01-07 13:22:29"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 3 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
FutureResult:
value: ‘integer’
visible: TRUE
stdout: character
conditions: [n = 0] 
RNG used: FALSE
duration: 0.003322124 secs (started 2025-01-07 13:22:29.183933)
version: 1.8
[13:22:29.200] getGlobalsAndPackages() ...
[13:22:29.200] Searching for globals...
[13:22:29.203] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[13:22:29.203] Searching for globals ... DONE
[13:22:29.203] Resolving globals: FALSE
[13:22:29.204] 
[13:22:29.204] - packages: [1] ‘utils’
[13:22:29.204] getGlobalsAndPackages() ... DONE
[13:22:29.204] run() for ‘Future’ ...
[13:22:29.204] - state: ‘created’
[13:22:29.204] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:22:29.205] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:22:29.205] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:22:29.205]   - Field: ‘label’
[13:22:29.205]   - Field: ‘local’
[13:22:29.205]   - Field: ‘owner’
[13:22:29.205]   - Field: ‘envir’
[13:22:29.205]   - Field: ‘packages’
[13:22:29.205]   - Field: ‘gc’
[13:22:29.206]   - Field: ‘conditions’
[13:22:29.206]   - Field: ‘expr’
[13:22:29.206]   - Field: ‘uuid’
[13:22:29.206]   - Field: ‘seed’
[13:22:29.206]   - Field: ‘version’
[13:22:29.206]   - Field: ‘result’
[13:22:29.206]   - Field: ‘asynchronous’
[13:22:29.206]   - Field: ‘calls’
[13:22:29.206]   - Field: ‘globals’
[13:22:29.206]   - Field: ‘stdout’
[13:22:29.206]   - Field: ‘earlySignal’
[13:22:29.207]   - Field: ‘lazy’
[13:22:29.207]   - Field: ‘state’
[13:22:29.207] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:22:29.207] - Launch lazy future ...
[13:22:29.207] Packages needed by the future expression (n = 1): ‘utils’
[13:22:29.207] Packages needed by future strategies (n = 0): <none>
[13:22:29.208] {
[13:22:29.208]     {
[13:22:29.208]         {
[13:22:29.208]             ...future.startTime <- base::Sys.time()
[13:22:29.208]             {
[13:22:29.208]                 {
[13:22:29.208]                   {
[13:22:29.208]                     {
[13:22:29.208]                       base::local({
[13:22:29.208]                         has_future <- base::requireNamespace("future", 
[13:22:29.208]                           quietly = TRUE)
[13:22:29.208]                         if (has_future) {
[13:22:29.208]                           ns <- base::getNamespace("future")
[13:22:29.208]                           version <- ns[[".package"]][["version"]]
[13:22:29.208]                           if (is.null(version)) 
[13:22:29.208]                             version <- utils::packageVersion("future")
[13:22:29.208]                         }
[13:22:29.208]                         else {
[13:22:29.208]                           version <- NULL
[13:22:29.208]                         }
[13:22:29.208]                         if (!has_future || version < "1.8.0") {
[13:22:29.208]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:29.208]                             "", base::R.version$version.string), 
[13:22:29.208]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:29.208]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:29.208]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:29.208]                               "release", "version")], collapse = " "), 
[13:22:29.208]                             hostname = base::Sys.info()[["nodename"]])
[13:22:29.208]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:29.208]                             info)
[13:22:29.208]                           info <- base::paste(info, collapse = "; ")
[13:22:29.208]                           if (!has_future) {
[13:22:29.208]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:29.208]                               info)
[13:22:29.208]                           }
[13:22:29.208]                           else {
[13:22:29.208]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:29.208]                               info, version)
[13:22:29.208]                           }
[13:22:29.208]                           base::stop(msg)
[13:22:29.208]                         }
[13:22:29.208]                       })
[13:22:29.208]                     }
[13:22:29.208]                     base::local({
[13:22:29.208]                       for (pkg in "utils") {
[13:22:29.208]                         base::loadNamespace(pkg)
[13:22:29.208]                         base::library(pkg, character.only = TRUE)
[13:22:29.208]                       }
[13:22:29.208]                     })
[13:22:29.208]                   }
[13:22:29.208]                   options(future.plan = NULL)
[13:22:29.208]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:29.208]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:29.208]                 }
[13:22:29.208]                 ...future.workdir <- getwd()
[13:22:29.208]             }
[13:22:29.208]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:29.208]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:29.208]         }
[13:22:29.208]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:29.208]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:29.208]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:29.208]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:29.208]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:29.208]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:29.208]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:29.208]             base::names(...future.oldOptions))
[13:22:29.208]     }
[13:22:29.208]     if (FALSE) {
[13:22:29.208]     }
[13:22:29.208]     else {
[13:22:29.208]         if (TRUE) {
[13:22:29.208]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:29.208]                 open = "w")
[13:22:29.208]         }
[13:22:29.208]         else {
[13:22:29.208]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:29.208]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:29.208]         }
[13:22:29.208]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:29.208]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:29.208]             base::sink(type = "output", split = FALSE)
[13:22:29.208]             base::close(...future.stdout)
[13:22:29.208]         }, add = TRUE)
[13:22:29.208]     }
[13:22:29.208]     ...future.frame <- base::sys.nframe()
[13:22:29.208]     ...future.conditions <- base::list()
[13:22:29.208]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:29.208]     if (FALSE) {
[13:22:29.208]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:29.208]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:29.208]     }
[13:22:29.208]     ...future.result <- base::tryCatch({
[13:22:29.208]         base::withCallingHandlers({
[13:22:29.208]             ...future.value <- base::withVisible(base::local({
[13:22:29.208]                 print(1:50)
[13:22:29.208]                 str(1:50)
[13:22:29.208]                 cat(letters, sep = "-")
[13:22:29.208]                 cat(1:6, collapse = "\n")
[13:22:29.208]                 write.table(datasets::iris[1:10, ], sep = "\t")
[13:22:29.208]                 42L
[13:22:29.208]             }))
[13:22:29.208]             future::FutureResult(value = ...future.value$value, 
[13:22:29.208]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:29.208]                   ...future.rng), globalenv = if (FALSE) 
[13:22:29.208]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:29.208]                     ...future.globalenv.names))
[13:22:29.208]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:29.208]         }, condition = base::local({
[13:22:29.208]             c <- base::c
[13:22:29.208]             inherits <- base::inherits
[13:22:29.208]             invokeRestart <- base::invokeRestart
[13:22:29.208]             length <- base::length
[13:22:29.208]             list <- base::list
[13:22:29.208]             seq.int <- base::seq.int
[13:22:29.208]             signalCondition <- base::signalCondition
[13:22:29.208]             sys.calls <- base::sys.calls
[13:22:29.208]             `[[` <- base::`[[`
[13:22:29.208]             `+` <- base::`+`
[13:22:29.208]             `<<-` <- base::`<<-`
[13:22:29.208]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:29.208]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:29.208]                   3L)]
[13:22:29.208]             }
[13:22:29.208]             function(cond) {
[13:22:29.208]                 is_error <- inherits(cond, "error")
[13:22:29.208]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:29.208]                   NULL)
[13:22:29.208]                 if (is_error) {
[13:22:29.208]                   sessionInformation <- function() {
[13:22:29.208]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:29.208]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:29.208]                       search = base::search(), system = base::Sys.info())
[13:22:29.208]                   }
[13:22:29.208]                   ...future.conditions[[length(...future.conditions) + 
[13:22:29.208]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:29.208]                     cond$call), session = sessionInformation(), 
[13:22:29.208]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:29.208]                   signalCondition(cond)
[13:22:29.208]                 }
[13:22:29.208]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:29.208]                 "immediateCondition"))) {
[13:22:29.208]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:29.208]                   ...future.conditions[[length(...future.conditions) + 
[13:22:29.208]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:29.208]                   if (TRUE && !signal) {
[13:22:29.208]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.208]                     {
[13:22:29.208]                       inherits <- base::inherits
[13:22:29.208]                       invokeRestart <- base::invokeRestart
[13:22:29.208]                       is.null <- base::is.null
[13:22:29.208]                       muffled <- FALSE
[13:22:29.208]                       if (inherits(cond, "message")) {
[13:22:29.208]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:29.208]                         if (muffled) 
[13:22:29.208]                           invokeRestart("muffleMessage")
[13:22:29.208]                       }
[13:22:29.208]                       else if (inherits(cond, "warning")) {
[13:22:29.208]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:29.208]                         if (muffled) 
[13:22:29.208]                           invokeRestart("muffleWarning")
[13:22:29.208]                       }
[13:22:29.208]                       else if (inherits(cond, "condition")) {
[13:22:29.208]                         if (!is.null(pattern)) {
[13:22:29.208]                           computeRestarts <- base::computeRestarts
[13:22:29.208]                           grepl <- base::grepl
[13:22:29.208]                           restarts <- computeRestarts(cond)
[13:22:29.208]                           for (restart in restarts) {
[13:22:29.208]                             name <- restart$name
[13:22:29.208]                             if (is.null(name)) 
[13:22:29.208]                               next
[13:22:29.208]                             if (!grepl(pattern, name)) 
[13:22:29.208]                               next
[13:22:29.208]                             invokeRestart(restart)
[13:22:29.208]                             muffled <- TRUE
[13:22:29.208]                             break
[13:22:29.208]                           }
[13:22:29.208]                         }
[13:22:29.208]                       }
[13:22:29.208]                       invisible(muffled)
[13:22:29.208]                     }
[13:22:29.208]                     muffleCondition(cond, pattern = "^muffle")
[13:22:29.208]                   }
[13:22:29.208]                 }
[13:22:29.208]                 else {
[13:22:29.208]                   if (TRUE) {
[13:22:29.208]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.208]                     {
[13:22:29.208]                       inherits <- base::inherits
[13:22:29.208]                       invokeRestart <- base::invokeRestart
[13:22:29.208]                       is.null <- base::is.null
[13:22:29.208]                       muffled <- FALSE
[13:22:29.208]                       if (inherits(cond, "message")) {
[13:22:29.208]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:29.208]                         if (muffled) 
[13:22:29.208]                           invokeRestart("muffleMessage")
[13:22:29.208]                       }
[13:22:29.208]                       else if (inherits(cond, "warning")) {
[13:22:29.208]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:29.208]                         if (muffled) 
[13:22:29.208]                           invokeRestart("muffleWarning")
[13:22:29.208]                       }
[13:22:29.208]                       else if (inherits(cond, "condition")) {
[13:22:29.208]                         if (!is.null(pattern)) {
[13:22:29.208]                           computeRestarts <- base::computeRestarts
[13:22:29.208]                           grepl <- base::grepl
[13:22:29.208]                           restarts <- computeRestarts(cond)
[13:22:29.208]                           for (restart in restarts) {
[13:22:29.208]                             name <- restart$name
[13:22:29.208]                             if (is.null(name)) 
[13:22:29.208]                               next
[13:22:29.208]                             if (!grepl(pattern, name)) 
[13:22:29.208]                               next
[13:22:29.208]                             invokeRestart(restart)
[13:22:29.208]                             muffled <- TRUE
[13:22:29.208]                             break
[13:22:29.208]                           }
[13:22:29.208]                         }
[13:22:29.208]                       }
[13:22:29.208]                       invisible(muffled)
[13:22:29.208]                     }
[13:22:29.208]                     muffleCondition(cond, pattern = "^muffle")
[13:22:29.208]                   }
[13:22:29.208]                 }
[13:22:29.208]             }
[13:22:29.208]         }))
[13:22:29.208]     }, error = function(ex) {
[13:22:29.208]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:29.208]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:29.208]                 ...future.rng), started = ...future.startTime, 
[13:22:29.208]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:29.208]             version = "1.8"), class = "FutureResult")
[13:22:29.208]     }, finally = {
[13:22:29.208]         if (!identical(...future.workdir, getwd())) 
[13:22:29.208]             setwd(...future.workdir)
[13:22:29.208]         {
[13:22:29.208]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:29.208]                 ...future.oldOptions$nwarnings <- NULL
[13:22:29.208]             }
[13:22:29.208]             base::options(...future.oldOptions)
[13:22:29.208]             if (.Platform$OS.type == "windows") {
[13:22:29.208]                 old_names <- names(...future.oldEnvVars)
[13:22:29.208]                 envs <- base::Sys.getenv()
[13:22:29.208]                 names <- names(envs)
[13:22:29.208]                 common <- intersect(names, old_names)
[13:22:29.208]                 added <- setdiff(names, old_names)
[13:22:29.208]                 removed <- setdiff(old_names, names)
[13:22:29.208]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:29.208]                   envs[common]]
[13:22:29.208]                 NAMES <- toupper(changed)
[13:22:29.208]                 args <- list()
[13:22:29.208]                 for (kk in seq_along(NAMES)) {
[13:22:29.208]                   name <- changed[[kk]]
[13:22:29.208]                   NAME <- NAMES[[kk]]
[13:22:29.208]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.208]                     next
[13:22:29.208]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:29.208]                 }
[13:22:29.208]                 NAMES <- toupper(added)
[13:22:29.208]                 for (kk in seq_along(NAMES)) {
[13:22:29.208]                   name <- added[[kk]]
[13:22:29.208]                   NAME <- NAMES[[kk]]
[13:22:29.208]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.208]                     next
[13:22:29.208]                   args[[name]] <- ""
[13:22:29.208]                 }
[13:22:29.208]                 NAMES <- toupper(removed)
[13:22:29.208]                 for (kk in seq_along(NAMES)) {
[13:22:29.208]                   name <- removed[[kk]]
[13:22:29.208]                   NAME <- NAMES[[kk]]
[13:22:29.208]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.208]                     next
[13:22:29.208]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:29.208]                 }
[13:22:29.208]                 if (length(args) > 0) 
[13:22:29.208]                   base::do.call(base::Sys.setenv, args = args)
[13:22:29.208]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:29.208]             }
[13:22:29.208]             else {
[13:22:29.208]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:29.208]             }
[13:22:29.208]             {
[13:22:29.208]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:29.208]                   0L) {
[13:22:29.208]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:29.208]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:29.208]                   base::options(opts)
[13:22:29.208]                 }
[13:22:29.208]                 {
[13:22:29.208]                   {
[13:22:29.208]                     NULL
[13:22:29.208]                     RNGkind("Mersenne-Twister")
[13:22:29.208]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:22:29.208]                       inherits = FALSE)
[13:22:29.208]                   }
[13:22:29.208]                   options(future.plan = NULL)
[13:22:29.208]                   if (is.na(NA_character_)) 
[13:22:29.208]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:29.208]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:29.208]                   future::plan(list(function (..., envir = parent.frame()) 
[13:22:29.208]                   {
[13:22:29.208]                     future <- SequentialFuture(..., envir = envir)
[13:22:29.208]                     if (!future$lazy) 
[13:22:29.208]                       future <- run(future)
[13:22:29.208]                     invisible(future)
[13:22:29.208]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:29.208]                 }
[13:22:29.208]             }
[13:22:29.208]         }
[13:22:29.208]     })
[13:22:29.208]     if (TRUE) {
[13:22:29.208]         base::sink(type = "output", split = FALSE)
[13:22:29.208]         if (TRUE) {
[13:22:29.208]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:29.208]         }
[13:22:29.208]         else {
[13:22:29.208]             ...future.result["stdout"] <- base::list(NULL)
[13:22:29.208]         }
[13:22:29.208]         base::close(...future.stdout)
[13:22:29.208]         ...future.stdout <- NULL
[13:22:29.208]     }
[13:22:29.208]     ...future.result$conditions <- ...future.conditions
[13:22:29.208]     ...future.result$finished <- base::Sys.time()
[13:22:29.208]     ...future.result
[13:22:29.208] }
[13:22:29.210] plan(): Setting new future strategy stack:
[13:22:29.210] List of future strategies:
[13:22:29.210] 1. sequential:
[13:22:29.210]    - args: function (..., envir = parent.frame())
[13:22:29.210]    - tweaked: FALSE
[13:22:29.210]    - call: NULL
[13:22:29.210] plan(): nbrOfWorkers() = 1
[13:22:29.212] plan(): Setting new future strategy stack:
[13:22:29.212] List of future strategies:
[13:22:29.212] 1. sequential:
[13:22:29.212]    - args: function (..., envir = parent.frame())
[13:22:29.212]    - tweaked: FALSE
[13:22:29.212]    - call: plan(strategy)
[13:22:29.212] plan(): nbrOfWorkers() = 1
[13:22:29.212] SequentialFuture started (and completed)
[13:22:29.212] - Launch lazy future ... done
[13:22:29.213] run() for ‘SequentialFuture’ ... done
 [1] " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25"  
 [2] "[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50"  
 [3] " int [1:50] 1 2 3 4 5 6 7 8 9 10 ..."                                             
 [4] "a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 "                  
 [5] "\"Sepal.Length\"\t\"Sepal.Width\"\t\"Petal.Length\"\t\"Petal.Width\"\t\"Species\""
 [6] "\"1\"\t5.1\t3.5\t1.4\t0.2\t\"setosa\""                                            
 [7] "\"2\"\t4.9\t3\t1.4\t0.2\t\"setosa\""                                              
 [8] "\"3\"\t4.7\t3.2\t1.3\t0.2\t\"setosa\""                                            
 [9] "\"4\"\t4.6\t3.1\t1.5\t0.2\t\"setosa\""                                            
[10] "\"5\"\t5\t3.6\t1.4\t0.2\t\"setosa\""                                              
[11] "\"6\"\t5.4\t3.9\t1.7\t0.4\t\"setosa\""                                            
[12] "\"7\"\t4.6\t3.4\t1.4\t0.3\t\"setosa\""                                            
[13] "\"8\"\t5\t3.4\t1.5\t0.2\t\"setosa\""                                              
[14] "\"9\"\t4.4\t2.9\t1.4\t0.2\t\"setosa\""                                            
[15] "\"10\"\t4.9\t3.1\t1.5\t0.1\t\"setosa\""                                           
- stdout = structure(TRUE, drop = TRUE)
[13:22:29.213] getGlobalsAndPackages() ...
[13:22:29.213] Searching for globals...
[13:22:29.214] - globals found: [1] ‘print’
[13:22:29.214] Searching for globals ... DONE
[13:22:29.214] Resolving globals: FALSE
[13:22:29.214] 
[13:22:29.214] 
[13:22:29.214] getGlobalsAndPackages() ... DONE
[13:22:29.215] run() for ‘Future’ ...
[13:22:29.215] - state: ‘created’
[13:22:29.215] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:22:29.215] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:22:29.215] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:22:29.215]   - Field: ‘label’
[13:22:29.215]   - Field: ‘local’
[13:22:29.215]   - Field: ‘owner’
[13:22:29.216]   - Field: ‘envir’
[13:22:29.216]   - Field: ‘packages’
[13:22:29.216]   - Field: ‘gc’
[13:22:29.216]   - Field: ‘conditions’
[13:22:29.216]   - Field: ‘expr’
[13:22:29.216]   - Field: ‘uuid’
[13:22:29.216]   - Field: ‘seed’
[13:22:29.216]   - Field: ‘version’
[13:22:29.216]   - Field: ‘result’
[13:22:29.216]   - Field: ‘asynchronous’
[13:22:29.217]   - Field: ‘calls’
[13:22:29.217]   - Field: ‘globals’
[13:22:29.217]   - Field: ‘stdout’
[13:22:29.217]   - Field: ‘earlySignal’
[13:22:29.217]   - Field: ‘lazy’
[13:22:29.217]   - Field: ‘state’
[13:22:29.217] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:22:29.217] - Launch lazy future ...
[13:22:29.217] Packages needed by the future expression (n = 0): <none>
[13:22:29.218] Packages needed by future strategies (n = 0): <none>
[13:22:29.218] {
[13:22:29.218]     {
[13:22:29.218]         {
[13:22:29.218]             ...future.startTime <- base::Sys.time()
[13:22:29.218]             {
[13:22:29.218]                 {
[13:22:29.218]                   {
[13:22:29.218]                     base::local({
[13:22:29.218]                       has_future <- base::requireNamespace("future", 
[13:22:29.218]                         quietly = TRUE)
[13:22:29.218]                       if (has_future) {
[13:22:29.218]                         ns <- base::getNamespace("future")
[13:22:29.218]                         version <- ns[[".package"]][["version"]]
[13:22:29.218]                         if (is.null(version)) 
[13:22:29.218]                           version <- utils::packageVersion("future")
[13:22:29.218]                       }
[13:22:29.218]                       else {
[13:22:29.218]                         version <- NULL
[13:22:29.218]                       }
[13:22:29.218]                       if (!has_future || version < "1.8.0") {
[13:22:29.218]                         info <- base::c(r_version = base::gsub("R version ", 
[13:22:29.218]                           "", base::R.version$version.string), 
[13:22:29.218]                           platform = base::sprintf("%s (%s-bit)", 
[13:22:29.218]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:29.218]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:29.218]                             "release", "version")], collapse = " "), 
[13:22:29.218]                           hostname = base::Sys.info()[["nodename"]])
[13:22:29.218]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:22:29.218]                           info)
[13:22:29.218]                         info <- base::paste(info, collapse = "; ")
[13:22:29.218]                         if (!has_future) {
[13:22:29.218]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:29.218]                             info)
[13:22:29.218]                         }
[13:22:29.218]                         else {
[13:22:29.218]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:29.218]                             info, version)
[13:22:29.218]                         }
[13:22:29.218]                         base::stop(msg)
[13:22:29.218]                       }
[13:22:29.218]                     })
[13:22:29.218]                   }
[13:22:29.218]                   options(future.plan = NULL)
[13:22:29.218]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:29.218]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:29.218]                 }
[13:22:29.218]                 ...future.workdir <- getwd()
[13:22:29.218]             }
[13:22:29.218]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:29.218]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:29.218]         }
[13:22:29.218]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:29.218]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:29.218]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:29.218]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:29.218]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:29.218]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:29.218]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:29.218]             base::names(...future.oldOptions))
[13:22:29.218]     }
[13:22:29.218]     if (FALSE) {
[13:22:29.218]     }
[13:22:29.218]     else {
[13:22:29.218]         if (TRUE) {
[13:22:29.218]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:29.218]                 open = "w")
[13:22:29.218]         }
[13:22:29.218]         else {
[13:22:29.218]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:29.218]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:29.218]         }
[13:22:29.218]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:29.218]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:29.218]             base::sink(type = "output", split = FALSE)
[13:22:29.218]             base::close(...future.stdout)
[13:22:29.218]         }, add = TRUE)
[13:22:29.218]     }
[13:22:29.218]     ...future.frame <- base::sys.nframe()
[13:22:29.218]     ...future.conditions <- base::list()
[13:22:29.218]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:29.218]     if (FALSE) {
[13:22:29.218]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:29.218]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:29.218]     }
[13:22:29.218]     ...future.result <- base::tryCatch({
[13:22:29.218]         base::withCallingHandlers({
[13:22:29.218]             ...future.value <- base::withVisible(base::local(print(42)))
[13:22:29.218]             future::FutureResult(value = ...future.value$value, 
[13:22:29.218]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:29.218]                   ...future.rng), globalenv = if (FALSE) 
[13:22:29.218]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:29.218]                     ...future.globalenv.names))
[13:22:29.218]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:29.218]         }, condition = base::local({
[13:22:29.218]             c <- base::c
[13:22:29.218]             inherits <- base::inherits
[13:22:29.218]             invokeRestart <- base::invokeRestart
[13:22:29.218]             length <- base::length
[13:22:29.218]             list <- base::list
[13:22:29.218]             seq.int <- base::seq.int
[13:22:29.218]             signalCondition <- base::signalCondition
[13:22:29.218]             sys.calls <- base::sys.calls
[13:22:29.218]             `[[` <- base::`[[`
[13:22:29.218]             `+` <- base::`+`
[13:22:29.218]             `<<-` <- base::`<<-`
[13:22:29.218]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:29.218]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:29.218]                   3L)]
[13:22:29.218]             }
[13:22:29.218]             function(cond) {
[13:22:29.218]                 is_error <- inherits(cond, "error")
[13:22:29.218]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:29.218]                   NULL)
[13:22:29.218]                 if (is_error) {
[13:22:29.218]                   sessionInformation <- function() {
[13:22:29.218]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:29.218]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:29.218]                       search = base::search(), system = base::Sys.info())
[13:22:29.218]                   }
[13:22:29.218]                   ...future.conditions[[length(...future.conditions) + 
[13:22:29.218]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:29.218]                     cond$call), session = sessionInformation(), 
[13:22:29.218]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:29.218]                   signalCondition(cond)
[13:22:29.218]                 }
[13:22:29.218]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:29.218]                 "immediateCondition"))) {
[13:22:29.218]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:29.218]                   ...future.conditions[[length(...future.conditions) + 
[13:22:29.218]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:29.218]                   if (TRUE && !signal) {
[13:22:29.218]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.218]                     {
[13:22:29.218]                       inherits <- base::inherits
[13:22:29.218]                       invokeRestart <- base::invokeRestart
[13:22:29.218]                       is.null <- base::is.null
[13:22:29.218]                       muffled <- FALSE
[13:22:29.218]                       if (inherits(cond, "message")) {
[13:22:29.218]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:29.218]                         if (muffled) 
[13:22:29.218]                           invokeRestart("muffleMessage")
[13:22:29.218]                       }
[13:22:29.218]                       else if (inherits(cond, "warning")) {
[13:22:29.218]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:29.218]                         if (muffled) 
[13:22:29.218]                           invokeRestart("muffleWarning")
[13:22:29.218]                       }
[13:22:29.218]                       else if (inherits(cond, "condition")) {
[13:22:29.218]                         if (!is.null(pattern)) {
[13:22:29.218]                           computeRestarts <- base::computeRestarts
[13:22:29.218]                           grepl <- base::grepl
[13:22:29.218]                           restarts <- computeRestarts(cond)
[13:22:29.218]                           for (restart in restarts) {
[13:22:29.218]                             name <- restart$name
[13:22:29.218]                             if (is.null(name)) 
[13:22:29.218]                               next
[13:22:29.218]                             if (!grepl(pattern, name)) 
[13:22:29.218]                               next
[13:22:29.218]                             invokeRestart(restart)
[13:22:29.218]                             muffled <- TRUE
[13:22:29.218]                             break
[13:22:29.218]                           }
[13:22:29.218]                         }
[13:22:29.218]                       }
[13:22:29.218]                       invisible(muffled)
[13:22:29.218]                     }
[13:22:29.218]                     muffleCondition(cond, pattern = "^muffle")
[13:22:29.218]                   }
[13:22:29.218]                 }
[13:22:29.218]                 else {
[13:22:29.218]                   if (TRUE) {
[13:22:29.218]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.218]                     {
[13:22:29.218]                       inherits <- base::inherits
[13:22:29.218]                       invokeRestart <- base::invokeRestart
[13:22:29.218]                       is.null <- base::is.null
[13:22:29.218]                       muffled <- FALSE
[13:22:29.218]                       if (inherits(cond, "message")) {
[13:22:29.218]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:29.218]                         if (muffled) 
[13:22:29.218]                           invokeRestart("muffleMessage")
[13:22:29.218]                       }
[13:22:29.218]                       else if (inherits(cond, "warning")) {
[13:22:29.218]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:29.218]                         if (muffled) 
[13:22:29.218]                           invokeRestart("muffleWarning")
[13:22:29.218]                       }
[13:22:29.218]                       else if (inherits(cond, "condition")) {
[13:22:29.218]                         if (!is.null(pattern)) {
[13:22:29.218]                           computeRestarts <- base::computeRestarts
[13:22:29.218]                           grepl <- base::grepl
[13:22:29.218]                           restarts <- computeRestarts(cond)
[13:22:29.218]                           for (restart in restarts) {
[13:22:29.218]                             name <- restart$name
[13:22:29.218]                             if (is.null(name)) 
[13:22:29.218]                               next
[13:22:29.218]                             if (!grepl(pattern, name)) 
[13:22:29.218]                               next
[13:22:29.218]                             invokeRestart(restart)
[13:22:29.218]                             muffled <- TRUE
[13:22:29.218]                             break
[13:22:29.218]                           }
[13:22:29.218]                         }
[13:22:29.218]                       }
[13:22:29.218]                       invisible(muffled)
[13:22:29.218]                     }
[13:22:29.218]                     muffleCondition(cond, pattern = "^muffle")
[13:22:29.218]                   }
[13:22:29.218]                 }
[13:22:29.218]             }
[13:22:29.218]         }))
[13:22:29.218]     }, error = function(ex) {
[13:22:29.218]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:29.218]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:29.218]                 ...future.rng), started = ...future.startTime, 
[13:22:29.218]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:29.218]             version = "1.8"), class = "FutureResult")
[13:22:29.218]     }, finally = {
[13:22:29.218]         if (!identical(...future.workdir, getwd())) 
[13:22:29.218]             setwd(...future.workdir)
[13:22:29.218]         {
[13:22:29.218]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:29.218]                 ...future.oldOptions$nwarnings <- NULL
[13:22:29.218]             }
[13:22:29.218]             base::options(...future.oldOptions)
[13:22:29.218]             if (.Platform$OS.type == "windows") {
[13:22:29.218]                 old_names <- names(...future.oldEnvVars)
[13:22:29.218]                 envs <- base::Sys.getenv()
[13:22:29.218]                 names <- names(envs)
[13:22:29.218]                 common <- intersect(names, old_names)
[13:22:29.218]                 added <- setdiff(names, old_names)
[13:22:29.218]                 removed <- setdiff(old_names, names)
[13:22:29.218]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:29.218]                   envs[common]]
[13:22:29.218]                 NAMES <- toupper(changed)
[13:22:29.218]                 args <- list()
[13:22:29.218]                 for (kk in seq_along(NAMES)) {
[13:22:29.218]                   name <- changed[[kk]]
[13:22:29.218]                   NAME <- NAMES[[kk]]
[13:22:29.218]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.218]                     next
[13:22:29.218]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:29.218]                 }
[13:22:29.218]                 NAMES <- toupper(added)
[13:22:29.218]                 for (kk in seq_along(NAMES)) {
[13:22:29.218]                   name <- added[[kk]]
[13:22:29.218]                   NAME <- NAMES[[kk]]
[13:22:29.218]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.218]                     next
[13:22:29.218]                   args[[name]] <- ""
[13:22:29.218]                 }
[13:22:29.218]                 NAMES <- toupper(removed)
[13:22:29.218]                 for (kk in seq_along(NAMES)) {
[13:22:29.218]                   name <- removed[[kk]]
[13:22:29.218]                   NAME <- NAMES[[kk]]
[13:22:29.218]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.218]                     next
[13:22:29.218]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:29.218]                 }
[13:22:29.218]                 if (length(args) > 0) 
[13:22:29.218]                   base::do.call(base::Sys.setenv, args = args)
[13:22:29.218]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:29.218]             }
[13:22:29.218]             else {
[13:22:29.218]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:29.218]             }
[13:22:29.218]             {
[13:22:29.218]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:29.218]                   0L) {
[13:22:29.218]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:29.218]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:29.218]                   base::options(opts)
[13:22:29.218]                 }
[13:22:29.218]                 {
[13:22:29.218]                   {
[13:22:29.218]                     NULL
[13:22:29.218]                     RNGkind("Mersenne-Twister")
[13:22:29.218]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:22:29.218]                       inherits = FALSE)
[13:22:29.218]                   }
[13:22:29.218]                   options(future.plan = NULL)
[13:22:29.218]                   if (is.na(NA_character_)) 
[13:22:29.218]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:29.218]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:29.218]                   future::plan(list(function (..., envir = parent.frame()) 
[13:22:29.218]                   {
[13:22:29.218]                     future <- SequentialFuture(..., envir = envir)
[13:22:29.218]                     if (!future$lazy) 
[13:22:29.218]                       future <- run(future)
[13:22:29.218]                     invisible(future)
[13:22:29.218]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:29.218]                 }
[13:22:29.218]             }
[13:22:29.218]         }
[13:22:29.218]     })
[13:22:29.218]     if (TRUE) {
[13:22:29.218]         base::sink(type = "output", split = FALSE)
[13:22:29.218]         if (TRUE) {
[13:22:29.218]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:29.218]         }
[13:22:29.218]         else {
[13:22:29.218]             ...future.result["stdout"] <- base::list(NULL)
[13:22:29.218]         }
[13:22:29.218]         base::close(...future.stdout)
[13:22:29.218]         ...future.stdout <- NULL
[13:22:29.218]     }
[13:22:29.218]     ...future.result$conditions <- ...future.conditions
[13:22:29.218]     ...future.result$finished <- base::Sys.time()
[13:22:29.218]     ...future.result
[13:22:29.218] }
[13:22:29.220] plan(): Setting new future strategy stack:
[13:22:29.220] List of future strategies:
[13:22:29.220] 1. sequential:
[13:22:29.220]    - args: function (..., envir = parent.frame())
[13:22:29.220]    - tweaked: FALSE
[13:22:29.220]    - call: NULL
[13:22:29.220] plan(): nbrOfWorkers() = 1
[13:22:29.221] plan(): Setting new future strategy stack:
[13:22:29.221] List of future strategies:
[13:22:29.221] 1. sequential:
[13:22:29.221]    - args: function (..., envir = parent.frame())
[13:22:29.221]    - tweaked: FALSE
[13:22:29.221]    - call: plan(strategy)
[13:22:29.221] plan(): nbrOfWorkers() = 1
[13:22:29.221] SequentialFuture started (and completed)
[13:22:29.222] - Launch lazy future ... done
[13:22:29.222] run() for ‘SequentialFuture’ ... done
[1] 42
- stdout = FALSE
[13:22:29.222] getGlobalsAndPackages() ...
[13:22:29.222] Searching for globals...
[13:22:29.227] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[13:22:29.227] Searching for globals ... DONE
[13:22:29.227] Resolving globals: FALSE
[13:22:29.228] 
[13:22:29.228] - packages: [1] ‘utils’
[13:22:29.228] getGlobalsAndPackages() ... DONE
[13:22:29.228] run() for ‘Future’ ...
[13:22:29.228] - state: ‘created’
[13:22:29.228] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:22:29.228] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:22:29.229] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:22:29.229]   - Field: ‘label’
[13:22:29.229]   - Field: ‘local’
[13:22:29.229]   - Field: ‘owner’
[13:22:29.229]   - Field: ‘envir’
[13:22:29.229]   - Field: ‘packages’
[13:22:29.229]   - Field: ‘gc’
[13:22:29.229]   - Field: ‘conditions’
[13:22:29.229]   - Field: ‘expr’
[13:22:29.229]   - Field: ‘uuid’
[13:22:29.230]   - Field: ‘seed’
[13:22:29.230]   - Field: ‘version’
[13:22:29.230]   - Field: ‘result’
[13:22:29.230]   - Field: ‘asynchronous’
[13:22:29.230]   - Field: ‘calls’
[13:22:29.230]   - Field: ‘globals’
[13:22:29.230]   - Field: ‘stdout’
[13:22:29.230]   - Field: ‘earlySignal’
[13:22:29.230]   - Field: ‘lazy’
[13:22:29.230]   - Field: ‘state’
[13:22:29.231] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:22:29.231] - Launch lazy future ...
[13:22:29.231] Packages needed by the future expression (n = 1): ‘utils’
[13:22:29.231] Packages needed by future strategies (n = 0): <none>
[13:22:29.231] {
[13:22:29.231]     {
[13:22:29.231]         {
[13:22:29.231]             ...future.startTime <- base::Sys.time()
[13:22:29.231]             {
[13:22:29.231]                 {
[13:22:29.231]                   {
[13:22:29.231]                     {
[13:22:29.231]                       base::local({
[13:22:29.231]                         has_future <- base::requireNamespace("future", 
[13:22:29.231]                           quietly = TRUE)
[13:22:29.231]                         if (has_future) {
[13:22:29.231]                           ns <- base::getNamespace("future")
[13:22:29.231]                           version <- ns[[".package"]][["version"]]
[13:22:29.231]                           if (is.null(version)) 
[13:22:29.231]                             version <- utils::packageVersion("future")
[13:22:29.231]                         }
[13:22:29.231]                         else {
[13:22:29.231]                           version <- NULL
[13:22:29.231]                         }
[13:22:29.231]                         if (!has_future || version < "1.8.0") {
[13:22:29.231]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:29.231]                             "", base::R.version$version.string), 
[13:22:29.231]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:29.231]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:29.231]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:29.231]                               "release", "version")], collapse = " "), 
[13:22:29.231]                             hostname = base::Sys.info()[["nodename"]])
[13:22:29.231]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:29.231]                             info)
[13:22:29.231]                           info <- base::paste(info, collapse = "; ")
[13:22:29.231]                           if (!has_future) {
[13:22:29.231]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:29.231]                               info)
[13:22:29.231]                           }
[13:22:29.231]                           else {
[13:22:29.231]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:29.231]                               info, version)
[13:22:29.231]                           }
[13:22:29.231]                           base::stop(msg)
[13:22:29.231]                         }
[13:22:29.231]                       })
[13:22:29.231]                     }
[13:22:29.231]                     base::local({
[13:22:29.231]                       for (pkg in "utils") {
[13:22:29.231]                         base::loadNamespace(pkg)
[13:22:29.231]                         base::library(pkg, character.only = TRUE)
[13:22:29.231]                       }
[13:22:29.231]                     })
[13:22:29.231]                   }
[13:22:29.231]                   options(future.plan = NULL)
[13:22:29.231]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:29.231]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:29.231]                 }
[13:22:29.231]                 ...future.workdir <- getwd()
[13:22:29.231]             }
[13:22:29.231]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:29.231]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:29.231]         }
[13:22:29.231]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:29.231]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:29.231]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:29.231]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:29.231]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:29.231]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:29.231]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:29.231]             base::names(...future.oldOptions))
[13:22:29.231]     }
[13:22:29.231]     if (FALSE) {
[13:22:29.231]     }
[13:22:29.231]     else {
[13:22:29.231]         if (FALSE) {
[13:22:29.231]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:29.231]                 open = "w")
[13:22:29.231]         }
[13:22:29.231]         else {
[13:22:29.231]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:29.231]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:29.231]         }
[13:22:29.231]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:29.231]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:29.231]             base::sink(type = "output", split = FALSE)
[13:22:29.231]             base::close(...future.stdout)
[13:22:29.231]         }, add = TRUE)
[13:22:29.231]     }
[13:22:29.231]     ...future.frame <- base::sys.nframe()
[13:22:29.231]     ...future.conditions <- base::list()
[13:22:29.231]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:29.231]     if (FALSE) {
[13:22:29.231]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:29.231]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:29.231]     }
[13:22:29.231]     ...future.result <- base::tryCatch({
[13:22:29.231]         base::withCallingHandlers({
[13:22:29.231]             ...future.value <- base::withVisible(base::local({
[13:22:29.231]                 print(1:50)
[13:22:29.231]                 str(1:50)
[13:22:29.231]                 cat(letters, sep = "-")
[13:22:29.231]                 cat(1:6, collapse = "\n")
[13:22:29.231]                 write.table(datasets::iris[1:10, ], sep = "\t")
[13:22:29.231]                 42L
[13:22:29.231]             }))
[13:22:29.231]             future::FutureResult(value = ...future.value$value, 
[13:22:29.231]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:29.231]                   ...future.rng), globalenv = if (FALSE) 
[13:22:29.231]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:29.231]                     ...future.globalenv.names))
[13:22:29.231]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:29.231]         }, condition = base::local({
[13:22:29.231]             c <- base::c
[13:22:29.231]             inherits <- base::inherits
[13:22:29.231]             invokeRestart <- base::invokeRestart
[13:22:29.231]             length <- base::length
[13:22:29.231]             list <- base::list
[13:22:29.231]             seq.int <- base::seq.int
[13:22:29.231]             signalCondition <- base::signalCondition
[13:22:29.231]             sys.calls <- base::sys.calls
[13:22:29.231]             `[[` <- base::`[[`
[13:22:29.231]             `+` <- base::`+`
[13:22:29.231]             `<<-` <- base::`<<-`
[13:22:29.231]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:29.231]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:29.231]                   3L)]
[13:22:29.231]             }
[13:22:29.231]             function(cond) {
[13:22:29.231]                 is_error <- inherits(cond, "error")
[13:22:29.231]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:29.231]                   NULL)
[13:22:29.231]                 if (is_error) {
[13:22:29.231]                   sessionInformation <- function() {
[13:22:29.231]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:29.231]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:29.231]                       search = base::search(), system = base::Sys.info())
[13:22:29.231]                   }
[13:22:29.231]                   ...future.conditions[[length(...future.conditions) + 
[13:22:29.231]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:29.231]                     cond$call), session = sessionInformation(), 
[13:22:29.231]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:29.231]                   signalCondition(cond)
[13:22:29.231]                 }
[13:22:29.231]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:29.231]                 "immediateCondition"))) {
[13:22:29.231]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:29.231]                   ...future.conditions[[length(...future.conditions) + 
[13:22:29.231]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:29.231]                   if (TRUE && !signal) {
[13:22:29.231]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.231]                     {
[13:22:29.231]                       inherits <- base::inherits
[13:22:29.231]                       invokeRestart <- base::invokeRestart
[13:22:29.231]                       is.null <- base::is.null
[13:22:29.231]                       muffled <- FALSE
[13:22:29.231]                       if (inherits(cond, "message")) {
[13:22:29.231]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:29.231]                         if (muffled) 
[13:22:29.231]                           invokeRestart("muffleMessage")
[13:22:29.231]                       }
[13:22:29.231]                       else if (inherits(cond, "warning")) {
[13:22:29.231]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:29.231]                         if (muffled) 
[13:22:29.231]                           invokeRestart("muffleWarning")
[13:22:29.231]                       }
[13:22:29.231]                       else if (inherits(cond, "condition")) {
[13:22:29.231]                         if (!is.null(pattern)) {
[13:22:29.231]                           computeRestarts <- base::computeRestarts
[13:22:29.231]                           grepl <- base::grepl
[13:22:29.231]                           restarts <- computeRestarts(cond)
[13:22:29.231]                           for (restart in restarts) {
[13:22:29.231]                             name <- restart$name
[13:22:29.231]                             if (is.null(name)) 
[13:22:29.231]                               next
[13:22:29.231]                             if (!grepl(pattern, name)) 
[13:22:29.231]                               next
[13:22:29.231]                             invokeRestart(restart)
[13:22:29.231]                             muffled <- TRUE
[13:22:29.231]                             break
[13:22:29.231]                           }
[13:22:29.231]                         }
[13:22:29.231]                       }
[13:22:29.231]                       invisible(muffled)
[13:22:29.231]                     }
[13:22:29.231]                     muffleCondition(cond, pattern = "^muffle")
[13:22:29.231]                   }
[13:22:29.231]                 }
[13:22:29.231]                 else {
[13:22:29.231]                   if (TRUE) {
[13:22:29.231]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.231]                     {
[13:22:29.231]                       inherits <- base::inherits
[13:22:29.231]                       invokeRestart <- base::invokeRestart
[13:22:29.231]                       is.null <- base::is.null
[13:22:29.231]                       muffled <- FALSE
[13:22:29.231]                       if (inherits(cond, "message")) {
[13:22:29.231]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:29.231]                         if (muffled) 
[13:22:29.231]                           invokeRestart("muffleMessage")
[13:22:29.231]                       }
[13:22:29.231]                       else if (inherits(cond, "warning")) {
[13:22:29.231]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:29.231]                         if (muffled) 
[13:22:29.231]                           invokeRestart("muffleWarning")
[13:22:29.231]                       }
[13:22:29.231]                       else if (inherits(cond, "condition")) {
[13:22:29.231]                         if (!is.null(pattern)) {
[13:22:29.231]                           computeRestarts <- base::computeRestarts
[13:22:29.231]                           grepl <- base::grepl
[13:22:29.231]                           restarts <- computeRestarts(cond)
[13:22:29.231]                           for (restart in restarts) {
[13:22:29.231]                             name <- restart$name
[13:22:29.231]                             if (is.null(name)) 
[13:22:29.231]                               next
[13:22:29.231]                             if (!grepl(pattern, name)) 
[13:22:29.231]                               next
[13:22:29.231]                             invokeRestart(restart)
[13:22:29.231]                             muffled <- TRUE
[13:22:29.231]                             break
[13:22:29.231]                           }
[13:22:29.231]                         }
[13:22:29.231]                       }
[13:22:29.231]                       invisible(muffled)
[13:22:29.231]                     }
[13:22:29.231]                     muffleCondition(cond, pattern = "^muffle")
[13:22:29.231]                   }
[13:22:29.231]                 }
[13:22:29.231]             }
[13:22:29.231]         }))
[13:22:29.231]     }, error = function(ex) {
[13:22:29.231]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:29.231]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:29.231]                 ...future.rng), started = ...future.startTime, 
[13:22:29.231]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:29.231]             version = "1.8"), class = "FutureResult")
[13:22:29.231]     }, finally = {
[13:22:29.231]         if (!identical(...future.workdir, getwd())) 
[13:22:29.231]             setwd(...future.workdir)
[13:22:29.231]         {
[13:22:29.231]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:29.231]                 ...future.oldOptions$nwarnings <- NULL
[13:22:29.231]             }
[13:22:29.231]             base::options(...future.oldOptions)
[13:22:29.231]             if (.Platform$OS.type == "windows") {
[13:22:29.231]                 old_names <- names(...future.oldEnvVars)
[13:22:29.231]                 envs <- base::Sys.getenv()
[13:22:29.231]                 names <- names(envs)
[13:22:29.231]                 common <- intersect(names, old_names)
[13:22:29.231]                 added <- setdiff(names, old_names)
[13:22:29.231]                 removed <- setdiff(old_names, names)
[13:22:29.231]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:29.231]                   envs[common]]
[13:22:29.231]                 NAMES <- toupper(changed)
[13:22:29.231]                 args <- list()
[13:22:29.231]                 for (kk in seq_along(NAMES)) {
[13:22:29.231]                   name <- changed[[kk]]
[13:22:29.231]                   NAME <- NAMES[[kk]]
[13:22:29.231]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.231]                     next
[13:22:29.231]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:29.231]                 }
[13:22:29.231]                 NAMES <- toupper(added)
[13:22:29.231]                 for (kk in seq_along(NAMES)) {
[13:22:29.231]                   name <- added[[kk]]
[13:22:29.231]                   NAME <- NAMES[[kk]]
[13:22:29.231]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.231]                     next
[13:22:29.231]                   args[[name]] <- ""
[13:22:29.231]                 }
[13:22:29.231]                 NAMES <- toupper(removed)
[13:22:29.231]                 for (kk in seq_along(NAMES)) {
[13:22:29.231]                   name <- removed[[kk]]
[13:22:29.231]                   NAME <- NAMES[[kk]]
[13:22:29.231]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.231]                     next
[13:22:29.231]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:29.231]                 }
[13:22:29.231]                 if (length(args) > 0) 
[13:22:29.231]                   base::do.call(base::Sys.setenv, args = args)
[13:22:29.231]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:29.231]             }
[13:22:29.231]             else {
[13:22:29.231]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:29.231]             }
[13:22:29.231]             {
[13:22:29.231]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:29.231]                   0L) {
[13:22:29.231]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:29.231]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:29.231]                   base::options(opts)
[13:22:29.231]                 }
[13:22:29.231]                 {
[13:22:29.231]                   {
[13:22:29.231]                     NULL
[13:22:29.231]                     RNGkind("Mersenne-Twister")
[13:22:29.231]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:22:29.231]                       inherits = FALSE)
[13:22:29.231]                   }
[13:22:29.231]                   options(future.plan = NULL)
[13:22:29.231]                   if (is.na(NA_character_)) 
[13:22:29.231]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:29.231]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:29.231]                   future::plan(list(function (..., envir = parent.frame()) 
[13:22:29.231]                   {
[13:22:29.231]                     future <- SequentialFuture(..., envir = envir)
[13:22:29.231]                     if (!future$lazy) 
[13:22:29.231]                       future <- run(future)
[13:22:29.231]                     invisible(future)
[13:22:29.231]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:29.231]                 }
[13:22:29.231]             }
[13:22:29.231]         }
[13:22:29.231]     })
[13:22:29.231]     if (TRUE) {
[13:22:29.231]         base::sink(type = "output", split = FALSE)
[13:22:29.231]         if (FALSE) {
[13:22:29.231]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:29.231]         }
[13:22:29.231]         else {
[13:22:29.231]             ...future.result["stdout"] <- base::list(NULL)
[13:22:29.231]         }
[13:22:29.231]         base::close(...future.stdout)
[13:22:29.231]         ...future.stdout <- NULL
[13:22:29.231]     }
[13:22:29.231]     ...future.result$conditions <- ...future.conditions
[13:22:29.231]     ...future.result$finished <- base::Sys.time()
[13:22:29.231]     ...future.result
[13:22:29.231] }
[13:22:29.233] plan(): Setting new future strategy stack:
[13:22:29.233] List of future strategies:
[13:22:29.233] 1. sequential:
[13:22:29.233]    - args: function (..., envir = parent.frame())
[13:22:29.233]    - tweaked: FALSE
[13:22:29.233]    - call: NULL
[13:22:29.234] plan(): nbrOfWorkers() = 1
[13:22:29.235] plan(): Setting new future strategy stack:
[13:22:29.235] List of future strategies:
[13:22:29.235] 1. sequential:
[13:22:29.235]    - args: function (..., envir = parent.frame())
[13:22:29.235]    - tweaked: FALSE
[13:22:29.235]    - call: plan(strategy)
[13:22:29.236] plan(): nbrOfWorkers() = 1
[13:22:29.236] SequentialFuture started (and completed)
[13:22:29.236] - Launch lazy future ... done
[13:22:29.236] run() for ‘SequentialFuture’ ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-01-07 13:22:29"
 $ finished    : POSIXct[1:1], format: "2025-01-07 13:22:29"
 $ session_uuid: chr "3cc83afd-53db-40eb-3db7-60d73dc7b598"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "5853cd8d1af0"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "5853cd8d1af0" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 93426
  .. ..$ time  : POSIXct[1:1], format: "2025-01-07 13:22:29"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 3 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[13:22:29.244] getGlobalsAndPackages() ...
[13:22:29.244] Searching for globals...
[13:22:29.247] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[13:22:29.247] Searching for globals ... DONE
[13:22:29.247] Resolving globals: FALSE
[13:22:29.247] 
[13:22:29.248] - packages: [1] ‘utils’
[13:22:29.248] getGlobalsAndPackages() ... DONE
[13:22:29.248] run() for ‘Future’ ...
[13:22:29.248] - state: ‘created’
[13:22:29.248] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:22:29.248] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:22:29.249] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:22:29.249]   - Field: ‘label’
[13:22:29.249]   - Field: ‘local’
[13:22:29.249]   - Field: ‘owner’
[13:22:29.249]   - Field: ‘envir’
[13:22:29.251]   - Field: ‘packages’
[13:22:29.251]   - Field: ‘gc’
[13:22:29.251]   - Field: ‘conditions’
[13:22:29.251]   - Field: ‘expr’
[13:22:29.251]   - Field: ‘uuid’
[13:22:29.251]   - Field: ‘seed’
[13:22:29.251]   - Field: ‘version’
[13:22:29.251]   - Field: ‘result’
[13:22:29.251]   - Field: ‘asynchronous’
[13:22:29.251]   - Field: ‘calls’
[13:22:29.251]   - Field: ‘globals’
[13:22:29.252]   - Field: ‘stdout’
[13:22:29.252]   - Field: ‘earlySignal’
[13:22:29.252]   - Field: ‘lazy’
[13:22:29.252]   - Field: ‘state’
[13:22:29.252] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:22:29.252] - Launch lazy future ...
[13:22:29.252] Packages needed by the future expression (n = 1): ‘utils’
[13:22:29.252] Packages needed by future strategies (n = 0): <none>
[13:22:29.253] {
[13:22:29.253]     {
[13:22:29.253]         {
[13:22:29.253]             ...future.startTime <- base::Sys.time()
[13:22:29.253]             {
[13:22:29.253]                 {
[13:22:29.253]                   {
[13:22:29.253]                     {
[13:22:29.253]                       base::local({
[13:22:29.253]                         has_future <- base::requireNamespace("future", 
[13:22:29.253]                           quietly = TRUE)
[13:22:29.253]                         if (has_future) {
[13:22:29.253]                           ns <- base::getNamespace("future")
[13:22:29.253]                           version <- ns[[".package"]][["version"]]
[13:22:29.253]                           if (is.null(version)) 
[13:22:29.253]                             version <- utils::packageVersion("future")
[13:22:29.253]                         }
[13:22:29.253]                         else {
[13:22:29.253]                           version <- NULL
[13:22:29.253]                         }
[13:22:29.253]                         if (!has_future || version < "1.8.0") {
[13:22:29.253]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:29.253]                             "", base::R.version$version.string), 
[13:22:29.253]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:29.253]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:29.253]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:29.253]                               "release", "version")], collapse = " "), 
[13:22:29.253]                             hostname = base::Sys.info()[["nodename"]])
[13:22:29.253]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:29.253]                             info)
[13:22:29.253]                           info <- base::paste(info, collapse = "; ")
[13:22:29.253]                           if (!has_future) {
[13:22:29.253]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:29.253]                               info)
[13:22:29.253]                           }
[13:22:29.253]                           else {
[13:22:29.253]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:29.253]                               info, version)
[13:22:29.253]                           }
[13:22:29.253]                           base::stop(msg)
[13:22:29.253]                         }
[13:22:29.253]                       })
[13:22:29.253]                     }
[13:22:29.253]                     base::local({
[13:22:29.253]                       for (pkg in "utils") {
[13:22:29.253]                         base::loadNamespace(pkg)
[13:22:29.253]                         base::library(pkg, character.only = TRUE)
[13:22:29.253]                       }
[13:22:29.253]                     })
[13:22:29.253]                   }
[13:22:29.253]                   options(future.plan = NULL)
[13:22:29.253]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:29.253]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:29.253]                 }
[13:22:29.253]                 ...future.workdir <- getwd()
[13:22:29.253]             }
[13:22:29.253]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:29.253]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:29.253]         }
[13:22:29.253]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:29.253]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:29.253]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:29.253]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:29.253]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:29.253]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:29.253]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:29.253]             base::names(...future.oldOptions))
[13:22:29.253]     }
[13:22:29.253]     if (FALSE) {
[13:22:29.253]     }
[13:22:29.253]     else {
[13:22:29.253]         if (FALSE) {
[13:22:29.253]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:29.253]                 open = "w")
[13:22:29.253]         }
[13:22:29.253]         else {
[13:22:29.253]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:29.253]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:29.253]         }
[13:22:29.253]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:29.253]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:29.253]             base::sink(type = "output", split = FALSE)
[13:22:29.253]             base::close(...future.stdout)
[13:22:29.253]         }, add = TRUE)
[13:22:29.253]     }
[13:22:29.253]     ...future.frame <- base::sys.nframe()
[13:22:29.253]     ...future.conditions <- base::list()
[13:22:29.253]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:29.253]     if (FALSE) {
[13:22:29.253]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:29.253]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:29.253]     }
[13:22:29.253]     ...future.result <- base::tryCatch({
[13:22:29.253]         base::withCallingHandlers({
[13:22:29.253]             ...future.value <- base::withVisible(base::local({
[13:22:29.253]                 print(1:50)
[13:22:29.253]                 str(1:50)
[13:22:29.253]                 cat(letters, sep = "-")
[13:22:29.253]                 cat(1:6, collapse = "\n")
[13:22:29.253]                 write.table(datasets::iris[1:10, ], sep = "\t")
[13:22:29.253]                 42L
[13:22:29.253]             }))
[13:22:29.253]             future::FutureResult(value = ...future.value$value, 
[13:22:29.253]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:29.253]                   ...future.rng), globalenv = if (FALSE) 
[13:22:29.253]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:29.253]                     ...future.globalenv.names))
[13:22:29.253]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:29.253]         }, condition = base::local({
[13:22:29.253]             c <- base::c
[13:22:29.253]             inherits <- base::inherits
[13:22:29.253]             invokeRestart <- base::invokeRestart
[13:22:29.253]             length <- base::length
[13:22:29.253]             list <- base::list
[13:22:29.253]             seq.int <- base::seq.int
[13:22:29.253]             signalCondition <- base::signalCondition
[13:22:29.253]             sys.calls <- base::sys.calls
[13:22:29.253]             `[[` <- base::`[[`
[13:22:29.253]             `+` <- base::`+`
[13:22:29.253]             `<<-` <- base::`<<-`
[13:22:29.253]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:29.253]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:29.253]                   3L)]
[13:22:29.253]             }
[13:22:29.253]             function(cond) {
[13:22:29.253]                 is_error <- inherits(cond, "error")
[13:22:29.253]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:29.253]                   NULL)
[13:22:29.253]                 if (is_error) {
[13:22:29.253]                   sessionInformation <- function() {
[13:22:29.253]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:29.253]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:29.253]                       search = base::search(), system = base::Sys.info())
[13:22:29.253]                   }
[13:22:29.253]                   ...future.conditions[[length(...future.conditions) + 
[13:22:29.253]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:29.253]                     cond$call), session = sessionInformation(), 
[13:22:29.253]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:29.253]                   signalCondition(cond)
[13:22:29.253]                 }
[13:22:29.253]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:29.253]                 "immediateCondition"))) {
[13:22:29.253]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:29.253]                   ...future.conditions[[length(...future.conditions) + 
[13:22:29.253]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:29.253]                   if (TRUE && !signal) {
[13:22:29.253]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.253]                     {
[13:22:29.253]                       inherits <- base::inherits
[13:22:29.253]                       invokeRestart <- base::invokeRestart
[13:22:29.253]                       is.null <- base::is.null
[13:22:29.253]                       muffled <- FALSE
[13:22:29.253]                       if (inherits(cond, "message")) {
[13:22:29.253]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:29.253]                         if (muffled) 
[13:22:29.253]                           invokeRestart("muffleMessage")
[13:22:29.253]                       }
[13:22:29.253]                       else if (inherits(cond, "warning")) {
[13:22:29.253]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:29.253]                         if (muffled) 
[13:22:29.253]                           invokeRestart("muffleWarning")
[13:22:29.253]                       }
[13:22:29.253]                       else if (inherits(cond, "condition")) {
[13:22:29.253]                         if (!is.null(pattern)) {
[13:22:29.253]                           computeRestarts <- base::computeRestarts
[13:22:29.253]                           grepl <- base::grepl
[13:22:29.253]                           restarts <- computeRestarts(cond)
[13:22:29.253]                           for (restart in restarts) {
[13:22:29.253]                             name <- restart$name
[13:22:29.253]                             if (is.null(name)) 
[13:22:29.253]                               next
[13:22:29.253]                             if (!grepl(pattern, name)) 
[13:22:29.253]                               next
[13:22:29.253]                             invokeRestart(restart)
[13:22:29.253]                             muffled <- TRUE
[13:22:29.253]                             break
[13:22:29.253]                           }
[13:22:29.253]                         }
[13:22:29.253]                       }
[13:22:29.253]                       invisible(muffled)
[13:22:29.253]                     }
[13:22:29.253]                     muffleCondition(cond, pattern = "^muffle")
[13:22:29.253]                   }
[13:22:29.253]                 }
[13:22:29.253]                 else {
[13:22:29.253]                   if (TRUE) {
[13:22:29.253]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.253]                     {
[13:22:29.253]                       inherits <- base::inherits
[13:22:29.253]                       invokeRestart <- base::invokeRestart
[13:22:29.253]                       is.null <- base::is.null
[13:22:29.253]                       muffled <- FALSE
[13:22:29.253]                       if (inherits(cond, "message")) {
[13:22:29.253]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:29.253]                         if (muffled) 
[13:22:29.253]                           invokeRestart("muffleMessage")
[13:22:29.253]                       }
[13:22:29.253]                       else if (inherits(cond, "warning")) {
[13:22:29.253]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:29.253]                         if (muffled) 
[13:22:29.253]                           invokeRestart("muffleWarning")
[13:22:29.253]                       }
[13:22:29.253]                       else if (inherits(cond, "condition")) {
[13:22:29.253]                         if (!is.null(pattern)) {
[13:22:29.253]                           computeRestarts <- base::computeRestarts
[13:22:29.253]                           grepl <- base::grepl
[13:22:29.253]                           restarts <- computeRestarts(cond)
[13:22:29.253]                           for (restart in restarts) {
[13:22:29.253]                             name <- restart$name
[13:22:29.253]                             if (is.null(name)) 
[13:22:29.253]                               next
[13:22:29.253]                             if (!grepl(pattern, name)) 
[13:22:29.253]                               next
[13:22:29.253]                             invokeRestart(restart)
[13:22:29.253]                             muffled <- TRUE
[13:22:29.253]                             break
[13:22:29.253]                           }
[13:22:29.253]                         }
[13:22:29.253]                       }
[13:22:29.253]                       invisible(muffled)
[13:22:29.253]                     }
[13:22:29.253]                     muffleCondition(cond, pattern = "^muffle")
[13:22:29.253]                   }
[13:22:29.253]                 }
[13:22:29.253]             }
[13:22:29.253]         }))
[13:22:29.253]     }, error = function(ex) {
[13:22:29.253]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:29.253]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:29.253]                 ...future.rng), started = ...future.startTime, 
[13:22:29.253]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:29.253]             version = "1.8"), class = "FutureResult")
[13:22:29.253]     }, finally = {
[13:22:29.253]         if (!identical(...future.workdir, getwd())) 
[13:22:29.253]             setwd(...future.workdir)
[13:22:29.253]         {
[13:22:29.253]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:29.253]                 ...future.oldOptions$nwarnings <- NULL
[13:22:29.253]             }
[13:22:29.253]             base::options(...future.oldOptions)
[13:22:29.253]             if (.Platform$OS.type == "windows") {
[13:22:29.253]                 old_names <- names(...future.oldEnvVars)
[13:22:29.253]                 envs <- base::Sys.getenv()
[13:22:29.253]                 names <- names(envs)
[13:22:29.253]                 common <- intersect(names, old_names)
[13:22:29.253]                 added <- setdiff(names, old_names)
[13:22:29.253]                 removed <- setdiff(old_names, names)
[13:22:29.253]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:29.253]                   envs[common]]
[13:22:29.253]                 NAMES <- toupper(changed)
[13:22:29.253]                 args <- list()
[13:22:29.253]                 for (kk in seq_along(NAMES)) {
[13:22:29.253]                   name <- changed[[kk]]
[13:22:29.253]                   NAME <- NAMES[[kk]]
[13:22:29.253]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.253]                     next
[13:22:29.253]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:29.253]                 }
[13:22:29.253]                 NAMES <- toupper(added)
[13:22:29.253]                 for (kk in seq_along(NAMES)) {
[13:22:29.253]                   name <- added[[kk]]
[13:22:29.253]                   NAME <- NAMES[[kk]]
[13:22:29.253]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.253]                     next
[13:22:29.253]                   args[[name]] <- ""
[13:22:29.253]                 }
[13:22:29.253]                 NAMES <- toupper(removed)
[13:22:29.253]                 for (kk in seq_along(NAMES)) {
[13:22:29.253]                   name <- removed[[kk]]
[13:22:29.253]                   NAME <- NAMES[[kk]]
[13:22:29.253]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.253]                     next
[13:22:29.253]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:29.253]                 }
[13:22:29.253]                 if (length(args) > 0) 
[13:22:29.253]                   base::do.call(base::Sys.setenv, args = args)
[13:22:29.253]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:29.253]             }
[13:22:29.253]             else {
[13:22:29.253]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:29.253]             }
[13:22:29.253]             {
[13:22:29.253]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:29.253]                   0L) {
[13:22:29.253]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:29.253]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:29.253]                   base::options(opts)
[13:22:29.253]                 }
[13:22:29.253]                 {
[13:22:29.253]                   {
[13:22:29.253]                     NULL
[13:22:29.253]                     RNGkind("Mersenne-Twister")
[13:22:29.253]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:22:29.253]                       inherits = FALSE)
[13:22:29.253]                   }
[13:22:29.253]                   options(future.plan = NULL)
[13:22:29.253]                   if (is.na(NA_character_)) 
[13:22:29.253]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:29.253]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:29.253]                   future::plan(list(function (..., envir = parent.frame()) 
[13:22:29.253]                   {
[13:22:29.253]                     future <- SequentialFuture(..., envir = envir)
[13:22:29.253]                     if (!future$lazy) 
[13:22:29.253]                       future <- run(future)
[13:22:29.253]                     invisible(future)
[13:22:29.253]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:29.253]                 }
[13:22:29.253]             }
[13:22:29.253]         }
[13:22:29.253]     })
[13:22:29.253]     if (TRUE) {
[13:22:29.253]         base::sink(type = "output", split = FALSE)
[13:22:29.253]         if (FALSE) {
[13:22:29.253]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:29.253]         }
[13:22:29.253]         else {
[13:22:29.253]             ...future.result["stdout"] <- base::list(NULL)
[13:22:29.253]         }
[13:22:29.253]         base::close(...future.stdout)
[13:22:29.253]         ...future.stdout <- NULL
[13:22:29.253]     }
[13:22:29.253]     ...future.result$conditions <- ...future.conditions
[13:22:29.253]     ...future.result$finished <- base::Sys.time()
[13:22:29.253]     ...future.result
[13:22:29.253] }
[13:22:29.255] plan(): Setting new future strategy stack:
[13:22:29.255] List of future strategies:
[13:22:29.255] 1. sequential:
[13:22:29.255]    - args: function (..., envir = parent.frame())
[13:22:29.255]    - tweaked: FALSE
[13:22:29.255]    - call: NULL
[13:22:29.255] plan(): nbrOfWorkers() = 1
[13:22:29.257] plan(): Setting new future strategy stack:
[13:22:29.257] List of future strategies:
[13:22:29.257] 1. sequential:
[13:22:29.257]    - args: function (..., envir = parent.frame())
[13:22:29.257]    - tweaked: FALSE
[13:22:29.257]    - call: plan(strategy)
[13:22:29.257] plan(): nbrOfWorkers() = 1
[13:22:29.257] SequentialFuture started (and completed)
[13:22:29.258] - Launch lazy future ... done
[13:22:29.258] run() for ‘SequentialFuture’ ... done
- stdout = structure(TRUE, drop = TRUE)
[13:22:29.258] getGlobalsAndPackages() ...
[13:22:29.258] Searching for globals...
[13:22:29.259] - globals found: [1] ‘print’
[13:22:29.259] Searching for globals ... DONE
[13:22:29.259] Resolving globals: FALSE
[13:22:29.259] 
[13:22:29.259] 
[13:22:29.259] getGlobalsAndPackages() ... DONE
[13:22:29.259] run() for ‘Future’ ...
[13:22:29.260] - state: ‘created’
[13:22:29.260] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:22:29.260] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:22:29.260] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:22:29.260]   - Field: ‘label’
[13:22:29.260]   - Field: ‘local’
[13:22:29.260]   - Field: ‘owner’
[13:22:29.261]   - Field: ‘envir’
[13:22:29.261]   - Field: ‘packages’
[13:22:29.261]   - Field: ‘gc’
[13:22:29.261]   - Field: ‘conditions’
[13:22:29.261]   - Field: ‘expr’
[13:22:29.261]   - Field: ‘uuid’
[13:22:29.261]   - Field: ‘seed’
[13:22:29.261]   - Field: ‘version’
[13:22:29.261]   - Field: ‘result’
[13:22:29.261]   - Field: ‘asynchronous’
[13:22:29.261]   - Field: ‘calls’
[13:22:29.262]   - Field: ‘globals’
[13:22:29.262]   - Field: ‘stdout’
[13:22:29.262]   - Field: ‘earlySignal’
[13:22:29.262]   - Field: ‘lazy’
[13:22:29.262]   - Field: ‘state’
[13:22:29.262] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:22:29.262] - Launch lazy future ...
[13:22:29.262] Packages needed by the future expression (n = 0): <none>
[13:22:29.262] Packages needed by future strategies (n = 0): <none>
[13:22:29.263] {
[13:22:29.263]     {
[13:22:29.263]         {
[13:22:29.263]             ...future.startTime <- base::Sys.time()
[13:22:29.263]             {
[13:22:29.263]                 {
[13:22:29.263]                   {
[13:22:29.263]                     base::local({
[13:22:29.263]                       has_future <- base::requireNamespace("future", 
[13:22:29.263]                         quietly = TRUE)
[13:22:29.263]                       if (has_future) {
[13:22:29.263]                         ns <- base::getNamespace("future")
[13:22:29.263]                         version <- ns[[".package"]][["version"]]
[13:22:29.263]                         if (is.null(version)) 
[13:22:29.263]                           version <- utils::packageVersion("future")
[13:22:29.263]                       }
[13:22:29.263]                       else {
[13:22:29.263]                         version <- NULL
[13:22:29.263]                       }
[13:22:29.263]                       if (!has_future || version < "1.8.0") {
[13:22:29.263]                         info <- base::c(r_version = base::gsub("R version ", 
[13:22:29.263]                           "", base::R.version$version.string), 
[13:22:29.263]                           platform = base::sprintf("%s (%s-bit)", 
[13:22:29.263]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:29.263]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:29.263]                             "release", "version")], collapse = " "), 
[13:22:29.263]                           hostname = base::Sys.info()[["nodename"]])
[13:22:29.263]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:22:29.263]                           info)
[13:22:29.263]                         info <- base::paste(info, collapse = "; ")
[13:22:29.263]                         if (!has_future) {
[13:22:29.263]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:29.263]                             info)
[13:22:29.263]                         }
[13:22:29.263]                         else {
[13:22:29.263]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:29.263]                             info, version)
[13:22:29.263]                         }
[13:22:29.263]                         base::stop(msg)
[13:22:29.263]                       }
[13:22:29.263]                     })
[13:22:29.263]                   }
[13:22:29.263]                   options(future.plan = NULL)
[13:22:29.263]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:29.263]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:29.263]                 }
[13:22:29.263]                 ...future.workdir <- getwd()
[13:22:29.263]             }
[13:22:29.263]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:29.263]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:29.263]         }
[13:22:29.263]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:29.263]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:29.263]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:29.263]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:29.263]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:29.263]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:29.263]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:29.263]             base::names(...future.oldOptions))
[13:22:29.263]     }
[13:22:29.263]     if (FALSE) {
[13:22:29.263]     }
[13:22:29.263]     else {
[13:22:29.263]         if (TRUE) {
[13:22:29.263]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:29.263]                 open = "w")
[13:22:29.263]         }
[13:22:29.263]         else {
[13:22:29.263]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:29.263]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:29.263]         }
[13:22:29.263]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:29.263]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:29.263]             base::sink(type = "output", split = FALSE)
[13:22:29.263]             base::close(...future.stdout)
[13:22:29.263]         }, add = TRUE)
[13:22:29.263]     }
[13:22:29.263]     ...future.frame <- base::sys.nframe()
[13:22:29.263]     ...future.conditions <- base::list()
[13:22:29.263]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:29.263]     if (FALSE) {
[13:22:29.263]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:29.263]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:29.263]     }
[13:22:29.263]     ...future.result <- base::tryCatch({
[13:22:29.263]         base::withCallingHandlers({
[13:22:29.263]             ...future.value <- base::withVisible(base::local(print(42)))
[13:22:29.263]             future::FutureResult(value = ...future.value$value, 
[13:22:29.263]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:29.263]                   ...future.rng), globalenv = if (FALSE) 
[13:22:29.263]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:29.263]                     ...future.globalenv.names))
[13:22:29.263]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:29.263]         }, condition = base::local({
[13:22:29.263]             c <- base::c
[13:22:29.263]             inherits <- base::inherits
[13:22:29.263]             invokeRestart <- base::invokeRestart
[13:22:29.263]             length <- base::length
[13:22:29.263]             list <- base::list
[13:22:29.263]             seq.int <- base::seq.int
[13:22:29.263]             signalCondition <- base::signalCondition
[13:22:29.263]             sys.calls <- base::sys.calls
[13:22:29.263]             `[[` <- base::`[[`
[13:22:29.263]             `+` <- base::`+`
[13:22:29.263]             `<<-` <- base::`<<-`
[13:22:29.263]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:29.263]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:29.263]                   3L)]
[13:22:29.263]             }
[13:22:29.263]             function(cond) {
[13:22:29.263]                 is_error <- inherits(cond, "error")
[13:22:29.263]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:29.263]                   NULL)
[13:22:29.263]                 if (is_error) {
[13:22:29.263]                   sessionInformation <- function() {
[13:22:29.263]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:29.263]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:29.263]                       search = base::search(), system = base::Sys.info())
[13:22:29.263]                   }
[13:22:29.263]                   ...future.conditions[[length(...future.conditions) + 
[13:22:29.263]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:29.263]                     cond$call), session = sessionInformation(), 
[13:22:29.263]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:29.263]                   signalCondition(cond)
[13:22:29.263]                 }
[13:22:29.263]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:29.263]                 "immediateCondition"))) {
[13:22:29.263]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:29.263]                   ...future.conditions[[length(...future.conditions) + 
[13:22:29.263]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:29.263]                   if (TRUE && !signal) {
[13:22:29.263]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.263]                     {
[13:22:29.263]                       inherits <- base::inherits
[13:22:29.263]                       invokeRestart <- base::invokeRestart
[13:22:29.263]                       is.null <- base::is.null
[13:22:29.263]                       muffled <- FALSE
[13:22:29.263]                       if (inherits(cond, "message")) {
[13:22:29.263]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:29.263]                         if (muffled) 
[13:22:29.263]                           invokeRestart("muffleMessage")
[13:22:29.263]                       }
[13:22:29.263]                       else if (inherits(cond, "warning")) {
[13:22:29.263]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:29.263]                         if (muffled) 
[13:22:29.263]                           invokeRestart("muffleWarning")
[13:22:29.263]                       }
[13:22:29.263]                       else if (inherits(cond, "condition")) {
[13:22:29.263]                         if (!is.null(pattern)) {
[13:22:29.263]                           computeRestarts <- base::computeRestarts
[13:22:29.263]                           grepl <- base::grepl
[13:22:29.263]                           restarts <- computeRestarts(cond)
[13:22:29.263]                           for (restart in restarts) {
[13:22:29.263]                             name <- restart$name
[13:22:29.263]                             if (is.null(name)) 
[13:22:29.263]                               next
[13:22:29.263]                             if (!grepl(pattern, name)) 
[13:22:29.263]                               next
[13:22:29.263]                             invokeRestart(restart)
[13:22:29.263]                             muffled <- TRUE
[13:22:29.263]                             break
[13:22:29.263]                           }
[13:22:29.263]                         }
[13:22:29.263]                       }
[13:22:29.263]                       invisible(muffled)
[13:22:29.263]                     }
[13:22:29.263]                     muffleCondition(cond, pattern = "^muffle")
[13:22:29.263]                   }
[13:22:29.263]                 }
[13:22:29.263]                 else {
[13:22:29.263]                   if (TRUE) {
[13:22:29.263]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.263]                     {
[13:22:29.263]                       inherits <- base::inherits
[13:22:29.263]                       invokeRestart <- base::invokeRestart
[13:22:29.263]                       is.null <- base::is.null
[13:22:29.263]                       muffled <- FALSE
[13:22:29.263]                       if (inherits(cond, "message")) {
[13:22:29.263]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:29.263]                         if (muffled) 
[13:22:29.263]                           invokeRestart("muffleMessage")
[13:22:29.263]                       }
[13:22:29.263]                       else if (inherits(cond, "warning")) {
[13:22:29.263]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:29.263]                         if (muffled) 
[13:22:29.263]                           invokeRestart("muffleWarning")
[13:22:29.263]                       }
[13:22:29.263]                       else if (inherits(cond, "condition")) {
[13:22:29.263]                         if (!is.null(pattern)) {
[13:22:29.263]                           computeRestarts <- base::computeRestarts
[13:22:29.263]                           grepl <- base::grepl
[13:22:29.263]                           restarts <- computeRestarts(cond)
[13:22:29.263]                           for (restart in restarts) {
[13:22:29.263]                             name <- restart$name
[13:22:29.263]                             if (is.null(name)) 
[13:22:29.263]                               next
[13:22:29.263]                             if (!grepl(pattern, name)) 
[13:22:29.263]                               next
[13:22:29.263]                             invokeRestart(restart)
[13:22:29.263]                             muffled <- TRUE
[13:22:29.263]                             break
[13:22:29.263]                           }
[13:22:29.263]                         }
[13:22:29.263]                       }
[13:22:29.263]                       invisible(muffled)
[13:22:29.263]                     }
[13:22:29.263]                     muffleCondition(cond, pattern = "^muffle")
[13:22:29.263]                   }
[13:22:29.263]                 }
[13:22:29.263]             }
[13:22:29.263]         }))
[13:22:29.263]     }, error = function(ex) {
[13:22:29.263]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:29.263]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:29.263]                 ...future.rng), started = ...future.startTime, 
[13:22:29.263]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:29.263]             version = "1.8"), class = "FutureResult")
[13:22:29.263]     }, finally = {
[13:22:29.263]         if (!identical(...future.workdir, getwd())) 
[13:22:29.263]             setwd(...future.workdir)
[13:22:29.263]         {
[13:22:29.263]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:29.263]                 ...future.oldOptions$nwarnings <- NULL
[13:22:29.263]             }
[13:22:29.263]             base::options(...future.oldOptions)
[13:22:29.263]             if (.Platform$OS.type == "windows") {
[13:22:29.263]                 old_names <- names(...future.oldEnvVars)
[13:22:29.263]                 envs <- base::Sys.getenv()
[13:22:29.263]                 names <- names(envs)
[13:22:29.263]                 common <- intersect(names, old_names)
[13:22:29.263]                 added <- setdiff(names, old_names)
[13:22:29.263]                 removed <- setdiff(old_names, names)
[13:22:29.263]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:29.263]                   envs[common]]
[13:22:29.263]                 NAMES <- toupper(changed)
[13:22:29.263]                 args <- list()
[13:22:29.263]                 for (kk in seq_along(NAMES)) {
[13:22:29.263]                   name <- changed[[kk]]
[13:22:29.263]                   NAME <- NAMES[[kk]]
[13:22:29.263]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.263]                     next
[13:22:29.263]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:29.263]                 }
[13:22:29.263]                 NAMES <- toupper(added)
[13:22:29.263]                 for (kk in seq_along(NAMES)) {
[13:22:29.263]                   name <- added[[kk]]
[13:22:29.263]                   NAME <- NAMES[[kk]]
[13:22:29.263]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.263]                     next
[13:22:29.263]                   args[[name]] <- ""
[13:22:29.263]                 }
[13:22:29.263]                 NAMES <- toupper(removed)
[13:22:29.263]                 for (kk in seq_along(NAMES)) {
[13:22:29.263]                   name <- removed[[kk]]
[13:22:29.263]                   NAME <- NAMES[[kk]]
[13:22:29.263]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.263]                     next
[13:22:29.263]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:29.263]                 }
[13:22:29.263]                 if (length(args) > 0) 
[13:22:29.263]                   base::do.call(base::Sys.setenv, args = args)
[13:22:29.263]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:29.263]             }
[13:22:29.263]             else {
[13:22:29.263]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:29.263]             }
[13:22:29.263]             {
[13:22:29.263]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:29.263]                   0L) {
[13:22:29.263]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:29.263]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:29.263]                   base::options(opts)
[13:22:29.263]                 }
[13:22:29.263]                 {
[13:22:29.263]                   {
[13:22:29.263]                     NULL
[13:22:29.263]                     RNGkind("Mersenne-Twister")
[13:22:29.263]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:22:29.263]                       inherits = FALSE)
[13:22:29.263]                   }
[13:22:29.263]                   options(future.plan = NULL)
[13:22:29.263]                   if (is.na(NA_character_)) 
[13:22:29.263]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:29.263]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:29.263]                   future::plan(list(function (..., envir = parent.frame()) 
[13:22:29.263]                   {
[13:22:29.263]                     future <- SequentialFuture(..., envir = envir)
[13:22:29.263]                     if (!future$lazy) 
[13:22:29.263]                       future <- run(future)
[13:22:29.263]                     invisible(future)
[13:22:29.263]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:29.263]                 }
[13:22:29.263]             }
[13:22:29.263]         }
[13:22:29.263]     })
[13:22:29.263]     if (TRUE) {
[13:22:29.263]         base::sink(type = "output", split = FALSE)
[13:22:29.263]         if (TRUE) {
[13:22:29.263]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:29.263]         }
[13:22:29.263]         else {
[13:22:29.263]             ...future.result["stdout"] <- base::list(NULL)
[13:22:29.263]         }
[13:22:29.263]         base::close(...future.stdout)
[13:22:29.263]         ...future.stdout <- NULL
[13:22:29.263]     }
[13:22:29.263]     ...future.result$conditions <- ...future.conditions
[13:22:29.263]     ...future.result$finished <- base::Sys.time()
[13:22:29.263]     ...future.result
[13:22:29.263] }
[13:22:29.265] plan(): Setting new future strategy stack:
[13:22:29.265] List of future strategies:
[13:22:29.265] 1. sequential:
[13:22:29.265]    - args: function (..., envir = parent.frame())
[13:22:29.265]    - tweaked: FALSE
[13:22:29.265]    - call: NULL
[13:22:29.265] plan(): nbrOfWorkers() = 1
[13:22:29.266] plan(): Setting new future strategy stack:
[13:22:29.266] List of future strategies:
[13:22:29.266] 1. sequential:
[13:22:29.266]    - args: function (..., envir = parent.frame())
[13:22:29.266]    - tweaked: FALSE
[13:22:29.266]    - call: plan(strategy)
[13:22:29.266] plan(): nbrOfWorkers() = 1
[13:22:29.266] SequentialFuture started (and completed)
[13:22:29.266] - Launch lazy future ... done
[13:22:29.267] run() for ‘SequentialFuture’ ... done
[1] 42
- stdout = NA
[13:22:29.267] getGlobalsAndPackages() ...
[13:22:29.267] Searching for globals...
[13:22:29.270] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[13:22:29.270] Searching for globals ... DONE
[13:22:29.270] Resolving globals: FALSE
[13:22:29.270] 
[13:22:29.271] - packages: [1] ‘utils’
[13:22:29.271] getGlobalsAndPackages() ... DONE
[13:22:29.271] run() for ‘Future’ ...
[13:22:29.271] - state: ‘created’
[13:22:29.271] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:22:29.271] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:22:29.272] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:22:29.272]   - Field: ‘label’
[13:22:29.272]   - Field: ‘local’
[13:22:29.272]   - Field: ‘owner’
[13:22:29.272]   - Field: ‘envir’
[13:22:29.272]   - Field: ‘packages’
[13:22:29.272]   - Field: ‘gc’
[13:22:29.272]   - Field: ‘conditions’
[13:22:29.272]   - Field: ‘expr’
[13:22:29.272]   - Field: ‘uuid’
[13:22:29.272]   - Field: ‘seed’
[13:22:29.273]   - Field: ‘version’
[13:22:29.273]   - Field: ‘result’
[13:22:29.273]   - Field: ‘asynchronous’
[13:22:29.273]   - Field: ‘calls’
[13:22:29.273]   - Field: ‘globals’
[13:22:29.273]   - Field: ‘stdout’
[13:22:29.273]   - Field: ‘earlySignal’
[13:22:29.273]   - Field: ‘lazy’
[13:22:29.273]   - Field: ‘state’
[13:22:29.273] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:22:29.274] - Launch lazy future ...
[13:22:29.274] Packages needed by the future expression (n = 1): ‘utils’
[13:22:29.274] Packages needed by future strategies (n = 0): <none>
[13:22:29.274] {
[13:22:29.274]     {
[13:22:29.274]         {
[13:22:29.274]             ...future.startTime <- base::Sys.time()
[13:22:29.274]             {
[13:22:29.274]                 {
[13:22:29.274]                   {
[13:22:29.274]                     {
[13:22:29.274]                       base::local({
[13:22:29.274]                         has_future <- base::requireNamespace("future", 
[13:22:29.274]                           quietly = TRUE)
[13:22:29.274]                         if (has_future) {
[13:22:29.274]                           ns <- base::getNamespace("future")
[13:22:29.274]                           version <- ns[[".package"]][["version"]]
[13:22:29.274]                           if (is.null(version)) 
[13:22:29.274]                             version <- utils::packageVersion("future")
[13:22:29.274]                         }
[13:22:29.274]                         else {
[13:22:29.274]                           version <- NULL
[13:22:29.274]                         }
[13:22:29.274]                         if (!has_future || version < "1.8.0") {
[13:22:29.274]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:29.274]                             "", base::R.version$version.string), 
[13:22:29.274]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:29.274]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:29.274]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:29.274]                               "release", "version")], collapse = " "), 
[13:22:29.274]                             hostname = base::Sys.info()[["nodename"]])
[13:22:29.274]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:29.274]                             info)
[13:22:29.274]                           info <- base::paste(info, collapse = "; ")
[13:22:29.274]                           if (!has_future) {
[13:22:29.274]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:29.274]                               info)
[13:22:29.274]                           }
[13:22:29.274]                           else {
[13:22:29.274]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:29.274]                               info, version)
[13:22:29.274]                           }
[13:22:29.274]                           base::stop(msg)
[13:22:29.274]                         }
[13:22:29.274]                       })
[13:22:29.274]                     }
[13:22:29.274]                     base::local({
[13:22:29.274]                       for (pkg in "utils") {
[13:22:29.274]                         base::loadNamespace(pkg)
[13:22:29.274]                         base::library(pkg, character.only = TRUE)
[13:22:29.274]                       }
[13:22:29.274]                     })
[13:22:29.274]                   }
[13:22:29.274]                   options(future.plan = NULL)
[13:22:29.274]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:29.274]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:29.274]                 }
[13:22:29.274]                 ...future.workdir <- getwd()
[13:22:29.274]             }
[13:22:29.274]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:29.274]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:29.274]         }
[13:22:29.274]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:29.274]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:29.274]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:29.274]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:29.274]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:29.274]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:29.274]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:29.274]             base::names(...future.oldOptions))
[13:22:29.274]     }
[13:22:29.274]     if (TRUE) {
[13:22:29.274]     }
[13:22:29.274]     else {
[13:22:29.274]         if (NA) {
[13:22:29.274]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:29.274]                 open = "w")
[13:22:29.274]         }
[13:22:29.274]         else {
[13:22:29.274]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:29.274]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:29.274]         }
[13:22:29.274]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:29.274]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:29.274]             base::sink(type = "output", split = FALSE)
[13:22:29.274]             base::close(...future.stdout)
[13:22:29.274]         }, add = TRUE)
[13:22:29.274]     }
[13:22:29.274]     ...future.frame <- base::sys.nframe()
[13:22:29.274]     ...future.conditions <- base::list()
[13:22:29.274]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:29.274]     if (FALSE) {
[13:22:29.274]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:29.274]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:29.274]     }
[13:22:29.274]     ...future.result <- base::tryCatch({
[13:22:29.274]         base::withCallingHandlers({
[13:22:29.274]             ...future.value <- base::withVisible(base::local({
[13:22:29.274]                 print(1:50)
[13:22:29.274]                 str(1:50)
[13:22:29.274]                 cat(letters, sep = "-")
[13:22:29.274]                 cat(1:6, collapse = "\n")
[13:22:29.274]                 write.table(datasets::iris[1:10, ], sep = "\t")
[13:22:29.274]                 42L
[13:22:29.274]             }))
[13:22:29.274]             future::FutureResult(value = ...future.value$value, 
[13:22:29.274]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:29.274]                   ...future.rng), globalenv = if (FALSE) 
[13:22:29.274]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:29.274]                     ...future.globalenv.names))
[13:22:29.274]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:29.274]         }, condition = base::local({
[13:22:29.274]             c <- base::c
[13:22:29.274]             inherits <- base::inherits
[13:22:29.274]             invokeRestart <- base::invokeRestart
[13:22:29.274]             length <- base::length
[13:22:29.274]             list <- base::list
[13:22:29.274]             seq.int <- base::seq.int
[13:22:29.274]             signalCondition <- base::signalCondition
[13:22:29.274]             sys.calls <- base::sys.calls
[13:22:29.274]             `[[` <- base::`[[`
[13:22:29.274]             `+` <- base::`+`
[13:22:29.274]             `<<-` <- base::`<<-`
[13:22:29.274]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:29.274]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:29.274]                   3L)]
[13:22:29.274]             }
[13:22:29.274]             function(cond) {
[13:22:29.274]                 is_error <- inherits(cond, "error")
[13:22:29.274]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:29.274]                   NULL)
[13:22:29.274]                 if (is_error) {
[13:22:29.274]                   sessionInformation <- function() {
[13:22:29.274]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:29.274]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:29.274]                       search = base::search(), system = base::Sys.info())
[13:22:29.274]                   }
[13:22:29.274]                   ...future.conditions[[length(...future.conditions) + 
[13:22:29.274]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:29.274]                     cond$call), session = sessionInformation(), 
[13:22:29.274]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:29.274]                   signalCondition(cond)
[13:22:29.274]                 }
[13:22:29.274]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:29.274]                 "immediateCondition"))) {
[13:22:29.274]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:29.274]                   ...future.conditions[[length(...future.conditions) + 
[13:22:29.274]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:29.274]                   if (TRUE && !signal) {
[13:22:29.274]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.274]                     {
[13:22:29.274]                       inherits <- base::inherits
[13:22:29.274]                       invokeRestart <- base::invokeRestart
[13:22:29.274]                       is.null <- base::is.null
[13:22:29.274]                       muffled <- FALSE
[13:22:29.274]                       if (inherits(cond, "message")) {
[13:22:29.274]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:29.274]                         if (muffled) 
[13:22:29.274]                           invokeRestart("muffleMessage")
[13:22:29.274]                       }
[13:22:29.274]                       else if (inherits(cond, "warning")) {
[13:22:29.274]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:29.274]                         if (muffled) 
[13:22:29.274]                           invokeRestart("muffleWarning")
[13:22:29.274]                       }
[13:22:29.274]                       else if (inherits(cond, "condition")) {
[13:22:29.274]                         if (!is.null(pattern)) {
[13:22:29.274]                           computeRestarts <- base::computeRestarts
[13:22:29.274]                           grepl <- base::grepl
[13:22:29.274]                           restarts <- computeRestarts(cond)
[13:22:29.274]                           for (restart in restarts) {
[13:22:29.274]                             name <- restart$name
[13:22:29.274]                             if (is.null(name)) 
[13:22:29.274]                               next
[13:22:29.274]                             if (!grepl(pattern, name)) 
[13:22:29.274]                               next
[13:22:29.274]                             invokeRestart(restart)
[13:22:29.274]                             muffled <- TRUE
[13:22:29.274]                             break
[13:22:29.274]                           }
[13:22:29.274]                         }
[13:22:29.274]                       }
[13:22:29.274]                       invisible(muffled)
[13:22:29.274]                     }
[13:22:29.274]                     muffleCondition(cond, pattern = "^muffle")
[13:22:29.274]                   }
[13:22:29.274]                 }
[13:22:29.274]                 else {
[13:22:29.274]                   if (TRUE) {
[13:22:29.274]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.274]                     {
[13:22:29.274]                       inherits <- base::inherits
[13:22:29.274]                       invokeRestart <- base::invokeRestart
[13:22:29.274]                       is.null <- base::is.null
[13:22:29.274]                       muffled <- FALSE
[13:22:29.274]                       if (inherits(cond, "message")) {
[13:22:29.274]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:29.274]                         if (muffled) 
[13:22:29.274]                           invokeRestart("muffleMessage")
[13:22:29.274]                       }
[13:22:29.274]                       else if (inherits(cond, "warning")) {
[13:22:29.274]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:29.274]                         if (muffled) 
[13:22:29.274]                           invokeRestart("muffleWarning")
[13:22:29.274]                       }
[13:22:29.274]                       else if (inherits(cond, "condition")) {
[13:22:29.274]                         if (!is.null(pattern)) {
[13:22:29.274]                           computeRestarts <- base::computeRestarts
[13:22:29.274]                           grepl <- base::grepl
[13:22:29.274]                           restarts <- computeRestarts(cond)
[13:22:29.274]                           for (restart in restarts) {
[13:22:29.274]                             name <- restart$name
[13:22:29.274]                             if (is.null(name)) 
[13:22:29.274]                               next
[13:22:29.274]                             if (!grepl(pattern, name)) 
[13:22:29.274]                               next
[13:22:29.274]                             invokeRestart(restart)
[13:22:29.274]                             muffled <- TRUE
[13:22:29.274]                             break
[13:22:29.274]                           }
[13:22:29.274]                         }
[13:22:29.274]                       }
[13:22:29.274]                       invisible(muffled)
[13:22:29.274]                     }
[13:22:29.274]                     muffleCondition(cond, pattern = "^muffle")
[13:22:29.274]                   }
[13:22:29.274]                 }
[13:22:29.274]             }
[13:22:29.274]         }))
[13:22:29.274]     }, error = function(ex) {
[13:22:29.274]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:29.274]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:29.274]                 ...future.rng), started = ...future.startTime, 
[13:22:29.274]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:29.274]             version = "1.8"), class = "FutureResult")
[13:22:29.274]     }, finally = {
[13:22:29.274]         if (!identical(...future.workdir, getwd())) 
[13:22:29.274]             setwd(...future.workdir)
[13:22:29.274]         {
[13:22:29.274]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:29.274]                 ...future.oldOptions$nwarnings <- NULL
[13:22:29.274]             }
[13:22:29.274]             base::options(...future.oldOptions)
[13:22:29.274]             if (.Platform$OS.type == "windows") {
[13:22:29.274]                 old_names <- names(...future.oldEnvVars)
[13:22:29.274]                 envs <- base::Sys.getenv()
[13:22:29.274]                 names <- names(envs)
[13:22:29.274]                 common <- intersect(names, old_names)
[13:22:29.274]                 added <- setdiff(names, old_names)
[13:22:29.274]                 removed <- setdiff(old_names, names)
[13:22:29.274]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:29.274]                   envs[common]]
[13:22:29.274]                 NAMES <- toupper(changed)
[13:22:29.274]                 args <- list()
[13:22:29.274]                 for (kk in seq_along(NAMES)) {
[13:22:29.274]                   name <- changed[[kk]]
[13:22:29.274]                   NAME <- NAMES[[kk]]
[13:22:29.274]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.274]                     next
[13:22:29.274]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:29.274]                 }
[13:22:29.274]                 NAMES <- toupper(added)
[13:22:29.274]                 for (kk in seq_along(NAMES)) {
[13:22:29.274]                   name <- added[[kk]]
[13:22:29.274]                   NAME <- NAMES[[kk]]
[13:22:29.274]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.274]                     next
[13:22:29.274]                   args[[name]] <- ""
[13:22:29.274]                 }
[13:22:29.274]                 NAMES <- toupper(removed)
[13:22:29.274]                 for (kk in seq_along(NAMES)) {
[13:22:29.274]                   name <- removed[[kk]]
[13:22:29.274]                   NAME <- NAMES[[kk]]
[13:22:29.274]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.274]                     next
[13:22:29.274]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:29.274]                 }
[13:22:29.274]                 if (length(args) > 0) 
[13:22:29.274]                   base::do.call(base::Sys.setenv, args = args)
[13:22:29.274]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:29.274]             }
[13:22:29.274]             else {
[13:22:29.274]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:29.274]             }
[13:22:29.274]             {
[13:22:29.274]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:29.274]                   0L) {
[13:22:29.274]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:29.274]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:29.274]                   base::options(opts)
[13:22:29.274]                 }
[13:22:29.274]                 {
[13:22:29.274]                   {
[13:22:29.274]                     NULL
[13:22:29.274]                     RNGkind("Mersenne-Twister")
[13:22:29.274]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:22:29.274]                       inherits = FALSE)
[13:22:29.274]                   }
[13:22:29.274]                   options(future.plan = NULL)
[13:22:29.274]                   if (is.na(NA_character_)) 
[13:22:29.274]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:29.274]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:29.274]                   future::plan(list(function (..., envir = parent.frame()) 
[13:22:29.274]                   {
[13:22:29.274]                     future <- SequentialFuture(..., envir = envir)
[13:22:29.274]                     if (!future$lazy) 
[13:22:29.274]                       future <- run(future)
[13:22:29.274]                     invisible(future)
[13:22:29.274]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:29.274]                 }
[13:22:29.274]             }
[13:22:29.274]         }
[13:22:29.274]     })
[13:22:29.274]     if (FALSE) {
[13:22:29.274]         base::sink(type = "output", split = FALSE)
[13:22:29.274]         if (NA) {
[13:22:29.274]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:29.274]         }
[13:22:29.274]         else {
[13:22:29.274]             ...future.result["stdout"] <- base::list(NULL)
[13:22:29.274]         }
[13:22:29.274]         base::close(...future.stdout)
[13:22:29.274]         ...future.stdout <- NULL
[13:22:29.274]     }
[13:22:29.274]     ...future.result$conditions <- ...future.conditions
[13:22:29.274]     ...future.result$finished <- base::Sys.time()
[13:22:29.274]     ...future.result
[13:22:29.274] }
[13:22:29.276] plan(): Setting new future strategy stack:
[13:22:29.276] List of future strategies:
[13:22:29.276] 1. sequential:
[13:22:29.276]    - args: function (..., envir = parent.frame())
[13:22:29.276]    - tweaked: FALSE
[13:22:29.276]    - call: NULL
[13:22:29.277] plan(): nbrOfWorkers() = 1
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
[13:22:29.278] plan(): Setting new future strategy stack:
[13:22:29.278] List of future strategies:
[13:22:29.278] 1. sequential:
[13:22:29.278]    - args: function (..., envir = parent.frame())
[13:22:29.278]    - tweaked: FALSE
[13:22:29.278]    - call: plan(strategy)
[13:22:29.279] plan(): nbrOfWorkers() = 1
[13:22:29.279] SequentialFuture started (and completed)
[13:22:29.279] - Launch lazy future ... done
[13:22:29.281] run() for ‘SequentialFuture’ ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-01-07 13:22:29"
 $ finished    : POSIXct[1:1], format: "2025-01-07 13:22:29"
 $ session_uuid: chr "3cc83afd-53db-40eb-3db7-60d73dc7b598"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "5853cd8d1af0"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "5853cd8d1af0" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 93426
  .. ..$ time  : POSIXct[1:1], format: "2025-01-07 13:22:29"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 3 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[13:22:29.289] getGlobalsAndPackages() ...
[13:22:29.289] Searching for globals...
[13:22:29.292] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[13:22:29.292] Searching for globals ... DONE
[13:22:29.292] Resolving globals: FALSE
[13:22:29.292] 
[13:22:29.292] - packages: [1] ‘utils’
[13:22:29.293] getGlobalsAndPackages() ... DONE
[13:22:29.293] run() for ‘Future’ ...
[13:22:29.293] - state: ‘created’
[13:22:29.293] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:22:29.293] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:22:29.293] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:22:29.294]   - Field: ‘label’
[13:22:29.294]   - Field: ‘local’
[13:22:29.294]   - Field: ‘owner’
[13:22:29.294]   - Field: ‘envir’
[13:22:29.294]   - Field: ‘packages’
[13:22:29.294]   - Field: ‘gc’
[13:22:29.294]   - Field: ‘conditions’
[13:22:29.294]   - Field: ‘expr’
[13:22:29.294]   - Field: ‘uuid’
[13:22:29.294]   - Field: ‘seed’
[13:22:29.294]   - Field: ‘version’
[13:22:29.295]   - Field: ‘result’
[13:22:29.295]   - Field: ‘asynchronous’
[13:22:29.295]   - Field: ‘calls’
[13:22:29.295]   - Field: ‘globals’
[13:22:29.295]   - Field: ‘stdout’
[13:22:29.295]   - Field: ‘earlySignal’
[13:22:29.295]   - Field: ‘lazy’
[13:22:29.295]   - Field: ‘state’
[13:22:29.295] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:22:29.295] - Launch lazy future ...
[13:22:29.296] Packages needed by the future expression (n = 1): ‘utils’
[13:22:29.296] Packages needed by future strategies (n = 0): <none>
[13:22:29.296] {
[13:22:29.296]     {
[13:22:29.296]         {
[13:22:29.296]             ...future.startTime <- base::Sys.time()
[13:22:29.296]             {
[13:22:29.296]                 {
[13:22:29.296]                   {
[13:22:29.296]                     {
[13:22:29.296]                       base::local({
[13:22:29.296]                         has_future <- base::requireNamespace("future", 
[13:22:29.296]                           quietly = TRUE)
[13:22:29.296]                         if (has_future) {
[13:22:29.296]                           ns <- base::getNamespace("future")
[13:22:29.296]                           version <- ns[[".package"]][["version"]]
[13:22:29.296]                           if (is.null(version)) 
[13:22:29.296]                             version <- utils::packageVersion("future")
[13:22:29.296]                         }
[13:22:29.296]                         else {
[13:22:29.296]                           version <- NULL
[13:22:29.296]                         }
[13:22:29.296]                         if (!has_future || version < "1.8.0") {
[13:22:29.296]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:29.296]                             "", base::R.version$version.string), 
[13:22:29.296]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:29.296]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:29.296]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:29.296]                               "release", "version")], collapse = " "), 
[13:22:29.296]                             hostname = base::Sys.info()[["nodename"]])
[13:22:29.296]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:29.296]                             info)
[13:22:29.296]                           info <- base::paste(info, collapse = "; ")
[13:22:29.296]                           if (!has_future) {
[13:22:29.296]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:29.296]                               info)
[13:22:29.296]                           }
[13:22:29.296]                           else {
[13:22:29.296]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:29.296]                               info, version)
[13:22:29.296]                           }
[13:22:29.296]                           base::stop(msg)
[13:22:29.296]                         }
[13:22:29.296]                       })
[13:22:29.296]                     }
[13:22:29.296]                     base::local({
[13:22:29.296]                       for (pkg in "utils") {
[13:22:29.296]                         base::loadNamespace(pkg)
[13:22:29.296]                         base::library(pkg, character.only = TRUE)
[13:22:29.296]                       }
[13:22:29.296]                     })
[13:22:29.296]                   }
[13:22:29.296]                   options(future.plan = NULL)
[13:22:29.296]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:29.296]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:29.296]                 }
[13:22:29.296]                 ...future.workdir <- getwd()
[13:22:29.296]             }
[13:22:29.296]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:29.296]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:29.296]         }
[13:22:29.296]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:29.296]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:29.296]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:29.296]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:29.296]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:29.296]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:29.296]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:29.296]             base::names(...future.oldOptions))
[13:22:29.296]     }
[13:22:29.296]     if (TRUE) {
[13:22:29.296]     }
[13:22:29.296]     else {
[13:22:29.296]         if (NA) {
[13:22:29.296]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:29.296]                 open = "w")
[13:22:29.296]         }
[13:22:29.296]         else {
[13:22:29.296]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:29.296]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:29.296]         }
[13:22:29.296]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:29.296]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:29.296]             base::sink(type = "output", split = FALSE)
[13:22:29.296]             base::close(...future.stdout)
[13:22:29.296]         }, add = TRUE)
[13:22:29.296]     }
[13:22:29.296]     ...future.frame <- base::sys.nframe()
[13:22:29.296]     ...future.conditions <- base::list()
[13:22:29.296]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:29.296]     if (FALSE) {
[13:22:29.296]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:29.296]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:29.296]     }
[13:22:29.296]     ...future.result <- base::tryCatch({
[13:22:29.296]         base::withCallingHandlers({
[13:22:29.296]             ...future.value <- base::withVisible(base::local({
[13:22:29.296]                 print(1:50)
[13:22:29.296]                 str(1:50)
[13:22:29.296]                 cat(letters, sep = "-")
[13:22:29.296]                 cat(1:6, collapse = "\n")
[13:22:29.296]                 write.table(datasets::iris[1:10, ], sep = "\t")
[13:22:29.296]                 42L
[13:22:29.296]             }))
[13:22:29.296]             future::FutureResult(value = ...future.value$value, 
[13:22:29.296]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:29.296]                   ...future.rng), globalenv = if (FALSE) 
[13:22:29.296]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:29.296]                     ...future.globalenv.names))
[13:22:29.296]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:29.296]         }, condition = base::local({
[13:22:29.296]             c <- base::c
[13:22:29.296]             inherits <- base::inherits
[13:22:29.296]             invokeRestart <- base::invokeRestart
[13:22:29.296]             length <- base::length
[13:22:29.296]             list <- base::list
[13:22:29.296]             seq.int <- base::seq.int
[13:22:29.296]             signalCondition <- base::signalCondition
[13:22:29.296]             sys.calls <- base::sys.calls
[13:22:29.296]             `[[` <- base::`[[`
[13:22:29.296]             `+` <- base::`+`
[13:22:29.296]             `<<-` <- base::`<<-`
[13:22:29.296]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:29.296]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:29.296]                   3L)]
[13:22:29.296]             }
[13:22:29.296]             function(cond) {
[13:22:29.296]                 is_error <- inherits(cond, "error")
[13:22:29.296]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:29.296]                   NULL)
[13:22:29.296]                 if (is_error) {
[13:22:29.296]                   sessionInformation <- function() {
[13:22:29.296]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:29.296]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:29.296]                       search = base::search(), system = base::Sys.info())
[13:22:29.296]                   }
[13:22:29.296]                   ...future.conditions[[length(...future.conditions) + 
[13:22:29.296]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:29.296]                     cond$call), session = sessionInformation(), 
[13:22:29.296]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:29.296]                   signalCondition(cond)
[13:22:29.296]                 }
[13:22:29.296]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:29.296]                 "immediateCondition"))) {
[13:22:29.296]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:29.296]                   ...future.conditions[[length(...future.conditions) + 
[13:22:29.296]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:29.296]                   if (TRUE && !signal) {
[13:22:29.296]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.296]                     {
[13:22:29.296]                       inherits <- base::inherits
[13:22:29.296]                       invokeRestart <- base::invokeRestart
[13:22:29.296]                       is.null <- base::is.null
[13:22:29.296]                       muffled <- FALSE
[13:22:29.296]                       if (inherits(cond, "message")) {
[13:22:29.296]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:29.296]                         if (muffled) 
[13:22:29.296]                           invokeRestart("muffleMessage")
[13:22:29.296]                       }
[13:22:29.296]                       else if (inherits(cond, "warning")) {
[13:22:29.296]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:29.296]                         if (muffled) 
[13:22:29.296]                           invokeRestart("muffleWarning")
[13:22:29.296]                       }
[13:22:29.296]                       else if (inherits(cond, "condition")) {
[13:22:29.296]                         if (!is.null(pattern)) {
[13:22:29.296]                           computeRestarts <- base::computeRestarts
[13:22:29.296]                           grepl <- base::grepl
[13:22:29.296]                           restarts <- computeRestarts(cond)
[13:22:29.296]                           for (restart in restarts) {
[13:22:29.296]                             name <- restart$name
[13:22:29.296]                             if (is.null(name)) 
[13:22:29.296]                               next
[13:22:29.296]                             if (!grepl(pattern, name)) 
[13:22:29.296]                               next
[13:22:29.296]                             invokeRestart(restart)
[13:22:29.296]                             muffled <- TRUE
[13:22:29.296]                             break
[13:22:29.296]                           }
[13:22:29.296]                         }
[13:22:29.296]                       }
[13:22:29.296]                       invisible(muffled)
[13:22:29.296]                     }
[13:22:29.296]                     muffleCondition(cond, pattern = "^muffle")
[13:22:29.296]                   }
[13:22:29.296]                 }
[13:22:29.296]                 else {
[13:22:29.296]                   if (TRUE) {
[13:22:29.296]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.296]                     {
[13:22:29.296]                       inherits <- base::inherits
[13:22:29.296]                       invokeRestart <- base::invokeRestart
[13:22:29.296]                       is.null <- base::is.null
[13:22:29.296]                       muffled <- FALSE
[13:22:29.296]                       if (inherits(cond, "message")) {
[13:22:29.296]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:29.296]                         if (muffled) 
[13:22:29.296]                           invokeRestart("muffleMessage")
[13:22:29.296]                       }
[13:22:29.296]                       else if (inherits(cond, "warning")) {
[13:22:29.296]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:29.296]                         if (muffled) 
[13:22:29.296]                           invokeRestart("muffleWarning")
[13:22:29.296]                       }
[13:22:29.296]                       else if (inherits(cond, "condition")) {
[13:22:29.296]                         if (!is.null(pattern)) {
[13:22:29.296]                           computeRestarts <- base::computeRestarts
[13:22:29.296]                           grepl <- base::grepl
[13:22:29.296]                           restarts <- computeRestarts(cond)
[13:22:29.296]                           for (restart in restarts) {
[13:22:29.296]                             name <- restart$name
[13:22:29.296]                             if (is.null(name)) 
[13:22:29.296]                               next
[13:22:29.296]                             if (!grepl(pattern, name)) 
[13:22:29.296]                               next
[13:22:29.296]                             invokeRestart(restart)
[13:22:29.296]                             muffled <- TRUE
[13:22:29.296]                             break
[13:22:29.296]                           }
[13:22:29.296]                         }
[13:22:29.296]                       }
[13:22:29.296]                       invisible(muffled)
[13:22:29.296]                     }
[13:22:29.296]                     muffleCondition(cond, pattern = "^muffle")
[13:22:29.296]                   }
[13:22:29.296]                 }
[13:22:29.296]             }
[13:22:29.296]         }))
[13:22:29.296]     }, error = function(ex) {
[13:22:29.296]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:29.296]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:29.296]                 ...future.rng), started = ...future.startTime, 
[13:22:29.296]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:29.296]             version = "1.8"), class = "FutureResult")
[13:22:29.296]     }, finally = {
[13:22:29.296]         if (!identical(...future.workdir, getwd())) 
[13:22:29.296]             setwd(...future.workdir)
[13:22:29.296]         {
[13:22:29.296]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:29.296]                 ...future.oldOptions$nwarnings <- NULL
[13:22:29.296]             }
[13:22:29.296]             base::options(...future.oldOptions)
[13:22:29.296]             if (.Platform$OS.type == "windows") {
[13:22:29.296]                 old_names <- names(...future.oldEnvVars)
[13:22:29.296]                 envs <- base::Sys.getenv()
[13:22:29.296]                 names <- names(envs)
[13:22:29.296]                 common <- intersect(names, old_names)
[13:22:29.296]                 added <- setdiff(names, old_names)
[13:22:29.296]                 removed <- setdiff(old_names, names)
[13:22:29.296]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:29.296]                   envs[common]]
[13:22:29.296]                 NAMES <- toupper(changed)
[13:22:29.296]                 args <- list()
[13:22:29.296]                 for (kk in seq_along(NAMES)) {
[13:22:29.296]                   name <- changed[[kk]]
[13:22:29.296]                   NAME <- NAMES[[kk]]
[13:22:29.296]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.296]                     next
[13:22:29.296]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:29.296]                 }
[13:22:29.296]                 NAMES <- toupper(added)
[13:22:29.296]                 for (kk in seq_along(NAMES)) {
[13:22:29.296]                   name <- added[[kk]]
[13:22:29.296]                   NAME <- NAMES[[kk]]
[13:22:29.296]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.296]                     next
[13:22:29.296]                   args[[name]] <- ""
[13:22:29.296]                 }
[13:22:29.296]                 NAMES <- toupper(removed)
[13:22:29.296]                 for (kk in seq_along(NAMES)) {
[13:22:29.296]                   name <- removed[[kk]]
[13:22:29.296]                   NAME <- NAMES[[kk]]
[13:22:29.296]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.296]                     next
[13:22:29.296]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:29.296]                 }
[13:22:29.296]                 if (length(args) > 0) 
[13:22:29.296]                   base::do.call(base::Sys.setenv, args = args)
[13:22:29.296]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:29.296]             }
[13:22:29.296]             else {
[13:22:29.296]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:29.296]             }
[13:22:29.296]             {
[13:22:29.296]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:29.296]                   0L) {
[13:22:29.296]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:29.296]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:29.296]                   base::options(opts)
[13:22:29.296]                 }
[13:22:29.296]                 {
[13:22:29.296]                   {
[13:22:29.296]                     NULL
[13:22:29.296]                     RNGkind("Mersenne-Twister")
[13:22:29.296]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:22:29.296]                       inherits = FALSE)
[13:22:29.296]                   }
[13:22:29.296]                   options(future.plan = NULL)
[13:22:29.296]                   if (is.na(NA_character_)) 
[13:22:29.296]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:29.296]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:29.296]                   future::plan(list(function (..., envir = parent.frame()) 
[13:22:29.296]                   {
[13:22:29.296]                     future <- SequentialFuture(..., envir = envir)
[13:22:29.296]                     if (!future$lazy) 
[13:22:29.296]                       future <- run(future)
[13:22:29.296]                     invisible(future)
[13:22:29.296]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:29.296]                 }
[13:22:29.296]             }
[13:22:29.296]         }
[13:22:29.296]     })
[13:22:29.296]     if (FALSE) {
[13:22:29.296]         base::sink(type = "output", split = FALSE)
[13:22:29.296]         if (NA) {
[13:22:29.296]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:29.296]         }
[13:22:29.296]         else {
[13:22:29.296]             ...future.result["stdout"] <- base::list(NULL)
[13:22:29.296]         }
[13:22:29.296]         base::close(...future.stdout)
[13:22:29.296]         ...future.stdout <- NULL
[13:22:29.296]     }
[13:22:29.296]     ...future.result$conditions <- ...future.conditions
[13:22:29.296]     ...future.result$finished <- base::Sys.time()
[13:22:29.296]     ...future.result
[13:22:29.296] }
[13:22:29.298] plan(): Setting new future strategy stack:
[13:22:29.298] List of future strategies:
[13:22:29.298] 1. sequential:
[13:22:29.298]    - args: function (..., envir = parent.frame())
[13:22:29.298]    - tweaked: FALSE
[13:22:29.298]    - call: NULL
[13:22:29.299] plan(): nbrOfWorkers() = 1
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
[13:22:29.300] plan(): Setting new future strategy stack:
[13:22:29.300] List of future strategies:
[13:22:29.300] 1. sequential:
[13:22:29.300]    - args: function (..., envir = parent.frame())
[13:22:29.300]    - tweaked: FALSE
[13:22:29.300]    - call: plan(strategy)
[13:22:29.301] plan(): nbrOfWorkers() = 1
[13:22:29.301] SequentialFuture started (and completed)
[13:22:29.301] - Launch lazy future ... done
[13:22:29.301] run() for ‘SequentialFuture’ ... done
- stdout = structure(TRUE, drop = TRUE)
[13:22:29.302] getGlobalsAndPackages() ...
[13:22:29.302] Searching for globals...
[13:22:29.302] - globals found: [1] ‘print’
[13:22:29.302] Searching for globals ... DONE
[13:22:29.302] Resolving globals: FALSE
[13:22:29.303] 
[13:22:29.303] 
[13:22:29.303] getGlobalsAndPackages() ... DONE
[13:22:29.303] run() for ‘Future’ ...
[13:22:29.303] - state: ‘created’
[13:22:29.303] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:22:29.303] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:22:29.304] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:22:29.304]   - Field: ‘label’
[13:22:29.304]   - Field: ‘local’
[13:22:29.304]   - Field: ‘owner’
[13:22:29.304]   - Field: ‘envir’
[13:22:29.304]   - Field: ‘packages’
[13:22:29.304]   - Field: ‘gc’
[13:22:29.304]   - Field: ‘conditions’
[13:22:29.304]   - Field: ‘expr’
[13:22:29.304]   - Field: ‘uuid’
[13:22:29.305]   - Field: ‘seed’
[13:22:29.305]   - Field: ‘version’
[13:22:29.305]   - Field: ‘result’
[13:22:29.305]   - Field: ‘asynchronous’
[13:22:29.305]   - Field: ‘calls’
[13:22:29.305]   - Field: ‘globals’
[13:22:29.305]   - Field: ‘stdout’
[13:22:29.305]   - Field: ‘earlySignal’
[13:22:29.305]   - Field: ‘lazy’
[13:22:29.305]   - Field: ‘state’
[13:22:29.305] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:22:29.307] - Launch lazy future ...
[13:22:29.307] Packages needed by the future expression (n = 0): <none>
[13:22:29.307] Packages needed by future strategies (n = 0): <none>
[13:22:29.308] {
[13:22:29.308]     {
[13:22:29.308]         {
[13:22:29.308]             ...future.startTime <- base::Sys.time()
[13:22:29.308]             {
[13:22:29.308]                 {
[13:22:29.308]                   {
[13:22:29.308]                     base::local({
[13:22:29.308]                       has_future <- base::requireNamespace("future", 
[13:22:29.308]                         quietly = TRUE)
[13:22:29.308]                       if (has_future) {
[13:22:29.308]                         ns <- base::getNamespace("future")
[13:22:29.308]                         version <- ns[[".package"]][["version"]]
[13:22:29.308]                         if (is.null(version)) 
[13:22:29.308]                           version <- utils::packageVersion("future")
[13:22:29.308]                       }
[13:22:29.308]                       else {
[13:22:29.308]                         version <- NULL
[13:22:29.308]                       }
[13:22:29.308]                       if (!has_future || version < "1.8.0") {
[13:22:29.308]                         info <- base::c(r_version = base::gsub("R version ", 
[13:22:29.308]                           "", base::R.version$version.string), 
[13:22:29.308]                           platform = base::sprintf("%s (%s-bit)", 
[13:22:29.308]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:29.308]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:29.308]                             "release", "version")], collapse = " "), 
[13:22:29.308]                           hostname = base::Sys.info()[["nodename"]])
[13:22:29.308]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:22:29.308]                           info)
[13:22:29.308]                         info <- base::paste(info, collapse = "; ")
[13:22:29.308]                         if (!has_future) {
[13:22:29.308]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:29.308]                             info)
[13:22:29.308]                         }
[13:22:29.308]                         else {
[13:22:29.308]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:29.308]                             info, version)
[13:22:29.308]                         }
[13:22:29.308]                         base::stop(msg)
[13:22:29.308]                       }
[13:22:29.308]                     })
[13:22:29.308]                   }
[13:22:29.308]                   options(future.plan = NULL)
[13:22:29.308]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:29.308]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:29.308]                 }
[13:22:29.308]                 ...future.workdir <- getwd()
[13:22:29.308]             }
[13:22:29.308]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:29.308]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:29.308]         }
[13:22:29.308]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:29.308]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:29.308]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:29.308]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:29.308]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:29.308]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:29.308]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:29.308]             base::names(...future.oldOptions))
[13:22:29.308]     }
[13:22:29.308]     if (FALSE) {
[13:22:29.308]     }
[13:22:29.308]     else {
[13:22:29.308]         if (TRUE) {
[13:22:29.308]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:29.308]                 open = "w")
[13:22:29.308]         }
[13:22:29.308]         else {
[13:22:29.308]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:29.308]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:29.308]         }
[13:22:29.308]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:29.308]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:29.308]             base::sink(type = "output", split = FALSE)
[13:22:29.308]             base::close(...future.stdout)
[13:22:29.308]         }, add = TRUE)
[13:22:29.308]     }
[13:22:29.308]     ...future.frame <- base::sys.nframe()
[13:22:29.308]     ...future.conditions <- base::list()
[13:22:29.308]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:29.308]     if (FALSE) {
[13:22:29.308]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:29.308]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:29.308]     }
[13:22:29.308]     ...future.result <- base::tryCatch({
[13:22:29.308]         base::withCallingHandlers({
[13:22:29.308]             ...future.value <- base::withVisible(base::local(print(42)))
[13:22:29.308]             future::FutureResult(value = ...future.value$value, 
[13:22:29.308]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:29.308]                   ...future.rng), globalenv = if (FALSE) 
[13:22:29.308]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:29.308]                     ...future.globalenv.names))
[13:22:29.308]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:29.308]         }, condition = base::local({
[13:22:29.308]             c <- base::c
[13:22:29.308]             inherits <- base::inherits
[13:22:29.308]             invokeRestart <- base::invokeRestart
[13:22:29.308]             length <- base::length
[13:22:29.308]             list <- base::list
[13:22:29.308]             seq.int <- base::seq.int
[13:22:29.308]             signalCondition <- base::signalCondition
[13:22:29.308]             sys.calls <- base::sys.calls
[13:22:29.308]             `[[` <- base::`[[`
[13:22:29.308]             `+` <- base::`+`
[13:22:29.308]             `<<-` <- base::`<<-`
[13:22:29.308]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:29.308]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:29.308]                   3L)]
[13:22:29.308]             }
[13:22:29.308]             function(cond) {
[13:22:29.308]                 is_error <- inherits(cond, "error")
[13:22:29.308]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:29.308]                   NULL)
[13:22:29.308]                 if (is_error) {
[13:22:29.308]                   sessionInformation <- function() {
[13:22:29.308]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:29.308]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:29.308]                       search = base::search(), system = base::Sys.info())
[13:22:29.308]                   }
[13:22:29.308]                   ...future.conditions[[length(...future.conditions) + 
[13:22:29.308]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:29.308]                     cond$call), session = sessionInformation(), 
[13:22:29.308]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:29.308]                   signalCondition(cond)
[13:22:29.308]                 }
[13:22:29.308]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:29.308]                 "immediateCondition"))) {
[13:22:29.308]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:29.308]                   ...future.conditions[[length(...future.conditions) + 
[13:22:29.308]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:29.308]                   if (TRUE && !signal) {
[13:22:29.308]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.308]                     {
[13:22:29.308]                       inherits <- base::inherits
[13:22:29.308]                       invokeRestart <- base::invokeRestart
[13:22:29.308]                       is.null <- base::is.null
[13:22:29.308]                       muffled <- FALSE
[13:22:29.308]                       if (inherits(cond, "message")) {
[13:22:29.308]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:29.308]                         if (muffled) 
[13:22:29.308]                           invokeRestart("muffleMessage")
[13:22:29.308]                       }
[13:22:29.308]                       else if (inherits(cond, "warning")) {
[13:22:29.308]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:29.308]                         if (muffled) 
[13:22:29.308]                           invokeRestart("muffleWarning")
[13:22:29.308]                       }
[13:22:29.308]                       else if (inherits(cond, "condition")) {
[13:22:29.308]                         if (!is.null(pattern)) {
[13:22:29.308]                           computeRestarts <- base::computeRestarts
[13:22:29.308]                           grepl <- base::grepl
[13:22:29.308]                           restarts <- computeRestarts(cond)
[13:22:29.308]                           for (restart in restarts) {
[13:22:29.308]                             name <- restart$name
[13:22:29.308]                             if (is.null(name)) 
[13:22:29.308]                               next
[13:22:29.308]                             if (!grepl(pattern, name)) 
[13:22:29.308]                               next
[13:22:29.308]                             invokeRestart(restart)
[13:22:29.308]                             muffled <- TRUE
[13:22:29.308]                             break
[13:22:29.308]                           }
[13:22:29.308]                         }
[13:22:29.308]                       }
[13:22:29.308]                       invisible(muffled)
[13:22:29.308]                     }
[13:22:29.308]                     muffleCondition(cond, pattern = "^muffle")
[13:22:29.308]                   }
[13:22:29.308]                 }
[13:22:29.308]                 else {
[13:22:29.308]                   if (TRUE) {
[13:22:29.308]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.308]                     {
[13:22:29.308]                       inherits <- base::inherits
[13:22:29.308]                       invokeRestart <- base::invokeRestart
[13:22:29.308]                       is.null <- base::is.null
[13:22:29.308]                       muffled <- FALSE
[13:22:29.308]                       if (inherits(cond, "message")) {
[13:22:29.308]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:29.308]                         if (muffled) 
[13:22:29.308]                           invokeRestart("muffleMessage")
[13:22:29.308]                       }
[13:22:29.308]                       else if (inherits(cond, "warning")) {
[13:22:29.308]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:29.308]                         if (muffled) 
[13:22:29.308]                           invokeRestart("muffleWarning")
[13:22:29.308]                       }
[13:22:29.308]                       else if (inherits(cond, "condition")) {
[13:22:29.308]                         if (!is.null(pattern)) {
[13:22:29.308]                           computeRestarts <- base::computeRestarts
[13:22:29.308]                           grepl <- base::grepl
[13:22:29.308]                           restarts <- computeRestarts(cond)
[13:22:29.308]                           for (restart in restarts) {
[13:22:29.308]                             name <- restart$name
[13:22:29.308]                             if (is.null(name)) 
[13:22:29.308]                               next
[13:22:29.308]                             if (!grepl(pattern, name)) 
[13:22:29.308]                               next
[13:22:29.308]                             invokeRestart(restart)
[13:22:29.308]                             muffled <- TRUE
[13:22:29.308]                             break
[13:22:29.308]                           }
[13:22:29.308]                         }
[13:22:29.308]                       }
[13:22:29.308]                       invisible(muffled)
[13:22:29.308]                     }
[13:22:29.308]                     muffleCondition(cond, pattern = "^muffle")
[13:22:29.308]                   }
[13:22:29.308]                 }
[13:22:29.308]             }
[13:22:29.308]         }))
[13:22:29.308]     }, error = function(ex) {
[13:22:29.308]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:29.308]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:29.308]                 ...future.rng), started = ...future.startTime, 
[13:22:29.308]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:29.308]             version = "1.8"), class = "FutureResult")
[13:22:29.308]     }, finally = {
[13:22:29.308]         if (!identical(...future.workdir, getwd())) 
[13:22:29.308]             setwd(...future.workdir)
[13:22:29.308]         {
[13:22:29.308]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:29.308]                 ...future.oldOptions$nwarnings <- NULL
[13:22:29.308]             }
[13:22:29.308]             base::options(...future.oldOptions)
[13:22:29.308]             if (.Platform$OS.type == "windows") {
[13:22:29.308]                 old_names <- names(...future.oldEnvVars)
[13:22:29.308]                 envs <- base::Sys.getenv()
[13:22:29.308]                 names <- names(envs)
[13:22:29.308]                 common <- intersect(names, old_names)
[13:22:29.308]                 added <- setdiff(names, old_names)
[13:22:29.308]                 removed <- setdiff(old_names, names)
[13:22:29.308]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:29.308]                   envs[common]]
[13:22:29.308]                 NAMES <- toupper(changed)
[13:22:29.308]                 args <- list()
[13:22:29.308]                 for (kk in seq_along(NAMES)) {
[13:22:29.308]                   name <- changed[[kk]]
[13:22:29.308]                   NAME <- NAMES[[kk]]
[13:22:29.308]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.308]                     next
[13:22:29.308]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:29.308]                 }
[13:22:29.308]                 NAMES <- toupper(added)
[13:22:29.308]                 for (kk in seq_along(NAMES)) {
[13:22:29.308]                   name <- added[[kk]]
[13:22:29.308]                   NAME <- NAMES[[kk]]
[13:22:29.308]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.308]                     next
[13:22:29.308]                   args[[name]] <- ""
[13:22:29.308]                 }
[13:22:29.308]                 NAMES <- toupper(removed)
[13:22:29.308]                 for (kk in seq_along(NAMES)) {
[13:22:29.308]                   name <- removed[[kk]]
[13:22:29.308]                   NAME <- NAMES[[kk]]
[13:22:29.308]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.308]                     next
[13:22:29.308]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:29.308]                 }
[13:22:29.308]                 if (length(args) > 0) 
[13:22:29.308]                   base::do.call(base::Sys.setenv, args = args)
[13:22:29.308]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:29.308]             }
[13:22:29.308]             else {
[13:22:29.308]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:29.308]             }
[13:22:29.308]             {
[13:22:29.308]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:29.308]                   0L) {
[13:22:29.308]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:29.308]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:29.308]                   base::options(opts)
[13:22:29.308]                 }
[13:22:29.308]                 {
[13:22:29.308]                   {
[13:22:29.308]                     NULL
[13:22:29.308]                     RNGkind("Mersenne-Twister")
[13:22:29.308]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:22:29.308]                       inherits = FALSE)
[13:22:29.308]                   }
[13:22:29.308]                   options(future.plan = NULL)
[13:22:29.308]                   if (is.na(NA_character_)) 
[13:22:29.308]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:29.308]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:29.308]                   future::plan(list(function (..., envir = parent.frame()) 
[13:22:29.308]                   {
[13:22:29.308]                     future <- SequentialFuture(..., envir = envir)
[13:22:29.308]                     if (!future$lazy) 
[13:22:29.308]                       future <- run(future)
[13:22:29.308]                     invisible(future)
[13:22:29.308]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:29.308]                 }
[13:22:29.308]             }
[13:22:29.308]         }
[13:22:29.308]     })
[13:22:29.308]     if (TRUE) {
[13:22:29.308]         base::sink(type = "output", split = FALSE)
[13:22:29.308]         if (TRUE) {
[13:22:29.308]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:29.308]         }
[13:22:29.308]         else {
[13:22:29.308]             ...future.result["stdout"] <- base::list(NULL)
[13:22:29.308]         }
[13:22:29.308]         base::close(...future.stdout)
[13:22:29.308]         ...future.stdout <- NULL
[13:22:29.308]     }
[13:22:29.308]     ...future.result$conditions <- ...future.conditions
[13:22:29.308]     ...future.result$finished <- base::Sys.time()
[13:22:29.308]     ...future.result
[13:22:29.308] }
[13:22:29.310] plan(): Setting new future strategy stack:
[13:22:29.310] List of future strategies:
[13:22:29.310] 1. sequential:
[13:22:29.310]    - args: function (..., envir = parent.frame())
[13:22:29.310]    - tweaked: FALSE
[13:22:29.310]    - call: NULL
[13:22:29.310] plan(): nbrOfWorkers() = 1
[13:22:29.311] plan(): Setting new future strategy stack:
[13:22:29.311] List of future strategies:
[13:22:29.311] 1. sequential:
[13:22:29.311]    - args: function (..., envir = parent.frame())
[13:22:29.311]    - tweaked: FALSE
[13:22:29.311]    - call: plan(strategy)
[13:22:29.311] plan(): nbrOfWorkers() = 1
[13:22:29.311] SequentialFuture started (and completed)
[13:22:29.312] - Launch lazy future ... done
[13:22:29.312] run() for ‘SequentialFuture’ ... done
[1] 42
sequential ... done
Testing with 1 cores ... done
Testing with 2 cores ...
multicore ...
[13:22:29.318] plan(): Setting new future strategy stack:
[13:22:29.318] List of future strategies:
[13:22:29.318] 1. multicore:
[13:22:29.318]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:22:29.318]    - tweaked: FALSE
[13:22:29.318]    - call: plan(strategy)
[13:22:29.322] plan(): nbrOfWorkers() = 2
- stdout = TRUE
[13:22:29.322] getGlobalsAndPackages() ...
[13:22:29.322] Searching for globals...
[13:22:29.325] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[13:22:29.325] Searching for globals ... DONE
[13:22:29.325] Resolving globals: FALSE
[13:22:29.326] 
[13:22:29.326] - packages: [1] ‘utils’
[13:22:29.326] getGlobalsAndPackages() ... DONE
[13:22:29.326] run() for ‘Future’ ...
[13:22:29.326] - state: ‘created’
[13:22:29.326] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:22:29.330] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:29.330] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:22:29.330]   - Field: ‘label’
[13:22:29.330]   - Field: ‘local’
[13:22:29.330]   - Field: ‘owner’
[13:22:29.330]   - Field: ‘envir’
[13:22:29.330]   - Field: ‘workers’
[13:22:29.330]   - Field: ‘packages’
[13:22:29.331]   - Field: ‘gc’
[13:22:29.331]   - Field: ‘job’
[13:22:29.331]   - Field: ‘conditions’
[13:22:29.331]   - Field: ‘expr’
[13:22:29.331]   - Field: ‘uuid’
[13:22:29.331]   - Field: ‘seed’
[13:22:29.331]   - Field: ‘version’
[13:22:29.331]   - Field: ‘result’
[13:22:29.331]   - Field: ‘asynchronous’
[13:22:29.331]   - Field: ‘calls’
[13:22:29.331]   - Field: ‘globals’
[13:22:29.332]   - Field: ‘stdout’
[13:22:29.332]   - Field: ‘earlySignal’
[13:22:29.332]   - Field: ‘lazy’
[13:22:29.332]   - Field: ‘state’
[13:22:29.332] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:22:29.332] - Launch lazy future ...
[13:22:29.333] Packages needed by the future expression (n = 1): ‘utils’
[13:22:29.333] Packages needed by future strategies (n = 0): <none>
[13:22:29.334] {
[13:22:29.334]     {
[13:22:29.334]         {
[13:22:29.334]             ...future.startTime <- base::Sys.time()
[13:22:29.334]             {
[13:22:29.334]                 {
[13:22:29.334]                   {
[13:22:29.334]                     {
[13:22:29.334]                       {
[13:22:29.334]                         base::local({
[13:22:29.334]                           has_future <- base::requireNamespace("future", 
[13:22:29.334]                             quietly = TRUE)
[13:22:29.334]                           if (has_future) {
[13:22:29.334]                             ns <- base::getNamespace("future")
[13:22:29.334]                             version <- ns[[".package"]][["version"]]
[13:22:29.334]                             if (is.null(version)) 
[13:22:29.334]                               version <- utils::packageVersion("future")
[13:22:29.334]                           }
[13:22:29.334]                           else {
[13:22:29.334]                             version <- NULL
[13:22:29.334]                           }
[13:22:29.334]                           if (!has_future || version < "1.8.0") {
[13:22:29.334]                             info <- base::c(r_version = base::gsub("R version ", 
[13:22:29.334]                               "", base::R.version$version.string), 
[13:22:29.334]                               platform = base::sprintf("%s (%s-bit)", 
[13:22:29.334]                                 base::R.version$platform, 8 * 
[13:22:29.334]                                   base::.Machine$sizeof.pointer), 
[13:22:29.334]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:29.334]                                 "release", "version")], collapse = " "), 
[13:22:29.334]                               hostname = base::Sys.info()[["nodename"]])
[13:22:29.334]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:22:29.334]                               info)
[13:22:29.334]                             info <- base::paste(info, collapse = "; ")
[13:22:29.334]                             if (!has_future) {
[13:22:29.334]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:29.334]                                 info)
[13:22:29.334]                             }
[13:22:29.334]                             else {
[13:22:29.334]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:29.334]                                 info, version)
[13:22:29.334]                             }
[13:22:29.334]                             base::stop(msg)
[13:22:29.334]                           }
[13:22:29.334]                         })
[13:22:29.334]                       }
[13:22:29.334]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:29.334]                       base::options(mc.cores = 1L)
[13:22:29.334]                     }
[13:22:29.334]                     base::local({
[13:22:29.334]                       for (pkg in "utils") {
[13:22:29.334]                         base::loadNamespace(pkg)
[13:22:29.334]                         base::library(pkg, character.only = TRUE)
[13:22:29.334]                       }
[13:22:29.334]                     })
[13:22:29.334]                   }
[13:22:29.334]                   options(future.plan = NULL)
[13:22:29.334]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:29.334]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:29.334]                 }
[13:22:29.334]                 ...future.workdir <- getwd()
[13:22:29.334]             }
[13:22:29.334]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:29.334]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:29.334]         }
[13:22:29.334]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:29.334]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:29.334]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:29.334]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:29.334]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:29.334]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:29.334]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:29.334]             base::names(...future.oldOptions))
[13:22:29.334]     }
[13:22:29.334]     if (FALSE) {
[13:22:29.334]     }
[13:22:29.334]     else {
[13:22:29.334]         if (TRUE) {
[13:22:29.334]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:29.334]                 open = "w")
[13:22:29.334]         }
[13:22:29.334]         else {
[13:22:29.334]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:29.334]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:29.334]         }
[13:22:29.334]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:29.334]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:29.334]             base::sink(type = "output", split = FALSE)
[13:22:29.334]             base::close(...future.stdout)
[13:22:29.334]         }, add = TRUE)
[13:22:29.334]     }
[13:22:29.334]     ...future.frame <- base::sys.nframe()
[13:22:29.334]     ...future.conditions <- base::list()
[13:22:29.334]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:29.334]     if (FALSE) {
[13:22:29.334]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:29.334]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:29.334]     }
[13:22:29.334]     ...future.result <- base::tryCatch({
[13:22:29.334]         base::withCallingHandlers({
[13:22:29.334]             ...future.value <- base::withVisible(base::local({
[13:22:29.334]                 withCallingHandlers({
[13:22:29.334]                   {
[13:22:29.334]                     print(1:50)
[13:22:29.334]                     str(1:50)
[13:22:29.334]                     cat(letters, sep = "-")
[13:22:29.334]                     cat(1:6, collapse = "\n")
[13:22:29.334]                     write.table(datasets::iris[1:10, ], sep = "\t")
[13:22:29.334]                     42L
[13:22:29.334]                   }
[13:22:29.334]                 }, immediateCondition = function(cond) {
[13:22:29.334]                   save_rds <- function (object, pathname, ...) 
[13:22:29.334]                   {
[13:22:29.334]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:22:29.334]                     if (file_test("-f", pathname_tmp)) {
[13:22:29.334]                       fi_tmp <- file.info(pathname_tmp)
[13:22:29.334]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:22:29.334]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:29.334]                         fi_tmp[["mtime"]])
[13:22:29.334]                     }
[13:22:29.334]                     tryCatch({
[13:22:29.334]                       saveRDS(object, file = pathname_tmp, ...)
[13:22:29.334]                     }, error = function(ex) {
[13:22:29.334]                       msg <- conditionMessage(ex)
[13:22:29.334]                       fi_tmp <- file.info(pathname_tmp)
[13:22:29.334]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:22:29.334]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:29.334]                         fi_tmp[["mtime"]], msg)
[13:22:29.334]                       ex$message <- msg
[13:22:29.334]                       stop(ex)
[13:22:29.334]                     })
[13:22:29.334]                     stopifnot(file_test("-f", pathname_tmp))
[13:22:29.334]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:22:29.334]                     if (!res || file_test("-f", pathname_tmp)) {
[13:22:29.334]                       fi_tmp <- file.info(pathname_tmp)
[13:22:29.334]                       fi <- file.info(pathname)
[13:22:29.334]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:22:29.334]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:29.334]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:22:29.334]                         fi[["size"]], fi[["mtime"]])
[13:22:29.334]                       stop(msg)
[13:22:29.334]                     }
[13:22:29.334]                     invisible(pathname)
[13:22:29.334]                   }
[13:22:29.334]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:22:29.334]                     rootPath = tempdir()) 
[13:22:29.334]                   {
[13:22:29.334]                     obj <- list(time = Sys.time(), condition = cond)
[13:22:29.334]                     file <- tempfile(pattern = class(cond)[1], 
[13:22:29.334]                       tmpdir = path, fileext = ".rds")
[13:22:29.334]                     save_rds(obj, file)
[13:22:29.334]                   }
[13:22:29.334]                   saveImmediateCondition(cond, path = "/tmp/RtmpeTCoqm/.future/immediateConditions")
[13:22:29.334]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.334]                   {
[13:22:29.334]                     inherits <- base::inherits
[13:22:29.334]                     invokeRestart <- base::invokeRestart
[13:22:29.334]                     is.null <- base::is.null
[13:22:29.334]                     muffled <- FALSE
[13:22:29.334]                     if (inherits(cond, "message")) {
[13:22:29.334]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:29.334]                       if (muffled) 
[13:22:29.334]                         invokeRestart("muffleMessage")
[13:22:29.334]                     }
[13:22:29.334]                     else if (inherits(cond, "warning")) {
[13:22:29.334]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:29.334]                       if (muffled) 
[13:22:29.334]                         invokeRestart("muffleWarning")
[13:22:29.334]                     }
[13:22:29.334]                     else if (inherits(cond, "condition")) {
[13:22:29.334]                       if (!is.null(pattern)) {
[13:22:29.334]                         computeRestarts <- base::computeRestarts
[13:22:29.334]                         grepl <- base::grepl
[13:22:29.334]                         restarts <- computeRestarts(cond)
[13:22:29.334]                         for (restart in restarts) {
[13:22:29.334]                           name <- restart$name
[13:22:29.334]                           if (is.null(name)) 
[13:22:29.334]                             next
[13:22:29.334]                           if (!grepl(pattern, name)) 
[13:22:29.334]                             next
[13:22:29.334]                           invokeRestart(restart)
[13:22:29.334]                           muffled <- TRUE
[13:22:29.334]                           break
[13:22:29.334]                         }
[13:22:29.334]                       }
[13:22:29.334]                     }
[13:22:29.334]                     invisible(muffled)
[13:22:29.334]                   }
[13:22:29.334]                   muffleCondition(cond)
[13:22:29.334]                 })
[13:22:29.334]             }))
[13:22:29.334]             future::FutureResult(value = ...future.value$value, 
[13:22:29.334]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:29.334]                   ...future.rng), globalenv = if (FALSE) 
[13:22:29.334]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:29.334]                     ...future.globalenv.names))
[13:22:29.334]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:29.334]         }, condition = base::local({
[13:22:29.334]             c <- base::c
[13:22:29.334]             inherits <- base::inherits
[13:22:29.334]             invokeRestart <- base::invokeRestart
[13:22:29.334]             length <- base::length
[13:22:29.334]             list <- base::list
[13:22:29.334]             seq.int <- base::seq.int
[13:22:29.334]             signalCondition <- base::signalCondition
[13:22:29.334]             sys.calls <- base::sys.calls
[13:22:29.334]             `[[` <- base::`[[`
[13:22:29.334]             `+` <- base::`+`
[13:22:29.334]             `<<-` <- base::`<<-`
[13:22:29.334]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:29.334]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:29.334]                   3L)]
[13:22:29.334]             }
[13:22:29.334]             function(cond) {
[13:22:29.334]                 is_error <- inherits(cond, "error")
[13:22:29.334]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:29.334]                   NULL)
[13:22:29.334]                 if (is_error) {
[13:22:29.334]                   sessionInformation <- function() {
[13:22:29.334]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:29.334]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:29.334]                       search = base::search(), system = base::Sys.info())
[13:22:29.334]                   }
[13:22:29.334]                   ...future.conditions[[length(...future.conditions) + 
[13:22:29.334]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:29.334]                     cond$call), session = sessionInformation(), 
[13:22:29.334]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:29.334]                   signalCondition(cond)
[13:22:29.334]                 }
[13:22:29.334]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:29.334]                 "immediateCondition"))) {
[13:22:29.334]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:29.334]                   ...future.conditions[[length(...future.conditions) + 
[13:22:29.334]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:29.334]                   if (TRUE && !signal) {
[13:22:29.334]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.334]                     {
[13:22:29.334]                       inherits <- base::inherits
[13:22:29.334]                       invokeRestart <- base::invokeRestart
[13:22:29.334]                       is.null <- base::is.null
[13:22:29.334]                       muffled <- FALSE
[13:22:29.334]                       if (inherits(cond, "message")) {
[13:22:29.334]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:29.334]                         if (muffled) 
[13:22:29.334]                           invokeRestart("muffleMessage")
[13:22:29.334]                       }
[13:22:29.334]                       else if (inherits(cond, "warning")) {
[13:22:29.334]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:29.334]                         if (muffled) 
[13:22:29.334]                           invokeRestart("muffleWarning")
[13:22:29.334]                       }
[13:22:29.334]                       else if (inherits(cond, "condition")) {
[13:22:29.334]                         if (!is.null(pattern)) {
[13:22:29.334]                           computeRestarts <- base::computeRestarts
[13:22:29.334]                           grepl <- base::grepl
[13:22:29.334]                           restarts <- computeRestarts(cond)
[13:22:29.334]                           for (restart in restarts) {
[13:22:29.334]                             name <- restart$name
[13:22:29.334]                             if (is.null(name)) 
[13:22:29.334]                               next
[13:22:29.334]                             if (!grepl(pattern, name)) 
[13:22:29.334]                               next
[13:22:29.334]                             invokeRestart(restart)
[13:22:29.334]                             muffled <- TRUE
[13:22:29.334]                             break
[13:22:29.334]                           }
[13:22:29.334]                         }
[13:22:29.334]                       }
[13:22:29.334]                       invisible(muffled)
[13:22:29.334]                     }
[13:22:29.334]                     muffleCondition(cond, pattern = "^muffle")
[13:22:29.334]                   }
[13:22:29.334]                 }
[13:22:29.334]                 else {
[13:22:29.334]                   if (TRUE) {
[13:22:29.334]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.334]                     {
[13:22:29.334]                       inherits <- base::inherits
[13:22:29.334]                       invokeRestart <- base::invokeRestart
[13:22:29.334]                       is.null <- base::is.null
[13:22:29.334]                       muffled <- FALSE
[13:22:29.334]                       if (inherits(cond, "message")) {
[13:22:29.334]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:29.334]                         if (muffled) 
[13:22:29.334]                           invokeRestart("muffleMessage")
[13:22:29.334]                       }
[13:22:29.334]                       else if (inherits(cond, "warning")) {
[13:22:29.334]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:29.334]                         if (muffled) 
[13:22:29.334]                           invokeRestart("muffleWarning")
[13:22:29.334]                       }
[13:22:29.334]                       else if (inherits(cond, "condition")) {
[13:22:29.334]                         if (!is.null(pattern)) {
[13:22:29.334]                           computeRestarts <- base::computeRestarts
[13:22:29.334]                           grepl <- base::grepl
[13:22:29.334]                           restarts <- computeRestarts(cond)
[13:22:29.334]                           for (restart in restarts) {
[13:22:29.334]                             name <- restart$name
[13:22:29.334]                             if (is.null(name)) 
[13:22:29.334]                               next
[13:22:29.334]                             if (!grepl(pattern, name)) 
[13:22:29.334]                               next
[13:22:29.334]                             invokeRestart(restart)
[13:22:29.334]                             muffled <- TRUE
[13:22:29.334]                             break
[13:22:29.334]                           }
[13:22:29.334]                         }
[13:22:29.334]                       }
[13:22:29.334]                       invisible(muffled)
[13:22:29.334]                     }
[13:22:29.334]                     muffleCondition(cond, pattern = "^muffle")
[13:22:29.334]                   }
[13:22:29.334]                 }
[13:22:29.334]             }
[13:22:29.334]         }))
[13:22:29.334]     }, error = function(ex) {
[13:22:29.334]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:29.334]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:29.334]                 ...future.rng), started = ...future.startTime, 
[13:22:29.334]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:29.334]             version = "1.8"), class = "FutureResult")
[13:22:29.334]     }, finally = {
[13:22:29.334]         if (!identical(...future.workdir, getwd())) 
[13:22:29.334]             setwd(...future.workdir)
[13:22:29.334]         {
[13:22:29.334]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:29.334]                 ...future.oldOptions$nwarnings <- NULL
[13:22:29.334]             }
[13:22:29.334]             base::options(...future.oldOptions)
[13:22:29.334]             if (.Platform$OS.type == "windows") {
[13:22:29.334]                 old_names <- names(...future.oldEnvVars)
[13:22:29.334]                 envs <- base::Sys.getenv()
[13:22:29.334]                 names <- names(envs)
[13:22:29.334]                 common <- intersect(names, old_names)
[13:22:29.334]                 added <- setdiff(names, old_names)
[13:22:29.334]                 removed <- setdiff(old_names, names)
[13:22:29.334]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:29.334]                   envs[common]]
[13:22:29.334]                 NAMES <- toupper(changed)
[13:22:29.334]                 args <- list()
[13:22:29.334]                 for (kk in seq_along(NAMES)) {
[13:22:29.334]                   name <- changed[[kk]]
[13:22:29.334]                   NAME <- NAMES[[kk]]
[13:22:29.334]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.334]                     next
[13:22:29.334]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:29.334]                 }
[13:22:29.334]                 NAMES <- toupper(added)
[13:22:29.334]                 for (kk in seq_along(NAMES)) {
[13:22:29.334]                   name <- added[[kk]]
[13:22:29.334]                   NAME <- NAMES[[kk]]
[13:22:29.334]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.334]                     next
[13:22:29.334]                   args[[name]] <- ""
[13:22:29.334]                 }
[13:22:29.334]                 NAMES <- toupper(removed)
[13:22:29.334]                 for (kk in seq_along(NAMES)) {
[13:22:29.334]                   name <- removed[[kk]]
[13:22:29.334]                   NAME <- NAMES[[kk]]
[13:22:29.334]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.334]                     next
[13:22:29.334]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:29.334]                 }
[13:22:29.334]                 if (length(args) > 0) 
[13:22:29.334]                   base::do.call(base::Sys.setenv, args = args)
[13:22:29.334]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:29.334]             }
[13:22:29.334]             else {
[13:22:29.334]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:29.334]             }
[13:22:29.334]             {
[13:22:29.334]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:29.334]                   0L) {
[13:22:29.334]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:29.334]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:29.334]                   base::options(opts)
[13:22:29.334]                 }
[13:22:29.334]                 {
[13:22:29.334]                   {
[13:22:29.334]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:29.334]                     NULL
[13:22:29.334]                   }
[13:22:29.334]                   options(future.plan = NULL)
[13:22:29.334]                   if (is.na(NA_character_)) 
[13:22:29.334]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:29.334]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:29.334]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:22:29.334]                     envir = parent.frame()) 
[13:22:29.334]                   {
[13:22:29.334]                     default_workers <- missing(workers)
[13:22:29.334]                     if (is.function(workers)) 
[13:22:29.334]                       workers <- workers()
[13:22:29.334]                     workers <- structure(as.integer(workers), 
[13:22:29.334]                       class = class(workers))
[13:22:29.334]                     stop_if_not(is.finite(workers), workers >= 
[13:22:29.334]                       1L)
[13:22:29.334]                     if ((workers == 1L && !inherits(workers, 
[13:22:29.334]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:22:29.334]                       if (default_workers) 
[13:22:29.334]                         supportsMulticore(warn = TRUE)
[13:22:29.334]                       return(sequential(..., envir = envir))
[13:22:29.334]                     }
[13:22:29.334]                     oopts <- options(mc.cores = workers)
[13:22:29.334]                     on.exit(options(oopts))
[13:22:29.334]                     future <- MulticoreFuture(..., workers = workers, 
[13:22:29.334]                       envir = envir)
[13:22:29.334]                     if (!future$lazy) 
[13:22:29.334]                       future <- run(future)
[13:22:29.334]                     invisible(future)
[13:22:29.334]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:29.334]                 }
[13:22:29.334]             }
[13:22:29.334]         }
[13:22:29.334]     })
[13:22:29.334]     if (TRUE) {
[13:22:29.334]         base::sink(type = "output", split = FALSE)
[13:22:29.334]         if (TRUE) {
[13:22:29.334]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:29.334]         }
[13:22:29.334]         else {
[13:22:29.334]             ...future.result["stdout"] <- base::list(NULL)
[13:22:29.334]         }
[13:22:29.334]         base::close(...future.stdout)
[13:22:29.334]         ...future.stdout <- NULL
[13:22:29.334]     }
[13:22:29.334]     ...future.result$conditions <- ...future.conditions
[13:22:29.334]     ...future.result$finished <- base::Sys.time()
[13:22:29.334]     ...future.result
[13:22:29.334] }
[13:22:29.336] requestCore(): workers = 2
[13:22:29.339] MulticoreFuture started
[13:22:29.339] - Launch lazy future ... done
[13:22:29.340] run() for ‘MulticoreFuture’ ... done
[13:22:29.340] plan(): Setting new future strategy stack:
[13:22:29.340] List of future strategies:
[13:22:29.340] 1. sequential:
[13:22:29.340]    - args: function (..., envir = parent.frame())
[13:22:29.340]    - tweaked: FALSE
[13:22:29.340]    - call: NULL
[13:22:29.346] plan(): nbrOfWorkers() = 1
[13:22:29.350] plan(): Setting new future strategy stack:
[13:22:29.350] List of future strategies:
[13:22:29.350] 1. multicore:
[13:22:29.350]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:22:29.350]    - tweaked: FALSE
[13:22:29.350]    - call: plan(strategy)
[13:22:29.356] plan(): nbrOfWorkers() = 2
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : chr " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 3"| __truncated__
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-01-07 13:22:29"
 $ finished    : POSIXct[1:1], format: "2025-01-07 13:22:29"
 $ session_uuid: chr "f53f16f5-6959-c66a-a49a-c96c9a14a617"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "5853cd8d1af0"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "5853cd8d1af0" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 93450
  .. ..$ time  : POSIXct[1:1], format: "2025-01-07 13:22:29"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 3 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
FutureResult:
value: ‘integer’
visible: TRUE
stdout: character
conditions: [n = 0] 
RNG used: FALSE
duration: 0.01670194 secs (started 2025-01-07 13:22:29.339663)
version: 1.8
[13:22:29.371] getGlobalsAndPackages() ...
[13:22:29.371] Searching for globals...
[13:22:29.375] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[13:22:29.375] Searching for globals ... DONE
[13:22:29.375] Resolving globals: FALSE
[13:22:29.376] 
[13:22:29.376] - packages: [1] ‘utils’
[13:22:29.376] getGlobalsAndPackages() ... DONE
[13:22:29.376] run() for ‘Future’ ...
[13:22:29.376] - state: ‘created’
[13:22:29.377] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:22:29.381] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:29.381] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:22:29.381]   - Field: ‘label’
[13:22:29.381]   - Field: ‘local’
[13:22:29.381]   - Field: ‘owner’
[13:22:29.381]   - Field: ‘envir’
[13:22:29.381]   - Field: ‘workers’
[13:22:29.382]   - Field: ‘packages’
[13:22:29.382]   - Field: ‘gc’
[13:22:29.382]   - Field: ‘job’
[13:22:29.382]   - Field: ‘conditions’
[13:22:29.382]   - Field: ‘expr’
[13:22:29.382]   - Field: ‘uuid’
[13:22:29.382]   - Field: ‘seed’
[13:22:29.382]   - Field: ‘version’
[13:22:29.382]   - Field: ‘result’
[13:22:29.383]   - Field: ‘asynchronous’
[13:22:29.383]   - Field: ‘calls’
[13:22:29.383]   - Field: ‘globals’
[13:22:29.383]   - Field: ‘stdout’
[13:22:29.383]   - Field: ‘earlySignal’
[13:22:29.383]   - Field: ‘lazy’
[13:22:29.383]   - Field: ‘state’
[13:22:29.383] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:22:29.383] - Launch lazy future ...
[13:22:29.384] Packages needed by the future expression (n = 1): ‘utils’
[13:22:29.384] Packages needed by future strategies (n = 0): <none>
[13:22:29.384] {
[13:22:29.384]     {
[13:22:29.384]         {
[13:22:29.384]             ...future.startTime <- base::Sys.time()
[13:22:29.384]             {
[13:22:29.384]                 {
[13:22:29.384]                   {
[13:22:29.384]                     {
[13:22:29.384]                       {
[13:22:29.384]                         base::local({
[13:22:29.384]                           has_future <- base::requireNamespace("future", 
[13:22:29.384]                             quietly = TRUE)
[13:22:29.384]                           if (has_future) {
[13:22:29.384]                             ns <- base::getNamespace("future")
[13:22:29.384]                             version <- ns[[".package"]][["version"]]
[13:22:29.384]                             if (is.null(version)) 
[13:22:29.384]                               version <- utils::packageVersion("future")
[13:22:29.384]                           }
[13:22:29.384]                           else {
[13:22:29.384]                             version <- NULL
[13:22:29.384]                           }
[13:22:29.384]                           if (!has_future || version < "1.8.0") {
[13:22:29.384]                             info <- base::c(r_version = base::gsub("R version ", 
[13:22:29.384]                               "", base::R.version$version.string), 
[13:22:29.384]                               platform = base::sprintf("%s (%s-bit)", 
[13:22:29.384]                                 base::R.version$platform, 8 * 
[13:22:29.384]                                   base::.Machine$sizeof.pointer), 
[13:22:29.384]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:29.384]                                 "release", "version")], collapse = " "), 
[13:22:29.384]                               hostname = base::Sys.info()[["nodename"]])
[13:22:29.384]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:22:29.384]                               info)
[13:22:29.384]                             info <- base::paste(info, collapse = "; ")
[13:22:29.384]                             if (!has_future) {
[13:22:29.384]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:29.384]                                 info)
[13:22:29.384]                             }
[13:22:29.384]                             else {
[13:22:29.384]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:29.384]                                 info, version)
[13:22:29.384]                             }
[13:22:29.384]                             base::stop(msg)
[13:22:29.384]                           }
[13:22:29.384]                         })
[13:22:29.384]                       }
[13:22:29.384]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:29.384]                       base::options(mc.cores = 1L)
[13:22:29.384]                     }
[13:22:29.384]                     base::local({
[13:22:29.384]                       for (pkg in "utils") {
[13:22:29.384]                         base::loadNamespace(pkg)
[13:22:29.384]                         base::library(pkg, character.only = TRUE)
[13:22:29.384]                       }
[13:22:29.384]                     })
[13:22:29.384]                   }
[13:22:29.384]                   options(future.plan = NULL)
[13:22:29.384]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:29.384]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:29.384]                 }
[13:22:29.384]                 ...future.workdir <- getwd()
[13:22:29.384]             }
[13:22:29.384]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:29.384]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:29.384]         }
[13:22:29.384]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:29.384]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:29.384]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:29.384]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:29.384]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:29.384]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:29.384]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:29.384]             base::names(...future.oldOptions))
[13:22:29.384]     }
[13:22:29.384]     if (FALSE) {
[13:22:29.384]     }
[13:22:29.384]     else {
[13:22:29.384]         if (TRUE) {
[13:22:29.384]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:29.384]                 open = "w")
[13:22:29.384]         }
[13:22:29.384]         else {
[13:22:29.384]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:29.384]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:29.384]         }
[13:22:29.384]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:29.384]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:29.384]             base::sink(type = "output", split = FALSE)
[13:22:29.384]             base::close(...future.stdout)
[13:22:29.384]         }, add = TRUE)
[13:22:29.384]     }
[13:22:29.384]     ...future.frame <- base::sys.nframe()
[13:22:29.384]     ...future.conditions <- base::list()
[13:22:29.384]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:29.384]     if (FALSE) {
[13:22:29.384]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:29.384]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:29.384]     }
[13:22:29.384]     ...future.result <- base::tryCatch({
[13:22:29.384]         base::withCallingHandlers({
[13:22:29.384]             ...future.value <- base::withVisible(base::local({
[13:22:29.384]                 withCallingHandlers({
[13:22:29.384]                   {
[13:22:29.384]                     print(1:50)
[13:22:29.384]                     str(1:50)
[13:22:29.384]                     cat(letters, sep = "-")
[13:22:29.384]                     cat(1:6, collapse = "\n")
[13:22:29.384]                     write.table(datasets::iris[1:10, ], sep = "\t")
[13:22:29.384]                     42L
[13:22:29.384]                   }
[13:22:29.384]                 }, immediateCondition = function(cond) {
[13:22:29.384]                   save_rds <- function (object, pathname, ...) 
[13:22:29.384]                   {
[13:22:29.384]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:22:29.384]                     if (file_test("-f", pathname_tmp)) {
[13:22:29.384]                       fi_tmp <- file.info(pathname_tmp)
[13:22:29.384]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:22:29.384]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:29.384]                         fi_tmp[["mtime"]])
[13:22:29.384]                     }
[13:22:29.384]                     tryCatch({
[13:22:29.384]                       saveRDS(object, file = pathname_tmp, ...)
[13:22:29.384]                     }, error = function(ex) {
[13:22:29.384]                       msg <- conditionMessage(ex)
[13:22:29.384]                       fi_tmp <- file.info(pathname_tmp)
[13:22:29.384]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:22:29.384]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:29.384]                         fi_tmp[["mtime"]], msg)
[13:22:29.384]                       ex$message <- msg
[13:22:29.384]                       stop(ex)
[13:22:29.384]                     })
[13:22:29.384]                     stopifnot(file_test("-f", pathname_tmp))
[13:22:29.384]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:22:29.384]                     if (!res || file_test("-f", pathname_tmp)) {
[13:22:29.384]                       fi_tmp <- file.info(pathname_tmp)
[13:22:29.384]                       fi <- file.info(pathname)
[13:22:29.384]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:22:29.384]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:29.384]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:22:29.384]                         fi[["size"]], fi[["mtime"]])
[13:22:29.384]                       stop(msg)
[13:22:29.384]                     }
[13:22:29.384]                     invisible(pathname)
[13:22:29.384]                   }
[13:22:29.384]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:22:29.384]                     rootPath = tempdir()) 
[13:22:29.384]                   {
[13:22:29.384]                     obj <- list(time = Sys.time(), condition = cond)
[13:22:29.384]                     file <- tempfile(pattern = class(cond)[1], 
[13:22:29.384]                       tmpdir = path, fileext = ".rds")
[13:22:29.384]                     save_rds(obj, file)
[13:22:29.384]                   }
[13:22:29.384]                   saveImmediateCondition(cond, path = "/tmp/RtmpeTCoqm/.future/immediateConditions")
[13:22:29.384]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.384]                   {
[13:22:29.384]                     inherits <- base::inherits
[13:22:29.384]                     invokeRestart <- base::invokeRestart
[13:22:29.384]                     is.null <- base::is.null
[13:22:29.384]                     muffled <- FALSE
[13:22:29.384]                     if (inherits(cond, "message")) {
[13:22:29.384]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:29.384]                       if (muffled) 
[13:22:29.384]                         invokeRestart("muffleMessage")
[13:22:29.384]                     }
[13:22:29.384]                     else if (inherits(cond, "warning")) {
[13:22:29.384]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:29.384]                       if (muffled) 
[13:22:29.384]                         invokeRestart("muffleWarning")
[13:22:29.384]                     }
[13:22:29.384]                     else if (inherits(cond, "condition")) {
[13:22:29.384]                       if (!is.null(pattern)) {
[13:22:29.384]                         computeRestarts <- base::computeRestarts
[13:22:29.384]                         grepl <- base::grepl
[13:22:29.384]                         restarts <- computeRestarts(cond)
[13:22:29.384]                         for (restart in restarts) {
[13:22:29.384]                           name <- restart$name
[13:22:29.384]                           if (is.null(name)) 
[13:22:29.384]                             next
[13:22:29.384]                           if (!grepl(pattern, name)) 
[13:22:29.384]                             next
[13:22:29.384]                           invokeRestart(restart)
[13:22:29.384]                           muffled <- TRUE
[13:22:29.384]                           break
[13:22:29.384]                         }
[13:22:29.384]                       }
[13:22:29.384]                     }
[13:22:29.384]                     invisible(muffled)
[13:22:29.384]                   }
[13:22:29.384]                   muffleCondition(cond)
[13:22:29.384]                 })
[13:22:29.384]             }))
[13:22:29.384]             future::FutureResult(value = ...future.value$value, 
[13:22:29.384]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:29.384]                   ...future.rng), globalenv = if (FALSE) 
[13:22:29.384]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:29.384]                     ...future.globalenv.names))
[13:22:29.384]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:29.384]         }, condition = base::local({
[13:22:29.384]             c <- base::c
[13:22:29.384]             inherits <- base::inherits
[13:22:29.384]             invokeRestart <- base::invokeRestart
[13:22:29.384]             length <- base::length
[13:22:29.384]             list <- base::list
[13:22:29.384]             seq.int <- base::seq.int
[13:22:29.384]             signalCondition <- base::signalCondition
[13:22:29.384]             sys.calls <- base::sys.calls
[13:22:29.384]             `[[` <- base::`[[`
[13:22:29.384]             `+` <- base::`+`
[13:22:29.384]             `<<-` <- base::`<<-`
[13:22:29.384]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:29.384]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:29.384]                   3L)]
[13:22:29.384]             }
[13:22:29.384]             function(cond) {
[13:22:29.384]                 is_error <- inherits(cond, "error")
[13:22:29.384]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:29.384]                   NULL)
[13:22:29.384]                 if (is_error) {
[13:22:29.384]                   sessionInformation <- function() {
[13:22:29.384]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:29.384]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:29.384]                       search = base::search(), system = base::Sys.info())
[13:22:29.384]                   }
[13:22:29.384]                   ...future.conditions[[length(...future.conditions) + 
[13:22:29.384]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:29.384]                     cond$call), session = sessionInformation(), 
[13:22:29.384]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:29.384]                   signalCondition(cond)
[13:22:29.384]                 }
[13:22:29.384]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:29.384]                 "immediateCondition"))) {
[13:22:29.384]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:29.384]                   ...future.conditions[[length(...future.conditions) + 
[13:22:29.384]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:29.384]                   if (TRUE && !signal) {
[13:22:29.384]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.384]                     {
[13:22:29.384]                       inherits <- base::inherits
[13:22:29.384]                       invokeRestart <- base::invokeRestart
[13:22:29.384]                       is.null <- base::is.null
[13:22:29.384]                       muffled <- FALSE
[13:22:29.384]                       if (inherits(cond, "message")) {
[13:22:29.384]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:29.384]                         if (muffled) 
[13:22:29.384]                           invokeRestart("muffleMessage")
[13:22:29.384]                       }
[13:22:29.384]                       else if (inherits(cond, "warning")) {
[13:22:29.384]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:29.384]                         if (muffled) 
[13:22:29.384]                           invokeRestart("muffleWarning")
[13:22:29.384]                       }
[13:22:29.384]                       else if (inherits(cond, "condition")) {
[13:22:29.384]                         if (!is.null(pattern)) {
[13:22:29.384]                           computeRestarts <- base::computeRestarts
[13:22:29.384]                           grepl <- base::grepl
[13:22:29.384]                           restarts <- computeRestarts(cond)
[13:22:29.384]                           for (restart in restarts) {
[13:22:29.384]                             name <- restart$name
[13:22:29.384]                             if (is.null(name)) 
[13:22:29.384]                               next
[13:22:29.384]                             if (!grepl(pattern, name)) 
[13:22:29.384]                               next
[13:22:29.384]                             invokeRestart(restart)
[13:22:29.384]                             muffled <- TRUE
[13:22:29.384]                             break
[13:22:29.384]                           }
[13:22:29.384]                         }
[13:22:29.384]                       }
[13:22:29.384]                       invisible(muffled)
[13:22:29.384]                     }
[13:22:29.384]                     muffleCondition(cond, pattern = "^muffle")
[13:22:29.384]                   }
[13:22:29.384]                 }
[13:22:29.384]                 else {
[13:22:29.384]                   if (TRUE) {
[13:22:29.384]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.384]                     {
[13:22:29.384]                       inherits <- base::inherits
[13:22:29.384]                       invokeRestart <- base::invokeRestart
[13:22:29.384]                       is.null <- base::is.null
[13:22:29.384]                       muffled <- FALSE
[13:22:29.384]                       if (inherits(cond, "message")) {
[13:22:29.384]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:29.384]                         if (muffled) 
[13:22:29.384]                           invokeRestart("muffleMessage")
[13:22:29.384]                       }
[13:22:29.384]                       else if (inherits(cond, "warning")) {
[13:22:29.384]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:29.384]                         if (muffled) 
[13:22:29.384]                           invokeRestart("muffleWarning")
[13:22:29.384]                       }
[13:22:29.384]                       else if (inherits(cond, "condition")) {
[13:22:29.384]                         if (!is.null(pattern)) {
[13:22:29.384]                           computeRestarts <- base::computeRestarts
[13:22:29.384]                           grepl <- base::grepl
[13:22:29.384]                           restarts <- computeRestarts(cond)
[13:22:29.384]                           for (restart in restarts) {
[13:22:29.384]                             name <- restart$name
[13:22:29.384]                             if (is.null(name)) 
[13:22:29.384]                               next
[13:22:29.384]                             if (!grepl(pattern, name)) 
[13:22:29.384]                               next
[13:22:29.384]                             invokeRestart(restart)
[13:22:29.384]                             muffled <- TRUE
[13:22:29.384]                             break
[13:22:29.384]                           }
[13:22:29.384]                         }
[13:22:29.384]                       }
[13:22:29.384]                       invisible(muffled)
[13:22:29.384]                     }
[13:22:29.384]                     muffleCondition(cond, pattern = "^muffle")
[13:22:29.384]                   }
[13:22:29.384]                 }
[13:22:29.384]             }
[13:22:29.384]         }))
[13:22:29.384]     }, error = function(ex) {
[13:22:29.384]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:29.384]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:29.384]                 ...future.rng), started = ...future.startTime, 
[13:22:29.384]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:29.384]             version = "1.8"), class = "FutureResult")
[13:22:29.384]     }, finally = {
[13:22:29.384]         if (!identical(...future.workdir, getwd())) 
[13:22:29.384]             setwd(...future.workdir)
[13:22:29.384]         {
[13:22:29.384]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:29.384]                 ...future.oldOptions$nwarnings <- NULL
[13:22:29.384]             }
[13:22:29.384]             base::options(...future.oldOptions)
[13:22:29.384]             if (.Platform$OS.type == "windows") {
[13:22:29.384]                 old_names <- names(...future.oldEnvVars)
[13:22:29.384]                 envs <- base::Sys.getenv()
[13:22:29.384]                 names <- names(envs)
[13:22:29.384]                 common <- intersect(names, old_names)
[13:22:29.384]                 added <- setdiff(names, old_names)
[13:22:29.384]                 removed <- setdiff(old_names, names)
[13:22:29.384]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:29.384]                   envs[common]]
[13:22:29.384]                 NAMES <- toupper(changed)
[13:22:29.384]                 args <- list()
[13:22:29.384]                 for (kk in seq_along(NAMES)) {
[13:22:29.384]                   name <- changed[[kk]]
[13:22:29.384]                   NAME <- NAMES[[kk]]
[13:22:29.384]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.384]                     next
[13:22:29.384]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:29.384]                 }
[13:22:29.384]                 NAMES <- toupper(added)
[13:22:29.384]                 for (kk in seq_along(NAMES)) {
[13:22:29.384]                   name <- added[[kk]]
[13:22:29.384]                   NAME <- NAMES[[kk]]
[13:22:29.384]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.384]                     next
[13:22:29.384]                   args[[name]] <- ""
[13:22:29.384]                 }
[13:22:29.384]                 NAMES <- toupper(removed)
[13:22:29.384]                 for (kk in seq_along(NAMES)) {
[13:22:29.384]                   name <- removed[[kk]]
[13:22:29.384]                   NAME <- NAMES[[kk]]
[13:22:29.384]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.384]                     next
[13:22:29.384]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:29.384]                 }
[13:22:29.384]                 if (length(args) > 0) 
[13:22:29.384]                   base::do.call(base::Sys.setenv, args = args)
[13:22:29.384]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:29.384]             }
[13:22:29.384]             else {
[13:22:29.384]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:29.384]             }
[13:22:29.384]             {
[13:22:29.384]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:29.384]                   0L) {
[13:22:29.384]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:29.384]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:29.384]                   base::options(opts)
[13:22:29.384]                 }
[13:22:29.384]                 {
[13:22:29.384]                   {
[13:22:29.384]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:29.384]                     NULL
[13:22:29.384]                   }
[13:22:29.384]                   options(future.plan = NULL)
[13:22:29.384]                   if (is.na(NA_character_)) 
[13:22:29.384]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:29.384]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:29.384]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:22:29.384]                     envir = parent.frame()) 
[13:22:29.384]                   {
[13:22:29.384]                     default_workers <- missing(workers)
[13:22:29.384]                     if (is.function(workers)) 
[13:22:29.384]                       workers <- workers()
[13:22:29.384]                     workers <- structure(as.integer(workers), 
[13:22:29.384]                       class = class(workers))
[13:22:29.384]                     stop_if_not(is.finite(workers), workers >= 
[13:22:29.384]                       1L)
[13:22:29.384]                     if ((workers == 1L && !inherits(workers, 
[13:22:29.384]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:22:29.384]                       if (default_workers) 
[13:22:29.384]                         supportsMulticore(warn = TRUE)
[13:22:29.384]                       return(sequential(..., envir = envir))
[13:22:29.384]                     }
[13:22:29.384]                     oopts <- options(mc.cores = workers)
[13:22:29.384]                     on.exit(options(oopts))
[13:22:29.384]                     future <- MulticoreFuture(..., workers = workers, 
[13:22:29.384]                       envir = envir)
[13:22:29.384]                     if (!future$lazy) 
[13:22:29.384]                       future <- run(future)
[13:22:29.384]                     invisible(future)
[13:22:29.384]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:29.384]                 }
[13:22:29.384]             }
[13:22:29.384]         }
[13:22:29.384]     })
[13:22:29.384]     if (TRUE) {
[13:22:29.384]         base::sink(type = "output", split = FALSE)
[13:22:29.384]         if (TRUE) {
[13:22:29.384]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:29.384]         }
[13:22:29.384]         else {
[13:22:29.384]             ...future.result["stdout"] <- base::list(NULL)
[13:22:29.384]         }
[13:22:29.384]         base::close(...future.stdout)
[13:22:29.384]         ...future.stdout <- NULL
[13:22:29.384]     }
[13:22:29.384]     ...future.result$conditions <- ...future.conditions
[13:22:29.384]     ...future.result$finished <- base::Sys.time()
[13:22:29.384]     ...future.result
[13:22:29.384] }
[13:22:29.387] requestCore(): workers = 2
[13:22:29.389] MulticoreFuture started
[13:22:29.390] - Launch lazy future ... done
[13:22:29.390] run() for ‘MulticoreFuture’ ... done
[13:22:29.391] plan(): Setting new future strategy stack:
[13:22:29.391] List of future strategies:
[13:22:29.391] 1. sequential:
[13:22:29.391]    - args: function (..., envir = parent.frame())
[13:22:29.391]    - tweaked: FALSE
[13:22:29.391]    - call: NULL
[13:22:29.392] plan(): nbrOfWorkers() = 1
[13:22:29.399] plan(): Setting new future strategy stack:
[13:22:29.400] List of future strategies:
[13:22:29.400] 1. multicore:
[13:22:29.400]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:22:29.400]    - tweaked: FALSE
[13:22:29.400]    - call: plan(strategy)
[13:22:29.405] plan(): nbrOfWorkers() = 2
 [1] " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25"  
 [2] "[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50"  
 [3] " int [1:50] 1 2 3 4 5 6 7 8 9 10 ..."                                             
 [4] "a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 "                  
 [5] "\"Sepal.Length\"\t\"Sepal.Width\"\t\"Petal.Length\"\t\"Petal.Width\"\t\"Species\""
 [6] "\"1\"\t5.1\t3.5\t1.4\t0.2\t\"setosa\""                                            
 [7] "\"2\"\t4.9\t3\t1.4\t0.2\t\"setosa\""                                              
 [8] "\"3\"\t4.7\t3.2\t1.3\t0.2\t\"setosa\""                                            
 [9] "\"4\"\t4.6\t3.1\t1.5\t0.2\t\"setosa\""                                            
[10] "\"5\"\t5\t3.6\t1.4\t0.2\t\"setosa\""                                              
[11] "\"6\"\t5.4\t3.9\t1.7\t0.4\t\"setosa\""                                            
[12] "\"7\"\t4.6\t3.4\t1.4\t0.3\t\"setosa\""                                            
[13] "\"8\"\t5\t3.4\t1.5\t0.2\t\"setosa\""                                              
[14] "\"9\"\t4.4\t2.9\t1.4\t0.2\t\"setosa\""                                            
[15] "\"10\"\t4.9\t3.1\t1.5\t0.1\t\"setosa\""                                           
- stdout = structure(TRUE, drop = TRUE)
[13:22:29.407] getGlobalsAndPackages() ...
[13:22:29.407] Searching for globals...
[13:22:29.411] - globals found: [1] ‘print’
[13:22:29.411] Searching for globals ... DONE
[13:22:29.411] Resolving globals: FALSE
[13:22:29.412] 
[13:22:29.412] 
[13:22:29.412] getGlobalsAndPackages() ... DONE
[13:22:29.412] run() for ‘Future’ ...
[13:22:29.413] - state: ‘created’
[13:22:29.413] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:22:29.417] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:29.418] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:22:29.418]   - Field: ‘label’
[13:22:29.418]   - Field: ‘local’
[13:22:29.418]   - Field: ‘owner’
[13:22:29.418]   - Field: ‘envir’
[13:22:29.418]   - Field: ‘workers’
[13:22:29.418]   - Field: ‘packages’
[13:22:29.419]   - Field: ‘gc’
[13:22:29.419]   - Field: ‘job’
[13:22:29.419]   - Field: ‘conditions’
[13:22:29.419]   - Field: ‘expr’
[13:22:29.419]   - Field: ‘uuid’
[13:22:29.419]   - Field: ‘seed’
[13:22:29.419]   - Field: ‘version’
[13:22:29.420]   - Field: ‘result’
[13:22:29.420]   - Field: ‘asynchronous’
[13:22:29.420]   - Field: ‘calls’
[13:22:29.420]   - Field: ‘globals’
[13:22:29.420]   - Field: ‘stdout’
[13:22:29.420]   - Field: ‘earlySignal’
[13:22:29.420]   - Field: ‘lazy’
[13:22:29.421]   - Field: ‘state’
[13:22:29.421] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:22:29.421] - Launch lazy future ...
[13:22:29.421] Packages needed by the future expression (n = 0): <none>
[13:22:29.421] Packages needed by future strategies (n = 0): <none>
[13:22:29.422] {
[13:22:29.422]     {
[13:22:29.422]         {
[13:22:29.422]             ...future.startTime <- base::Sys.time()
[13:22:29.422]             {
[13:22:29.422]                 {
[13:22:29.422]                   {
[13:22:29.422]                     {
[13:22:29.422]                       base::local({
[13:22:29.422]                         has_future <- base::requireNamespace("future", 
[13:22:29.422]                           quietly = TRUE)
[13:22:29.422]                         if (has_future) {
[13:22:29.422]                           ns <- base::getNamespace("future")
[13:22:29.422]                           version <- ns[[".package"]][["version"]]
[13:22:29.422]                           if (is.null(version)) 
[13:22:29.422]                             version <- utils::packageVersion("future")
[13:22:29.422]                         }
[13:22:29.422]                         else {
[13:22:29.422]                           version <- NULL
[13:22:29.422]                         }
[13:22:29.422]                         if (!has_future || version < "1.8.0") {
[13:22:29.422]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:29.422]                             "", base::R.version$version.string), 
[13:22:29.422]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:29.422]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:29.422]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:29.422]                               "release", "version")], collapse = " "), 
[13:22:29.422]                             hostname = base::Sys.info()[["nodename"]])
[13:22:29.422]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:29.422]                             info)
[13:22:29.422]                           info <- base::paste(info, collapse = "; ")
[13:22:29.422]                           if (!has_future) {
[13:22:29.422]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:29.422]                               info)
[13:22:29.422]                           }
[13:22:29.422]                           else {
[13:22:29.422]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:29.422]                               info, version)
[13:22:29.422]                           }
[13:22:29.422]                           base::stop(msg)
[13:22:29.422]                         }
[13:22:29.422]                       })
[13:22:29.422]                     }
[13:22:29.422]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:29.422]                     base::options(mc.cores = 1L)
[13:22:29.422]                   }
[13:22:29.422]                   options(future.plan = NULL)
[13:22:29.422]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:29.422]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:29.422]                 }
[13:22:29.422]                 ...future.workdir <- getwd()
[13:22:29.422]             }
[13:22:29.422]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:29.422]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:29.422]         }
[13:22:29.422]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:29.422]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:29.422]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:29.422]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:29.422]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:29.422]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:29.422]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:29.422]             base::names(...future.oldOptions))
[13:22:29.422]     }
[13:22:29.422]     if (FALSE) {
[13:22:29.422]     }
[13:22:29.422]     else {
[13:22:29.422]         if (TRUE) {
[13:22:29.422]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:29.422]                 open = "w")
[13:22:29.422]         }
[13:22:29.422]         else {
[13:22:29.422]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:29.422]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:29.422]         }
[13:22:29.422]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:29.422]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:29.422]             base::sink(type = "output", split = FALSE)
[13:22:29.422]             base::close(...future.stdout)
[13:22:29.422]         }, add = TRUE)
[13:22:29.422]     }
[13:22:29.422]     ...future.frame <- base::sys.nframe()
[13:22:29.422]     ...future.conditions <- base::list()
[13:22:29.422]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:29.422]     if (FALSE) {
[13:22:29.422]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:29.422]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:29.422]     }
[13:22:29.422]     ...future.result <- base::tryCatch({
[13:22:29.422]         base::withCallingHandlers({
[13:22:29.422]             ...future.value <- base::withVisible(base::local({
[13:22:29.422]                 withCallingHandlers({
[13:22:29.422]                   print(42)
[13:22:29.422]                 }, immediateCondition = function(cond) {
[13:22:29.422]                   save_rds <- function (object, pathname, ...) 
[13:22:29.422]                   {
[13:22:29.422]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:22:29.422]                     if (file_test("-f", pathname_tmp)) {
[13:22:29.422]                       fi_tmp <- file.info(pathname_tmp)
[13:22:29.422]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:22:29.422]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:29.422]                         fi_tmp[["mtime"]])
[13:22:29.422]                     }
[13:22:29.422]                     tryCatch({
[13:22:29.422]                       saveRDS(object, file = pathname_tmp, ...)
[13:22:29.422]                     }, error = function(ex) {
[13:22:29.422]                       msg <- conditionMessage(ex)
[13:22:29.422]                       fi_tmp <- file.info(pathname_tmp)
[13:22:29.422]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:22:29.422]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:29.422]                         fi_tmp[["mtime"]], msg)
[13:22:29.422]                       ex$message <- msg
[13:22:29.422]                       stop(ex)
[13:22:29.422]                     })
[13:22:29.422]                     stopifnot(file_test("-f", pathname_tmp))
[13:22:29.422]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:22:29.422]                     if (!res || file_test("-f", pathname_tmp)) {
[13:22:29.422]                       fi_tmp <- file.info(pathname_tmp)
[13:22:29.422]                       fi <- file.info(pathname)
[13:22:29.422]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:22:29.422]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:29.422]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:22:29.422]                         fi[["size"]], fi[["mtime"]])
[13:22:29.422]                       stop(msg)
[13:22:29.422]                     }
[13:22:29.422]                     invisible(pathname)
[13:22:29.422]                   }
[13:22:29.422]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:22:29.422]                     rootPath = tempdir()) 
[13:22:29.422]                   {
[13:22:29.422]                     obj <- list(time = Sys.time(), condition = cond)
[13:22:29.422]                     file <- tempfile(pattern = class(cond)[1], 
[13:22:29.422]                       tmpdir = path, fileext = ".rds")
[13:22:29.422]                     save_rds(obj, file)
[13:22:29.422]                   }
[13:22:29.422]                   saveImmediateCondition(cond, path = "/tmp/RtmpeTCoqm/.future/immediateConditions")
[13:22:29.422]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.422]                   {
[13:22:29.422]                     inherits <- base::inherits
[13:22:29.422]                     invokeRestart <- base::invokeRestart
[13:22:29.422]                     is.null <- base::is.null
[13:22:29.422]                     muffled <- FALSE
[13:22:29.422]                     if (inherits(cond, "message")) {
[13:22:29.422]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:29.422]                       if (muffled) 
[13:22:29.422]                         invokeRestart("muffleMessage")
[13:22:29.422]                     }
[13:22:29.422]                     else if (inherits(cond, "warning")) {
[13:22:29.422]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:29.422]                       if (muffled) 
[13:22:29.422]                         invokeRestart("muffleWarning")
[13:22:29.422]                     }
[13:22:29.422]                     else if (inherits(cond, "condition")) {
[13:22:29.422]                       if (!is.null(pattern)) {
[13:22:29.422]                         computeRestarts <- base::computeRestarts
[13:22:29.422]                         grepl <- base::grepl
[13:22:29.422]                         restarts <- computeRestarts(cond)
[13:22:29.422]                         for (restart in restarts) {
[13:22:29.422]                           name <- restart$name
[13:22:29.422]                           if (is.null(name)) 
[13:22:29.422]                             next
[13:22:29.422]                           if (!grepl(pattern, name)) 
[13:22:29.422]                             next
[13:22:29.422]                           invokeRestart(restart)
[13:22:29.422]                           muffled <- TRUE
[13:22:29.422]                           break
[13:22:29.422]                         }
[13:22:29.422]                       }
[13:22:29.422]                     }
[13:22:29.422]                     invisible(muffled)
[13:22:29.422]                   }
[13:22:29.422]                   muffleCondition(cond)
[13:22:29.422]                 })
[13:22:29.422]             }))
[13:22:29.422]             future::FutureResult(value = ...future.value$value, 
[13:22:29.422]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:29.422]                   ...future.rng), globalenv = if (FALSE) 
[13:22:29.422]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:29.422]                     ...future.globalenv.names))
[13:22:29.422]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:29.422]         }, condition = base::local({
[13:22:29.422]             c <- base::c
[13:22:29.422]             inherits <- base::inherits
[13:22:29.422]             invokeRestart <- base::invokeRestart
[13:22:29.422]             length <- base::length
[13:22:29.422]             list <- base::list
[13:22:29.422]             seq.int <- base::seq.int
[13:22:29.422]             signalCondition <- base::signalCondition
[13:22:29.422]             sys.calls <- base::sys.calls
[13:22:29.422]             `[[` <- base::`[[`
[13:22:29.422]             `+` <- base::`+`
[13:22:29.422]             `<<-` <- base::`<<-`
[13:22:29.422]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:29.422]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:29.422]                   3L)]
[13:22:29.422]             }
[13:22:29.422]             function(cond) {
[13:22:29.422]                 is_error <- inherits(cond, "error")
[13:22:29.422]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:29.422]                   NULL)
[13:22:29.422]                 if (is_error) {
[13:22:29.422]                   sessionInformation <- function() {
[13:22:29.422]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:29.422]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:29.422]                       search = base::search(), system = base::Sys.info())
[13:22:29.422]                   }
[13:22:29.422]                   ...future.conditions[[length(...future.conditions) + 
[13:22:29.422]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:29.422]                     cond$call), session = sessionInformation(), 
[13:22:29.422]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:29.422]                   signalCondition(cond)
[13:22:29.422]                 }
[13:22:29.422]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:29.422]                 "immediateCondition"))) {
[13:22:29.422]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:29.422]                   ...future.conditions[[length(...future.conditions) + 
[13:22:29.422]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:29.422]                   if (TRUE && !signal) {
[13:22:29.422]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.422]                     {
[13:22:29.422]                       inherits <- base::inherits
[13:22:29.422]                       invokeRestart <- base::invokeRestart
[13:22:29.422]                       is.null <- base::is.null
[13:22:29.422]                       muffled <- FALSE
[13:22:29.422]                       if (inherits(cond, "message")) {
[13:22:29.422]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:29.422]                         if (muffled) 
[13:22:29.422]                           invokeRestart("muffleMessage")
[13:22:29.422]                       }
[13:22:29.422]                       else if (inherits(cond, "warning")) {
[13:22:29.422]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:29.422]                         if (muffled) 
[13:22:29.422]                           invokeRestart("muffleWarning")
[13:22:29.422]                       }
[13:22:29.422]                       else if (inherits(cond, "condition")) {
[13:22:29.422]                         if (!is.null(pattern)) {
[13:22:29.422]                           computeRestarts <- base::computeRestarts
[13:22:29.422]                           grepl <- base::grepl
[13:22:29.422]                           restarts <- computeRestarts(cond)
[13:22:29.422]                           for (restart in restarts) {
[13:22:29.422]                             name <- restart$name
[13:22:29.422]                             if (is.null(name)) 
[13:22:29.422]                               next
[13:22:29.422]                             if (!grepl(pattern, name)) 
[13:22:29.422]                               next
[13:22:29.422]                             invokeRestart(restart)
[13:22:29.422]                             muffled <- TRUE
[13:22:29.422]                             break
[13:22:29.422]                           }
[13:22:29.422]                         }
[13:22:29.422]                       }
[13:22:29.422]                       invisible(muffled)
[13:22:29.422]                     }
[13:22:29.422]                     muffleCondition(cond, pattern = "^muffle")
[13:22:29.422]                   }
[13:22:29.422]                 }
[13:22:29.422]                 else {
[13:22:29.422]                   if (TRUE) {
[13:22:29.422]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.422]                     {
[13:22:29.422]                       inherits <- base::inherits
[13:22:29.422]                       invokeRestart <- base::invokeRestart
[13:22:29.422]                       is.null <- base::is.null
[13:22:29.422]                       muffled <- FALSE
[13:22:29.422]                       if (inherits(cond, "message")) {
[13:22:29.422]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:29.422]                         if (muffled) 
[13:22:29.422]                           invokeRestart("muffleMessage")
[13:22:29.422]                       }
[13:22:29.422]                       else if (inherits(cond, "warning")) {
[13:22:29.422]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:29.422]                         if (muffled) 
[13:22:29.422]                           invokeRestart("muffleWarning")
[13:22:29.422]                       }
[13:22:29.422]                       else if (inherits(cond, "condition")) {
[13:22:29.422]                         if (!is.null(pattern)) {
[13:22:29.422]                           computeRestarts <- base::computeRestarts
[13:22:29.422]                           grepl <- base::grepl
[13:22:29.422]                           restarts <- computeRestarts(cond)
[13:22:29.422]                           for (restart in restarts) {
[13:22:29.422]                             name <- restart$name
[13:22:29.422]                             if (is.null(name)) 
[13:22:29.422]                               next
[13:22:29.422]                             if (!grepl(pattern, name)) 
[13:22:29.422]                               next
[13:22:29.422]                             invokeRestart(restart)
[13:22:29.422]                             muffled <- TRUE
[13:22:29.422]                             break
[13:22:29.422]                           }
[13:22:29.422]                         }
[13:22:29.422]                       }
[13:22:29.422]                       invisible(muffled)
[13:22:29.422]                     }
[13:22:29.422]                     muffleCondition(cond, pattern = "^muffle")
[13:22:29.422]                   }
[13:22:29.422]                 }
[13:22:29.422]             }
[13:22:29.422]         }))
[13:22:29.422]     }, error = function(ex) {
[13:22:29.422]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:29.422]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:29.422]                 ...future.rng), started = ...future.startTime, 
[13:22:29.422]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:29.422]             version = "1.8"), class = "FutureResult")
[13:22:29.422]     }, finally = {
[13:22:29.422]         if (!identical(...future.workdir, getwd())) 
[13:22:29.422]             setwd(...future.workdir)
[13:22:29.422]         {
[13:22:29.422]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:29.422]                 ...future.oldOptions$nwarnings <- NULL
[13:22:29.422]             }
[13:22:29.422]             base::options(...future.oldOptions)
[13:22:29.422]             if (.Platform$OS.type == "windows") {
[13:22:29.422]                 old_names <- names(...future.oldEnvVars)
[13:22:29.422]                 envs <- base::Sys.getenv()
[13:22:29.422]                 names <- names(envs)
[13:22:29.422]                 common <- intersect(names, old_names)
[13:22:29.422]                 added <- setdiff(names, old_names)
[13:22:29.422]                 removed <- setdiff(old_names, names)
[13:22:29.422]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:29.422]                   envs[common]]
[13:22:29.422]                 NAMES <- toupper(changed)
[13:22:29.422]                 args <- list()
[13:22:29.422]                 for (kk in seq_along(NAMES)) {
[13:22:29.422]                   name <- changed[[kk]]
[13:22:29.422]                   NAME <- NAMES[[kk]]
[13:22:29.422]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.422]                     next
[13:22:29.422]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:29.422]                 }
[13:22:29.422]                 NAMES <- toupper(added)
[13:22:29.422]                 for (kk in seq_along(NAMES)) {
[13:22:29.422]                   name <- added[[kk]]
[13:22:29.422]                   NAME <- NAMES[[kk]]
[13:22:29.422]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.422]                     next
[13:22:29.422]                   args[[name]] <- ""
[13:22:29.422]                 }
[13:22:29.422]                 NAMES <- toupper(removed)
[13:22:29.422]                 for (kk in seq_along(NAMES)) {
[13:22:29.422]                   name <- removed[[kk]]
[13:22:29.422]                   NAME <- NAMES[[kk]]
[13:22:29.422]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.422]                     next
[13:22:29.422]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:29.422]                 }
[13:22:29.422]                 if (length(args) > 0) 
[13:22:29.422]                   base::do.call(base::Sys.setenv, args = args)
[13:22:29.422]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:29.422]             }
[13:22:29.422]             else {
[13:22:29.422]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:29.422]             }
[13:22:29.422]             {
[13:22:29.422]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:29.422]                   0L) {
[13:22:29.422]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:29.422]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:29.422]                   base::options(opts)
[13:22:29.422]                 }
[13:22:29.422]                 {
[13:22:29.422]                   {
[13:22:29.422]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:29.422]                     NULL
[13:22:29.422]                   }
[13:22:29.422]                   options(future.plan = NULL)
[13:22:29.422]                   if (is.na(NA_character_)) 
[13:22:29.422]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:29.422]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:29.422]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:22:29.422]                     envir = parent.frame()) 
[13:22:29.422]                   {
[13:22:29.422]                     default_workers <- missing(workers)
[13:22:29.422]                     if (is.function(workers)) 
[13:22:29.422]                       workers <- workers()
[13:22:29.422]                     workers <- structure(as.integer(workers), 
[13:22:29.422]                       class = class(workers))
[13:22:29.422]                     stop_if_not(is.finite(workers), workers >= 
[13:22:29.422]                       1L)
[13:22:29.422]                     if ((workers == 1L && !inherits(workers, 
[13:22:29.422]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:22:29.422]                       if (default_workers) 
[13:22:29.422]                         supportsMulticore(warn = TRUE)
[13:22:29.422]                       return(sequential(..., envir = envir))
[13:22:29.422]                     }
[13:22:29.422]                     oopts <- options(mc.cores = workers)
[13:22:29.422]                     on.exit(options(oopts))
[13:22:29.422]                     future <- MulticoreFuture(..., workers = workers, 
[13:22:29.422]                       envir = envir)
[13:22:29.422]                     if (!future$lazy) 
[13:22:29.422]                       future <- run(future)
[13:22:29.422]                     invisible(future)
[13:22:29.422]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:29.422]                 }
[13:22:29.422]             }
[13:22:29.422]         }
[13:22:29.422]     })
[13:22:29.422]     if (TRUE) {
[13:22:29.422]         base::sink(type = "output", split = FALSE)
[13:22:29.422]         if (TRUE) {
[13:22:29.422]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:29.422]         }
[13:22:29.422]         else {
[13:22:29.422]             ...future.result["stdout"] <- base::list(NULL)
[13:22:29.422]         }
[13:22:29.422]         base::close(...future.stdout)
[13:22:29.422]         ...future.stdout <- NULL
[13:22:29.422]     }
[13:22:29.422]     ...future.result$conditions <- ...future.conditions
[13:22:29.422]     ...future.result$finished <- base::Sys.time()
[13:22:29.422]     ...future.result
[13:22:29.422] }
[13:22:29.425] requestCore(): workers = 2
[13:22:29.427] MulticoreFuture started
[13:22:29.427] - Launch lazy future ... done
[13:22:29.428] run() for ‘MulticoreFuture’ ... done
[13:22:29.428] plan(): Setting new future strategy stack:
[13:22:29.428] List of future strategies:
[13:22:29.428] 1. sequential:
[13:22:29.428]    - args: function (..., envir = parent.frame())
[13:22:29.428]    - tweaked: FALSE
[13:22:29.428]    - call: NULL
[13:22:29.430] plan(): nbrOfWorkers() = 1
[13:22:29.432] plan(): Setting new future strategy stack:
[13:22:29.432] List of future strategies:
[13:22:29.432] 1. multicore:
[13:22:29.432]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:22:29.432]    - tweaked: FALSE
[13:22:29.432]    - call: plan(strategy)
[13:22:29.437] plan(): nbrOfWorkers() = 2
[1] 42
- stdout = FALSE
[13:22:29.438] getGlobalsAndPackages() ...
[13:22:29.438] Searching for globals...
[13:22:29.442] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[13:22:29.442] Searching for globals ... DONE
[13:22:29.442] Resolving globals: FALSE
[13:22:29.443] 
[13:22:29.443] - packages: [1] ‘utils’
[13:22:29.443] getGlobalsAndPackages() ... DONE
[13:22:29.444] run() for ‘Future’ ...
[13:22:29.444] - state: ‘created’
[13:22:29.444] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:22:29.448] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:29.448] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:22:29.448]   - Field: ‘label’
[13:22:29.448]   - Field: ‘local’
[13:22:29.449]   - Field: ‘owner’
[13:22:29.449]   - Field: ‘envir’
[13:22:29.449]   - Field: ‘workers’
[13:22:29.449]   - Field: ‘packages’
[13:22:29.449]   - Field: ‘gc’
[13:22:29.449]   - Field: ‘job’
[13:22:29.449]   - Field: ‘conditions’
[13:22:29.449]   - Field: ‘expr’
[13:22:29.449]   - Field: ‘uuid’
[13:22:29.450]   - Field: ‘seed’
[13:22:29.450]   - Field: ‘version’
[13:22:29.450]   - Field: ‘result’
[13:22:29.450]   - Field: ‘asynchronous’
[13:22:29.450]   - Field: ‘calls’
[13:22:29.450]   - Field: ‘globals’
[13:22:29.450]   - Field: ‘stdout’
[13:22:29.450]   - Field: ‘earlySignal’
[13:22:29.450]   - Field: ‘lazy’
[13:22:29.451]   - Field: ‘state’
[13:22:29.451] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:22:29.451] - Launch lazy future ...
[13:22:29.451] Packages needed by the future expression (n = 1): ‘utils’
[13:22:29.451] Packages needed by future strategies (n = 0): <none>
[13:22:29.452] {
[13:22:29.452]     {
[13:22:29.452]         {
[13:22:29.452]             ...future.startTime <- base::Sys.time()
[13:22:29.452]             {
[13:22:29.452]                 {
[13:22:29.452]                   {
[13:22:29.452]                     {
[13:22:29.452]                       {
[13:22:29.452]                         base::local({
[13:22:29.452]                           has_future <- base::requireNamespace("future", 
[13:22:29.452]                             quietly = TRUE)
[13:22:29.452]                           if (has_future) {
[13:22:29.452]                             ns <- base::getNamespace("future")
[13:22:29.452]                             version <- ns[[".package"]][["version"]]
[13:22:29.452]                             if (is.null(version)) 
[13:22:29.452]                               version <- utils::packageVersion("future")
[13:22:29.452]                           }
[13:22:29.452]                           else {
[13:22:29.452]                             version <- NULL
[13:22:29.452]                           }
[13:22:29.452]                           if (!has_future || version < "1.8.0") {
[13:22:29.452]                             info <- base::c(r_version = base::gsub("R version ", 
[13:22:29.452]                               "", base::R.version$version.string), 
[13:22:29.452]                               platform = base::sprintf("%s (%s-bit)", 
[13:22:29.452]                                 base::R.version$platform, 8 * 
[13:22:29.452]                                   base::.Machine$sizeof.pointer), 
[13:22:29.452]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:29.452]                                 "release", "version")], collapse = " "), 
[13:22:29.452]                               hostname = base::Sys.info()[["nodename"]])
[13:22:29.452]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:22:29.452]                               info)
[13:22:29.452]                             info <- base::paste(info, collapse = "; ")
[13:22:29.452]                             if (!has_future) {
[13:22:29.452]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:29.452]                                 info)
[13:22:29.452]                             }
[13:22:29.452]                             else {
[13:22:29.452]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:29.452]                                 info, version)
[13:22:29.452]                             }
[13:22:29.452]                             base::stop(msg)
[13:22:29.452]                           }
[13:22:29.452]                         })
[13:22:29.452]                       }
[13:22:29.452]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:29.452]                       base::options(mc.cores = 1L)
[13:22:29.452]                     }
[13:22:29.452]                     base::local({
[13:22:29.452]                       for (pkg in "utils") {
[13:22:29.452]                         base::loadNamespace(pkg)
[13:22:29.452]                         base::library(pkg, character.only = TRUE)
[13:22:29.452]                       }
[13:22:29.452]                     })
[13:22:29.452]                   }
[13:22:29.452]                   options(future.plan = NULL)
[13:22:29.452]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:29.452]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:29.452]                 }
[13:22:29.452]                 ...future.workdir <- getwd()
[13:22:29.452]             }
[13:22:29.452]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:29.452]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:29.452]         }
[13:22:29.452]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:29.452]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:29.452]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:29.452]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:29.452]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:29.452]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:29.452]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:29.452]             base::names(...future.oldOptions))
[13:22:29.452]     }
[13:22:29.452]     if (FALSE) {
[13:22:29.452]     }
[13:22:29.452]     else {
[13:22:29.452]         if (FALSE) {
[13:22:29.452]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:29.452]                 open = "w")
[13:22:29.452]         }
[13:22:29.452]         else {
[13:22:29.452]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:29.452]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:29.452]         }
[13:22:29.452]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:29.452]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:29.452]             base::sink(type = "output", split = FALSE)
[13:22:29.452]             base::close(...future.stdout)
[13:22:29.452]         }, add = TRUE)
[13:22:29.452]     }
[13:22:29.452]     ...future.frame <- base::sys.nframe()
[13:22:29.452]     ...future.conditions <- base::list()
[13:22:29.452]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:29.452]     if (FALSE) {
[13:22:29.452]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:29.452]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:29.452]     }
[13:22:29.452]     ...future.result <- base::tryCatch({
[13:22:29.452]         base::withCallingHandlers({
[13:22:29.452]             ...future.value <- base::withVisible(base::local({
[13:22:29.452]                 withCallingHandlers({
[13:22:29.452]                   {
[13:22:29.452]                     print(1:50)
[13:22:29.452]                     str(1:50)
[13:22:29.452]                     cat(letters, sep = "-")
[13:22:29.452]                     cat(1:6, collapse = "\n")
[13:22:29.452]                     write.table(datasets::iris[1:10, ], sep = "\t")
[13:22:29.452]                     42L
[13:22:29.452]                   }
[13:22:29.452]                 }, immediateCondition = function(cond) {
[13:22:29.452]                   save_rds <- function (object, pathname, ...) 
[13:22:29.452]                   {
[13:22:29.452]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:22:29.452]                     if (file_test("-f", pathname_tmp)) {
[13:22:29.452]                       fi_tmp <- file.info(pathname_tmp)
[13:22:29.452]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:22:29.452]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:29.452]                         fi_tmp[["mtime"]])
[13:22:29.452]                     }
[13:22:29.452]                     tryCatch({
[13:22:29.452]                       saveRDS(object, file = pathname_tmp, ...)
[13:22:29.452]                     }, error = function(ex) {
[13:22:29.452]                       msg <- conditionMessage(ex)
[13:22:29.452]                       fi_tmp <- file.info(pathname_tmp)
[13:22:29.452]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:22:29.452]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:29.452]                         fi_tmp[["mtime"]], msg)
[13:22:29.452]                       ex$message <- msg
[13:22:29.452]                       stop(ex)
[13:22:29.452]                     })
[13:22:29.452]                     stopifnot(file_test("-f", pathname_tmp))
[13:22:29.452]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:22:29.452]                     if (!res || file_test("-f", pathname_tmp)) {
[13:22:29.452]                       fi_tmp <- file.info(pathname_tmp)
[13:22:29.452]                       fi <- file.info(pathname)
[13:22:29.452]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:22:29.452]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:29.452]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:22:29.452]                         fi[["size"]], fi[["mtime"]])
[13:22:29.452]                       stop(msg)
[13:22:29.452]                     }
[13:22:29.452]                     invisible(pathname)
[13:22:29.452]                   }
[13:22:29.452]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:22:29.452]                     rootPath = tempdir()) 
[13:22:29.452]                   {
[13:22:29.452]                     obj <- list(time = Sys.time(), condition = cond)
[13:22:29.452]                     file <- tempfile(pattern = class(cond)[1], 
[13:22:29.452]                       tmpdir = path, fileext = ".rds")
[13:22:29.452]                     save_rds(obj, file)
[13:22:29.452]                   }
[13:22:29.452]                   saveImmediateCondition(cond, path = "/tmp/RtmpeTCoqm/.future/immediateConditions")
[13:22:29.452]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.452]                   {
[13:22:29.452]                     inherits <- base::inherits
[13:22:29.452]                     invokeRestart <- base::invokeRestart
[13:22:29.452]                     is.null <- base::is.null
[13:22:29.452]                     muffled <- FALSE
[13:22:29.452]                     if (inherits(cond, "message")) {
[13:22:29.452]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:29.452]                       if (muffled) 
[13:22:29.452]                         invokeRestart("muffleMessage")
[13:22:29.452]                     }
[13:22:29.452]                     else if (inherits(cond, "warning")) {
[13:22:29.452]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:29.452]                       if (muffled) 
[13:22:29.452]                         invokeRestart("muffleWarning")
[13:22:29.452]                     }
[13:22:29.452]                     else if (inherits(cond, "condition")) {
[13:22:29.452]                       if (!is.null(pattern)) {
[13:22:29.452]                         computeRestarts <- base::computeRestarts
[13:22:29.452]                         grepl <- base::grepl
[13:22:29.452]                         restarts <- computeRestarts(cond)
[13:22:29.452]                         for (restart in restarts) {
[13:22:29.452]                           name <- restart$name
[13:22:29.452]                           if (is.null(name)) 
[13:22:29.452]                             next
[13:22:29.452]                           if (!grepl(pattern, name)) 
[13:22:29.452]                             next
[13:22:29.452]                           invokeRestart(restart)
[13:22:29.452]                           muffled <- TRUE
[13:22:29.452]                           break
[13:22:29.452]                         }
[13:22:29.452]                       }
[13:22:29.452]                     }
[13:22:29.452]                     invisible(muffled)
[13:22:29.452]                   }
[13:22:29.452]                   muffleCondition(cond)
[13:22:29.452]                 })
[13:22:29.452]             }))
[13:22:29.452]             future::FutureResult(value = ...future.value$value, 
[13:22:29.452]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:29.452]                   ...future.rng), globalenv = if (FALSE) 
[13:22:29.452]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:29.452]                     ...future.globalenv.names))
[13:22:29.452]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:29.452]         }, condition = base::local({
[13:22:29.452]             c <- base::c
[13:22:29.452]             inherits <- base::inherits
[13:22:29.452]             invokeRestart <- base::invokeRestart
[13:22:29.452]             length <- base::length
[13:22:29.452]             list <- base::list
[13:22:29.452]             seq.int <- base::seq.int
[13:22:29.452]             signalCondition <- base::signalCondition
[13:22:29.452]             sys.calls <- base::sys.calls
[13:22:29.452]             `[[` <- base::`[[`
[13:22:29.452]             `+` <- base::`+`
[13:22:29.452]             `<<-` <- base::`<<-`
[13:22:29.452]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:29.452]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:29.452]                   3L)]
[13:22:29.452]             }
[13:22:29.452]             function(cond) {
[13:22:29.452]                 is_error <- inherits(cond, "error")
[13:22:29.452]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:29.452]                   NULL)
[13:22:29.452]                 if (is_error) {
[13:22:29.452]                   sessionInformation <- function() {
[13:22:29.452]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:29.452]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:29.452]                       search = base::search(), system = base::Sys.info())
[13:22:29.452]                   }
[13:22:29.452]                   ...future.conditions[[length(...future.conditions) + 
[13:22:29.452]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:29.452]                     cond$call), session = sessionInformation(), 
[13:22:29.452]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:29.452]                   signalCondition(cond)
[13:22:29.452]                 }
[13:22:29.452]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:29.452]                 "immediateCondition"))) {
[13:22:29.452]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:29.452]                   ...future.conditions[[length(...future.conditions) + 
[13:22:29.452]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:29.452]                   if (TRUE && !signal) {
[13:22:29.452]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.452]                     {
[13:22:29.452]                       inherits <- base::inherits
[13:22:29.452]                       invokeRestart <- base::invokeRestart
[13:22:29.452]                       is.null <- base::is.null
[13:22:29.452]                       muffled <- FALSE
[13:22:29.452]                       if (inherits(cond, "message")) {
[13:22:29.452]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:29.452]                         if (muffled) 
[13:22:29.452]                           invokeRestart("muffleMessage")
[13:22:29.452]                       }
[13:22:29.452]                       else if (inherits(cond, "warning")) {
[13:22:29.452]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:29.452]                         if (muffled) 
[13:22:29.452]                           invokeRestart("muffleWarning")
[13:22:29.452]                       }
[13:22:29.452]                       else if (inherits(cond, "condition")) {
[13:22:29.452]                         if (!is.null(pattern)) {
[13:22:29.452]                           computeRestarts <- base::computeRestarts
[13:22:29.452]                           grepl <- base::grepl
[13:22:29.452]                           restarts <- computeRestarts(cond)
[13:22:29.452]                           for (restart in restarts) {
[13:22:29.452]                             name <- restart$name
[13:22:29.452]                             if (is.null(name)) 
[13:22:29.452]                               next
[13:22:29.452]                             if (!grepl(pattern, name)) 
[13:22:29.452]                               next
[13:22:29.452]                             invokeRestart(restart)
[13:22:29.452]                             muffled <- TRUE
[13:22:29.452]                             break
[13:22:29.452]                           }
[13:22:29.452]                         }
[13:22:29.452]                       }
[13:22:29.452]                       invisible(muffled)
[13:22:29.452]                     }
[13:22:29.452]                     muffleCondition(cond, pattern = "^muffle")
[13:22:29.452]                   }
[13:22:29.452]                 }
[13:22:29.452]                 else {
[13:22:29.452]                   if (TRUE) {
[13:22:29.452]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.452]                     {
[13:22:29.452]                       inherits <- base::inherits
[13:22:29.452]                       invokeRestart <- base::invokeRestart
[13:22:29.452]                       is.null <- base::is.null
[13:22:29.452]                       muffled <- FALSE
[13:22:29.452]                       if (inherits(cond, "message")) {
[13:22:29.452]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:29.452]                         if (muffled) 
[13:22:29.452]                           invokeRestart("muffleMessage")
[13:22:29.452]                       }
[13:22:29.452]                       else if (inherits(cond, "warning")) {
[13:22:29.452]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:29.452]                         if (muffled) 
[13:22:29.452]                           invokeRestart("muffleWarning")
[13:22:29.452]                       }
[13:22:29.452]                       else if (inherits(cond, "condition")) {
[13:22:29.452]                         if (!is.null(pattern)) {
[13:22:29.452]                           computeRestarts <- base::computeRestarts
[13:22:29.452]                           grepl <- base::grepl
[13:22:29.452]                           restarts <- computeRestarts(cond)
[13:22:29.452]                           for (restart in restarts) {
[13:22:29.452]                             name <- restart$name
[13:22:29.452]                             if (is.null(name)) 
[13:22:29.452]                               next
[13:22:29.452]                             if (!grepl(pattern, name)) 
[13:22:29.452]                               next
[13:22:29.452]                             invokeRestart(restart)
[13:22:29.452]                             muffled <- TRUE
[13:22:29.452]                             break
[13:22:29.452]                           }
[13:22:29.452]                         }
[13:22:29.452]                       }
[13:22:29.452]                       invisible(muffled)
[13:22:29.452]                     }
[13:22:29.452]                     muffleCondition(cond, pattern = "^muffle")
[13:22:29.452]                   }
[13:22:29.452]                 }
[13:22:29.452]             }
[13:22:29.452]         }))
[13:22:29.452]     }, error = function(ex) {
[13:22:29.452]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:29.452]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:29.452]                 ...future.rng), started = ...future.startTime, 
[13:22:29.452]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:29.452]             version = "1.8"), class = "FutureResult")
[13:22:29.452]     }, finally = {
[13:22:29.452]         if (!identical(...future.workdir, getwd())) 
[13:22:29.452]             setwd(...future.workdir)
[13:22:29.452]         {
[13:22:29.452]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:29.452]                 ...future.oldOptions$nwarnings <- NULL
[13:22:29.452]             }
[13:22:29.452]             base::options(...future.oldOptions)
[13:22:29.452]             if (.Platform$OS.type == "windows") {
[13:22:29.452]                 old_names <- names(...future.oldEnvVars)
[13:22:29.452]                 envs <- base::Sys.getenv()
[13:22:29.452]                 names <- names(envs)
[13:22:29.452]                 common <- intersect(names, old_names)
[13:22:29.452]                 added <- setdiff(names, old_names)
[13:22:29.452]                 removed <- setdiff(old_names, names)
[13:22:29.452]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:29.452]                   envs[common]]
[13:22:29.452]                 NAMES <- toupper(changed)
[13:22:29.452]                 args <- list()
[13:22:29.452]                 for (kk in seq_along(NAMES)) {
[13:22:29.452]                   name <- changed[[kk]]
[13:22:29.452]                   NAME <- NAMES[[kk]]
[13:22:29.452]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.452]                     next
[13:22:29.452]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:29.452]                 }
[13:22:29.452]                 NAMES <- toupper(added)
[13:22:29.452]                 for (kk in seq_along(NAMES)) {
[13:22:29.452]                   name <- added[[kk]]
[13:22:29.452]                   NAME <- NAMES[[kk]]
[13:22:29.452]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.452]                     next
[13:22:29.452]                   args[[name]] <- ""
[13:22:29.452]                 }
[13:22:29.452]                 NAMES <- toupper(removed)
[13:22:29.452]                 for (kk in seq_along(NAMES)) {
[13:22:29.452]                   name <- removed[[kk]]
[13:22:29.452]                   NAME <- NAMES[[kk]]
[13:22:29.452]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.452]                     next
[13:22:29.452]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:29.452]                 }
[13:22:29.452]                 if (length(args) > 0) 
[13:22:29.452]                   base::do.call(base::Sys.setenv, args = args)
[13:22:29.452]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:29.452]             }
[13:22:29.452]             else {
[13:22:29.452]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:29.452]             }
[13:22:29.452]             {
[13:22:29.452]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:29.452]                   0L) {
[13:22:29.452]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:29.452]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:29.452]                   base::options(opts)
[13:22:29.452]                 }
[13:22:29.452]                 {
[13:22:29.452]                   {
[13:22:29.452]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:29.452]                     NULL
[13:22:29.452]                   }
[13:22:29.452]                   options(future.plan = NULL)
[13:22:29.452]                   if (is.na(NA_character_)) 
[13:22:29.452]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:29.452]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:29.452]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:22:29.452]                     envir = parent.frame()) 
[13:22:29.452]                   {
[13:22:29.452]                     default_workers <- missing(workers)
[13:22:29.452]                     if (is.function(workers)) 
[13:22:29.452]                       workers <- workers()
[13:22:29.452]                     workers <- structure(as.integer(workers), 
[13:22:29.452]                       class = class(workers))
[13:22:29.452]                     stop_if_not(is.finite(workers), workers >= 
[13:22:29.452]                       1L)
[13:22:29.452]                     if ((workers == 1L && !inherits(workers, 
[13:22:29.452]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:22:29.452]                       if (default_workers) 
[13:22:29.452]                         supportsMulticore(warn = TRUE)
[13:22:29.452]                       return(sequential(..., envir = envir))
[13:22:29.452]                     }
[13:22:29.452]                     oopts <- options(mc.cores = workers)
[13:22:29.452]                     on.exit(options(oopts))
[13:22:29.452]                     future <- MulticoreFuture(..., workers = workers, 
[13:22:29.452]                       envir = envir)
[13:22:29.452]                     if (!future$lazy) 
[13:22:29.452]                       future <- run(future)
[13:22:29.452]                     invisible(future)
[13:22:29.452]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:29.452]                 }
[13:22:29.452]             }
[13:22:29.452]         }
[13:22:29.452]     })
[13:22:29.452]     if (TRUE) {
[13:22:29.452]         base::sink(type = "output", split = FALSE)
[13:22:29.452]         if (FALSE) {
[13:22:29.452]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:29.452]         }
[13:22:29.452]         else {
[13:22:29.452]             ...future.result["stdout"] <- base::list(NULL)
[13:22:29.452]         }
[13:22:29.452]         base::close(...future.stdout)
[13:22:29.452]         ...future.stdout <- NULL
[13:22:29.452]     }
[13:22:29.452]     ...future.result$conditions <- ...future.conditions
[13:22:29.452]     ...future.result$finished <- base::Sys.time()
[13:22:29.452]     ...future.result
[13:22:29.452] }
[13:22:29.455] requestCore(): workers = 2
[13:22:29.457] MulticoreFuture started
[13:22:29.457] - Launch lazy future ... done
[13:22:29.457] run() for ‘MulticoreFuture’ ... done
[13:22:29.458] plan(): Setting new future strategy stack:
[13:22:29.458] List of future strategies:
[13:22:29.458] 1. sequential:
[13:22:29.458]    - args: function (..., envir = parent.frame())
[13:22:29.458]    - tweaked: FALSE
[13:22:29.458]    - call: NULL
[13:22:29.459] plan(): nbrOfWorkers() = 1
[13:22:29.463] plan(): Setting new future strategy stack:
[13:22:29.463] List of future strategies:
[13:22:29.463] 1. multicore:
[13:22:29.463]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:22:29.463]    - tweaked: FALSE
[13:22:29.463]    - call: plan(strategy)
[13:22:29.468] plan(): nbrOfWorkers() = 2
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-01-07 13:22:29"
 $ finished    : POSIXct[1:1], format: "2025-01-07 13:22:29"
 $ session_uuid: chr "c8349e03-ab12-e4f2-40e8-f76afded70f0"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "5853cd8d1af0"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "5853cd8d1af0" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 93465
  .. ..$ time  : POSIXct[1:1], format: "2025-01-07 13:22:29"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 3 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[13:22:29.482] getGlobalsAndPackages() ...
[13:22:29.482] Searching for globals...
[13:22:29.486] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[13:22:29.486] Searching for globals ... DONE
[13:22:29.487] Resolving globals: FALSE
[13:22:29.487] 
[13:22:29.487] - packages: [1] ‘utils’
[13:22:29.487] getGlobalsAndPackages() ... DONE
[13:22:29.488] run() for ‘Future’ ...
[13:22:29.488] - state: ‘created’
[13:22:29.488] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:22:29.492] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:29.492] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:22:29.492]   - Field: ‘label’
[13:22:29.493]   - Field: ‘local’
[13:22:29.493]   - Field: ‘owner’
[13:22:29.493]   - Field: ‘envir’
[13:22:29.493]   - Field: ‘workers’
[13:22:29.493]   - Field: ‘packages’
[13:22:29.493]   - Field: ‘gc’
[13:22:29.493]   - Field: ‘job’
[13:22:29.493]   - Field: ‘conditions’
[13:22:29.494]   - Field: ‘expr’
[13:22:29.494]   - Field: ‘uuid’
[13:22:29.494]   - Field: ‘seed’
[13:22:29.494]   - Field: ‘version’
[13:22:29.494]   - Field: ‘result’
[13:22:29.494]   - Field: ‘asynchronous’
[13:22:29.494]   - Field: ‘calls’
[13:22:29.494]   - Field: ‘globals’
[13:22:29.494]   - Field: ‘stdout’
[13:22:29.495]   - Field: ‘earlySignal’
[13:22:29.495]   - Field: ‘lazy’
[13:22:29.495]   - Field: ‘state’
[13:22:29.495] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:22:29.495] - Launch lazy future ...
[13:22:29.495] Packages needed by the future expression (n = 1): ‘utils’
[13:22:29.495] Packages needed by future strategies (n = 0): <none>
[13:22:29.496] {
[13:22:29.496]     {
[13:22:29.496]         {
[13:22:29.496]             ...future.startTime <- base::Sys.time()
[13:22:29.496]             {
[13:22:29.496]                 {
[13:22:29.496]                   {
[13:22:29.496]                     {
[13:22:29.496]                       {
[13:22:29.496]                         base::local({
[13:22:29.496]                           has_future <- base::requireNamespace("future", 
[13:22:29.496]                             quietly = TRUE)
[13:22:29.496]                           if (has_future) {
[13:22:29.496]                             ns <- base::getNamespace("future")
[13:22:29.496]                             version <- ns[[".package"]][["version"]]
[13:22:29.496]                             if (is.null(version)) 
[13:22:29.496]                               version <- utils::packageVersion("future")
[13:22:29.496]                           }
[13:22:29.496]                           else {
[13:22:29.496]                             version <- NULL
[13:22:29.496]                           }
[13:22:29.496]                           if (!has_future || version < "1.8.0") {
[13:22:29.496]                             info <- base::c(r_version = base::gsub("R version ", 
[13:22:29.496]                               "", base::R.version$version.string), 
[13:22:29.496]                               platform = base::sprintf("%s (%s-bit)", 
[13:22:29.496]                                 base::R.version$platform, 8 * 
[13:22:29.496]                                   base::.Machine$sizeof.pointer), 
[13:22:29.496]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:29.496]                                 "release", "version")], collapse = " "), 
[13:22:29.496]                               hostname = base::Sys.info()[["nodename"]])
[13:22:29.496]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:22:29.496]                               info)
[13:22:29.496]                             info <- base::paste(info, collapse = "; ")
[13:22:29.496]                             if (!has_future) {
[13:22:29.496]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:29.496]                                 info)
[13:22:29.496]                             }
[13:22:29.496]                             else {
[13:22:29.496]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:29.496]                                 info, version)
[13:22:29.496]                             }
[13:22:29.496]                             base::stop(msg)
[13:22:29.496]                           }
[13:22:29.496]                         })
[13:22:29.496]                       }
[13:22:29.496]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:29.496]                       base::options(mc.cores = 1L)
[13:22:29.496]                     }
[13:22:29.496]                     base::local({
[13:22:29.496]                       for (pkg in "utils") {
[13:22:29.496]                         base::loadNamespace(pkg)
[13:22:29.496]                         base::library(pkg, character.only = TRUE)
[13:22:29.496]                       }
[13:22:29.496]                     })
[13:22:29.496]                   }
[13:22:29.496]                   options(future.plan = NULL)
[13:22:29.496]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:29.496]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:29.496]                 }
[13:22:29.496]                 ...future.workdir <- getwd()
[13:22:29.496]             }
[13:22:29.496]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:29.496]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:29.496]         }
[13:22:29.496]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:29.496]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:29.496]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:29.496]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:29.496]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:29.496]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:29.496]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:29.496]             base::names(...future.oldOptions))
[13:22:29.496]     }
[13:22:29.496]     if (FALSE) {
[13:22:29.496]     }
[13:22:29.496]     else {
[13:22:29.496]         if (FALSE) {
[13:22:29.496]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:29.496]                 open = "w")
[13:22:29.496]         }
[13:22:29.496]         else {
[13:22:29.496]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:29.496]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:29.496]         }
[13:22:29.496]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:29.496]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:29.496]             base::sink(type = "output", split = FALSE)
[13:22:29.496]             base::close(...future.stdout)
[13:22:29.496]         }, add = TRUE)
[13:22:29.496]     }
[13:22:29.496]     ...future.frame <- base::sys.nframe()
[13:22:29.496]     ...future.conditions <- base::list()
[13:22:29.496]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:29.496]     if (FALSE) {
[13:22:29.496]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:29.496]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:29.496]     }
[13:22:29.496]     ...future.result <- base::tryCatch({
[13:22:29.496]         base::withCallingHandlers({
[13:22:29.496]             ...future.value <- base::withVisible(base::local({
[13:22:29.496]                 withCallingHandlers({
[13:22:29.496]                   {
[13:22:29.496]                     print(1:50)
[13:22:29.496]                     str(1:50)
[13:22:29.496]                     cat(letters, sep = "-")
[13:22:29.496]                     cat(1:6, collapse = "\n")
[13:22:29.496]                     write.table(datasets::iris[1:10, ], sep = "\t")
[13:22:29.496]                     42L
[13:22:29.496]                   }
[13:22:29.496]                 }, immediateCondition = function(cond) {
[13:22:29.496]                   save_rds <- function (object, pathname, ...) 
[13:22:29.496]                   {
[13:22:29.496]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:22:29.496]                     if (file_test("-f", pathname_tmp)) {
[13:22:29.496]                       fi_tmp <- file.info(pathname_tmp)
[13:22:29.496]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:22:29.496]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:29.496]                         fi_tmp[["mtime"]])
[13:22:29.496]                     }
[13:22:29.496]                     tryCatch({
[13:22:29.496]                       saveRDS(object, file = pathname_tmp, ...)
[13:22:29.496]                     }, error = function(ex) {
[13:22:29.496]                       msg <- conditionMessage(ex)
[13:22:29.496]                       fi_tmp <- file.info(pathname_tmp)
[13:22:29.496]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:22:29.496]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:29.496]                         fi_tmp[["mtime"]], msg)
[13:22:29.496]                       ex$message <- msg
[13:22:29.496]                       stop(ex)
[13:22:29.496]                     })
[13:22:29.496]                     stopifnot(file_test("-f", pathname_tmp))
[13:22:29.496]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:22:29.496]                     if (!res || file_test("-f", pathname_tmp)) {
[13:22:29.496]                       fi_tmp <- file.info(pathname_tmp)
[13:22:29.496]                       fi <- file.info(pathname)
[13:22:29.496]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:22:29.496]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:29.496]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:22:29.496]                         fi[["size"]], fi[["mtime"]])
[13:22:29.496]                       stop(msg)
[13:22:29.496]                     }
[13:22:29.496]                     invisible(pathname)
[13:22:29.496]                   }
[13:22:29.496]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:22:29.496]                     rootPath = tempdir()) 
[13:22:29.496]                   {
[13:22:29.496]                     obj <- list(time = Sys.time(), condition = cond)
[13:22:29.496]                     file <- tempfile(pattern = class(cond)[1], 
[13:22:29.496]                       tmpdir = path, fileext = ".rds")
[13:22:29.496]                     save_rds(obj, file)
[13:22:29.496]                   }
[13:22:29.496]                   saveImmediateCondition(cond, path = "/tmp/RtmpeTCoqm/.future/immediateConditions")
[13:22:29.496]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.496]                   {
[13:22:29.496]                     inherits <- base::inherits
[13:22:29.496]                     invokeRestart <- base::invokeRestart
[13:22:29.496]                     is.null <- base::is.null
[13:22:29.496]                     muffled <- FALSE
[13:22:29.496]                     if (inherits(cond, "message")) {
[13:22:29.496]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:29.496]                       if (muffled) 
[13:22:29.496]                         invokeRestart("muffleMessage")
[13:22:29.496]                     }
[13:22:29.496]                     else if (inherits(cond, "warning")) {
[13:22:29.496]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:29.496]                       if (muffled) 
[13:22:29.496]                         invokeRestart("muffleWarning")
[13:22:29.496]                     }
[13:22:29.496]                     else if (inherits(cond, "condition")) {
[13:22:29.496]                       if (!is.null(pattern)) {
[13:22:29.496]                         computeRestarts <- base::computeRestarts
[13:22:29.496]                         grepl <- base::grepl
[13:22:29.496]                         restarts <- computeRestarts(cond)
[13:22:29.496]                         for (restart in restarts) {
[13:22:29.496]                           name <- restart$name
[13:22:29.496]                           if (is.null(name)) 
[13:22:29.496]                             next
[13:22:29.496]                           if (!grepl(pattern, name)) 
[13:22:29.496]                             next
[13:22:29.496]                           invokeRestart(restart)
[13:22:29.496]                           muffled <- TRUE
[13:22:29.496]                           break
[13:22:29.496]                         }
[13:22:29.496]                       }
[13:22:29.496]                     }
[13:22:29.496]                     invisible(muffled)
[13:22:29.496]                   }
[13:22:29.496]                   muffleCondition(cond)
[13:22:29.496]                 })
[13:22:29.496]             }))
[13:22:29.496]             future::FutureResult(value = ...future.value$value, 
[13:22:29.496]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:29.496]                   ...future.rng), globalenv = if (FALSE) 
[13:22:29.496]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:29.496]                     ...future.globalenv.names))
[13:22:29.496]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:29.496]         }, condition = base::local({
[13:22:29.496]             c <- base::c
[13:22:29.496]             inherits <- base::inherits
[13:22:29.496]             invokeRestart <- base::invokeRestart
[13:22:29.496]             length <- base::length
[13:22:29.496]             list <- base::list
[13:22:29.496]             seq.int <- base::seq.int
[13:22:29.496]             signalCondition <- base::signalCondition
[13:22:29.496]             sys.calls <- base::sys.calls
[13:22:29.496]             `[[` <- base::`[[`
[13:22:29.496]             `+` <- base::`+`
[13:22:29.496]             `<<-` <- base::`<<-`
[13:22:29.496]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:29.496]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:29.496]                   3L)]
[13:22:29.496]             }
[13:22:29.496]             function(cond) {
[13:22:29.496]                 is_error <- inherits(cond, "error")
[13:22:29.496]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:29.496]                   NULL)
[13:22:29.496]                 if (is_error) {
[13:22:29.496]                   sessionInformation <- function() {
[13:22:29.496]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:29.496]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:29.496]                       search = base::search(), system = base::Sys.info())
[13:22:29.496]                   }
[13:22:29.496]                   ...future.conditions[[length(...future.conditions) + 
[13:22:29.496]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:29.496]                     cond$call), session = sessionInformation(), 
[13:22:29.496]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:29.496]                   signalCondition(cond)
[13:22:29.496]                 }
[13:22:29.496]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:29.496]                 "immediateCondition"))) {
[13:22:29.496]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:29.496]                   ...future.conditions[[length(...future.conditions) + 
[13:22:29.496]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:29.496]                   if (TRUE && !signal) {
[13:22:29.496]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.496]                     {
[13:22:29.496]                       inherits <- base::inherits
[13:22:29.496]                       invokeRestart <- base::invokeRestart
[13:22:29.496]                       is.null <- base::is.null
[13:22:29.496]                       muffled <- FALSE
[13:22:29.496]                       if (inherits(cond, "message")) {
[13:22:29.496]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:29.496]                         if (muffled) 
[13:22:29.496]                           invokeRestart("muffleMessage")
[13:22:29.496]                       }
[13:22:29.496]                       else if (inherits(cond, "warning")) {
[13:22:29.496]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:29.496]                         if (muffled) 
[13:22:29.496]                           invokeRestart("muffleWarning")
[13:22:29.496]                       }
[13:22:29.496]                       else if (inherits(cond, "condition")) {
[13:22:29.496]                         if (!is.null(pattern)) {
[13:22:29.496]                           computeRestarts <- base::computeRestarts
[13:22:29.496]                           grepl <- base::grepl
[13:22:29.496]                           restarts <- computeRestarts(cond)
[13:22:29.496]                           for (restart in restarts) {
[13:22:29.496]                             name <- restart$name
[13:22:29.496]                             if (is.null(name)) 
[13:22:29.496]                               next
[13:22:29.496]                             if (!grepl(pattern, name)) 
[13:22:29.496]                               next
[13:22:29.496]                             invokeRestart(restart)
[13:22:29.496]                             muffled <- TRUE
[13:22:29.496]                             break
[13:22:29.496]                           }
[13:22:29.496]                         }
[13:22:29.496]                       }
[13:22:29.496]                       invisible(muffled)
[13:22:29.496]                     }
[13:22:29.496]                     muffleCondition(cond, pattern = "^muffle")
[13:22:29.496]                   }
[13:22:29.496]                 }
[13:22:29.496]                 else {
[13:22:29.496]                   if (TRUE) {
[13:22:29.496]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.496]                     {
[13:22:29.496]                       inherits <- base::inherits
[13:22:29.496]                       invokeRestart <- base::invokeRestart
[13:22:29.496]                       is.null <- base::is.null
[13:22:29.496]                       muffled <- FALSE
[13:22:29.496]                       if (inherits(cond, "message")) {
[13:22:29.496]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:29.496]                         if (muffled) 
[13:22:29.496]                           invokeRestart("muffleMessage")
[13:22:29.496]                       }
[13:22:29.496]                       else if (inherits(cond, "warning")) {
[13:22:29.496]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:29.496]                         if (muffled) 
[13:22:29.496]                           invokeRestart("muffleWarning")
[13:22:29.496]                       }
[13:22:29.496]                       else if (inherits(cond, "condition")) {
[13:22:29.496]                         if (!is.null(pattern)) {
[13:22:29.496]                           computeRestarts <- base::computeRestarts
[13:22:29.496]                           grepl <- base::grepl
[13:22:29.496]                           restarts <- computeRestarts(cond)
[13:22:29.496]                           for (restart in restarts) {
[13:22:29.496]                             name <- restart$name
[13:22:29.496]                             if (is.null(name)) 
[13:22:29.496]                               next
[13:22:29.496]                             if (!grepl(pattern, name)) 
[13:22:29.496]                               next
[13:22:29.496]                             invokeRestart(restart)
[13:22:29.496]                             muffled <- TRUE
[13:22:29.496]                             break
[13:22:29.496]                           }
[13:22:29.496]                         }
[13:22:29.496]                       }
[13:22:29.496]                       invisible(muffled)
[13:22:29.496]                     }
[13:22:29.496]                     muffleCondition(cond, pattern = "^muffle")
[13:22:29.496]                   }
[13:22:29.496]                 }
[13:22:29.496]             }
[13:22:29.496]         }))
[13:22:29.496]     }, error = function(ex) {
[13:22:29.496]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:29.496]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:29.496]                 ...future.rng), started = ...future.startTime, 
[13:22:29.496]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:29.496]             version = "1.8"), class = "FutureResult")
[13:22:29.496]     }, finally = {
[13:22:29.496]         if (!identical(...future.workdir, getwd())) 
[13:22:29.496]             setwd(...future.workdir)
[13:22:29.496]         {
[13:22:29.496]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:29.496]                 ...future.oldOptions$nwarnings <- NULL
[13:22:29.496]             }
[13:22:29.496]             base::options(...future.oldOptions)
[13:22:29.496]             if (.Platform$OS.type == "windows") {
[13:22:29.496]                 old_names <- names(...future.oldEnvVars)
[13:22:29.496]                 envs <- base::Sys.getenv()
[13:22:29.496]                 names <- names(envs)
[13:22:29.496]                 common <- intersect(names, old_names)
[13:22:29.496]                 added <- setdiff(names, old_names)
[13:22:29.496]                 removed <- setdiff(old_names, names)
[13:22:29.496]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:29.496]                   envs[common]]
[13:22:29.496]                 NAMES <- toupper(changed)
[13:22:29.496]                 args <- list()
[13:22:29.496]                 for (kk in seq_along(NAMES)) {
[13:22:29.496]                   name <- changed[[kk]]
[13:22:29.496]                   NAME <- NAMES[[kk]]
[13:22:29.496]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.496]                     next
[13:22:29.496]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:29.496]                 }
[13:22:29.496]                 NAMES <- toupper(added)
[13:22:29.496]                 for (kk in seq_along(NAMES)) {
[13:22:29.496]                   name <- added[[kk]]
[13:22:29.496]                   NAME <- NAMES[[kk]]
[13:22:29.496]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.496]                     next
[13:22:29.496]                   args[[name]] <- ""
[13:22:29.496]                 }
[13:22:29.496]                 NAMES <- toupper(removed)
[13:22:29.496]                 for (kk in seq_along(NAMES)) {
[13:22:29.496]                   name <- removed[[kk]]
[13:22:29.496]                   NAME <- NAMES[[kk]]
[13:22:29.496]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.496]                     next
[13:22:29.496]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:29.496]                 }
[13:22:29.496]                 if (length(args) > 0) 
[13:22:29.496]                   base::do.call(base::Sys.setenv, args = args)
[13:22:29.496]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:29.496]             }
[13:22:29.496]             else {
[13:22:29.496]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:29.496]             }
[13:22:29.496]             {
[13:22:29.496]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:29.496]                   0L) {
[13:22:29.496]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:29.496]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:29.496]                   base::options(opts)
[13:22:29.496]                 }
[13:22:29.496]                 {
[13:22:29.496]                   {
[13:22:29.496]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:29.496]                     NULL
[13:22:29.496]                   }
[13:22:29.496]                   options(future.plan = NULL)
[13:22:29.496]                   if (is.na(NA_character_)) 
[13:22:29.496]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:29.496]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:29.496]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:22:29.496]                     envir = parent.frame()) 
[13:22:29.496]                   {
[13:22:29.496]                     default_workers <- missing(workers)
[13:22:29.496]                     if (is.function(workers)) 
[13:22:29.496]                       workers <- workers()
[13:22:29.496]                     workers <- structure(as.integer(workers), 
[13:22:29.496]                       class = class(workers))
[13:22:29.496]                     stop_if_not(is.finite(workers), workers >= 
[13:22:29.496]                       1L)
[13:22:29.496]                     if ((workers == 1L && !inherits(workers, 
[13:22:29.496]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:22:29.496]                       if (default_workers) 
[13:22:29.496]                         supportsMulticore(warn = TRUE)
[13:22:29.496]                       return(sequential(..., envir = envir))
[13:22:29.496]                     }
[13:22:29.496]                     oopts <- options(mc.cores = workers)
[13:22:29.496]                     on.exit(options(oopts))
[13:22:29.496]                     future <- MulticoreFuture(..., workers = workers, 
[13:22:29.496]                       envir = envir)
[13:22:29.496]                     if (!future$lazy) 
[13:22:29.496]                       future <- run(future)
[13:22:29.496]                     invisible(future)
[13:22:29.496]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:29.496]                 }
[13:22:29.496]             }
[13:22:29.496]         }
[13:22:29.496]     })
[13:22:29.496]     if (TRUE) {
[13:22:29.496]         base::sink(type = "output", split = FALSE)
[13:22:29.496]         if (FALSE) {
[13:22:29.496]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:29.496]         }
[13:22:29.496]         else {
[13:22:29.496]             ...future.result["stdout"] <- base::list(NULL)
[13:22:29.496]         }
[13:22:29.496]         base::close(...future.stdout)
[13:22:29.496]         ...future.stdout <- NULL
[13:22:29.496]     }
[13:22:29.496]     ...future.result$conditions <- ...future.conditions
[13:22:29.496]     ...future.result$finished <- base::Sys.time()
[13:22:29.496]     ...future.result
[13:22:29.496] }
[13:22:29.499] requestCore(): workers = 2
[13:22:29.501] MulticoreFuture started
[13:22:29.501] - Launch lazy future ... done
[13:22:29.501] run() for ‘MulticoreFuture’ ... done
[13:22:29.502] plan(): Setting new future strategy stack:
[13:22:29.502] List of future strategies:
[13:22:29.502] 1. sequential:
[13:22:29.502]    - args: function (..., envir = parent.frame())
[13:22:29.502]    - tweaked: FALSE
[13:22:29.502]    - call: NULL
[13:22:29.503] plan(): nbrOfWorkers() = 1
[13:22:29.507] plan(): Setting new future strategy stack:
[13:22:29.507] List of future strategies:
[13:22:29.507] 1. multicore:
[13:22:29.507]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:22:29.507]    - tweaked: FALSE
[13:22:29.507]    - call: plan(strategy)
[13:22:29.513] plan(): nbrOfWorkers() = 2
- stdout = structure(TRUE, drop = TRUE)
[13:22:29.514] getGlobalsAndPackages() ...
[13:22:29.514] Searching for globals...
[13:22:29.515] - globals found: [1] ‘print’
[13:22:29.515] Searching for globals ... DONE
[13:22:29.515] Resolving globals: FALSE
[13:22:29.516] 
[13:22:29.516] 
[13:22:29.516] getGlobalsAndPackages() ... DONE
[13:22:29.516] run() for ‘Future’ ...
[13:22:29.517] - state: ‘created’
[13:22:29.517] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:22:29.521] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:29.521] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:22:29.521]   - Field: ‘label’
[13:22:29.521]   - Field: ‘local’
[13:22:29.521]   - Field: ‘owner’
[13:22:29.522]   - Field: ‘envir’
[13:22:29.522]   - Field: ‘workers’
[13:22:29.522]   - Field: ‘packages’
[13:22:29.522]   - Field: ‘gc’
[13:22:29.522]   - Field: ‘job’
[13:22:29.522]   - Field: ‘conditions’
[13:22:29.522]   - Field: ‘expr’
[13:22:29.522]   - Field: ‘uuid’
[13:22:29.522]   - Field: ‘seed’
[13:22:29.523]   - Field: ‘version’
[13:22:29.523]   - Field: ‘result’
[13:22:29.523]   - Field: ‘asynchronous’
[13:22:29.523]   - Field: ‘calls’
[13:22:29.523]   - Field: ‘globals’
[13:22:29.523]   - Field: ‘stdout’
[13:22:29.523]   - Field: ‘earlySignal’
[13:22:29.523]   - Field: ‘lazy’
[13:22:29.523]   - Field: ‘state’
[13:22:29.524] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:22:29.524] - Launch lazy future ...
[13:22:29.524] Packages needed by the future expression (n = 0): <none>
[13:22:29.524] Packages needed by future strategies (n = 0): <none>
[13:22:29.525] {
[13:22:29.525]     {
[13:22:29.525]         {
[13:22:29.525]             ...future.startTime <- base::Sys.time()
[13:22:29.525]             {
[13:22:29.525]                 {
[13:22:29.525]                   {
[13:22:29.525]                     {
[13:22:29.525]                       base::local({
[13:22:29.525]                         has_future <- base::requireNamespace("future", 
[13:22:29.525]                           quietly = TRUE)
[13:22:29.525]                         if (has_future) {
[13:22:29.525]                           ns <- base::getNamespace("future")
[13:22:29.525]                           version <- ns[[".package"]][["version"]]
[13:22:29.525]                           if (is.null(version)) 
[13:22:29.525]                             version <- utils::packageVersion("future")
[13:22:29.525]                         }
[13:22:29.525]                         else {
[13:22:29.525]                           version <- NULL
[13:22:29.525]                         }
[13:22:29.525]                         if (!has_future || version < "1.8.0") {
[13:22:29.525]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:29.525]                             "", base::R.version$version.string), 
[13:22:29.525]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:29.525]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:29.525]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:29.525]                               "release", "version")], collapse = " "), 
[13:22:29.525]                             hostname = base::Sys.info()[["nodename"]])
[13:22:29.525]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:29.525]                             info)
[13:22:29.525]                           info <- base::paste(info, collapse = "; ")
[13:22:29.525]                           if (!has_future) {
[13:22:29.525]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:29.525]                               info)
[13:22:29.525]                           }
[13:22:29.525]                           else {
[13:22:29.525]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:29.525]                               info, version)
[13:22:29.525]                           }
[13:22:29.525]                           base::stop(msg)
[13:22:29.525]                         }
[13:22:29.525]                       })
[13:22:29.525]                     }
[13:22:29.525]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:29.525]                     base::options(mc.cores = 1L)
[13:22:29.525]                   }
[13:22:29.525]                   options(future.plan = NULL)
[13:22:29.525]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:29.525]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:29.525]                 }
[13:22:29.525]                 ...future.workdir <- getwd()
[13:22:29.525]             }
[13:22:29.525]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:29.525]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:29.525]         }
[13:22:29.525]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:29.525]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:29.525]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:29.525]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:29.525]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:29.525]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:29.525]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:29.525]             base::names(...future.oldOptions))
[13:22:29.525]     }
[13:22:29.525]     if (FALSE) {
[13:22:29.525]     }
[13:22:29.525]     else {
[13:22:29.525]         if (TRUE) {
[13:22:29.525]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:29.525]                 open = "w")
[13:22:29.525]         }
[13:22:29.525]         else {
[13:22:29.525]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:29.525]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:29.525]         }
[13:22:29.525]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:29.525]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:29.525]             base::sink(type = "output", split = FALSE)
[13:22:29.525]             base::close(...future.stdout)
[13:22:29.525]         }, add = TRUE)
[13:22:29.525]     }
[13:22:29.525]     ...future.frame <- base::sys.nframe()
[13:22:29.525]     ...future.conditions <- base::list()
[13:22:29.525]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:29.525]     if (FALSE) {
[13:22:29.525]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:29.525]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:29.525]     }
[13:22:29.525]     ...future.result <- base::tryCatch({
[13:22:29.525]         base::withCallingHandlers({
[13:22:29.525]             ...future.value <- base::withVisible(base::local({
[13:22:29.525]                 withCallingHandlers({
[13:22:29.525]                   print(42)
[13:22:29.525]                 }, immediateCondition = function(cond) {
[13:22:29.525]                   save_rds <- function (object, pathname, ...) 
[13:22:29.525]                   {
[13:22:29.525]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:22:29.525]                     if (file_test("-f", pathname_tmp)) {
[13:22:29.525]                       fi_tmp <- file.info(pathname_tmp)
[13:22:29.525]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:22:29.525]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:29.525]                         fi_tmp[["mtime"]])
[13:22:29.525]                     }
[13:22:29.525]                     tryCatch({
[13:22:29.525]                       saveRDS(object, file = pathname_tmp, ...)
[13:22:29.525]                     }, error = function(ex) {
[13:22:29.525]                       msg <- conditionMessage(ex)
[13:22:29.525]                       fi_tmp <- file.info(pathname_tmp)
[13:22:29.525]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:22:29.525]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:29.525]                         fi_tmp[["mtime"]], msg)
[13:22:29.525]                       ex$message <- msg
[13:22:29.525]                       stop(ex)
[13:22:29.525]                     })
[13:22:29.525]                     stopifnot(file_test("-f", pathname_tmp))
[13:22:29.525]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:22:29.525]                     if (!res || file_test("-f", pathname_tmp)) {
[13:22:29.525]                       fi_tmp <- file.info(pathname_tmp)
[13:22:29.525]                       fi <- file.info(pathname)
[13:22:29.525]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:22:29.525]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:29.525]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:22:29.525]                         fi[["size"]], fi[["mtime"]])
[13:22:29.525]                       stop(msg)
[13:22:29.525]                     }
[13:22:29.525]                     invisible(pathname)
[13:22:29.525]                   }
[13:22:29.525]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:22:29.525]                     rootPath = tempdir()) 
[13:22:29.525]                   {
[13:22:29.525]                     obj <- list(time = Sys.time(), condition = cond)
[13:22:29.525]                     file <- tempfile(pattern = class(cond)[1], 
[13:22:29.525]                       tmpdir = path, fileext = ".rds")
[13:22:29.525]                     save_rds(obj, file)
[13:22:29.525]                   }
[13:22:29.525]                   saveImmediateCondition(cond, path = "/tmp/RtmpeTCoqm/.future/immediateConditions")
[13:22:29.525]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.525]                   {
[13:22:29.525]                     inherits <- base::inherits
[13:22:29.525]                     invokeRestart <- base::invokeRestart
[13:22:29.525]                     is.null <- base::is.null
[13:22:29.525]                     muffled <- FALSE
[13:22:29.525]                     if (inherits(cond, "message")) {
[13:22:29.525]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:29.525]                       if (muffled) 
[13:22:29.525]                         invokeRestart("muffleMessage")
[13:22:29.525]                     }
[13:22:29.525]                     else if (inherits(cond, "warning")) {
[13:22:29.525]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:29.525]                       if (muffled) 
[13:22:29.525]                         invokeRestart("muffleWarning")
[13:22:29.525]                     }
[13:22:29.525]                     else if (inherits(cond, "condition")) {
[13:22:29.525]                       if (!is.null(pattern)) {
[13:22:29.525]                         computeRestarts <- base::computeRestarts
[13:22:29.525]                         grepl <- base::grepl
[13:22:29.525]                         restarts <- computeRestarts(cond)
[13:22:29.525]                         for (restart in restarts) {
[13:22:29.525]                           name <- restart$name
[13:22:29.525]                           if (is.null(name)) 
[13:22:29.525]                             next
[13:22:29.525]                           if (!grepl(pattern, name)) 
[13:22:29.525]                             next
[13:22:29.525]                           invokeRestart(restart)
[13:22:29.525]                           muffled <- TRUE
[13:22:29.525]                           break
[13:22:29.525]                         }
[13:22:29.525]                       }
[13:22:29.525]                     }
[13:22:29.525]                     invisible(muffled)
[13:22:29.525]                   }
[13:22:29.525]                   muffleCondition(cond)
[13:22:29.525]                 })
[13:22:29.525]             }))
[13:22:29.525]             future::FutureResult(value = ...future.value$value, 
[13:22:29.525]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:29.525]                   ...future.rng), globalenv = if (FALSE) 
[13:22:29.525]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:29.525]                     ...future.globalenv.names))
[13:22:29.525]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:29.525]         }, condition = base::local({
[13:22:29.525]             c <- base::c
[13:22:29.525]             inherits <- base::inherits
[13:22:29.525]             invokeRestart <- base::invokeRestart
[13:22:29.525]             length <- base::length
[13:22:29.525]             list <- base::list
[13:22:29.525]             seq.int <- base::seq.int
[13:22:29.525]             signalCondition <- base::signalCondition
[13:22:29.525]             sys.calls <- base::sys.calls
[13:22:29.525]             `[[` <- base::`[[`
[13:22:29.525]             `+` <- base::`+`
[13:22:29.525]             `<<-` <- base::`<<-`
[13:22:29.525]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:29.525]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:29.525]                   3L)]
[13:22:29.525]             }
[13:22:29.525]             function(cond) {
[13:22:29.525]                 is_error <- inherits(cond, "error")
[13:22:29.525]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:29.525]                   NULL)
[13:22:29.525]                 if (is_error) {
[13:22:29.525]                   sessionInformation <- function() {
[13:22:29.525]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:29.525]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:29.525]                       search = base::search(), system = base::Sys.info())
[13:22:29.525]                   }
[13:22:29.525]                   ...future.conditions[[length(...future.conditions) + 
[13:22:29.525]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:29.525]                     cond$call), session = sessionInformation(), 
[13:22:29.525]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:29.525]                   signalCondition(cond)
[13:22:29.525]                 }
[13:22:29.525]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:29.525]                 "immediateCondition"))) {
[13:22:29.525]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:29.525]                   ...future.conditions[[length(...future.conditions) + 
[13:22:29.525]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:29.525]                   if (TRUE && !signal) {
[13:22:29.525]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.525]                     {
[13:22:29.525]                       inherits <- base::inherits
[13:22:29.525]                       invokeRestart <- base::invokeRestart
[13:22:29.525]                       is.null <- base::is.null
[13:22:29.525]                       muffled <- FALSE
[13:22:29.525]                       if (inherits(cond, "message")) {
[13:22:29.525]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:29.525]                         if (muffled) 
[13:22:29.525]                           invokeRestart("muffleMessage")
[13:22:29.525]                       }
[13:22:29.525]                       else if (inherits(cond, "warning")) {
[13:22:29.525]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:29.525]                         if (muffled) 
[13:22:29.525]                           invokeRestart("muffleWarning")
[13:22:29.525]                       }
[13:22:29.525]                       else if (inherits(cond, "condition")) {
[13:22:29.525]                         if (!is.null(pattern)) {
[13:22:29.525]                           computeRestarts <- base::computeRestarts
[13:22:29.525]                           grepl <- base::grepl
[13:22:29.525]                           restarts <- computeRestarts(cond)
[13:22:29.525]                           for (restart in restarts) {
[13:22:29.525]                             name <- restart$name
[13:22:29.525]                             if (is.null(name)) 
[13:22:29.525]                               next
[13:22:29.525]                             if (!grepl(pattern, name)) 
[13:22:29.525]                               next
[13:22:29.525]                             invokeRestart(restart)
[13:22:29.525]                             muffled <- TRUE
[13:22:29.525]                             break
[13:22:29.525]                           }
[13:22:29.525]                         }
[13:22:29.525]                       }
[13:22:29.525]                       invisible(muffled)
[13:22:29.525]                     }
[13:22:29.525]                     muffleCondition(cond, pattern = "^muffle")
[13:22:29.525]                   }
[13:22:29.525]                 }
[13:22:29.525]                 else {
[13:22:29.525]                   if (TRUE) {
[13:22:29.525]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.525]                     {
[13:22:29.525]                       inherits <- base::inherits
[13:22:29.525]                       invokeRestart <- base::invokeRestart
[13:22:29.525]                       is.null <- base::is.null
[13:22:29.525]                       muffled <- FALSE
[13:22:29.525]                       if (inherits(cond, "message")) {
[13:22:29.525]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:29.525]                         if (muffled) 
[13:22:29.525]                           invokeRestart("muffleMessage")
[13:22:29.525]                       }
[13:22:29.525]                       else if (inherits(cond, "warning")) {
[13:22:29.525]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:29.525]                         if (muffled) 
[13:22:29.525]                           invokeRestart("muffleWarning")
[13:22:29.525]                       }
[13:22:29.525]                       else if (inherits(cond, "condition")) {
[13:22:29.525]                         if (!is.null(pattern)) {
[13:22:29.525]                           computeRestarts <- base::computeRestarts
[13:22:29.525]                           grepl <- base::grepl
[13:22:29.525]                           restarts <- computeRestarts(cond)
[13:22:29.525]                           for (restart in restarts) {
[13:22:29.525]                             name <- restart$name
[13:22:29.525]                             if (is.null(name)) 
[13:22:29.525]                               next
[13:22:29.525]                             if (!grepl(pattern, name)) 
[13:22:29.525]                               next
[13:22:29.525]                             invokeRestart(restart)
[13:22:29.525]                             muffled <- TRUE
[13:22:29.525]                             break
[13:22:29.525]                           }
[13:22:29.525]                         }
[13:22:29.525]                       }
[13:22:29.525]                       invisible(muffled)
[13:22:29.525]                     }
[13:22:29.525]                     muffleCondition(cond, pattern = "^muffle")
[13:22:29.525]                   }
[13:22:29.525]                 }
[13:22:29.525]             }
[13:22:29.525]         }))
[13:22:29.525]     }, error = function(ex) {
[13:22:29.525]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:29.525]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:29.525]                 ...future.rng), started = ...future.startTime, 
[13:22:29.525]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:29.525]             version = "1.8"), class = "FutureResult")
[13:22:29.525]     }, finally = {
[13:22:29.525]         if (!identical(...future.workdir, getwd())) 
[13:22:29.525]             setwd(...future.workdir)
[13:22:29.525]         {
[13:22:29.525]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:29.525]                 ...future.oldOptions$nwarnings <- NULL
[13:22:29.525]             }
[13:22:29.525]             base::options(...future.oldOptions)
[13:22:29.525]             if (.Platform$OS.type == "windows") {
[13:22:29.525]                 old_names <- names(...future.oldEnvVars)
[13:22:29.525]                 envs <- base::Sys.getenv()
[13:22:29.525]                 names <- names(envs)
[13:22:29.525]                 common <- intersect(names, old_names)
[13:22:29.525]                 added <- setdiff(names, old_names)
[13:22:29.525]                 removed <- setdiff(old_names, names)
[13:22:29.525]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:29.525]                   envs[common]]
[13:22:29.525]                 NAMES <- toupper(changed)
[13:22:29.525]                 args <- list()
[13:22:29.525]                 for (kk in seq_along(NAMES)) {
[13:22:29.525]                   name <- changed[[kk]]
[13:22:29.525]                   NAME <- NAMES[[kk]]
[13:22:29.525]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.525]                     next
[13:22:29.525]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:29.525]                 }
[13:22:29.525]                 NAMES <- toupper(added)
[13:22:29.525]                 for (kk in seq_along(NAMES)) {
[13:22:29.525]                   name <- added[[kk]]
[13:22:29.525]                   NAME <- NAMES[[kk]]
[13:22:29.525]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.525]                     next
[13:22:29.525]                   args[[name]] <- ""
[13:22:29.525]                 }
[13:22:29.525]                 NAMES <- toupper(removed)
[13:22:29.525]                 for (kk in seq_along(NAMES)) {
[13:22:29.525]                   name <- removed[[kk]]
[13:22:29.525]                   NAME <- NAMES[[kk]]
[13:22:29.525]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.525]                     next
[13:22:29.525]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:29.525]                 }
[13:22:29.525]                 if (length(args) > 0) 
[13:22:29.525]                   base::do.call(base::Sys.setenv, args = args)
[13:22:29.525]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:29.525]             }
[13:22:29.525]             else {
[13:22:29.525]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:29.525]             }
[13:22:29.525]             {
[13:22:29.525]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:29.525]                   0L) {
[13:22:29.525]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:29.525]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:29.525]                   base::options(opts)
[13:22:29.525]                 }
[13:22:29.525]                 {
[13:22:29.525]                   {
[13:22:29.525]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:29.525]                     NULL
[13:22:29.525]                   }
[13:22:29.525]                   options(future.plan = NULL)
[13:22:29.525]                   if (is.na(NA_character_)) 
[13:22:29.525]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:29.525]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:29.525]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:22:29.525]                     envir = parent.frame()) 
[13:22:29.525]                   {
[13:22:29.525]                     default_workers <- missing(workers)
[13:22:29.525]                     if (is.function(workers)) 
[13:22:29.525]                       workers <- workers()
[13:22:29.525]                     workers <- structure(as.integer(workers), 
[13:22:29.525]                       class = class(workers))
[13:22:29.525]                     stop_if_not(is.finite(workers), workers >= 
[13:22:29.525]                       1L)
[13:22:29.525]                     if ((workers == 1L && !inherits(workers, 
[13:22:29.525]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:22:29.525]                       if (default_workers) 
[13:22:29.525]                         supportsMulticore(warn = TRUE)
[13:22:29.525]                       return(sequential(..., envir = envir))
[13:22:29.525]                     }
[13:22:29.525]                     oopts <- options(mc.cores = workers)
[13:22:29.525]                     on.exit(options(oopts))
[13:22:29.525]                     future <- MulticoreFuture(..., workers = workers, 
[13:22:29.525]                       envir = envir)
[13:22:29.525]                     if (!future$lazy) 
[13:22:29.525]                       future <- run(future)
[13:22:29.525]                     invisible(future)
[13:22:29.525]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:29.525]                 }
[13:22:29.525]             }
[13:22:29.525]         }
[13:22:29.525]     })
[13:22:29.525]     if (TRUE) {
[13:22:29.525]         base::sink(type = "output", split = FALSE)
[13:22:29.525]         if (TRUE) {
[13:22:29.525]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:29.525]         }
[13:22:29.525]         else {
[13:22:29.525]             ...future.result["stdout"] <- base::list(NULL)
[13:22:29.525]         }
[13:22:29.525]         base::close(...future.stdout)
[13:22:29.525]         ...future.stdout <- NULL
[13:22:29.525]     }
[13:22:29.525]     ...future.result$conditions <- ...future.conditions
[13:22:29.525]     ...future.result$finished <- base::Sys.time()
[13:22:29.525]     ...future.result
[13:22:29.525] }
[13:22:29.528] requestCore(): workers = 2
[13:22:29.529] MulticoreFuture started
[13:22:29.530] - Launch lazy future ... done
[13:22:29.530] run() for ‘MulticoreFuture’ ... done
[13:22:29.531] plan(): Setting new future strategy stack:
[13:22:29.531] List of future strategies:
[13:22:29.531] 1. sequential:
[13:22:29.531]    - args: function (..., envir = parent.frame())
[13:22:29.531]    - tweaked: FALSE
[13:22:29.531]    - call: NULL
[13:22:29.532] plan(): nbrOfWorkers() = 1
[13:22:29.534] plan(): Setting new future strategy stack:
[13:22:29.534] List of future strategies:
[13:22:29.534] 1. multicore:
[13:22:29.534]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:22:29.534]    - tweaked: FALSE
[13:22:29.534]    - call: plan(strategy)
[13:22:29.544] plan(): nbrOfWorkers() = 2
[1] 42
- stdout = NA
[13:22:29.545] getGlobalsAndPackages() ...
[13:22:29.545] Searching for globals...
[13:22:29.553] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[13:22:29.553] Searching for globals ... DONE
[13:22:29.553] Resolving globals: FALSE
[13:22:29.554] 
[13:22:29.554] - packages: [1] ‘utils’
[13:22:29.554] getGlobalsAndPackages() ... DONE
[13:22:29.554] run() for ‘Future’ ...
[13:22:29.555] - state: ‘created’
[13:22:29.555] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:22:29.559] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:29.559] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:22:29.559]   - Field: ‘label’
[13:22:29.559]   - Field: ‘local’
[13:22:29.559]   - Field: ‘owner’
[13:22:29.560]   - Field: ‘envir’
[13:22:29.560]   - Field: ‘workers’
[13:22:29.560]   - Field: ‘packages’
[13:22:29.560]   - Field: ‘gc’
[13:22:29.560]   - Field: ‘job’
[13:22:29.560]   - Field: ‘conditions’
[13:22:29.560]   - Field: ‘expr’
[13:22:29.560]   - Field: ‘uuid’
[13:22:29.561]   - Field: ‘seed’
[13:22:29.561]   - Field: ‘version’
[13:22:29.561]   - Field: ‘result’
[13:22:29.561]   - Field: ‘asynchronous’
[13:22:29.561]   - Field: ‘calls’
[13:22:29.561]   - Field: ‘globals’
[13:22:29.561]   - Field: ‘stdout’
[13:22:29.561]   - Field: ‘earlySignal’
[13:22:29.561]   - Field: ‘lazy’
[13:22:29.562]   - Field: ‘state’
[13:22:29.562] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:22:29.562] - Launch lazy future ...
[13:22:29.562] Packages needed by the future expression (n = 1): ‘utils’
[13:22:29.562] Packages needed by future strategies (n = 0): <none>
[13:22:29.563] {
[13:22:29.563]     {
[13:22:29.563]         {
[13:22:29.563]             ...future.startTime <- base::Sys.time()
[13:22:29.563]             {
[13:22:29.563]                 {
[13:22:29.563]                   {
[13:22:29.563]                     {
[13:22:29.563]                       {
[13:22:29.563]                         base::local({
[13:22:29.563]                           has_future <- base::requireNamespace("future", 
[13:22:29.563]                             quietly = TRUE)
[13:22:29.563]                           if (has_future) {
[13:22:29.563]                             ns <- base::getNamespace("future")
[13:22:29.563]                             version <- ns[[".package"]][["version"]]
[13:22:29.563]                             if (is.null(version)) 
[13:22:29.563]                               version <- utils::packageVersion("future")
[13:22:29.563]                           }
[13:22:29.563]                           else {
[13:22:29.563]                             version <- NULL
[13:22:29.563]                           }
[13:22:29.563]                           if (!has_future || version < "1.8.0") {
[13:22:29.563]                             info <- base::c(r_version = base::gsub("R version ", 
[13:22:29.563]                               "", base::R.version$version.string), 
[13:22:29.563]                               platform = base::sprintf("%s (%s-bit)", 
[13:22:29.563]                                 base::R.version$platform, 8 * 
[13:22:29.563]                                   base::.Machine$sizeof.pointer), 
[13:22:29.563]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:29.563]                                 "release", "version")], collapse = " "), 
[13:22:29.563]                               hostname = base::Sys.info()[["nodename"]])
[13:22:29.563]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:22:29.563]                               info)
[13:22:29.563]                             info <- base::paste(info, collapse = "; ")
[13:22:29.563]                             if (!has_future) {
[13:22:29.563]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:29.563]                                 info)
[13:22:29.563]                             }
[13:22:29.563]                             else {
[13:22:29.563]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:29.563]                                 info, version)
[13:22:29.563]                             }
[13:22:29.563]                             base::stop(msg)
[13:22:29.563]                           }
[13:22:29.563]                         })
[13:22:29.563]                       }
[13:22:29.563]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:29.563]                       base::options(mc.cores = 1L)
[13:22:29.563]                     }
[13:22:29.563]                     base::local({
[13:22:29.563]                       for (pkg in "utils") {
[13:22:29.563]                         base::loadNamespace(pkg)
[13:22:29.563]                         base::library(pkg, character.only = TRUE)
[13:22:29.563]                       }
[13:22:29.563]                     })
[13:22:29.563]                   }
[13:22:29.563]                   options(future.plan = NULL)
[13:22:29.563]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:29.563]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:29.563]                 }
[13:22:29.563]                 ...future.workdir <- getwd()
[13:22:29.563]             }
[13:22:29.563]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:29.563]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:29.563]         }
[13:22:29.563]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:29.563]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:29.563]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:29.563]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:29.563]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:29.563]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:29.563]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:29.563]             base::names(...future.oldOptions))
[13:22:29.563]     }
[13:22:29.563]     if (TRUE) {
[13:22:29.563]     }
[13:22:29.563]     else {
[13:22:29.563]         if (NA) {
[13:22:29.563]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:29.563]                 open = "w")
[13:22:29.563]         }
[13:22:29.563]         else {
[13:22:29.563]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:29.563]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:29.563]         }
[13:22:29.563]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:29.563]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:29.563]             base::sink(type = "output", split = FALSE)
[13:22:29.563]             base::close(...future.stdout)
[13:22:29.563]         }, add = TRUE)
[13:22:29.563]     }
[13:22:29.563]     ...future.frame <- base::sys.nframe()
[13:22:29.563]     ...future.conditions <- base::list()
[13:22:29.563]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:29.563]     if (FALSE) {
[13:22:29.563]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:29.563]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:29.563]     }
[13:22:29.563]     ...future.result <- base::tryCatch({
[13:22:29.563]         base::withCallingHandlers({
[13:22:29.563]             ...future.value <- base::withVisible(base::local({
[13:22:29.563]                 withCallingHandlers({
[13:22:29.563]                   {
[13:22:29.563]                     print(1:50)
[13:22:29.563]                     str(1:50)
[13:22:29.563]                     cat(letters, sep = "-")
[13:22:29.563]                     cat(1:6, collapse = "\n")
[13:22:29.563]                     write.table(datasets::iris[1:10, ], sep = "\t")
[13:22:29.563]                     42L
[13:22:29.563]                   }
[13:22:29.563]                 }, immediateCondition = function(cond) {
[13:22:29.563]                   save_rds <- function (object, pathname, ...) 
[13:22:29.563]                   {
[13:22:29.563]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:22:29.563]                     if (file_test("-f", pathname_tmp)) {
[13:22:29.563]                       fi_tmp <- file.info(pathname_tmp)
[13:22:29.563]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:22:29.563]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:29.563]                         fi_tmp[["mtime"]])
[13:22:29.563]                     }
[13:22:29.563]                     tryCatch({
[13:22:29.563]                       saveRDS(object, file = pathname_tmp, ...)
[13:22:29.563]                     }, error = function(ex) {
[13:22:29.563]                       msg <- conditionMessage(ex)
[13:22:29.563]                       fi_tmp <- file.info(pathname_tmp)
[13:22:29.563]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:22:29.563]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:29.563]                         fi_tmp[["mtime"]], msg)
[13:22:29.563]                       ex$message <- msg
[13:22:29.563]                       stop(ex)
[13:22:29.563]                     })
[13:22:29.563]                     stopifnot(file_test("-f", pathname_tmp))
[13:22:29.563]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:22:29.563]                     if (!res || file_test("-f", pathname_tmp)) {
[13:22:29.563]                       fi_tmp <- file.info(pathname_tmp)
[13:22:29.563]                       fi <- file.info(pathname)
[13:22:29.563]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:22:29.563]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:29.563]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:22:29.563]                         fi[["size"]], fi[["mtime"]])
[13:22:29.563]                       stop(msg)
[13:22:29.563]                     }
[13:22:29.563]                     invisible(pathname)
[13:22:29.563]                   }
[13:22:29.563]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:22:29.563]                     rootPath = tempdir()) 
[13:22:29.563]                   {
[13:22:29.563]                     obj <- list(time = Sys.time(), condition = cond)
[13:22:29.563]                     file <- tempfile(pattern = class(cond)[1], 
[13:22:29.563]                       tmpdir = path, fileext = ".rds")
[13:22:29.563]                     save_rds(obj, file)
[13:22:29.563]                   }
[13:22:29.563]                   saveImmediateCondition(cond, path = "/tmp/RtmpeTCoqm/.future/immediateConditions")
[13:22:29.563]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.563]                   {
[13:22:29.563]                     inherits <- base::inherits
[13:22:29.563]                     invokeRestart <- base::invokeRestart
[13:22:29.563]                     is.null <- base::is.null
[13:22:29.563]                     muffled <- FALSE
[13:22:29.563]                     if (inherits(cond, "message")) {
[13:22:29.563]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:29.563]                       if (muffled) 
[13:22:29.563]                         invokeRestart("muffleMessage")
[13:22:29.563]                     }
[13:22:29.563]                     else if (inherits(cond, "warning")) {
[13:22:29.563]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:29.563]                       if (muffled) 
[13:22:29.563]                         invokeRestart("muffleWarning")
[13:22:29.563]                     }
[13:22:29.563]                     else if (inherits(cond, "condition")) {
[13:22:29.563]                       if (!is.null(pattern)) {
[13:22:29.563]                         computeRestarts <- base::computeRestarts
[13:22:29.563]                         grepl <- base::grepl
[13:22:29.563]                         restarts <- computeRestarts(cond)
[13:22:29.563]                         for (restart in restarts) {
[13:22:29.563]                           name <- restart$name
[13:22:29.563]                           if (is.null(name)) 
[13:22:29.563]                             next
[13:22:29.563]                           if (!grepl(pattern, name)) 
[13:22:29.563]                             next
[13:22:29.563]                           invokeRestart(restart)
[13:22:29.563]                           muffled <- TRUE
[13:22:29.563]                           break
[13:22:29.563]                         }
[13:22:29.563]                       }
[13:22:29.563]                     }
[13:22:29.563]                     invisible(muffled)
[13:22:29.563]                   }
[13:22:29.563]                   muffleCondition(cond)
[13:22:29.563]                 })
[13:22:29.563]             }))
[13:22:29.563]             future::FutureResult(value = ...future.value$value, 
[13:22:29.563]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:29.563]                   ...future.rng), globalenv = if (FALSE) 
[13:22:29.563]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:29.563]                     ...future.globalenv.names))
[13:22:29.563]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:29.563]         }, condition = base::local({
[13:22:29.563]             c <- base::c
[13:22:29.563]             inherits <- base::inherits
[13:22:29.563]             invokeRestart <- base::invokeRestart
[13:22:29.563]             length <- base::length
[13:22:29.563]             list <- base::list
[13:22:29.563]             seq.int <- base::seq.int
[13:22:29.563]             signalCondition <- base::signalCondition
[13:22:29.563]             sys.calls <- base::sys.calls
[13:22:29.563]             `[[` <- base::`[[`
[13:22:29.563]             `+` <- base::`+`
[13:22:29.563]             `<<-` <- base::`<<-`
[13:22:29.563]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:29.563]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:29.563]                   3L)]
[13:22:29.563]             }
[13:22:29.563]             function(cond) {
[13:22:29.563]                 is_error <- inherits(cond, "error")
[13:22:29.563]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:29.563]                   NULL)
[13:22:29.563]                 if (is_error) {
[13:22:29.563]                   sessionInformation <- function() {
[13:22:29.563]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:29.563]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:29.563]                       search = base::search(), system = base::Sys.info())
[13:22:29.563]                   }
[13:22:29.563]                   ...future.conditions[[length(...future.conditions) + 
[13:22:29.563]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:29.563]                     cond$call), session = sessionInformation(), 
[13:22:29.563]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:29.563]                   signalCondition(cond)
[13:22:29.563]                 }
[13:22:29.563]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:29.563]                 "immediateCondition"))) {
[13:22:29.563]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:29.563]                   ...future.conditions[[length(...future.conditions) + 
[13:22:29.563]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:29.563]                   if (TRUE && !signal) {
[13:22:29.563]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.563]                     {
[13:22:29.563]                       inherits <- base::inherits
[13:22:29.563]                       invokeRestart <- base::invokeRestart
[13:22:29.563]                       is.null <- base::is.null
[13:22:29.563]                       muffled <- FALSE
[13:22:29.563]                       if (inherits(cond, "message")) {
[13:22:29.563]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:29.563]                         if (muffled) 
[13:22:29.563]                           invokeRestart("muffleMessage")
[13:22:29.563]                       }
[13:22:29.563]                       else if (inherits(cond, "warning")) {
[13:22:29.563]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:29.563]                         if (muffled) 
[13:22:29.563]                           invokeRestart("muffleWarning")
[13:22:29.563]                       }
[13:22:29.563]                       else if (inherits(cond, "condition")) {
[13:22:29.563]                         if (!is.null(pattern)) {
[13:22:29.563]                           computeRestarts <- base::computeRestarts
[13:22:29.563]                           grepl <- base::grepl
[13:22:29.563]                           restarts <- computeRestarts(cond)
[13:22:29.563]                           for (restart in restarts) {
[13:22:29.563]                             name <- restart$name
[13:22:29.563]                             if (is.null(name)) 
[13:22:29.563]                               next
[13:22:29.563]                             if (!grepl(pattern, name)) 
[13:22:29.563]                               next
[13:22:29.563]                             invokeRestart(restart)
[13:22:29.563]                             muffled <- TRUE
[13:22:29.563]                             break
[13:22:29.563]                           }
[13:22:29.563]                         }
[13:22:29.563]                       }
[13:22:29.563]                       invisible(muffled)
[13:22:29.563]                     }
[13:22:29.563]                     muffleCondition(cond, pattern = "^muffle")
[13:22:29.563]                   }
[13:22:29.563]                 }
[13:22:29.563]                 else {
[13:22:29.563]                   if (TRUE) {
[13:22:29.563]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.563]                     {
[13:22:29.563]                       inherits <- base::inherits
[13:22:29.563]                       invokeRestart <- base::invokeRestart
[13:22:29.563]                       is.null <- base::is.null
[13:22:29.563]                       muffled <- FALSE
[13:22:29.563]                       if (inherits(cond, "message")) {
[13:22:29.563]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:29.563]                         if (muffled) 
[13:22:29.563]                           invokeRestart("muffleMessage")
[13:22:29.563]                       }
[13:22:29.563]                       else if (inherits(cond, "warning")) {
[13:22:29.563]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:29.563]                         if (muffled) 
[13:22:29.563]                           invokeRestart("muffleWarning")
[13:22:29.563]                       }
[13:22:29.563]                       else if (inherits(cond, "condition")) {
[13:22:29.563]                         if (!is.null(pattern)) {
[13:22:29.563]                           computeRestarts <- base::computeRestarts
[13:22:29.563]                           grepl <- base::grepl
[13:22:29.563]                           restarts <- computeRestarts(cond)
[13:22:29.563]                           for (restart in restarts) {
[13:22:29.563]                             name <- restart$name
[13:22:29.563]                             if (is.null(name)) 
[13:22:29.563]                               next
[13:22:29.563]                             if (!grepl(pattern, name)) 
[13:22:29.563]                               next
[13:22:29.563]                             invokeRestart(restart)
[13:22:29.563]                             muffled <- TRUE
[13:22:29.563]                             break
[13:22:29.563]                           }
[13:22:29.563]                         }
[13:22:29.563]                       }
[13:22:29.563]                       invisible(muffled)
[13:22:29.563]                     }
[13:22:29.563]                     muffleCondition(cond, pattern = "^muffle")
[13:22:29.563]                   }
[13:22:29.563]                 }
[13:22:29.563]             }
[13:22:29.563]         }))
[13:22:29.563]     }, error = function(ex) {
[13:22:29.563]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:29.563]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:29.563]                 ...future.rng), started = ...future.startTime, 
[13:22:29.563]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:29.563]             version = "1.8"), class = "FutureResult")
[13:22:29.563]     }, finally = {
[13:22:29.563]         if (!identical(...future.workdir, getwd())) 
[13:22:29.563]             setwd(...future.workdir)
[13:22:29.563]         {
[13:22:29.563]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:29.563]                 ...future.oldOptions$nwarnings <- NULL
[13:22:29.563]             }
[13:22:29.563]             base::options(...future.oldOptions)
[13:22:29.563]             if (.Platform$OS.type == "windows") {
[13:22:29.563]                 old_names <- names(...future.oldEnvVars)
[13:22:29.563]                 envs <- base::Sys.getenv()
[13:22:29.563]                 names <- names(envs)
[13:22:29.563]                 common <- intersect(names, old_names)
[13:22:29.563]                 added <- setdiff(names, old_names)
[13:22:29.563]                 removed <- setdiff(old_names, names)
[13:22:29.563]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:29.563]                   envs[common]]
[13:22:29.563]                 NAMES <- toupper(changed)
[13:22:29.563]                 args <- list()
[13:22:29.563]                 for (kk in seq_along(NAMES)) {
[13:22:29.563]                   name <- changed[[kk]]
[13:22:29.563]                   NAME <- NAMES[[kk]]
[13:22:29.563]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.563]                     next
[13:22:29.563]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:29.563]                 }
[13:22:29.563]                 NAMES <- toupper(added)
[13:22:29.563]                 for (kk in seq_along(NAMES)) {
[13:22:29.563]                   name <- added[[kk]]
[13:22:29.563]                   NAME <- NAMES[[kk]]
[13:22:29.563]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.563]                     next
[13:22:29.563]                   args[[name]] <- ""
[13:22:29.563]                 }
[13:22:29.563]                 NAMES <- toupper(removed)
[13:22:29.563]                 for (kk in seq_along(NAMES)) {
[13:22:29.563]                   name <- removed[[kk]]
[13:22:29.563]                   NAME <- NAMES[[kk]]
[13:22:29.563]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.563]                     next
[13:22:29.563]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:29.563]                 }
[13:22:29.563]                 if (length(args) > 0) 
[13:22:29.563]                   base::do.call(base::Sys.setenv, args = args)
[13:22:29.563]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:29.563]             }
[13:22:29.563]             else {
[13:22:29.563]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:29.563]             }
[13:22:29.563]             {
[13:22:29.563]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:29.563]                   0L) {
[13:22:29.563]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:29.563]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:29.563]                   base::options(opts)
[13:22:29.563]                 }
[13:22:29.563]                 {
[13:22:29.563]                   {
[13:22:29.563]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:29.563]                     NULL
[13:22:29.563]                   }
[13:22:29.563]                   options(future.plan = NULL)
[13:22:29.563]                   if (is.na(NA_character_)) 
[13:22:29.563]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:29.563]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:29.563]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:22:29.563]                     envir = parent.frame()) 
[13:22:29.563]                   {
[13:22:29.563]                     default_workers <- missing(workers)
[13:22:29.563]                     if (is.function(workers)) 
[13:22:29.563]                       workers <- workers()
[13:22:29.563]                     workers <- structure(as.integer(workers), 
[13:22:29.563]                       class = class(workers))
[13:22:29.563]                     stop_if_not(is.finite(workers), workers >= 
[13:22:29.563]                       1L)
[13:22:29.563]                     if ((workers == 1L && !inherits(workers, 
[13:22:29.563]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:22:29.563]                       if (default_workers) 
[13:22:29.563]                         supportsMulticore(warn = TRUE)
[13:22:29.563]                       return(sequential(..., envir = envir))
[13:22:29.563]                     }
[13:22:29.563]                     oopts <- options(mc.cores = workers)
[13:22:29.563]                     on.exit(options(oopts))
[13:22:29.563]                     future <- MulticoreFuture(..., workers = workers, 
[13:22:29.563]                       envir = envir)
[13:22:29.563]                     if (!future$lazy) 
[13:22:29.563]                       future <- run(future)
[13:22:29.563]                     invisible(future)
[13:22:29.563]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:29.563]                 }
[13:22:29.563]             }
[13:22:29.563]         }
[13:22:29.563]     })
[13:22:29.563]     if (FALSE) {
[13:22:29.563]         base::sink(type = "output", split = FALSE)
[13:22:29.563]         if (NA) {
[13:22:29.563]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:29.563]         }
[13:22:29.563]         else {
[13:22:29.563]             ...future.result["stdout"] <- base::list(NULL)
[13:22:29.563]         }
[13:22:29.563]         base::close(...future.stdout)
[13:22:29.563]         ...future.stdout <- NULL
[13:22:29.563]     }
[13:22:29.563]     ...future.result$conditions <- ...future.conditions
[13:22:29.563]     ...future.result$finished <- base::Sys.time()
[13:22:29.563]     ...future.result
[13:22:29.563] }
[13:22:29.566] requestCore(): workers = 2
[13:22:29.568] MulticoreFuture started
[13:22:29.568] - Launch lazy future ... done
[13:22:29.568] run() for ‘MulticoreFuture’ ... done
[13:22:29.569] plan(): Setting new future strategy stack:
[13:22:29.569] List of future strategies:
[13:22:29.569] 1. sequential:
[13:22:29.569]    - args: function (..., envir = parent.frame())
[13:22:29.569]    - tweaked: FALSE
[13:22:29.569]    - call: NULL
[13:22:29.570] plan(): nbrOfWorkers() = 1
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
[13:22:29.574] plan(): Setting new future strategy stack:
[13:22:29.574] List of future strategies:
[13:22:29.574] 1. multicore:
[13:22:29.574]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:22:29.574]    - tweaked: FALSE
[13:22:29.574]    - call: plan(strategy)
[13:22:29.579] plan(): nbrOfWorkers() = 2
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-01-07 13:22:29"
 $ finished    : POSIXct[1:1], format: "2025-01-07 13:22:29"
 $ session_uuid: chr "4d385922-c673-db84-32e3-ebd7a49a6bf4"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "5853cd8d1af0"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "5853cd8d1af0" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 93480
  .. ..$ time  : POSIXct[1:1], format: "2025-01-07 13:22:29"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 3 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[13:22:29.590] getGlobalsAndPackages() ...
[13:22:29.590] Searching for globals...
[13:22:29.596] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[13:22:29.596] Searching for globals ... DONE
[13:22:29.596] Resolving globals: FALSE
[13:22:29.597] 
[13:22:29.597] - packages: [1] ‘utils’
[13:22:29.597] getGlobalsAndPackages() ... DONE
[13:22:29.598] run() for ‘Future’ ...
[13:22:29.598] - state: ‘created’
[13:22:29.598] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:22:29.603] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:29.603] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:22:29.603]   - Field: ‘label’
[13:22:29.603]   - Field: ‘local’
[13:22:29.603]   - Field: ‘owner’
[13:22:29.603]   - Field: ‘envir’
[13:22:29.604]   - Field: ‘workers’
[13:22:29.604]   - Field: ‘packages’
[13:22:29.604]   - Field: ‘gc’
[13:22:29.604]   - Field: ‘job’
[13:22:29.604]   - Field: ‘conditions’
[13:22:29.604]   - Field: ‘expr’
[13:22:29.604]   - Field: ‘uuid’
[13:22:29.604]   - Field: ‘seed’
[13:22:29.605]   - Field: ‘version’
[13:22:29.605]   - Field: ‘result’
[13:22:29.605]   - Field: ‘asynchronous’
[13:22:29.605]   - Field: ‘calls’
[13:22:29.605]   - Field: ‘globals’
[13:22:29.605]   - Field: ‘stdout’
[13:22:29.605]   - Field: ‘earlySignal’
[13:22:29.605]   - Field: ‘lazy’
[13:22:29.606]   - Field: ‘state’
[13:22:29.606] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:22:29.606] - Launch lazy future ...
[13:22:29.606] Packages needed by the future expression (n = 1): ‘utils’
[13:22:29.606] Packages needed by future strategies (n = 0): <none>
[13:22:29.607] {
[13:22:29.607]     {
[13:22:29.607]         {
[13:22:29.607]             ...future.startTime <- base::Sys.time()
[13:22:29.607]             {
[13:22:29.607]                 {
[13:22:29.607]                   {
[13:22:29.607]                     {
[13:22:29.607]                       {
[13:22:29.607]                         base::local({
[13:22:29.607]                           has_future <- base::requireNamespace("future", 
[13:22:29.607]                             quietly = TRUE)
[13:22:29.607]                           if (has_future) {
[13:22:29.607]                             ns <- base::getNamespace("future")
[13:22:29.607]                             version <- ns[[".package"]][["version"]]
[13:22:29.607]                             if (is.null(version)) 
[13:22:29.607]                               version <- utils::packageVersion("future")
[13:22:29.607]                           }
[13:22:29.607]                           else {
[13:22:29.607]                             version <- NULL
[13:22:29.607]                           }
[13:22:29.607]                           if (!has_future || version < "1.8.0") {
[13:22:29.607]                             info <- base::c(r_version = base::gsub("R version ", 
[13:22:29.607]                               "", base::R.version$version.string), 
[13:22:29.607]                               platform = base::sprintf("%s (%s-bit)", 
[13:22:29.607]                                 base::R.version$platform, 8 * 
[13:22:29.607]                                   base::.Machine$sizeof.pointer), 
[13:22:29.607]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:29.607]                                 "release", "version")], collapse = " "), 
[13:22:29.607]                               hostname = base::Sys.info()[["nodename"]])
[13:22:29.607]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:22:29.607]                               info)
[13:22:29.607]                             info <- base::paste(info, collapse = "; ")
[13:22:29.607]                             if (!has_future) {
[13:22:29.607]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:29.607]                                 info)
[13:22:29.607]                             }
[13:22:29.607]                             else {
[13:22:29.607]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:29.607]                                 info, version)
[13:22:29.607]                             }
[13:22:29.607]                             base::stop(msg)
[13:22:29.607]                           }
[13:22:29.607]                         })
[13:22:29.607]                       }
[13:22:29.607]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:29.607]                       base::options(mc.cores = 1L)
[13:22:29.607]                     }
[13:22:29.607]                     base::local({
[13:22:29.607]                       for (pkg in "utils") {
[13:22:29.607]                         base::loadNamespace(pkg)
[13:22:29.607]                         base::library(pkg, character.only = TRUE)
[13:22:29.607]                       }
[13:22:29.607]                     })
[13:22:29.607]                   }
[13:22:29.607]                   options(future.plan = NULL)
[13:22:29.607]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:29.607]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:29.607]                 }
[13:22:29.607]                 ...future.workdir <- getwd()
[13:22:29.607]             }
[13:22:29.607]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:29.607]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:29.607]         }
[13:22:29.607]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:29.607]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:29.607]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:29.607]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:29.607]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:29.607]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:29.607]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:29.607]             base::names(...future.oldOptions))
[13:22:29.607]     }
[13:22:29.607]     if (TRUE) {
[13:22:29.607]     }
[13:22:29.607]     else {
[13:22:29.607]         if (NA) {
[13:22:29.607]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:29.607]                 open = "w")
[13:22:29.607]         }
[13:22:29.607]         else {
[13:22:29.607]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:29.607]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:29.607]         }
[13:22:29.607]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:29.607]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:29.607]             base::sink(type = "output", split = FALSE)
[13:22:29.607]             base::close(...future.stdout)
[13:22:29.607]         }, add = TRUE)
[13:22:29.607]     }
[13:22:29.607]     ...future.frame <- base::sys.nframe()
[13:22:29.607]     ...future.conditions <- base::list()
[13:22:29.607]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:29.607]     if (FALSE) {
[13:22:29.607]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:29.607]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:29.607]     }
[13:22:29.607]     ...future.result <- base::tryCatch({
[13:22:29.607]         base::withCallingHandlers({
[13:22:29.607]             ...future.value <- base::withVisible(base::local({
[13:22:29.607]                 withCallingHandlers({
[13:22:29.607]                   {
[13:22:29.607]                     print(1:50)
[13:22:29.607]                     str(1:50)
[13:22:29.607]                     cat(letters, sep = "-")
[13:22:29.607]                     cat(1:6, collapse = "\n")
[13:22:29.607]                     write.table(datasets::iris[1:10, ], sep = "\t")
[13:22:29.607]                     42L
[13:22:29.607]                   }
[13:22:29.607]                 }, immediateCondition = function(cond) {
[13:22:29.607]                   save_rds <- function (object, pathname, ...) 
[13:22:29.607]                   {
[13:22:29.607]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:22:29.607]                     if (file_test("-f", pathname_tmp)) {
[13:22:29.607]                       fi_tmp <- file.info(pathname_tmp)
[13:22:29.607]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:22:29.607]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:29.607]                         fi_tmp[["mtime"]])
[13:22:29.607]                     }
[13:22:29.607]                     tryCatch({
[13:22:29.607]                       saveRDS(object, file = pathname_tmp, ...)
[13:22:29.607]                     }, error = function(ex) {
[13:22:29.607]                       msg <- conditionMessage(ex)
[13:22:29.607]                       fi_tmp <- file.info(pathname_tmp)
[13:22:29.607]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:22:29.607]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:29.607]                         fi_tmp[["mtime"]], msg)
[13:22:29.607]                       ex$message <- msg
[13:22:29.607]                       stop(ex)
[13:22:29.607]                     })
[13:22:29.607]                     stopifnot(file_test("-f", pathname_tmp))
[13:22:29.607]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:22:29.607]                     if (!res || file_test("-f", pathname_tmp)) {
[13:22:29.607]                       fi_tmp <- file.info(pathname_tmp)
[13:22:29.607]                       fi <- file.info(pathname)
[13:22:29.607]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:22:29.607]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:29.607]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:22:29.607]                         fi[["size"]], fi[["mtime"]])
[13:22:29.607]                       stop(msg)
[13:22:29.607]                     }
[13:22:29.607]                     invisible(pathname)
[13:22:29.607]                   }
[13:22:29.607]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:22:29.607]                     rootPath = tempdir()) 
[13:22:29.607]                   {
[13:22:29.607]                     obj <- list(time = Sys.time(), condition = cond)
[13:22:29.607]                     file <- tempfile(pattern = class(cond)[1], 
[13:22:29.607]                       tmpdir = path, fileext = ".rds")
[13:22:29.607]                     save_rds(obj, file)
[13:22:29.607]                   }
[13:22:29.607]                   saveImmediateCondition(cond, path = "/tmp/RtmpeTCoqm/.future/immediateConditions")
[13:22:29.607]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.607]                   {
[13:22:29.607]                     inherits <- base::inherits
[13:22:29.607]                     invokeRestart <- base::invokeRestart
[13:22:29.607]                     is.null <- base::is.null
[13:22:29.607]                     muffled <- FALSE
[13:22:29.607]                     if (inherits(cond, "message")) {
[13:22:29.607]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:29.607]                       if (muffled) 
[13:22:29.607]                         invokeRestart("muffleMessage")
[13:22:29.607]                     }
[13:22:29.607]                     else if (inherits(cond, "warning")) {
[13:22:29.607]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:29.607]                       if (muffled) 
[13:22:29.607]                         invokeRestart("muffleWarning")
[13:22:29.607]                     }
[13:22:29.607]                     else if (inherits(cond, "condition")) {
[13:22:29.607]                       if (!is.null(pattern)) {
[13:22:29.607]                         computeRestarts <- base::computeRestarts
[13:22:29.607]                         grepl <- base::grepl
[13:22:29.607]                         restarts <- computeRestarts(cond)
[13:22:29.607]                         for (restart in restarts) {
[13:22:29.607]                           name <- restart$name
[13:22:29.607]                           if (is.null(name)) 
[13:22:29.607]                             next
[13:22:29.607]                           if (!grepl(pattern, name)) 
[13:22:29.607]                             next
[13:22:29.607]                           invokeRestart(restart)
[13:22:29.607]                           muffled <- TRUE
[13:22:29.607]                           break
[13:22:29.607]                         }
[13:22:29.607]                       }
[13:22:29.607]                     }
[13:22:29.607]                     invisible(muffled)
[13:22:29.607]                   }
[13:22:29.607]                   muffleCondition(cond)
[13:22:29.607]                 })
[13:22:29.607]             }))
[13:22:29.607]             future::FutureResult(value = ...future.value$value, 
[13:22:29.607]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:29.607]                   ...future.rng), globalenv = if (FALSE) 
[13:22:29.607]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:29.607]                     ...future.globalenv.names))
[13:22:29.607]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:29.607]         }, condition = base::local({
[13:22:29.607]             c <- base::c
[13:22:29.607]             inherits <- base::inherits
[13:22:29.607]             invokeRestart <- base::invokeRestart
[13:22:29.607]             length <- base::length
[13:22:29.607]             list <- base::list
[13:22:29.607]             seq.int <- base::seq.int
[13:22:29.607]             signalCondition <- base::signalCondition
[13:22:29.607]             sys.calls <- base::sys.calls
[13:22:29.607]             `[[` <- base::`[[`
[13:22:29.607]             `+` <- base::`+`
[13:22:29.607]             `<<-` <- base::`<<-`
[13:22:29.607]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:29.607]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:29.607]                   3L)]
[13:22:29.607]             }
[13:22:29.607]             function(cond) {
[13:22:29.607]                 is_error <- inherits(cond, "error")
[13:22:29.607]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:29.607]                   NULL)
[13:22:29.607]                 if (is_error) {
[13:22:29.607]                   sessionInformation <- function() {
[13:22:29.607]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:29.607]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:29.607]                       search = base::search(), system = base::Sys.info())
[13:22:29.607]                   }
[13:22:29.607]                   ...future.conditions[[length(...future.conditions) + 
[13:22:29.607]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:29.607]                     cond$call), session = sessionInformation(), 
[13:22:29.607]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:29.607]                   signalCondition(cond)
[13:22:29.607]                 }
[13:22:29.607]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:29.607]                 "immediateCondition"))) {
[13:22:29.607]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:29.607]                   ...future.conditions[[length(...future.conditions) + 
[13:22:29.607]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:29.607]                   if (TRUE && !signal) {
[13:22:29.607]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.607]                     {
[13:22:29.607]                       inherits <- base::inherits
[13:22:29.607]                       invokeRestart <- base::invokeRestart
[13:22:29.607]                       is.null <- base::is.null
[13:22:29.607]                       muffled <- FALSE
[13:22:29.607]                       if (inherits(cond, "message")) {
[13:22:29.607]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:29.607]                         if (muffled) 
[13:22:29.607]                           invokeRestart("muffleMessage")
[13:22:29.607]                       }
[13:22:29.607]                       else if (inherits(cond, "warning")) {
[13:22:29.607]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:29.607]                         if (muffled) 
[13:22:29.607]                           invokeRestart("muffleWarning")
[13:22:29.607]                       }
[13:22:29.607]                       else if (inherits(cond, "condition")) {
[13:22:29.607]                         if (!is.null(pattern)) {
[13:22:29.607]                           computeRestarts <- base::computeRestarts
[13:22:29.607]                           grepl <- base::grepl
[13:22:29.607]                           restarts <- computeRestarts(cond)
[13:22:29.607]                           for (restart in restarts) {
[13:22:29.607]                             name <- restart$name
[13:22:29.607]                             if (is.null(name)) 
[13:22:29.607]                               next
[13:22:29.607]                             if (!grepl(pattern, name)) 
[13:22:29.607]                               next
[13:22:29.607]                             invokeRestart(restart)
[13:22:29.607]                             muffled <- TRUE
[13:22:29.607]                             break
[13:22:29.607]                           }
[13:22:29.607]                         }
[13:22:29.607]                       }
[13:22:29.607]                       invisible(muffled)
[13:22:29.607]                     }
[13:22:29.607]                     muffleCondition(cond, pattern = "^muffle")
[13:22:29.607]                   }
[13:22:29.607]                 }
[13:22:29.607]                 else {
[13:22:29.607]                   if (TRUE) {
[13:22:29.607]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.607]                     {
[13:22:29.607]                       inherits <- base::inherits
[13:22:29.607]                       invokeRestart <- base::invokeRestart
[13:22:29.607]                       is.null <- base::is.null
[13:22:29.607]                       muffled <- FALSE
[13:22:29.607]                       if (inherits(cond, "message")) {
[13:22:29.607]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:29.607]                         if (muffled) 
[13:22:29.607]                           invokeRestart("muffleMessage")
[13:22:29.607]                       }
[13:22:29.607]                       else if (inherits(cond, "warning")) {
[13:22:29.607]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:29.607]                         if (muffled) 
[13:22:29.607]                           invokeRestart("muffleWarning")
[13:22:29.607]                       }
[13:22:29.607]                       else if (inherits(cond, "condition")) {
[13:22:29.607]                         if (!is.null(pattern)) {
[13:22:29.607]                           computeRestarts <- base::computeRestarts
[13:22:29.607]                           grepl <- base::grepl
[13:22:29.607]                           restarts <- computeRestarts(cond)
[13:22:29.607]                           for (restart in restarts) {
[13:22:29.607]                             name <- restart$name
[13:22:29.607]                             if (is.null(name)) 
[13:22:29.607]                               next
[13:22:29.607]                             if (!grepl(pattern, name)) 
[13:22:29.607]                               next
[13:22:29.607]                             invokeRestart(restart)
[13:22:29.607]                             muffled <- TRUE
[13:22:29.607]                             break
[13:22:29.607]                           }
[13:22:29.607]                         }
[13:22:29.607]                       }
[13:22:29.607]                       invisible(muffled)
[13:22:29.607]                     }
[13:22:29.607]                     muffleCondition(cond, pattern = "^muffle")
[13:22:29.607]                   }
[13:22:29.607]                 }
[13:22:29.607]             }
[13:22:29.607]         }))
[13:22:29.607]     }, error = function(ex) {
[13:22:29.607]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:29.607]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:29.607]                 ...future.rng), started = ...future.startTime, 
[13:22:29.607]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:29.607]             version = "1.8"), class = "FutureResult")
[13:22:29.607]     }, finally = {
[13:22:29.607]         if (!identical(...future.workdir, getwd())) 
[13:22:29.607]             setwd(...future.workdir)
[13:22:29.607]         {
[13:22:29.607]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:29.607]                 ...future.oldOptions$nwarnings <- NULL
[13:22:29.607]             }
[13:22:29.607]             base::options(...future.oldOptions)
[13:22:29.607]             if (.Platform$OS.type == "windows") {
[13:22:29.607]                 old_names <- names(...future.oldEnvVars)
[13:22:29.607]                 envs <- base::Sys.getenv()
[13:22:29.607]                 names <- names(envs)
[13:22:29.607]                 common <- intersect(names, old_names)
[13:22:29.607]                 added <- setdiff(names, old_names)
[13:22:29.607]                 removed <- setdiff(old_names, names)
[13:22:29.607]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:29.607]                   envs[common]]
[13:22:29.607]                 NAMES <- toupper(changed)
[13:22:29.607]                 args <- list()
[13:22:29.607]                 for (kk in seq_along(NAMES)) {
[13:22:29.607]                   name <- changed[[kk]]
[13:22:29.607]                   NAME <- NAMES[[kk]]
[13:22:29.607]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.607]                     next
[13:22:29.607]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:29.607]                 }
[13:22:29.607]                 NAMES <- toupper(added)
[13:22:29.607]                 for (kk in seq_along(NAMES)) {
[13:22:29.607]                   name <- added[[kk]]
[13:22:29.607]                   NAME <- NAMES[[kk]]
[13:22:29.607]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.607]                     next
[13:22:29.607]                   args[[name]] <- ""
[13:22:29.607]                 }
[13:22:29.607]                 NAMES <- toupper(removed)
[13:22:29.607]                 for (kk in seq_along(NAMES)) {
[13:22:29.607]                   name <- removed[[kk]]
[13:22:29.607]                   NAME <- NAMES[[kk]]
[13:22:29.607]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.607]                     next
[13:22:29.607]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:29.607]                 }
[13:22:29.607]                 if (length(args) > 0) 
[13:22:29.607]                   base::do.call(base::Sys.setenv, args = args)
[13:22:29.607]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:29.607]             }
[13:22:29.607]             else {
[13:22:29.607]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:29.607]             }
[13:22:29.607]             {
[13:22:29.607]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:29.607]                   0L) {
[13:22:29.607]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:29.607]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:29.607]                   base::options(opts)
[13:22:29.607]                 }
[13:22:29.607]                 {
[13:22:29.607]                   {
[13:22:29.607]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:29.607]                     NULL
[13:22:29.607]                   }
[13:22:29.607]                   options(future.plan = NULL)
[13:22:29.607]                   if (is.na(NA_character_)) 
[13:22:29.607]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:29.607]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:29.607]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:22:29.607]                     envir = parent.frame()) 
[13:22:29.607]                   {
[13:22:29.607]                     default_workers <- missing(workers)
[13:22:29.607]                     if (is.function(workers)) 
[13:22:29.607]                       workers <- workers()
[13:22:29.607]                     workers <- structure(as.integer(workers), 
[13:22:29.607]                       class = class(workers))
[13:22:29.607]                     stop_if_not(is.finite(workers), workers >= 
[13:22:29.607]                       1L)
[13:22:29.607]                     if ((workers == 1L && !inherits(workers, 
[13:22:29.607]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:22:29.607]                       if (default_workers) 
[13:22:29.607]                         supportsMulticore(warn = TRUE)
[13:22:29.607]                       return(sequential(..., envir = envir))
[13:22:29.607]                     }
[13:22:29.607]                     oopts <- options(mc.cores = workers)
[13:22:29.607]                     on.exit(options(oopts))
[13:22:29.607]                     future <- MulticoreFuture(..., workers = workers, 
[13:22:29.607]                       envir = envir)
[13:22:29.607]                     if (!future$lazy) 
[13:22:29.607]                       future <- run(future)
[13:22:29.607]                     invisible(future)
[13:22:29.607]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:29.607]                 }
[13:22:29.607]             }
[13:22:29.607]         }
[13:22:29.607]     })
[13:22:29.607]     if (FALSE) {
[13:22:29.607]         base::sink(type = "output", split = FALSE)
[13:22:29.607]         if (NA) {
[13:22:29.607]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:29.607]         }
[13:22:29.607]         else {
[13:22:29.607]             ...future.result["stdout"] <- base::list(NULL)
[13:22:29.607]         }
[13:22:29.607]         base::close(...future.stdout)
[13:22:29.607]         ...future.stdout <- NULL
[13:22:29.607]     }
[13:22:29.607]     ...future.result$conditions <- ...future.conditions
[13:22:29.607]     ...future.result$finished <- base::Sys.time()
[13:22:29.607]     ...future.result
[13:22:29.607] }
[13:22:29.609] requestCore(): workers = 2
[13:22:29.611] MulticoreFuture started
[13:22:29.612] - Launch lazy future ... done
[13:22:29.612] run() for ‘MulticoreFuture’ ... done
[13:22:29.613] plan(): Setting new future strategy stack:
[13:22:29.613] List of future strategies:
[13:22:29.613] 1. sequential:
[13:22:29.613]    - args: function (..., envir = parent.frame())
[13:22:29.613]    - tweaked: FALSE
[13:22:29.613]    - call: NULL
[13:22:29.614] plan(): nbrOfWorkers() = 1
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
[13:22:29.618] plan(): Setting new future strategy stack:
[13:22:29.618] List of future strategies:
[13:22:29.618] 1. multicore:
[13:22:29.618]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:22:29.618]    - tweaked: FALSE
[13:22:29.618]    - call: plan(strategy)
[13:22:29.623] plan(): nbrOfWorkers() = 2
- stdout = structure(TRUE, drop = TRUE)
[13:22:29.624] getGlobalsAndPackages() ...
[13:22:29.624] Searching for globals...
[13:22:29.625] - globals found: [1] ‘print’
[13:22:29.625] Searching for globals ... DONE
[13:22:29.625] Resolving globals: FALSE
[13:22:29.626] 
[13:22:29.626] 
[13:22:29.626] getGlobalsAndPackages() ... DONE
[13:22:29.626] run() for ‘Future’ ...
[13:22:29.626] - state: ‘created’
[13:22:29.626] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:22:29.631] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:29.631] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:22:29.631]   - Field: ‘label’
[13:22:29.631]   - Field: ‘local’
[13:22:29.631]   - Field: ‘owner’
[13:22:29.631]   - Field: ‘envir’
[13:22:29.631]   - Field: ‘workers’
[13:22:29.631]   - Field: ‘packages’
[13:22:29.632]   - Field: ‘gc’
[13:22:29.632]   - Field: ‘job’
[13:22:29.632]   - Field: ‘conditions’
[13:22:29.632]   - Field: ‘expr’
[13:22:29.632]   - Field: ‘uuid’
[13:22:29.632]   - Field: ‘seed’
[13:22:29.632]   - Field: ‘version’
[13:22:29.632]   - Field: ‘result’
[13:22:29.633]   - Field: ‘asynchronous’
[13:22:29.633]   - Field: ‘calls’
[13:22:29.633]   - Field: ‘globals’
[13:22:29.633]   - Field: ‘stdout’
[13:22:29.633]   - Field: ‘earlySignal’
[13:22:29.633]   - Field: ‘lazy’
[13:22:29.633]   - Field: ‘state’
[13:22:29.633] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:22:29.633] - Launch lazy future ...
[13:22:29.634] Packages needed by the future expression (n = 0): <none>
[13:22:29.634] Packages needed by future strategies (n = 0): <none>
[13:22:29.635] {
[13:22:29.635]     {
[13:22:29.635]         {
[13:22:29.635]             ...future.startTime <- base::Sys.time()
[13:22:29.635]             {
[13:22:29.635]                 {
[13:22:29.635]                   {
[13:22:29.635]                     {
[13:22:29.635]                       base::local({
[13:22:29.635]                         has_future <- base::requireNamespace("future", 
[13:22:29.635]                           quietly = TRUE)
[13:22:29.635]                         if (has_future) {
[13:22:29.635]                           ns <- base::getNamespace("future")
[13:22:29.635]                           version <- ns[[".package"]][["version"]]
[13:22:29.635]                           if (is.null(version)) 
[13:22:29.635]                             version <- utils::packageVersion("future")
[13:22:29.635]                         }
[13:22:29.635]                         else {
[13:22:29.635]                           version <- NULL
[13:22:29.635]                         }
[13:22:29.635]                         if (!has_future || version < "1.8.0") {
[13:22:29.635]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:29.635]                             "", base::R.version$version.string), 
[13:22:29.635]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:29.635]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:29.635]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:29.635]                               "release", "version")], collapse = " "), 
[13:22:29.635]                             hostname = base::Sys.info()[["nodename"]])
[13:22:29.635]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:29.635]                             info)
[13:22:29.635]                           info <- base::paste(info, collapse = "; ")
[13:22:29.635]                           if (!has_future) {
[13:22:29.635]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:29.635]                               info)
[13:22:29.635]                           }
[13:22:29.635]                           else {
[13:22:29.635]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:29.635]                               info, version)
[13:22:29.635]                           }
[13:22:29.635]                           base::stop(msg)
[13:22:29.635]                         }
[13:22:29.635]                       })
[13:22:29.635]                     }
[13:22:29.635]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:29.635]                     base::options(mc.cores = 1L)
[13:22:29.635]                   }
[13:22:29.635]                   options(future.plan = NULL)
[13:22:29.635]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:29.635]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:29.635]                 }
[13:22:29.635]                 ...future.workdir <- getwd()
[13:22:29.635]             }
[13:22:29.635]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:29.635]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:29.635]         }
[13:22:29.635]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:29.635]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:29.635]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:29.635]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:29.635]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:29.635]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:29.635]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:29.635]             base::names(...future.oldOptions))
[13:22:29.635]     }
[13:22:29.635]     if (FALSE) {
[13:22:29.635]     }
[13:22:29.635]     else {
[13:22:29.635]         if (TRUE) {
[13:22:29.635]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:29.635]                 open = "w")
[13:22:29.635]         }
[13:22:29.635]         else {
[13:22:29.635]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:29.635]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:29.635]         }
[13:22:29.635]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:29.635]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:29.635]             base::sink(type = "output", split = FALSE)
[13:22:29.635]             base::close(...future.stdout)
[13:22:29.635]         }, add = TRUE)
[13:22:29.635]     }
[13:22:29.635]     ...future.frame <- base::sys.nframe()
[13:22:29.635]     ...future.conditions <- base::list()
[13:22:29.635]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:29.635]     if (FALSE) {
[13:22:29.635]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:29.635]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:29.635]     }
[13:22:29.635]     ...future.result <- base::tryCatch({
[13:22:29.635]         base::withCallingHandlers({
[13:22:29.635]             ...future.value <- base::withVisible(base::local({
[13:22:29.635]                 withCallingHandlers({
[13:22:29.635]                   print(42)
[13:22:29.635]                 }, immediateCondition = function(cond) {
[13:22:29.635]                   save_rds <- function (object, pathname, ...) 
[13:22:29.635]                   {
[13:22:29.635]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:22:29.635]                     if (file_test("-f", pathname_tmp)) {
[13:22:29.635]                       fi_tmp <- file.info(pathname_tmp)
[13:22:29.635]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:22:29.635]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:29.635]                         fi_tmp[["mtime"]])
[13:22:29.635]                     }
[13:22:29.635]                     tryCatch({
[13:22:29.635]                       saveRDS(object, file = pathname_tmp, ...)
[13:22:29.635]                     }, error = function(ex) {
[13:22:29.635]                       msg <- conditionMessage(ex)
[13:22:29.635]                       fi_tmp <- file.info(pathname_tmp)
[13:22:29.635]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:22:29.635]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:29.635]                         fi_tmp[["mtime"]], msg)
[13:22:29.635]                       ex$message <- msg
[13:22:29.635]                       stop(ex)
[13:22:29.635]                     })
[13:22:29.635]                     stopifnot(file_test("-f", pathname_tmp))
[13:22:29.635]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:22:29.635]                     if (!res || file_test("-f", pathname_tmp)) {
[13:22:29.635]                       fi_tmp <- file.info(pathname_tmp)
[13:22:29.635]                       fi <- file.info(pathname)
[13:22:29.635]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:22:29.635]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:29.635]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:22:29.635]                         fi[["size"]], fi[["mtime"]])
[13:22:29.635]                       stop(msg)
[13:22:29.635]                     }
[13:22:29.635]                     invisible(pathname)
[13:22:29.635]                   }
[13:22:29.635]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:22:29.635]                     rootPath = tempdir()) 
[13:22:29.635]                   {
[13:22:29.635]                     obj <- list(time = Sys.time(), condition = cond)
[13:22:29.635]                     file <- tempfile(pattern = class(cond)[1], 
[13:22:29.635]                       tmpdir = path, fileext = ".rds")
[13:22:29.635]                     save_rds(obj, file)
[13:22:29.635]                   }
[13:22:29.635]                   saveImmediateCondition(cond, path = "/tmp/RtmpeTCoqm/.future/immediateConditions")
[13:22:29.635]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.635]                   {
[13:22:29.635]                     inherits <- base::inherits
[13:22:29.635]                     invokeRestart <- base::invokeRestart
[13:22:29.635]                     is.null <- base::is.null
[13:22:29.635]                     muffled <- FALSE
[13:22:29.635]                     if (inherits(cond, "message")) {
[13:22:29.635]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:29.635]                       if (muffled) 
[13:22:29.635]                         invokeRestart("muffleMessage")
[13:22:29.635]                     }
[13:22:29.635]                     else if (inherits(cond, "warning")) {
[13:22:29.635]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:29.635]                       if (muffled) 
[13:22:29.635]                         invokeRestart("muffleWarning")
[13:22:29.635]                     }
[13:22:29.635]                     else if (inherits(cond, "condition")) {
[13:22:29.635]                       if (!is.null(pattern)) {
[13:22:29.635]                         computeRestarts <- base::computeRestarts
[13:22:29.635]                         grepl <- base::grepl
[13:22:29.635]                         restarts <- computeRestarts(cond)
[13:22:29.635]                         for (restart in restarts) {
[13:22:29.635]                           name <- restart$name
[13:22:29.635]                           if (is.null(name)) 
[13:22:29.635]                             next
[13:22:29.635]                           if (!grepl(pattern, name)) 
[13:22:29.635]                             next
[13:22:29.635]                           invokeRestart(restart)
[13:22:29.635]                           muffled <- TRUE
[13:22:29.635]                           break
[13:22:29.635]                         }
[13:22:29.635]                       }
[13:22:29.635]                     }
[13:22:29.635]                     invisible(muffled)
[13:22:29.635]                   }
[13:22:29.635]                   muffleCondition(cond)
[13:22:29.635]                 })
[13:22:29.635]             }))
[13:22:29.635]             future::FutureResult(value = ...future.value$value, 
[13:22:29.635]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:29.635]                   ...future.rng), globalenv = if (FALSE) 
[13:22:29.635]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:29.635]                     ...future.globalenv.names))
[13:22:29.635]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:29.635]         }, condition = base::local({
[13:22:29.635]             c <- base::c
[13:22:29.635]             inherits <- base::inherits
[13:22:29.635]             invokeRestart <- base::invokeRestart
[13:22:29.635]             length <- base::length
[13:22:29.635]             list <- base::list
[13:22:29.635]             seq.int <- base::seq.int
[13:22:29.635]             signalCondition <- base::signalCondition
[13:22:29.635]             sys.calls <- base::sys.calls
[13:22:29.635]             `[[` <- base::`[[`
[13:22:29.635]             `+` <- base::`+`
[13:22:29.635]             `<<-` <- base::`<<-`
[13:22:29.635]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:29.635]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:29.635]                   3L)]
[13:22:29.635]             }
[13:22:29.635]             function(cond) {
[13:22:29.635]                 is_error <- inherits(cond, "error")
[13:22:29.635]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:29.635]                   NULL)
[13:22:29.635]                 if (is_error) {
[13:22:29.635]                   sessionInformation <- function() {
[13:22:29.635]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:29.635]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:29.635]                       search = base::search(), system = base::Sys.info())
[13:22:29.635]                   }
[13:22:29.635]                   ...future.conditions[[length(...future.conditions) + 
[13:22:29.635]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:29.635]                     cond$call), session = sessionInformation(), 
[13:22:29.635]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:29.635]                   signalCondition(cond)
[13:22:29.635]                 }
[13:22:29.635]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:29.635]                 "immediateCondition"))) {
[13:22:29.635]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:29.635]                   ...future.conditions[[length(...future.conditions) + 
[13:22:29.635]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:29.635]                   if (TRUE && !signal) {
[13:22:29.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.635]                     {
[13:22:29.635]                       inherits <- base::inherits
[13:22:29.635]                       invokeRestart <- base::invokeRestart
[13:22:29.635]                       is.null <- base::is.null
[13:22:29.635]                       muffled <- FALSE
[13:22:29.635]                       if (inherits(cond, "message")) {
[13:22:29.635]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:29.635]                         if (muffled) 
[13:22:29.635]                           invokeRestart("muffleMessage")
[13:22:29.635]                       }
[13:22:29.635]                       else if (inherits(cond, "warning")) {
[13:22:29.635]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:29.635]                         if (muffled) 
[13:22:29.635]                           invokeRestart("muffleWarning")
[13:22:29.635]                       }
[13:22:29.635]                       else if (inherits(cond, "condition")) {
[13:22:29.635]                         if (!is.null(pattern)) {
[13:22:29.635]                           computeRestarts <- base::computeRestarts
[13:22:29.635]                           grepl <- base::grepl
[13:22:29.635]                           restarts <- computeRestarts(cond)
[13:22:29.635]                           for (restart in restarts) {
[13:22:29.635]                             name <- restart$name
[13:22:29.635]                             if (is.null(name)) 
[13:22:29.635]                               next
[13:22:29.635]                             if (!grepl(pattern, name)) 
[13:22:29.635]                               next
[13:22:29.635]                             invokeRestart(restart)
[13:22:29.635]                             muffled <- TRUE
[13:22:29.635]                             break
[13:22:29.635]                           }
[13:22:29.635]                         }
[13:22:29.635]                       }
[13:22:29.635]                       invisible(muffled)
[13:22:29.635]                     }
[13:22:29.635]                     muffleCondition(cond, pattern = "^muffle")
[13:22:29.635]                   }
[13:22:29.635]                 }
[13:22:29.635]                 else {
[13:22:29.635]                   if (TRUE) {
[13:22:29.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:29.635]                     {
[13:22:29.635]                       inherits <- base::inherits
[13:22:29.635]                       invokeRestart <- base::invokeRestart
[13:22:29.635]                       is.null <- base::is.null
[13:22:29.635]                       muffled <- FALSE
[13:22:29.635]                       if (inherits(cond, "message")) {
[13:22:29.635]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:29.635]                         if (muffled) 
[13:22:29.635]                           invokeRestart("muffleMessage")
[13:22:29.635]                       }
[13:22:29.635]                       else if (inherits(cond, "warning")) {
[13:22:29.635]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:29.635]                         if (muffled) 
[13:22:29.635]                           invokeRestart("muffleWarning")
[13:22:29.635]                       }
[13:22:29.635]                       else if (inherits(cond, "condition")) {
[13:22:29.635]                         if (!is.null(pattern)) {
[13:22:29.635]                           computeRestarts <- base::computeRestarts
[13:22:29.635]                           grepl <- base::grepl
[13:22:29.635]                           restarts <- computeRestarts(cond)
[13:22:29.635]                           for (restart in restarts) {
[13:22:29.635]                             name <- restart$name
[13:22:29.635]                             if (is.null(name)) 
[13:22:29.635]                               next
[13:22:29.635]                             if (!grepl(pattern, name)) 
[13:22:29.635]                               next
[13:22:29.635]                             invokeRestart(restart)
[13:22:29.635]                             muffled <- TRUE
[13:22:29.635]                             break
[13:22:29.635]                           }
[13:22:29.635]                         }
[13:22:29.635]                       }
[13:22:29.635]                       invisible(muffled)
[13:22:29.635]                     }
[13:22:29.635]                     muffleCondition(cond, pattern = "^muffle")
[13:22:29.635]                   }
[13:22:29.635]                 }
[13:22:29.635]             }
[13:22:29.635]         }))
[13:22:29.635]     }, error = function(ex) {
[13:22:29.635]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:29.635]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:29.635]                 ...future.rng), started = ...future.startTime, 
[13:22:29.635]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:29.635]             version = "1.8"), class = "FutureResult")
[13:22:29.635]     }, finally = {
[13:22:29.635]         if (!identical(...future.workdir, getwd())) 
[13:22:29.635]             setwd(...future.workdir)
[13:22:29.635]         {
[13:22:29.635]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:29.635]                 ...future.oldOptions$nwarnings <- NULL
[13:22:29.635]             }
[13:22:29.635]             base::options(...future.oldOptions)
[13:22:29.635]             if (.Platform$OS.type == "windows") {
[13:22:29.635]                 old_names <- names(...future.oldEnvVars)
[13:22:29.635]                 envs <- base::Sys.getenv()
[13:22:29.635]                 names <- names(envs)
[13:22:29.635]                 common <- intersect(names, old_names)
[13:22:29.635]                 added <- setdiff(names, old_names)
[13:22:29.635]                 removed <- setdiff(old_names, names)
[13:22:29.635]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:29.635]                   envs[common]]
[13:22:29.635]                 NAMES <- toupper(changed)
[13:22:29.635]                 args <- list()
[13:22:29.635]                 for (kk in seq_along(NAMES)) {
[13:22:29.635]                   name <- changed[[kk]]
[13:22:29.635]                   NAME <- NAMES[[kk]]
[13:22:29.635]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.635]                     next
[13:22:29.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:29.635]                 }
[13:22:29.635]                 NAMES <- toupper(added)
[13:22:29.635]                 for (kk in seq_along(NAMES)) {
[13:22:29.635]                   name <- added[[kk]]
[13:22:29.635]                   NAME <- NAMES[[kk]]
[13:22:29.635]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.635]                     next
[13:22:29.635]                   args[[name]] <- ""
[13:22:29.635]                 }
[13:22:29.635]                 NAMES <- toupper(removed)
[13:22:29.635]                 for (kk in seq_along(NAMES)) {
[13:22:29.635]                   name <- removed[[kk]]
[13:22:29.635]                   NAME <- NAMES[[kk]]
[13:22:29.635]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:29.635]                     next
[13:22:29.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:29.635]                 }
[13:22:29.635]                 if (length(args) > 0) 
[13:22:29.635]                   base::do.call(base::Sys.setenv, args = args)
[13:22:29.635]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:29.635]             }
[13:22:29.635]             else {
[13:22:29.635]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:29.635]             }
[13:22:29.635]             {
[13:22:29.635]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:29.635]                   0L) {
[13:22:29.635]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:29.635]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:29.635]                   base::options(opts)
[13:22:29.635]                 }
[13:22:29.635]                 {
[13:22:29.635]                   {
[13:22:29.635]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:29.635]                     NULL
[13:22:29.635]                   }
[13:22:29.635]                   options(future.plan = NULL)
[13:22:29.635]                   if (is.na(NA_character_)) 
[13:22:29.635]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:29.635]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:29.635]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:22:29.635]                     envir = parent.frame()) 
[13:22:29.635]                   {
[13:22:29.635]                     default_workers <- missing(workers)
[13:22:29.635]                     if (is.function(workers)) 
[13:22:29.635]                       workers <- workers()
[13:22:29.635]                     workers <- structure(as.integer(workers), 
[13:22:29.635]                       class = class(workers))
[13:22:29.635]                     stop_if_not(is.finite(workers), workers >= 
[13:22:29.635]                       1L)
[13:22:29.635]                     if ((workers == 1L && !inherits(workers, 
[13:22:29.635]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:22:29.635]                       if (default_workers) 
[13:22:29.635]                         supportsMulticore(warn = TRUE)
[13:22:29.635]                       return(sequential(..., envir = envir))
[13:22:29.635]                     }
[13:22:29.635]                     oopts <- options(mc.cores = workers)
[13:22:29.635]                     on.exit(options(oopts))
[13:22:29.635]                     future <- MulticoreFuture(..., workers = workers, 
[13:22:29.635]                       envir = envir)
[13:22:29.635]                     if (!future$lazy) 
[13:22:29.635]                       future <- run(future)
[13:22:29.635]                     invisible(future)
[13:22:29.635]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:29.635]                 }
[13:22:29.635]             }
[13:22:29.635]         }
[13:22:29.635]     })
[13:22:29.635]     if (TRUE) {
[13:22:29.635]         base::sink(type = "output", split = FALSE)
[13:22:29.635]         if (TRUE) {
[13:22:29.635]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:29.635]         }
[13:22:29.635]         else {
[13:22:29.635]             ...future.result["stdout"] <- base::list(NULL)
[13:22:29.635]         }
[13:22:29.635]         base::close(...future.stdout)
[13:22:29.635]         ...future.stdout <- NULL
[13:22:29.635]     }
[13:22:29.635]     ...future.result$conditions <- ...future.conditions
[13:22:29.635]     ...future.result$finished <- base::Sys.time()
[13:22:29.635]     ...future.result
[13:22:29.635] }
[13:22:29.637] requestCore(): workers = 2
[13:22:29.639] MulticoreFuture started
[13:22:29.640] - Launch lazy future ... done
[13:22:29.640] run() for ‘MulticoreFuture’ ... done
[13:22:29.640] plan(): Setting new future strategy stack:
[13:22:29.641] List of future strategies:
[13:22:29.641] 1. sequential:
[13:22:29.641]    - args: function (..., envir = parent.frame())
[13:22:29.641]    - tweaked: FALSE
[13:22:29.641]    - call: NULL
[13:22:29.641] plan(): nbrOfWorkers() = 1
[13:22:29.643] plan(): Setting new future strategy stack:
[13:22:29.644] List of future strategies:
[13:22:29.644] 1. multicore:
[13:22:29.644]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:22:29.644]    - tweaked: FALSE
[13:22:29.644]    - call: plan(strategy)
[13:22:29.649] plan(): nbrOfWorkers() = 2
[1] 42
multicore ... done
multisession ...
[13:22:29.651] plan(): Setting new future strategy stack:
[13:22:29.651] List of future strategies:
[13:22:29.651] 1. multisession:
[13:22:29.651]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:22:29.651]    - tweaked: FALSE
[13:22:29.651]    - call: plan(strategy)
[13:22:29.652] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:22:29.652] multisession:
[13:22:29.652] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:22:29.652] - tweaked: FALSE
[13:22:29.652] - call: plan(strategy)
[13:22:29.659] getGlobalsAndPackages() ...
[13:22:29.659] Not searching for globals
[13:22:29.659] - globals: [0] <none>
[13:22:29.659] getGlobalsAndPackages() ... DONE
[13:22:29.660] [local output] makeClusterPSOCK() ...
[13:22:29.705] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:22:29.711] [local output] Base port: 11048
[13:22:29.711] [local output] Getting setup options for 2 cluster nodes ...
[13:22:29.711] [local output]  - Node 1 of 2 ...
[13:22:29.711] [local output] localMachine=TRUE => revtunnel=FALSE

[13:22:29.712] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpeTCoqm/worker.rank=1.parallelly.parent=93426.16cf24d36e51d.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpeTCoqm/worker.rank=1.parallelly.parent=93426.16cf24d36e51d.pid")'’
[13:22:29.904] - Possible to infer worker's PID: TRUE
[13:22:29.904] [local output] Rscript port: 11048

[13:22:29.904] [local output]  - Node 2 of 2 ...
[13:22:29.905] [local output] localMachine=TRUE => revtunnel=FALSE

[13:22:29.905] [local output] Rscript port: 11048

[13:22:29.906] [local output] Getting setup options for 2 cluster nodes ... done
[13:22:29.906] [local output]  - Parallel setup requested for some PSOCK nodes
[13:22:29.906] [local output] Setting up PSOCK nodes in parallel
[13:22:29.907] List of 36
[13:22:29.907]  $ worker          : chr "localhost"
[13:22:29.907]   ..- attr(*, "localhost")= logi TRUE
[13:22:29.907]  $ master          : chr "localhost"
[13:22:29.907]  $ port            : int 11048
[13:22:29.907]  $ connectTimeout  : num 120
[13:22:29.907]  $ timeout         : num 2592000
[13:22:29.907]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:22:29.907]  $ homogeneous     : logi TRUE
[13:22:29.907]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:22:29.907]  $ rscript_envs    : NULL
[13:22:29.907]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:22:29.907]  $ rscript_startup : NULL
[13:22:29.907]  $ rscript_sh      : chr "sh"
[13:22:29.907]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:22:29.907]  $ methods         : logi TRUE
[13:22:29.907]  $ socketOptions   : chr "no-delay"
[13:22:29.907]  $ useXDR          : logi FALSE
[13:22:29.907]  $ outfile         : chr "/dev/null"
[13:22:29.907]  $ renice          : int NA
[13:22:29.907]  $ rshcmd          : NULL
[13:22:29.907]  $ user            : chr(0) 
[13:22:29.907]  $ revtunnel       : logi FALSE
[13:22:29.907]  $ rshlogfile      : NULL
[13:22:29.907]  $ rshopts         : chr(0) 
[13:22:29.907]  $ rank            : int 1
[13:22:29.907]  $ manual          : logi FALSE
[13:22:29.907]  $ dryrun          : logi FALSE
[13:22:29.907]  $ quiet           : logi FALSE
[13:22:29.907]  $ setup_strategy  : chr "parallel"
[13:22:29.907]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:22:29.907]  $ pidfile         : chr "/tmp/RtmpeTCoqm/worker.rank=1.parallelly.parent=93426.16cf24d36e51d.pid"
[13:22:29.907]  $ rshcmd_label    : NULL
[13:22:29.907]  $ rsh_call        : NULL
[13:22:29.907]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:22:29.907]  $ localMachine    : logi TRUE
[13:22:29.907]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:22:29.907]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:22:29.907]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:22:29.907]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:22:29.907]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:22:29.907]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:22:29.907]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:22:29.907]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:22:29.907]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:22:29.907]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:22:29.907]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:22:29.907]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:22:29.907]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:22:29.907]  $ arguments       :List of 28
[13:22:29.907]   ..$ worker          : chr "localhost"
[13:22:29.907]   ..$ master          : NULL
[13:22:29.907]   ..$ port            : int 11048
[13:22:29.907]   ..$ connectTimeout  : num 120
[13:22:29.907]   ..$ timeout         : num 2592000
[13:22:29.907]   ..$ rscript         : NULL
[13:22:29.907]   ..$ homogeneous     : NULL
[13:22:29.907]   ..$ rscript_args    : NULL
[13:22:29.907]   ..$ rscript_envs    : NULL
[13:22:29.907]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:22:29.907]   ..$ rscript_startup : NULL
[13:22:29.907]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:22:29.907]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:22:29.907]   ..$ methods         : logi TRUE
[13:22:29.907]   ..$ socketOptions   : chr "no-delay"
[13:22:29.907]   ..$ useXDR          : logi FALSE
[13:22:29.907]   ..$ outfile         : chr "/dev/null"
[13:22:29.907]   ..$ renice          : int NA
[13:22:29.907]   ..$ rshcmd          : NULL
[13:22:29.907]   ..$ user            : NULL
[13:22:29.907]   ..$ revtunnel       : logi NA
[13:22:29.907]   ..$ rshlogfile      : NULL
[13:22:29.907]   ..$ rshopts         : NULL
[13:22:29.907]   ..$ rank            : int 1
[13:22:29.907]   ..$ manual          : logi FALSE
[13:22:29.907]   ..$ dryrun          : logi FALSE
[13:22:29.907]   ..$ quiet           : logi FALSE
[13:22:29.907]   ..$ setup_strategy  : chr "parallel"
[13:22:29.907]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:22:29.924] [local output] System call to launch all workers:
[13:22:29.924] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpeTCoqm/worker.rank=1.parallelly.parent=93426.16cf24d36e51d.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11048 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:22:29.924] [local output] Starting PSOCK main server
[13:22:29.925] [local output] Workers launched
[13:22:29.926] [local output] Waiting for workers to connect back
[13:22:29.926]  - [local output] 0 workers out of 2 ready
[13:22:30.178]  - [local output] 0 workers out of 2 ready
[13:22:30.179]  - [local output] 1 workers out of 2 ready
[13:22:30.179]  - [local output] 1 workers out of 2 ready
[13:22:30.180]  - [local output] 2 workers out of 2 ready
[13:22:30.180] [local output] Launching of workers completed
[13:22:30.180] [local output] Collecting session information from workers
[13:22:30.181] [local output]  - Worker #1 of 2
[13:22:30.181] [local output]  - Worker #2 of 2
[13:22:30.182] [local output] makeClusterPSOCK() ... done
[13:22:30.193] Packages needed by the future expression (n = 0): <none>
[13:22:30.194] Packages needed by future strategies (n = 0): <none>
[13:22:30.194] {
[13:22:30.194]     {
[13:22:30.194]         {
[13:22:30.194]             ...future.startTime <- base::Sys.time()
[13:22:30.194]             {
[13:22:30.194]                 {
[13:22:30.194]                   {
[13:22:30.194]                     {
[13:22:30.194]                       base::local({
[13:22:30.194]                         has_future <- base::requireNamespace("future", 
[13:22:30.194]                           quietly = TRUE)
[13:22:30.194]                         if (has_future) {
[13:22:30.194]                           ns <- base::getNamespace("future")
[13:22:30.194]                           version <- ns[[".package"]][["version"]]
[13:22:30.194]                           if (is.null(version)) 
[13:22:30.194]                             version <- utils::packageVersion("future")
[13:22:30.194]                         }
[13:22:30.194]                         else {
[13:22:30.194]                           version <- NULL
[13:22:30.194]                         }
[13:22:30.194]                         if (!has_future || version < "1.8.0") {
[13:22:30.194]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:30.194]                             "", base::R.version$version.string), 
[13:22:30.194]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:30.194]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:30.194]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:30.194]                               "release", "version")], collapse = " "), 
[13:22:30.194]                             hostname = base::Sys.info()[["nodename"]])
[13:22:30.194]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:30.194]                             info)
[13:22:30.194]                           info <- base::paste(info, collapse = "; ")
[13:22:30.194]                           if (!has_future) {
[13:22:30.194]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:30.194]                               info)
[13:22:30.194]                           }
[13:22:30.194]                           else {
[13:22:30.194]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:30.194]                               info, version)
[13:22:30.194]                           }
[13:22:30.194]                           base::stop(msg)
[13:22:30.194]                         }
[13:22:30.194]                       })
[13:22:30.194]                     }
[13:22:30.194]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:30.194]                     base::options(mc.cores = 1L)
[13:22:30.194]                   }
[13:22:30.194]                   options(future.plan = NULL)
[13:22:30.194]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:30.194]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:30.194]                 }
[13:22:30.194]                 ...future.workdir <- getwd()
[13:22:30.194]             }
[13:22:30.194]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:30.194]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:30.194]         }
[13:22:30.194]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:30.194]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:30.194]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:30.194]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:30.194]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:30.194]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:30.194]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:30.194]             base::names(...future.oldOptions))
[13:22:30.194]     }
[13:22:30.194]     if (FALSE) {
[13:22:30.194]     }
[13:22:30.194]     else {
[13:22:30.194]         if (TRUE) {
[13:22:30.194]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:30.194]                 open = "w")
[13:22:30.194]         }
[13:22:30.194]         else {
[13:22:30.194]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:30.194]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:30.194]         }
[13:22:30.194]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:30.194]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:30.194]             base::sink(type = "output", split = FALSE)
[13:22:30.194]             base::close(...future.stdout)
[13:22:30.194]         }, add = TRUE)
[13:22:30.194]     }
[13:22:30.194]     ...future.frame <- base::sys.nframe()
[13:22:30.194]     ...future.conditions <- base::list()
[13:22:30.194]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:30.194]     if (FALSE) {
[13:22:30.194]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:30.194]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:30.194]     }
[13:22:30.194]     ...future.result <- base::tryCatch({
[13:22:30.194]         base::withCallingHandlers({
[13:22:30.194]             ...future.value <- base::withVisible(base::local({
[13:22:30.194]                 ...future.makeSendCondition <- local({
[13:22:30.194]                   sendCondition <- NULL
[13:22:30.194]                   function(frame = 1L) {
[13:22:30.194]                     if (is.function(sendCondition)) 
[13:22:30.194]                       return(sendCondition)
[13:22:30.194]                     ns <- getNamespace("parallel")
[13:22:30.194]                     if (exists("sendData", mode = "function", 
[13:22:30.194]                       envir = ns)) {
[13:22:30.194]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:30.194]                         envir = ns)
[13:22:30.194]                       envir <- sys.frame(frame)
[13:22:30.194]                       master <- NULL
[13:22:30.194]                       while (!identical(envir, .GlobalEnv) && 
[13:22:30.194]                         !identical(envir, emptyenv())) {
[13:22:30.194]                         if (exists("master", mode = "list", envir = envir, 
[13:22:30.194]                           inherits = FALSE)) {
[13:22:30.194]                           master <- get("master", mode = "list", 
[13:22:30.194]                             envir = envir, inherits = FALSE)
[13:22:30.194]                           if (inherits(master, c("SOCKnode", 
[13:22:30.194]                             "SOCK0node"))) {
[13:22:30.194]                             sendCondition <<- function(cond) {
[13:22:30.194]                               data <- list(type = "VALUE", value = cond, 
[13:22:30.194]                                 success = TRUE)
[13:22:30.194]                               parallel_sendData(master, data)
[13:22:30.194]                             }
[13:22:30.194]                             return(sendCondition)
[13:22:30.194]                           }
[13:22:30.194]                         }
[13:22:30.194]                         frame <- frame + 1L
[13:22:30.194]                         envir <- sys.frame(frame)
[13:22:30.194]                       }
[13:22:30.194]                     }
[13:22:30.194]                     sendCondition <<- function(cond) NULL
[13:22:30.194]                   }
[13:22:30.194]                 })
[13:22:30.194]                 withCallingHandlers({
[13:22:30.194]                   NA
[13:22:30.194]                 }, immediateCondition = function(cond) {
[13:22:30.194]                   sendCondition <- ...future.makeSendCondition()
[13:22:30.194]                   sendCondition(cond)
[13:22:30.194]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:30.194]                   {
[13:22:30.194]                     inherits <- base::inherits
[13:22:30.194]                     invokeRestart <- base::invokeRestart
[13:22:30.194]                     is.null <- base::is.null
[13:22:30.194]                     muffled <- FALSE
[13:22:30.194]                     if (inherits(cond, "message")) {
[13:22:30.194]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:30.194]                       if (muffled) 
[13:22:30.194]                         invokeRestart("muffleMessage")
[13:22:30.194]                     }
[13:22:30.194]                     else if (inherits(cond, "warning")) {
[13:22:30.194]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:30.194]                       if (muffled) 
[13:22:30.194]                         invokeRestart("muffleWarning")
[13:22:30.194]                     }
[13:22:30.194]                     else if (inherits(cond, "condition")) {
[13:22:30.194]                       if (!is.null(pattern)) {
[13:22:30.194]                         computeRestarts <- base::computeRestarts
[13:22:30.194]                         grepl <- base::grepl
[13:22:30.194]                         restarts <- computeRestarts(cond)
[13:22:30.194]                         for (restart in restarts) {
[13:22:30.194]                           name <- restart$name
[13:22:30.194]                           if (is.null(name)) 
[13:22:30.194]                             next
[13:22:30.194]                           if (!grepl(pattern, name)) 
[13:22:30.194]                             next
[13:22:30.194]                           invokeRestart(restart)
[13:22:30.194]                           muffled <- TRUE
[13:22:30.194]                           break
[13:22:30.194]                         }
[13:22:30.194]                       }
[13:22:30.194]                     }
[13:22:30.194]                     invisible(muffled)
[13:22:30.194]                   }
[13:22:30.194]                   muffleCondition(cond)
[13:22:30.194]                 })
[13:22:30.194]             }))
[13:22:30.194]             future::FutureResult(value = ...future.value$value, 
[13:22:30.194]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:30.194]                   ...future.rng), globalenv = if (FALSE) 
[13:22:30.194]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:30.194]                     ...future.globalenv.names))
[13:22:30.194]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:30.194]         }, condition = base::local({
[13:22:30.194]             c <- base::c
[13:22:30.194]             inherits <- base::inherits
[13:22:30.194]             invokeRestart <- base::invokeRestart
[13:22:30.194]             length <- base::length
[13:22:30.194]             list <- base::list
[13:22:30.194]             seq.int <- base::seq.int
[13:22:30.194]             signalCondition <- base::signalCondition
[13:22:30.194]             sys.calls <- base::sys.calls
[13:22:30.194]             `[[` <- base::`[[`
[13:22:30.194]             `+` <- base::`+`
[13:22:30.194]             `<<-` <- base::`<<-`
[13:22:30.194]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:30.194]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:30.194]                   3L)]
[13:22:30.194]             }
[13:22:30.194]             function(cond) {
[13:22:30.194]                 is_error <- inherits(cond, "error")
[13:22:30.194]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:30.194]                   NULL)
[13:22:30.194]                 if (is_error) {
[13:22:30.194]                   sessionInformation <- function() {
[13:22:30.194]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:30.194]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:30.194]                       search = base::search(), system = base::Sys.info())
[13:22:30.194]                   }
[13:22:30.194]                   ...future.conditions[[length(...future.conditions) + 
[13:22:30.194]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:30.194]                     cond$call), session = sessionInformation(), 
[13:22:30.194]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:30.194]                   signalCondition(cond)
[13:22:30.194]                 }
[13:22:30.194]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:30.194]                 "immediateCondition"))) {
[13:22:30.194]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:30.194]                   ...future.conditions[[length(...future.conditions) + 
[13:22:30.194]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:30.194]                   if (TRUE && !signal) {
[13:22:30.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:30.194]                     {
[13:22:30.194]                       inherits <- base::inherits
[13:22:30.194]                       invokeRestart <- base::invokeRestart
[13:22:30.194]                       is.null <- base::is.null
[13:22:30.194]                       muffled <- FALSE
[13:22:30.194]                       if (inherits(cond, "message")) {
[13:22:30.194]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:30.194]                         if (muffled) 
[13:22:30.194]                           invokeRestart("muffleMessage")
[13:22:30.194]                       }
[13:22:30.194]                       else if (inherits(cond, "warning")) {
[13:22:30.194]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:30.194]                         if (muffled) 
[13:22:30.194]                           invokeRestart("muffleWarning")
[13:22:30.194]                       }
[13:22:30.194]                       else if (inherits(cond, "condition")) {
[13:22:30.194]                         if (!is.null(pattern)) {
[13:22:30.194]                           computeRestarts <- base::computeRestarts
[13:22:30.194]                           grepl <- base::grepl
[13:22:30.194]                           restarts <- computeRestarts(cond)
[13:22:30.194]                           for (restart in restarts) {
[13:22:30.194]                             name <- restart$name
[13:22:30.194]                             if (is.null(name)) 
[13:22:30.194]                               next
[13:22:30.194]                             if (!grepl(pattern, name)) 
[13:22:30.194]                               next
[13:22:30.194]                             invokeRestart(restart)
[13:22:30.194]                             muffled <- TRUE
[13:22:30.194]                             break
[13:22:30.194]                           }
[13:22:30.194]                         }
[13:22:30.194]                       }
[13:22:30.194]                       invisible(muffled)
[13:22:30.194]                     }
[13:22:30.194]                     muffleCondition(cond, pattern = "^muffle")
[13:22:30.194]                   }
[13:22:30.194]                 }
[13:22:30.194]                 else {
[13:22:30.194]                   if (TRUE) {
[13:22:30.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:30.194]                     {
[13:22:30.194]                       inherits <- base::inherits
[13:22:30.194]                       invokeRestart <- base::invokeRestart
[13:22:30.194]                       is.null <- base::is.null
[13:22:30.194]                       muffled <- FALSE
[13:22:30.194]                       if (inherits(cond, "message")) {
[13:22:30.194]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:30.194]                         if (muffled) 
[13:22:30.194]                           invokeRestart("muffleMessage")
[13:22:30.194]                       }
[13:22:30.194]                       else if (inherits(cond, "warning")) {
[13:22:30.194]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:30.194]                         if (muffled) 
[13:22:30.194]                           invokeRestart("muffleWarning")
[13:22:30.194]                       }
[13:22:30.194]                       else if (inherits(cond, "condition")) {
[13:22:30.194]                         if (!is.null(pattern)) {
[13:22:30.194]                           computeRestarts <- base::computeRestarts
[13:22:30.194]                           grepl <- base::grepl
[13:22:30.194]                           restarts <- computeRestarts(cond)
[13:22:30.194]                           for (restart in restarts) {
[13:22:30.194]                             name <- restart$name
[13:22:30.194]                             if (is.null(name)) 
[13:22:30.194]                               next
[13:22:30.194]                             if (!grepl(pattern, name)) 
[13:22:30.194]                               next
[13:22:30.194]                             invokeRestart(restart)
[13:22:30.194]                             muffled <- TRUE
[13:22:30.194]                             break
[13:22:30.194]                           }
[13:22:30.194]                         }
[13:22:30.194]                       }
[13:22:30.194]                       invisible(muffled)
[13:22:30.194]                     }
[13:22:30.194]                     muffleCondition(cond, pattern = "^muffle")
[13:22:30.194]                   }
[13:22:30.194]                 }
[13:22:30.194]             }
[13:22:30.194]         }))
[13:22:30.194]     }, error = function(ex) {
[13:22:30.194]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:30.194]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:30.194]                 ...future.rng), started = ...future.startTime, 
[13:22:30.194]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:30.194]             version = "1.8"), class = "FutureResult")
[13:22:30.194]     }, finally = {
[13:22:30.194]         if (!identical(...future.workdir, getwd())) 
[13:22:30.194]             setwd(...future.workdir)
[13:22:30.194]         {
[13:22:30.194]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:30.194]                 ...future.oldOptions$nwarnings <- NULL
[13:22:30.194]             }
[13:22:30.194]             base::options(...future.oldOptions)
[13:22:30.194]             if (.Platform$OS.type == "windows") {
[13:22:30.194]                 old_names <- names(...future.oldEnvVars)
[13:22:30.194]                 envs <- base::Sys.getenv()
[13:22:30.194]                 names <- names(envs)
[13:22:30.194]                 common <- intersect(names, old_names)
[13:22:30.194]                 added <- setdiff(names, old_names)
[13:22:30.194]                 removed <- setdiff(old_names, names)
[13:22:30.194]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:30.194]                   envs[common]]
[13:22:30.194]                 NAMES <- toupper(changed)
[13:22:30.194]                 args <- list()
[13:22:30.194]                 for (kk in seq_along(NAMES)) {
[13:22:30.194]                   name <- changed[[kk]]
[13:22:30.194]                   NAME <- NAMES[[kk]]
[13:22:30.194]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:30.194]                     next
[13:22:30.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:30.194]                 }
[13:22:30.194]                 NAMES <- toupper(added)
[13:22:30.194]                 for (kk in seq_along(NAMES)) {
[13:22:30.194]                   name <- added[[kk]]
[13:22:30.194]                   NAME <- NAMES[[kk]]
[13:22:30.194]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:30.194]                     next
[13:22:30.194]                   args[[name]] <- ""
[13:22:30.194]                 }
[13:22:30.194]                 NAMES <- toupper(removed)
[13:22:30.194]                 for (kk in seq_along(NAMES)) {
[13:22:30.194]                   name <- removed[[kk]]
[13:22:30.194]                   NAME <- NAMES[[kk]]
[13:22:30.194]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:30.194]                     next
[13:22:30.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:30.194]                 }
[13:22:30.194]                 if (length(args) > 0) 
[13:22:30.194]                   base::do.call(base::Sys.setenv, args = args)
[13:22:30.194]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:30.194]             }
[13:22:30.194]             else {
[13:22:30.194]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:30.194]             }
[13:22:30.194]             {
[13:22:30.194]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:30.194]                   0L) {
[13:22:30.194]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:30.194]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:30.194]                   base::options(opts)
[13:22:30.194]                 }
[13:22:30.194]                 {
[13:22:30.194]                   {
[13:22:30.194]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:30.194]                     NULL
[13:22:30.194]                   }
[13:22:30.194]                   options(future.plan = NULL)
[13:22:30.194]                   if (is.na(NA_character_)) 
[13:22:30.194]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:30.194]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:30.194]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:30.194]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:30.194]                     envir = parent.frame()) 
[13:22:30.194]                   {
[13:22:30.194]                     if (is.function(workers)) 
[13:22:30.194]                       workers <- workers()
[13:22:30.194]                     workers <- structure(as.integer(workers), 
[13:22:30.194]                       class = class(workers))
[13:22:30.194]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:30.194]                       workers >= 1)
[13:22:30.194]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:30.194]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:30.194]                     }
[13:22:30.194]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:30.194]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:30.194]                       envir = envir)
[13:22:30.194]                     if (!future$lazy) 
[13:22:30.194]                       future <- run(future)
[13:22:30.194]                     invisible(future)
[13:22:30.194]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:30.194]                 }
[13:22:30.194]             }
[13:22:30.194]         }
[13:22:30.194]     })
[13:22:30.194]     if (TRUE) {
[13:22:30.194]         base::sink(type = "output", split = FALSE)
[13:22:30.194]         if (TRUE) {
[13:22:30.194]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:30.194]         }
[13:22:30.194]         else {
[13:22:30.194]             ...future.result["stdout"] <- base::list(NULL)
[13:22:30.194]         }
[13:22:30.194]         base::close(...future.stdout)
[13:22:30.194]         ...future.stdout <- NULL
[13:22:30.194]     }
[13:22:30.194]     ...future.result$conditions <- ...future.conditions
[13:22:30.194]     ...future.result$finished <- base::Sys.time()
[13:22:30.194]     ...future.result
[13:22:30.194] }
[13:22:30.267] MultisessionFuture started
[13:22:30.267] result() for ClusterFuture ...
[13:22:30.268] receiveMessageFromWorker() for ClusterFuture ...
[13:22:30.268] - Validating connection of MultisessionFuture
[13:22:30.300] - received message: FutureResult
[13:22:30.301] - Received FutureResult
[13:22:30.301] - Erased future from FutureRegistry
[13:22:30.301] result() for ClusterFuture ...
[13:22:30.301] - result already collected: FutureResult
[13:22:30.301] result() for ClusterFuture ... done
[13:22:30.301] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:30.301] result() for ClusterFuture ... done
[13:22:30.301] result() for ClusterFuture ...
[13:22:30.302] - result already collected: FutureResult
[13:22:30.302] result() for ClusterFuture ... done
[13:22:30.302] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:22:30.306] plan(): nbrOfWorkers() = 2
- stdout = TRUE
[13:22:30.306] getGlobalsAndPackages() ...
[13:22:30.306] Searching for globals...
[13:22:30.310] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[13:22:30.310] Searching for globals ... DONE
[13:22:30.310] Resolving globals: FALSE
[13:22:30.311] 
[13:22:30.311] - packages: [1] ‘utils’
[13:22:30.311] getGlobalsAndPackages() ... DONE
[13:22:30.311] run() for ‘Future’ ...
[13:22:30.312] - state: ‘created’
[13:22:30.312] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:30.327] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:30.327] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:30.327]   - Field: ‘node’
[13:22:30.327]   - Field: ‘label’
[13:22:30.327]   - Field: ‘local’
[13:22:30.327]   - Field: ‘owner’
[13:22:30.327]   - Field: ‘envir’
[13:22:30.328]   - Field: ‘workers’
[13:22:30.328]   - Field: ‘packages’
[13:22:30.328]   - Field: ‘gc’
[13:22:30.328]   - Field: ‘conditions’
[13:22:30.328]   - Field: ‘persistent’
[13:22:30.328]   - Field: ‘expr’
[13:22:30.328]   - Field: ‘uuid’
[13:22:30.328]   - Field: ‘seed’
[13:22:30.328]   - Field: ‘version’
[13:22:30.329]   - Field: ‘result’
[13:22:30.329]   - Field: ‘asynchronous’
[13:22:30.329]   - Field: ‘calls’
[13:22:30.329]   - Field: ‘globals’
[13:22:30.329]   - Field: ‘stdout’
[13:22:30.329]   - Field: ‘earlySignal’
[13:22:30.329]   - Field: ‘lazy’
[13:22:30.329]   - Field: ‘state’
[13:22:30.329] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:30.330] - Launch lazy future ...
[13:22:30.330] Packages needed by the future expression (n = 1): ‘utils’
[13:22:30.330] Packages needed by future strategies (n = 0): <none>
[13:22:30.331] {
[13:22:30.331]     {
[13:22:30.331]         {
[13:22:30.331]             ...future.startTime <- base::Sys.time()
[13:22:30.331]             {
[13:22:30.331]                 {
[13:22:30.331]                   {
[13:22:30.331]                     {
[13:22:30.331]                       {
[13:22:30.331]                         base::local({
[13:22:30.331]                           has_future <- base::requireNamespace("future", 
[13:22:30.331]                             quietly = TRUE)
[13:22:30.331]                           if (has_future) {
[13:22:30.331]                             ns <- base::getNamespace("future")
[13:22:30.331]                             version <- ns[[".package"]][["version"]]
[13:22:30.331]                             if (is.null(version)) 
[13:22:30.331]                               version <- utils::packageVersion("future")
[13:22:30.331]                           }
[13:22:30.331]                           else {
[13:22:30.331]                             version <- NULL
[13:22:30.331]                           }
[13:22:30.331]                           if (!has_future || version < "1.8.0") {
[13:22:30.331]                             info <- base::c(r_version = base::gsub("R version ", 
[13:22:30.331]                               "", base::R.version$version.string), 
[13:22:30.331]                               platform = base::sprintf("%s (%s-bit)", 
[13:22:30.331]                                 base::R.version$platform, 8 * 
[13:22:30.331]                                   base::.Machine$sizeof.pointer), 
[13:22:30.331]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:30.331]                                 "release", "version")], collapse = " "), 
[13:22:30.331]                               hostname = base::Sys.info()[["nodename"]])
[13:22:30.331]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:22:30.331]                               info)
[13:22:30.331]                             info <- base::paste(info, collapse = "; ")
[13:22:30.331]                             if (!has_future) {
[13:22:30.331]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:30.331]                                 info)
[13:22:30.331]                             }
[13:22:30.331]                             else {
[13:22:30.331]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:30.331]                                 info, version)
[13:22:30.331]                             }
[13:22:30.331]                             base::stop(msg)
[13:22:30.331]                           }
[13:22:30.331]                         })
[13:22:30.331]                       }
[13:22:30.331]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:30.331]                       base::options(mc.cores = 1L)
[13:22:30.331]                     }
[13:22:30.331]                     base::local({
[13:22:30.331]                       for (pkg in "utils") {
[13:22:30.331]                         base::loadNamespace(pkg)
[13:22:30.331]                         base::library(pkg, character.only = TRUE)
[13:22:30.331]                       }
[13:22:30.331]                     })
[13:22:30.331]                   }
[13:22:30.331]                   options(future.plan = NULL)
[13:22:30.331]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:30.331]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:30.331]                 }
[13:22:30.331]                 ...future.workdir <- getwd()
[13:22:30.331]             }
[13:22:30.331]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:30.331]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:30.331]         }
[13:22:30.331]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:30.331]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:30.331]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:30.331]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:30.331]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:30.331]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:30.331]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:30.331]             base::names(...future.oldOptions))
[13:22:30.331]     }
[13:22:30.331]     if (FALSE) {
[13:22:30.331]     }
[13:22:30.331]     else {
[13:22:30.331]         if (TRUE) {
[13:22:30.331]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:30.331]                 open = "w")
[13:22:30.331]         }
[13:22:30.331]         else {
[13:22:30.331]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:30.331]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:30.331]         }
[13:22:30.331]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:30.331]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:30.331]             base::sink(type = "output", split = FALSE)
[13:22:30.331]             base::close(...future.stdout)
[13:22:30.331]         }, add = TRUE)
[13:22:30.331]     }
[13:22:30.331]     ...future.frame <- base::sys.nframe()
[13:22:30.331]     ...future.conditions <- base::list()
[13:22:30.331]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:30.331]     if (FALSE) {
[13:22:30.331]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:30.331]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:30.331]     }
[13:22:30.331]     ...future.result <- base::tryCatch({
[13:22:30.331]         base::withCallingHandlers({
[13:22:30.331]             ...future.value <- base::withVisible(base::local({
[13:22:30.331]                 ...future.makeSendCondition <- local({
[13:22:30.331]                   sendCondition <- NULL
[13:22:30.331]                   function(frame = 1L) {
[13:22:30.331]                     if (is.function(sendCondition)) 
[13:22:30.331]                       return(sendCondition)
[13:22:30.331]                     ns <- getNamespace("parallel")
[13:22:30.331]                     if (exists("sendData", mode = "function", 
[13:22:30.331]                       envir = ns)) {
[13:22:30.331]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:30.331]                         envir = ns)
[13:22:30.331]                       envir <- sys.frame(frame)
[13:22:30.331]                       master <- NULL
[13:22:30.331]                       while (!identical(envir, .GlobalEnv) && 
[13:22:30.331]                         !identical(envir, emptyenv())) {
[13:22:30.331]                         if (exists("master", mode = "list", envir = envir, 
[13:22:30.331]                           inherits = FALSE)) {
[13:22:30.331]                           master <- get("master", mode = "list", 
[13:22:30.331]                             envir = envir, inherits = FALSE)
[13:22:30.331]                           if (inherits(master, c("SOCKnode", 
[13:22:30.331]                             "SOCK0node"))) {
[13:22:30.331]                             sendCondition <<- function(cond) {
[13:22:30.331]                               data <- list(type = "VALUE", value = cond, 
[13:22:30.331]                                 success = TRUE)
[13:22:30.331]                               parallel_sendData(master, data)
[13:22:30.331]                             }
[13:22:30.331]                             return(sendCondition)
[13:22:30.331]                           }
[13:22:30.331]                         }
[13:22:30.331]                         frame <- frame + 1L
[13:22:30.331]                         envir <- sys.frame(frame)
[13:22:30.331]                       }
[13:22:30.331]                     }
[13:22:30.331]                     sendCondition <<- function(cond) NULL
[13:22:30.331]                   }
[13:22:30.331]                 })
[13:22:30.331]                 withCallingHandlers({
[13:22:30.331]                   {
[13:22:30.331]                     print(1:50)
[13:22:30.331]                     str(1:50)
[13:22:30.331]                     cat(letters, sep = "-")
[13:22:30.331]                     cat(1:6, collapse = "\n")
[13:22:30.331]                     write.table(datasets::iris[1:10, ], sep = "\t")
[13:22:30.331]                     42L
[13:22:30.331]                   }
[13:22:30.331]                 }, immediateCondition = function(cond) {
[13:22:30.331]                   sendCondition <- ...future.makeSendCondition()
[13:22:30.331]                   sendCondition(cond)
[13:22:30.331]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:30.331]                   {
[13:22:30.331]                     inherits <- base::inherits
[13:22:30.331]                     invokeRestart <- base::invokeRestart
[13:22:30.331]                     is.null <- base::is.null
[13:22:30.331]                     muffled <- FALSE
[13:22:30.331]                     if (inherits(cond, "message")) {
[13:22:30.331]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:30.331]                       if (muffled) 
[13:22:30.331]                         invokeRestart("muffleMessage")
[13:22:30.331]                     }
[13:22:30.331]                     else if (inherits(cond, "warning")) {
[13:22:30.331]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:30.331]                       if (muffled) 
[13:22:30.331]                         invokeRestart("muffleWarning")
[13:22:30.331]                     }
[13:22:30.331]                     else if (inherits(cond, "condition")) {
[13:22:30.331]                       if (!is.null(pattern)) {
[13:22:30.331]                         computeRestarts <- base::computeRestarts
[13:22:30.331]                         grepl <- base::grepl
[13:22:30.331]                         restarts <- computeRestarts(cond)
[13:22:30.331]                         for (restart in restarts) {
[13:22:30.331]                           name <- restart$name
[13:22:30.331]                           if (is.null(name)) 
[13:22:30.331]                             next
[13:22:30.331]                           if (!grepl(pattern, name)) 
[13:22:30.331]                             next
[13:22:30.331]                           invokeRestart(restart)
[13:22:30.331]                           muffled <- TRUE
[13:22:30.331]                           break
[13:22:30.331]                         }
[13:22:30.331]                       }
[13:22:30.331]                     }
[13:22:30.331]                     invisible(muffled)
[13:22:30.331]                   }
[13:22:30.331]                   muffleCondition(cond)
[13:22:30.331]                 })
[13:22:30.331]             }))
[13:22:30.331]             future::FutureResult(value = ...future.value$value, 
[13:22:30.331]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:30.331]                   ...future.rng), globalenv = if (FALSE) 
[13:22:30.331]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:30.331]                     ...future.globalenv.names))
[13:22:30.331]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:30.331]         }, condition = base::local({
[13:22:30.331]             c <- base::c
[13:22:30.331]             inherits <- base::inherits
[13:22:30.331]             invokeRestart <- base::invokeRestart
[13:22:30.331]             length <- base::length
[13:22:30.331]             list <- base::list
[13:22:30.331]             seq.int <- base::seq.int
[13:22:30.331]             signalCondition <- base::signalCondition
[13:22:30.331]             sys.calls <- base::sys.calls
[13:22:30.331]             `[[` <- base::`[[`
[13:22:30.331]             `+` <- base::`+`
[13:22:30.331]             `<<-` <- base::`<<-`
[13:22:30.331]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:30.331]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:30.331]                   3L)]
[13:22:30.331]             }
[13:22:30.331]             function(cond) {
[13:22:30.331]                 is_error <- inherits(cond, "error")
[13:22:30.331]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:30.331]                   NULL)
[13:22:30.331]                 if (is_error) {
[13:22:30.331]                   sessionInformation <- function() {
[13:22:30.331]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:30.331]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:30.331]                       search = base::search(), system = base::Sys.info())
[13:22:30.331]                   }
[13:22:30.331]                   ...future.conditions[[length(...future.conditions) + 
[13:22:30.331]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:30.331]                     cond$call), session = sessionInformation(), 
[13:22:30.331]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:30.331]                   signalCondition(cond)
[13:22:30.331]                 }
[13:22:30.331]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:30.331]                 "immediateCondition"))) {
[13:22:30.331]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:30.331]                   ...future.conditions[[length(...future.conditions) + 
[13:22:30.331]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:30.331]                   if (TRUE && !signal) {
[13:22:30.331]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:30.331]                     {
[13:22:30.331]                       inherits <- base::inherits
[13:22:30.331]                       invokeRestart <- base::invokeRestart
[13:22:30.331]                       is.null <- base::is.null
[13:22:30.331]                       muffled <- FALSE
[13:22:30.331]                       if (inherits(cond, "message")) {
[13:22:30.331]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:30.331]                         if (muffled) 
[13:22:30.331]                           invokeRestart("muffleMessage")
[13:22:30.331]                       }
[13:22:30.331]                       else if (inherits(cond, "warning")) {
[13:22:30.331]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:30.331]                         if (muffled) 
[13:22:30.331]                           invokeRestart("muffleWarning")
[13:22:30.331]                       }
[13:22:30.331]                       else if (inherits(cond, "condition")) {
[13:22:30.331]                         if (!is.null(pattern)) {
[13:22:30.331]                           computeRestarts <- base::computeRestarts
[13:22:30.331]                           grepl <- base::grepl
[13:22:30.331]                           restarts <- computeRestarts(cond)
[13:22:30.331]                           for (restart in restarts) {
[13:22:30.331]                             name <- restart$name
[13:22:30.331]                             if (is.null(name)) 
[13:22:30.331]                               next
[13:22:30.331]                             if (!grepl(pattern, name)) 
[13:22:30.331]                               next
[13:22:30.331]                             invokeRestart(restart)
[13:22:30.331]                             muffled <- TRUE
[13:22:30.331]                             break
[13:22:30.331]                           }
[13:22:30.331]                         }
[13:22:30.331]                       }
[13:22:30.331]                       invisible(muffled)
[13:22:30.331]                     }
[13:22:30.331]                     muffleCondition(cond, pattern = "^muffle")
[13:22:30.331]                   }
[13:22:30.331]                 }
[13:22:30.331]                 else {
[13:22:30.331]                   if (TRUE) {
[13:22:30.331]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:30.331]                     {
[13:22:30.331]                       inherits <- base::inherits
[13:22:30.331]                       invokeRestart <- base::invokeRestart
[13:22:30.331]                       is.null <- base::is.null
[13:22:30.331]                       muffled <- FALSE
[13:22:30.331]                       if (inherits(cond, "message")) {
[13:22:30.331]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:30.331]                         if (muffled) 
[13:22:30.331]                           invokeRestart("muffleMessage")
[13:22:30.331]                       }
[13:22:30.331]                       else if (inherits(cond, "warning")) {
[13:22:30.331]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:30.331]                         if (muffled) 
[13:22:30.331]                           invokeRestart("muffleWarning")
[13:22:30.331]                       }
[13:22:30.331]                       else if (inherits(cond, "condition")) {
[13:22:30.331]                         if (!is.null(pattern)) {
[13:22:30.331]                           computeRestarts <- base::computeRestarts
[13:22:30.331]                           grepl <- base::grepl
[13:22:30.331]                           restarts <- computeRestarts(cond)
[13:22:30.331]                           for (restart in restarts) {
[13:22:30.331]                             name <- restart$name
[13:22:30.331]                             if (is.null(name)) 
[13:22:30.331]                               next
[13:22:30.331]                             if (!grepl(pattern, name)) 
[13:22:30.331]                               next
[13:22:30.331]                             invokeRestart(restart)
[13:22:30.331]                             muffled <- TRUE
[13:22:30.331]                             break
[13:22:30.331]                           }
[13:22:30.331]                         }
[13:22:30.331]                       }
[13:22:30.331]                       invisible(muffled)
[13:22:30.331]                     }
[13:22:30.331]                     muffleCondition(cond, pattern = "^muffle")
[13:22:30.331]                   }
[13:22:30.331]                 }
[13:22:30.331]             }
[13:22:30.331]         }))
[13:22:30.331]     }, error = function(ex) {
[13:22:30.331]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:30.331]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:30.331]                 ...future.rng), started = ...future.startTime, 
[13:22:30.331]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:30.331]             version = "1.8"), class = "FutureResult")
[13:22:30.331]     }, finally = {
[13:22:30.331]         if (!identical(...future.workdir, getwd())) 
[13:22:30.331]             setwd(...future.workdir)
[13:22:30.331]         {
[13:22:30.331]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:30.331]                 ...future.oldOptions$nwarnings <- NULL
[13:22:30.331]             }
[13:22:30.331]             base::options(...future.oldOptions)
[13:22:30.331]             if (.Platform$OS.type == "windows") {
[13:22:30.331]                 old_names <- names(...future.oldEnvVars)
[13:22:30.331]                 envs <- base::Sys.getenv()
[13:22:30.331]                 names <- names(envs)
[13:22:30.331]                 common <- intersect(names, old_names)
[13:22:30.331]                 added <- setdiff(names, old_names)
[13:22:30.331]                 removed <- setdiff(old_names, names)
[13:22:30.331]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:30.331]                   envs[common]]
[13:22:30.331]                 NAMES <- toupper(changed)
[13:22:30.331]                 args <- list()
[13:22:30.331]                 for (kk in seq_along(NAMES)) {
[13:22:30.331]                   name <- changed[[kk]]
[13:22:30.331]                   NAME <- NAMES[[kk]]
[13:22:30.331]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:30.331]                     next
[13:22:30.331]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:30.331]                 }
[13:22:30.331]                 NAMES <- toupper(added)
[13:22:30.331]                 for (kk in seq_along(NAMES)) {
[13:22:30.331]                   name <- added[[kk]]
[13:22:30.331]                   NAME <- NAMES[[kk]]
[13:22:30.331]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:30.331]                     next
[13:22:30.331]                   args[[name]] <- ""
[13:22:30.331]                 }
[13:22:30.331]                 NAMES <- toupper(removed)
[13:22:30.331]                 for (kk in seq_along(NAMES)) {
[13:22:30.331]                   name <- removed[[kk]]
[13:22:30.331]                   NAME <- NAMES[[kk]]
[13:22:30.331]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:30.331]                     next
[13:22:30.331]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:30.331]                 }
[13:22:30.331]                 if (length(args) > 0) 
[13:22:30.331]                   base::do.call(base::Sys.setenv, args = args)
[13:22:30.331]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:30.331]             }
[13:22:30.331]             else {
[13:22:30.331]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:30.331]             }
[13:22:30.331]             {
[13:22:30.331]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:30.331]                   0L) {
[13:22:30.331]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:30.331]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:30.331]                   base::options(opts)
[13:22:30.331]                 }
[13:22:30.331]                 {
[13:22:30.331]                   {
[13:22:30.331]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:30.331]                     NULL
[13:22:30.331]                   }
[13:22:30.331]                   options(future.plan = NULL)
[13:22:30.331]                   if (is.na(NA_character_)) 
[13:22:30.331]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:30.331]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:30.331]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:30.331]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:30.331]                     envir = parent.frame()) 
[13:22:30.331]                   {
[13:22:30.331]                     if (is.function(workers)) 
[13:22:30.331]                       workers <- workers()
[13:22:30.331]                     workers <- structure(as.integer(workers), 
[13:22:30.331]                       class = class(workers))
[13:22:30.331]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:30.331]                       workers >= 1)
[13:22:30.331]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:30.331]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:30.331]                     }
[13:22:30.331]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:30.331]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:30.331]                       envir = envir)
[13:22:30.331]                     if (!future$lazy) 
[13:22:30.331]                       future <- run(future)
[13:22:30.331]                     invisible(future)
[13:22:30.331]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:30.331]                 }
[13:22:30.331]             }
[13:22:30.331]         }
[13:22:30.331]     })
[13:22:30.331]     if (TRUE) {
[13:22:30.331]         base::sink(type = "output", split = FALSE)
[13:22:30.331]         if (TRUE) {
[13:22:30.331]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:30.331]         }
[13:22:30.331]         else {
[13:22:30.331]             ...future.result["stdout"] <- base::list(NULL)
[13:22:30.331]         }
[13:22:30.331]         base::close(...future.stdout)
[13:22:30.331]         ...future.stdout <- NULL
[13:22:30.331]     }
[13:22:30.331]     ...future.result$conditions <- ...future.conditions
[13:22:30.331]     ...future.result$finished <- base::Sys.time()
[13:22:30.331]     ...future.result
[13:22:30.331] }
[13:22:30.335] MultisessionFuture started
[13:22:30.335] - Launch lazy future ... done
[13:22:30.335] run() for ‘MultisessionFuture’ ... done
[13:22:30.335] result() for ClusterFuture ...
[13:22:30.335] receiveMessageFromWorker() for ClusterFuture ...
[13:22:30.335] - Validating connection of MultisessionFuture
[13:22:30.386] - received message: FutureResult
[13:22:30.386] - Received FutureResult
[13:22:30.386] - Erased future from FutureRegistry
[13:22:30.386] result() for ClusterFuture ...
[13:22:30.386] - result already collected: FutureResult
[13:22:30.387] result() for ClusterFuture ... done
[13:22:30.387] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:30.387] result() for ClusterFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : chr " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 3"| __truncated__
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-01-07 13:22:30"
 $ finished    : POSIXct[1:1], format: "2025-01-07 13:22:30"
 $ session_uuid: chr "256798a4-5c30-7eef-db48-d08f6d787740"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "5853cd8d1af0"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "5853cd8d1af0" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 93526
  .. ..$ time  : POSIXct[1:1], format: "2025-01-07 13:22:30"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 3 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[13:22:30.397] result() for ClusterFuture ...
[13:22:30.397] - result already collected: FutureResult
[13:22:30.397] result() for ClusterFuture ... done
[13:22:30.397] result() for ClusterFuture ...
[13:22:30.397] - result already collected: FutureResult
[13:22:30.397] result() for ClusterFuture ... done
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
FutureResult:
value: ‘integer’
visible: TRUE
stdout: character
conditions: [n = 0] 
RNG used: FALSE
duration: 0.008710623 secs (started 2025-01-07 13:22:30.377282)
version: 1.8
[13:22:30.398] getGlobalsAndPackages() ...
[13:22:30.398] Searching for globals...
[13:22:30.402] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[13:22:30.402] Searching for globals ... DONE
[13:22:30.403] Resolving globals: FALSE
[13:22:30.403] 
[13:22:30.403] - packages: [1] ‘utils’
[13:22:30.403] getGlobalsAndPackages() ... DONE
[13:22:30.404] run() for ‘Future’ ...
[13:22:30.404] - state: ‘created’
[13:22:30.404] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:30.420] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:30.420] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:30.420]   - Field: ‘node’
[13:22:30.420]   - Field: ‘label’
[13:22:30.420]   - Field: ‘local’
[13:22:30.420]   - Field: ‘owner’
[13:22:30.420]   - Field: ‘envir’
[13:22:30.421]   - Field: ‘workers’
[13:22:30.421]   - Field: ‘packages’
[13:22:30.421]   - Field: ‘gc’
[13:22:30.421]   - Field: ‘conditions’
[13:22:30.421]   - Field: ‘persistent’
[13:22:30.421]   - Field: ‘expr’
[13:22:30.421]   - Field: ‘uuid’
[13:22:30.421]   - Field: ‘seed’
[13:22:30.421]   - Field: ‘version’
[13:22:30.422]   - Field: ‘result’
[13:22:30.422]   - Field: ‘asynchronous’
[13:22:30.422]   - Field: ‘calls’
[13:22:30.422]   - Field: ‘globals’
[13:22:30.422]   - Field: ‘stdout’
[13:22:30.422]   - Field: ‘earlySignal’
[13:22:30.422]   - Field: ‘lazy’
[13:22:30.422]   - Field: ‘state’
[13:22:30.422] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:30.423] - Launch lazy future ...
[13:22:30.423] Packages needed by the future expression (n = 1): ‘utils’
[13:22:30.423] Packages needed by future strategies (n = 0): <none>
[13:22:30.424] {
[13:22:30.424]     {
[13:22:30.424]         {
[13:22:30.424]             ...future.startTime <- base::Sys.time()
[13:22:30.424]             {
[13:22:30.424]                 {
[13:22:30.424]                   {
[13:22:30.424]                     {
[13:22:30.424]                       {
[13:22:30.424]                         base::local({
[13:22:30.424]                           has_future <- base::requireNamespace("future", 
[13:22:30.424]                             quietly = TRUE)
[13:22:30.424]                           if (has_future) {
[13:22:30.424]                             ns <- base::getNamespace("future")
[13:22:30.424]                             version <- ns[[".package"]][["version"]]
[13:22:30.424]                             if (is.null(version)) 
[13:22:30.424]                               version <- utils::packageVersion("future")
[13:22:30.424]                           }
[13:22:30.424]                           else {
[13:22:30.424]                             version <- NULL
[13:22:30.424]                           }
[13:22:30.424]                           if (!has_future || version < "1.8.0") {
[13:22:30.424]                             info <- base::c(r_version = base::gsub("R version ", 
[13:22:30.424]                               "", base::R.version$version.string), 
[13:22:30.424]                               platform = base::sprintf("%s (%s-bit)", 
[13:22:30.424]                                 base::R.version$platform, 8 * 
[13:22:30.424]                                   base::.Machine$sizeof.pointer), 
[13:22:30.424]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:30.424]                                 "release", "version")], collapse = " "), 
[13:22:30.424]                               hostname = base::Sys.info()[["nodename"]])
[13:22:30.424]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:22:30.424]                               info)
[13:22:30.424]                             info <- base::paste(info, collapse = "; ")
[13:22:30.424]                             if (!has_future) {
[13:22:30.424]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:30.424]                                 info)
[13:22:30.424]                             }
[13:22:30.424]                             else {
[13:22:30.424]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:30.424]                                 info, version)
[13:22:30.424]                             }
[13:22:30.424]                             base::stop(msg)
[13:22:30.424]                           }
[13:22:30.424]                         })
[13:22:30.424]                       }
[13:22:30.424]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:30.424]                       base::options(mc.cores = 1L)
[13:22:30.424]                     }
[13:22:30.424]                     base::local({
[13:22:30.424]                       for (pkg in "utils") {
[13:22:30.424]                         base::loadNamespace(pkg)
[13:22:30.424]                         base::library(pkg, character.only = TRUE)
[13:22:30.424]                       }
[13:22:30.424]                     })
[13:22:30.424]                   }
[13:22:30.424]                   options(future.plan = NULL)
[13:22:30.424]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:30.424]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:30.424]                 }
[13:22:30.424]                 ...future.workdir <- getwd()
[13:22:30.424]             }
[13:22:30.424]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:30.424]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:30.424]         }
[13:22:30.424]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:30.424]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:30.424]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:30.424]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:30.424]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:30.424]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:30.424]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:30.424]             base::names(...future.oldOptions))
[13:22:30.424]     }
[13:22:30.424]     if (FALSE) {
[13:22:30.424]     }
[13:22:30.424]     else {
[13:22:30.424]         if (TRUE) {
[13:22:30.424]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:30.424]                 open = "w")
[13:22:30.424]         }
[13:22:30.424]         else {
[13:22:30.424]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:30.424]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:30.424]         }
[13:22:30.424]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:30.424]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:30.424]             base::sink(type = "output", split = FALSE)
[13:22:30.424]             base::close(...future.stdout)
[13:22:30.424]         }, add = TRUE)
[13:22:30.424]     }
[13:22:30.424]     ...future.frame <- base::sys.nframe()
[13:22:30.424]     ...future.conditions <- base::list()
[13:22:30.424]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:30.424]     if (FALSE) {
[13:22:30.424]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:30.424]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:30.424]     }
[13:22:30.424]     ...future.result <- base::tryCatch({
[13:22:30.424]         base::withCallingHandlers({
[13:22:30.424]             ...future.value <- base::withVisible(base::local({
[13:22:30.424]                 ...future.makeSendCondition <- local({
[13:22:30.424]                   sendCondition <- NULL
[13:22:30.424]                   function(frame = 1L) {
[13:22:30.424]                     if (is.function(sendCondition)) 
[13:22:30.424]                       return(sendCondition)
[13:22:30.424]                     ns <- getNamespace("parallel")
[13:22:30.424]                     if (exists("sendData", mode = "function", 
[13:22:30.424]                       envir = ns)) {
[13:22:30.424]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:30.424]                         envir = ns)
[13:22:30.424]                       envir <- sys.frame(frame)
[13:22:30.424]                       master <- NULL
[13:22:30.424]                       while (!identical(envir, .GlobalEnv) && 
[13:22:30.424]                         !identical(envir, emptyenv())) {
[13:22:30.424]                         if (exists("master", mode = "list", envir = envir, 
[13:22:30.424]                           inherits = FALSE)) {
[13:22:30.424]                           master <- get("master", mode = "list", 
[13:22:30.424]                             envir = envir, inherits = FALSE)
[13:22:30.424]                           if (inherits(master, c("SOCKnode", 
[13:22:30.424]                             "SOCK0node"))) {
[13:22:30.424]                             sendCondition <<- function(cond) {
[13:22:30.424]                               data <- list(type = "VALUE", value = cond, 
[13:22:30.424]                                 success = TRUE)
[13:22:30.424]                               parallel_sendData(master, data)
[13:22:30.424]                             }
[13:22:30.424]                             return(sendCondition)
[13:22:30.424]                           }
[13:22:30.424]                         }
[13:22:30.424]                         frame <- frame + 1L
[13:22:30.424]                         envir <- sys.frame(frame)
[13:22:30.424]                       }
[13:22:30.424]                     }
[13:22:30.424]                     sendCondition <<- function(cond) NULL
[13:22:30.424]                   }
[13:22:30.424]                 })
[13:22:30.424]                 withCallingHandlers({
[13:22:30.424]                   {
[13:22:30.424]                     print(1:50)
[13:22:30.424]                     str(1:50)
[13:22:30.424]                     cat(letters, sep = "-")
[13:22:30.424]                     cat(1:6, collapse = "\n")
[13:22:30.424]                     write.table(datasets::iris[1:10, ], sep = "\t")
[13:22:30.424]                     42L
[13:22:30.424]                   }
[13:22:30.424]                 }, immediateCondition = function(cond) {
[13:22:30.424]                   sendCondition <- ...future.makeSendCondition()
[13:22:30.424]                   sendCondition(cond)
[13:22:30.424]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:30.424]                   {
[13:22:30.424]                     inherits <- base::inherits
[13:22:30.424]                     invokeRestart <- base::invokeRestart
[13:22:30.424]                     is.null <- base::is.null
[13:22:30.424]                     muffled <- FALSE
[13:22:30.424]                     if (inherits(cond, "message")) {
[13:22:30.424]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:30.424]                       if (muffled) 
[13:22:30.424]                         invokeRestart("muffleMessage")
[13:22:30.424]                     }
[13:22:30.424]                     else if (inherits(cond, "warning")) {
[13:22:30.424]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:30.424]                       if (muffled) 
[13:22:30.424]                         invokeRestart("muffleWarning")
[13:22:30.424]                     }
[13:22:30.424]                     else if (inherits(cond, "condition")) {
[13:22:30.424]                       if (!is.null(pattern)) {
[13:22:30.424]                         computeRestarts <- base::computeRestarts
[13:22:30.424]                         grepl <- base::grepl
[13:22:30.424]                         restarts <- computeRestarts(cond)
[13:22:30.424]                         for (restart in restarts) {
[13:22:30.424]                           name <- restart$name
[13:22:30.424]                           if (is.null(name)) 
[13:22:30.424]                             next
[13:22:30.424]                           if (!grepl(pattern, name)) 
[13:22:30.424]                             next
[13:22:30.424]                           invokeRestart(restart)
[13:22:30.424]                           muffled <- TRUE
[13:22:30.424]                           break
[13:22:30.424]                         }
[13:22:30.424]                       }
[13:22:30.424]                     }
[13:22:30.424]                     invisible(muffled)
[13:22:30.424]                   }
[13:22:30.424]                   muffleCondition(cond)
[13:22:30.424]                 })
[13:22:30.424]             }))
[13:22:30.424]             future::FutureResult(value = ...future.value$value, 
[13:22:30.424]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:30.424]                   ...future.rng), globalenv = if (FALSE) 
[13:22:30.424]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:30.424]                     ...future.globalenv.names))
[13:22:30.424]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:30.424]         }, condition = base::local({
[13:22:30.424]             c <- base::c
[13:22:30.424]             inherits <- base::inherits
[13:22:30.424]             invokeRestart <- base::invokeRestart
[13:22:30.424]             length <- base::length
[13:22:30.424]             list <- base::list
[13:22:30.424]             seq.int <- base::seq.int
[13:22:30.424]             signalCondition <- base::signalCondition
[13:22:30.424]             sys.calls <- base::sys.calls
[13:22:30.424]             `[[` <- base::`[[`
[13:22:30.424]             `+` <- base::`+`
[13:22:30.424]             `<<-` <- base::`<<-`
[13:22:30.424]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:30.424]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:30.424]                   3L)]
[13:22:30.424]             }
[13:22:30.424]             function(cond) {
[13:22:30.424]                 is_error <- inherits(cond, "error")
[13:22:30.424]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:30.424]                   NULL)
[13:22:30.424]                 if (is_error) {
[13:22:30.424]                   sessionInformation <- function() {
[13:22:30.424]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:30.424]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:30.424]                       search = base::search(), system = base::Sys.info())
[13:22:30.424]                   }
[13:22:30.424]                   ...future.conditions[[length(...future.conditions) + 
[13:22:30.424]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:30.424]                     cond$call), session = sessionInformation(), 
[13:22:30.424]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:30.424]                   signalCondition(cond)
[13:22:30.424]                 }
[13:22:30.424]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:30.424]                 "immediateCondition"))) {
[13:22:30.424]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:30.424]                   ...future.conditions[[length(...future.conditions) + 
[13:22:30.424]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:30.424]                   if (TRUE && !signal) {
[13:22:30.424]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:30.424]                     {
[13:22:30.424]                       inherits <- base::inherits
[13:22:30.424]                       invokeRestart <- base::invokeRestart
[13:22:30.424]                       is.null <- base::is.null
[13:22:30.424]                       muffled <- FALSE
[13:22:30.424]                       if (inherits(cond, "message")) {
[13:22:30.424]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:30.424]                         if (muffled) 
[13:22:30.424]                           invokeRestart("muffleMessage")
[13:22:30.424]                       }
[13:22:30.424]                       else if (inherits(cond, "warning")) {
[13:22:30.424]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:30.424]                         if (muffled) 
[13:22:30.424]                           invokeRestart("muffleWarning")
[13:22:30.424]                       }
[13:22:30.424]                       else if (inherits(cond, "condition")) {
[13:22:30.424]                         if (!is.null(pattern)) {
[13:22:30.424]                           computeRestarts <- base::computeRestarts
[13:22:30.424]                           grepl <- base::grepl
[13:22:30.424]                           restarts <- computeRestarts(cond)
[13:22:30.424]                           for (restart in restarts) {
[13:22:30.424]                             name <- restart$name
[13:22:30.424]                             if (is.null(name)) 
[13:22:30.424]                               next
[13:22:30.424]                             if (!grepl(pattern, name)) 
[13:22:30.424]                               next
[13:22:30.424]                             invokeRestart(restart)
[13:22:30.424]                             muffled <- TRUE
[13:22:30.424]                             break
[13:22:30.424]                           }
[13:22:30.424]                         }
[13:22:30.424]                       }
[13:22:30.424]                       invisible(muffled)
[13:22:30.424]                     }
[13:22:30.424]                     muffleCondition(cond, pattern = "^muffle")
[13:22:30.424]                   }
[13:22:30.424]                 }
[13:22:30.424]                 else {
[13:22:30.424]                   if (TRUE) {
[13:22:30.424]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:30.424]                     {
[13:22:30.424]                       inherits <- base::inherits
[13:22:30.424]                       invokeRestart <- base::invokeRestart
[13:22:30.424]                       is.null <- base::is.null
[13:22:30.424]                       muffled <- FALSE
[13:22:30.424]                       if (inherits(cond, "message")) {
[13:22:30.424]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:30.424]                         if (muffled) 
[13:22:30.424]                           invokeRestart("muffleMessage")
[13:22:30.424]                       }
[13:22:30.424]                       else if (inherits(cond, "warning")) {
[13:22:30.424]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:30.424]                         if (muffled) 
[13:22:30.424]                           invokeRestart("muffleWarning")
[13:22:30.424]                       }
[13:22:30.424]                       else if (inherits(cond, "condition")) {
[13:22:30.424]                         if (!is.null(pattern)) {
[13:22:30.424]                           computeRestarts <- base::computeRestarts
[13:22:30.424]                           grepl <- base::grepl
[13:22:30.424]                           restarts <- computeRestarts(cond)
[13:22:30.424]                           for (restart in restarts) {
[13:22:30.424]                             name <- restart$name
[13:22:30.424]                             if (is.null(name)) 
[13:22:30.424]                               next
[13:22:30.424]                             if (!grepl(pattern, name)) 
[13:22:30.424]                               next
[13:22:30.424]                             invokeRestart(restart)
[13:22:30.424]                             muffled <- TRUE
[13:22:30.424]                             break
[13:22:30.424]                           }
[13:22:30.424]                         }
[13:22:30.424]                       }
[13:22:30.424]                       invisible(muffled)
[13:22:30.424]                     }
[13:22:30.424]                     muffleCondition(cond, pattern = "^muffle")
[13:22:30.424]                   }
[13:22:30.424]                 }
[13:22:30.424]             }
[13:22:30.424]         }))
[13:22:30.424]     }, error = function(ex) {
[13:22:30.424]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:30.424]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:30.424]                 ...future.rng), started = ...future.startTime, 
[13:22:30.424]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:30.424]             version = "1.8"), class = "FutureResult")
[13:22:30.424]     }, finally = {
[13:22:30.424]         if (!identical(...future.workdir, getwd())) 
[13:22:30.424]             setwd(...future.workdir)
[13:22:30.424]         {
[13:22:30.424]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:30.424]                 ...future.oldOptions$nwarnings <- NULL
[13:22:30.424]             }
[13:22:30.424]             base::options(...future.oldOptions)
[13:22:30.424]             if (.Platform$OS.type == "windows") {
[13:22:30.424]                 old_names <- names(...future.oldEnvVars)
[13:22:30.424]                 envs <- base::Sys.getenv()
[13:22:30.424]                 names <- names(envs)
[13:22:30.424]                 common <- intersect(names, old_names)
[13:22:30.424]                 added <- setdiff(names, old_names)
[13:22:30.424]                 removed <- setdiff(old_names, names)
[13:22:30.424]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:30.424]                   envs[common]]
[13:22:30.424]                 NAMES <- toupper(changed)
[13:22:30.424]                 args <- list()
[13:22:30.424]                 for (kk in seq_along(NAMES)) {
[13:22:30.424]                   name <- changed[[kk]]
[13:22:30.424]                   NAME <- NAMES[[kk]]
[13:22:30.424]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:30.424]                     next
[13:22:30.424]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:30.424]                 }
[13:22:30.424]                 NAMES <- toupper(added)
[13:22:30.424]                 for (kk in seq_along(NAMES)) {
[13:22:30.424]                   name <- added[[kk]]
[13:22:30.424]                   NAME <- NAMES[[kk]]
[13:22:30.424]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:30.424]                     next
[13:22:30.424]                   args[[name]] <- ""
[13:22:30.424]                 }
[13:22:30.424]                 NAMES <- toupper(removed)
[13:22:30.424]                 for (kk in seq_along(NAMES)) {
[13:22:30.424]                   name <- removed[[kk]]
[13:22:30.424]                   NAME <- NAMES[[kk]]
[13:22:30.424]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:30.424]                     next
[13:22:30.424]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:30.424]                 }
[13:22:30.424]                 if (length(args) > 0) 
[13:22:30.424]                   base::do.call(base::Sys.setenv, args = args)
[13:22:30.424]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:30.424]             }
[13:22:30.424]             else {
[13:22:30.424]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:30.424]             }
[13:22:30.424]             {
[13:22:30.424]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:30.424]                   0L) {
[13:22:30.424]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:30.424]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:30.424]                   base::options(opts)
[13:22:30.424]                 }
[13:22:30.424]                 {
[13:22:30.424]                   {
[13:22:30.424]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:30.424]                     NULL
[13:22:30.424]                   }
[13:22:30.424]                   options(future.plan = NULL)
[13:22:30.424]                   if (is.na(NA_character_)) 
[13:22:30.424]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:30.424]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:30.424]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:30.424]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:30.424]                     envir = parent.frame()) 
[13:22:30.424]                   {
[13:22:30.424]                     if (is.function(workers)) 
[13:22:30.424]                       workers <- workers()
[13:22:30.424]                     workers <- structure(as.integer(workers), 
[13:22:30.424]                       class = class(workers))
[13:22:30.424]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:30.424]                       workers >= 1)
[13:22:30.424]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:30.424]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:30.424]                     }
[13:22:30.424]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:30.424]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:30.424]                       envir = envir)
[13:22:30.424]                     if (!future$lazy) 
[13:22:30.424]                       future <- run(future)
[13:22:30.424]                     invisible(future)
[13:22:30.424]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:30.424]                 }
[13:22:30.424]             }
[13:22:30.424]         }
[13:22:30.424]     })
[13:22:30.424]     if (TRUE) {
[13:22:30.424]         base::sink(type = "output", split = FALSE)
[13:22:30.424]         if (TRUE) {
[13:22:30.424]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:30.424]         }
[13:22:30.424]         else {
[13:22:30.424]             ...future.result["stdout"] <- base::list(NULL)
[13:22:30.424]         }
[13:22:30.424]         base::close(...future.stdout)
[13:22:30.424]         ...future.stdout <- NULL
[13:22:30.424]     }
[13:22:30.424]     ...future.result$conditions <- ...future.conditions
[13:22:30.424]     ...future.result$finished <- base::Sys.time()
[13:22:30.424]     ...future.result
[13:22:30.424] }
[13:22:30.428] MultisessionFuture started
[13:22:30.428] - Launch lazy future ... done
[13:22:30.428] run() for ‘MultisessionFuture’ ... done
[13:22:30.428] result() for ClusterFuture ...
[13:22:30.428] receiveMessageFromWorker() for ClusterFuture ...
[13:22:30.429] - Validating connection of MultisessionFuture
[13:22:30.475] - received message: FutureResult
[13:22:30.475] - Received FutureResult
[13:22:30.475] - Erased future from FutureRegistry
[13:22:30.475] result() for ClusterFuture ...
[13:22:30.475] - result already collected: FutureResult
[13:22:30.475] result() for ClusterFuture ... done
[13:22:30.476] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:30.476] result() for ClusterFuture ... done
[13:22:30.476] result() for ClusterFuture ...
[13:22:30.476] - result already collected: FutureResult
[13:22:30.476] result() for ClusterFuture ... done
 [1] " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25"  
 [2] "[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50"  
 [3] " int [1:50] 1 2 3 4 5 6 7 8 9 10 ..."                                             
 [4] "a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 "                  
 [5] "\"Sepal.Length\"\t\"Sepal.Width\"\t\"Petal.Length\"\t\"Petal.Width\"\t\"Species\""
 [6] "\"1\"\t5.1\t3.5\t1.4\t0.2\t\"setosa\""                                            
 [7] "\"2\"\t4.9\t3\t1.4\t0.2\t\"setosa\""                                              
 [8] "\"3\"\t4.7\t3.2\t1.3\t0.2\t\"setosa\""                                            
 [9] "\"4\"\t4.6\t3.1\t1.5\t0.2\t\"setosa\""                                            
[10] "\"5\"\t5\t3.6\t1.4\t0.2\t\"setosa\""                                              
[11] "\"6\"\t5.4\t3.9\t1.7\t0.4\t\"setosa\""                                            
[12] "\"7\"\t4.6\t3.4\t1.4\t0.3\t\"setosa\""                                            
[13] "\"8\"\t5\t3.4\t1.5\t0.2\t\"setosa\""                                              
[14] "\"9\"\t4.4\t2.9\t1.4\t0.2\t\"setosa\""                                            
[15] "\"10\"\t4.9\t3.1\t1.5\t0.1\t\"setosa\""                                           
- stdout = structure(TRUE, drop = TRUE)
[13:22:30.476] getGlobalsAndPackages() ...
[13:22:30.477] Searching for globals...
[13:22:30.477] - globals found: [1] ‘print’
[13:22:30.477] Searching for globals ... DONE
[13:22:30.477] Resolving globals: FALSE
[13:22:30.478] 
[13:22:30.478] 
[13:22:30.478] getGlobalsAndPackages() ... DONE
[13:22:30.478] run() for ‘Future’ ...
[13:22:30.478] - state: ‘created’
[13:22:30.478] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:30.493] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:30.493] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:30.493]   - Field: ‘node’
[13:22:30.493]   - Field: ‘label’
[13:22:30.493]   - Field: ‘local’
[13:22:30.493]   - Field: ‘owner’
[13:22:30.494]   - Field: ‘envir’
[13:22:30.494]   - Field: ‘workers’
[13:22:30.494]   - Field: ‘packages’
[13:22:30.494]   - Field: ‘gc’
[13:22:30.494]   - Field: ‘conditions’
[13:22:30.494]   - Field: ‘persistent’
[13:22:30.494]   - Field: ‘expr’
[13:22:30.494]   - Field: ‘uuid’
[13:22:30.494]   - Field: ‘seed’
[13:22:30.494]   - Field: ‘version’
[13:22:30.494]   - Field: ‘result’
[13:22:30.495]   - Field: ‘asynchronous’
[13:22:30.495]   - Field: ‘calls’
[13:22:30.495]   - Field: ‘globals’
[13:22:30.495]   - Field: ‘stdout’
[13:22:30.495]   - Field: ‘earlySignal’
[13:22:30.495]   - Field: ‘lazy’
[13:22:30.495]   - Field: ‘state’
[13:22:30.495] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:30.495] - Launch lazy future ...
[13:22:30.496] Packages needed by the future expression (n = 0): <none>
[13:22:30.496] Packages needed by future strategies (n = 0): <none>
[13:22:30.496] {
[13:22:30.496]     {
[13:22:30.496]         {
[13:22:30.496]             ...future.startTime <- base::Sys.time()
[13:22:30.496]             {
[13:22:30.496]                 {
[13:22:30.496]                   {
[13:22:30.496]                     {
[13:22:30.496]                       base::local({
[13:22:30.496]                         has_future <- base::requireNamespace("future", 
[13:22:30.496]                           quietly = TRUE)
[13:22:30.496]                         if (has_future) {
[13:22:30.496]                           ns <- base::getNamespace("future")
[13:22:30.496]                           version <- ns[[".package"]][["version"]]
[13:22:30.496]                           if (is.null(version)) 
[13:22:30.496]                             version <- utils::packageVersion("future")
[13:22:30.496]                         }
[13:22:30.496]                         else {
[13:22:30.496]                           version <- NULL
[13:22:30.496]                         }
[13:22:30.496]                         if (!has_future || version < "1.8.0") {
[13:22:30.496]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:30.496]                             "", base::R.version$version.string), 
[13:22:30.496]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:30.496]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:30.496]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:30.496]                               "release", "version")], collapse = " "), 
[13:22:30.496]                             hostname = base::Sys.info()[["nodename"]])
[13:22:30.496]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:30.496]                             info)
[13:22:30.496]                           info <- base::paste(info, collapse = "; ")
[13:22:30.496]                           if (!has_future) {
[13:22:30.496]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:30.496]                               info)
[13:22:30.496]                           }
[13:22:30.496]                           else {
[13:22:30.496]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:30.496]                               info, version)
[13:22:30.496]                           }
[13:22:30.496]                           base::stop(msg)
[13:22:30.496]                         }
[13:22:30.496]                       })
[13:22:30.496]                     }
[13:22:30.496]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:30.496]                     base::options(mc.cores = 1L)
[13:22:30.496]                   }
[13:22:30.496]                   options(future.plan = NULL)
[13:22:30.496]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:30.496]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:30.496]                 }
[13:22:30.496]                 ...future.workdir <- getwd()
[13:22:30.496]             }
[13:22:30.496]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:30.496]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:30.496]         }
[13:22:30.496]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:30.496]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:30.496]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:30.496]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:30.496]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:30.496]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:30.496]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:30.496]             base::names(...future.oldOptions))
[13:22:30.496]     }
[13:22:30.496]     if (FALSE) {
[13:22:30.496]     }
[13:22:30.496]     else {
[13:22:30.496]         if (TRUE) {
[13:22:30.496]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:30.496]                 open = "w")
[13:22:30.496]         }
[13:22:30.496]         else {
[13:22:30.496]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:30.496]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:30.496]         }
[13:22:30.496]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:30.496]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:30.496]             base::sink(type = "output", split = FALSE)
[13:22:30.496]             base::close(...future.stdout)
[13:22:30.496]         }, add = TRUE)
[13:22:30.496]     }
[13:22:30.496]     ...future.frame <- base::sys.nframe()
[13:22:30.496]     ...future.conditions <- base::list()
[13:22:30.496]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:30.496]     if (FALSE) {
[13:22:30.496]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:30.496]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:30.496]     }
[13:22:30.496]     ...future.result <- base::tryCatch({
[13:22:30.496]         base::withCallingHandlers({
[13:22:30.496]             ...future.value <- base::withVisible(base::local({
[13:22:30.496]                 ...future.makeSendCondition <- local({
[13:22:30.496]                   sendCondition <- NULL
[13:22:30.496]                   function(frame = 1L) {
[13:22:30.496]                     if (is.function(sendCondition)) 
[13:22:30.496]                       return(sendCondition)
[13:22:30.496]                     ns <- getNamespace("parallel")
[13:22:30.496]                     if (exists("sendData", mode = "function", 
[13:22:30.496]                       envir = ns)) {
[13:22:30.496]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:30.496]                         envir = ns)
[13:22:30.496]                       envir <- sys.frame(frame)
[13:22:30.496]                       master <- NULL
[13:22:30.496]                       while (!identical(envir, .GlobalEnv) && 
[13:22:30.496]                         !identical(envir, emptyenv())) {
[13:22:30.496]                         if (exists("master", mode = "list", envir = envir, 
[13:22:30.496]                           inherits = FALSE)) {
[13:22:30.496]                           master <- get("master", mode = "list", 
[13:22:30.496]                             envir = envir, inherits = FALSE)
[13:22:30.496]                           if (inherits(master, c("SOCKnode", 
[13:22:30.496]                             "SOCK0node"))) {
[13:22:30.496]                             sendCondition <<- function(cond) {
[13:22:30.496]                               data <- list(type = "VALUE", value = cond, 
[13:22:30.496]                                 success = TRUE)
[13:22:30.496]                               parallel_sendData(master, data)
[13:22:30.496]                             }
[13:22:30.496]                             return(sendCondition)
[13:22:30.496]                           }
[13:22:30.496]                         }
[13:22:30.496]                         frame <- frame + 1L
[13:22:30.496]                         envir <- sys.frame(frame)
[13:22:30.496]                       }
[13:22:30.496]                     }
[13:22:30.496]                     sendCondition <<- function(cond) NULL
[13:22:30.496]                   }
[13:22:30.496]                 })
[13:22:30.496]                 withCallingHandlers({
[13:22:30.496]                   print(42)
[13:22:30.496]                 }, immediateCondition = function(cond) {
[13:22:30.496]                   sendCondition <- ...future.makeSendCondition()
[13:22:30.496]                   sendCondition(cond)
[13:22:30.496]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:30.496]                   {
[13:22:30.496]                     inherits <- base::inherits
[13:22:30.496]                     invokeRestart <- base::invokeRestart
[13:22:30.496]                     is.null <- base::is.null
[13:22:30.496]                     muffled <- FALSE
[13:22:30.496]                     if (inherits(cond, "message")) {
[13:22:30.496]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:30.496]                       if (muffled) 
[13:22:30.496]                         invokeRestart("muffleMessage")
[13:22:30.496]                     }
[13:22:30.496]                     else if (inherits(cond, "warning")) {
[13:22:30.496]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:30.496]                       if (muffled) 
[13:22:30.496]                         invokeRestart("muffleWarning")
[13:22:30.496]                     }
[13:22:30.496]                     else if (inherits(cond, "condition")) {
[13:22:30.496]                       if (!is.null(pattern)) {
[13:22:30.496]                         computeRestarts <- base::computeRestarts
[13:22:30.496]                         grepl <- base::grepl
[13:22:30.496]                         restarts <- computeRestarts(cond)
[13:22:30.496]                         for (restart in restarts) {
[13:22:30.496]                           name <- restart$name
[13:22:30.496]                           if (is.null(name)) 
[13:22:30.496]                             next
[13:22:30.496]                           if (!grepl(pattern, name)) 
[13:22:30.496]                             next
[13:22:30.496]                           invokeRestart(restart)
[13:22:30.496]                           muffled <- TRUE
[13:22:30.496]                           break
[13:22:30.496]                         }
[13:22:30.496]                       }
[13:22:30.496]                     }
[13:22:30.496]                     invisible(muffled)
[13:22:30.496]                   }
[13:22:30.496]                   muffleCondition(cond)
[13:22:30.496]                 })
[13:22:30.496]             }))
[13:22:30.496]             future::FutureResult(value = ...future.value$value, 
[13:22:30.496]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:30.496]                   ...future.rng), globalenv = if (FALSE) 
[13:22:30.496]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:30.496]                     ...future.globalenv.names))
[13:22:30.496]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:30.496]         }, condition = base::local({
[13:22:30.496]             c <- base::c
[13:22:30.496]             inherits <- base::inherits
[13:22:30.496]             invokeRestart <- base::invokeRestart
[13:22:30.496]             length <- base::length
[13:22:30.496]             list <- base::list
[13:22:30.496]             seq.int <- base::seq.int
[13:22:30.496]             signalCondition <- base::signalCondition
[13:22:30.496]             sys.calls <- base::sys.calls
[13:22:30.496]             `[[` <- base::`[[`
[13:22:30.496]             `+` <- base::`+`
[13:22:30.496]             `<<-` <- base::`<<-`
[13:22:30.496]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:30.496]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:30.496]                   3L)]
[13:22:30.496]             }
[13:22:30.496]             function(cond) {
[13:22:30.496]                 is_error <- inherits(cond, "error")
[13:22:30.496]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:30.496]                   NULL)
[13:22:30.496]                 if (is_error) {
[13:22:30.496]                   sessionInformation <- function() {
[13:22:30.496]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:30.496]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:30.496]                       search = base::search(), system = base::Sys.info())
[13:22:30.496]                   }
[13:22:30.496]                   ...future.conditions[[length(...future.conditions) + 
[13:22:30.496]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:30.496]                     cond$call), session = sessionInformation(), 
[13:22:30.496]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:30.496]                   signalCondition(cond)
[13:22:30.496]                 }
[13:22:30.496]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:30.496]                 "immediateCondition"))) {
[13:22:30.496]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:30.496]                   ...future.conditions[[length(...future.conditions) + 
[13:22:30.496]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:30.496]                   if (TRUE && !signal) {
[13:22:30.496]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:30.496]                     {
[13:22:30.496]                       inherits <- base::inherits
[13:22:30.496]                       invokeRestart <- base::invokeRestart
[13:22:30.496]                       is.null <- base::is.null
[13:22:30.496]                       muffled <- FALSE
[13:22:30.496]                       if (inherits(cond, "message")) {
[13:22:30.496]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:30.496]                         if (muffled) 
[13:22:30.496]                           invokeRestart("muffleMessage")
[13:22:30.496]                       }
[13:22:30.496]                       else if (inherits(cond, "warning")) {
[13:22:30.496]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:30.496]                         if (muffled) 
[13:22:30.496]                           invokeRestart("muffleWarning")
[13:22:30.496]                       }
[13:22:30.496]                       else if (inherits(cond, "condition")) {
[13:22:30.496]                         if (!is.null(pattern)) {
[13:22:30.496]                           computeRestarts <- base::computeRestarts
[13:22:30.496]                           grepl <- base::grepl
[13:22:30.496]                           restarts <- computeRestarts(cond)
[13:22:30.496]                           for (restart in restarts) {
[13:22:30.496]                             name <- restart$name
[13:22:30.496]                             if (is.null(name)) 
[13:22:30.496]                               next
[13:22:30.496]                             if (!grepl(pattern, name)) 
[13:22:30.496]                               next
[13:22:30.496]                             invokeRestart(restart)
[13:22:30.496]                             muffled <- TRUE
[13:22:30.496]                             break
[13:22:30.496]                           }
[13:22:30.496]                         }
[13:22:30.496]                       }
[13:22:30.496]                       invisible(muffled)
[13:22:30.496]                     }
[13:22:30.496]                     muffleCondition(cond, pattern = "^muffle")
[13:22:30.496]                   }
[13:22:30.496]                 }
[13:22:30.496]                 else {
[13:22:30.496]                   if (TRUE) {
[13:22:30.496]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:30.496]                     {
[13:22:30.496]                       inherits <- base::inherits
[13:22:30.496]                       invokeRestart <- base::invokeRestart
[13:22:30.496]                       is.null <- base::is.null
[13:22:30.496]                       muffled <- FALSE
[13:22:30.496]                       if (inherits(cond, "message")) {
[13:22:30.496]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:30.496]                         if (muffled) 
[13:22:30.496]                           invokeRestart("muffleMessage")
[13:22:30.496]                       }
[13:22:30.496]                       else if (inherits(cond, "warning")) {
[13:22:30.496]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:30.496]                         if (muffled) 
[13:22:30.496]                           invokeRestart("muffleWarning")
[13:22:30.496]                       }
[13:22:30.496]                       else if (inherits(cond, "condition")) {
[13:22:30.496]                         if (!is.null(pattern)) {
[13:22:30.496]                           computeRestarts <- base::computeRestarts
[13:22:30.496]                           grepl <- base::grepl
[13:22:30.496]                           restarts <- computeRestarts(cond)
[13:22:30.496]                           for (restart in restarts) {
[13:22:30.496]                             name <- restart$name
[13:22:30.496]                             if (is.null(name)) 
[13:22:30.496]                               next
[13:22:30.496]                             if (!grepl(pattern, name)) 
[13:22:30.496]                               next
[13:22:30.496]                             invokeRestart(restart)
[13:22:30.496]                             muffled <- TRUE
[13:22:30.496]                             break
[13:22:30.496]                           }
[13:22:30.496]                         }
[13:22:30.496]                       }
[13:22:30.496]                       invisible(muffled)
[13:22:30.496]                     }
[13:22:30.496]                     muffleCondition(cond, pattern = "^muffle")
[13:22:30.496]                   }
[13:22:30.496]                 }
[13:22:30.496]             }
[13:22:30.496]         }))
[13:22:30.496]     }, error = function(ex) {
[13:22:30.496]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:30.496]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:30.496]                 ...future.rng), started = ...future.startTime, 
[13:22:30.496]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:30.496]             version = "1.8"), class = "FutureResult")
[13:22:30.496]     }, finally = {
[13:22:30.496]         if (!identical(...future.workdir, getwd())) 
[13:22:30.496]             setwd(...future.workdir)
[13:22:30.496]         {
[13:22:30.496]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:30.496]                 ...future.oldOptions$nwarnings <- NULL
[13:22:30.496]             }
[13:22:30.496]             base::options(...future.oldOptions)
[13:22:30.496]             if (.Platform$OS.type == "windows") {
[13:22:30.496]                 old_names <- names(...future.oldEnvVars)
[13:22:30.496]                 envs <- base::Sys.getenv()
[13:22:30.496]                 names <- names(envs)
[13:22:30.496]                 common <- intersect(names, old_names)
[13:22:30.496]                 added <- setdiff(names, old_names)
[13:22:30.496]                 removed <- setdiff(old_names, names)
[13:22:30.496]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:30.496]                   envs[common]]
[13:22:30.496]                 NAMES <- toupper(changed)
[13:22:30.496]                 args <- list()
[13:22:30.496]                 for (kk in seq_along(NAMES)) {
[13:22:30.496]                   name <- changed[[kk]]
[13:22:30.496]                   NAME <- NAMES[[kk]]
[13:22:30.496]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:30.496]                     next
[13:22:30.496]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:30.496]                 }
[13:22:30.496]                 NAMES <- toupper(added)
[13:22:30.496]                 for (kk in seq_along(NAMES)) {
[13:22:30.496]                   name <- added[[kk]]
[13:22:30.496]                   NAME <- NAMES[[kk]]
[13:22:30.496]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:30.496]                     next
[13:22:30.496]                   args[[name]] <- ""
[13:22:30.496]                 }
[13:22:30.496]                 NAMES <- toupper(removed)
[13:22:30.496]                 for (kk in seq_along(NAMES)) {
[13:22:30.496]                   name <- removed[[kk]]
[13:22:30.496]                   NAME <- NAMES[[kk]]
[13:22:30.496]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:30.496]                     next
[13:22:30.496]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:30.496]                 }
[13:22:30.496]                 if (length(args) > 0) 
[13:22:30.496]                   base::do.call(base::Sys.setenv, args = args)
[13:22:30.496]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:30.496]             }
[13:22:30.496]             else {
[13:22:30.496]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:30.496]             }
[13:22:30.496]             {
[13:22:30.496]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:30.496]                   0L) {
[13:22:30.496]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:30.496]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:30.496]                   base::options(opts)
[13:22:30.496]                 }
[13:22:30.496]                 {
[13:22:30.496]                   {
[13:22:30.496]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:30.496]                     NULL
[13:22:30.496]                   }
[13:22:30.496]                   options(future.plan = NULL)
[13:22:30.496]                   if (is.na(NA_character_)) 
[13:22:30.496]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:30.496]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:30.496]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:30.496]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:30.496]                     envir = parent.frame()) 
[13:22:30.496]                   {
[13:22:30.496]                     if (is.function(workers)) 
[13:22:30.496]                       workers <- workers()
[13:22:30.496]                     workers <- structure(as.integer(workers), 
[13:22:30.496]                       class = class(workers))
[13:22:30.496]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:30.496]                       workers >= 1)
[13:22:30.496]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:30.496]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:30.496]                     }
[13:22:30.496]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:30.496]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:30.496]                       envir = envir)
[13:22:30.496]                     if (!future$lazy) 
[13:22:30.496]                       future <- run(future)
[13:22:30.496]                     invisible(future)
[13:22:30.496]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:30.496]                 }
[13:22:30.496]             }
[13:22:30.496]         }
[13:22:30.496]     })
[13:22:30.496]     if (TRUE) {
[13:22:30.496]         base::sink(type = "output", split = FALSE)
[13:22:30.496]         if (TRUE) {
[13:22:30.496]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:30.496]         }
[13:22:30.496]         else {
[13:22:30.496]             ...future.result["stdout"] <- base::list(NULL)
[13:22:30.496]         }
[13:22:30.496]         base::close(...future.stdout)
[13:22:30.496]         ...future.stdout <- NULL
[13:22:30.496]     }
[13:22:30.496]     ...future.result$conditions <- ...future.conditions
[13:22:30.496]     ...future.result$finished <- base::Sys.time()
[13:22:30.496]     ...future.result
[13:22:30.496] }
[13:22:30.499] MultisessionFuture started
[13:22:30.500] - Launch lazy future ... done
[13:22:30.500] run() for ‘MultisessionFuture’ ... done
[13:22:30.500] result() for ClusterFuture ...
[13:22:30.500] receiveMessageFromWorker() for ClusterFuture ...
[13:22:30.500] - Validating connection of MultisessionFuture
[13:22:30.546] - received message: FutureResult
[13:22:30.546] - Received FutureResult
[13:22:30.546] - Erased future from FutureRegistry
[13:22:30.546] result() for ClusterFuture ...
[13:22:30.546] - result already collected: FutureResult
[13:22:30.547] result() for ClusterFuture ... done
[13:22:30.547] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:30.547] result() for ClusterFuture ... done
[13:22:30.547] result() for ClusterFuture ...
[13:22:30.547] - result already collected: FutureResult
[13:22:30.547] result() for ClusterFuture ... done
[13:22:30.547] result() for ClusterFuture ...
[13:22:30.547] - result already collected: FutureResult
[13:22:30.547] result() for ClusterFuture ... done
[1] 42
[13:22:30.547] result() for ClusterFuture ...
[13:22:30.548] - result already collected: FutureResult
[13:22:30.548] result() for ClusterFuture ... done
- stdout = FALSE
[13:22:30.548] getGlobalsAndPackages() ...
[13:22:30.548] Searching for globals...
[13:22:30.551] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[13:22:30.551] Searching for globals ... DONE
[13:22:30.551] Resolving globals: FALSE
[13:22:30.552] 
[13:22:30.552] - packages: [1] ‘utils’
[13:22:30.552] getGlobalsAndPackages() ... DONE
[13:22:30.552] run() for ‘Future’ ...
[13:22:30.552] - state: ‘created’
[13:22:30.552] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:30.567] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:30.567] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:30.567]   - Field: ‘node’
[13:22:30.567]   - Field: ‘label’
[13:22:30.568]   - Field: ‘local’
[13:22:30.568]   - Field: ‘owner’
[13:22:30.568]   - Field: ‘envir’
[13:22:30.568]   - Field: ‘workers’
[13:22:30.568]   - Field: ‘packages’
[13:22:30.568]   - Field: ‘gc’
[13:22:30.568]   - Field: ‘conditions’
[13:22:30.568]   - Field: ‘persistent’
[13:22:30.568]   - Field: ‘expr’
[13:22:30.568]   - Field: ‘uuid’
[13:22:30.568]   - Field: ‘seed’
[13:22:30.569]   - Field: ‘version’
[13:22:30.569]   - Field: ‘result’
[13:22:30.569]   - Field: ‘asynchronous’
[13:22:30.569]   - Field: ‘calls’
[13:22:30.569]   - Field: ‘globals’
[13:22:30.569]   - Field: ‘stdout’
[13:22:30.569]   - Field: ‘earlySignal’
[13:22:30.569]   - Field: ‘lazy’
[13:22:30.569]   - Field: ‘state’
[13:22:30.569] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:30.569] - Launch lazy future ...
[13:22:30.570] Packages needed by the future expression (n = 1): ‘utils’
[13:22:30.570] Packages needed by future strategies (n = 0): <none>
[13:22:30.570] {
[13:22:30.570]     {
[13:22:30.570]         {
[13:22:30.570]             ...future.startTime <- base::Sys.time()
[13:22:30.570]             {
[13:22:30.570]                 {
[13:22:30.570]                   {
[13:22:30.570]                     {
[13:22:30.570]                       {
[13:22:30.570]                         base::local({
[13:22:30.570]                           has_future <- base::requireNamespace("future", 
[13:22:30.570]                             quietly = TRUE)
[13:22:30.570]                           if (has_future) {
[13:22:30.570]                             ns <- base::getNamespace("future")
[13:22:30.570]                             version <- ns[[".package"]][["version"]]
[13:22:30.570]                             if (is.null(version)) 
[13:22:30.570]                               version <- utils::packageVersion("future")
[13:22:30.570]                           }
[13:22:30.570]                           else {
[13:22:30.570]                             version <- NULL
[13:22:30.570]                           }
[13:22:30.570]                           if (!has_future || version < "1.8.0") {
[13:22:30.570]                             info <- base::c(r_version = base::gsub("R version ", 
[13:22:30.570]                               "", base::R.version$version.string), 
[13:22:30.570]                               platform = base::sprintf("%s (%s-bit)", 
[13:22:30.570]                                 base::R.version$platform, 8 * 
[13:22:30.570]                                   base::.Machine$sizeof.pointer), 
[13:22:30.570]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:30.570]                                 "release", "version")], collapse = " "), 
[13:22:30.570]                               hostname = base::Sys.info()[["nodename"]])
[13:22:30.570]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:22:30.570]                               info)
[13:22:30.570]                             info <- base::paste(info, collapse = "; ")
[13:22:30.570]                             if (!has_future) {
[13:22:30.570]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:30.570]                                 info)
[13:22:30.570]                             }
[13:22:30.570]                             else {
[13:22:30.570]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:30.570]                                 info, version)
[13:22:30.570]                             }
[13:22:30.570]                             base::stop(msg)
[13:22:30.570]                           }
[13:22:30.570]                         })
[13:22:30.570]                       }
[13:22:30.570]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:30.570]                       base::options(mc.cores = 1L)
[13:22:30.570]                     }
[13:22:30.570]                     base::local({
[13:22:30.570]                       for (pkg in "utils") {
[13:22:30.570]                         base::loadNamespace(pkg)
[13:22:30.570]                         base::library(pkg, character.only = TRUE)
[13:22:30.570]                       }
[13:22:30.570]                     })
[13:22:30.570]                   }
[13:22:30.570]                   options(future.plan = NULL)
[13:22:30.570]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:30.570]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:30.570]                 }
[13:22:30.570]                 ...future.workdir <- getwd()
[13:22:30.570]             }
[13:22:30.570]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:30.570]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:30.570]         }
[13:22:30.570]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:30.570]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:30.570]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:30.570]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:30.570]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:30.570]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:30.570]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:30.570]             base::names(...future.oldOptions))
[13:22:30.570]     }
[13:22:30.570]     if (FALSE) {
[13:22:30.570]     }
[13:22:30.570]     else {
[13:22:30.570]         if (FALSE) {
[13:22:30.570]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:30.570]                 open = "w")
[13:22:30.570]         }
[13:22:30.570]         else {
[13:22:30.570]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:30.570]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:30.570]         }
[13:22:30.570]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:30.570]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:30.570]             base::sink(type = "output", split = FALSE)
[13:22:30.570]             base::close(...future.stdout)
[13:22:30.570]         }, add = TRUE)
[13:22:30.570]     }
[13:22:30.570]     ...future.frame <- base::sys.nframe()
[13:22:30.570]     ...future.conditions <- base::list()
[13:22:30.570]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:30.570]     if (FALSE) {
[13:22:30.570]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:30.570]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:30.570]     }
[13:22:30.570]     ...future.result <- base::tryCatch({
[13:22:30.570]         base::withCallingHandlers({
[13:22:30.570]             ...future.value <- base::withVisible(base::local({
[13:22:30.570]                 ...future.makeSendCondition <- local({
[13:22:30.570]                   sendCondition <- NULL
[13:22:30.570]                   function(frame = 1L) {
[13:22:30.570]                     if (is.function(sendCondition)) 
[13:22:30.570]                       return(sendCondition)
[13:22:30.570]                     ns <- getNamespace("parallel")
[13:22:30.570]                     if (exists("sendData", mode = "function", 
[13:22:30.570]                       envir = ns)) {
[13:22:30.570]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:30.570]                         envir = ns)
[13:22:30.570]                       envir <- sys.frame(frame)
[13:22:30.570]                       master <- NULL
[13:22:30.570]                       while (!identical(envir, .GlobalEnv) && 
[13:22:30.570]                         !identical(envir, emptyenv())) {
[13:22:30.570]                         if (exists("master", mode = "list", envir = envir, 
[13:22:30.570]                           inherits = FALSE)) {
[13:22:30.570]                           master <- get("master", mode = "list", 
[13:22:30.570]                             envir = envir, inherits = FALSE)
[13:22:30.570]                           if (inherits(master, c("SOCKnode", 
[13:22:30.570]                             "SOCK0node"))) {
[13:22:30.570]                             sendCondition <<- function(cond) {
[13:22:30.570]                               data <- list(type = "VALUE", value = cond, 
[13:22:30.570]                                 success = TRUE)
[13:22:30.570]                               parallel_sendData(master, data)
[13:22:30.570]                             }
[13:22:30.570]                             return(sendCondition)
[13:22:30.570]                           }
[13:22:30.570]                         }
[13:22:30.570]                         frame <- frame + 1L
[13:22:30.570]                         envir <- sys.frame(frame)
[13:22:30.570]                       }
[13:22:30.570]                     }
[13:22:30.570]                     sendCondition <<- function(cond) NULL
[13:22:30.570]                   }
[13:22:30.570]                 })
[13:22:30.570]                 withCallingHandlers({
[13:22:30.570]                   {
[13:22:30.570]                     print(1:50)
[13:22:30.570]                     str(1:50)
[13:22:30.570]                     cat(letters, sep = "-")
[13:22:30.570]                     cat(1:6, collapse = "\n")
[13:22:30.570]                     write.table(datasets::iris[1:10, ], sep = "\t")
[13:22:30.570]                     42L
[13:22:30.570]                   }
[13:22:30.570]                 }, immediateCondition = function(cond) {
[13:22:30.570]                   sendCondition <- ...future.makeSendCondition()
[13:22:30.570]                   sendCondition(cond)
[13:22:30.570]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:30.570]                   {
[13:22:30.570]                     inherits <- base::inherits
[13:22:30.570]                     invokeRestart <- base::invokeRestart
[13:22:30.570]                     is.null <- base::is.null
[13:22:30.570]                     muffled <- FALSE
[13:22:30.570]                     if (inherits(cond, "message")) {
[13:22:30.570]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:30.570]                       if (muffled) 
[13:22:30.570]                         invokeRestart("muffleMessage")
[13:22:30.570]                     }
[13:22:30.570]                     else if (inherits(cond, "warning")) {
[13:22:30.570]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:30.570]                       if (muffled) 
[13:22:30.570]                         invokeRestart("muffleWarning")
[13:22:30.570]                     }
[13:22:30.570]                     else if (inherits(cond, "condition")) {
[13:22:30.570]                       if (!is.null(pattern)) {
[13:22:30.570]                         computeRestarts <- base::computeRestarts
[13:22:30.570]                         grepl <- base::grepl
[13:22:30.570]                         restarts <- computeRestarts(cond)
[13:22:30.570]                         for (restart in restarts) {
[13:22:30.570]                           name <- restart$name
[13:22:30.570]                           if (is.null(name)) 
[13:22:30.570]                             next
[13:22:30.570]                           if (!grepl(pattern, name)) 
[13:22:30.570]                             next
[13:22:30.570]                           invokeRestart(restart)
[13:22:30.570]                           muffled <- TRUE
[13:22:30.570]                           break
[13:22:30.570]                         }
[13:22:30.570]                       }
[13:22:30.570]                     }
[13:22:30.570]                     invisible(muffled)
[13:22:30.570]                   }
[13:22:30.570]                   muffleCondition(cond)
[13:22:30.570]                 })
[13:22:30.570]             }))
[13:22:30.570]             future::FutureResult(value = ...future.value$value, 
[13:22:30.570]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:30.570]                   ...future.rng), globalenv = if (FALSE) 
[13:22:30.570]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:30.570]                     ...future.globalenv.names))
[13:22:30.570]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:30.570]         }, condition = base::local({
[13:22:30.570]             c <- base::c
[13:22:30.570]             inherits <- base::inherits
[13:22:30.570]             invokeRestart <- base::invokeRestart
[13:22:30.570]             length <- base::length
[13:22:30.570]             list <- base::list
[13:22:30.570]             seq.int <- base::seq.int
[13:22:30.570]             signalCondition <- base::signalCondition
[13:22:30.570]             sys.calls <- base::sys.calls
[13:22:30.570]             `[[` <- base::`[[`
[13:22:30.570]             `+` <- base::`+`
[13:22:30.570]             `<<-` <- base::`<<-`
[13:22:30.570]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:30.570]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:30.570]                   3L)]
[13:22:30.570]             }
[13:22:30.570]             function(cond) {
[13:22:30.570]                 is_error <- inherits(cond, "error")
[13:22:30.570]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:30.570]                   NULL)
[13:22:30.570]                 if (is_error) {
[13:22:30.570]                   sessionInformation <- function() {
[13:22:30.570]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:30.570]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:30.570]                       search = base::search(), system = base::Sys.info())
[13:22:30.570]                   }
[13:22:30.570]                   ...future.conditions[[length(...future.conditions) + 
[13:22:30.570]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:30.570]                     cond$call), session = sessionInformation(), 
[13:22:30.570]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:30.570]                   signalCondition(cond)
[13:22:30.570]                 }
[13:22:30.570]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:30.570]                 "immediateCondition"))) {
[13:22:30.570]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:30.570]                   ...future.conditions[[length(...future.conditions) + 
[13:22:30.570]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:30.570]                   if (TRUE && !signal) {
[13:22:30.570]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:30.570]                     {
[13:22:30.570]                       inherits <- base::inherits
[13:22:30.570]                       invokeRestart <- base::invokeRestart
[13:22:30.570]                       is.null <- base::is.null
[13:22:30.570]                       muffled <- FALSE
[13:22:30.570]                       if (inherits(cond, "message")) {
[13:22:30.570]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:30.570]                         if (muffled) 
[13:22:30.570]                           invokeRestart("muffleMessage")
[13:22:30.570]                       }
[13:22:30.570]                       else if (inherits(cond, "warning")) {
[13:22:30.570]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:30.570]                         if (muffled) 
[13:22:30.570]                           invokeRestart("muffleWarning")
[13:22:30.570]                       }
[13:22:30.570]                       else if (inherits(cond, "condition")) {
[13:22:30.570]                         if (!is.null(pattern)) {
[13:22:30.570]                           computeRestarts <- base::computeRestarts
[13:22:30.570]                           grepl <- base::grepl
[13:22:30.570]                           restarts <- computeRestarts(cond)
[13:22:30.570]                           for (restart in restarts) {
[13:22:30.570]                             name <- restart$name
[13:22:30.570]                             if (is.null(name)) 
[13:22:30.570]                               next
[13:22:30.570]                             if (!grepl(pattern, name)) 
[13:22:30.570]                               next
[13:22:30.570]                             invokeRestart(restart)
[13:22:30.570]                             muffled <- TRUE
[13:22:30.570]                             break
[13:22:30.570]                           }
[13:22:30.570]                         }
[13:22:30.570]                       }
[13:22:30.570]                       invisible(muffled)
[13:22:30.570]                     }
[13:22:30.570]                     muffleCondition(cond, pattern = "^muffle")
[13:22:30.570]                   }
[13:22:30.570]                 }
[13:22:30.570]                 else {
[13:22:30.570]                   if (TRUE) {
[13:22:30.570]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:30.570]                     {
[13:22:30.570]                       inherits <- base::inherits
[13:22:30.570]                       invokeRestart <- base::invokeRestart
[13:22:30.570]                       is.null <- base::is.null
[13:22:30.570]                       muffled <- FALSE
[13:22:30.570]                       if (inherits(cond, "message")) {
[13:22:30.570]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:30.570]                         if (muffled) 
[13:22:30.570]                           invokeRestart("muffleMessage")
[13:22:30.570]                       }
[13:22:30.570]                       else if (inherits(cond, "warning")) {
[13:22:30.570]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:30.570]                         if (muffled) 
[13:22:30.570]                           invokeRestart("muffleWarning")
[13:22:30.570]                       }
[13:22:30.570]                       else if (inherits(cond, "condition")) {
[13:22:30.570]                         if (!is.null(pattern)) {
[13:22:30.570]                           computeRestarts <- base::computeRestarts
[13:22:30.570]                           grepl <- base::grepl
[13:22:30.570]                           restarts <- computeRestarts(cond)
[13:22:30.570]                           for (restart in restarts) {
[13:22:30.570]                             name <- restart$name
[13:22:30.570]                             if (is.null(name)) 
[13:22:30.570]                               next
[13:22:30.570]                             if (!grepl(pattern, name)) 
[13:22:30.570]                               next
[13:22:30.570]                             invokeRestart(restart)
[13:22:30.570]                             muffled <- TRUE
[13:22:30.570]                             break
[13:22:30.570]                           }
[13:22:30.570]                         }
[13:22:30.570]                       }
[13:22:30.570]                       invisible(muffled)
[13:22:30.570]                     }
[13:22:30.570]                     muffleCondition(cond, pattern = "^muffle")
[13:22:30.570]                   }
[13:22:30.570]                 }
[13:22:30.570]             }
[13:22:30.570]         }))
[13:22:30.570]     }, error = function(ex) {
[13:22:30.570]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:30.570]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:30.570]                 ...future.rng), started = ...future.startTime, 
[13:22:30.570]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:30.570]             version = "1.8"), class = "FutureResult")
[13:22:30.570]     }, finally = {
[13:22:30.570]         if (!identical(...future.workdir, getwd())) 
[13:22:30.570]             setwd(...future.workdir)
[13:22:30.570]         {
[13:22:30.570]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:30.570]                 ...future.oldOptions$nwarnings <- NULL
[13:22:30.570]             }
[13:22:30.570]             base::options(...future.oldOptions)
[13:22:30.570]             if (.Platform$OS.type == "windows") {
[13:22:30.570]                 old_names <- names(...future.oldEnvVars)
[13:22:30.570]                 envs <- base::Sys.getenv()
[13:22:30.570]                 names <- names(envs)
[13:22:30.570]                 common <- intersect(names, old_names)
[13:22:30.570]                 added <- setdiff(names, old_names)
[13:22:30.570]                 removed <- setdiff(old_names, names)
[13:22:30.570]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:30.570]                   envs[common]]
[13:22:30.570]                 NAMES <- toupper(changed)
[13:22:30.570]                 args <- list()
[13:22:30.570]                 for (kk in seq_along(NAMES)) {
[13:22:30.570]                   name <- changed[[kk]]
[13:22:30.570]                   NAME <- NAMES[[kk]]
[13:22:30.570]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:30.570]                     next
[13:22:30.570]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:30.570]                 }
[13:22:30.570]                 NAMES <- toupper(added)
[13:22:30.570]                 for (kk in seq_along(NAMES)) {
[13:22:30.570]                   name <- added[[kk]]
[13:22:30.570]                   NAME <- NAMES[[kk]]
[13:22:30.570]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:30.570]                     next
[13:22:30.570]                   args[[name]] <- ""
[13:22:30.570]                 }
[13:22:30.570]                 NAMES <- toupper(removed)
[13:22:30.570]                 for (kk in seq_along(NAMES)) {
[13:22:30.570]                   name <- removed[[kk]]
[13:22:30.570]                   NAME <- NAMES[[kk]]
[13:22:30.570]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:30.570]                     next
[13:22:30.570]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:30.570]                 }
[13:22:30.570]                 if (length(args) > 0) 
[13:22:30.570]                   base::do.call(base::Sys.setenv, args = args)
[13:22:30.570]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:30.570]             }
[13:22:30.570]             else {
[13:22:30.570]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:30.570]             }
[13:22:30.570]             {
[13:22:30.570]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:30.570]                   0L) {
[13:22:30.570]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:30.570]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:30.570]                   base::options(opts)
[13:22:30.570]                 }
[13:22:30.570]                 {
[13:22:30.570]                   {
[13:22:30.570]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:30.570]                     NULL
[13:22:30.570]                   }
[13:22:30.570]                   options(future.plan = NULL)
[13:22:30.570]                   if (is.na(NA_character_)) 
[13:22:30.570]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:30.570]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:30.570]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:30.570]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:30.570]                     envir = parent.frame()) 
[13:22:30.570]                   {
[13:22:30.570]                     if (is.function(workers)) 
[13:22:30.570]                       workers <- workers()
[13:22:30.570]                     workers <- structure(as.integer(workers), 
[13:22:30.570]                       class = class(workers))
[13:22:30.570]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:30.570]                       workers >= 1)
[13:22:30.570]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:30.570]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:30.570]                     }
[13:22:30.570]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:30.570]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:30.570]                       envir = envir)
[13:22:30.570]                     if (!future$lazy) 
[13:22:30.570]                       future <- run(future)
[13:22:30.570]                     invisible(future)
[13:22:30.570]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:30.570]                 }
[13:22:30.570]             }
[13:22:30.570]         }
[13:22:30.570]     })
[13:22:30.570]     if (TRUE) {
[13:22:30.570]         base::sink(type = "output", split = FALSE)
[13:22:30.570]         if (FALSE) {
[13:22:30.570]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:30.570]         }
[13:22:30.570]         else {
[13:22:30.570]             ...future.result["stdout"] <- base::list(NULL)
[13:22:30.570]         }
[13:22:30.570]         base::close(...future.stdout)
[13:22:30.570]         ...future.stdout <- NULL
[13:22:30.570]     }
[13:22:30.570]     ...future.result$conditions <- ...future.conditions
[13:22:30.570]     ...future.result$finished <- base::Sys.time()
[13:22:30.570]     ...future.result
[13:22:30.570] }
[13:22:30.574] MultisessionFuture started
[13:22:30.574] - Launch lazy future ... done
[13:22:30.574] run() for ‘MultisessionFuture’ ... done
[13:22:30.574] result() for ClusterFuture ...
[13:22:30.574] receiveMessageFromWorker() for ClusterFuture ...
[13:22:30.574] - Validating connection of MultisessionFuture
[13:22:30.623] - received message: FutureResult
[13:22:30.623] - Received FutureResult
[13:22:30.623] - Erased future from FutureRegistry
[13:22:30.624] result() for ClusterFuture ...
[13:22:30.624] - result already collected: FutureResult
[13:22:30.624] result() for ClusterFuture ... done
[13:22:30.624] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:30.624] result() for ClusterFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-01-07 13:22:30"
 $ finished    : POSIXct[1:1], format: "2025-01-07 13:22:30"
 $ session_uuid: chr "256798a4-5c30-7eef-db48-d08f6d787740"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "5853cd8d1af0"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "5853cd8d1af0" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 93526
  .. ..$ time  : POSIXct[1:1], format: "2025-01-07 13:22:30"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 3 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[13:22:30.632] result() for ClusterFuture ...
[13:22:30.632] - result already collected: FutureResult
[13:22:30.632] result() for ClusterFuture ... done
[13:22:30.632] result() for ClusterFuture ...
[13:22:30.632] - result already collected: FutureResult
[13:22:30.632] result() for ClusterFuture ... done
[13:22:30.633] getGlobalsAndPackages() ...
[13:22:30.633] Searching for globals...
[13:22:30.636] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[13:22:30.636] Searching for globals ... DONE
[13:22:30.636] Resolving globals: FALSE
[13:22:30.637] 
[13:22:30.637] - packages: [1] ‘utils’
[13:22:30.637] getGlobalsAndPackages() ... DONE
[13:22:30.637] run() for ‘Future’ ...
[13:22:30.637] - state: ‘created’
[13:22:30.637] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:30.652] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:30.652] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:30.652]   - Field: ‘node’
[13:22:30.652]   - Field: ‘label’
[13:22:30.652]   - Field: ‘local’
[13:22:30.653]   - Field: ‘owner’
[13:22:30.653]   - Field: ‘envir’
[13:22:30.653]   - Field: ‘workers’
[13:22:30.653]   - Field: ‘packages’
[13:22:30.653]   - Field: ‘gc’
[13:22:30.653]   - Field: ‘conditions’
[13:22:30.653]   - Field: ‘persistent’
[13:22:30.653]   - Field: ‘expr’
[13:22:30.653]   - Field: ‘uuid’
[13:22:30.653]   - Field: ‘seed’
[13:22:30.654]   - Field: ‘version’
[13:22:30.654]   - Field: ‘result’
[13:22:30.654]   - Field: ‘asynchronous’
[13:22:30.654]   - Field: ‘calls’
[13:22:30.654]   - Field: ‘globals’
[13:22:30.654]   - Field: ‘stdout’
[13:22:30.654]   - Field: ‘earlySignal’
[13:22:30.654]   - Field: ‘lazy’
[13:22:30.654]   - Field: ‘state’
[13:22:30.655] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:30.655] - Launch lazy future ...
[13:22:30.655] Packages needed by the future expression (n = 1): ‘utils’
[13:22:30.655] Packages needed by future strategies (n = 0): <none>
[13:22:30.656] {
[13:22:30.656]     {
[13:22:30.656]         {
[13:22:30.656]             ...future.startTime <- base::Sys.time()
[13:22:30.656]             {
[13:22:30.656]                 {
[13:22:30.656]                   {
[13:22:30.656]                     {
[13:22:30.656]                       {
[13:22:30.656]                         base::local({
[13:22:30.656]                           has_future <- base::requireNamespace("future", 
[13:22:30.656]                             quietly = TRUE)
[13:22:30.656]                           if (has_future) {
[13:22:30.656]                             ns <- base::getNamespace("future")
[13:22:30.656]                             version <- ns[[".package"]][["version"]]
[13:22:30.656]                             if (is.null(version)) 
[13:22:30.656]                               version <- utils::packageVersion("future")
[13:22:30.656]                           }
[13:22:30.656]                           else {
[13:22:30.656]                             version <- NULL
[13:22:30.656]                           }
[13:22:30.656]                           if (!has_future || version < "1.8.0") {
[13:22:30.656]                             info <- base::c(r_version = base::gsub("R version ", 
[13:22:30.656]                               "", base::R.version$version.string), 
[13:22:30.656]                               platform = base::sprintf("%s (%s-bit)", 
[13:22:30.656]                                 base::R.version$platform, 8 * 
[13:22:30.656]                                   base::.Machine$sizeof.pointer), 
[13:22:30.656]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:30.656]                                 "release", "version")], collapse = " "), 
[13:22:30.656]                               hostname = base::Sys.info()[["nodename"]])
[13:22:30.656]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:22:30.656]                               info)
[13:22:30.656]                             info <- base::paste(info, collapse = "; ")
[13:22:30.656]                             if (!has_future) {
[13:22:30.656]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:30.656]                                 info)
[13:22:30.656]                             }
[13:22:30.656]                             else {
[13:22:30.656]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:30.656]                                 info, version)
[13:22:30.656]                             }
[13:22:30.656]                             base::stop(msg)
[13:22:30.656]                           }
[13:22:30.656]                         })
[13:22:30.656]                       }
[13:22:30.656]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:30.656]                       base::options(mc.cores = 1L)
[13:22:30.656]                     }
[13:22:30.656]                     base::local({
[13:22:30.656]                       for (pkg in "utils") {
[13:22:30.656]                         base::loadNamespace(pkg)
[13:22:30.656]                         base::library(pkg, character.only = TRUE)
[13:22:30.656]                       }
[13:22:30.656]                     })
[13:22:30.656]                   }
[13:22:30.656]                   options(future.plan = NULL)
[13:22:30.656]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:30.656]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:30.656]                 }
[13:22:30.656]                 ...future.workdir <- getwd()
[13:22:30.656]             }
[13:22:30.656]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:30.656]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:30.656]         }
[13:22:30.656]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:30.656]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:30.656]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:30.656]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:30.656]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:30.656]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:30.656]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:30.656]             base::names(...future.oldOptions))
[13:22:30.656]     }
[13:22:30.656]     if (FALSE) {
[13:22:30.656]     }
[13:22:30.656]     else {
[13:22:30.656]         if (FALSE) {
[13:22:30.656]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:30.656]                 open = "w")
[13:22:30.656]         }
[13:22:30.656]         else {
[13:22:30.656]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:30.656]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:30.656]         }
[13:22:30.656]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:30.656]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:30.656]             base::sink(type = "output", split = FALSE)
[13:22:30.656]             base::close(...future.stdout)
[13:22:30.656]         }, add = TRUE)
[13:22:30.656]     }
[13:22:30.656]     ...future.frame <- base::sys.nframe()
[13:22:30.656]     ...future.conditions <- base::list()
[13:22:30.656]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:30.656]     if (FALSE) {
[13:22:30.656]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:30.656]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:30.656]     }
[13:22:30.656]     ...future.result <- base::tryCatch({
[13:22:30.656]         base::withCallingHandlers({
[13:22:30.656]             ...future.value <- base::withVisible(base::local({
[13:22:30.656]                 ...future.makeSendCondition <- local({
[13:22:30.656]                   sendCondition <- NULL
[13:22:30.656]                   function(frame = 1L) {
[13:22:30.656]                     if (is.function(sendCondition)) 
[13:22:30.656]                       return(sendCondition)
[13:22:30.656]                     ns <- getNamespace("parallel")
[13:22:30.656]                     if (exists("sendData", mode = "function", 
[13:22:30.656]                       envir = ns)) {
[13:22:30.656]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:30.656]                         envir = ns)
[13:22:30.656]                       envir <- sys.frame(frame)
[13:22:30.656]                       master <- NULL
[13:22:30.656]                       while (!identical(envir, .GlobalEnv) && 
[13:22:30.656]                         !identical(envir, emptyenv())) {
[13:22:30.656]                         if (exists("master", mode = "list", envir = envir, 
[13:22:30.656]                           inherits = FALSE)) {
[13:22:30.656]                           master <- get("master", mode = "list", 
[13:22:30.656]                             envir = envir, inherits = FALSE)
[13:22:30.656]                           if (inherits(master, c("SOCKnode", 
[13:22:30.656]                             "SOCK0node"))) {
[13:22:30.656]                             sendCondition <<- function(cond) {
[13:22:30.656]                               data <- list(type = "VALUE", value = cond, 
[13:22:30.656]                                 success = TRUE)
[13:22:30.656]                               parallel_sendData(master, data)
[13:22:30.656]                             }
[13:22:30.656]                             return(sendCondition)
[13:22:30.656]                           }
[13:22:30.656]                         }
[13:22:30.656]                         frame <- frame + 1L
[13:22:30.656]                         envir <- sys.frame(frame)
[13:22:30.656]                       }
[13:22:30.656]                     }
[13:22:30.656]                     sendCondition <<- function(cond) NULL
[13:22:30.656]                   }
[13:22:30.656]                 })
[13:22:30.656]                 withCallingHandlers({
[13:22:30.656]                   {
[13:22:30.656]                     print(1:50)
[13:22:30.656]                     str(1:50)
[13:22:30.656]                     cat(letters, sep = "-")
[13:22:30.656]                     cat(1:6, collapse = "\n")
[13:22:30.656]                     write.table(datasets::iris[1:10, ], sep = "\t")
[13:22:30.656]                     42L
[13:22:30.656]                   }
[13:22:30.656]                 }, immediateCondition = function(cond) {
[13:22:30.656]                   sendCondition <- ...future.makeSendCondition()
[13:22:30.656]                   sendCondition(cond)
[13:22:30.656]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:30.656]                   {
[13:22:30.656]                     inherits <- base::inherits
[13:22:30.656]                     invokeRestart <- base::invokeRestart
[13:22:30.656]                     is.null <- base::is.null
[13:22:30.656]                     muffled <- FALSE
[13:22:30.656]                     if (inherits(cond, "message")) {
[13:22:30.656]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:30.656]                       if (muffled) 
[13:22:30.656]                         invokeRestart("muffleMessage")
[13:22:30.656]                     }
[13:22:30.656]                     else if (inherits(cond, "warning")) {
[13:22:30.656]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:30.656]                       if (muffled) 
[13:22:30.656]                         invokeRestart("muffleWarning")
[13:22:30.656]                     }
[13:22:30.656]                     else if (inherits(cond, "condition")) {
[13:22:30.656]                       if (!is.null(pattern)) {
[13:22:30.656]                         computeRestarts <- base::computeRestarts
[13:22:30.656]                         grepl <- base::grepl
[13:22:30.656]                         restarts <- computeRestarts(cond)
[13:22:30.656]                         for (restart in restarts) {
[13:22:30.656]                           name <- restart$name
[13:22:30.656]                           if (is.null(name)) 
[13:22:30.656]                             next
[13:22:30.656]                           if (!grepl(pattern, name)) 
[13:22:30.656]                             next
[13:22:30.656]                           invokeRestart(restart)
[13:22:30.656]                           muffled <- TRUE
[13:22:30.656]                           break
[13:22:30.656]                         }
[13:22:30.656]                       }
[13:22:30.656]                     }
[13:22:30.656]                     invisible(muffled)
[13:22:30.656]                   }
[13:22:30.656]                   muffleCondition(cond)
[13:22:30.656]                 })
[13:22:30.656]             }))
[13:22:30.656]             future::FutureResult(value = ...future.value$value, 
[13:22:30.656]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:30.656]                   ...future.rng), globalenv = if (FALSE) 
[13:22:30.656]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:30.656]                     ...future.globalenv.names))
[13:22:30.656]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:30.656]         }, condition = base::local({
[13:22:30.656]             c <- base::c
[13:22:30.656]             inherits <- base::inherits
[13:22:30.656]             invokeRestart <- base::invokeRestart
[13:22:30.656]             length <- base::length
[13:22:30.656]             list <- base::list
[13:22:30.656]             seq.int <- base::seq.int
[13:22:30.656]             signalCondition <- base::signalCondition
[13:22:30.656]             sys.calls <- base::sys.calls
[13:22:30.656]             `[[` <- base::`[[`
[13:22:30.656]             `+` <- base::`+`
[13:22:30.656]             `<<-` <- base::`<<-`
[13:22:30.656]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:30.656]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:30.656]                   3L)]
[13:22:30.656]             }
[13:22:30.656]             function(cond) {
[13:22:30.656]                 is_error <- inherits(cond, "error")
[13:22:30.656]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:30.656]                   NULL)
[13:22:30.656]                 if (is_error) {
[13:22:30.656]                   sessionInformation <- function() {
[13:22:30.656]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:30.656]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:30.656]                       search = base::search(), system = base::Sys.info())
[13:22:30.656]                   }
[13:22:30.656]                   ...future.conditions[[length(...future.conditions) + 
[13:22:30.656]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:30.656]                     cond$call), session = sessionInformation(), 
[13:22:30.656]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:30.656]                   signalCondition(cond)
[13:22:30.656]                 }
[13:22:30.656]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:30.656]                 "immediateCondition"))) {
[13:22:30.656]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:30.656]                   ...future.conditions[[length(...future.conditions) + 
[13:22:30.656]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:30.656]                   if (TRUE && !signal) {
[13:22:30.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:30.656]                     {
[13:22:30.656]                       inherits <- base::inherits
[13:22:30.656]                       invokeRestart <- base::invokeRestart
[13:22:30.656]                       is.null <- base::is.null
[13:22:30.656]                       muffled <- FALSE
[13:22:30.656]                       if (inherits(cond, "message")) {
[13:22:30.656]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:30.656]                         if (muffled) 
[13:22:30.656]                           invokeRestart("muffleMessage")
[13:22:30.656]                       }
[13:22:30.656]                       else if (inherits(cond, "warning")) {
[13:22:30.656]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:30.656]                         if (muffled) 
[13:22:30.656]                           invokeRestart("muffleWarning")
[13:22:30.656]                       }
[13:22:30.656]                       else if (inherits(cond, "condition")) {
[13:22:30.656]                         if (!is.null(pattern)) {
[13:22:30.656]                           computeRestarts <- base::computeRestarts
[13:22:30.656]                           grepl <- base::grepl
[13:22:30.656]                           restarts <- computeRestarts(cond)
[13:22:30.656]                           for (restart in restarts) {
[13:22:30.656]                             name <- restart$name
[13:22:30.656]                             if (is.null(name)) 
[13:22:30.656]                               next
[13:22:30.656]                             if (!grepl(pattern, name)) 
[13:22:30.656]                               next
[13:22:30.656]                             invokeRestart(restart)
[13:22:30.656]                             muffled <- TRUE
[13:22:30.656]                             break
[13:22:30.656]                           }
[13:22:30.656]                         }
[13:22:30.656]                       }
[13:22:30.656]                       invisible(muffled)
[13:22:30.656]                     }
[13:22:30.656]                     muffleCondition(cond, pattern = "^muffle")
[13:22:30.656]                   }
[13:22:30.656]                 }
[13:22:30.656]                 else {
[13:22:30.656]                   if (TRUE) {
[13:22:30.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:30.656]                     {
[13:22:30.656]                       inherits <- base::inherits
[13:22:30.656]                       invokeRestart <- base::invokeRestart
[13:22:30.656]                       is.null <- base::is.null
[13:22:30.656]                       muffled <- FALSE
[13:22:30.656]                       if (inherits(cond, "message")) {
[13:22:30.656]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:30.656]                         if (muffled) 
[13:22:30.656]                           invokeRestart("muffleMessage")
[13:22:30.656]                       }
[13:22:30.656]                       else if (inherits(cond, "warning")) {
[13:22:30.656]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:30.656]                         if (muffled) 
[13:22:30.656]                           invokeRestart("muffleWarning")
[13:22:30.656]                       }
[13:22:30.656]                       else if (inherits(cond, "condition")) {
[13:22:30.656]                         if (!is.null(pattern)) {
[13:22:30.656]                           computeRestarts <- base::computeRestarts
[13:22:30.656]                           grepl <- base::grepl
[13:22:30.656]                           restarts <- computeRestarts(cond)
[13:22:30.656]                           for (restart in restarts) {
[13:22:30.656]                             name <- restart$name
[13:22:30.656]                             if (is.null(name)) 
[13:22:30.656]                               next
[13:22:30.656]                             if (!grepl(pattern, name)) 
[13:22:30.656]                               next
[13:22:30.656]                             invokeRestart(restart)
[13:22:30.656]                             muffled <- TRUE
[13:22:30.656]                             break
[13:22:30.656]                           }
[13:22:30.656]                         }
[13:22:30.656]                       }
[13:22:30.656]                       invisible(muffled)
[13:22:30.656]                     }
[13:22:30.656]                     muffleCondition(cond, pattern = "^muffle")
[13:22:30.656]                   }
[13:22:30.656]                 }
[13:22:30.656]             }
[13:22:30.656]         }))
[13:22:30.656]     }, error = function(ex) {
[13:22:30.656]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:30.656]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:30.656]                 ...future.rng), started = ...future.startTime, 
[13:22:30.656]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:30.656]             version = "1.8"), class = "FutureResult")
[13:22:30.656]     }, finally = {
[13:22:30.656]         if (!identical(...future.workdir, getwd())) 
[13:22:30.656]             setwd(...future.workdir)
[13:22:30.656]         {
[13:22:30.656]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:30.656]                 ...future.oldOptions$nwarnings <- NULL
[13:22:30.656]             }
[13:22:30.656]             base::options(...future.oldOptions)
[13:22:30.656]             if (.Platform$OS.type == "windows") {
[13:22:30.656]                 old_names <- names(...future.oldEnvVars)
[13:22:30.656]                 envs <- base::Sys.getenv()
[13:22:30.656]                 names <- names(envs)
[13:22:30.656]                 common <- intersect(names, old_names)
[13:22:30.656]                 added <- setdiff(names, old_names)
[13:22:30.656]                 removed <- setdiff(old_names, names)
[13:22:30.656]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:30.656]                   envs[common]]
[13:22:30.656]                 NAMES <- toupper(changed)
[13:22:30.656]                 args <- list()
[13:22:30.656]                 for (kk in seq_along(NAMES)) {
[13:22:30.656]                   name <- changed[[kk]]
[13:22:30.656]                   NAME <- NAMES[[kk]]
[13:22:30.656]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:30.656]                     next
[13:22:30.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:30.656]                 }
[13:22:30.656]                 NAMES <- toupper(added)
[13:22:30.656]                 for (kk in seq_along(NAMES)) {
[13:22:30.656]                   name <- added[[kk]]
[13:22:30.656]                   NAME <- NAMES[[kk]]
[13:22:30.656]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:30.656]                     next
[13:22:30.656]                   args[[name]] <- ""
[13:22:30.656]                 }
[13:22:30.656]                 NAMES <- toupper(removed)
[13:22:30.656]                 for (kk in seq_along(NAMES)) {
[13:22:30.656]                   name <- removed[[kk]]
[13:22:30.656]                   NAME <- NAMES[[kk]]
[13:22:30.656]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:30.656]                     next
[13:22:30.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:30.656]                 }
[13:22:30.656]                 if (length(args) > 0) 
[13:22:30.656]                   base::do.call(base::Sys.setenv, args = args)
[13:22:30.656]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:30.656]             }
[13:22:30.656]             else {
[13:22:30.656]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:30.656]             }
[13:22:30.656]             {
[13:22:30.656]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:30.656]                   0L) {
[13:22:30.656]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:30.656]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:30.656]                   base::options(opts)
[13:22:30.656]                 }
[13:22:30.656]                 {
[13:22:30.656]                   {
[13:22:30.656]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:30.656]                     NULL
[13:22:30.656]                   }
[13:22:30.656]                   options(future.plan = NULL)
[13:22:30.656]                   if (is.na(NA_character_)) 
[13:22:30.656]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:30.656]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:30.656]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:30.656]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:30.656]                     envir = parent.frame()) 
[13:22:30.656]                   {
[13:22:30.656]                     if (is.function(workers)) 
[13:22:30.656]                       workers <- workers()
[13:22:30.656]                     workers <- structure(as.integer(workers), 
[13:22:30.656]                       class = class(workers))
[13:22:30.656]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:30.656]                       workers >= 1)
[13:22:30.656]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:30.656]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:30.656]                     }
[13:22:30.656]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:30.656]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:30.656]                       envir = envir)
[13:22:30.656]                     if (!future$lazy) 
[13:22:30.656]                       future <- run(future)
[13:22:30.656]                     invisible(future)
[13:22:30.656]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:30.656]                 }
[13:22:30.656]             }
[13:22:30.656]         }
[13:22:30.656]     })
[13:22:30.656]     if (TRUE) {
[13:22:30.656]         base::sink(type = "output", split = FALSE)
[13:22:30.656]         if (FALSE) {
[13:22:30.656]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:30.656]         }
[13:22:30.656]         else {
[13:22:30.656]             ...future.result["stdout"] <- base::list(NULL)
[13:22:30.656]         }
[13:22:30.656]         base::close(...future.stdout)
[13:22:30.656]         ...future.stdout <- NULL
[13:22:30.656]     }
[13:22:30.656]     ...future.result$conditions <- ...future.conditions
[13:22:30.656]     ...future.result$finished <- base::Sys.time()
[13:22:30.656]     ...future.result
[13:22:30.656] }
[13:22:30.659] MultisessionFuture started
[13:22:30.659] - Launch lazy future ... done
[13:22:30.660] run() for ‘MultisessionFuture’ ... done
[13:22:30.660] result() for ClusterFuture ...
[13:22:30.660] receiveMessageFromWorker() for ClusterFuture ...
[13:22:30.660] - Validating connection of MultisessionFuture
[13:22:30.707] - received message: FutureResult
[13:22:30.707] - Received FutureResult
[13:22:30.707] - Erased future from FutureRegistry
[13:22:30.707] result() for ClusterFuture ...
[13:22:30.707] - result already collected: FutureResult
[13:22:30.707] result() for ClusterFuture ... done
[13:22:30.707] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:30.708] result() for ClusterFuture ... done
[13:22:30.708] result() for ClusterFuture ...
[13:22:30.708] - result already collected: FutureResult
[13:22:30.708] result() for ClusterFuture ... done
- stdout = structure(TRUE, drop = TRUE)
[13:22:30.708] getGlobalsAndPackages() ...
[13:22:30.708] Searching for globals...
[13:22:30.709] - globals found: [1] ‘print’
[13:22:30.709] Searching for globals ... DONE
[13:22:30.709] Resolving globals: FALSE
[13:22:30.709] 
[13:22:30.709] 
[13:22:30.710] getGlobalsAndPackages() ... DONE
[13:22:30.710] run() for ‘Future’ ...
[13:22:30.710] - state: ‘created’
[13:22:30.710] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:30.725] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:30.725] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:30.725]   - Field: ‘node’
[13:22:30.725]   - Field: ‘label’
[13:22:30.725]   - Field: ‘local’
[13:22:30.725]   - Field: ‘owner’
[13:22:30.725]   - Field: ‘envir’
[13:22:30.726]   - Field: ‘workers’
[13:22:30.726]   - Field: ‘packages’
[13:22:30.726]   - Field: ‘gc’
[13:22:30.726]   - Field: ‘conditions’
[13:22:30.726]   - Field: ‘persistent’
[13:22:30.726]   - Field: ‘expr’
[13:22:30.726]   - Field: ‘uuid’
[13:22:30.726]   - Field: ‘seed’
[13:22:30.726]   - Field: ‘version’
[13:22:30.726]   - Field: ‘result’
[13:22:30.727]   - Field: ‘asynchronous’
[13:22:30.727]   - Field: ‘calls’
[13:22:30.727]   - Field: ‘globals’
[13:22:30.727]   - Field: ‘stdout’
[13:22:30.727]   - Field: ‘earlySignal’
[13:22:30.727]   - Field: ‘lazy’
[13:22:30.727]   - Field: ‘state’
[13:22:30.727] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:30.727] - Launch lazy future ...
[13:22:30.728] Packages needed by the future expression (n = 0): <none>
[13:22:30.728] Packages needed by future strategies (n = 0): <none>
[13:22:30.728] {
[13:22:30.728]     {
[13:22:30.728]         {
[13:22:30.728]             ...future.startTime <- base::Sys.time()
[13:22:30.728]             {
[13:22:30.728]                 {
[13:22:30.728]                   {
[13:22:30.728]                     {
[13:22:30.728]                       base::local({
[13:22:30.728]                         has_future <- base::requireNamespace("future", 
[13:22:30.728]                           quietly = TRUE)
[13:22:30.728]                         if (has_future) {
[13:22:30.728]                           ns <- base::getNamespace("future")
[13:22:30.728]                           version <- ns[[".package"]][["version"]]
[13:22:30.728]                           if (is.null(version)) 
[13:22:30.728]                             version <- utils::packageVersion("future")
[13:22:30.728]                         }
[13:22:30.728]                         else {
[13:22:30.728]                           version <- NULL
[13:22:30.728]                         }
[13:22:30.728]                         if (!has_future || version < "1.8.0") {
[13:22:30.728]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:30.728]                             "", base::R.version$version.string), 
[13:22:30.728]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:30.728]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:30.728]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:30.728]                               "release", "version")], collapse = " "), 
[13:22:30.728]                             hostname = base::Sys.info()[["nodename"]])
[13:22:30.728]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:30.728]                             info)
[13:22:30.728]                           info <- base::paste(info, collapse = "; ")
[13:22:30.728]                           if (!has_future) {
[13:22:30.728]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:30.728]                               info)
[13:22:30.728]                           }
[13:22:30.728]                           else {
[13:22:30.728]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:30.728]                               info, version)
[13:22:30.728]                           }
[13:22:30.728]                           base::stop(msg)
[13:22:30.728]                         }
[13:22:30.728]                       })
[13:22:30.728]                     }
[13:22:30.728]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:30.728]                     base::options(mc.cores = 1L)
[13:22:30.728]                   }
[13:22:30.728]                   options(future.plan = NULL)
[13:22:30.728]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:30.728]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:30.728]                 }
[13:22:30.728]                 ...future.workdir <- getwd()
[13:22:30.728]             }
[13:22:30.728]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:30.728]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:30.728]         }
[13:22:30.728]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:30.728]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:30.728]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:30.728]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:30.728]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:30.728]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:30.728]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:30.728]             base::names(...future.oldOptions))
[13:22:30.728]     }
[13:22:30.728]     if (FALSE) {
[13:22:30.728]     }
[13:22:30.728]     else {
[13:22:30.728]         if (TRUE) {
[13:22:30.728]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:30.728]                 open = "w")
[13:22:30.728]         }
[13:22:30.728]         else {
[13:22:30.728]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:30.728]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:30.728]         }
[13:22:30.728]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:30.728]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:30.728]             base::sink(type = "output", split = FALSE)
[13:22:30.728]             base::close(...future.stdout)
[13:22:30.728]         }, add = TRUE)
[13:22:30.728]     }
[13:22:30.728]     ...future.frame <- base::sys.nframe()
[13:22:30.728]     ...future.conditions <- base::list()
[13:22:30.728]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:30.728]     if (FALSE) {
[13:22:30.728]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:30.728]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:30.728]     }
[13:22:30.728]     ...future.result <- base::tryCatch({
[13:22:30.728]         base::withCallingHandlers({
[13:22:30.728]             ...future.value <- base::withVisible(base::local({
[13:22:30.728]                 ...future.makeSendCondition <- local({
[13:22:30.728]                   sendCondition <- NULL
[13:22:30.728]                   function(frame = 1L) {
[13:22:30.728]                     if (is.function(sendCondition)) 
[13:22:30.728]                       return(sendCondition)
[13:22:30.728]                     ns <- getNamespace("parallel")
[13:22:30.728]                     if (exists("sendData", mode = "function", 
[13:22:30.728]                       envir = ns)) {
[13:22:30.728]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:30.728]                         envir = ns)
[13:22:30.728]                       envir <- sys.frame(frame)
[13:22:30.728]                       master <- NULL
[13:22:30.728]                       while (!identical(envir, .GlobalEnv) && 
[13:22:30.728]                         !identical(envir, emptyenv())) {
[13:22:30.728]                         if (exists("master", mode = "list", envir = envir, 
[13:22:30.728]                           inherits = FALSE)) {
[13:22:30.728]                           master <- get("master", mode = "list", 
[13:22:30.728]                             envir = envir, inherits = FALSE)
[13:22:30.728]                           if (inherits(master, c("SOCKnode", 
[13:22:30.728]                             "SOCK0node"))) {
[13:22:30.728]                             sendCondition <<- function(cond) {
[13:22:30.728]                               data <- list(type = "VALUE", value = cond, 
[13:22:30.728]                                 success = TRUE)
[13:22:30.728]                               parallel_sendData(master, data)
[13:22:30.728]                             }
[13:22:30.728]                             return(sendCondition)
[13:22:30.728]                           }
[13:22:30.728]                         }
[13:22:30.728]                         frame <- frame + 1L
[13:22:30.728]                         envir <- sys.frame(frame)
[13:22:30.728]                       }
[13:22:30.728]                     }
[13:22:30.728]                     sendCondition <<- function(cond) NULL
[13:22:30.728]                   }
[13:22:30.728]                 })
[13:22:30.728]                 withCallingHandlers({
[13:22:30.728]                   print(42)
[13:22:30.728]                 }, immediateCondition = function(cond) {
[13:22:30.728]                   sendCondition <- ...future.makeSendCondition()
[13:22:30.728]                   sendCondition(cond)
[13:22:30.728]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:30.728]                   {
[13:22:30.728]                     inherits <- base::inherits
[13:22:30.728]                     invokeRestart <- base::invokeRestart
[13:22:30.728]                     is.null <- base::is.null
[13:22:30.728]                     muffled <- FALSE
[13:22:30.728]                     if (inherits(cond, "message")) {
[13:22:30.728]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:30.728]                       if (muffled) 
[13:22:30.728]                         invokeRestart("muffleMessage")
[13:22:30.728]                     }
[13:22:30.728]                     else if (inherits(cond, "warning")) {
[13:22:30.728]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:30.728]                       if (muffled) 
[13:22:30.728]                         invokeRestart("muffleWarning")
[13:22:30.728]                     }
[13:22:30.728]                     else if (inherits(cond, "condition")) {
[13:22:30.728]                       if (!is.null(pattern)) {
[13:22:30.728]                         computeRestarts <- base::computeRestarts
[13:22:30.728]                         grepl <- base::grepl
[13:22:30.728]                         restarts <- computeRestarts(cond)
[13:22:30.728]                         for (restart in restarts) {
[13:22:30.728]                           name <- restart$name
[13:22:30.728]                           if (is.null(name)) 
[13:22:30.728]                             next
[13:22:30.728]                           if (!grepl(pattern, name)) 
[13:22:30.728]                             next
[13:22:30.728]                           invokeRestart(restart)
[13:22:30.728]                           muffled <- TRUE
[13:22:30.728]                           break
[13:22:30.728]                         }
[13:22:30.728]                       }
[13:22:30.728]                     }
[13:22:30.728]                     invisible(muffled)
[13:22:30.728]                   }
[13:22:30.728]                   muffleCondition(cond)
[13:22:30.728]                 })
[13:22:30.728]             }))
[13:22:30.728]             future::FutureResult(value = ...future.value$value, 
[13:22:30.728]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:30.728]                   ...future.rng), globalenv = if (FALSE) 
[13:22:30.728]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:30.728]                     ...future.globalenv.names))
[13:22:30.728]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:30.728]         }, condition = base::local({
[13:22:30.728]             c <- base::c
[13:22:30.728]             inherits <- base::inherits
[13:22:30.728]             invokeRestart <- base::invokeRestart
[13:22:30.728]             length <- base::length
[13:22:30.728]             list <- base::list
[13:22:30.728]             seq.int <- base::seq.int
[13:22:30.728]             signalCondition <- base::signalCondition
[13:22:30.728]             sys.calls <- base::sys.calls
[13:22:30.728]             `[[` <- base::`[[`
[13:22:30.728]             `+` <- base::`+`
[13:22:30.728]             `<<-` <- base::`<<-`
[13:22:30.728]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:30.728]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:30.728]                   3L)]
[13:22:30.728]             }
[13:22:30.728]             function(cond) {
[13:22:30.728]                 is_error <- inherits(cond, "error")
[13:22:30.728]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:30.728]                   NULL)
[13:22:30.728]                 if (is_error) {
[13:22:30.728]                   sessionInformation <- function() {
[13:22:30.728]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:30.728]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:30.728]                       search = base::search(), system = base::Sys.info())
[13:22:30.728]                   }
[13:22:30.728]                   ...future.conditions[[length(...future.conditions) + 
[13:22:30.728]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:30.728]                     cond$call), session = sessionInformation(), 
[13:22:30.728]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:30.728]                   signalCondition(cond)
[13:22:30.728]                 }
[13:22:30.728]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:30.728]                 "immediateCondition"))) {
[13:22:30.728]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:30.728]                   ...future.conditions[[length(...future.conditions) + 
[13:22:30.728]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:30.728]                   if (TRUE && !signal) {
[13:22:30.728]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:30.728]                     {
[13:22:30.728]                       inherits <- base::inherits
[13:22:30.728]                       invokeRestart <- base::invokeRestart
[13:22:30.728]                       is.null <- base::is.null
[13:22:30.728]                       muffled <- FALSE
[13:22:30.728]                       if (inherits(cond, "message")) {
[13:22:30.728]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:30.728]                         if (muffled) 
[13:22:30.728]                           invokeRestart("muffleMessage")
[13:22:30.728]                       }
[13:22:30.728]                       else if (inherits(cond, "warning")) {
[13:22:30.728]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:30.728]                         if (muffled) 
[13:22:30.728]                           invokeRestart("muffleWarning")
[13:22:30.728]                       }
[13:22:30.728]                       else if (inherits(cond, "condition")) {
[13:22:30.728]                         if (!is.null(pattern)) {
[13:22:30.728]                           computeRestarts <- base::computeRestarts
[13:22:30.728]                           grepl <- base::grepl
[13:22:30.728]                           restarts <- computeRestarts(cond)
[13:22:30.728]                           for (restart in restarts) {
[13:22:30.728]                             name <- restart$name
[13:22:30.728]                             if (is.null(name)) 
[13:22:30.728]                               next
[13:22:30.728]                             if (!grepl(pattern, name)) 
[13:22:30.728]                               next
[13:22:30.728]                             invokeRestart(restart)
[13:22:30.728]                             muffled <- TRUE
[13:22:30.728]                             break
[13:22:30.728]                           }
[13:22:30.728]                         }
[13:22:30.728]                       }
[13:22:30.728]                       invisible(muffled)
[13:22:30.728]                     }
[13:22:30.728]                     muffleCondition(cond, pattern = "^muffle")
[13:22:30.728]                   }
[13:22:30.728]                 }
[13:22:30.728]                 else {
[13:22:30.728]                   if (TRUE) {
[13:22:30.728]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:30.728]                     {
[13:22:30.728]                       inherits <- base::inherits
[13:22:30.728]                       invokeRestart <- base::invokeRestart
[13:22:30.728]                       is.null <- base::is.null
[13:22:30.728]                       muffled <- FALSE
[13:22:30.728]                       if (inherits(cond, "message")) {
[13:22:30.728]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:30.728]                         if (muffled) 
[13:22:30.728]                           invokeRestart("muffleMessage")
[13:22:30.728]                       }
[13:22:30.728]                       else if (inherits(cond, "warning")) {
[13:22:30.728]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:30.728]                         if (muffled) 
[13:22:30.728]                           invokeRestart("muffleWarning")
[13:22:30.728]                       }
[13:22:30.728]                       else if (inherits(cond, "condition")) {
[13:22:30.728]                         if (!is.null(pattern)) {
[13:22:30.728]                           computeRestarts <- base::computeRestarts
[13:22:30.728]                           grepl <- base::grepl
[13:22:30.728]                           restarts <- computeRestarts(cond)
[13:22:30.728]                           for (restart in restarts) {
[13:22:30.728]                             name <- restart$name
[13:22:30.728]                             if (is.null(name)) 
[13:22:30.728]                               next
[13:22:30.728]                             if (!grepl(pattern, name)) 
[13:22:30.728]                               next
[13:22:30.728]                             invokeRestart(restart)
[13:22:30.728]                             muffled <- TRUE
[13:22:30.728]                             break
[13:22:30.728]                           }
[13:22:30.728]                         }
[13:22:30.728]                       }
[13:22:30.728]                       invisible(muffled)
[13:22:30.728]                     }
[13:22:30.728]                     muffleCondition(cond, pattern = "^muffle")
[13:22:30.728]                   }
[13:22:30.728]                 }
[13:22:30.728]             }
[13:22:30.728]         }))
[13:22:30.728]     }, error = function(ex) {
[13:22:30.728]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:30.728]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:30.728]                 ...future.rng), started = ...future.startTime, 
[13:22:30.728]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:30.728]             version = "1.8"), class = "FutureResult")
[13:22:30.728]     }, finally = {
[13:22:30.728]         if (!identical(...future.workdir, getwd())) 
[13:22:30.728]             setwd(...future.workdir)
[13:22:30.728]         {
[13:22:30.728]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:30.728]                 ...future.oldOptions$nwarnings <- NULL
[13:22:30.728]             }
[13:22:30.728]             base::options(...future.oldOptions)
[13:22:30.728]             if (.Platform$OS.type == "windows") {
[13:22:30.728]                 old_names <- names(...future.oldEnvVars)
[13:22:30.728]                 envs <- base::Sys.getenv()
[13:22:30.728]                 names <- names(envs)
[13:22:30.728]                 common <- intersect(names, old_names)
[13:22:30.728]                 added <- setdiff(names, old_names)
[13:22:30.728]                 removed <- setdiff(old_names, names)
[13:22:30.728]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:30.728]                   envs[common]]
[13:22:30.728]                 NAMES <- toupper(changed)
[13:22:30.728]                 args <- list()
[13:22:30.728]                 for (kk in seq_along(NAMES)) {
[13:22:30.728]                   name <- changed[[kk]]
[13:22:30.728]                   NAME <- NAMES[[kk]]
[13:22:30.728]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:30.728]                     next
[13:22:30.728]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:30.728]                 }
[13:22:30.728]                 NAMES <- toupper(added)
[13:22:30.728]                 for (kk in seq_along(NAMES)) {
[13:22:30.728]                   name <- added[[kk]]
[13:22:30.728]                   NAME <- NAMES[[kk]]
[13:22:30.728]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:30.728]                     next
[13:22:30.728]                   args[[name]] <- ""
[13:22:30.728]                 }
[13:22:30.728]                 NAMES <- toupper(removed)
[13:22:30.728]                 for (kk in seq_along(NAMES)) {
[13:22:30.728]                   name <- removed[[kk]]
[13:22:30.728]                   NAME <- NAMES[[kk]]
[13:22:30.728]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:30.728]                     next
[13:22:30.728]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:30.728]                 }
[13:22:30.728]                 if (length(args) > 0) 
[13:22:30.728]                   base::do.call(base::Sys.setenv, args = args)
[13:22:30.728]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:30.728]             }
[13:22:30.728]             else {
[13:22:30.728]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:30.728]             }
[13:22:30.728]             {
[13:22:30.728]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:30.728]                   0L) {
[13:22:30.728]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:30.728]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:30.728]                   base::options(opts)
[13:22:30.728]                 }
[13:22:30.728]                 {
[13:22:30.728]                   {
[13:22:30.728]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:30.728]                     NULL
[13:22:30.728]                   }
[13:22:30.728]                   options(future.plan = NULL)
[13:22:30.728]                   if (is.na(NA_character_)) 
[13:22:30.728]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:30.728]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:30.728]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:30.728]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:30.728]                     envir = parent.frame()) 
[13:22:30.728]                   {
[13:22:30.728]                     if (is.function(workers)) 
[13:22:30.728]                       workers <- workers()
[13:22:30.728]                     workers <- structure(as.integer(workers), 
[13:22:30.728]                       class = class(workers))
[13:22:30.728]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:30.728]                       workers >= 1)
[13:22:30.728]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:30.728]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:30.728]                     }
[13:22:30.728]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:30.728]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:30.728]                       envir = envir)
[13:22:30.728]                     if (!future$lazy) 
[13:22:30.728]                       future <- run(future)
[13:22:30.728]                     invisible(future)
[13:22:30.728]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:30.728]                 }
[13:22:30.728]             }
[13:22:30.728]         }
[13:22:30.728]     })
[13:22:30.728]     if (TRUE) {
[13:22:30.728]         base::sink(type = "output", split = FALSE)
[13:22:30.728]         if (TRUE) {
[13:22:30.728]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:30.728]         }
[13:22:30.728]         else {
[13:22:30.728]             ...future.result["stdout"] <- base::list(NULL)
[13:22:30.728]         }
[13:22:30.728]         base::close(...future.stdout)
[13:22:30.728]         ...future.stdout <- NULL
[13:22:30.728]     }
[13:22:30.728]     ...future.result$conditions <- ...future.conditions
[13:22:30.728]     ...future.result$finished <- base::Sys.time()
[13:22:30.728]     ...future.result
[13:22:30.728] }
[13:22:30.731] MultisessionFuture started
[13:22:30.731] - Launch lazy future ... done
[13:22:30.732] run() for ‘MultisessionFuture’ ... done
[13:22:30.732] result() for ClusterFuture ...
[13:22:30.732] receiveMessageFromWorker() for ClusterFuture ...
[13:22:30.732] - Validating connection of MultisessionFuture
[13:22:30.779] - received message: FutureResult
[13:22:30.779] - Received FutureResult
[13:22:30.779] - Erased future from FutureRegistry
[13:22:30.779] result() for ClusterFuture ...
[13:22:30.780] - result already collected: FutureResult
[13:22:30.780] result() for ClusterFuture ... done
[13:22:30.780] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:30.780] result() for ClusterFuture ... done
[13:22:30.780] result() for ClusterFuture ...
[13:22:30.780] - result already collected: FutureResult
[13:22:30.780] result() for ClusterFuture ... done
[13:22:30.781] result() for ClusterFuture ...
[13:22:30.781] - result already collected: FutureResult
[13:22:30.781] result() for ClusterFuture ... done
[1] 42
[13:22:30.781] result() for ClusterFuture ...
[13:22:30.781] - result already collected: FutureResult
[13:22:30.781] result() for ClusterFuture ... done
- stdout = NA
[13:22:30.781] getGlobalsAndPackages() ...
[13:22:30.782] Searching for globals...
[13:22:30.785] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[13:22:30.785] Searching for globals ... DONE
[13:22:30.786] Resolving globals: FALSE
[13:22:30.786] 
[13:22:30.786] - packages: [1] ‘utils’
[13:22:30.786] getGlobalsAndPackages() ... DONE
[13:22:30.787] run() for ‘Future’ ...
[13:22:30.787] - state: ‘created’
[13:22:30.787] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:30.804] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:30.804] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:30.804]   - Field: ‘node’
[13:22:30.804]   - Field: ‘label’
[13:22:30.804]   - Field: ‘local’
[13:22:30.805]   - Field: ‘owner’
[13:22:30.805]   - Field: ‘envir’
[13:22:30.805]   - Field: ‘workers’
[13:22:30.805]   - Field: ‘packages’
[13:22:30.808]   - Field: ‘gc’
[13:22:30.808]   - Field: ‘conditions’
[13:22:30.808]   - Field: ‘persistent’
[13:22:30.808]   - Field: ‘expr’
[13:22:30.808]   - Field: ‘uuid’
[13:22:30.808]   - Field: ‘seed’
[13:22:30.808]   - Field: ‘version’
[13:22:30.808]   - Field: ‘result’
[13:22:30.809]   - Field: ‘asynchronous’
[13:22:30.809]   - Field: ‘calls’
[13:22:30.809]   - Field: ‘globals’
[13:22:30.809]   - Field: ‘stdout’
[13:22:30.809]   - Field: ‘earlySignal’
[13:22:30.809]   - Field: ‘lazy’
[13:22:30.809]   - Field: ‘state’
[13:22:30.809] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:30.809] - Launch lazy future ...
[13:22:30.810] Packages needed by the future expression (n = 1): ‘utils’
[13:22:30.810] Packages needed by future strategies (n = 0): <none>
[13:22:30.811] {
[13:22:30.811]     {
[13:22:30.811]         {
[13:22:30.811]             ...future.startTime <- base::Sys.time()
[13:22:30.811]             {
[13:22:30.811]                 {
[13:22:30.811]                   {
[13:22:30.811]                     {
[13:22:30.811]                       {
[13:22:30.811]                         base::local({
[13:22:30.811]                           has_future <- base::requireNamespace("future", 
[13:22:30.811]                             quietly = TRUE)
[13:22:30.811]                           if (has_future) {
[13:22:30.811]                             ns <- base::getNamespace("future")
[13:22:30.811]                             version <- ns[[".package"]][["version"]]
[13:22:30.811]                             if (is.null(version)) 
[13:22:30.811]                               version <- utils::packageVersion("future")
[13:22:30.811]                           }
[13:22:30.811]                           else {
[13:22:30.811]                             version <- NULL
[13:22:30.811]                           }
[13:22:30.811]                           if (!has_future || version < "1.8.0") {
[13:22:30.811]                             info <- base::c(r_version = base::gsub("R version ", 
[13:22:30.811]                               "", base::R.version$version.string), 
[13:22:30.811]                               platform = base::sprintf("%s (%s-bit)", 
[13:22:30.811]                                 base::R.version$platform, 8 * 
[13:22:30.811]                                   base::.Machine$sizeof.pointer), 
[13:22:30.811]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:30.811]                                 "release", "version")], collapse = " "), 
[13:22:30.811]                               hostname = base::Sys.info()[["nodename"]])
[13:22:30.811]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:22:30.811]                               info)
[13:22:30.811]                             info <- base::paste(info, collapse = "; ")
[13:22:30.811]                             if (!has_future) {
[13:22:30.811]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:30.811]                                 info)
[13:22:30.811]                             }
[13:22:30.811]                             else {
[13:22:30.811]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:30.811]                                 info, version)
[13:22:30.811]                             }
[13:22:30.811]                             base::stop(msg)
[13:22:30.811]                           }
[13:22:30.811]                         })
[13:22:30.811]                       }
[13:22:30.811]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:30.811]                       base::options(mc.cores = 1L)
[13:22:30.811]                     }
[13:22:30.811]                     base::local({
[13:22:30.811]                       for (pkg in "utils") {
[13:22:30.811]                         base::loadNamespace(pkg)
[13:22:30.811]                         base::library(pkg, character.only = TRUE)
[13:22:30.811]                       }
[13:22:30.811]                     })
[13:22:30.811]                   }
[13:22:30.811]                   options(future.plan = NULL)
[13:22:30.811]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:30.811]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:30.811]                 }
[13:22:30.811]                 ...future.workdir <- getwd()
[13:22:30.811]             }
[13:22:30.811]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:30.811]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:30.811]         }
[13:22:30.811]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:30.811]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:30.811]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:30.811]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:30.811]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:30.811]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:30.811]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:30.811]             base::names(...future.oldOptions))
[13:22:30.811]     }
[13:22:30.811]     if (TRUE) {
[13:22:30.811]     }
[13:22:30.811]     else {
[13:22:30.811]         if (NA) {
[13:22:30.811]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:30.811]                 open = "w")
[13:22:30.811]         }
[13:22:30.811]         else {
[13:22:30.811]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:30.811]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:30.811]         }
[13:22:30.811]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:30.811]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:30.811]             base::sink(type = "output", split = FALSE)
[13:22:30.811]             base::close(...future.stdout)
[13:22:30.811]         }, add = TRUE)
[13:22:30.811]     }
[13:22:30.811]     ...future.frame <- base::sys.nframe()
[13:22:30.811]     ...future.conditions <- base::list()
[13:22:30.811]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:30.811]     if (FALSE) {
[13:22:30.811]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:30.811]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:30.811]     }
[13:22:30.811]     ...future.result <- base::tryCatch({
[13:22:30.811]         base::withCallingHandlers({
[13:22:30.811]             ...future.value <- base::withVisible(base::local({
[13:22:30.811]                 ...future.makeSendCondition <- local({
[13:22:30.811]                   sendCondition <- NULL
[13:22:30.811]                   function(frame = 1L) {
[13:22:30.811]                     if (is.function(sendCondition)) 
[13:22:30.811]                       return(sendCondition)
[13:22:30.811]                     ns <- getNamespace("parallel")
[13:22:30.811]                     if (exists("sendData", mode = "function", 
[13:22:30.811]                       envir = ns)) {
[13:22:30.811]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:30.811]                         envir = ns)
[13:22:30.811]                       envir <- sys.frame(frame)
[13:22:30.811]                       master <- NULL
[13:22:30.811]                       while (!identical(envir, .GlobalEnv) && 
[13:22:30.811]                         !identical(envir, emptyenv())) {
[13:22:30.811]                         if (exists("master", mode = "list", envir = envir, 
[13:22:30.811]                           inherits = FALSE)) {
[13:22:30.811]                           master <- get("master", mode = "list", 
[13:22:30.811]                             envir = envir, inherits = FALSE)
[13:22:30.811]                           if (inherits(master, c("SOCKnode", 
[13:22:30.811]                             "SOCK0node"))) {
[13:22:30.811]                             sendCondition <<- function(cond) {
[13:22:30.811]                               data <- list(type = "VALUE", value = cond, 
[13:22:30.811]                                 success = TRUE)
[13:22:30.811]                               parallel_sendData(master, data)
[13:22:30.811]                             }
[13:22:30.811]                             return(sendCondition)
[13:22:30.811]                           }
[13:22:30.811]                         }
[13:22:30.811]                         frame <- frame + 1L
[13:22:30.811]                         envir <- sys.frame(frame)
[13:22:30.811]                       }
[13:22:30.811]                     }
[13:22:30.811]                     sendCondition <<- function(cond) NULL
[13:22:30.811]                   }
[13:22:30.811]                 })
[13:22:30.811]                 withCallingHandlers({
[13:22:30.811]                   {
[13:22:30.811]                     print(1:50)
[13:22:30.811]                     str(1:50)
[13:22:30.811]                     cat(letters, sep = "-")
[13:22:30.811]                     cat(1:6, collapse = "\n")
[13:22:30.811]                     write.table(datasets::iris[1:10, ], sep = "\t")
[13:22:30.811]                     42L
[13:22:30.811]                   }
[13:22:30.811]                 }, immediateCondition = function(cond) {
[13:22:30.811]                   sendCondition <- ...future.makeSendCondition()
[13:22:30.811]                   sendCondition(cond)
[13:22:30.811]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:30.811]                   {
[13:22:30.811]                     inherits <- base::inherits
[13:22:30.811]                     invokeRestart <- base::invokeRestart
[13:22:30.811]                     is.null <- base::is.null
[13:22:30.811]                     muffled <- FALSE
[13:22:30.811]                     if (inherits(cond, "message")) {
[13:22:30.811]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:30.811]                       if (muffled) 
[13:22:30.811]                         invokeRestart("muffleMessage")
[13:22:30.811]                     }
[13:22:30.811]                     else if (inherits(cond, "warning")) {
[13:22:30.811]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:30.811]                       if (muffled) 
[13:22:30.811]                         invokeRestart("muffleWarning")
[13:22:30.811]                     }
[13:22:30.811]                     else if (inherits(cond, "condition")) {
[13:22:30.811]                       if (!is.null(pattern)) {
[13:22:30.811]                         computeRestarts <- base::computeRestarts
[13:22:30.811]                         grepl <- base::grepl
[13:22:30.811]                         restarts <- computeRestarts(cond)
[13:22:30.811]                         for (restart in restarts) {
[13:22:30.811]                           name <- restart$name
[13:22:30.811]                           if (is.null(name)) 
[13:22:30.811]                             next
[13:22:30.811]                           if (!grepl(pattern, name)) 
[13:22:30.811]                             next
[13:22:30.811]                           invokeRestart(restart)
[13:22:30.811]                           muffled <- TRUE
[13:22:30.811]                           break
[13:22:30.811]                         }
[13:22:30.811]                       }
[13:22:30.811]                     }
[13:22:30.811]                     invisible(muffled)
[13:22:30.811]                   }
[13:22:30.811]                   muffleCondition(cond)
[13:22:30.811]                 })
[13:22:30.811]             }))
[13:22:30.811]             future::FutureResult(value = ...future.value$value, 
[13:22:30.811]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:30.811]                   ...future.rng), globalenv = if (FALSE) 
[13:22:30.811]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:30.811]                     ...future.globalenv.names))
[13:22:30.811]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:30.811]         }, condition = base::local({
[13:22:30.811]             c <- base::c
[13:22:30.811]             inherits <- base::inherits
[13:22:30.811]             invokeRestart <- base::invokeRestart
[13:22:30.811]             length <- base::length
[13:22:30.811]             list <- base::list
[13:22:30.811]             seq.int <- base::seq.int
[13:22:30.811]             signalCondition <- base::signalCondition
[13:22:30.811]             sys.calls <- base::sys.calls
[13:22:30.811]             `[[` <- base::`[[`
[13:22:30.811]             `+` <- base::`+`
[13:22:30.811]             `<<-` <- base::`<<-`
[13:22:30.811]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:30.811]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:30.811]                   3L)]
[13:22:30.811]             }
[13:22:30.811]             function(cond) {
[13:22:30.811]                 is_error <- inherits(cond, "error")
[13:22:30.811]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:30.811]                   NULL)
[13:22:30.811]                 if (is_error) {
[13:22:30.811]                   sessionInformation <- function() {
[13:22:30.811]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:30.811]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:30.811]                       search = base::search(), system = base::Sys.info())
[13:22:30.811]                   }
[13:22:30.811]                   ...future.conditions[[length(...future.conditions) + 
[13:22:30.811]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:30.811]                     cond$call), session = sessionInformation(), 
[13:22:30.811]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:30.811]                   signalCondition(cond)
[13:22:30.811]                 }
[13:22:30.811]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:30.811]                 "immediateCondition"))) {
[13:22:30.811]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:30.811]                   ...future.conditions[[length(...future.conditions) + 
[13:22:30.811]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:30.811]                   if (TRUE && !signal) {
[13:22:30.811]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:30.811]                     {
[13:22:30.811]                       inherits <- base::inherits
[13:22:30.811]                       invokeRestart <- base::invokeRestart
[13:22:30.811]                       is.null <- base::is.null
[13:22:30.811]                       muffled <- FALSE
[13:22:30.811]                       if (inherits(cond, "message")) {
[13:22:30.811]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:30.811]                         if (muffled) 
[13:22:30.811]                           invokeRestart("muffleMessage")
[13:22:30.811]                       }
[13:22:30.811]                       else if (inherits(cond, "warning")) {
[13:22:30.811]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:30.811]                         if (muffled) 
[13:22:30.811]                           invokeRestart("muffleWarning")
[13:22:30.811]                       }
[13:22:30.811]                       else if (inherits(cond, "condition")) {
[13:22:30.811]                         if (!is.null(pattern)) {
[13:22:30.811]                           computeRestarts <- base::computeRestarts
[13:22:30.811]                           grepl <- base::grepl
[13:22:30.811]                           restarts <- computeRestarts(cond)
[13:22:30.811]                           for (restart in restarts) {
[13:22:30.811]                             name <- restart$name
[13:22:30.811]                             if (is.null(name)) 
[13:22:30.811]                               next
[13:22:30.811]                             if (!grepl(pattern, name)) 
[13:22:30.811]                               next
[13:22:30.811]                             invokeRestart(restart)
[13:22:30.811]                             muffled <- TRUE
[13:22:30.811]                             break
[13:22:30.811]                           }
[13:22:30.811]                         }
[13:22:30.811]                       }
[13:22:30.811]                       invisible(muffled)
[13:22:30.811]                     }
[13:22:30.811]                     muffleCondition(cond, pattern = "^muffle")
[13:22:30.811]                   }
[13:22:30.811]                 }
[13:22:30.811]                 else {
[13:22:30.811]                   if (TRUE) {
[13:22:30.811]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:30.811]                     {
[13:22:30.811]                       inherits <- base::inherits
[13:22:30.811]                       invokeRestart <- base::invokeRestart
[13:22:30.811]                       is.null <- base::is.null
[13:22:30.811]                       muffled <- FALSE
[13:22:30.811]                       if (inherits(cond, "message")) {
[13:22:30.811]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:30.811]                         if (muffled) 
[13:22:30.811]                           invokeRestart("muffleMessage")
[13:22:30.811]                       }
[13:22:30.811]                       else if (inherits(cond, "warning")) {
[13:22:30.811]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:30.811]                         if (muffled) 
[13:22:30.811]                           invokeRestart("muffleWarning")
[13:22:30.811]                       }
[13:22:30.811]                       else if (inherits(cond, "condition")) {
[13:22:30.811]                         if (!is.null(pattern)) {
[13:22:30.811]                           computeRestarts <- base::computeRestarts
[13:22:30.811]                           grepl <- base::grepl
[13:22:30.811]                           restarts <- computeRestarts(cond)
[13:22:30.811]                           for (restart in restarts) {
[13:22:30.811]                             name <- restart$name
[13:22:30.811]                             if (is.null(name)) 
[13:22:30.811]                               next
[13:22:30.811]                             if (!grepl(pattern, name)) 
[13:22:30.811]                               next
[13:22:30.811]                             invokeRestart(restart)
[13:22:30.811]                             muffled <- TRUE
[13:22:30.811]                             break
[13:22:30.811]                           }
[13:22:30.811]                         }
[13:22:30.811]                       }
[13:22:30.811]                       invisible(muffled)
[13:22:30.811]                     }
[13:22:30.811]                     muffleCondition(cond, pattern = "^muffle")
[13:22:30.811]                   }
[13:22:30.811]                 }
[13:22:30.811]             }
[13:22:30.811]         }))
[13:22:30.811]     }, error = function(ex) {
[13:22:30.811]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:30.811]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:30.811]                 ...future.rng), started = ...future.startTime, 
[13:22:30.811]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:30.811]             version = "1.8"), class = "FutureResult")
[13:22:30.811]     }, finally = {
[13:22:30.811]         if (!identical(...future.workdir, getwd())) 
[13:22:30.811]             setwd(...future.workdir)
[13:22:30.811]         {
[13:22:30.811]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:30.811]                 ...future.oldOptions$nwarnings <- NULL
[13:22:30.811]             }
[13:22:30.811]             base::options(...future.oldOptions)
[13:22:30.811]             if (.Platform$OS.type == "windows") {
[13:22:30.811]                 old_names <- names(...future.oldEnvVars)
[13:22:30.811]                 envs <- base::Sys.getenv()
[13:22:30.811]                 names <- names(envs)
[13:22:30.811]                 common <- intersect(names, old_names)
[13:22:30.811]                 added <- setdiff(names, old_names)
[13:22:30.811]                 removed <- setdiff(old_names, names)
[13:22:30.811]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:30.811]                   envs[common]]
[13:22:30.811]                 NAMES <- toupper(changed)
[13:22:30.811]                 args <- list()
[13:22:30.811]                 for (kk in seq_along(NAMES)) {
[13:22:30.811]                   name <- changed[[kk]]
[13:22:30.811]                   NAME <- NAMES[[kk]]
[13:22:30.811]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:30.811]                     next
[13:22:30.811]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:30.811]                 }
[13:22:30.811]                 NAMES <- toupper(added)
[13:22:30.811]                 for (kk in seq_along(NAMES)) {
[13:22:30.811]                   name <- added[[kk]]
[13:22:30.811]                   NAME <- NAMES[[kk]]
[13:22:30.811]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:30.811]                     next
[13:22:30.811]                   args[[name]] <- ""
[13:22:30.811]                 }
[13:22:30.811]                 NAMES <- toupper(removed)
[13:22:30.811]                 for (kk in seq_along(NAMES)) {
[13:22:30.811]                   name <- removed[[kk]]
[13:22:30.811]                   NAME <- NAMES[[kk]]
[13:22:30.811]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:30.811]                     next
[13:22:30.811]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:30.811]                 }
[13:22:30.811]                 if (length(args) > 0) 
[13:22:30.811]                   base::do.call(base::Sys.setenv, args = args)
[13:22:30.811]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:30.811]             }
[13:22:30.811]             else {
[13:22:30.811]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:30.811]             }
[13:22:30.811]             {
[13:22:30.811]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:30.811]                   0L) {
[13:22:30.811]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:30.811]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:30.811]                   base::options(opts)
[13:22:30.811]                 }
[13:22:30.811]                 {
[13:22:30.811]                   {
[13:22:30.811]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:30.811]                     NULL
[13:22:30.811]                   }
[13:22:30.811]                   options(future.plan = NULL)
[13:22:30.811]                   if (is.na(NA_character_)) 
[13:22:30.811]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:30.811]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:30.811]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:30.811]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:30.811]                     envir = parent.frame()) 
[13:22:30.811]                   {
[13:22:30.811]                     if (is.function(workers)) 
[13:22:30.811]                       workers <- workers()
[13:22:30.811]                     workers <- structure(as.integer(workers), 
[13:22:30.811]                       class = class(workers))
[13:22:30.811]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:30.811]                       workers >= 1)
[13:22:30.811]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:30.811]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:30.811]                     }
[13:22:30.811]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:30.811]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:30.811]                       envir = envir)
[13:22:30.811]                     if (!future$lazy) 
[13:22:30.811]                       future <- run(future)
[13:22:30.811]                     invisible(future)
[13:22:30.811]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:30.811]                 }
[13:22:30.811]             }
[13:22:30.811]         }
[13:22:30.811]     })
[13:22:30.811]     if (FALSE) {
[13:22:30.811]         base::sink(type = "output", split = FALSE)
[13:22:30.811]         if (NA) {
[13:22:30.811]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:30.811]         }
[13:22:30.811]         else {
[13:22:30.811]             ...future.result["stdout"] <- base::list(NULL)
[13:22:30.811]         }
[13:22:30.811]         base::close(...future.stdout)
[13:22:30.811]         ...future.stdout <- NULL
[13:22:30.811]     }
[13:22:30.811]     ...future.result$conditions <- ...future.conditions
[13:22:30.811]     ...future.result$finished <- base::Sys.time()
[13:22:30.811]     ...future.result
[13:22:30.811] }
[13:22:30.814] MultisessionFuture started
[13:22:30.815] - Launch lazy future ... done
[13:22:30.815] run() for ‘MultisessionFuture’ ... done
[13:22:30.815] result() for ClusterFuture ...
[13:22:30.815] receiveMessageFromWorker() for ClusterFuture ...
[13:22:30.815] - Validating connection of MultisessionFuture
[13:22:30.863] - received message: FutureResult
[13:22:30.863] - Received FutureResult
[13:22:30.863] - Erased future from FutureRegistry
[13:22:30.863] result() for ClusterFuture ...
[13:22:30.863] - result already collected: FutureResult
[13:22:30.863] result() for ClusterFuture ... done
[13:22:30.864] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:30.864] result() for ClusterFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-01-07 13:22:30"
 $ finished    : POSIXct[1:1], format: "2025-01-07 13:22:30"
 $ session_uuid: chr "256798a4-5c30-7eef-db48-d08f6d787740"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "5853cd8d1af0"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "5853cd8d1af0" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 93526
  .. ..$ time  : POSIXct[1:1], format: "2025-01-07 13:22:30"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 3 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[13:22:30.871] result() for ClusterFuture ...
[13:22:30.871] - result already collected: FutureResult
[13:22:30.872] result() for ClusterFuture ... done
[13:22:30.872] result() for ClusterFuture ...
[13:22:30.872] - result already collected: FutureResult
[13:22:30.872] result() for ClusterFuture ... done
[13:22:30.872] getGlobalsAndPackages() ...
[13:22:30.872] Searching for globals...
[13:22:30.875] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[13:22:30.875] Searching for globals ... DONE
[13:22:30.875] Resolving globals: FALSE
[13:22:30.876] 
[13:22:30.876] - packages: [1] ‘utils’
[13:22:30.876] getGlobalsAndPackages() ... DONE
[13:22:30.876] run() for ‘Future’ ...
[13:22:30.877] - state: ‘created’
[13:22:30.877] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:30.892] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:30.893] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:30.893]   - Field: ‘node’
[13:22:30.893]   - Field: ‘label’
[13:22:30.893]   - Field: ‘local’
[13:22:30.893]   - Field: ‘owner’
[13:22:30.893]   - Field: ‘envir’
[13:22:30.893]   - Field: ‘workers’
[13:22:30.893]   - Field: ‘packages’
[13:22:30.894]   - Field: ‘gc’
[13:22:30.894]   - Field: ‘conditions’
[13:22:30.894]   - Field: ‘persistent’
[13:22:30.894]   - Field: ‘expr’
[13:22:30.894]   - Field: ‘uuid’
[13:22:30.894]   - Field: ‘seed’
[13:22:30.894]   - Field: ‘version’
[13:22:30.894]   - Field: ‘result’
[13:22:30.894]   - Field: ‘asynchronous’
[13:22:30.894]   - Field: ‘calls’
[13:22:30.894]   - Field: ‘globals’
[13:22:30.895]   - Field: ‘stdout’
[13:22:30.895]   - Field: ‘earlySignal’
[13:22:30.895]   - Field: ‘lazy’
[13:22:30.895]   - Field: ‘state’
[13:22:30.895] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:30.895] - Launch lazy future ...
[13:22:30.895] Packages needed by the future expression (n = 1): ‘utils’
[13:22:30.895] Packages needed by future strategies (n = 0): <none>
[13:22:30.896] {
[13:22:30.896]     {
[13:22:30.896]         {
[13:22:30.896]             ...future.startTime <- base::Sys.time()
[13:22:30.896]             {
[13:22:30.896]                 {
[13:22:30.896]                   {
[13:22:30.896]                     {
[13:22:30.896]                       {
[13:22:30.896]                         base::local({
[13:22:30.896]                           has_future <- base::requireNamespace("future", 
[13:22:30.896]                             quietly = TRUE)
[13:22:30.896]                           if (has_future) {
[13:22:30.896]                             ns <- base::getNamespace("future")
[13:22:30.896]                             version <- ns[[".package"]][["version"]]
[13:22:30.896]                             if (is.null(version)) 
[13:22:30.896]                               version <- utils::packageVersion("future")
[13:22:30.896]                           }
[13:22:30.896]                           else {
[13:22:30.896]                             version <- NULL
[13:22:30.896]                           }
[13:22:30.896]                           if (!has_future || version < "1.8.0") {
[13:22:30.896]                             info <- base::c(r_version = base::gsub("R version ", 
[13:22:30.896]                               "", base::R.version$version.string), 
[13:22:30.896]                               platform = base::sprintf("%s (%s-bit)", 
[13:22:30.896]                                 base::R.version$platform, 8 * 
[13:22:30.896]                                   base::.Machine$sizeof.pointer), 
[13:22:30.896]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:30.896]                                 "release", "version")], collapse = " "), 
[13:22:30.896]                               hostname = base::Sys.info()[["nodename"]])
[13:22:30.896]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:22:30.896]                               info)
[13:22:30.896]                             info <- base::paste(info, collapse = "; ")
[13:22:30.896]                             if (!has_future) {
[13:22:30.896]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:30.896]                                 info)
[13:22:30.896]                             }
[13:22:30.896]                             else {
[13:22:30.896]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:30.896]                                 info, version)
[13:22:30.896]                             }
[13:22:30.896]                             base::stop(msg)
[13:22:30.896]                           }
[13:22:30.896]                         })
[13:22:30.896]                       }
[13:22:30.896]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:30.896]                       base::options(mc.cores = 1L)
[13:22:30.896]                     }
[13:22:30.896]                     base::local({
[13:22:30.896]                       for (pkg in "utils") {
[13:22:30.896]                         base::loadNamespace(pkg)
[13:22:30.896]                         base::library(pkg, character.only = TRUE)
[13:22:30.896]                       }
[13:22:30.896]                     })
[13:22:30.896]                   }
[13:22:30.896]                   options(future.plan = NULL)
[13:22:30.896]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:30.896]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:30.896]                 }
[13:22:30.896]                 ...future.workdir <- getwd()
[13:22:30.896]             }
[13:22:30.896]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:30.896]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:30.896]         }
[13:22:30.896]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:30.896]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:30.896]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:30.896]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:30.896]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:30.896]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:30.896]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:30.896]             base::names(...future.oldOptions))
[13:22:30.896]     }
[13:22:30.896]     if (TRUE) {
[13:22:30.896]     }
[13:22:30.896]     else {
[13:22:30.896]         if (NA) {
[13:22:30.896]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:30.896]                 open = "w")
[13:22:30.896]         }
[13:22:30.896]         else {
[13:22:30.896]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:30.896]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:30.896]         }
[13:22:30.896]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:30.896]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:30.896]             base::sink(type = "output", split = FALSE)
[13:22:30.896]             base::close(...future.stdout)
[13:22:30.896]         }, add = TRUE)
[13:22:30.896]     }
[13:22:30.896]     ...future.frame <- base::sys.nframe()
[13:22:30.896]     ...future.conditions <- base::list()
[13:22:30.896]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:30.896]     if (FALSE) {
[13:22:30.896]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:30.896]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:30.896]     }
[13:22:30.896]     ...future.result <- base::tryCatch({
[13:22:30.896]         base::withCallingHandlers({
[13:22:30.896]             ...future.value <- base::withVisible(base::local({
[13:22:30.896]                 ...future.makeSendCondition <- local({
[13:22:30.896]                   sendCondition <- NULL
[13:22:30.896]                   function(frame = 1L) {
[13:22:30.896]                     if (is.function(sendCondition)) 
[13:22:30.896]                       return(sendCondition)
[13:22:30.896]                     ns <- getNamespace("parallel")
[13:22:30.896]                     if (exists("sendData", mode = "function", 
[13:22:30.896]                       envir = ns)) {
[13:22:30.896]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:30.896]                         envir = ns)
[13:22:30.896]                       envir <- sys.frame(frame)
[13:22:30.896]                       master <- NULL
[13:22:30.896]                       while (!identical(envir, .GlobalEnv) && 
[13:22:30.896]                         !identical(envir, emptyenv())) {
[13:22:30.896]                         if (exists("master", mode = "list", envir = envir, 
[13:22:30.896]                           inherits = FALSE)) {
[13:22:30.896]                           master <- get("master", mode = "list", 
[13:22:30.896]                             envir = envir, inherits = FALSE)
[13:22:30.896]                           if (inherits(master, c("SOCKnode", 
[13:22:30.896]                             "SOCK0node"))) {
[13:22:30.896]                             sendCondition <<- function(cond) {
[13:22:30.896]                               data <- list(type = "VALUE", value = cond, 
[13:22:30.896]                                 success = TRUE)
[13:22:30.896]                               parallel_sendData(master, data)
[13:22:30.896]                             }
[13:22:30.896]                             return(sendCondition)
[13:22:30.896]                           }
[13:22:30.896]                         }
[13:22:30.896]                         frame <- frame + 1L
[13:22:30.896]                         envir <- sys.frame(frame)
[13:22:30.896]                       }
[13:22:30.896]                     }
[13:22:30.896]                     sendCondition <<- function(cond) NULL
[13:22:30.896]                   }
[13:22:30.896]                 })
[13:22:30.896]                 withCallingHandlers({
[13:22:30.896]                   {
[13:22:30.896]                     print(1:50)
[13:22:30.896]                     str(1:50)
[13:22:30.896]                     cat(letters, sep = "-")
[13:22:30.896]                     cat(1:6, collapse = "\n")
[13:22:30.896]                     write.table(datasets::iris[1:10, ], sep = "\t")
[13:22:30.896]                     42L
[13:22:30.896]                   }
[13:22:30.896]                 }, immediateCondition = function(cond) {
[13:22:30.896]                   sendCondition <- ...future.makeSendCondition()
[13:22:30.896]                   sendCondition(cond)
[13:22:30.896]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:30.896]                   {
[13:22:30.896]                     inherits <- base::inherits
[13:22:30.896]                     invokeRestart <- base::invokeRestart
[13:22:30.896]                     is.null <- base::is.null
[13:22:30.896]                     muffled <- FALSE
[13:22:30.896]                     if (inherits(cond, "message")) {
[13:22:30.896]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:30.896]                       if (muffled) 
[13:22:30.896]                         invokeRestart("muffleMessage")
[13:22:30.896]                     }
[13:22:30.896]                     else if (inherits(cond, "warning")) {
[13:22:30.896]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:30.896]                       if (muffled) 
[13:22:30.896]                         invokeRestart("muffleWarning")
[13:22:30.896]                     }
[13:22:30.896]                     else if (inherits(cond, "condition")) {
[13:22:30.896]                       if (!is.null(pattern)) {
[13:22:30.896]                         computeRestarts <- base::computeRestarts
[13:22:30.896]                         grepl <- base::grepl
[13:22:30.896]                         restarts <- computeRestarts(cond)
[13:22:30.896]                         for (restart in restarts) {
[13:22:30.896]                           name <- restart$name
[13:22:30.896]                           if (is.null(name)) 
[13:22:30.896]                             next
[13:22:30.896]                           if (!grepl(pattern, name)) 
[13:22:30.896]                             next
[13:22:30.896]                           invokeRestart(restart)
[13:22:30.896]                           muffled <- TRUE
[13:22:30.896]                           break
[13:22:30.896]                         }
[13:22:30.896]                       }
[13:22:30.896]                     }
[13:22:30.896]                     invisible(muffled)
[13:22:30.896]                   }
[13:22:30.896]                   muffleCondition(cond)
[13:22:30.896]                 })
[13:22:30.896]             }))
[13:22:30.896]             future::FutureResult(value = ...future.value$value, 
[13:22:30.896]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:30.896]                   ...future.rng), globalenv = if (FALSE) 
[13:22:30.896]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:30.896]                     ...future.globalenv.names))
[13:22:30.896]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:30.896]         }, condition = base::local({
[13:22:30.896]             c <- base::c
[13:22:30.896]             inherits <- base::inherits
[13:22:30.896]             invokeRestart <- base::invokeRestart
[13:22:30.896]             length <- base::length
[13:22:30.896]             list <- base::list
[13:22:30.896]             seq.int <- base::seq.int
[13:22:30.896]             signalCondition <- base::signalCondition
[13:22:30.896]             sys.calls <- base::sys.calls
[13:22:30.896]             `[[` <- base::`[[`
[13:22:30.896]             `+` <- base::`+`
[13:22:30.896]             `<<-` <- base::`<<-`
[13:22:30.896]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:30.896]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:30.896]                   3L)]
[13:22:30.896]             }
[13:22:30.896]             function(cond) {
[13:22:30.896]                 is_error <- inherits(cond, "error")
[13:22:30.896]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:30.896]                   NULL)
[13:22:30.896]                 if (is_error) {
[13:22:30.896]                   sessionInformation <- function() {
[13:22:30.896]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:30.896]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:30.896]                       search = base::search(), system = base::Sys.info())
[13:22:30.896]                   }
[13:22:30.896]                   ...future.conditions[[length(...future.conditions) + 
[13:22:30.896]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:30.896]                     cond$call), session = sessionInformation(), 
[13:22:30.896]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:30.896]                   signalCondition(cond)
[13:22:30.896]                 }
[13:22:30.896]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:30.896]                 "immediateCondition"))) {
[13:22:30.896]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:30.896]                   ...future.conditions[[length(...future.conditions) + 
[13:22:30.896]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:30.896]                   if (TRUE && !signal) {
[13:22:30.896]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:30.896]                     {
[13:22:30.896]                       inherits <- base::inherits
[13:22:30.896]                       invokeRestart <- base::invokeRestart
[13:22:30.896]                       is.null <- base::is.null
[13:22:30.896]                       muffled <- FALSE
[13:22:30.896]                       if (inherits(cond, "message")) {
[13:22:30.896]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:30.896]                         if (muffled) 
[13:22:30.896]                           invokeRestart("muffleMessage")
[13:22:30.896]                       }
[13:22:30.896]                       else if (inherits(cond, "warning")) {
[13:22:30.896]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:30.896]                         if (muffled) 
[13:22:30.896]                           invokeRestart("muffleWarning")
[13:22:30.896]                       }
[13:22:30.896]                       else if (inherits(cond, "condition")) {
[13:22:30.896]                         if (!is.null(pattern)) {
[13:22:30.896]                           computeRestarts <- base::computeRestarts
[13:22:30.896]                           grepl <- base::grepl
[13:22:30.896]                           restarts <- computeRestarts(cond)
[13:22:30.896]                           for (restart in restarts) {
[13:22:30.896]                             name <- restart$name
[13:22:30.896]                             if (is.null(name)) 
[13:22:30.896]                               next
[13:22:30.896]                             if (!grepl(pattern, name)) 
[13:22:30.896]                               next
[13:22:30.896]                             invokeRestart(restart)
[13:22:30.896]                             muffled <- TRUE
[13:22:30.896]                             break
[13:22:30.896]                           }
[13:22:30.896]                         }
[13:22:30.896]                       }
[13:22:30.896]                       invisible(muffled)
[13:22:30.896]                     }
[13:22:30.896]                     muffleCondition(cond, pattern = "^muffle")
[13:22:30.896]                   }
[13:22:30.896]                 }
[13:22:30.896]                 else {
[13:22:30.896]                   if (TRUE) {
[13:22:30.896]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:30.896]                     {
[13:22:30.896]                       inherits <- base::inherits
[13:22:30.896]                       invokeRestart <- base::invokeRestart
[13:22:30.896]                       is.null <- base::is.null
[13:22:30.896]                       muffled <- FALSE
[13:22:30.896]                       if (inherits(cond, "message")) {
[13:22:30.896]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:30.896]                         if (muffled) 
[13:22:30.896]                           invokeRestart("muffleMessage")
[13:22:30.896]                       }
[13:22:30.896]                       else if (inherits(cond, "warning")) {
[13:22:30.896]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:30.896]                         if (muffled) 
[13:22:30.896]                           invokeRestart("muffleWarning")
[13:22:30.896]                       }
[13:22:30.896]                       else if (inherits(cond, "condition")) {
[13:22:30.896]                         if (!is.null(pattern)) {
[13:22:30.896]                           computeRestarts <- base::computeRestarts
[13:22:30.896]                           grepl <- base::grepl
[13:22:30.896]                           restarts <- computeRestarts(cond)
[13:22:30.896]                           for (restart in restarts) {
[13:22:30.896]                             name <- restart$name
[13:22:30.896]                             if (is.null(name)) 
[13:22:30.896]                               next
[13:22:30.896]                             if (!grepl(pattern, name)) 
[13:22:30.896]                               next
[13:22:30.896]                             invokeRestart(restart)
[13:22:30.896]                             muffled <- TRUE
[13:22:30.896]                             break
[13:22:30.896]                           }
[13:22:30.896]                         }
[13:22:30.896]                       }
[13:22:30.896]                       invisible(muffled)
[13:22:30.896]                     }
[13:22:30.896]                     muffleCondition(cond, pattern = "^muffle")
[13:22:30.896]                   }
[13:22:30.896]                 }
[13:22:30.896]             }
[13:22:30.896]         }))
[13:22:30.896]     }, error = function(ex) {
[13:22:30.896]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:30.896]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:30.896]                 ...future.rng), started = ...future.startTime, 
[13:22:30.896]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:30.896]             version = "1.8"), class = "FutureResult")
[13:22:30.896]     }, finally = {
[13:22:30.896]         if (!identical(...future.workdir, getwd())) 
[13:22:30.896]             setwd(...future.workdir)
[13:22:30.896]         {
[13:22:30.896]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:30.896]                 ...future.oldOptions$nwarnings <- NULL
[13:22:30.896]             }
[13:22:30.896]             base::options(...future.oldOptions)
[13:22:30.896]             if (.Platform$OS.type == "windows") {
[13:22:30.896]                 old_names <- names(...future.oldEnvVars)
[13:22:30.896]                 envs <- base::Sys.getenv()
[13:22:30.896]                 names <- names(envs)
[13:22:30.896]                 common <- intersect(names, old_names)
[13:22:30.896]                 added <- setdiff(names, old_names)
[13:22:30.896]                 removed <- setdiff(old_names, names)
[13:22:30.896]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:30.896]                   envs[common]]
[13:22:30.896]                 NAMES <- toupper(changed)
[13:22:30.896]                 args <- list()
[13:22:30.896]                 for (kk in seq_along(NAMES)) {
[13:22:30.896]                   name <- changed[[kk]]
[13:22:30.896]                   NAME <- NAMES[[kk]]
[13:22:30.896]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:30.896]                     next
[13:22:30.896]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:30.896]                 }
[13:22:30.896]                 NAMES <- toupper(added)
[13:22:30.896]                 for (kk in seq_along(NAMES)) {
[13:22:30.896]                   name <- added[[kk]]
[13:22:30.896]                   NAME <- NAMES[[kk]]
[13:22:30.896]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:30.896]                     next
[13:22:30.896]                   args[[name]] <- ""
[13:22:30.896]                 }
[13:22:30.896]                 NAMES <- toupper(removed)
[13:22:30.896]                 for (kk in seq_along(NAMES)) {
[13:22:30.896]                   name <- removed[[kk]]
[13:22:30.896]                   NAME <- NAMES[[kk]]
[13:22:30.896]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:30.896]                     next
[13:22:30.896]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:30.896]                 }
[13:22:30.896]                 if (length(args) > 0) 
[13:22:30.896]                   base::do.call(base::Sys.setenv, args = args)
[13:22:30.896]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:30.896]             }
[13:22:30.896]             else {
[13:22:30.896]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:30.896]             }
[13:22:30.896]             {
[13:22:30.896]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:30.896]                   0L) {
[13:22:30.896]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:30.896]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:30.896]                   base::options(opts)
[13:22:30.896]                 }
[13:22:30.896]                 {
[13:22:30.896]                   {
[13:22:30.896]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:30.896]                     NULL
[13:22:30.896]                   }
[13:22:30.896]                   options(future.plan = NULL)
[13:22:30.896]                   if (is.na(NA_character_)) 
[13:22:30.896]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:30.896]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:30.896]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:30.896]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:30.896]                     envir = parent.frame()) 
[13:22:30.896]                   {
[13:22:30.896]                     if (is.function(workers)) 
[13:22:30.896]                       workers <- workers()
[13:22:30.896]                     workers <- structure(as.integer(workers), 
[13:22:30.896]                       class = class(workers))
[13:22:30.896]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:30.896]                       workers >= 1)
[13:22:30.896]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:30.896]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:30.896]                     }
[13:22:30.896]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:30.896]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:30.896]                       envir = envir)
[13:22:30.896]                     if (!future$lazy) 
[13:22:30.896]                       future <- run(future)
[13:22:30.896]                     invisible(future)
[13:22:30.896]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:30.896]                 }
[13:22:30.896]             }
[13:22:30.896]         }
[13:22:30.896]     })
[13:22:30.896]     if (FALSE) {
[13:22:30.896]         base::sink(type = "output", split = FALSE)
[13:22:30.896]         if (NA) {
[13:22:30.896]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:30.896]         }
[13:22:30.896]         else {
[13:22:30.896]             ...future.result["stdout"] <- base::list(NULL)
[13:22:30.896]         }
[13:22:30.896]         base::close(...future.stdout)
[13:22:30.896]         ...future.stdout <- NULL
[13:22:30.896]     }
[13:22:30.896]     ...future.result$conditions <- ...future.conditions
[13:22:30.896]     ...future.result$finished <- base::Sys.time()
[13:22:30.896]     ...future.result
[13:22:30.896] }
[13:22:30.899] MultisessionFuture started
[13:22:30.900] - Launch lazy future ... done
[13:22:30.900] run() for ‘MultisessionFuture’ ... done
[13:22:30.900] result() for ClusterFuture ...
[13:22:30.900] receiveMessageFromWorker() for ClusterFuture ...
[13:22:30.900] - Validating connection of MultisessionFuture
[13:22:30.947] - received message: FutureResult
[13:22:30.947] - Received FutureResult
[13:22:30.947] - Erased future from FutureRegistry
[13:22:30.947] result() for ClusterFuture ...
[13:22:30.947] - result already collected: FutureResult
[13:22:30.947] result() for ClusterFuture ... done
[13:22:30.948] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:30.948] result() for ClusterFuture ... done
[13:22:30.948] result() for ClusterFuture ...
[13:22:30.948] - result already collected: FutureResult
[13:22:30.948] result() for ClusterFuture ... done
- stdout = structure(TRUE, drop = TRUE)
[13:22:30.948] getGlobalsAndPackages() ...
[13:22:30.948] Searching for globals...
[13:22:30.949] - globals found: [1] ‘print’
[13:22:30.949] Searching for globals ... DONE
[13:22:30.949] Resolving globals: FALSE
[13:22:30.949] 
[13:22:30.949] 
[13:22:30.950] getGlobalsAndPackages() ... DONE
[13:22:30.950] run() for ‘Future’ ...
[13:22:30.950] - state: ‘created’
[13:22:30.950] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:30.964] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:30.965] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:30.965]   - Field: ‘node’
[13:22:30.965]   - Field: ‘label’
[13:22:30.965]   - Field: ‘local’
[13:22:30.965]   - Field: ‘owner’
[13:22:30.965]   - Field: ‘envir’
[13:22:30.965]   - Field: ‘workers’
[13:22:30.965]   - Field: ‘packages’
[13:22:30.965]   - Field: ‘gc’
[13:22:30.966]   - Field: ‘conditions’
[13:22:30.966]   - Field: ‘persistent’
[13:22:30.966]   - Field: ‘expr’
[13:22:30.966]   - Field: ‘uuid’
[13:22:30.966]   - Field: ‘seed’
[13:22:30.966]   - Field: ‘version’
[13:22:30.966]   - Field: ‘result’
[13:22:30.966]   - Field: ‘asynchronous’
[13:22:30.966]   - Field: ‘calls’
[13:22:30.966]   - Field: ‘globals’
[13:22:30.967]   - Field: ‘stdout’
[13:22:30.967]   - Field: ‘earlySignal’
[13:22:30.967]   - Field: ‘lazy’
[13:22:30.967]   - Field: ‘state’
[13:22:30.967] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:30.967] - Launch lazy future ...
[13:22:30.967] Packages needed by the future expression (n = 0): <none>
[13:22:30.967] Packages needed by future strategies (n = 0): <none>
[13:22:30.968] {
[13:22:30.968]     {
[13:22:30.968]         {
[13:22:30.968]             ...future.startTime <- base::Sys.time()
[13:22:30.968]             {
[13:22:30.968]                 {
[13:22:30.968]                   {
[13:22:30.968]                     {
[13:22:30.968]                       base::local({
[13:22:30.968]                         has_future <- base::requireNamespace("future", 
[13:22:30.968]                           quietly = TRUE)
[13:22:30.968]                         if (has_future) {
[13:22:30.968]                           ns <- base::getNamespace("future")
[13:22:30.968]                           version <- ns[[".package"]][["version"]]
[13:22:30.968]                           if (is.null(version)) 
[13:22:30.968]                             version <- utils::packageVersion("future")
[13:22:30.968]                         }
[13:22:30.968]                         else {
[13:22:30.968]                           version <- NULL
[13:22:30.968]                         }
[13:22:30.968]                         if (!has_future || version < "1.8.0") {
[13:22:30.968]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:30.968]                             "", base::R.version$version.string), 
[13:22:30.968]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:30.968]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:30.968]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:30.968]                               "release", "version")], collapse = " "), 
[13:22:30.968]                             hostname = base::Sys.info()[["nodename"]])
[13:22:30.968]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:30.968]                             info)
[13:22:30.968]                           info <- base::paste(info, collapse = "; ")
[13:22:30.968]                           if (!has_future) {
[13:22:30.968]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:30.968]                               info)
[13:22:30.968]                           }
[13:22:30.968]                           else {
[13:22:30.968]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:30.968]                               info, version)
[13:22:30.968]                           }
[13:22:30.968]                           base::stop(msg)
[13:22:30.968]                         }
[13:22:30.968]                       })
[13:22:30.968]                     }
[13:22:30.968]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:30.968]                     base::options(mc.cores = 1L)
[13:22:30.968]                   }
[13:22:30.968]                   options(future.plan = NULL)
[13:22:30.968]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:30.968]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:30.968]                 }
[13:22:30.968]                 ...future.workdir <- getwd()
[13:22:30.968]             }
[13:22:30.968]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:30.968]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:30.968]         }
[13:22:30.968]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:30.968]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:30.968]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:30.968]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:30.968]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:30.968]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:30.968]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:30.968]             base::names(...future.oldOptions))
[13:22:30.968]     }
[13:22:30.968]     if (FALSE) {
[13:22:30.968]     }
[13:22:30.968]     else {
[13:22:30.968]         if (TRUE) {
[13:22:30.968]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:30.968]                 open = "w")
[13:22:30.968]         }
[13:22:30.968]         else {
[13:22:30.968]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:30.968]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:30.968]         }
[13:22:30.968]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:30.968]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:30.968]             base::sink(type = "output", split = FALSE)
[13:22:30.968]             base::close(...future.stdout)
[13:22:30.968]         }, add = TRUE)
[13:22:30.968]     }
[13:22:30.968]     ...future.frame <- base::sys.nframe()
[13:22:30.968]     ...future.conditions <- base::list()
[13:22:30.968]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:30.968]     if (FALSE) {
[13:22:30.968]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:30.968]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:30.968]     }
[13:22:30.968]     ...future.result <- base::tryCatch({
[13:22:30.968]         base::withCallingHandlers({
[13:22:30.968]             ...future.value <- base::withVisible(base::local({
[13:22:30.968]                 ...future.makeSendCondition <- local({
[13:22:30.968]                   sendCondition <- NULL
[13:22:30.968]                   function(frame = 1L) {
[13:22:30.968]                     if (is.function(sendCondition)) 
[13:22:30.968]                       return(sendCondition)
[13:22:30.968]                     ns <- getNamespace("parallel")
[13:22:30.968]                     if (exists("sendData", mode = "function", 
[13:22:30.968]                       envir = ns)) {
[13:22:30.968]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:30.968]                         envir = ns)
[13:22:30.968]                       envir <- sys.frame(frame)
[13:22:30.968]                       master <- NULL
[13:22:30.968]                       while (!identical(envir, .GlobalEnv) && 
[13:22:30.968]                         !identical(envir, emptyenv())) {
[13:22:30.968]                         if (exists("master", mode = "list", envir = envir, 
[13:22:30.968]                           inherits = FALSE)) {
[13:22:30.968]                           master <- get("master", mode = "list", 
[13:22:30.968]                             envir = envir, inherits = FALSE)
[13:22:30.968]                           if (inherits(master, c("SOCKnode", 
[13:22:30.968]                             "SOCK0node"))) {
[13:22:30.968]                             sendCondition <<- function(cond) {
[13:22:30.968]                               data <- list(type = "VALUE", value = cond, 
[13:22:30.968]                                 success = TRUE)
[13:22:30.968]                               parallel_sendData(master, data)
[13:22:30.968]                             }
[13:22:30.968]                             return(sendCondition)
[13:22:30.968]                           }
[13:22:30.968]                         }
[13:22:30.968]                         frame <- frame + 1L
[13:22:30.968]                         envir <- sys.frame(frame)
[13:22:30.968]                       }
[13:22:30.968]                     }
[13:22:30.968]                     sendCondition <<- function(cond) NULL
[13:22:30.968]                   }
[13:22:30.968]                 })
[13:22:30.968]                 withCallingHandlers({
[13:22:30.968]                   print(42)
[13:22:30.968]                 }, immediateCondition = function(cond) {
[13:22:30.968]                   sendCondition <- ...future.makeSendCondition()
[13:22:30.968]                   sendCondition(cond)
[13:22:30.968]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:30.968]                   {
[13:22:30.968]                     inherits <- base::inherits
[13:22:30.968]                     invokeRestart <- base::invokeRestart
[13:22:30.968]                     is.null <- base::is.null
[13:22:30.968]                     muffled <- FALSE
[13:22:30.968]                     if (inherits(cond, "message")) {
[13:22:30.968]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:30.968]                       if (muffled) 
[13:22:30.968]                         invokeRestart("muffleMessage")
[13:22:30.968]                     }
[13:22:30.968]                     else if (inherits(cond, "warning")) {
[13:22:30.968]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:30.968]                       if (muffled) 
[13:22:30.968]                         invokeRestart("muffleWarning")
[13:22:30.968]                     }
[13:22:30.968]                     else if (inherits(cond, "condition")) {
[13:22:30.968]                       if (!is.null(pattern)) {
[13:22:30.968]                         computeRestarts <- base::computeRestarts
[13:22:30.968]                         grepl <- base::grepl
[13:22:30.968]                         restarts <- computeRestarts(cond)
[13:22:30.968]                         for (restart in restarts) {
[13:22:30.968]                           name <- restart$name
[13:22:30.968]                           if (is.null(name)) 
[13:22:30.968]                             next
[13:22:30.968]                           if (!grepl(pattern, name)) 
[13:22:30.968]                             next
[13:22:30.968]                           invokeRestart(restart)
[13:22:30.968]                           muffled <- TRUE
[13:22:30.968]                           break
[13:22:30.968]                         }
[13:22:30.968]                       }
[13:22:30.968]                     }
[13:22:30.968]                     invisible(muffled)
[13:22:30.968]                   }
[13:22:30.968]                   muffleCondition(cond)
[13:22:30.968]                 })
[13:22:30.968]             }))
[13:22:30.968]             future::FutureResult(value = ...future.value$value, 
[13:22:30.968]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:30.968]                   ...future.rng), globalenv = if (FALSE) 
[13:22:30.968]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:30.968]                     ...future.globalenv.names))
[13:22:30.968]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:30.968]         }, condition = base::local({
[13:22:30.968]             c <- base::c
[13:22:30.968]             inherits <- base::inherits
[13:22:30.968]             invokeRestart <- base::invokeRestart
[13:22:30.968]             length <- base::length
[13:22:30.968]             list <- base::list
[13:22:30.968]             seq.int <- base::seq.int
[13:22:30.968]             signalCondition <- base::signalCondition
[13:22:30.968]             sys.calls <- base::sys.calls
[13:22:30.968]             `[[` <- base::`[[`
[13:22:30.968]             `+` <- base::`+`
[13:22:30.968]             `<<-` <- base::`<<-`
[13:22:30.968]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:30.968]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:30.968]                   3L)]
[13:22:30.968]             }
[13:22:30.968]             function(cond) {
[13:22:30.968]                 is_error <- inherits(cond, "error")
[13:22:30.968]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:30.968]                   NULL)
[13:22:30.968]                 if (is_error) {
[13:22:30.968]                   sessionInformation <- function() {
[13:22:30.968]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:30.968]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:30.968]                       search = base::search(), system = base::Sys.info())
[13:22:30.968]                   }
[13:22:30.968]                   ...future.conditions[[length(...future.conditions) + 
[13:22:30.968]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:30.968]                     cond$call), session = sessionInformation(), 
[13:22:30.968]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:30.968]                   signalCondition(cond)
[13:22:30.968]                 }
[13:22:30.968]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:30.968]                 "immediateCondition"))) {
[13:22:30.968]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:30.968]                   ...future.conditions[[length(...future.conditions) + 
[13:22:30.968]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:30.968]                   if (TRUE && !signal) {
[13:22:30.968]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:30.968]                     {
[13:22:30.968]                       inherits <- base::inherits
[13:22:30.968]                       invokeRestart <- base::invokeRestart
[13:22:30.968]                       is.null <- base::is.null
[13:22:30.968]                       muffled <- FALSE
[13:22:30.968]                       if (inherits(cond, "message")) {
[13:22:30.968]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:30.968]                         if (muffled) 
[13:22:30.968]                           invokeRestart("muffleMessage")
[13:22:30.968]                       }
[13:22:30.968]                       else if (inherits(cond, "warning")) {
[13:22:30.968]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:30.968]                         if (muffled) 
[13:22:30.968]                           invokeRestart("muffleWarning")
[13:22:30.968]                       }
[13:22:30.968]                       else if (inherits(cond, "condition")) {
[13:22:30.968]                         if (!is.null(pattern)) {
[13:22:30.968]                           computeRestarts <- base::computeRestarts
[13:22:30.968]                           grepl <- base::grepl
[13:22:30.968]                           restarts <- computeRestarts(cond)
[13:22:30.968]                           for (restart in restarts) {
[13:22:30.968]                             name <- restart$name
[13:22:30.968]                             if (is.null(name)) 
[13:22:30.968]                               next
[13:22:30.968]                             if (!grepl(pattern, name)) 
[13:22:30.968]                               next
[13:22:30.968]                             invokeRestart(restart)
[13:22:30.968]                             muffled <- TRUE
[13:22:30.968]                             break
[13:22:30.968]                           }
[13:22:30.968]                         }
[13:22:30.968]                       }
[13:22:30.968]                       invisible(muffled)
[13:22:30.968]                     }
[13:22:30.968]                     muffleCondition(cond, pattern = "^muffle")
[13:22:30.968]                   }
[13:22:30.968]                 }
[13:22:30.968]                 else {
[13:22:30.968]                   if (TRUE) {
[13:22:30.968]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:30.968]                     {
[13:22:30.968]                       inherits <- base::inherits
[13:22:30.968]                       invokeRestart <- base::invokeRestart
[13:22:30.968]                       is.null <- base::is.null
[13:22:30.968]                       muffled <- FALSE
[13:22:30.968]                       if (inherits(cond, "message")) {
[13:22:30.968]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:30.968]                         if (muffled) 
[13:22:30.968]                           invokeRestart("muffleMessage")
[13:22:30.968]                       }
[13:22:30.968]                       else if (inherits(cond, "warning")) {
[13:22:30.968]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:30.968]                         if (muffled) 
[13:22:30.968]                           invokeRestart("muffleWarning")
[13:22:30.968]                       }
[13:22:30.968]                       else if (inherits(cond, "condition")) {
[13:22:30.968]                         if (!is.null(pattern)) {
[13:22:30.968]                           computeRestarts <- base::computeRestarts
[13:22:30.968]                           grepl <- base::grepl
[13:22:30.968]                           restarts <- computeRestarts(cond)
[13:22:30.968]                           for (restart in restarts) {
[13:22:30.968]                             name <- restart$name
[13:22:30.968]                             if (is.null(name)) 
[13:22:30.968]                               next
[13:22:30.968]                             if (!grepl(pattern, name)) 
[13:22:30.968]                               next
[13:22:30.968]                             invokeRestart(restart)
[13:22:30.968]                             muffled <- TRUE
[13:22:30.968]                             break
[13:22:30.968]                           }
[13:22:30.968]                         }
[13:22:30.968]                       }
[13:22:30.968]                       invisible(muffled)
[13:22:30.968]                     }
[13:22:30.968]                     muffleCondition(cond, pattern = "^muffle")
[13:22:30.968]                   }
[13:22:30.968]                 }
[13:22:30.968]             }
[13:22:30.968]         }))
[13:22:30.968]     }, error = function(ex) {
[13:22:30.968]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:30.968]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:30.968]                 ...future.rng), started = ...future.startTime, 
[13:22:30.968]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:30.968]             version = "1.8"), class = "FutureResult")
[13:22:30.968]     }, finally = {
[13:22:30.968]         if (!identical(...future.workdir, getwd())) 
[13:22:30.968]             setwd(...future.workdir)
[13:22:30.968]         {
[13:22:30.968]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:30.968]                 ...future.oldOptions$nwarnings <- NULL
[13:22:30.968]             }
[13:22:30.968]             base::options(...future.oldOptions)
[13:22:30.968]             if (.Platform$OS.type == "windows") {
[13:22:30.968]                 old_names <- names(...future.oldEnvVars)
[13:22:30.968]                 envs <- base::Sys.getenv()
[13:22:30.968]                 names <- names(envs)
[13:22:30.968]                 common <- intersect(names, old_names)
[13:22:30.968]                 added <- setdiff(names, old_names)
[13:22:30.968]                 removed <- setdiff(old_names, names)
[13:22:30.968]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:30.968]                   envs[common]]
[13:22:30.968]                 NAMES <- toupper(changed)
[13:22:30.968]                 args <- list()
[13:22:30.968]                 for (kk in seq_along(NAMES)) {
[13:22:30.968]                   name <- changed[[kk]]
[13:22:30.968]                   NAME <- NAMES[[kk]]
[13:22:30.968]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:30.968]                     next
[13:22:30.968]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:30.968]                 }
[13:22:30.968]                 NAMES <- toupper(added)
[13:22:30.968]                 for (kk in seq_along(NAMES)) {
[13:22:30.968]                   name <- added[[kk]]
[13:22:30.968]                   NAME <- NAMES[[kk]]
[13:22:30.968]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:30.968]                     next
[13:22:30.968]                   args[[name]] <- ""
[13:22:30.968]                 }
[13:22:30.968]                 NAMES <- toupper(removed)
[13:22:30.968]                 for (kk in seq_along(NAMES)) {
[13:22:30.968]                   name <- removed[[kk]]
[13:22:30.968]                   NAME <- NAMES[[kk]]
[13:22:30.968]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:30.968]                     next
[13:22:30.968]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:30.968]                 }
[13:22:30.968]                 if (length(args) > 0) 
[13:22:30.968]                   base::do.call(base::Sys.setenv, args = args)
[13:22:30.968]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:30.968]             }
[13:22:30.968]             else {
[13:22:30.968]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:30.968]             }
[13:22:30.968]             {
[13:22:30.968]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:30.968]                   0L) {
[13:22:30.968]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:30.968]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:30.968]                   base::options(opts)
[13:22:30.968]                 }
[13:22:30.968]                 {
[13:22:30.968]                   {
[13:22:30.968]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:30.968]                     NULL
[13:22:30.968]                   }
[13:22:30.968]                   options(future.plan = NULL)
[13:22:30.968]                   if (is.na(NA_character_)) 
[13:22:30.968]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:30.968]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:30.968]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:30.968]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:30.968]                     envir = parent.frame()) 
[13:22:30.968]                   {
[13:22:30.968]                     if (is.function(workers)) 
[13:22:30.968]                       workers <- workers()
[13:22:30.968]                     workers <- structure(as.integer(workers), 
[13:22:30.968]                       class = class(workers))
[13:22:30.968]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:30.968]                       workers >= 1)
[13:22:30.968]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:30.968]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:30.968]                     }
[13:22:30.968]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:30.968]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:30.968]                       envir = envir)
[13:22:30.968]                     if (!future$lazy) 
[13:22:30.968]                       future <- run(future)
[13:22:30.968]                     invisible(future)
[13:22:30.968]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:30.968]                 }
[13:22:30.968]             }
[13:22:30.968]         }
[13:22:30.968]     })
[13:22:30.968]     if (TRUE) {
[13:22:30.968]         base::sink(type = "output", split = FALSE)
[13:22:30.968]         if (TRUE) {
[13:22:30.968]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:30.968]         }
[13:22:30.968]         else {
[13:22:30.968]             ...future.result["stdout"] <- base::list(NULL)
[13:22:30.968]         }
[13:22:30.968]         base::close(...future.stdout)
[13:22:30.968]         ...future.stdout <- NULL
[13:22:30.968]     }
[13:22:30.968]     ...future.result$conditions <- ...future.conditions
[13:22:30.968]     ...future.result$finished <- base::Sys.time()
[13:22:30.968]     ...future.result
[13:22:30.968] }
[13:22:30.971] MultisessionFuture started
[13:22:30.971] - Launch lazy future ... done
[13:22:30.971] run() for ‘MultisessionFuture’ ... done
[13:22:30.971] result() for ClusterFuture ...
[13:22:30.971] receiveMessageFromWorker() for ClusterFuture ...
[13:22:30.971] - Validating connection of MultisessionFuture
[13:22:31.021] - received message: FutureResult
[13:22:31.021] - Received FutureResult
[13:22:31.022] - Erased future from FutureRegistry
[13:22:31.022] result() for ClusterFuture ...
[13:22:31.022] - result already collected: FutureResult
[13:22:31.022] result() for ClusterFuture ... done
[13:22:31.022] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:31.022] result() for ClusterFuture ... done
[13:22:31.022] result() for ClusterFuture ...
[13:22:31.022] - result already collected: FutureResult
[13:22:31.022] result() for ClusterFuture ... done
[13:22:31.022] result() for ClusterFuture ...
[13:22:31.023] - result already collected: FutureResult
[13:22:31.023] result() for ClusterFuture ... done
[1] 42
[13:22:31.023] result() for ClusterFuture ...
[13:22:31.023] - result already collected: FutureResult
[13:22:31.023] result() for ClusterFuture ... done
multisession ... done
Testing with 2 cores ... done
> 
> message("*** Standard output ... DONE")
*** Standard output ... DONE
> 
> source("incl/end.R")
[13:22:31.024] plan(): Setting new future strategy stack:
[13:22:31.024] List of future strategies:
[13:22:31.024] 1. FutureStrategy:
[13:22:31.024]    - args: function (..., envir = parent.frame())
[13:22:31.024]    - tweaked: FALSE
[13:22:31.024]    - call: future::plan(oplan)
[13:22:31.025] plan(): nbrOfWorkers() = 1
> 
