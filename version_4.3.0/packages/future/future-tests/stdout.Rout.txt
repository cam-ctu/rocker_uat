
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[16:14:28.890] plan(): Setting new future strategy stack:
[16:14:28.891] List of future strategies:
[16:14:28.891] 1. sequential:
[16:14:28.891]    - args: function (..., envir = parent.frame())
[16:14:28.891]    - tweaked: FALSE
[16:14:28.891]    - call: future::plan("sequential")
[16:14:28.904] plan(): nbrOfWorkers() = 1
> 
> message("*** Standard output ...")
*** Standard output ...
> 
> truth_rows <- utils::capture.output({
+   print(1:50)
+   str(1:50)
+   cat(letters, sep = "-")
+   cat(1:6, collapse = "\n")
+   write.table(datasets::iris[1:10,], sep = "\t")
+ })
> truth <- paste0(paste(truth_rows, collapse = "\n"), "\n")
> print(truth)
[1] " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50\n int [1:50] 1 2 3 4 5 6 7 8 9 10 ...\na-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 \n\"Sepal.Length\"\t\"Sepal.Width\"\t\"Petal.Length\"\t\"Petal.Width\"\t\"Species\"\n\"1\"\t5.1\t3.5\t1.4\t0.2\t\"setosa\"\n\"2\"\t4.9\t3\t1.4\t0.2\t\"setosa\"\n\"3\"\t4.7\t3.2\t1.3\t0.2\t\"setosa\"\n\"4\"\t4.6\t3.1\t1.5\t0.2\t\"setosa\"\n\"5\"\t5\t3.6\t1.4\t0.2\t\"setosa\"\n\"6\"\t5.4\t3.9\t1.7\t0.4\t\"setosa\"\n\"7\"\t4.6\t3.4\t1.4\t0.3\t\"setosa\"\n\"8\"\t5\t3.4\t1.5\t0.2\t\"setosa\"\n\"9\"\t4.4\t2.9\t1.4\t0.2\t\"setosa\"\n\"10\"\t4.9\t3.1\t1.5\t0.1\t\"setosa\"\n"
> 
> for (cores in seq_len(min(2L, availCores))) {
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("%s ...", strategy))
+     plan(strategy)
+ 
+     for (stdout in c(TRUE, FALSE, NA)) {
+       message(sprintf("- stdout = %s", stdout))
+ 
+       f <- future({
+         print(1:50)
+         str(1:50)
+         cat(letters, sep = "-")
+         cat(1:6, collapse = "\n")
+         write.table(datasets::iris[1:10,], sep = "\t")
+         42L
+       }, stdout = stdout)
+       r <- result(f)
+       str(r)
+       stopifnot(value(f) == 42L)
+       if (is.na(stdout)) {
+         stopifnot(is.null(r$stdout) || r$stdout == "")
+       } else if (stdout) {
+         print(r)
+         stopifnot(identical(r$stdout, truth))
+       } else {
+         stopifnot(is.null(r$stdout))
+       }
+ 
+       v %<-% {
+         print(1:50)
+         str(1:50)
+         cat(letters, sep = "-")
+         cat(1:6, collapse = "\n")
+         write.table(datasets::iris[1:10,], sep = "\t")
+         42L
+       } %stdout% stdout
+       out <- utils::capture.output(y <- v)
+       stopifnot(y == 42L)
+       if (is.na(stdout)) {
+         ## Single-core multisession => sequential
+         if (cores > 1L || strategy != "multisession") {
+           stopifnot(out == "")
+         }
+       } else if (stdout) {
+         print(out)
+         stopifnot(identical(out, truth_rows))
+       } else {
+         stopifnot(out == "")
+       }
+ 
+       message("- stdout = structure(TRUE, drop = TRUE)")
+       f <- future(print(42), stdout = structure(TRUE, drop = TRUE))
+       r <- result(f)
+       stopifnot(inherits(r$stdout, "character"))
+       v <- value(f)
+       r <- result(f)
+       stopifnot(is.null(r$stdout))
+     } ## for (stdout ...)
+ 
+     message(sprintf("%s ... done", strategy))
+   } ## for (strategy ...)
+ 
+   message(sprintf("Testing with %d cores ... done", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
sequential ...
[16:14:28.951] plan(): Setting new future strategy stack:
[16:14:28.951] List of future strategies:
[16:14:28.951] 1. sequential:
[16:14:28.951]    - args: function (..., envir = parent.frame())
[16:14:28.951]    - tweaked: FALSE
[16:14:28.951]    - call: plan(strategy)
[16:14:28.962] plan(): nbrOfWorkers() = 1
- stdout = TRUE
[16:14:28.963] getGlobalsAndPackages() ...
[16:14:28.963] Searching for globals...
[16:14:28.971] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[16:14:28.971] Searching for globals ... DONE
[16:14:28.972] Resolving globals: FALSE
[16:14:28.972] 
[16:14:28.972] - packages: [1] ‘utils’
[16:14:28.973] getGlobalsAndPackages() ... DONE
[16:14:28.973] run() for ‘Future’ ...
[16:14:28.973] - state: ‘created’
[16:14:28.974] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:14:28.974] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:14:28.974] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:14:28.974]   - Field: ‘label’
[16:14:28.974]   - Field: ‘local’
[16:14:28.974]   - Field: ‘owner’
[16:14:28.974]   - Field: ‘envir’
[16:14:28.974]   - Field: ‘packages’
[16:14:28.975]   - Field: ‘gc’
[16:14:28.975]   - Field: ‘conditions’
[16:14:28.975]   - Field: ‘expr’
[16:14:28.975]   - Field: ‘uuid’
[16:14:28.975]   - Field: ‘seed’
[16:14:28.975]   - Field: ‘version’
[16:14:28.975]   - Field: ‘result’
[16:14:28.975]   - Field: ‘asynchronous’
[16:14:28.975]   - Field: ‘calls’
[16:14:28.975]   - Field: ‘globals’
[16:14:28.975]   - Field: ‘stdout’
[16:14:28.975]   - Field: ‘earlySignal’
[16:14:28.976]   - Field: ‘lazy’
[16:14:28.976]   - Field: ‘state’
[16:14:28.976] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:14:28.976] - Launch lazy future ...
[16:14:28.977] Packages needed by the future expression (n = 1): ‘utils’
[16:14:28.977] Packages needed by future strategies (n = 0): <none>
[16:14:28.978] {
[16:14:28.978]     {
[16:14:28.978]         {
[16:14:28.978]             ...future.startTime <- base::Sys.time()
[16:14:28.978]             {
[16:14:28.978]                 {
[16:14:28.978]                   {
[16:14:28.978]                     {
[16:14:28.978]                       base::local({
[16:14:28.978]                         has_future <- base::requireNamespace("future", 
[16:14:28.978]                           quietly = TRUE)
[16:14:28.978]                         if (has_future) {
[16:14:28.978]                           ns <- base::getNamespace("future")
[16:14:28.978]                           version <- ns[[".package"]][["version"]]
[16:14:28.978]                           if (is.null(version)) 
[16:14:28.978]                             version <- utils::packageVersion("future")
[16:14:28.978]                         }
[16:14:28.978]                         else {
[16:14:28.978]                           version <- NULL
[16:14:28.978]                         }
[16:14:28.978]                         if (!has_future || version < "1.8.0") {
[16:14:28.978]                           info <- base::c(r_version = base::gsub("R version ", 
[16:14:28.978]                             "", base::R.version$version.string), 
[16:14:28.978]                             platform = base::sprintf("%s (%s-bit)", 
[16:14:28.978]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:14:28.978]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:28.978]                               "release", "version")], collapse = " "), 
[16:14:28.978]                             hostname = base::Sys.info()[["nodename"]])
[16:14:28.978]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:14:28.978]                             info)
[16:14:28.978]                           info <- base::paste(info, collapse = "; ")
[16:14:28.978]                           if (!has_future) {
[16:14:28.978]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:28.978]                               info)
[16:14:28.978]                           }
[16:14:28.978]                           else {
[16:14:28.978]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:28.978]                               info, version)
[16:14:28.978]                           }
[16:14:28.978]                           base::stop(msg)
[16:14:28.978]                         }
[16:14:28.978]                       })
[16:14:28.978]                     }
[16:14:28.978]                     base::local({
[16:14:28.978]                       for (pkg in "utils") {
[16:14:28.978]                         base::loadNamespace(pkg)
[16:14:28.978]                         base::library(pkg, character.only = TRUE)
[16:14:28.978]                       }
[16:14:28.978]                     })
[16:14:28.978]                   }
[16:14:28.978]                   options(future.plan = NULL)
[16:14:28.978]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:28.978]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:28.978]                 }
[16:14:28.978]                 ...future.workdir <- getwd()
[16:14:28.978]             }
[16:14:28.978]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:28.978]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:28.978]         }
[16:14:28.978]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:28.978]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:28.978]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:28.978]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:28.978]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:28.978]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:28.978]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:28.978]             base::names(...future.oldOptions))
[16:14:28.978]     }
[16:14:28.978]     if (FALSE) {
[16:14:28.978]     }
[16:14:28.978]     else {
[16:14:28.978]         if (TRUE) {
[16:14:28.978]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:28.978]                 open = "w")
[16:14:28.978]         }
[16:14:28.978]         else {
[16:14:28.978]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:28.978]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:28.978]         }
[16:14:28.978]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:28.978]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:28.978]             base::sink(type = "output", split = FALSE)
[16:14:28.978]             base::close(...future.stdout)
[16:14:28.978]         }, add = TRUE)
[16:14:28.978]     }
[16:14:28.978]     ...future.frame <- base::sys.nframe()
[16:14:28.978]     ...future.conditions <- base::list()
[16:14:28.978]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:28.978]     if (FALSE) {
[16:14:28.978]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:28.978]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:28.978]     }
[16:14:28.978]     ...future.result <- base::tryCatch({
[16:14:28.978]         base::withCallingHandlers({
[16:14:28.978]             ...future.value <- base::withVisible(base::local({
[16:14:28.978]                 print(1:50)
[16:14:28.978]                 str(1:50)
[16:14:28.978]                 cat(letters, sep = "-")
[16:14:28.978]                 cat(1:6, collapse = "\n")
[16:14:28.978]                 write.table(datasets::iris[1:10, ], sep = "\t")
[16:14:28.978]                 42L
[16:14:28.978]             }))
[16:14:28.978]             future::FutureResult(value = ...future.value$value, 
[16:14:28.978]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:28.978]                   ...future.rng), globalenv = if (FALSE) 
[16:14:28.978]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:28.978]                     ...future.globalenv.names))
[16:14:28.978]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:28.978]         }, condition = base::local({
[16:14:28.978]             c <- base::c
[16:14:28.978]             inherits <- base::inherits
[16:14:28.978]             invokeRestart <- base::invokeRestart
[16:14:28.978]             length <- base::length
[16:14:28.978]             list <- base::list
[16:14:28.978]             seq.int <- base::seq.int
[16:14:28.978]             signalCondition <- base::signalCondition
[16:14:28.978]             sys.calls <- base::sys.calls
[16:14:28.978]             `[[` <- base::`[[`
[16:14:28.978]             `+` <- base::`+`
[16:14:28.978]             `<<-` <- base::`<<-`
[16:14:28.978]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:28.978]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:28.978]                   3L)]
[16:14:28.978]             }
[16:14:28.978]             function(cond) {
[16:14:28.978]                 is_error <- inherits(cond, "error")
[16:14:28.978]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:28.978]                   NULL)
[16:14:28.978]                 if (is_error) {
[16:14:28.978]                   sessionInformation <- function() {
[16:14:28.978]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:28.978]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:28.978]                       search = base::search(), system = base::Sys.info())
[16:14:28.978]                   }
[16:14:28.978]                   ...future.conditions[[length(...future.conditions) + 
[16:14:28.978]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:28.978]                     cond$call), session = sessionInformation(), 
[16:14:28.978]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:28.978]                   signalCondition(cond)
[16:14:28.978]                 }
[16:14:28.978]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:28.978]                 "immediateCondition"))) {
[16:14:28.978]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:28.978]                   ...future.conditions[[length(...future.conditions) + 
[16:14:28.978]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:28.978]                   if (TRUE && !signal) {
[16:14:28.978]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:28.978]                     {
[16:14:28.978]                       inherits <- base::inherits
[16:14:28.978]                       invokeRestart <- base::invokeRestart
[16:14:28.978]                       is.null <- base::is.null
[16:14:28.978]                       muffled <- FALSE
[16:14:28.978]                       if (inherits(cond, "message")) {
[16:14:28.978]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:28.978]                         if (muffled) 
[16:14:28.978]                           invokeRestart("muffleMessage")
[16:14:28.978]                       }
[16:14:28.978]                       else if (inherits(cond, "warning")) {
[16:14:28.978]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:28.978]                         if (muffled) 
[16:14:28.978]                           invokeRestart("muffleWarning")
[16:14:28.978]                       }
[16:14:28.978]                       else if (inherits(cond, "condition")) {
[16:14:28.978]                         if (!is.null(pattern)) {
[16:14:28.978]                           computeRestarts <- base::computeRestarts
[16:14:28.978]                           grepl <- base::grepl
[16:14:28.978]                           restarts <- computeRestarts(cond)
[16:14:28.978]                           for (restart in restarts) {
[16:14:28.978]                             name <- restart$name
[16:14:28.978]                             if (is.null(name)) 
[16:14:28.978]                               next
[16:14:28.978]                             if (!grepl(pattern, name)) 
[16:14:28.978]                               next
[16:14:28.978]                             invokeRestart(restart)
[16:14:28.978]                             muffled <- TRUE
[16:14:28.978]                             break
[16:14:28.978]                           }
[16:14:28.978]                         }
[16:14:28.978]                       }
[16:14:28.978]                       invisible(muffled)
[16:14:28.978]                     }
[16:14:28.978]                     muffleCondition(cond, pattern = "^muffle")
[16:14:28.978]                   }
[16:14:28.978]                 }
[16:14:28.978]                 else {
[16:14:28.978]                   if (TRUE) {
[16:14:28.978]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:28.978]                     {
[16:14:28.978]                       inherits <- base::inherits
[16:14:28.978]                       invokeRestart <- base::invokeRestart
[16:14:28.978]                       is.null <- base::is.null
[16:14:28.978]                       muffled <- FALSE
[16:14:28.978]                       if (inherits(cond, "message")) {
[16:14:28.978]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:28.978]                         if (muffled) 
[16:14:28.978]                           invokeRestart("muffleMessage")
[16:14:28.978]                       }
[16:14:28.978]                       else if (inherits(cond, "warning")) {
[16:14:28.978]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:28.978]                         if (muffled) 
[16:14:28.978]                           invokeRestart("muffleWarning")
[16:14:28.978]                       }
[16:14:28.978]                       else if (inherits(cond, "condition")) {
[16:14:28.978]                         if (!is.null(pattern)) {
[16:14:28.978]                           computeRestarts <- base::computeRestarts
[16:14:28.978]                           grepl <- base::grepl
[16:14:28.978]                           restarts <- computeRestarts(cond)
[16:14:28.978]                           for (restart in restarts) {
[16:14:28.978]                             name <- restart$name
[16:14:28.978]                             if (is.null(name)) 
[16:14:28.978]                               next
[16:14:28.978]                             if (!grepl(pattern, name)) 
[16:14:28.978]                               next
[16:14:28.978]                             invokeRestart(restart)
[16:14:28.978]                             muffled <- TRUE
[16:14:28.978]                             break
[16:14:28.978]                           }
[16:14:28.978]                         }
[16:14:28.978]                       }
[16:14:28.978]                       invisible(muffled)
[16:14:28.978]                     }
[16:14:28.978]                     muffleCondition(cond, pattern = "^muffle")
[16:14:28.978]                   }
[16:14:28.978]                 }
[16:14:28.978]             }
[16:14:28.978]         }))
[16:14:28.978]     }, error = function(ex) {
[16:14:28.978]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:28.978]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:28.978]                 ...future.rng), started = ...future.startTime, 
[16:14:28.978]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:28.978]             version = "1.8"), class = "FutureResult")
[16:14:28.978]     }, finally = {
[16:14:28.978]         if (!identical(...future.workdir, getwd())) 
[16:14:28.978]             setwd(...future.workdir)
[16:14:28.978]         {
[16:14:28.978]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:28.978]                 ...future.oldOptions$nwarnings <- NULL
[16:14:28.978]             }
[16:14:28.978]             base::options(...future.oldOptions)
[16:14:28.978]             if (.Platform$OS.type == "windows") {
[16:14:28.978]                 old_names <- names(...future.oldEnvVars)
[16:14:28.978]                 envs <- base::Sys.getenv()
[16:14:28.978]                 names <- names(envs)
[16:14:28.978]                 common <- intersect(names, old_names)
[16:14:28.978]                 added <- setdiff(names, old_names)
[16:14:28.978]                 removed <- setdiff(old_names, names)
[16:14:28.978]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:28.978]                   envs[common]]
[16:14:28.978]                 NAMES <- toupper(changed)
[16:14:28.978]                 args <- list()
[16:14:28.978]                 for (kk in seq_along(NAMES)) {
[16:14:28.978]                   name <- changed[[kk]]
[16:14:28.978]                   NAME <- NAMES[[kk]]
[16:14:28.978]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:28.978]                     next
[16:14:28.978]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:28.978]                 }
[16:14:28.978]                 NAMES <- toupper(added)
[16:14:28.978]                 for (kk in seq_along(NAMES)) {
[16:14:28.978]                   name <- added[[kk]]
[16:14:28.978]                   NAME <- NAMES[[kk]]
[16:14:28.978]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:28.978]                     next
[16:14:28.978]                   args[[name]] <- ""
[16:14:28.978]                 }
[16:14:28.978]                 NAMES <- toupper(removed)
[16:14:28.978]                 for (kk in seq_along(NAMES)) {
[16:14:28.978]                   name <- removed[[kk]]
[16:14:28.978]                   NAME <- NAMES[[kk]]
[16:14:28.978]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:28.978]                     next
[16:14:28.978]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:28.978]                 }
[16:14:28.978]                 if (length(args) > 0) 
[16:14:28.978]                   base::do.call(base::Sys.setenv, args = args)
[16:14:28.978]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:28.978]             }
[16:14:28.978]             else {
[16:14:28.978]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:28.978]             }
[16:14:28.978]             {
[16:14:28.978]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:28.978]                   0L) {
[16:14:28.978]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:28.978]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:28.978]                   base::options(opts)
[16:14:28.978]                 }
[16:14:28.978]                 {
[16:14:28.978]                   {
[16:14:28.978]                     NULL
[16:14:28.978]                     RNGkind("Mersenne-Twister")
[16:14:28.978]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:14:28.978]                       inherits = FALSE)
[16:14:28.978]                   }
[16:14:28.978]                   options(future.plan = NULL)
[16:14:28.978]                   if (is.na(NA_character_)) 
[16:14:28.978]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:28.978]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:28.978]                   future::plan(list(function (..., envir = parent.frame()) 
[16:14:28.978]                   {
[16:14:28.978]                     future <- SequentialFuture(..., envir = envir)
[16:14:28.978]                     if (!future$lazy) 
[16:14:28.978]                       future <- run(future)
[16:14:28.978]                     invisible(future)
[16:14:28.978]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:28.978]                 }
[16:14:28.978]             }
[16:14:28.978]         }
[16:14:28.978]     })
[16:14:28.978]     if (TRUE) {
[16:14:28.978]         base::sink(type = "output", split = FALSE)
[16:14:28.978]         if (TRUE) {
[16:14:28.978]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:28.978]         }
[16:14:28.978]         else {
[16:14:28.978]             ...future.result["stdout"] <- base::list(NULL)
[16:14:28.978]         }
[16:14:28.978]         base::close(...future.stdout)
[16:14:28.978]         ...future.stdout <- NULL
[16:14:28.978]     }
[16:14:28.978]     ...future.result$conditions <- ...future.conditions
[16:14:28.978]     ...future.result$finished <- base::Sys.time()
[16:14:28.978]     ...future.result
[16:14:28.978] }
[16:14:28.980] plan(): Setting new future strategy stack:
[16:14:28.980] List of future strategies:
[16:14:28.980] 1. sequential:
[16:14:28.980]    - args: function (..., envir = parent.frame())
[16:14:28.980]    - tweaked: FALSE
[16:14:28.980]    - call: NULL
[16:14:28.980] plan(): nbrOfWorkers() = 1
[16:14:28.982] plan(): Setting new future strategy stack:
[16:14:28.982] List of future strategies:
[16:14:28.982] 1. sequential:
[16:14:28.982]    - args: function (..., envir = parent.frame())
[16:14:28.982]    - tweaked: FALSE
[16:14:28.982]    - call: plan(strategy)
[16:14:28.982] plan(): nbrOfWorkers() = 1
[16:14:28.982] SequentialFuture started (and completed)
[16:14:28.983] - Launch lazy future ... done
[16:14:28.983] run() for ‘SequentialFuture’ ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : chr " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 3"| __truncated__
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-01-06 16:14:28"
 $ finished    : POSIXct[1:1], format: "2025-01-06 16:14:28"
 $ session_uuid: chr "f2024c80-2b92-d4d1-117a-ce2ef0d518b0"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "2729ef2608da"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "2729ef2608da" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 92308
  .. ..$ time  : POSIXct[1:1], format: "2025-01-06 16:14:28"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 3 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
FutureResult:
value: ‘integer’
visible: TRUE
stdout: character
conditions: [n = 0] 
RNG used: FALSE
duration: 0.003083944 secs (started 2025-01-06 16:14:28.979847)
version: 1.8
[16:14:28.994] getGlobalsAndPackages() ...
[16:14:28.994] Searching for globals...
[16:14:28.997] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[16:14:28.997] Searching for globals ... DONE
[16:14:28.997] Resolving globals: FALSE
[16:14:28.998] 
[16:14:28.998] - packages: [1] ‘utils’
[16:14:28.998] getGlobalsAndPackages() ... DONE
[16:14:28.998] run() for ‘Future’ ...
[16:14:28.998] - state: ‘created’
[16:14:28.999] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:14:28.999] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:14:28.999] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:14:28.999]   - Field: ‘label’
[16:14:28.999]   - Field: ‘local’
[16:14:28.999]   - Field: ‘owner’
[16:14:28.999]   - Field: ‘envir’
[16:14:28.999]   - Field: ‘packages’
[16:14:28.999]   - Field: ‘gc’
[16:14:29.000]   - Field: ‘conditions’
[16:14:29.000]   - Field: ‘expr’
[16:14:29.000]   - Field: ‘uuid’
[16:14:29.000]   - Field: ‘seed’
[16:14:29.000]   - Field: ‘version’
[16:14:29.000]   - Field: ‘result’
[16:14:29.000]   - Field: ‘asynchronous’
[16:14:29.000]   - Field: ‘calls’
[16:14:29.000]   - Field: ‘globals’
[16:14:29.000]   - Field: ‘stdout’
[16:14:29.000]   - Field: ‘earlySignal’
[16:14:29.001]   - Field: ‘lazy’
[16:14:29.001]   - Field: ‘state’
[16:14:29.001] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:14:29.001] - Launch lazy future ...
[16:14:29.001] Packages needed by the future expression (n = 1): ‘utils’
[16:14:29.001] Packages needed by future strategies (n = 0): <none>
[16:14:29.002] {
[16:14:29.002]     {
[16:14:29.002]         {
[16:14:29.002]             ...future.startTime <- base::Sys.time()
[16:14:29.002]             {
[16:14:29.002]                 {
[16:14:29.002]                   {
[16:14:29.002]                     {
[16:14:29.002]                       base::local({
[16:14:29.002]                         has_future <- base::requireNamespace("future", 
[16:14:29.002]                           quietly = TRUE)
[16:14:29.002]                         if (has_future) {
[16:14:29.002]                           ns <- base::getNamespace("future")
[16:14:29.002]                           version <- ns[[".package"]][["version"]]
[16:14:29.002]                           if (is.null(version)) 
[16:14:29.002]                             version <- utils::packageVersion("future")
[16:14:29.002]                         }
[16:14:29.002]                         else {
[16:14:29.002]                           version <- NULL
[16:14:29.002]                         }
[16:14:29.002]                         if (!has_future || version < "1.8.0") {
[16:14:29.002]                           info <- base::c(r_version = base::gsub("R version ", 
[16:14:29.002]                             "", base::R.version$version.string), 
[16:14:29.002]                             platform = base::sprintf("%s (%s-bit)", 
[16:14:29.002]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:14:29.002]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:29.002]                               "release", "version")], collapse = " "), 
[16:14:29.002]                             hostname = base::Sys.info()[["nodename"]])
[16:14:29.002]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:14:29.002]                             info)
[16:14:29.002]                           info <- base::paste(info, collapse = "; ")
[16:14:29.002]                           if (!has_future) {
[16:14:29.002]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:29.002]                               info)
[16:14:29.002]                           }
[16:14:29.002]                           else {
[16:14:29.002]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:29.002]                               info, version)
[16:14:29.002]                           }
[16:14:29.002]                           base::stop(msg)
[16:14:29.002]                         }
[16:14:29.002]                       })
[16:14:29.002]                     }
[16:14:29.002]                     base::local({
[16:14:29.002]                       for (pkg in "utils") {
[16:14:29.002]                         base::loadNamespace(pkg)
[16:14:29.002]                         base::library(pkg, character.only = TRUE)
[16:14:29.002]                       }
[16:14:29.002]                     })
[16:14:29.002]                   }
[16:14:29.002]                   options(future.plan = NULL)
[16:14:29.002]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:29.002]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:29.002]                 }
[16:14:29.002]                 ...future.workdir <- getwd()
[16:14:29.002]             }
[16:14:29.002]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:29.002]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:29.002]         }
[16:14:29.002]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:29.002]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:29.002]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:29.002]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:29.002]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:29.002]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:29.002]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:29.002]             base::names(...future.oldOptions))
[16:14:29.002]     }
[16:14:29.002]     if (FALSE) {
[16:14:29.002]     }
[16:14:29.002]     else {
[16:14:29.002]         if (TRUE) {
[16:14:29.002]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:29.002]                 open = "w")
[16:14:29.002]         }
[16:14:29.002]         else {
[16:14:29.002]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:29.002]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:29.002]         }
[16:14:29.002]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:29.002]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:29.002]             base::sink(type = "output", split = FALSE)
[16:14:29.002]             base::close(...future.stdout)
[16:14:29.002]         }, add = TRUE)
[16:14:29.002]     }
[16:14:29.002]     ...future.frame <- base::sys.nframe()
[16:14:29.002]     ...future.conditions <- base::list()
[16:14:29.002]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:29.002]     if (FALSE) {
[16:14:29.002]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:29.002]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:29.002]     }
[16:14:29.002]     ...future.result <- base::tryCatch({
[16:14:29.002]         base::withCallingHandlers({
[16:14:29.002]             ...future.value <- base::withVisible(base::local({
[16:14:29.002]                 print(1:50)
[16:14:29.002]                 str(1:50)
[16:14:29.002]                 cat(letters, sep = "-")
[16:14:29.002]                 cat(1:6, collapse = "\n")
[16:14:29.002]                 write.table(datasets::iris[1:10, ], sep = "\t")
[16:14:29.002]                 42L
[16:14:29.002]             }))
[16:14:29.002]             future::FutureResult(value = ...future.value$value, 
[16:14:29.002]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:29.002]                   ...future.rng), globalenv = if (FALSE) 
[16:14:29.002]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:29.002]                     ...future.globalenv.names))
[16:14:29.002]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:29.002]         }, condition = base::local({
[16:14:29.002]             c <- base::c
[16:14:29.002]             inherits <- base::inherits
[16:14:29.002]             invokeRestart <- base::invokeRestart
[16:14:29.002]             length <- base::length
[16:14:29.002]             list <- base::list
[16:14:29.002]             seq.int <- base::seq.int
[16:14:29.002]             signalCondition <- base::signalCondition
[16:14:29.002]             sys.calls <- base::sys.calls
[16:14:29.002]             `[[` <- base::`[[`
[16:14:29.002]             `+` <- base::`+`
[16:14:29.002]             `<<-` <- base::`<<-`
[16:14:29.002]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:29.002]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:29.002]                   3L)]
[16:14:29.002]             }
[16:14:29.002]             function(cond) {
[16:14:29.002]                 is_error <- inherits(cond, "error")
[16:14:29.002]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:29.002]                   NULL)
[16:14:29.002]                 if (is_error) {
[16:14:29.002]                   sessionInformation <- function() {
[16:14:29.002]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:29.002]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:29.002]                       search = base::search(), system = base::Sys.info())
[16:14:29.002]                   }
[16:14:29.002]                   ...future.conditions[[length(...future.conditions) + 
[16:14:29.002]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:29.002]                     cond$call), session = sessionInformation(), 
[16:14:29.002]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:29.002]                   signalCondition(cond)
[16:14:29.002]                 }
[16:14:29.002]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:29.002]                 "immediateCondition"))) {
[16:14:29.002]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:29.002]                   ...future.conditions[[length(...future.conditions) + 
[16:14:29.002]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:29.002]                   if (TRUE && !signal) {
[16:14:29.002]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.002]                     {
[16:14:29.002]                       inherits <- base::inherits
[16:14:29.002]                       invokeRestart <- base::invokeRestart
[16:14:29.002]                       is.null <- base::is.null
[16:14:29.002]                       muffled <- FALSE
[16:14:29.002]                       if (inherits(cond, "message")) {
[16:14:29.002]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:29.002]                         if (muffled) 
[16:14:29.002]                           invokeRestart("muffleMessage")
[16:14:29.002]                       }
[16:14:29.002]                       else if (inherits(cond, "warning")) {
[16:14:29.002]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:29.002]                         if (muffled) 
[16:14:29.002]                           invokeRestart("muffleWarning")
[16:14:29.002]                       }
[16:14:29.002]                       else if (inherits(cond, "condition")) {
[16:14:29.002]                         if (!is.null(pattern)) {
[16:14:29.002]                           computeRestarts <- base::computeRestarts
[16:14:29.002]                           grepl <- base::grepl
[16:14:29.002]                           restarts <- computeRestarts(cond)
[16:14:29.002]                           for (restart in restarts) {
[16:14:29.002]                             name <- restart$name
[16:14:29.002]                             if (is.null(name)) 
[16:14:29.002]                               next
[16:14:29.002]                             if (!grepl(pattern, name)) 
[16:14:29.002]                               next
[16:14:29.002]                             invokeRestart(restart)
[16:14:29.002]                             muffled <- TRUE
[16:14:29.002]                             break
[16:14:29.002]                           }
[16:14:29.002]                         }
[16:14:29.002]                       }
[16:14:29.002]                       invisible(muffled)
[16:14:29.002]                     }
[16:14:29.002]                     muffleCondition(cond, pattern = "^muffle")
[16:14:29.002]                   }
[16:14:29.002]                 }
[16:14:29.002]                 else {
[16:14:29.002]                   if (TRUE) {
[16:14:29.002]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.002]                     {
[16:14:29.002]                       inherits <- base::inherits
[16:14:29.002]                       invokeRestart <- base::invokeRestart
[16:14:29.002]                       is.null <- base::is.null
[16:14:29.002]                       muffled <- FALSE
[16:14:29.002]                       if (inherits(cond, "message")) {
[16:14:29.002]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:29.002]                         if (muffled) 
[16:14:29.002]                           invokeRestart("muffleMessage")
[16:14:29.002]                       }
[16:14:29.002]                       else if (inherits(cond, "warning")) {
[16:14:29.002]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:29.002]                         if (muffled) 
[16:14:29.002]                           invokeRestart("muffleWarning")
[16:14:29.002]                       }
[16:14:29.002]                       else if (inherits(cond, "condition")) {
[16:14:29.002]                         if (!is.null(pattern)) {
[16:14:29.002]                           computeRestarts <- base::computeRestarts
[16:14:29.002]                           grepl <- base::grepl
[16:14:29.002]                           restarts <- computeRestarts(cond)
[16:14:29.002]                           for (restart in restarts) {
[16:14:29.002]                             name <- restart$name
[16:14:29.002]                             if (is.null(name)) 
[16:14:29.002]                               next
[16:14:29.002]                             if (!grepl(pattern, name)) 
[16:14:29.002]                               next
[16:14:29.002]                             invokeRestart(restart)
[16:14:29.002]                             muffled <- TRUE
[16:14:29.002]                             break
[16:14:29.002]                           }
[16:14:29.002]                         }
[16:14:29.002]                       }
[16:14:29.002]                       invisible(muffled)
[16:14:29.002]                     }
[16:14:29.002]                     muffleCondition(cond, pattern = "^muffle")
[16:14:29.002]                   }
[16:14:29.002]                 }
[16:14:29.002]             }
[16:14:29.002]         }))
[16:14:29.002]     }, error = function(ex) {
[16:14:29.002]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:29.002]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:29.002]                 ...future.rng), started = ...future.startTime, 
[16:14:29.002]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:29.002]             version = "1.8"), class = "FutureResult")
[16:14:29.002]     }, finally = {
[16:14:29.002]         if (!identical(...future.workdir, getwd())) 
[16:14:29.002]             setwd(...future.workdir)
[16:14:29.002]         {
[16:14:29.002]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:29.002]                 ...future.oldOptions$nwarnings <- NULL
[16:14:29.002]             }
[16:14:29.002]             base::options(...future.oldOptions)
[16:14:29.002]             if (.Platform$OS.type == "windows") {
[16:14:29.002]                 old_names <- names(...future.oldEnvVars)
[16:14:29.002]                 envs <- base::Sys.getenv()
[16:14:29.002]                 names <- names(envs)
[16:14:29.002]                 common <- intersect(names, old_names)
[16:14:29.002]                 added <- setdiff(names, old_names)
[16:14:29.002]                 removed <- setdiff(old_names, names)
[16:14:29.002]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:29.002]                   envs[common]]
[16:14:29.002]                 NAMES <- toupper(changed)
[16:14:29.002]                 args <- list()
[16:14:29.002]                 for (kk in seq_along(NAMES)) {
[16:14:29.002]                   name <- changed[[kk]]
[16:14:29.002]                   NAME <- NAMES[[kk]]
[16:14:29.002]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.002]                     next
[16:14:29.002]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:29.002]                 }
[16:14:29.002]                 NAMES <- toupper(added)
[16:14:29.002]                 for (kk in seq_along(NAMES)) {
[16:14:29.002]                   name <- added[[kk]]
[16:14:29.002]                   NAME <- NAMES[[kk]]
[16:14:29.002]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.002]                     next
[16:14:29.002]                   args[[name]] <- ""
[16:14:29.002]                 }
[16:14:29.002]                 NAMES <- toupper(removed)
[16:14:29.002]                 for (kk in seq_along(NAMES)) {
[16:14:29.002]                   name <- removed[[kk]]
[16:14:29.002]                   NAME <- NAMES[[kk]]
[16:14:29.002]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.002]                     next
[16:14:29.002]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:29.002]                 }
[16:14:29.002]                 if (length(args) > 0) 
[16:14:29.002]                   base::do.call(base::Sys.setenv, args = args)
[16:14:29.002]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:29.002]             }
[16:14:29.002]             else {
[16:14:29.002]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:29.002]             }
[16:14:29.002]             {
[16:14:29.002]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:29.002]                   0L) {
[16:14:29.002]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:29.002]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:29.002]                   base::options(opts)
[16:14:29.002]                 }
[16:14:29.002]                 {
[16:14:29.002]                   {
[16:14:29.002]                     NULL
[16:14:29.002]                     RNGkind("Mersenne-Twister")
[16:14:29.002]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:14:29.002]                       inherits = FALSE)
[16:14:29.002]                   }
[16:14:29.002]                   options(future.plan = NULL)
[16:14:29.002]                   if (is.na(NA_character_)) 
[16:14:29.002]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:29.002]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:29.002]                   future::plan(list(function (..., envir = parent.frame()) 
[16:14:29.002]                   {
[16:14:29.002]                     future <- SequentialFuture(..., envir = envir)
[16:14:29.002]                     if (!future$lazy) 
[16:14:29.002]                       future <- run(future)
[16:14:29.002]                     invisible(future)
[16:14:29.002]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:29.002]                 }
[16:14:29.002]             }
[16:14:29.002]         }
[16:14:29.002]     })
[16:14:29.002]     if (TRUE) {
[16:14:29.002]         base::sink(type = "output", split = FALSE)
[16:14:29.002]         if (TRUE) {
[16:14:29.002]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:29.002]         }
[16:14:29.002]         else {
[16:14:29.002]             ...future.result["stdout"] <- base::list(NULL)
[16:14:29.002]         }
[16:14:29.002]         base::close(...future.stdout)
[16:14:29.002]         ...future.stdout <- NULL
[16:14:29.002]     }
[16:14:29.002]     ...future.result$conditions <- ...future.conditions
[16:14:29.002]     ...future.result$finished <- base::Sys.time()
[16:14:29.002]     ...future.result
[16:14:29.002] }
[16:14:29.003] plan(): Setting new future strategy stack:
[16:14:29.003] List of future strategies:
[16:14:29.003] 1. sequential:
[16:14:29.003]    - args: function (..., envir = parent.frame())
[16:14:29.003]    - tweaked: FALSE
[16:14:29.003]    - call: NULL
[16:14:29.004] plan(): nbrOfWorkers() = 1
[16:14:29.005] plan(): Setting new future strategy stack:
[16:14:29.005] List of future strategies:
[16:14:29.005] 1. sequential:
[16:14:29.005]    - args: function (..., envir = parent.frame())
[16:14:29.005]    - tweaked: FALSE
[16:14:29.005]    - call: plan(strategy)
[16:14:29.006] plan(): nbrOfWorkers() = 1
[16:14:29.006] SequentialFuture started (and completed)
[16:14:29.006] - Launch lazy future ... done
[16:14:29.006] run() for ‘SequentialFuture’ ... done
 [1] " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25"  
 [2] "[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50"  
 [3] " int [1:50] 1 2 3 4 5 6 7 8 9 10 ..."                                             
 [4] "a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 "                  
 [5] "\"Sepal.Length\"\t\"Sepal.Width\"\t\"Petal.Length\"\t\"Petal.Width\"\t\"Species\""
 [6] "\"1\"\t5.1\t3.5\t1.4\t0.2\t\"setosa\""                                            
 [7] "\"2\"\t4.9\t3\t1.4\t0.2\t\"setosa\""                                              
 [8] "\"3\"\t4.7\t3.2\t1.3\t0.2\t\"setosa\""                                            
 [9] "\"4\"\t4.6\t3.1\t1.5\t0.2\t\"setosa\""                                            
[10] "\"5\"\t5\t3.6\t1.4\t0.2\t\"setosa\""                                              
[11] "\"6\"\t5.4\t3.9\t1.7\t0.4\t\"setosa\""                                            
[12] "\"7\"\t4.6\t3.4\t1.4\t0.3\t\"setosa\""                                            
[13] "\"8\"\t5\t3.4\t1.5\t0.2\t\"setosa\""                                              
[14] "\"9\"\t4.4\t2.9\t1.4\t0.2\t\"setosa\""                                            
[15] "\"10\"\t4.9\t3.1\t1.5\t0.1\t\"setosa\""                                           
- stdout = structure(TRUE, drop = TRUE)
[16:14:29.006] getGlobalsAndPackages() ...
[16:14:29.007] Searching for globals...
[16:14:29.007] - globals found: [1] ‘print’
[16:14:29.007] Searching for globals ... DONE
[16:14:29.007] Resolving globals: FALSE
[16:14:29.007] 
[16:14:29.007] 
[16:14:29.008] getGlobalsAndPackages() ... DONE
[16:14:29.008] run() for ‘Future’ ...
[16:14:29.008] - state: ‘created’
[16:14:29.008] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:14:29.008] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:14:29.008] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:14:29.008]   - Field: ‘label’
[16:14:29.009]   - Field: ‘local’
[16:14:29.009]   - Field: ‘owner’
[16:14:29.009]   - Field: ‘envir’
[16:14:29.009]   - Field: ‘packages’
[16:14:29.009]   - Field: ‘gc’
[16:14:29.009]   - Field: ‘conditions’
[16:14:29.009]   - Field: ‘expr’
[16:14:29.009]   - Field: ‘uuid’
[16:14:29.009]   - Field: ‘seed’
[16:14:29.009]   - Field: ‘version’
[16:14:29.009]   - Field: ‘result’
[16:14:29.009]   - Field: ‘asynchronous’
[16:14:29.010]   - Field: ‘calls’
[16:14:29.010]   - Field: ‘globals’
[16:14:29.010]   - Field: ‘stdout’
[16:14:29.010]   - Field: ‘earlySignal’
[16:14:29.010]   - Field: ‘lazy’
[16:14:29.010]   - Field: ‘state’
[16:14:29.010] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:14:29.010] - Launch lazy future ...
[16:14:29.010] Packages needed by the future expression (n = 0): <none>
[16:14:29.010] Packages needed by future strategies (n = 0): <none>
[16:14:29.011] {
[16:14:29.011]     {
[16:14:29.011]         {
[16:14:29.011]             ...future.startTime <- base::Sys.time()
[16:14:29.011]             {
[16:14:29.011]                 {
[16:14:29.011]                   {
[16:14:29.011]                     base::local({
[16:14:29.011]                       has_future <- base::requireNamespace("future", 
[16:14:29.011]                         quietly = TRUE)
[16:14:29.011]                       if (has_future) {
[16:14:29.011]                         ns <- base::getNamespace("future")
[16:14:29.011]                         version <- ns[[".package"]][["version"]]
[16:14:29.011]                         if (is.null(version)) 
[16:14:29.011]                           version <- utils::packageVersion("future")
[16:14:29.011]                       }
[16:14:29.011]                       else {
[16:14:29.011]                         version <- NULL
[16:14:29.011]                       }
[16:14:29.011]                       if (!has_future || version < "1.8.0") {
[16:14:29.011]                         info <- base::c(r_version = base::gsub("R version ", 
[16:14:29.011]                           "", base::R.version$version.string), 
[16:14:29.011]                           platform = base::sprintf("%s (%s-bit)", 
[16:14:29.011]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:14:29.011]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:29.011]                             "release", "version")], collapse = " "), 
[16:14:29.011]                           hostname = base::Sys.info()[["nodename"]])
[16:14:29.011]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:14:29.011]                           info)
[16:14:29.011]                         info <- base::paste(info, collapse = "; ")
[16:14:29.011]                         if (!has_future) {
[16:14:29.011]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:29.011]                             info)
[16:14:29.011]                         }
[16:14:29.011]                         else {
[16:14:29.011]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:29.011]                             info, version)
[16:14:29.011]                         }
[16:14:29.011]                         base::stop(msg)
[16:14:29.011]                       }
[16:14:29.011]                     })
[16:14:29.011]                   }
[16:14:29.011]                   options(future.plan = NULL)
[16:14:29.011]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:29.011]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:29.011]                 }
[16:14:29.011]                 ...future.workdir <- getwd()
[16:14:29.011]             }
[16:14:29.011]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:29.011]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:29.011]         }
[16:14:29.011]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:29.011]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:29.011]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:29.011]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:29.011]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:29.011]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:29.011]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:29.011]             base::names(...future.oldOptions))
[16:14:29.011]     }
[16:14:29.011]     if (FALSE) {
[16:14:29.011]     }
[16:14:29.011]     else {
[16:14:29.011]         if (TRUE) {
[16:14:29.011]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:29.011]                 open = "w")
[16:14:29.011]         }
[16:14:29.011]         else {
[16:14:29.011]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:29.011]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:29.011]         }
[16:14:29.011]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:29.011]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:29.011]             base::sink(type = "output", split = FALSE)
[16:14:29.011]             base::close(...future.stdout)
[16:14:29.011]         }, add = TRUE)
[16:14:29.011]     }
[16:14:29.011]     ...future.frame <- base::sys.nframe()
[16:14:29.011]     ...future.conditions <- base::list()
[16:14:29.011]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:29.011]     if (FALSE) {
[16:14:29.011]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:29.011]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:29.011]     }
[16:14:29.011]     ...future.result <- base::tryCatch({
[16:14:29.011]         base::withCallingHandlers({
[16:14:29.011]             ...future.value <- base::withVisible(base::local(print(42)))
[16:14:29.011]             future::FutureResult(value = ...future.value$value, 
[16:14:29.011]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:29.011]                   ...future.rng), globalenv = if (FALSE) 
[16:14:29.011]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:29.011]                     ...future.globalenv.names))
[16:14:29.011]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:29.011]         }, condition = base::local({
[16:14:29.011]             c <- base::c
[16:14:29.011]             inherits <- base::inherits
[16:14:29.011]             invokeRestart <- base::invokeRestart
[16:14:29.011]             length <- base::length
[16:14:29.011]             list <- base::list
[16:14:29.011]             seq.int <- base::seq.int
[16:14:29.011]             signalCondition <- base::signalCondition
[16:14:29.011]             sys.calls <- base::sys.calls
[16:14:29.011]             `[[` <- base::`[[`
[16:14:29.011]             `+` <- base::`+`
[16:14:29.011]             `<<-` <- base::`<<-`
[16:14:29.011]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:29.011]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:29.011]                   3L)]
[16:14:29.011]             }
[16:14:29.011]             function(cond) {
[16:14:29.011]                 is_error <- inherits(cond, "error")
[16:14:29.011]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:29.011]                   NULL)
[16:14:29.011]                 if (is_error) {
[16:14:29.011]                   sessionInformation <- function() {
[16:14:29.011]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:29.011]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:29.011]                       search = base::search(), system = base::Sys.info())
[16:14:29.011]                   }
[16:14:29.011]                   ...future.conditions[[length(...future.conditions) + 
[16:14:29.011]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:29.011]                     cond$call), session = sessionInformation(), 
[16:14:29.011]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:29.011]                   signalCondition(cond)
[16:14:29.011]                 }
[16:14:29.011]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:29.011]                 "immediateCondition"))) {
[16:14:29.011]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:29.011]                   ...future.conditions[[length(...future.conditions) + 
[16:14:29.011]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:29.011]                   if (TRUE && !signal) {
[16:14:29.011]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.011]                     {
[16:14:29.011]                       inherits <- base::inherits
[16:14:29.011]                       invokeRestart <- base::invokeRestart
[16:14:29.011]                       is.null <- base::is.null
[16:14:29.011]                       muffled <- FALSE
[16:14:29.011]                       if (inherits(cond, "message")) {
[16:14:29.011]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:29.011]                         if (muffled) 
[16:14:29.011]                           invokeRestart("muffleMessage")
[16:14:29.011]                       }
[16:14:29.011]                       else if (inherits(cond, "warning")) {
[16:14:29.011]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:29.011]                         if (muffled) 
[16:14:29.011]                           invokeRestart("muffleWarning")
[16:14:29.011]                       }
[16:14:29.011]                       else if (inherits(cond, "condition")) {
[16:14:29.011]                         if (!is.null(pattern)) {
[16:14:29.011]                           computeRestarts <- base::computeRestarts
[16:14:29.011]                           grepl <- base::grepl
[16:14:29.011]                           restarts <- computeRestarts(cond)
[16:14:29.011]                           for (restart in restarts) {
[16:14:29.011]                             name <- restart$name
[16:14:29.011]                             if (is.null(name)) 
[16:14:29.011]                               next
[16:14:29.011]                             if (!grepl(pattern, name)) 
[16:14:29.011]                               next
[16:14:29.011]                             invokeRestart(restart)
[16:14:29.011]                             muffled <- TRUE
[16:14:29.011]                             break
[16:14:29.011]                           }
[16:14:29.011]                         }
[16:14:29.011]                       }
[16:14:29.011]                       invisible(muffled)
[16:14:29.011]                     }
[16:14:29.011]                     muffleCondition(cond, pattern = "^muffle")
[16:14:29.011]                   }
[16:14:29.011]                 }
[16:14:29.011]                 else {
[16:14:29.011]                   if (TRUE) {
[16:14:29.011]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.011]                     {
[16:14:29.011]                       inherits <- base::inherits
[16:14:29.011]                       invokeRestart <- base::invokeRestart
[16:14:29.011]                       is.null <- base::is.null
[16:14:29.011]                       muffled <- FALSE
[16:14:29.011]                       if (inherits(cond, "message")) {
[16:14:29.011]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:29.011]                         if (muffled) 
[16:14:29.011]                           invokeRestart("muffleMessage")
[16:14:29.011]                       }
[16:14:29.011]                       else if (inherits(cond, "warning")) {
[16:14:29.011]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:29.011]                         if (muffled) 
[16:14:29.011]                           invokeRestart("muffleWarning")
[16:14:29.011]                       }
[16:14:29.011]                       else if (inherits(cond, "condition")) {
[16:14:29.011]                         if (!is.null(pattern)) {
[16:14:29.011]                           computeRestarts <- base::computeRestarts
[16:14:29.011]                           grepl <- base::grepl
[16:14:29.011]                           restarts <- computeRestarts(cond)
[16:14:29.011]                           for (restart in restarts) {
[16:14:29.011]                             name <- restart$name
[16:14:29.011]                             if (is.null(name)) 
[16:14:29.011]                               next
[16:14:29.011]                             if (!grepl(pattern, name)) 
[16:14:29.011]                               next
[16:14:29.011]                             invokeRestart(restart)
[16:14:29.011]                             muffled <- TRUE
[16:14:29.011]                             break
[16:14:29.011]                           }
[16:14:29.011]                         }
[16:14:29.011]                       }
[16:14:29.011]                       invisible(muffled)
[16:14:29.011]                     }
[16:14:29.011]                     muffleCondition(cond, pattern = "^muffle")
[16:14:29.011]                   }
[16:14:29.011]                 }
[16:14:29.011]             }
[16:14:29.011]         }))
[16:14:29.011]     }, error = function(ex) {
[16:14:29.011]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:29.011]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:29.011]                 ...future.rng), started = ...future.startTime, 
[16:14:29.011]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:29.011]             version = "1.8"), class = "FutureResult")
[16:14:29.011]     }, finally = {
[16:14:29.011]         if (!identical(...future.workdir, getwd())) 
[16:14:29.011]             setwd(...future.workdir)
[16:14:29.011]         {
[16:14:29.011]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:29.011]                 ...future.oldOptions$nwarnings <- NULL
[16:14:29.011]             }
[16:14:29.011]             base::options(...future.oldOptions)
[16:14:29.011]             if (.Platform$OS.type == "windows") {
[16:14:29.011]                 old_names <- names(...future.oldEnvVars)
[16:14:29.011]                 envs <- base::Sys.getenv()
[16:14:29.011]                 names <- names(envs)
[16:14:29.011]                 common <- intersect(names, old_names)
[16:14:29.011]                 added <- setdiff(names, old_names)
[16:14:29.011]                 removed <- setdiff(old_names, names)
[16:14:29.011]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:29.011]                   envs[common]]
[16:14:29.011]                 NAMES <- toupper(changed)
[16:14:29.011]                 args <- list()
[16:14:29.011]                 for (kk in seq_along(NAMES)) {
[16:14:29.011]                   name <- changed[[kk]]
[16:14:29.011]                   NAME <- NAMES[[kk]]
[16:14:29.011]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.011]                     next
[16:14:29.011]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:29.011]                 }
[16:14:29.011]                 NAMES <- toupper(added)
[16:14:29.011]                 for (kk in seq_along(NAMES)) {
[16:14:29.011]                   name <- added[[kk]]
[16:14:29.011]                   NAME <- NAMES[[kk]]
[16:14:29.011]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.011]                     next
[16:14:29.011]                   args[[name]] <- ""
[16:14:29.011]                 }
[16:14:29.011]                 NAMES <- toupper(removed)
[16:14:29.011]                 for (kk in seq_along(NAMES)) {
[16:14:29.011]                   name <- removed[[kk]]
[16:14:29.011]                   NAME <- NAMES[[kk]]
[16:14:29.011]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.011]                     next
[16:14:29.011]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:29.011]                 }
[16:14:29.011]                 if (length(args) > 0) 
[16:14:29.011]                   base::do.call(base::Sys.setenv, args = args)
[16:14:29.011]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:29.011]             }
[16:14:29.011]             else {
[16:14:29.011]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:29.011]             }
[16:14:29.011]             {
[16:14:29.011]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:29.011]                   0L) {
[16:14:29.011]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:29.011]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:29.011]                   base::options(opts)
[16:14:29.011]                 }
[16:14:29.011]                 {
[16:14:29.011]                   {
[16:14:29.011]                     NULL
[16:14:29.011]                     RNGkind("Mersenne-Twister")
[16:14:29.011]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:14:29.011]                       inherits = FALSE)
[16:14:29.011]                   }
[16:14:29.011]                   options(future.plan = NULL)
[16:14:29.011]                   if (is.na(NA_character_)) 
[16:14:29.011]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:29.011]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:29.011]                   future::plan(list(function (..., envir = parent.frame()) 
[16:14:29.011]                   {
[16:14:29.011]                     future <- SequentialFuture(..., envir = envir)
[16:14:29.011]                     if (!future$lazy) 
[16:14:29.011]                       future <- run(future)
[16:14:29.011]                     invisible(future)
[16:14:29.011]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:29.011]                 }
[16:14:29.011]             }
[16:14:29.011]         }
[16:14:29.011]     })
[16:14:29.011]     if (TRUE) {
[16:14:29.011]         base::sink(type = "output", split = FALSE)
[16:14:29.011]         if (TRUE) {
[16:14:29.011]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:29.011]         }
[16:14:29.011]         else {
[16:14:29.011]             ...future.result["stdout"] <- base::list(NULL)
[16:14:29.011]         }
[16:14:29.011]         base::close(...future.stdout)
[16:14:29.011]         ...future.stdout <- NULL
[16:14:29.011]     }
[16:14:29.011]     ...future.result$conditions <- ...future.conditions
[16:14:29.011]     ...future.result$finished <- base::Sys.time()
[16:14:29.011]     ...future.result
[16:14:29.011] }
[16:14:29.013] plan(): Setting new future strategy stack:
[16:14:29.013] List of future strategies:
[16:14:29.013] 1. sequential:
[16:14:29.013]    - args: function (..., envir = parent.frame())
[16:14:29.013]    - tweaked: FALSE
[16:14:29.013]    - call: NULL
[16:14:29.013] plan(): nbrOfWorkers() = 1
[16:14:29.014] plan(): Setting new future strategy stack:
[16:14:29.014] List of future strategies:
[16:14:29.014] 1. sequential:
[16:14:29.014]    - args: function (..., envir = parent.frame())
[16:14:29.014]    - tweaked: FALSE
[16:14:29.014]    - call: plan(strategy)
[16:14:29.014] plan(): nbrOfWorkers() = 1
[16:14:29.014] SequentialFuture started (and completed)
[16:14:29.014] - Launch lazy future ... done
[16:14:29.014] run() for ‘SequentialFuture’ ... done
[1] 42
- stdout = FALSE
[16:14:29.015] getGlobalsAndPackages() ...
[16:14:29.015] Searching for globals...
[16:14:29.019] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[16:14:29.019] Searching for globals ... DONE
[16:14:29.019] Resolving globals: FALSE
[16:14:29.019] 
[16:14:29.019] - packages: [1] ‘utils’
[16:14:29.019] getGlobalsAndPackages() ... DONE
[16:14:29.020] run() for ‘Future’ ...
[16:14:29.020] - state: ‘created’
[16:14:29.020] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:14:29.020] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:14:29.020] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:14:29.020]   - Field: ‘label’
[16:14:29.020]   - Field: ‘local’
[16:14:29.021]   - Field: ‘owner’
[16:14:29.021]   - Field: ‘envir’
[16:14:29.021]   - Field: ‘packages’
[16:14:29.021]   - Field: ‘gc’
[16:14:29.021]   - Field: ‘conditions’
[16:14:29.021]   - Field: ‘expr’
[16:14:29.021]   - Field: ‘uuid’
[16:14:29.021]   - Field: ‘seed’
[16:14:29.021]   - Field: ‘version’
[16:14:29.021]   - Field: ‘result’
[16:14:29.021]   - Field: ‘asynchronous’
[16:14:29.021]   - Field: ‘calls’
[16:14:29.022]   - Field: ‘globals’
[16:14:29.022]   - Field: ‘stdout’
[16:14:29.022]   - Field: ‘earlySignal’
[16:14:29.022]   - Field: ‘lazy’
[16:14:29.022]   - Field: ‘state’
[16:14:29.022] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:14:29.022] - Launch lazy future ...
[16:14:29.022] Packages needed by the future expression (n = 1): ‘utils’
[16:14:29.022] Packages needed by future strategies (n = 0): <none>
[16:14:29.023] {
[16:14:29.023]     {
[16:14:29.023]         {
[16:14:29.023]             ...future.startTime <- base::Sys.time()
[16:14:29.023]             {
[16:14:29.023]                 {
[16:14:29.023]                   {
[16:14:29.023]                     {
[16:14:29.023]                       base::local({
[16:14:29.023]                         has_future <- base::requireNamespace("future", 
[16:14:29.023]                           quietly = TRUE)
[16:14:29.023]                         if (has_future) {
[16:14:29.023]                           ns <- base::getNamespace("future")
[16:14:29.023]                           version <- ns[[".package"]][["version"]]
[16:14:29.023]                           if (is.null(version)) 
[16:14:29.023]                             version <- utils::packageVersion("future")
[16:14:29.023]                         }
[16:14:29.023]                         else {
[16:14:29.023]                           version <- NULL
[16:14:29.023]                         }
[16:14:29.023]                         if (!has_future || version < "1.8.0") {
[16:14:29.023]                           info <- base::c(r_version = base::gsub("R version ", 
[16:14:29.023]                             "", base::R.version$version.string), 
[16:14:29.023]                             platform = base::sprintf("%s (%s-bit)", 
[16:14:29.023]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:14:29.023]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:29.023]                               "release", "version")], collapse = " "), 
[16:14:29.023]                             hostname = base::Sys.info()[["nodename"]])
[16:14:29.023]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:14:29.023]                             info)
[16:14:29.023]                           info <- base::paste(info, collapse = "; ")
[16:14:29.023]                           if (!has_future) {
[16:14:29.023]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:29.023]                               info)
[16:14:29.023]                           }
[16:14:29.023]                           else {
[16:14:29.023]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:29.023]                               info, version)
[16:14:29.023]                           }
[16:14:29.023]                           base::stop(msg)
[16:14:29.023]                         }
[16:14:29.023]                       })
[16:14:29.023]                     }
[16:14:29.023]                     base::local({
[16:14:29.023]                       for (pkg in "utils") {
[16:14:29.023]                         base::loadNamespace(pkg)
[16:14:29.023]                         base::library(pkg, character.only = TRUE)
[16:14:29.023]                       }
[16:14:29.023]                     })
[16:14:29.023]                   }
[16:14:29.023]                   options(future.plan = NULL)
[16:14:29.023]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:29.023]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:29.023]                 }
[16:14:29.023]                 ...future.workdir <- getwd()
[16:14:29.023]             }
[16:14:29.023]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:29.023]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:29.023]         }
[16:14:29.023]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:29.023]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:29.023]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:29.023]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:29.023]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:29.023]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:29.023]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:29.023]             base::names(...future.oldOptions))
[16:14:29.023]     }
[16:14:29.023]     if (FALSE) {
[16:14:29.023]     }
[16:14:29.023]     else {
[16:14:29.023]         if (FALSE) {
[16:14:29.023]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:29.023]                 open = "w")
[16:14:29.023]         }
[16:14:29.023]         else {
[16:14:29.023]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:29.023]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:29.023]         }
[16:14:29.023]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:29.023]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:29.023]             base::sink(type = "output", split = FALSE)
[16:14:29.023]             base::close(...future.stdout)
[16:14:29.023]         }, add = TRUE)
[16:14:29.023]     }
[16:14:29.023]     ...future.frame <- base::sys.nframe()
[16:14:29.023]     ...future.conditions <- base::list()
[16:14:29.023]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:29.023]     if (FALSE) {
[16:14:29.023]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:29.023]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:29.023]     }
[16:14:29.023]     ...future.result <- base::tryCatch({
[16:14:29.023]         base::withCallingHandlers({
[16:14:29.023]             ...future.value <- base::withVisible(base::local({
[16:14:29.023]                 print(1:50)
[16:14:29.023]                 str(1:50)
[16:14:29.023]                 cat(letters, sep = "-")
[16:14:29.023]                 cat(1:6, collapse = "\n")
[16:14:29.023]                 write.table(datasets::iris[1:10, ], sep = "\t")
[16:14:29.023]                 42L
[16:14:29.023]             }))
[16:14:29.023]             future::FutureResult(value = ...future.value$value, 
[16:14:29.023]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:29.023]                   ...future.rng), globalenv = if (FALSE) 
[16:14:29.023]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:29.023]                     ...future.globalenv.names))
[16:14:29.023]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:29.023]         }, condition = base::local({
[16:14:29.023]             c <- base::c
[16:14:29.023]             inherits <- base::inherits
[16:14:29.023]             invokeRestart <- base::invokeRestart
[16:14:29.023]             length <- base::length
[16:14:29.023]             list <- base::list
[16:14:29.023]             seq.int <- base::seq.int
[16:14:29.023]             signalCondition <- base::signalCondition
[16:14:29.023]             sys.calls <- base::sys.calls
[16:14:29.023]             `[[` <- base::`[[`
[16:14:29.023]             `+` <- base::`+`
[16:14:29.023]             `<<-` <- base::`<<-`
[16:14:29.023]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:29.023]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:29.023]                   3L)]
[16:14:29.023]             }
[16:14:29.023]             function(cond) {
[16:14:29.023]                 is_error <- inherits(cond, "error")
[16:14:29.023]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:29.023]                   NULL)
[16:14:29.023]                 if (is_error) {
[16:14:29.023]                   sessionInformation <- function() {
[16:14:29.023]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:29.023]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:29.023]                       search = base::search(), system = base::Sys.info())
[16:14:29.023]                   }
[16:14:29.023]                   ...future.conditions[[length(...future.conditions) + 
[16:14:29.023]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:29.023]                     cond$call), session = sessionInformation(), 
[16:14:29.023]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:29.023]                   signalCondition(cond)
[16:14:29.023]                 }
[16:14:29.023]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:29.023]                 "immediateCondition"))) {
[16:14:29.023]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:29.023]                   ...future.conditions[[length(...future.conditions) + 
[16:14:29.023]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:29.023]                   if (TRUE && !signal) {
[16:14:29.023]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.023]                     {
[16:14:29.023]                       inherits <- base::inherits
[16:14:29.023]                       invokeRestart <- base::invokeRestart
[16:14:29.023]                       is.null <- base::is.null
[16:14:29.023]                       muffled <- FALSE
[16:14:29.023]                       if (inherits(cond, "message")) {
[16:14:29.023]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:29.023]                         if (muffled) 
[16:14:29.023]                           invokeRestart("muffleMessage")
[16:14:29.023]                       }
[16:14:29.023]                       else if (inherits(cond, "warning")) {
[16:14:29.023]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:29.023]                         if (muffled) 
[16:14:29.023]                           invokeRestart("muffleWarning")
[16:14:29.023]                       }
[16:14:29.023]                       else if (inherits(cond, "condition")) {
[16:14:29.023]                         if (!is.null(pattern)) {
[16:14:29.023]                           computeRestarts <- base::computeRestarts
[16:14:29.023]                           grepl <- base::grepl
[16:14:29.023]                           restarts <- computeRestarts(cond)
[16:14:29.023]                           for (restart in restarts) {
[16:14:29.023]                             name <- restart$name
[16:14:29.023]                             if (is.null(name)) 
[16:14:29.023]                               next
[16:14:29.023]                             if (!grepl(pattern, name)) 
[16:14:29.023]                               next
[16:14:29.023]                             invokeRestart(restart)
[16:14:29.023]                             muffled <- TRUE
[16:14:29.023]                             break
[16:14:29.023]                           }
[16:14:29.023]                         }
[16:14:29.023]                       }
[16:14:29.023]                       invisible(muffled)
[16:14:29.023]                     }
[16:14:29.023]                     muffleCondition(cond, pattern = "^muffle")
[16:14:29.023]                   }
[16:14:29.023]                 }
[16:14:29.023]                 else {
[16:14:29.023]                   if (TRUE) {
[16:14:29.023]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.023]                     {
[16:14:29.023]                       inherits <- base::inherits
[16:14:29.023]                       invokeRestart <- base::invokeRestart
[16:14:29.023]                       is.null <- base::is.null
[16:14:29.023]                       muffled <- FALSE
[16:14:29.023]                       if (inherits(cond, "message")) {
[16:14:29.023]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:29.023]                         if (muffled) 
[16:14:29.023]                           invokeRestart("muffleMessage")
[16:14:29.023]                       }
[16:14:29.023]                       else if (inherits(cond, "warning")) {
[16:14:29.023]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:29.023]                         if (muffled) 
[16:14:29.023]                           invokeRestart("muffleWarning")
[16:14:29.023]                       }
[16:14:29.023]                       else if (inherits(cond, "condition")) {
[16:14:29.023]                         if (!is.null(pattern)) {
[16:14:29.023]                           computeRestarts <- base::computeRestarts
[16:14:29.023]                           grepl <- base::grepl
[16:14:29.023]                           restarts <- computeRestarts(cond)
[16:14:29.023]                           for (restart in restarts) {
[16:14:29.023]                             name <- restart$name
[16:14:29.023]                             if (is.null(name)) 
[16:14:29.023]                               next
[16:14:29.023]                             if (!grepl(pattern, name)) 
[16:14:29.023]                               next
[16:14:29.023]                             invokeRestart(restart)
[16:14:29.023]                             muffled <- TRUE
[16:14:29.023]                             break
[16:14:29.023]                           }
[16:14:29.023]                         }
[16:14:29.023]                       }
[16:14:29.023]                       invisible(muffled)
[16:14:29.023]                     }
[16:14:29.023]                     muffleCondition(cond, pattern = "^muffle")
[16:14:29.023]                   }
[16:14:29.023]                 }
[16:14:29.023]             }
[16:14:29.023]         }))
[16:14:29.023]     }, error = function(ex) {
[16:14:29.023]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:29.023]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:29.023]                 ...future.rng), started = ...future.startTime, 
[16:14:29.023]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:29.023]             version = "1.8"), class = "FutureResult")
[16:14:29.023]     }, finally = {
[16:14:29.023]         if (!identical(...future.workdir, getwd())) 
[16:14:29.023]             setwd(...future.workdir)
[16:14:29.023]         {
[16:14:29.023]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:29.023]                 ...future.oldOptions$nwarnings <- NULL
[16:14:29.023]             }
[16:14:29.023]             base::options(...future.oldOptions)
[16:14:29.023]             if (.Platform$OS.type == "windows") {
[16:14:29.023]                 old_names <- names(...future.oldEnvVars)
[16:14:29.023]                 envs <- base::Sys.getenv()
[16:14:29.023]                 names <- names(envs)
[16:14:29.023]                 common <- intersect(names, old_names)
[16:14:29.023]                 added <- setdiff(names, old_names)
[16:14:29.023]                 removed <- setdiff(old_names, names)
[16:14:29.023]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:29.023]                   envs[common]]
[16:14:29.023]                 NAMES <- toupper(changed)
[16:14:29.023]                 args <- list()
[16:14:29.023]                 for (kk in seq_along(NAMES)) {
[16:14:29.023]                   name <- changed[[kk]]
[16:14:29.023]                   NAME <- NAMES[[kk]]
[16:14:29.023]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.023]                     next
[16:14:29.023]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:29.023]                 }
[16:14:29.023]                 NAMES <- toupper(added)
[16:14:29.023]                 for (kk in seq_along(NAMES)) {
[16:14:29.023]                   name <- added[[kk]]
[16:14:29.023]                   NAME <- NAMES[[kk]]
[16:14:29.023]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.023]                     next
[16:14:29.023]                   args[[name]] <- ""
[16:14:29.023]                 }
[16:14:29.023]                 NAMES <- toupper(removed)
[16:14:29.023]                 for (kk in seq_along(NAMES)) {
[16:14:29.023]                   name <- removed[[kk]]
[16:14:29.023]                   NAME <- NAMES[[kk]]
[16:14:29.023]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.023]                     next
[16:14:29.023]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:29.023]                 }
[16:14:29.023]                 if (length(args) > 0) 
[16:14:29.023]                   base::do.call(base::Sys.setenv, args = args)
[16:14:29.023]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:29.023]             }
[16:14:29.023]             else {
[16:14:29.023]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:29.023]             }
[16:14:29.023]             {
[16:14:29.023]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:29.023]                   0L) {
[16:14:29.023]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:29.023]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:29.023]                   base::options(opts)
[16:14:29.023]                 }
[16:14:29.023]                 {
[16:14:29.023]                   {
[16:14:29.023]                     NULL
[16:14:29.023]                     RNGkind("Mersenne-Twister")
[16:14:29.023]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:14:29.023]                       inherits = FALSE)
[16:14:29.023]                   }
[16:14:29.023]                   options(future.plan = NULL)
[16:14:29.023]                   if (is.na(NA_character_)) 
[16:14:29.023]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:29.023]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:29.023]                   future::plan(list(function (..., envir = parent.frame()) 
[16:14:29.023]                   {
[16:14:29.023]                     future <- SequentialFuture(..., envir = envir)
[16:14:29.023]                     if (!future$lazy) 
[16:14:29.023]                       future <- run(future)
[16:14:29.023]                     invisible(future)
[16:14:29.023]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:29.023]                 }
[16:14:29.023]             }
[16:14:29.023]         }
[16:14:29.023]     })
[16:14:29.023]     if (TRUE) {
[16:14:29.023]         base::sink(type = "output", split = FALSE)
[16:14:29.023]         if (FALSE) {
[16:14:29.023]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:29.023]         }
[16:14:29.023]         else {
[16:14:29.023]             ...future.result["stdout"] <- base::list(NULL)
[16:14:29.023]         }
[16:14:29.023]         base::close(...future.stdout)
[16:14:29.023]         ...future.stdout <- NULL
[16:14:29.023]     }
[16:14:29.023]     ...future.result$conditions <- ...future.conditions
[16:14:29.023]     ...future.result$finished <- base::Sys.time()
[16:14:29.023]     ...future.result
[16:14:29.023] }
[16:14:29.025] plan(): Setting new future strategy stack:
[16:14:29.025] List of future strategies:
[16:14:29.025] 1. sequential:
[16:14:29.025]    - args: function (..., envir = parent.frame())
[16:14:29.025]    - tweaked: FALSE
[16:14:29.025]    - call: NULL
[16:14:29.025] plan(): nbrOfWorkers() = 1
[16:14:29.026] plan(): Setting new future strategy stack:
[16:14:29.026] List of future strategies:
[16:14:29.026] 1. sequential:
[16:14:29.026]    - args: function (..., envir = parent.frame())
[16:14:29.026]    - tweaked: FALSE
[16:14:29.026]    - call: plan(strategy)
[16:14:29.027] plan(): nbrOfWorkers() = 1
[16:14:29.027] SequentialFuture started (and completed)
[16:14:29.027] - Launch lazy future ... done
[16:14:29.027] run() for ‘SequentialFuture’ ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-01-06 16:14:29"
 $ finished    : POSIXct[1:1], format: "2025-01-06 16:14:29"
 $ session_uuid: chr "f2024c80-2b92-d4d1-117a-ce2ef0d518b0"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "2729ef2608da"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "2729ef2608da" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 92308
  .. ..$ time  : POSIXct[1:1], format: "2025-01-06 16:14:28"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 3 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[16:14:29.035] getGlobalsAndPackages() ...
[16:14:29.035] Searching for globals...
[16:14:29.037] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[16:14:29.037] Searching for globals ... DONE
[16:14:29.038] Resolving globals: FALSE
[16:14:29.038] 
[16:14:29.038] - packages: [1] ‘utils’
[16:14:29.038] getGlobalsAndPackages() ... DONE
[16:14:29.038] run() for ‘Future’ ...
[16:14:29.038] - state: ‘created’
[16:14:29.039] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:14:29.039] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:14:29.039] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:14:29.039]   - Field: ‘label’
[16:14:29.039]   - Field: ‘local’
[16:14:29.039]   - Field: ‘owner’
[16:14:29.039]   - Field: ‘envir’
[16:14:29.040]   - Field: ‘packages’
[16:14:29.040]   - Field: ‘gc’
[16:14:29.040]   - Field: ‘conditions’
[16:14:29.041]   - Field: ‘expr’
[16:14:29.041]   - Field: ‘uuid’
[16:14:29.041]   - Field: ‘seed’
[16:14:29.041]   - Field: ‘version’
[16:14:29.041]   - Field: ‘result’
[16:14:29.041]   - Field: ‘asynchronous’
[16:14:29.041]   - Field: ‘calls’
[16:14:29.041]   - Field: ‘globals’
[16:14:29.041]   - Field: ‘stdout’
[16:14:29.041]   - Field: ‘earlySignal’
[16:14:29.041]   - Field: ‘lazy’
[16:14:29.042]   - Field: ‘state’
[16:14:29.042] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:14:29.042] - Launch lazy future ...
[16:14:29.042] Packages needed by the future expression (n = 1): ‘utils’
[16:14:29.042] Packages needed by future strategies (n = 0): <none>
[16:14:29.042] {
[16:14:29.042]     {
[16:14:29.042]         {
[16:14:29.042]             ...future.startTime <- base::Sys.time()
[16:14:29.042]             {
[16:14:29.042]                 {
[16:14:29.042]                   {
[16:14:29.042]                     {
[16:14:29.042]                       base::local({
[16:14:29.042]                         has_future <- base::requireNamespace("future", 
[16:14:29.042]                           quietly = TRUE)
[16:14:29.042]                         if (has_future) {
[16:14:29.042]                           ns <- base::getNamespace("future")
[16:14:29.042]                           version <- ns[[".package"]][["version"]]
[16:14:29.042]                           if (is.null(version)) 
[16:14:29.042]                             version <- utils::packageVersion("future")
[16:14:29.042]                         }
[16:14:29.042]                         else {
[16:14:29.042]                           version <- NULL
[16:14:29.042]                         }
[16:14:29.042]                         if (!has_future || version < "1.8.0") {
[16:14:29.042]                           info <- base::c(r_version = base::gsub("R version ", 
[16:14:29.042]                             "", base::R.version$version.string), 
[16:14:29.042]                             platform = base::sprintf("%s (%s-bit)", 
[16:14:29.042]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:14:29.042]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:29.042]                               "release", "version")], collapse = " "), 
[16:14:29.042]                             hostname = base::Sys.info()[["nodename"]])
[16:14:29.042]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:14:29.042]                             info)
[16:14:29.042]                           info <- base::paste(info, collapse = "; ")
[16:14:29.042]                           if (!has_future) {
[16:14:29.042]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:29.042]                               info)
[16:14:29.042]                           }
[16:14:29.042]                           else {
[16:14:29.042]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:29.042]                               info, version)
[16:14:29.042]                           }
[16:14:29.042]                           base::stop(msg)
[16:14:29.042]                         }
[16:14:29.042]                       })
[16:14:29.042]                     }
[16:14:29.042]                     base::local({
[16:14:29.042]                       for (pkg in "utils") {
[16:14:29.042]                         base::loadNamespace(pkg)
[16:14:29.042]                         base::library(pkg, character.only = TRUE)
[16:14:29.042]                       }
[16:14:29.042]                     })
[16:14:29.042]                   }
[16:14:29.042]                   options(future.plan = NULL)
[16:14:29.042]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:29.042]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:29.042]                 }
[16:14:29.042]                 ...future.workdir <- getwd()
[16:14:29.042]             }
[16:14:29.042]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:29.042]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:29.042]         }
[16:14:29.042]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:29.042]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:29.042]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:29.042]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:29.042]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:29.042]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:29.042]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:29.042]             base::names(...future.oldOptions))
[16:14:29.042]     }
[16:14:29.042]     if (FALSE) {
[16:14:29.042]     }
[16:14:29.042]     else {
[16:14:29.042]         if (FALSE) {
[16:14:29.042]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:29.042]                 open = "w")
[16:14:29.042]         }
[16:14:29.042]         else {
[16:14:29.042]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:29.042]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:29.042]         }
[16:14:29.042]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:29.042]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:29.042]             base::sink(type = "output", split = FALSE)
[16:14:29.042]             base::close(...future.stdout)
[16:14:29.042]         }, add = TRUE)
[16:14:29.042]     }
[16:14:29.042]     ...future.frame <- base::sys.nframe()
[16:14:29.042]     ...future.conditions <- base::list()
[16:14:29.042]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:29.042]     if (FALSE) {
[16:14:29.042]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:29.042]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:29.042]     }
[16:14:29.042]     ...future.result <- base::tryCatch({
[16:14:29.042]         base::withCallingHandlers({
[16:14:29.042]             ...future.value <- base::withVisible(base::local({
[16:14:29.042]                 print(1:50)
[16:14:29.042]                 str(1:50)
[16:14:29.042]                 cat(letters, sep = "-")
[16:14:29.042]                 cat(1:6, collapse = "\n")
[16:14:29.042]                 write.table(datasets::iris[1:10, ], sep = "\t")
[16:14:29.042]                 42L
[16:14:29.042]             }))
[16:14:29.042]             future::FutureResult(value = ...future.value$value, 
[16:14:29.042]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:29.042]                   ...future.rng), globalenv = if (FALSE) 
[16:14:29.042]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:29.042]                     ...future.globalenv.names))
[16:14:29.042]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:29.042]         }, condition = base::local({
[16:14:29.042]             c <- base::c
[16:14:29.042]             inherits <- base::inherits
[16:14:29.042]             invokeRestart <- base::invokeRestart
[16:14:29.042]             length <- base::length
[16:14:29.042]             list <- base::list
[16:14:29.042]             seq.int <- base::seq.int
[16:14:29.042]             signalCondition <- base::signalCondition
[16:14:29.042]             sys.calls <- base::sys.calls
[16:14:29.042]             `[[` <- base::`[[`
[16:14:29.042]             `+` <- base::`+`
[16:14:29.042]             `<<-` <- base::`<<-`
[16:14:29.042]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:29.042]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:29.042]                   3L)]
[16:14:29.042]             }
[16:14:29.042]             function(cond) {
[16:14:29.042]                 is_error <- inherits(cond, "error")
[16:14:29.042]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:29.042]                   NULL)
[16:14:29.042]                 if (is_error) {
[16:14:29.042]                   sessionInformation <- function() {
[16:14:29.042]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:29.042]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:29.042]                       search = base::search(), system = base::Sys.info())
[16:14:29.042]                   }
[16:14:29.042]                   ...future.conditions[[length(...future.conditions) + 
[16:14:29.042]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:29.042]                     cond$call), session = sessionInformation(), 
[16:14:29.042]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:29.042]                   signalCondition(cond)
[16:14:29.042]                 }
[16:14:29.042]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:29.042]                 "immediateCondition"))) {
[16:14:29.042]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:29.042]                   ...future.conditions[[length(...future.conditions) + 
[16:14:29.042]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:29.042]                   if (TRUE && !signal) {
[16:14:29.042]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.042]                     {
[16:14:29.042]                       inherits <- base::inherits
[16:14:29.042]                       invokeRestart <- base::invokeRestart
[16:14:29.042]                       is.null <- base::is.null
[16:14:29.042]                       muffled <- FALSE
[16:14:29.042]                       if (inherits(cond, "message")) {
[16:14:29.042]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:29.042]                         if (muffled) 
[16:14:29.042]                           invokeRestart("muffleMessage")
[16:14:29.042]                       }
[16:14:29.042]                       else if (inherits(cond, "warning")) {
[16:14:29.042]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:29.042]                         if (muffled) 
[16:14:29.042]                           invokeRestart("muffleWarning")
[16:14:29.042]                       }
[16:14:29.042]                       else if (inherits(cond, "condition")) {
[16:14:29.042]                         if (!is.null(pattern)) {
[16:14:29.042]                           computeRestarts <- base::computeRestarts
[16:14:29.042]                           grepl <- base::grepl
[16:14:29.042]                           restarts <- computeRestarts(cond)
[16:14:29.042]                           for (restart in restarts) {
[16:14:29.042]                             name <- restart$name
[16:14:29.042]                             if (is.null(name)) 
[16:14:29.042]                               next
[16:14:29.042]                             if (!grepl(pattern, name)) 
[16:14:29.042]                               next
[16:14:29.042]                             invokeRestart(restart)
[16:14:29.042]                             muffled <- TRUE
[16:14:29.042]                             break
[16:14:29.042]                           }
[16:14:29.042]                         }
[16:14:29.042]                       }
[16:14:29.042]                       invisible(muffled)
[16:14:29.042]                     }
[16:14:29.042]                     muffleCondition(cond, pattern = "^muffle")
[16:14:29.042]                   }
[16:14:29.042]                 }
[16:14:29.042]                 else {
[16:14:29.042]                   if (TRUE) {
[16:14:29.042]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.042]                     {
[16:14:29.042]                       inherits <- base::inherits
[16:14:29.042]                       invokeRestart <- base::invokeRestart
[16:14:29.042]                       is.null <- base::is.null
[16:14:29.042]                       muffled <- FALSE
[16:14:29.042]                       if (inherits(cond, "message")) {
[16:14:29.042]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:29.042]                         if (muffled) 
[16:14:29.042]                           invokeRestart("muffleMessage")
[16:14:29.042]                       }
[16:14:29.042]                       else if (inherits(cond, "warning")) {
[16:14:29.042]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:29.042]                         if (muffled) 
[16:14:29.042]                           invokeRestart("muffleWarning")
[16:14:29.042]                       }
[16:14:29.042]                       else if (inherits(cond, "condition")) {
[16:14:29.042]                         if (!is.null(pattern)) {
[16:14:29.042]                           computeRestarts <- base::computeRestarts
[16:14:29.042]                           grepl <- base::grepl
[16:14:29.042]                           restarts <- computeRestarts(cond)
[16:14:29.042]                           for (restart in restarts) {
[16:14:29.042]                             name <- restart$name
[16:14:29.042]                             if (is.null(name)) 
[16:14:29.042]                               next
[16:14:29.042]                             if (!grepl(pattern, name)) 
[16:14:29.042]                               next
[16:14:29.042]                             invokeRestart(restart)
[16:14:29.042]                             muffled <- TRUE
[16:14:29.042]                             break
[16:14:29.042]                           }
[16:14:29.042]                         }
[16:14:29.042]                       }
[16:14:29.042]                       invisible(muffled)
[16:14:29.042]                     }
[16:14:29.042]                     muffleCondition(cond, pattern = "^muffle")
[16:14:29.042]                   }
[16:14:29.042]                 }
[16:14:29.042]             }
[16:14:29.042]         }))
[16:14:29.042]     }, error = function(ex) {
[16:14:29.042]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:29.042]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:29.042]                 ...future.rng), started = ...future.startTime, 
[16:14:29.042]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:29.042]             version = "1.8"), class = "FutureResult")
[16:14:29.042]     }, finally = {
[16:14:29.042]         if (!identical(...future.workdir, getwd())) 
[16:14:29.042]             setwd(...future.workdir)
[16:14:29.042]         {
[16:14:29.042]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:29.042]                 ...future.oldOptions$nwarnings <- NULL
[16:14:29.042]             }
[16:14:29.042]             base::options(...future.oldOptions)
[16:14:29.042]             if (.Platform$OS.type == "windows") {
[16:14:29.042]                 old_names <- names(...future.oldEnvVars)
[16:14:29.042]                 envs <- base::Sys.getenv()
[16:14:29.042]                 names <- names(envs)
[16:14:29.042]                 common <- intersect(names, old_names)
[16:14:29.042]                 added <- setdiff(names, old_names)
[16:14:29.042]                 removed <- setdiff(old_names, names)
[16:14:29.042]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:29.042]                   envs[common]]
[16:14:29.042]                 NAMES <- toupper(changed)
[16:14:29.042]                 args <- list()
[16:14:29.042]                 for (kk in seq_along(NAMES)) {
[16:14:29.042]                   name <- changed[[kk]]
[16:14:29.042]                   NAME <- NAMES[[kk]]
[16:14:29.042]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.042]                     next
[16:14:29.042]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:29.042]                 }
[16:14:29.042]                 NAMES <- toupper(added)
[16:14:29.042]                 for (kk in seq_along(NAMES)) {
[16:14:29.042]                   name <- added[[kk]]
[16:14:29.042]                   NAME <- NAMES[[kk]]
[16:14:29.042]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.042]                     next
[16:14:29.042]                   args[[name]] <- ""
[16:14:29.042]                 }
[16:14:29.042]                 NAMES <- toupper(removed)
[16:14:29.042]                 for (kk in seq_along(NAMES)) {
[16:14:29.042]                   name <- removed[[kk]]
[16:14:29.042]                   NAME <- NAMES[[kk]]
[16:14:29.042]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.042]                     next
[16:14:29.042]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:29.042]                 }
[16:14:29.042]                 if (length(args) > 0) 
[16:14:29.042]                   base::do.call(base::Sys.setenv, args = args)
[16:14:29.042]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:29.042]             }
[16:14:29.042]             else {
[16:14:29.042]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:29.042]             }
[16:14:29.042]             {
[16:14:29.042]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:29.042]                   0L) {
[16:14:29.042]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:29.042]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:29.042]                   base::options(opts)
[16:14:29.042]                 }
[16:14:29.042]                 {
[16:14:29.042]                   {
[16:14:29.042]                     NULL
[16:14:29.042]                     RNGkind("Mersenne-Twister")
[16:14:29.042]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:14:29.042]                       inherits = FALSE)
[16:14:29.042]                   }
[16:14:29.042]                   options(future.plan = NULL)
[16:14:29.042]                   if (is.na(NA_character_)) 
[16:14:29.042]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:29.042]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:29.042]                   future::plan(list(function (..., envir = parent.frame()) 
[16:14:29.042]                   {
[16:14:29.042]                     future <- SequentialFuture(..., envir = envir)
[16:14:29.042]                     if (!future$lazy) 
[16:14:29.042]                       future <- run(future)
[16:14:29.042]                     invisible(future)
[16:14:29.042]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:29.042]                 }
[16:14:29.042]             }
[16:14:29.042]         }
[16:14:29.042]     })
[16:14:29.042]     if (TRUE) {
[16:14:29.042]         base::sink(type = "output", split = FALSE)
[16:14:29.042]         if (FALSE) {
[16:14:29.042]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:29.042]         }
[16:14:29.042]         else {
[16:14:29.042]             ...future.result["stdout"] <- base::list(NULL)
[16:14:29.042]         }
[16:14:29.042]         base::close(...future.stdout)
[16:14:29.042]         ...future.stdout <- NULL
[16:14:29.042]     }
[16:14:29.042]     ...future.result$conditions <- ...future.conditions
[16:14:29.042]     ...future.result$finished <- base::Sys.time()
[16:14:29.042]     ...future.result
[16:14:29.042] }
[16:14:29.044] plan(): Setting new future strategy stack:
[16:14:29.044] List of future strategies:
[16:14:29.044] 1. sequential:
[16:14:29.044]    - args: function (..., envir = parent.frame())
[16:14:29.044]    - tweaked: FALSE
[16:14:29.044]    - call: NULL
[16:14:29.045] plan(): nbrOfWorkers() = 1
[16:14:29.046] plan(): Setting new future strategy stack:
[16:14:29.046] List of future strategies:
[16:14:29.046] 1. sequential:
[16:14:29.046]    - args: function (..., envir = parent.frame())
[16:14:29.046]    - tweaked: FALSE
[16:14:29.046]    - call: plan(strategy)
[16:14:29.047] plan(): nbrOfWorkers() = 1
[16:14:29.047] SequentialFuture started (and completed)
[16:14:29.047] - Launch lazy future ... done
[16:14:29.047] run() for ‘SequentialFuture’ ... done
- stdout = structure(TRUE, drop = TRUE)
[16:14:29.047] getGlobalsAndPackages() ...
[16:14:29.047] Searching for globals...
[16:14:29.048] - globals found: [1] ‘print’
[16:14:29.048] Searching for globals ... DONE
[16:14:29.048] Resolving globals: FALSE
[16:14:29.048] 
[16:14:29.048] 
[16:14:29.048] getGlobalsAndPackages() ... DONE
[16:14:29.049] run() for ‘Future’ ...
[16:14:29.049] - state: ‘created’
[16:14:29.049] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:14:29.049] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:14:29.049] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:14:29.049]   - Field: ‘label’
[16:14:29.049]   - Field: ‘local’
[16:14:29.049]   - Field: ‘owner’
[16:14:29.050]   - Field: ‘envir’
[16:14:29.050]   - Field: ‘packages’
[16:14:29.050]   - Field: ‘gc’
[16:14:29.050]   - Field: ‘conditions’
[16:14:29.050]   - Field: ‘expr’
[16:14:29.050]   - Field: ‘uuid’
[16:14:29.050]   - Field: ‘seed’
[16:14:29.050]   - Field: ‘version’
[16:14:29.050]   - Field: ‘result’
[16:14:29.050]   - Field: ‘asynchronous’
[16:14:29.050]   - Field: ‘calls’
[16:14:29.050]   - Field: ‘globals’
[16:14:29.051]   - Field: ‘stdout’
[16:14:29.051]   - Field: ‘earlySignal’
[16:14:29.051]   - Field: ‘lazy’
[16:14:29.051]   - Field: ‘state’
[16:14:29.051] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:14:29.051] - Launch lazy future ...
[16:14:29.051] Packages needed by the future expression (n = 0): <none>
[16:14:29.051] Packages needed by future strategies (n = 0): <none>
[16:14:29.052] {
[16:14:29.052]     {
[16:14:29.052]         {
[16:14:29.052]             ...future.startTime <- base::Sys.time()
[16:14:29.052]             {
[16:14:29.052]                 {
[16:14:29.052]                   {
[16:14:29.052]                     base::local({
[16:14:29.052]                       has_future <- base::requireNamespace("future", 
[16:14:29.052]                         quietly = TRUE)
[16:14:29.052]                       if (has_future) {
[16:14:29.052]                         ns <- base::getNamespace("future")
[16:14:29.052]                         version <- ns[[".package"]][["version"]]
[16:14:29.052]                         if (is.null(version)) 
[16:14:29.052]                           version <- utils::packageVersion("future")
[16:14:29.052]                       }
[16:14:29.052]                       else {
[16:14:29.052]                         version <- NULL
[16:14:29.052]                       }
[16:14:29.052]                       if (!has_future || version < "1.8.0") {
[16:14:29.052]                         info <- base::c(r_version = base::gsub("R version ", 
[16:14:29.052]                           "", base::R.version$version.string), 
[16:14:29.052]                           platform = base::sprintf("%s (%s-bit)", 
[16:14:29.052]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:14:29.052]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:29.052]                             "release", "version")], collapse = " "), 
[16:14:29.052]                           hostname = base::Sys.info()[["nodename"]])
[16:14:29.052]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:14:29.052]                           info)
[16:14:29.052]                         info <- base::paste(info, collapse = "; ")
[16:14:29.052]                         if (!has_future) {
[16:14:29.052]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:29.052]                             info)
[16:14:29.052]                         }
[16:14:29.052]                         else {
[16:14:29.052]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:29.052]                             info, version)
[16:14:29.052]                         }
[16:14:29.052]                         base::stop(msg)
[16:14:29.052]                       }
[16:14:29.052]                     })
[16:14:29.052]                   }
[16:14:29.052]                   options(future.plan = NULL)
[16:14:29.052]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:29.052]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:29.052]                 }
[16:14:29.052]                 ...future.workdir <- getwd()
[16:14:29.052]             }
[16:14:29.052]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:29.052]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:29.052]         }
[16:14:29.052]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:29.052]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:29.052]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:29.052]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:29.052]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:29.052]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:29.052]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:29.052]             base::names(...future.oldOptions))
[16:14:29.052]     }
[16:14:29.052]     if (FALSE) {
[16:14:29.052]     }
[16:14:29.052]     else {
[16:14:29.052]         if (TRUE) {
[16:14:29.052]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:29.052]                 open = "w")
[16:14:29.052]         }
[16:14:29.052]         else {
[16:14:29.052]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:29.052]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:29.052]         }
[16:14:29.052]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:29.052]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:29.052]             base::sink(type = "output", split = FALSE)
[16:14:29.052]             base::close(...future.stdout)
[16:14:29.052]         }, add = TRUE)
[16:14:29.052]     }
[16:14:29.052]     ...future.frame <- base::sys.nframe()
[16:14:29.052]     ...future.conditions <- base::list()
[16:14:29.052]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:29.052]     if (FALSE) {
[16:14:29.052]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:29.052]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:29.052]     }
[16:14:29.052]     ...future.result <- base::tryCatch({
[16:14:29.052]         base::withCallingHandlers({
[16:14:29.052]             ...future.value <- base::withVisible(base::local(print(42)))
[16:14:29.052]             future::FutureResult(value = ...future.value$value, 
[16:14:29.052]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:29.052]                   ...future.rng), globalenv = if (FALSE) 
[16:14:29.052]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:29.052]                     ...future.globalenv.names))
[16:14:29.052]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:29.052]         }, condition = base::local({
[16:14:29.052]             c <- base::c
[16:14:29.052]             inherits <- base::inherits
[16:14:29.052]             invokeRestart <- base::invokeRestart
[16:14:29.052]             length <- base::length
[16:14:29.052]             list <- base::list
[16:14:29.052]             seq.int <- base::seq.int
[16:14:29.052]             signalCondition <- base::signalCondition
[16:14:29.052]             sys.calls <- base::sys.calls
[16:14:29.052]             `[[` <- base::`[[`
[16:14:29.052]             `+` <- base::`+`
[16:14:29.052]             `<<-` <- base::`<<-`
[16:14:29.052]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:29.052]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:29.052]                   3L)]
[16:14:29.052]             }
[16:14:29.052]             function(cond) {
[16:14:29.052]                 is_error <- inherits(cond, "error")
[16:14:29.052]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:29.052]                   NULL)
[16:14:29.052]                 if (is_error) {
[16:14:29.052]                   sessionInformation <- function() {
[16:14:29.052]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:29.052]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:29.052]                       search = base::search(), system = base::Sys.info())
[16:14:29.052]                   }
[16:14:29.052]                   ...future.conditions[[length(...future.conditions) + 
[16:14:29.052]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:29.052]                     cond$call), session = sessionInformation(), 
[16:14:29.052]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:29.052]                   signalCondition(cond)
[16:14:29.052]                 }
[16:14:29.052]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:29.052]                 "immediateCondition"))) {
[16:14:29.052]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:29.052]                   ...future.conditions[[length(...future.conditions) + 
[16:14:29.052]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:29.052]                   if (TRUE && !signal) {
[16:14:29.052]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.052]                     {
[16:14:29.052]                       inherits <- base::inherits
[16:14:29.052]                       invokeRestart <- base::invokeRestart
[16:14:29.052]                       is.null <- base::is.null
[16:14:29.052]                       muffled <- FALSE
[16:14:29.052]                       if (inherits(cond, "message")) {
[16:14:29.052]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:29.052]                         if (muffled) 
[16:14:29.052]                           invokeRestart("muffleMessage")
[16:14:29.052]                       }
[16:14:29.052]                       else if (inherits(cond, "warning")) {
[16:14:29.052]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:29.052]                         if (muffled) 
[16:14:29.052]                           invokeRestart("muffleWarning")
[16:14:29.052]                       }
[16:14:29.052]                       else if (inherits(cond, "condition")) {
[16:14:29.052]                         if (!is.null(pattern)) {
[16:14:29.052]                           computeRestarts <- base::computeRestarts
[16:14:29.052]                           grepl <- base::grepl
[16:14:29.052]                           restarts <- computeRestarts(cond)
[16:14:29.052]                           for (restart in restarts) {
[16:14:29.052]                             name <- restart$name
[16:14:29.052]                             if (is.null(name)) 
[16:14:29.052]                               next
[16:14:29.052]                             if (!grepl(pattern, name)) 
[16:14:29.052]                               next
[16:14:29.052]                             invokeRestart(restart)
[16:14:29.052]                             muffled <- TRUE
[16:14:29.052]                             break
[16:14:29.052]                           }
[16:14:29.052]                         }
[16:14:29.052]                       }
[16:14:29.052]                       invisible(muffled)
[16:14:29.052]                     }
[16:14:29.052]                     muffleCondition(cond, pattern = "^muffle")
[16:14:29.052]                   }
[16:14:29.052]                 }
[16:14:29.052]                 else {
[16:14:29.052]                   if (TRUE) {
[16:14:29.052]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.052]                     {
[16:14:29.052]                       inherits <- base::inherits
[16:14:29.052]                       invokeRestart <- base::invokeRestart
[16:14:29.052]                       is.null <- base::is.null
[16:14:29.052]                       muffled <- FALSE
[16:14:29.052]                       if (inherits(cond, "message")) {
[16:14:29.052]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:29.052]                         if (muffled) 
[16:14:29.052]                           invokeRestart("muffleMessage")
[16:14:29.052]                       }
[16:14:29.052]                       else if (inherits(cond, "warning")) {
[16:14:29.052]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:29.052]                         if (muffled) 
[16:14:29.052]                           invokeRestart("muffleWarning")
[16:14:29.052]                       }
[16:14:29.052]                       else if (inherits(cond, "condition")) {
[16:14:29.052]                         if (!is.null(pattern)) {
[16:14:29.052]                           computeRestarts <- base::computeRestarts
[16:14:29.052]                           grepl <- base::grepl
[16:14:29.052]                           restarts <- computeRestarts(cond)
[16:14:29.052]                           for (restart in restarts) {
[16:14:29.052]                             name <- restart$name
[16:14:29.052]                             if (is.null(name)) 
[16:14:29.052]                               next
[16:14:29.052]                             if (!grepl(pattern, name)) 
[16:14:29.052]                               next
[16:14:29.052]                             invokeRestart(restart)
[16:14:29.052]                             muffled <- TRUE
[16:14:29.052]                             break
[16:14:29.052]                           }
[16:14:29.052]                         }
[16:14:29.052]                       }
[16:14:29.052]                       invisible(muffled)
[16:14:29.052]                     }
[16:14:29.052]                     muffleCondition(cond, pattern = "^muffle")
[16:14:29.052]                   }
[16:14:29.052]                 }
[16:14:29.052]             }
[16:14:29.052]         }))
[16:14:29.052]     }, error = function(ex) {
[16:14:29.052]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:29.052]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:29.052]                 ...future.rng), started = ...future.startTime, 
[16:14:29.052]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:29.052]             version = "1.8"), class = "FutureResult")
[16:14:29.052]     }, finally = {
[16:14:29.052]         if (!identical(...future.workdir, getwd())) 
[16:14:29.052]             setwd(...future.workdir)
[16:14:29.052]         {
[16:14:29.052]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:29.052]                 ...future.oldOptions$nwarnings <- NULL
[16:14:29.052]             }
[16:14:29.052]             base::options(...future.oldOptions)
[16:14:29.052]             if (.Platform$OS.type == "windows") {
[16:14:29.052]                 old_names <- names(...future.oldEnvVars)
[16:14:29.052]                 envs <- base::Sys.getenv()
[16:14:29.052]                 names <- names(envs)
[16:14:29.052]                 common <- intersect(names, old_names)
[16:14:29.052]                 added <- setdiff(names, old_names)
[16:14:29.052]                 removed <- setdiff(old_names, names)
[16:14:29.052]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:29.052]                   envs[common]]
[16:14:29.052]                 NAMES <- toupper(changed)
[16:14:29.052]                 args <- list()
[16:14:29.052]                 for (kk in seq_along(NAMES)) {
[16:14:29.052]                   name <- changed[[kk]]
[16:14:29.052]                   NAME <- NAMES[[kk]]
[16:14:29.052]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.052]                     next
[16:14:29.052]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:29.052]                 }
[16:14:29.052]                 NAMES <- toupper(added)
[16:14:29.052]                 for (kk in seq_along(NAMES)) {
[16:14:29.052]                   name <- added[[kk]]
[16:14:29.052]                   NAME <- NAMES[[kk]]
[16:14:29.052]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.052]                     next
[16:14:29.052]                   args[[name]] <- ""
[16:14:29.052]                 }
[16:14:29.052]                 NAMES <- toupper(removed)
[16:14:29.052]                 for (kk in seq_along(NAMES)) {
[16:14:29.052]                   name <- removed[[kk]]
[16:14:29.052]                   NAME <- NAMES[[kk]]
[16:14:29.052]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.052]                     next
[16:14:29.052]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:29.052]                 }
[16:14:29.052]                 if (length(args) > 0) 
[16:14:29.052]                   base::do.call(base::Sys.setenv, args = args)
[16:14:29.052]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:29.052]             }
[16:14:29.052]             else {
[16:14:29.052]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:29.052]             }
[16:14:29.052]             {
[16:14:29.052]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:29.052]                   0L) {
[16:14:29.052]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:29.052]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:29.052]                   base::options(opts)
[16:14:29.052]                 }
[16:14:29.052]                 {
[16:14:29.052]                   {
[16:14:29.052]                     NULL
[16:14:29.052]                     RNGkind("Mersenne-Twister")
[16:14:29.052]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:14:29.052]                       inherits = FALSE)
[16:14:29.052]                   }
[16:14:29.052]                   options(future.plan = NULL)
[16:14:29.052]                   if (is.na(NA_character_)) 
[16:14:29.052]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:29.052]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:29.052]                   future::plan(list(function (..., envir = parent.frame()) 
[16:14:29.052]                   {
[16:14:29.052]                     future <- SequentialFuture(..., envir = envir)
[16:14:29.052]                     if (!future$lazy) 
[16:14:29.052]                       future <- run(future)
[16:14:29.052]                     invisible(future)
[16:14:29.052]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:29.052]                 }
[16:14:29.052]             }
[16:14:29.052]         }
[16:14:29.052]     })
[16:14:29.052]     if (TRUE) {
[16:14:29.052]         base::sink(type = "output", split = FALSE)
[16:14:29.052]         if (TRUE) {
[16:14:29.052]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:29.052]         }
[16:14:29.052]         else {
[16:14:29.052]             ...future.result["stdout"] <- base::list(NULL)
[16:14:29.052]         }
[16:14:29.052]         base::close(...future.stdout)
[16:14:29.052]         ...future.stdout <- NULL
[16:14:29.052]     }
[16:14:29.052]     ...future.result$conditions <- ...future.conditions
[16:14:29.052]     ...future.result$finished <- base::Sys.time()
[16:14:29.052]     ...future.result
[16:14:29.052] }
[16:14:29.053] plan(): Setting new future strategy stack:
[16:14:29.053] List of future strategies:
[16:14:29.053] 1. sequential:
[16:14:29.053]    - args: function (..., envir = parent.frame())
[16:14:29.053]    - tweaked: FALSE
[16:14:29.053]    - call: NULL
[16:14:29.054] plan(): nbrOfWorkers() = 1
[16:14:29.054] plan(): Setting new future strategy stack:
[16:14:29.055] List of future strategies:
[16:14:29.055] 1. sequential:
[16:14:29.055]    - args: function (..., envir = parent.frame())
[16:14:29.055]    - tweaked: FALSE
[16:14:29.055]    - call: plan(strategy)
[16:14:29.055] plan(): nbrOfWorkers() = 1
[16:14:29.055] SequentialFuture started (and completed)
[16:14:29.055] - Launch lazy future ... done
[16:14:29.055] run() for ‘SequentialFuture’ ... done
[1] 42
- stdout = NA
[16:14:29.056] getGlobalsAndPackages() ...
[16:14:29.056] Searching for globals...
[16:14:29.058] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[16:14:29.058] Searching for globals ... DONE
[16:14:29.059] Resolving globals: FALSE
[16:14:29.059] 
[16:14:29.059] - packages: [1] ‘utils’
[16:14:29.059] getGlobalsAndPackages() ... DONE
[16:14:29.059] run() for ‘Future’ ...
[16:14:29.059] - state: ‘created’
[16:14:29.060] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:14:29.060] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:14:29.060] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:14:29.060]   - Field: ‘label’
[16:14:29.060]   - Field: ‘local’
[16:14:29.060]   - Field: ‘owner’
[16:14:29.060]   - Field: ‘envir’
[16:14:29.060]   - Field: ‘packages’
[16:14:29.061]   - Field: ‘gc’
[16:14:29.061]   - Field: ‘conditions’
[16:14:29.061]   - Field: ‘expr’
[16:14:29.061]   - Field: ‘uuid’
[16:14:29.061]   - Field: ‘seed’
[16:14:29.061]   - Field: ‘version’
[16:14:29.061]   - Field: ‘result’
[16:14:29.061]   - Field: ‘asynchronous’
[16:14:29.061]   - Field: ‘calls’
[16:14:29.061]   - Field: ‘globals’
[16:14:29.061]   - Field: ‘stdout’
[16:14:29.061]   - Field: ‘earlySignal’
[16:14:29.062]   - Field: ‘lazy’
[16:14:29.062]   - Field: ‘state’
[16:14:29.062] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:14:29.062] - Launch lazy future ...
[16:14:29.062] Packages needed by the future expression (n = 1): ‘utils’
[16:14:29.062] Packages needed by future strategies (n = 0): <none>
[16:14:29.063] {
[16:14:29.063]     {
[16:14:29.063]         {
[16:14:29.063]             ...future.startTime <- base::Sys.time()
[16:14:29.063]             {
[16:14:29.063]                 {
[16:14:29.063]                   {
[16:14:29.063]                     {
[16:14:29.063]                       base::local({
[16:14:29.063]                         has_future <- base::requireNamespace("future", 
[16:14:29.063]                           quietly = TRUE)
[16:14:29.063]                         if (has_future) {
[16:14:29.063]                           ns <- base::getNamespace("future")
[16:14:29.063]                           version <- ns[[".package"]][["version"]]
[16:14:29.063]                           if (is.null(version)) 
[16:14:29.063]                             version <- utils::packageVersion("future")
[16:14:29.063]                         }
[16:14:29.063]                         else {
[16:14:29.063]                           version <- NULL
[16:14:29.063]                         }
[16:14:29.063]                         if (!has_future || version < "1.8.0") {
[16:14:29.063]                           info <- base::c(r_version = base::gsub("R version ", 
[16:14:29.063]                             "", base::R.version$version.string), 
[16:14:29.063]                             platform = base::sprintf("%s (%s-bit)", 
[16:14:29.063]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:14:29.063]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:29.063]                               "release", "version")], collapse = " "), 
[16:14:29.063]                             hostname = base::Sys.info()[["nodename"]])
[16:14:29.063]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:14:29.063]                             info)
[16:14:29.063]                           info <- base::paste(info, collapse = "; ")
[16:14:29.063]                           if (!has_future) {
[16:14:29.063]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:29.063]                               info)
[16:14:29.063]                           }
[16:14:29.063]                           else {
[16:14:29.063]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:29.063]                               info, version)
[16:14:29.063]                           }
[16:14:29.063]                           base::stop(msg)
[16:14:29.063]                         }
[16:14:29.063]                       })
[16:14:29.063]                     }
[16:14:29.063]                     base::local({
[16:14:29.063]                       for (pkg in "utils") {
[16:14:29.063]                         base::loadNamespace(pkg)
[16:14:29.063]                         base::library(pkg, character.only = TRUE)
[16:14:29.063]                       }
[16:14:29.063]                     })
[16:14:29.063]                   }
[16:14:29.063]                   options(future.plan = NULL)
[16:14:29.063]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:29.063]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:29.063]                 }
[16:14:29.063]                 ...future.workdir <- getwd()
[16:14:29.063]             }
[16:14:29.063]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:29.063]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:29.063]         }
[16:14:29.063]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:29.063]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:29.063]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:29.063]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:29.063]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:29.063]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:29.063]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:29.063]             base::names(...future.oldOptions))
[16:14:29.063]     }
[16:14:29.063]     if (TRUE) {
[16:14:29.063]     }
[16:14:29.063]     else {
[16:14:29.063]         if (NA) {
[16:14:29.063]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:29.063]                 open = "w")
[16:14:29.063]         }
[16:14:29.063]         else {
[16:14:29.063]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:29.063]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:29.063]         }
[16:14:29.063]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:29.063]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:29.063]             base::sink(type = "output", split = FALSE)
[16:14:29.063]             base::close(...future.stdout)
[16:14:29.063]         }, add = TRUE)
[16:14:29.063]     }
[16:14:29.063]     ...future.frame <- base::sys.nframe()
[16:14:29.063]     ...future.conditions <- base::list()
[16:14:29.063]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:29.063]     if (FALSE) {
[16:14:29.063]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:29.063]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:29.063]     }
[16:14:29.063]     ...future.result <- base::tryCatch({
[16:14:29.063]         base::withCallingHandlers({
[16:14:29.063]             ...future.value <- base::withVisible(base::local({
[16:14:29.063]                 print(1:50)
[16:14:29.063]                 str(1:50)
[16:14:29.063]                 cat(letters, sep = "-")
[16:14:29.063]                 cat(1:6, collapse = "\n")
[16:14:29.063]                 write.table(datasets::iris[1:10, ], sep = "\t")
[16:14:29.063]                 42L
[16:14:29.063]             }))
[16:14:29.063]             future::FutureResult(value = ...future.value$value, 
[16:14:29.063]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:29.063]                   ...future.rng), globalenv = if (FALSE) 
[16:14:29.063]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:29.063]                     ...future.globalenv.names))
[16:14:29.063]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:29.063]         }, condition = base::local({
[16:14:29.063]             c <- base::c
[16:14:29.063]             inherits <- base::inherits
[16:14:29.063]             invokeRestart <- base::invokeRestart
[16:14:29.063]             length <- base::length
[16:14:29.063]             list <- base::list
[16:14:29.063]             seq.int <- base::seq.int
[16:14:29.063]             signalCondition <- base::signalCondition
[16:14:29.063]             sys.calls <- base::sys.calls
[16:14:29.063]             `[[` <- base::`[[`
[16:14:29.063]             `+` <- base::`+`
[16:14:29.063]             `<<-` <- base::`<<-`
[16:14:29.063]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:29.063]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:29.063]                   3L)]
[16:14:29.063]             }
[16:14:29.063]             function(cond) {
[16:14:29.063]                 is_error <- inherits(cond, "error")
[16:14:29.063]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:29.063]                   NULL)
[16:14:29.063]                 if (is_error) {
[16:14:29.063]                   sessionInformation <- function() {
[16:14:29.063]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:29.063]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:29.063]                       search = base::search(), system = base::Sys.info())
[16:14:29.063]                   }
[16:14:29.063]                   ...future.conditions[[length(...future.conditions) + 
[16:14:29.063]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:29.063]                     cond$call), session = sessionInformation(), 
[16:14:29.063]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:29.063]                   signalCondition(cond)
[16:14:29.063]                 }
[16:14:29.063]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:29.063]                 "immediateCondition"))) {
[16:14:29.063]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:29.063]                   ...future.conditions[[length(...future.conditions) + 
[16:14:29.063]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:29.063]                   if (TRUE && !signal) {
[16:14:29.063]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.063]                     {
[16:14:29.063]                       inherits <- base::inherits
[16:14:29.063]                       invokeRestart <- base::invokeRestart
[16:14:29.063]                       is.null <- base::is.null
[16:14:29.063]                       muffled <- FALSE
[16:14:29.063]                       if (inherits(cond, "message")) {
[16:14:29.063]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:29.063]                         if (muffled) 
[16:14:29.063]                           invokeRestart("muffleMessage")
[16:14:29.063]                       }
[16:14:29.063]                       else if (inherits(cond, "warning")) {
[16:14:29.063]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:29.063]                         if (muffled) 
[16:14:29.063]                           invokeRestart("muffleWarning")
[16:14:29.063]                       }
[16:14:29.063]                       else if (inherits(cond, "condition")) {
[16:14:29.063]                         if (!is.null(pattern)) {
[16:14:29.063]                           computeRestarts <- base::computeRestarts
[16:14:29.063]                           grepl <- base::grepl
[16:14:29.063]                           restarts <- computeRestarts(cond)
[16:14:29.063]                           for (restart in restarts) {
[16:14:29.063]                             name <- restart$name
[16:14:29.063]                             if (is.null(name)) 
[16:14:29.063]                               next
[16:14:29.063]                             if (!grepl(pattern, name)) 
[16:14:29.063]                               next
[16:14:29.063]                             invokeRestart(restart)
[16:14:29.063]                             muffled <- TRUE
[16:14:29.063]                             break
[16:14:29.063]                           }
[16:14:29.063]                         }
[16:14:29.063]                       }
[16:14:29.063]                       invisible(muffled)
[16:14:29.063]                     }
[16:14:29.063]                     muffleCondition(cond, pattern = "^muffle")
[16:14:29.063]                   }
[16:14:29.063]                 }
[16:14:29.063]                 else {
[16:14:29.063]                   if (TRUE) {
[16:14:29.063]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.063]                     {
[16:14:29.063]                       inherits <- base::inherits
[16:14:29.063]                       invokeRestart <- base::invokeRestart
[16:14:29.063]                       is.null <- base::is.null
[16:14:29.063]                       muffled <- FALSE
[16:14:29.063]                       if (inherits(cond, "message")) {
[16:14:29.063]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:29.063]                         if (muffled) 
[16:14:29.063]                           invokeRestart("muffleMessage")
[16:14:29.063]                       }
[16:14:29.063]                       else if (inherits(cond, "warning")) {
[16:14:29.063]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:29.063]                         if (muffled) 
[16:14:29.063]                           invokeRestart("muffleWarning")
[16:14:29.063]                       }
[16:14:29.063]                       else if (inherits(cond, "condition")) {
[16:14:29.063]                         if (!is.null(pattern)) {
[16:14:29.063]                           computeRestarts <- base::computeRestarts
[16:14:29.063]                           grepl <- base::grepl
[16:14:29.063]                           restarts <- computeRestarts(cond)
[16:14:29.063]                           for (restart in restarts) {
[16:14:29.063]                             name <- restart$name
[16:14:29.063]                             if (is.null(name)) 
[16:14:29.063]                               next
[16:14:29.063]                             if (!grepl(pattern, name)) 
[16:14:29.063]                               next
[16:14:29.063]                             invokeRestart(restart)
[16:14:29.063]                             muffled <- TRUE
[16:14:29.063]                             break
[16:14:29.063]                           }
[16:14:29.063]                         }
[16:14:29.063]                       }
[16:14:29.063]                       invisible(muffled)
[16:14:29.063]                     }
[16:14:29.063]                     muffleCondition(cond, pattern = "^muffle")
[16:14:29.063]                   }
[16:14:29.063]                 }
[16:14:29.063]             }
[16:14:29.063]         }))
[16:14:29.063]     }, error = function(ex) {
[16:14:29.063]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:29.063]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:29.063]                 ...future.rng), started = ...future.startTime, 
[16:14:29.063]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:29.063]             version = "1.8"), class = "FutureResult")
[16:14:29.063]     }, finally = {
[16:14:29.063]         if (!identical(...future.workdir, getwd())) 
[16:14:29.063]             setwd(...future.workdir)
[16:14:29.063]         {
[16:14:29.063]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:29.063]                 ...future.oldOptions$nwarnings <- NULL
[16:14:29.063]             }
[16:14:29.063]             base::options(...future.oldOptions)
[16:14:29.063]             if (.Platform$OS.type == "windows") {
[16:14:29.063]                 old_names <- names(...future.oldEnvVars)
[16:14:29.063]                 envs <- base::Sys.getenv()
[16:14:29.063]                 names <- names(envs)
[16:14:29.063]                 common <- intersect(names, old_names)
[16:14:29.063]                 added <- setdiff(names, old_names)
[16:14:29.063]                 removed <- setdiff(old_names, names)
[16:14:29.063]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:29.063]                   envs[common]]
[16:14:29.063]                 NAMES <- toupper(changed)
[16:14:29.063]                 args <- list()
[16:14:29.063]                 for (kk in seq_along(NAMES)) {
[16:14:29.063]                   name <- changed[[kk]]
[16:14:29.063]                   NAME <- NAMES[[kk]]
[16:14:29.063]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.063]                     next
[16:14:29.063]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:29.063]                 }
[16:14:29.063]                 NAMES <- toupper(added)
[16:14:29.063]                 for (kk in seq_along(NAMES)) {
[16:14:29.063]                   name <- added[[kk]]
[16:14:29.063]                   NAME <- NAMES[[kk]]
[16:14:29.063]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.063]                     next
[16:14:29.063]                   args[[name]] <- ""
[16:14:29.063]                 }
[16:14:29.063]                 NAMES <- toupper(removed)
[16:14:29.063]                 for (kk in seq_along(NAMES)) {
[16:14:29.063]                   name <- removed[[kk]]
[16:14:29.063]                   NAME <- NAMES[[kk]]
[16:14:29.063]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.063]                     next
[16:14:29.063]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:29.063]                 }
[16:14:29.063]                 if (length(args) > 0) 
[16:14:29.063]                   base::do.call(base::Sys.setenv, args = args)
[16:14:29.063]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:29.063]             }
[16:14:29.063]             else {
[16:14:29.063]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:29.063]             }
[16:14:29.063]             {
[16:14:29.063]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:29.063]                   0L) {
[16:14:29.063]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:29.063]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:29.063]                   base::options(opts)
[16:14:29.063]                 }
[16:14:29.063]                 {
[16:14:29.063]                   {
[16:14:29.063]                     NULL
[16:14:29.063]                     RNGkind("Mersenne-Twister")
[16:14:29.063]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:14:29.063]                       inherits = FALSE)
[16:14:29.063]                   }
[16:14:29.063]                   options(future.plan = NULL)
[16:14:29.063]                   if (is.na(NA_character_)) 
[16:14:29.063]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:29.063]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:29.063]                   future::plan(list(function (..., envir = parent.frame()) 
[16:14:29.063]                   {
[16:14:29.063]                     future <- SequentialFuture(..., envir = envir)
[16:14:29.063]                     if (!future$lazy) 
[16:14:29.063]                       future <- run(future)
[16:14:29.063]                     invisible(future)
[16:14:29.063]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:29.063]                 }
[16:14:29.063]             }
[16:14:29.063]         }
[16:14:29.063]     })
[16:14:29.063]     if (FALSE) {
[16:14:29.063]         base::sink(type = "output", split = FALSE)
[16:14:29.063]         if (NA) {
[16:14:29.063]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:29.063]         }
[16:14:29.063]         else {
[16:14:29.063]             ...future.result["stdout"] <- base::list(NULL)
[16:14:29.063]         }
[16:14:29.063]         base::close(...future.stdout)
[16:14:29.063]         ...future.stdout <- NULL
[16:14:29.063]     }
[16:14:29.063]     ...future.result$conditions <- ...future.conditions
[16:14:29.063]     ...future.result$finished <- base::Sys.time()
[16:14:29.063]     ...future.result
[16:14:29.063] }
[16:14:29.064] plan(): Setting new future strategy stack:
[16:14:29.064] List of future strategies:
[16:14:29.064] 1. sequential:
[16:14:29.064]    - args: function (..., envir = parent.frame())
[16:14:29.064]    - tweaked: FALSE
[16:14:29.064]    - call: NULL
[16:14:29.065] plan(): nbrOfWorkers() = 1
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
[16:14:29.066] plan(): Setting new future strategy stack:
[16:14:29.066] List of future strategies:
[16:14:29.066] 1. sequential:
[16:14:29.066]    - args: function (..., envir = parent.frame())
[16:14:29.066]    - tweaked: FALSE
[16:14:29.066]    - call: plan(strategy)
[16:14:29.067] plan(): nbrOfWorkers() = 1
[16:14:29.067] SequentialFuture started (and completed)
[16:14:29.067] - Launch lazy future ... done
[16:14:29.067] run() for ‘SequentialFuture’ ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-01-06 16:14:29"
 $ finished    : POSIXct[1:1], format: "2025-01-06 16:14:29"
 $ session_uuid: chr "f2024c80-2b92-d4d1-117a-ce2ef0d518b0"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "2729ef2608da"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "2729ef2608da" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 92308
  .. ..$ time  : POSIXct[1:1], format: "2025-01-06 16:14:28"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 3 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[16:14:29.076] getGlobalsAndPackages() ...
[16:14:29.076] Searching for globals...
[16:14:29.078] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[16:14:29.079] Searching for globals ... DONE
[16:14:29.079] Resolving globals: FALSE
[16:14:29.079] 
[16:14:29.079] - packages: [1] ‘utils’
[16:14:29.079] getGlobalsAndPackages() ... DONE
[16:14:29.079] run() for ‘Future’ ...
[16:14:29.080] - state: ‘created’
[16:14:29.080] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:14:29.080] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:14:29.080] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:14:29.080]   - Field: ‘label’
[16:14:29.080]   - Field: ‘local’
[16:14:29.080]   - Field: ‘owner’
[16:14:29.080]   - Field: ‘envir’
[16:14:29.081]   - Field: ‘packages’
[16:14:29.081]   - Field: ‘gc’
[16:14:29.081]   - Field: ‘conditions’
[16:14:29.081]   - Field: ‘expr’
[16:14:29.081]   - Field: ‘uuid’
[16:14:29.081]   - Field: ‘seed’
[16:14:29.081]   - Field: ‘version’
[16:14:29.081]   - Field: ‘result’
[16:14:29.081]   - Field: ‘asynchronous’
[16:14:29.081]   - Field: ‘calls’
[16:14:29.081]   - Field: ‘globals’
[16:14:29.081]   - Field: ‘stdout’
[16:14:29.082]   - Field: ‘earlySignal’
[16:14:29.082]   - Field: ‘lazy’
[16:14:29.082]   - Field: ‘state’
[16:14:29.082] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:14:29.082] - Launch lazy future ...
[16:14:29.082] Packages needed by the future expression (n = 1): ‘utils’
[16:14:29.082] Packages needed by future strategies (n = 0): <none>
[16:14:29.083] {
[16:14:29.083]     {
[16:14:29.083]         {
[16:14:29.083]             ...future.startTime <- base::Sys.time()
[16:14:29.083]             {
[16:14:29.083]                 {
[16:14:29.083]                   {
[16:14:29.083]                     {
[16:14:29.083]                       base::local({
[16:14:29.083]                         has_future <- base::requireNamespace("future", 
[16:14:29.083]                           quietly = TRUE)
[16:14:29.083]                         if (has_future) {
[16:14:29.083]                           ns <- base::getNamespace("future")
[16:14:29.083]                           version <- ns[[".package"]][["version"]]
[16:14:29.083]                           if (is.null(version)) 
[16:14:29.083]                             version <- utils::packageVersion("future")
[16:14:29.083]                         }
[16:14:29.083]                         else {
[16:14:29.083]                           version <- NULL
[16:14:29.083]                         }
[16:14:29.083]                         if (!has_future || version < "1.8.0") {
[16:14:29.083]                           info <- base::c(r_version = base::gsub("R version ", 
[16:14:29.083]                             "", base::R.version$version.string), 
[16:14:29.083]                             platform = base::sprintf("%s (%s-bit)", 
[16:14:29.083]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:14:29.083]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:29.083]                               "release", "version")], collapse = " "), 
[16:14:29.083]                             hostname = base::Sys.info()[["nodename"]])
[16:14:29.083]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:14:29.083]                             info)
[16:14:29.083]                           info <- base::paste(info, collapse = "; ")
[16:14:29.083]                           if (!has_future) {
[16:14:29.083]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:29.083]                               info)
[16:14:29.083]                           }
[16:14:29.083]                           else {
[16:14:29.083]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:29.083]                               info, version)
[16:14:29.083]                           }
[16:14:29.083]                           base::stop(msg)
[16:14:29.083]                         }
[16:14:29.083]                       })
[16:14:29.083]                     }
[16:14:29.083]                     base::local({
[16:14:29.083]                       for (pkg in "utils") {
[16:14:29.083]                         base::loadNamespace(pkg)
[16:14:29.083]                         base::library(pkg, character.only = TRUE)
[16:14:29.083]                       }
[16:14:29.083]                     })
[16:14:29.083]                   }
[16:14:29.083]                   options(future.plan = NULL)
[16:14:29.083]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:29.083]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:29.083]                 }
[16:14:29.083]                 ...future.workdir <- getwd()
[16:14:29.083]             }
[16:14:29.083]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:29.083]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:29.083]         }
[16:14:29.083]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:29.083]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:29.083]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:29.083]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:29.083]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:29.083]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:29.083]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:29.083]             base::names(...future.oldOptions))
[16:14:29.083]     }
[16:14:29.083]     if (TRUE) {
[16:14:29.083]     }
[16:14:29.083]     else {
[16:14:29.083]         if (NA) {
[16:14:29.083]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:29.083]                 open = "w")
[16:14:29.083]         }
[16:14:29.083]         else {
[16:14:29.083]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:29.083]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:29.083]         }
[16:14:29.083]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:29.083]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:29.083]             base::sink(type = "output", split = FALSE)
[16:14:29.083]             base::close(...future.stdout)
[16:14:29.083]         }, add = TRUE)
[16:14:29.083]     }
[16:14:29.083]     ...future.frame <- base::sys.nframe()
[16:14:29.083]     ...future.conditions <- base::list()
[16:14:29.083]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:29.083]     if (FALSE) {
[16:14:29.083]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:29.083]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:29.083]     }
[16:14:29.083]     ...future.result <- base::tryCatch({
[16:14:29.083]         base::withCallingHandlers({
[16:14:29.083]             ...future.value <- base::withVisible(base::local({
[16:14:29.083]                 print(1:50)
[16:14:29.083]                 str(1:50)
[16:14:29.083]                 cat(letters, sep = "-")
[16:14:29.083]                 cat(1:6, collapse = "\n")
[16:14:29.083]                 write.table(datasets::iris[1:10, ], sep = "\t")
[16:14:29.083]                 42L
[16:14:29.083]             }))
[16:14:29.083]             future::FutureResult(value = ...future.value$value, 
[16:14:29.083]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:29.083]                   ...future.rng), globalenv = if (FALSE) 
[16:14:29.083]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:29.083]                     ...future.globalenv.names))
[16:14:29.083]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:29.083]         }, condition = base::local({
[16:14:29.083]             c <- base::c
[16:14:29.083]             inherits <- base::inherits
[16:14:29.083]             invokeRestart <- base::invokeRestart
[16:14:29.083]             length <- base::length
[16:14:29.083]             list <- base::list
[16:14:29.083]             seq.int <- base::seq.int
[16:14:29.083]             signalCondition <- base::signalCondition
[16:14:29.083]             sys.calls <- base::sys.calls
[16:14:29.083]             `[[` <- base::`[[`
[16:14:29.083]             `+` <- base::`+`
[16:14:29.083]             `<<-` <- base::`<<-`
[16:14:29.083]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:29.083]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:29.083]                   3L)]
[16:14:29.083]             }
[16:14:29.083]             function(cond) {
[16:14:29.083]                 is_error <- inherits(cond, "error")
[16:14:29.083]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:29.083]                   NULL)
[16:14:29.083]                 if (is_error) {
[16:14:29.083]                   sessionInformation <- function() {
[16:14:29.083]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:29.083]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:29.083]                       search = base::search(), system = base::Sys.info())
[16:14:29.083]                   }
[16:14:29.083]                   ...future.conditions[[length(...future.conditions) + 
[16:14:29.083]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:29.083]                     cond$call), session = sessionInformation(), 
[16:14:29.083]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:29.083]                   signalCondition(cond)
[16:14:29.083]                 }
[16:14:29.083]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:29.083]                 "immediateCondition"))) {
[16:14:29.083]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:29.083]                   ...future.conditions[[length(...future.conditions) + 
[16:14:29.083]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:29.083]                   if (TRUE && !signal) {
[16:14:29.083]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.083]                     {
[16:14:29.083]                       inherits <- base::inherits
[16:14:29.083]                       invokeRestart <- base::invokeRestart
[16:14:29.083]                       is.null <- base::is.null
[16:14:29.083]                       muffled <- FALSE
[16:14:29.083]                       if (inherits(cond, "message")) {
[16:14:29.083]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:29.083]                         if (muffled) 
[16:14:29.083]                           invokeRestart("muffleMessage")
[16:14:29.083]                       }
[16:14:29.083]                       else if (inherits(cond, "warning")) {
[16:14:29.083]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:29.083]                         if (muffled) 
[16:14:29.083]                           invokeRestart("muffleWarning")
[16:14:29.083]                       }
[16:14:29.083]                       else if (inherits(cond, "condition")) {
[16:14:29.083]                         if (!is.null(pattern)) {
[16:14:29.083]                           computeRestarts <- base::computeRestarts
[16:14:29.083]                           grepl <- base::grepl
[16:14:29.083]                           restarts <- computeRestarts(cond)
[16:14:29.083]                           for (restart in restarts) {
[16:14:29.083]                             name <- restart$name
[16:14:29.083]                             if (is.null(name)) 
[16:14:29.083]                               next
[16:14:29.083]                             if (!grepl(pattern, name)) 
[16:14:29.083]                               next
[16:14:29.083]                             invokeRestart(restart)
[16:14:29.083]                             muffled <- TRUE
[16:14:29.083]                             break
[16:14:29.083]                           }
[16:14:29.083]                         }
[16:14:29.083]                       }
[16:14:29.083]                       invisible(muffled)
[16:14:29.083]                     }
[16:14:29.083]                     muffleCondition(cond, pattern = "^muffle")
[16:14:29.083]                   }
[16:14:29.083]                 }
[16:14:29.083]                 else {
[16:14:29.083]                   if (TRUE) {
[16:14:29.083]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.083]                     {
[16:14:29.083]                       inherits <- base::inherits
[16:14:29.083]                       invokeRestart <- base::invokeRestart
[16:14:29.083]                       is.null <- base::is.null
[16:14:29.083]                       muffled <- FALSE
[16:14:29.083]                       if (inherits(cond, "message")) {
[16:14:29.083]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:29.083]                         if (muffled) 
[16:14:29.083]                           invokeRestart("muffleMessage")
[16:14:29.083]                       }
[16:14:29.083]                       else if (inherits(cond, "warning")) {
[16:14:29.083]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:29.083]                         if (muffled) 
[16:14:29.083]                           invokeRestart("muffleWarning")
[16:14:29.083]                       }
[16:14:29.083]                       else if (inherits(cond, "condition")) {
[16:14:29.083]                         if (!is.null(pattern)) {
[16:14:29.083]                           computeRestarts <- base::computeRestarts
[16:14:29.083]                           grepl <- base::grepl
[16:14:29.083]                           restarts <- computeRestarts(cond)
[16:14:29.083]                           for (restart in restarts) {
[16:14:29.083]                             name <- restart$name
[16:14:29.083]                             if (is.null(name)) 
[16:14:29.083]                               next
[16:14:29.083]                             if (!grepl(pattern, name)) 
[16:14:29.083]                               next
[16:14:29.083]                             invokeRestart(restart)
[16:14:29.083]                             muffled <- TRUE
[16:14:29.083]                             break
[16:14:29.083]                           }
[16:14:29.083]                         }
[16:14:29.083]                       }
[16:14:29.083]                       invisible(muffled)
[16:14:29.083]                     }
[16:14:29.083]                     muffleCondition(cond, pattern = "^muffle")
[16:14:29.083]                   }
[16:14:29.083]                 }
[16:14:29.083]             }
[16:14:29.083]         }))
[16:14:29.083]     }, error = function(ex) {
[16:14:29.083]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:29.083]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:29.083]                 ...future.rng), started = ...future.startTime, 
[16:14:29.083]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:29.083]             version = "1.8"), class = "FutureResult")
[16:14:29.083]     }, finally = {
[16:14:29.083]         if (!identical(...future.workdir, getwd())) 
[16:14:29.083]             setwd(...future.workdir)
[16:14:29.083]         {
[16:14:29.083]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:29.083]                 ...future.oldOptions$nwarnings <- NULL
[16:14:29.083]             }
[16:14:29.083]             base::options(...future.oldOptions)
[16:14:29.083]             if (.Platform$OS.type == "windows") {
[16:14:29.083]                 old_names <- names(...future.oldEnvVars)
[16:14:29.083]                 envs <- base::Sys.getenv()
[16:14:29.083]                 names <- names(envs)
[16:14:29.083]                 common <- intersect(names, old_names)
[16:14:29.083]                 added <- setdiff(names, old_names)
[16:14:29.083]                 removed <- setdiff(old_names, names)
[16:14:29.083]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:29.083]                   envs[common]]
[16:14:29.083]                 NAMES <- toupper(changed)
[16:14:29.083]                 args <- list()
[16:14:29.083]                 for (kk in seq_along(NAMES)) {
[16:14:29.083]                   name <- changed[[kk]]
[16:14:29.083]                   NAME <- NAMES[[kk]]
[16:14:29.083]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.083]                     next
[16:14:29.083]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:29.083]                 }
[16:14:29.083]                 NAMES <- toupper(added)
[16:14:29.083]                 for (kk in seq_along(NAMES)) {
[16:14:29.083]                   name <- added[[kk]]
[16:14:29.083]                   NAME <- NAMES[[kk]]
[16:14:29.083]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.083]                     next
[16:14:29.083]                   args[[name]] <- ""
[16:14:29.083]                 }
[16:14:29.083]                 NAMES <- toupper(removed)
[16:14:29.083]                 for (kk in seq_along(NAMES)) {
[16:14:29.083]                   name <- removed[[kk]]
[16:14:29.083]                   NAME <- NAMES[[kk]]
[16:14:29.083]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.083]                     next
[16:14:29.083]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:29.083]                 }
[16:14:29.083]                 if (length(args) > 0) 
[16:14:29.083]                   base::do.call(base::Sys.setenv, args = args)
[16:14:29.083]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:29.083]             }
[16:14:29.083]             else {
[16:14:29.083]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:29.083]             }
[16:14:29.083]             {
[16:14:29.083]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:29.083]                   0L) {
[16:14:29.083]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:29.083]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:29.083]                   base::options(opts)
[16:14:29.083]                 }
[16:14:29.083]                 {
[16:14:29.083]                   {
[16:14:29.083]                     NULL
[16:14:29.083]                     RNGkind("Mersenne-Twister")
[16:14:29.083]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:14:29.083]                       inherits = FALSE)
[16:14:29.083]                   }
[16:14:29.083]                   options(future.plan = NULL)
[16:14:29.083]                   if (is.na(NA_character_)) 
[16:14:29.083]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:29.083]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:29.083]                   future::plan(list(function (..., envir = parent.frame()) 
[16:14:29.083]                   {
[16:14:29.083]                     future <- SequentialFuture(..., envir = envir)
[16:14:29.083]                     if (!future$lazy) 
[16:14:29.083]                       future <- run(future)
[16:14:29.083]                     invisible(future)
[16:14:29.083]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:29.083]                 }
[16:14:29.083]             }
[16:14:29.083]         }
[16:14:29.083]     })
[16:14:29.083]     if (FALSE) {
[16:14:29.083]         base::sink(type = "output", split = FALSE)
[16:14:29.083]         if (NA) {
[16:14:29.083]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:29.083]         }
[16:14:29.083]         else {
[16:14:29.083]             ...future.result["stdout"] <- base::list(NULL)
[16:14:29.083]         }
[16:14:29.083]         base::close(...future.stdout)
[16:14:29.083]         ...future.stdout <- NULL
[16:14:29.083]     }
[16:14:29.083]     ...future.result$conditions <- ...future.conditions
[16:14:29.083]     ...future.result$finished <- base::Sys.time()
[16:14:29.083]     ...future.result
[16:14:29.083] }
[16:14:29.085] plan(): Setting new future strategy stack:
[16:14:29.085] List of future strategies:
[16:14:29.085] 1. sequential:
[16:14:29.085]    - args: function (..., envir = parent.frame())
[16:14:29.085]    - tweaked: FALSE
[16:14:29.085]    - call: NULL
[16:14:29.085] plan(): nbrOfWorkers() = 1
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
[16:14:29.086] plan(): Setting new future strategy stack:
[16:14:29.087] List of future strategies:
[16:14:29.087] 1. sequential:
[16:14:29.087]    - args: function (..., envir = parent.frame())
[16:14:29.087]    - tweaked: FALSE
[16:14:29.087]    - call: plan(strategy)
[16:14:29.087] plan(): nbrOfWorkers() = 1
[16:14:29.087] SequentialFuture started (and completed)
[16:14:29.087] - Launch lazy future ... done
[16:14:29.087] run() for ‘SequentialFuture’ ... done
- stdout = structure(TRUE, drop = TRUE)
[16:14:29.088] getGlobalsAndPackages() ...
[16:14:29.088] Searching for globals...
[16:14:29.088] - globals found: [1] ‘print’
[16:14:29.088] Searching for globals ... DONE
[16:14:29.088] Resolving globals: FALSE
[16:14:29.089] 
[16:14:29.089] 
[16:14:29.089] getGlobalsAndPackages() ... DONE
[16:14:29.089] run() for ‘Future’ ...
[16:14:29.089] - state: ‘created’
[16:14:29.089] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:14:29.089] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:14:29.090] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:14:29.090]   - Field: ‘label’
[16:14:29.090]   - Field: ‘local’
[16:14:29.090]   - Field: ‘owner’
[16:14:29.090]   - Field: ‘envir’
[16:14:29.090]   - Field: ‘packages’
[16:14:29.090]   - Field: ‘gc’
[16:14:29.090]   - Field: ‘conditions’
[16:14:29.090]   - Field: ‘expr’
[16:14:29.090]   - Field: ‘uuid’
[16:14:29.090]   - Field: ‘seed’
[16:14:29.091]   - Field: ‘version’
[16:14:29.091]   - Field: ‘result’
[16:14:29.091]   - Field: ‘asynchronous’
[16:14:29.091]   - Field: ‘calls’
[16:14:29.091]   - Field: ‘globals’
[16:14:29.091]   - Field: ‘stdout’
[16:14:29.091]   - Field: ‘earlySignal’
[16:14:29.091]   - Field: ‘lazy’
[16:14:29.091]   - Field: ‘state’
[16:14:29.091] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:14:29.092] - Launch lazy future ...
[16:14:29.093] Packages needed by the future expression (n = 0): <none>
[16:14:29.093] Packages needed by future strategies (n = 0): <none>
[16:14:29.093] {
[16:14:29.093]     {
[16:14:29.093]         {
[16:14:29.093]             ...future.startTime <- base::Sys.time()
[16:14:29.093]             {
[16:14:29.093]                 {
[16:14:29.093]                   {
[16:14:29.093]                     base::local({
[16:14:29.093]                       has_future <- base::requireNamespace("future", 
[16:14:29.093]                         quietly = TRUE)
[16:14:29.093]                       if (has_future) {
[16:14:29.093]                         ns <- base::getNamespace("future")
[16:14:29.093]                         version <- ns[[".package"]][["version"]]
[16:14:29.093]                         if (is.null(version)) 
[16:14:29.093]                           version <- utils::packageVersion("future")
[16:14:29.093]                       }
[16:14:29.093]                       else {
[16:14:29.093]                         version <- NULL
[16:14:29.093]                       }
[16:14:29.093]                       if (!has_future || version < "1.8.0") {
[16:14:29.093]                         info <- base::c(r_version = base::gsub("R version ", 
[16:14:29.093]                           "", base::R.version$version.string), 
[16:14:29.093]                           platform = base::sprintf("%s (%s-bit)", 
[16:14:29.093]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:14:29.093]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:29.093]                             "release", "version")], collapse = " "), 
[16:14:29.093]                           hostname = base::Sys.info()[["nodename"]])
[16:14:29.093]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:14:29.093]                           info)
[16:14:29.093]                         info <- base::paste(info, collapse = "; ")
[16:14:29.093]                         if (!has_future) {
[16:14:29.093]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:29.093]                             info)
[16:14:29.093]                         }
[16:14:29.093]                         else {
[16:14:29.093]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:29.093]                             info, version)
[16:14:29.093]                         }
[16:14:29.093]                         base::stop(msg)
[16:14:29.093]                       }
[16:14:29.093]                     })
[16:14:29.093]                   }
[16:14:29.093]                   options(future.plan = NULL)
[16:14:29.093]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:29.093]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:29.093]                 }
[16:14:29.093]                 ...future.workdir <- getwd()
[16:14:29.093]             }
[16:14:29.093]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:29.093]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:29.093]         }
[16:14:29.093]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:29.093]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:29.093]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:29.093]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:29.093]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:29.093]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:29.093]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:29.093]             base::names(...future.oldOptions))
[16:14:29.093]     }
[16:14:29.093]     if (FALSE) {
[16:14:29.093]     }
[16:14:29.093]     else {
[16:14:29.093]         if (TRUE) {
[16:14:29.093]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:29.093]                 open = "w")
[16:14:29.093]         }
[16:14:29.093]         else {
[16:14:29.093]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:29.093]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:29.093]         }
[16:14:29.093]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:29.093]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:29.093]             base::sink(type = "output", split = FALSE)
[16:14:29.093]             base::close(...future.stdout)
[16:14:29.093]         }, add = TRUE)
[16:14:29.093]     }
[16:14:29.093]     ...future.frame <- base::sys.nframe()
[16:14:29.093]     ...future.conditions <- base::list()
[16:14:29.093]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:29.093]     if (FALSE) {
[16:14:29.093]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:29.093]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:29.093]     }
[16:14:29.093]     ...future.result <- base::tryCatch({
[16:14:29.093]         base::withCallingHandlers({
[16:14:29.093]             ...future.value <- base::withVisible(base::local(print(42)))
[16:14:29.093]             future::FutureResult(value = ...future.value$value, 
[16:14:29.093]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:29.093]                   ...future.rng), globalenv = if (FALSE) 
[16:14:29.093]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:29.093]                     ...future.globalenv.names))
[16:14:29.093]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:29.093]         }, condition = base::local({
[16:14:29.093]             c <- base::c
[16:14:29.093]             inherits <- base::inherits
[16:14:29.093]             invokeRestart <- base::invokeRestart
[16:14:29.093]             length <- base::length
[16:14:29.093]             list <- base::list
[16:14:29.093]             seq.int <- base::seq.int
[16:14:29.093]             signalCondition <- base::signalCondition
[16:14:29.093]             sys.calls <- base::sys.calls
[16:14:29.093]             `[[` <- base::`[[`
[16:14:29.093]             `+` <- base::`+`
[16:14:29.093]             `<<-` <- base::`<<-`
[16:14:29.093]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:29.093]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:29.093]                   3L)]
[16:14:29.093]             }
[16:14:29.093]             function(cond) {
[16:14:29.093]                 is_error <- inherits(cond, "error")
[16:14:29.093]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:29.093]                   NULL)
[16:14:29.093]                 if (is_error) {
[16:14:29.093]                   sessionInformation <- function() {
[16:14:29.093]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:29.093]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:29.093]                       search = base::search(), system = base::Sys.info())
[16:14:29.093]                   }
[16:14:29.093]                   ...future.conditions[[length(...future.conditions) + 
[16:14:29.093]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:29.093]                     cond$call), session = sessionInformation(), 
[16:14:29.093]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:29.093]                   signalCondition(cond)
[16:14:29.093]                 }
[16:14:29.093]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:29.093]                 "immediateCondition"))) {
[16:14:29.093]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:29.093]                   ...future.conditions[[length(...future.conditions) + 
[16:14:29.093]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:29.093]                   if (TRUE && !signal) {
[16:14:29.093]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.093]                     {
[16:14:29.093]                       inherits <- base::inherits
[16:14:29.093]                       invokeRestart <- base::invokeRestart
[16:14:29.093]                       is.null <- base::is.null
[16:14:29.093]                       muffled <- FALSE
[16:14:29.093]                       if (inherits(cond, "message")) {
[16:14:29.093]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:29.093]                         if (muffled) 
[16:14:29.093]                           invokeRestart("muffleMessage")
[16:14:29.093]                       }
[16:14:29.093]                       else if (inherits(cond, "warning")) {
[16:14:29.093]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:29.093]                         if (muffled) 
[16:14:29.093]                           invokeRestart("muffleWarning")
[16:14:29.093]                       }
[16:14:29.093]                       else if (inherits(cond, "condition")) {
[16:14:29.093]                         if (!is.null(pattern)) {
[16:14:29.093]                           computeRestarts <- base::computeRestarts
[16:14:29.093]                           grepl <- base::grepl
[16:14:29.093]                           restarts <- computeRestarts(cond)
[16:14:29.093]                           for (restart in restarts) {
[16:14:29.093]                             name <- restart$name
[16:14:29.093]                             if (is.null(name)) 
[16:14:29.093]                               next
[16:14:29.093]                             if (!grepl(pattern, name)) 
[16:14:29.093]                               next
[16:14:29.093]                             invokeRestart(restart)
[16:14:29.093]                             muffled <- TRUE
[16:14:29.093]                             break
[16:14:29.093]                           }
[16:14:29.093]                         }
[16:14:29.093]                       }
[16:14:29.093]                       invisible(muffled)
[16:14:29.093]                     }
[16:14:29.093]                     muffleCondition(cond, pattern = "^muffle")
[16:14:29.093]                   }
[16:14:29.093]                 }
[16:14:29.093]                 else {
[16:14:29.093]                   if (TRUE) {
[16:14:29.093]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.093]                     {
[16:14:29.093]                       inherits <- base::inherits
[16:14:29.093]                       invokeRestart <- base::invokeRestart
[16:14:29.093]                       is.null <- base::is.null
[16:14:29.093]                       muffled <- FALSE
[16:14:29.093]                       if (inherits(cond, "message")) {
[16:14:29.093]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:29.093]                         if (muffled) 
[16:14:29.093]                           invokeRestart("muffleMessage")
[16:14:29.093]                       }
[16:14:29.093]                       else if (inherits(cond, "warning")) {
[16:14:29.093]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:29.093]                         if (muffled) 
[16:14:29.093]                           invokeRestart("muffleWarning")
[16:14:29.093]                       }
[16:14:29.093]                       else if (inherits(cond, "condition")) {
[16:14:29.093]                         if (!is.null(pattern)) {
[16:14:29.093]                           computeRestarts <- base::computeRestarts
[16:14:29.093]                           grepl <- base::grepl
[16:14:29.093]                           restarts <- computeRestarts(cond)
[16:14:29.093]                           for (restart in restarts) {
[16:14:29.093]                             name <- restart$name
[16:14:29.093]                             if (is.null(name)) 
[16:14:29.093]                               next
[16:14:29.093]                             if (!grepl(pattern, name)) 
[16:14:29.093]                               next
[16:14:29.093]                             invokeRestart(restart)
[16:14:29.093]                             muffled <- TRUE
[16:14:29.093]                             break
[16:14:29.093]                           }
[16:14:29.093]                         }
[16:14:29.093]                       }
[16:14:29.093]                       invisible(muffled)
[16:14:29.093]                     }
[16:14:29.093]                     muffleCondition(cond, pattern = "^muffle")
[16:14:29.093]                   }
[16:14:29.093]                 }
[16:14:29.093]             }
[16:14:29.093]         }))
[16:14:29.093]     }, error = function(ex) {
[16:14:29.093]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:29.093]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:29.093]                 ...future.rng), started = ...future.startTime, 
[16:14:29.093]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:29.093]             version = "1.8"), class = "FutureResult")
[16:14:29.093]     }, finally = {
[16:14:29.093]         if (!identical(...future.workdir, getwd())) 
[16:14:29.093]             setwd(...future.workdir)
[16:14:29.093]         {
[16:14:29.093]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:29.093]                 ...future.oldOptions$nwarnings <- NULL
[16:14:29.093]             }
[16:14:29.093]             base::options(...future.oldOptions)
[16:14:29.093]             if (.Platform$OS.type == "windows") {
[16:14:29.093]                 old_names <- names(...future.oldEnvVars)
[16:14:29.093]                 envs <- base::Sys.getenv()
[16:14:29.093]                 names <- names(envs)
[16:14:29.093]                 common <- intersect(names, old_names)
[16:14:29.093]                 added <- setdiff(names, old_names)
[16:14:29.093]                 removed <- setdiff(old_names, names)
[16:14:29.093]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:29.093]                   envs[common]]
[16:14:29.093]                 NAMES <- toupper(changed)
[16:14:29.093]                 args <- list()
[16:14:29.093]                 for (kk in seq_along(NAMES)) {
[16:14:29.093]                   name <- changed[[kk]]
[16:14:29.093]                   NAME <- NAMES[[kk]]
[16:14:29.093]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.093]                     next
[16:14:29.093]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:29.093]                 }
[16:14:29.093]                 NAMES <- toupper(added)
[16:14:29.093]                 for (kk in seq_along(NAMES)) {
[16:14:29.093]                   name <- added[[kk]]
[16:14:29.093]                   NAME <- NAMES[[kk]]
[16:14:29.093]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.093]                     next
[16:14:29.093]                   args[[name]] <- ""
[16:14:29.093]                 }
[16:14:29.093]                 NAMES <- toupper(removed)
[16:14:29.093]                 for (kk in seq_along(NAMES)) {
[16:14:29.093]                   name <- removed[[kk]]
[16:14:29.093]                   NAME <- NAMES[[kk]]
[16:14:29.093]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.093]                     next
[16:14:29.093]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:29.093]                 }
[16:14:29.093]                 if (length(args) > 0) 
[16:14:29.093]                   base::do.call(base::Sys.setenv, args = args)
[16:14:29.093]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:29.093]             }
[16:14:29.093]             else {
[16:14:29.093]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:29.093]             }
[16:14:29.093]             {
[16:14:29.093]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:29.093]                   0L) {
[16:14:29.093]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:29.093]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:29.093]                   base::options(opts)
[16:14:29.093]                 }
[16:14:29.093]                 {
[16:14:29.093]                   {
[16:14:29.093]                     NULL
[16:14:29.093]                     RNGkind("Mersenne-Twister")
[16:14:29.093]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:14:29.093]                       inherits = FALSE)
[16:14:29.093]                   }
[16:14:29.093]                   options(future.plan = NULL)
[16:14:29.093]                   if (is.na(NA_character_)) 
[16:14:29.093]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:29.093]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:29.093]                   future::plan(list(function (..., envir = parent.frame()) 
[16:14:29.093]                   {
[16:14:29.093]                     future <- SequentialFuture(..., envir = envir)
[16:14:29.093]                     if (!future$lazy) 
[16:14:29.093]                       future <- run(future)
[16:14:29.093]                     invisible(future)
[16:14:29.093]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:29.093]                 }
[16:14:29.093]             }
[16:14:29.093]         }
[16:14:29.093]     })
[16:14:29.093]     if (TRUE) {
[16:14:29.093]         base::sink(type = "output", split = FALSE)
[16:14:29.093]         if (TRUE) {
[16:14:29.093]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:29.093]         }
[16:14:29.093]         else {
[16:14:29.093]             ...future.result["stdout"] <- base::list(NULL)
[16:14:29.093]         }
[16:14:29.093]         base::close(...future.stdout)
[16:14:29.093]         ...future.stdout <- NULL
[16:14:29.093]     }
[16:14:29.093]     ...future.result$conditions <- ...future.conditions
[16:14:29.093]     ...future.result$finished <- base::Sys.time()
[16:14:29.093]     ...future.result
[16:14:29.093] }
[16:14:29.095] plan(): Setting new future strategy stack:
[16:14:29.095] List of future strategies:
[16:14:29.095] 1. sequential:
[16:14:29.095]    - args: function (..., envir = parent.frame())
[16:14:29.095]    - tweaked: FALSE
[16:14:29.095]    - call: NULL
[16:14:29.095] plan(): nbrOfWorkers() = 1
[16:14:29.096] plan(): Setting new future strategy stack:
[16:14:29.096] List of future strategies:
[16:14:29.096] 1. sequential:
[16:14:29.096]    - args: function (..., envir = parent.frame())
[16:14:29.096]    - tweaked: FALSE
[16:14:29.096]    - call: plan(strategy)
[16:14:29.096] plan(): nbrOfWorkers() = 1
[16:14:29.096] SequentialFuture started (and completed)
[16:14:29.097] - Launch lazy future ... done
[16:14:29.097] run() for ‘SequentialFuture’ ... done
[1] 42
sequential ... done
Testing with 1 cores ... done
Testing with 2 cores ...
multicore ...
[16:14:29.102] plan(): Setting new future strategy stack:
[16:14:29.102] List of future strategies:
[16:14:29.102] 1. multicore:
[16:14:29.102]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:14:29.102]    - tweaked: FALSE
[16:14:29.102]    - call: plan(strategy)
[16:14:29.106] plan(): nbrOfWorkers() = 2
- stdout = TRUE
[16:14:29.106] getGlobalsAndPackages() ...
[16:14:29.106] Searching for globals...
[16:14:29.109] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[16:14:29.109] Searching for globals ... DONE
[16:14:29.109] Resolving globals: FALSE
[16:14:29.110] 
[16:14:29.110] - packages: [1] ‘utils’
[16:14:29.110] getGlobalsAndPackages() ... DONE
[16:14:29.110] run() for ‘Future’ ...
[16:14:29.110] - state: ‘created’
[16:14:29.110] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:14:29.114] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:14:29.114] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:14:29.114]   - Field: ‘label’
[16:14:29.114]   - Field: ‘local’
[16:14:29.114]   - Field: ‘owner’
[16:14:29.114]   - Field: ‘envir’
[16:14:29.114]   - Field: ‘workers’
[16:14:29.114]   - Field: ‘packages’
[16:14:29.115]   - Field: ‘gc’
[16:14:29.115]   - Field: ‘job’
[16:14:29.115]   - Field: ‘conditions’
[16:14:29.115]   - Field: ‘expr’
[16:14:29.115]   - Field: ‘uuid’
[16:14:29.115]   - Field: ‘seed’
[16:14:29.115]   - Field: ‘version’
[16:14:29.115]   - Field: ‘result’
[16:14:29.115]   - Field: ‘asynchronous’
[16:14:29.115]   - Field: ‘calls’
[16:14:29.115]   - Field: ‘globals’
[16:14:29.115]   - Field: ‘stdout’
[16:14:29.116]   - Field: ‘earlySignal’
[16:14:29.116]   - Field: ‘lazy’
[16:14:29.116]   - Field: ‘state’
[16:14:29.116] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:14:29.116] - Launch lazy future ...
[16:14:29.117] Packages needed by the future expression (n = 1): ‘utils’
[16:14:29.117] Packages needed by future strategies (n = 0): <none>
[16:14:29.118] {
[16:14:29.118]     {
[16:14:29.118]         {
[16:14:29.118]             ...future.startTime <- base::Sys.time()
[16:14:29.118]             {
[16:14:29.118]                 {
[16:14:29.118]                   {
[16:14:29.118]                     {
[16:14:29.118]                       {
[16:14:29.118]                         base::local({
[16:14:29.118]                           has_future <- base::requireNamespace("future", 
[16:14:29.118]                             quietly = TRUE)
[16:14:29.118]                           if (has_future) {
[16:14:29.118]                             ns <- base::getNamespace("future")
[16:14:29.118]                             version <- ns[[".package"]][["version"]]
[16:14:29.118]                             if (is.null(version)) 
[16:14:29.118]                               version <- utils::packageVersion("future")
[16:14:29.118]                           }
[16:14:29.118]                           else {
[16:14:29.118]                             version <- NULL
[16:14:29.118]                           }
[16:14:29.118]                           if (!has_future || version < "1.8.0") {
[16:14:29.118]                             info <- base::c(r_version = base::gsub("R version ", 
[16:14:29.118]                               "", base::R.version$version.string), 
[16:14:29.118]                               platform = base::sprintf("%s (%s-bit)", 
[16:14:29.118]                                 base::R.version$platform, 8 * 
[16:14:29.118]                                   base::.Machine$sizeof.pointer), 
[16:14:29.118]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:29.118]                                 "release", "version")], collapse = " "), 
[16:14:29.118]                               hostname = base::Sys.info()[["nodename"]])
[16:14:29.118]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:14:29.118]                               info)
[16:14:29.118]                             info <- base::paste(info, collapse = "; ")
[16:14:29.118]                             if (!has_future) {
[16:14:29.118]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:29.118]                                 info)
[16:14:29.118]                             }
[16:14:29.118]                             else {
[16:14:29.118]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:29.118]                                 info, version)
[16:14:29.118]                             }
[16:14:29.118]                             base::stop(msg)
[16:14:29.118]                           }
[16:14:29.118]                         })
[16:14:29.118]                       }
[16:14:29.118]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:14:29.118]                       base::options(mc.cores = 1L)
[16:14:29.118]                     }
[16:14:29.118]                     base::local({
[16:14:29.118]                       for (pkg in "utils") {
[16:14:29.118]                         base::loadNamespace(pkg)
[16:14:29.118]                         base::library(pkg, character.only = TRUE)
[16:14:29.118]                       }
[16:14:29.118]                     })
[16:14:29.118]                   }
[16:14:29.118]                   options(future.plan = NULL)
[16:14:29.118]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:29.118]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:29.118]                 }
[16:14:29.118]                 ...future.workdir <- getwd()
[16:14:29.118]             }
[16:14:29.118]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:29.118]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:29.118]         }
[16:14:29.118]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:29.118]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:29.118]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:29.118]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:29.118]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:29.118]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:29.118]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:29.118]             base::names(...future.oldOptions))
[16:14:29.118]     }
[16:14:29.118]     if (FALSE) {
[16:14:29.118]     }
[16:14:29.118]     else {
[16:14:29.118]         if (TRUE) {
[16:14:29.118]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:29.118]                 open = "w")
[16:14:29.118]         }
[16:14:29.118]         else {
[16:14:29.118]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:29.118]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:29.118]         }
[16:14:29.118]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:29.118]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:29.118]             base::sink(type = "output", split = FALSE)
[16:14:29.118]             base::close(...future.stdout)
[16:14:29.118]         }, add = TRUE)
[16:14:29.118]     }
[16:14:29.118]     ...future.frame <- base::sys.nframe()
[16:14:29.118]     ...future.conditions <- base::list()
[16:14:29.118]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:29.118]     if (FALSE) {
[16:14:29.118]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:29.118]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:29.118]     }
[16:14:29.118]     ...future.result <- base::tryCatch({
[16:14:29.118]         base::withCallingHandlers({
[16:14:29.118]             ...future.value <- base::withVisible(base::local({
[16:14:29.118]                 withCallingHandlers({
[16:14:29.118]                   {
[16:14:29.118]                     print(1:50)
[16:14:29.118]                     str(1:50)
[16:14:29.118]                     cat(letters, sep = "-")
[16:14:29.118]                     cat(1:6, collapse = "\n")
[16:14:29.118]                     write.table(datasets::iris[1:10, ], sep = "\t")
[16:14:29.118]                     42L
[16:14:29.118]                   }
[16:14:29.118]                 }, immediateCondition = function(cond) {
[16:14:29.118]                   save_rds <- function (object, pathname, ...) 
[16:14:29.118]                   {
[16:14:29.118]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:14:29.118]                     if (file_test("-f", pathname_tmp)) {
[16:14:29.118]                       fi_tmp <- file.info(pathname_tmp)
[16:14:29.118]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:14:29.118]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:14:29.118]                         fi_tmp[["mtime"]])
[16:14:29.118]                     }
[16:14:29.118]                     tryCatch({
[16:14:29.118]                       saveRDS(object, file = pathname_tmp, ...)
[16:14:29.118]                     }, error = function(ex) {
[16:14:29.118]                       msg <- conditionMessage(ex)
[16:14:29.118]                       fi_tmp <- file.info(pathname_tmp)
[16:14:29.118]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:14:29.118]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:14:29.118]                         fi_tmp[["mtime"]], msg)
[16:14:29.118]                       ex$message <- msg
[16:14:29.118]                       stop(ex)
[16:14:29.118]                     })
[16:14:29.118]                     stopifnot(file_test("-f", pathname_tmp))
[16:14:29.118]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:14:29.118]                     if (!res || file_test("-f", pathname_tmp)) {
[16:14:29.118]                       fi_tmp <- file.info(pathname_tmp)
[16:14:29.118]                       fi <- file.info(pathname)
[16:14:29.118]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:14:29.118]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:14:29.118]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:14:29.118]                         fi[["size"]], fi[["mtime"]])
[16:14:29.118]                       stop(msg)
[16:14:29.118]                     }
[16:14:29.118]                     invisible(pathname)
[16:14:29.118]                   }
[16:14:29.118]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:14:29.118]                     rootPath = tempdir()) 
[16:14:29.118]                   {
[16:14:29.118]                     obj <- list(time = Sys.time(), condition = cond)
[16:14:29.118]                     file <- tempfile(pattern = class(cond)[1], 
[16:14:29.118]                       tmpdir = path, fileext = ".rds")
[16:14:29.118]                     save_rds(obj, file)
[16:14:29.118]                   }
[16:14:29.118]                   saveImmediateCondition(cond, path = "/tmp/RtmpEpin5U/.future/immediateConditions")
[16:14:29.118]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.118]                   {
[16:14:29.118]                     inherits <- base::inherits
[16:14:29.118]                     invokeRestart <- base::invokeRestart
[16:14:29.118]                     is.null <- base::is.null
[16:14:29.118]                     muffled <- FALSE
[16:14:29.118]                     if (inherits(cond, "message")) {
[16:14:29.118]                       muffled <- grepl(pattern, "muffleMessage")
[16:14:29.118]                       if (muffled) 
[16:14:29.118]                         invokeRestart("muffleMessage")
[16:14:29.118]                     }
[16:14:29.118]                     else if (inherits(cond, "warning")) {
[16:14:29.118]                       muffled <- grepl(pattern, "muffleWarning")
[16:14:29.118]                       if (muffled) 
[16:14:29.118]                         invokeRestart("muffleWarning")
[16:14:29.118]                     }
[16:14:29.118]                     else if (inherits(cond, "condition")) {
[16:14:29.118]                       if (!is.null(pattern)) {
[16:14:29.118]                         computeRestarts <- base::computeRestarts
[16:14:29.118]                         grepl <- base::grepl
[16:14:29.118]                         restarts <- computeRestarts(cond)
[16:14:29.118]                         for (restart in restarts) {
[16:14:29.118]                           name <- restart$name
[16:14:29.118]                           if (is.null(name)) 
[16:14:29.118]                             next
[16:14:29.118]                           if (!grepl(pattern, name)) 
[16:14:29.118]                             next
[16:14:29.118]                           invokeRestart(restart)
[16:14:29.118]                           muffled <- TRUE
[16:14:29.118]                           break
[16:14:29.118]                         }
[16:14:29.118]                       }
[16:14:29.118]                     }
[16:14:29.118]                     invisible(muffled)
[16:14:29.118]                   }
[16:14:29.118]                   muffleCondition(cond)
[16:14:29.118]                 })
[16:14:29.118]             }))
[16:14:29.118]             future::FutureResult(value = ...future.value$value, 
[16:14:29.118]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:29.118]                   ...future.rng), globalenv = if (FALSE) 
[16:14:29.118]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:29.118]                     ...future.globalenv.names))
[16:14:29.118]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:29.118]         }, condition = base::local({
[16:14:29.118]             c <- base::c
[16:14:29.118]             inherits <- base::inherits
[16:14:29.118]             invokeRestart <- base::invokeRestart
[16:14:29.118]             length <- base::length
[16:14:29.118]             list <- base::list
[16:14:29.118]             seq.int <- base::seq.int
[16:14:29.118]             signalCondition <- base::signalCondition
[16:14:29.118]             sys.calls <- base::sys.calls
[16:14:29.118]             `[[` <- base::`[[`
[16:14:29.118]             `+` <- base::`+`
[16:14:29.118]             `<<-` <- base::`<<-`
[16:14:29.118]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:29.118]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:29.118]                   3L)]
[16:14:29.118]             }
[16:14:29.118]             function(cond) {
[16:14:29.118]                 is_error <- inherits(cond, "error")
[16:14:29.118]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:29.118]                   NULL)
[16:14:29.118]                 if (is_error) {
[16:14:29.118]                   sessionInformation <- function() {
[16:14:29.118]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:29.118]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:29.118]                       search = base::search(), system = base::Sys.info())
[16:14:29.118]                   }
[16:14:29.118]                   ...future.conditions[[length(...future.conditions) + 
[16:14:29.118]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:29.118]                     cond$call), session = sessionInformation(), 
[16:14:29.118]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:29.118]                   signalCondition(cond)
[16:14:29.118]                 }
[16:14:29.118]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:29.118]                 "immediateCondition"))) {
[16:14:29.118]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:29.118]                   ...future.conditions[[length(...future.conditions) + 
[16:14:29.118]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:29.118]                   if (TRUE && !signal) {
[16:14:29.118]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.118]                     {
[16:14:29.118]                       inherits <- base::inherits
[16:14:29.118]                       invokeRestart <- base::invokeRestart
[16:14:29.118]                       is.null <- base::is.null
[16:14:29.118]                       muffled <- FALSE
[16:14:29.118]                       if (inherits(cond, "message")) {
[16:14:29.118]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:29.118]                         if (muffled) 
[16:14:29.118]                           invokeRestart("muffleMessage")
[16:14:29.118]                       }
[16:14:29.118]                       else if (inherits(cond, "warning")) {
[16:14:29.118]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:29.118]                         if (muffled) 
[16:14:29.118]                           invokeRestart("muffleWarning")
[16:14:29.118]                       }
[16:14:29.118]                       else if (inherits(cond, "condition")) {
[16:14:29.118]                         if (!is.null(pattern)) {
[16:14:29.118]                           computeRestarts <- base::computeRestarts
[16:14:29.118]                           grepl <- base::grepl
[16:14:29.118]                           restarts <- computeRestarts(cond)
[16:14:29.118]                           for (restart in restarts) {
[16:14:29.118]                             name <- restart$name
[16:14:29.118]                             if (is.null(name)) 
[16:14:29.118]                               next
[16:14:29.118]                             if (!grepl(pattern, name)) 
[16:14:29.118]                               next
[16:14:29.118]                             invokeRestart(restart)
[16:14:29.118]                             muffled <- TRUE
[16:14:29.118]                             break
[16:14:29.118]                           }
[16:14:29.118]                         }
[16:14:29.118]                       }
[16:14:29.118]                       invisible(muffled)
[16:14:29.118]                     }
[16:14:29.118]                     muffleCondition(cond, pattern = "^muffle")
[16:14:29.118]                   }
[16:14:29.118]                 }
[16:14:29.118]                 else {
[16:14:29.118]                   if (TRUE) {
[16:14:29.118]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.118]                     {
[16:14:29.118]                       inherits <- base::inherits
[16:14:29.118]                       invokeRestart <- base::invokeRestart
[16:14:29.118]                       is.null <- base::is.null
[16:14:29.118]                       muffled <- FALSE
[16:14:29.118]                       if (inherits(cond, "message")) {
[16:14:29.118]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:29.118]                         if (muffled) 
[16:14:29.118]                           invokeRestart("muffleMessage")
[16:14:29.118]                       }
[16:14:29.118]                       else if (inherits(cond, "warning")) {
[16:14:29.118]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:29.118]                         if (muffled) 
[16:14:29.118]                           invokeRestart("muffleWarning")
[16:14:29.118]                       }
[16:14:29.118]                       else if (inherits(cond, "condition")) {
[16:14:29.118]                         if (!is.null(pattern)) {
[16:14:29.118]                           computeRestarts <- base::computeRestarts
[16:14:29.118]                           grepl <- base::grepl
[16:14:29.118]                           restarts <- computeRestarts(cond)
[16:14:29.118]                           for (restart in restarts) {
[16:14:29.118]                             name <- restart$name
[16:14:29.118]                             if (is.null(name)) 
[16:14:29.118]                               next
[16:14:29.118]                             if (!grepl(pattern, name)) 
[16:14:29.118]                               next
[16:14:29.118]                             invokeRestart(restart)
[16:14:29.118]                             muffled <- TRUE
[16:14:29.118]                             break
[16:14:29.118]                           }
[16:14:29.118]                         }
[16:14:29.118]                       }
[16:14:29.118]                       invisible(muffled)
[16:14:29.118]                     }
[16:14:29.118]                     muffleCondition(cond, pattern = "^muffle")
[16:14:29.118]                   }
[16:14:29.118]                 }
[16:14:29.118]             }
[16:14:29.118]         }))
[16:14:29.118]     }, error = function(ex) {
[16:14:29.118]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:29.118]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:29.118]                 ...future.rng), started = ...future.startTime, 
[16:14:29.118]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:29.118]             version = "1.8"), class = "FutureResult")
[16:14:29.118]     }, finally = {
[16:14:29.118]         if (!identical(...future.workdir, getwd())) 
[16:14:29.118]             setwd(...future.workdir)
[16:14:29.118]         {
[16:14:29.118]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:29.118]                 ...future.oldOptions$nwarnings <- NULL
[16:14:29.118]             }
[16:14:29.118]             base::options(...future.oldOptions)
[16:14:29.118]             if (.Platform$OS.type == "windows") {
[16:14:29.118]                 old_names <- names(...future.oldEnvVars)
[16:14:29.118]                 envs <- base::Sys.getenv()
[16:14:29.118]                 names <- names(envs)
[16:14:29.118]                 common <- intersect(names, old_names)
[16:14:29.118]                 added <- setdiff(names, old_names)
[16:14:29.118]                 removed <- setdiff(old_names, names)
[16:14:29.118]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:29.118]                   envs[common]]
[16:14:29.118]                 NAMES <- toupper(changed)
[16:14:29.118]                 args <- list()
[16:14:29.118]                 for (kk in seq_along(NAMES)) {
[16:14:29.118]                   name <- changed[[kk]]
[16:14:29.118]                   NAME <- NAMES[[kk]]
[16:14:29.118]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.118]                     next
[16:14:29.118]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:29.118]                 }
[16:14:29.118]                 NAMES <- toupper(added)
[16:14:29.118]                 for (kk in seq_along(NAMES)) {
[16:14:29.118]                   name <- added[[kk]]
[16:14:29.118]                   NAME <- NAMES[[kk]]
[16:14:29.118]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.118]                     next
[16:14:29.118]                   args[[name]] <- ""
[16:14:29.118]                 }
[16:14:29.118]                 NAMES <- toupper(removed)
[16:14:29.118]                 for (kk in seq_along(NAMES)) {
[16:14:29.118]                   name <- removed[[kk]]
[16:14:29.118]                   NAME <- NAMES[[kk]]
[16:14:29.118]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.118]                     next
[16:14:29.118]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:29.118]                 }
[16:14:29.118]                 if (length(args) > 0) 
[16:14:29.118]                   base::do.call(base::Sys.setenv, args = args)
[16:14:29.118]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:29.118]             }
[16:14:29.118]             else {
[16:14:29.118]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:29.118]             }
[16:14:29.118]             {
[16:14:29.118]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:29.118]                   0L) {
[16:14:29.118]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:29.118]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:29.118]                   base::options(opts)
[16:14:29.118]                 }
[16:14:29.118]                 {
[16:14:29.118]                   {
[16:14:29.118]                     base::options(mc.cores = ...future.mc.cores.old)
[16:14:29.118]                     NULL
[16:14:29.118]                   }
[16:14:29.118]                   options(future.plan = NULL)
[16:14:29.118]                   if (is.na(NA_character_)) 
[16:14:29.118]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:29.118]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:29.118]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:14:29.118]                     envir = parent.frame()) 
[16:14:29.118]                   {
[16:14:29.118]                     default_workers <- missing(workers)
[16:14:29.118]                     if (is.function(workers)) 
[16:14:29.118]                       workers <- workers()
[16:14:29.118]                     workers <- structure(as.integer(workers), 
[16:14:29.118]                       class = class(workers))
[16:14:29.118]                     stop_if_not(is.finite(workers), workers >= 
[16:14:29.118]                       1L)
[16:14:29.118]                     if ((workers == 1L && !inherits(workers, 
[16:14:29.118]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:14:29.118]                       if (default_workers) 
[16:14:29.118]                         supportsMulticore(warn = TRUE)
[16:14:29.118]                       return(sequential(..., envir = envir))
[16:14:29.118]                     }
[16:14:29.118]                     oopts <- options(mc.cores = workers)
[16:14:29.118]                     on.exit(options(oopts))
[16:14:29.118]                     future <- MulticoreFuture(..., workers = workers, 
[16:14:29.118]                       envir = envir)
[16:14:29.118]                     if (!future$lazy) 
[16:14:29.118]                       future <- run(future)
[16:14:29.118]                     invisible(future)
[16:14:29.118]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:29.118]                 }
[16:14:29.118]             }
[16:14:29.118]         }
[16:14:29.118]     })
[16:14:29.118]     if (TRUE) {
[16:14:29.118]         base::sink(type = "output", split = FALSE)
[16:14:29.118]         if (TRUE) {
[16:14:29.118]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:29.118]         }
[16:14:29.118]         else {
[16:14:29.118]             ...future.result["stdout"] <- base::list(NULL)
[16:14:29.118]         }
[16:14:29.118]         base::close(...future.stdout)
[16:14:29.118]         ...future.stdout <- NULL
[16:14:29.118]     }
[16:14:29.118]     ...future.result$conditions <- ...future.conditions
[16:14:29.118]     ...future.result$finished <- base::Sys.time()
[16:14:29.118]     ...future.result
[16:14:29.118] }
[16:14:29.120] requestCore(): workers = 2
[16:14:29.123] MulticoreFuture started
[16:14:29.123] - Launch lazy future ... done
[16:14:29.123] run() for ‘MulticoreFuture’ ... done
[16:14:29.124] plan(): Setting new future strategy stack:
[16:14:29.124] List of future strategies:
[16:14:29.124] 1. sequential:
[16:14:29.124]    - args: function (..., envir = parent.frame())
[16:14:29.124]    - tweaked: FALSE
[16:14:29.124]    - call: NULL
[16:14:29.129] plan(): nbrOfWorkers() = 1
[16:14:29.133] plan(): Setting new future strategy stack:
[16:14:29.133] List of future strategies:
[16:14:29.133] 1. multicore:
[16:14:29.133]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:14:29.133]    - tweaked: FALSE
[16:14:29.133]    - call: plan(strategy)
[16:14:29.138] plan(): nbrOfWorkers() = 2
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : chr " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 3"| __truncated__
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-01-06 16:14:29"
 $ finished    : POSIXct[1:1], format: "2025-01-06 16:14:29"
 $ session_uuid: chr "16f4a02b-8e1f-a410-0d6e-cdd8ae210e68"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "2729ef2608da"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "2729ef2608da" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 92332
  .. ..$ time  : POSIXct[1:1], format: "2025-01-06 16:14:29"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 3 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
FutureResult:
value: ‘integer’
visible: TRUE
stdout: character
conditions: [n = 0] 
RNG used: FALSE
duration: 0.01569772 secs (started 2025-01-06 16:14:29.12329)
version: 1.8
[16:14:29.153] getGlobalsAndPackages() ...
[16:14:29.153] Searching for globals...
[16:14:29.157] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[16:14:29.157] Searching for globals ... DONE
[16:14:29.157] Resolving globals: FALSE
[16:14:29.158] 
[16:14:29.158] - packages: [1] ‘utils’
[16:14:29.158] getGlobalsAndPackages() ... DONE
[16:14:29.158] run() for ‘Future’ ...
[16:14:29.158] - state: ‘created’
[16:14:29.159] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:14:29.163] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:14:29.163] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:14:29.163]   - Field: ‘label’
[16:14:29.163]   - Field: ‘local’
[16:14:29.163]   - Field: ‘owner’
[16:14:29.163]   - Field: ‘envir’
[16:14:29.163]   - Field: ‘workers’
[16:14:29.163]   - Field: ‘packages’
[16:14:29.163]   - Field: ‘gc’
[16:14:29.164]   - Field: ‘job’
[16:14:29.164]   - Field: ‘conditions’
[16:14:29.164]   - Field: ‘expr’
[16:14:29.164]   - Field: ‘uuid’
[16:14:29.164]   - Field: ‘seed’
[16:14:29.164]   - Field: ‘version’
[16:14:29.164]   - Field: ‘result’
[16:14:29.164]   - Field: ‘asynchronous’
[16:14:29.164]   - Field: ‘calls’
[16:14:29.165]   - Field: ‘globals’
[16:14:29.165]   - Field: ‘stdout’
[16:14:29.165]   - Field: ‘earlySignal’
[16:14:29.165]   - Field: ‘lazy’
[16:14:29.165]   - Field: ‘state’
[16:14:29.165] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:14:29.165] - Launch lazy future ...
[16:14:29.165] Packages needed by the future expression (n = 1): ‘utils’
[16:14:29.166] Packages needed by future strategies (n = 0): <none>
[16:14:29.166] {
[16:14:29.166]     {
[16:14:29.166]         {
[16:14:29.166]             ...future.startTime <- base::Sys.time()
[16:14:29.166]             {
[16:14:29.166]                 {
[16:14:29.166]                   {
[16:14:29.166]                     {
[16:14:29.166]                       {
[16:14:29.166]                         base::local({
[16:14:29.166]                           has_future <- base::requireNamespace("future", 
[16:14:29.166]                             quietly = TRUE)
[16:14:29.166]                           if (has_future) {
[16:14:29.166]                             ns <- base::getNamespace("future")
[16:14:29.166]                             version <- ns[[".package"]][["version"]]
[16:14:29.166]                             if (is.null(version)) 
[16:14:29.166]                               version <- utils::packageVersion("future")
[16:14:29.166]                           }
[16:14:29.166]                           else {
[16:14:29.166]                             version <- NULL
[16:14:29.166]                           }
[16:14:29.166]                           if (!has_future || version < "1.8.0") {
[16:14:29.166]                             info <- base::c(r_version = base::gsub("R version ", 
[16:14:29.166]                               "", base::R.version$version.string), 
[16:14:29.166]                               platform = base::sprintf("%s (%s-bit)", 
[16:14:29.166]                                 base::R.version$platform, 8 * 
[16:14:29.166]                                   base::.Machine$sizeof.pointer), 
[16:14:29.166]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:29.166]                                 "release", "version")], collapse = " "), 
[16:14:29.166]                               hostname = base::Sys.info()[["nodename"]])
[16:14:29.166]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:14:29.166]                               info)
[16:14:29.166]                             info <- base::paste(info, collapse = "; ")
[16:14:29.166]                             if (!has_future) {
[16:14:29.166]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:29.166]                                 info)
[16:14:29.166]                             }
[16:14:29.166]                             else {
[16:14:29.166]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:29.166]                                 info, version)
[16:14:29.166]                             }
[16:14:29.166]                             base::stop(msg)
[16:14:29.166]                           }
[16:14:29.166]                         })
[16:14:29.166]                       }
[16:14:29.166]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:14:29.166]                       base::options(mc.cores = 1L)
[16:14:29.166]                     }
[16:14:29.166]                     base::local({
[16:14:29.166]                       for (pkg in "utils") {
[16:14:29.166]                         base::loadNamespace(pkg)
[16:14:29.166]                         base::library(pkg, character.only = TRUE)
[16:14:29.166]                       }
[16:14:29.166]                     })
[16:14:29.166]                   }
[16:14:29.166]                   options(future.plan = NULL)
[16:14:29.166]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:29.166]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:29.166]                 }
[16:14:29.166]                 ...future.workdir <- getwd()
[16:14:29.166]             }
[16:14:29.166]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:29.166]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:29.166]         }
[16:14:29.166]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:29.166]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:29.166]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:29.166]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:29.166]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:29.166]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:29.166]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:29.166]             base::names(...future.oldOptions))
[16:14:29.166]     }
[16:14:29.166]     if (FALSE) {
[16:14:29.166]     }
[16:14:29.166]     else {
[16:14:29.166]         if (TRUE) {
[16:14:29.166]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:29.166]                 open = "w")
[16:14:29.166]         }
[16:14:29.166]         else {
[16:14:29.166]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:29.166]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:29.166]         }
[16:14:29.166]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:29.166]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:29.166]             base::sink(type = "output", split = FALSE)
[16:14:29.166]             base::close(...future.stdout)
[16:14:29.166]         }, add = TRUE)
[16:14:29.166]     }
[16:14:29.166]     ...future.frame <- base::sys.nframe()
[16:14:29.166]     ...future.conditions <- base::list()
[16:14:29.166]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:29.166]     if (FALSE) {
[16:14:29.166]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:29.166]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:29.166]     }
[16:14:29.166]     ...future.result <- base::tryCatch({
[16:14:29.166]         base::withCallingHandlers({
[16:14:29.166]             ...future.value <- base::withVisible(base::local({
[16:14:29.166]                 withCallingHandlers({
[16:14:29.166]                   {
[16:14:29.166]                     print(1:50)
[16:14:29.166]                     str(1:50)
[16:14:29.166]                     cat(letters, sep = "-")
[16:14:29.166]                     cat(1:6, collapse = "\n")
[16:14:29.166]                     write.table(datasets::iris[1:10, ], sep = "\t")
[16:14:29.166]                     42L
[16:14:29.166]                   }
[16:14:29.166]                 }, immediateCondition = function(cond) {
[16:14:29.166]                   save_rds <- function (object, pathname, ...) 
[16:14:29.166]                   {
[16:14:29.166]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:14:29.166]                     if (file_test("-f", pathname_tmp)) {
[16:14:29.166]                       fi_tmp <- file.info(pathname_tmp)
[16:14:29.166]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:14:29.166]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:14:29.166]                         fi_tmp[["mtime"]])
[16:14:29.166]                     }
[16:14:29.166]                     tryCatch({
[16:14:29.166]                       saveRDS(object, file = pathname_tmp, ...)
[16:14:29.166]                     }, error = function(ex) {
[16:14:29.166]                       msg <- conditionMessage(ex)
[16:14:29.166]                       fi_tmp <- file.info(pathname_tmp)
[16:14:29.166]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:14:29.166]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:14:29.166]                         fi_tmp[["mtime"]], msg)
[16:14:29.166]                       ex$message <- msg
[16:14:29.166]                       stop(ex)
[16:14:29.166]                     })
[16:14:29.166]                     stopifnot(file_test("-f", pathname_tmp))
[16:14:29.166]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:14:29.166]                     if (!res || file_test("-f", pathname_tmp)) {
[16:14:29.166]                       fi_tmp <- file.info(pathname_tmp)
[16:14:29.166]                       fi <- file.info(pathname)
[16:14:29.166]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:14:29.166]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:14:29.166]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:14:29.166]                         fi[["size"]], fi[["mtime"]])
[16:14:29.166]                       stop(msg)
[16:14:29.166]                     }
[16:14:29.166]                     invisible(pathname)
[16:14:29.166]                   }
[16:14:29.166]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:14:29.166]                     rootPath = tempdir()) 
[16:14:29.166]                   {
[16:14:29.166]                     obj <- list(time = Sys.time(), condition = cond)
[16:14:29.166]                     file <- tempfile(pattern = class(cond)[1], 
[16:14:29.166]                       tmpdir = path, fileext = ".rds")
[16:14:29.166]                     save_rds(obj, file)
[16:14:29.166]                   }
[16:14:29.166]                   saveImmediateCondition(cond, path = "/tmp/RtmpEpin5U/.future/immediateConditions")
[16:14:29.166]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.166]                   {
[16:14:29.166]                     inherits <- base::inherits
[16:14:29.166]                     invokeRestart <- base::invokeRestart
[16:14:29.166]                     is.null <- base::is.null
[16:14:29.166]                     muffled <- FALSE
[16:14:29.166]                     if (inherits(cond, "message")) {
[16:14:29.166]                       muffled <- grepl(pattern, "muffleMessage")
[16:14:29.166]                       if (muffled) 
[16:14:29.166]                         invokeRestart("muffleMessage")
[16:14:29.166]                     }
[16:14:29.166]                     else if (inherits(cond, "warning")) {
[16:14:29.166]                       muffled <- grepl(pattern, "muffleWarning")
[16:14:29.166]                       if (muffled) 
[16:14:29.166]                         invokeRestart("muffleWarning")
[16:14:29.166]                     }
[16:14:29.166]                     else if (inherits(cond, "condition")) {
[16:14:29.166]                       if (!is.null(pattern)) {
[16:14:29.166]                         computeRestarts <- base::computeRestarts
[16:14:29.166]                         grepl <- base::grepl
[16:14:29.166]                         restarts <- computeRestarts(cond)
[16:14:29.166]                         for (restart in restarts) {
[16:14:29.166]                           name <- restart$name
[16:14:29.166]                           if (is.null(name)) 
[16:14:29.166]                             next
[16:14:29.166]                           if (!grepl(pattern, name)) 
[16:14:29.166]                             next
[16:14:29.166]                           invokeRestart(restart)
[16:14:29.166]                           muffled <- TRUE
[16:14:29.166]                           break
[16:14:29.166]                         }
[16:14:29.166]                       }
[16:14:29.166]                     }
[16:14:29.166]                     invisible(muffled)
[16:14:29.166]                   }
[16:14:29.166]                   muffleCondition(cond)
[16:14:29.166]                 })
[16:14:29.166]             }))
[16:14:29.166]             future::FutureResult(value = ...future.value$value, 
[16:14:29.166]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:29.166]                   ...future.rng), globalenv = if (FALSE) 
[16:14:29.166]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:29.166]                     ...future.globalenv.names))
[16:14:29.166]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:29.166]         }, condition = base::local({
[16:14:29.166]             c <- base::c
[16:14:29.166]             inherits <- base::inherits
[16:14:29.166]             invokeRestart <- base::invokeRestart
[16:14:29.166]             length <- base::length
[16:14:29.166]             list <- base::list
[16:14:29.166]             seq.int <- base::seq.int
[16:14:29.166]             signalCondition <- base::signalCondition
[16:14:29.166]             sys.calls <- base::sys.calls
[16:14:29.166]             `[[` <- base::`[[`
[16:14:29.166]             `+` <- base::`+`
[16:14:29.166]             `<<-` <- base::`<<-`
[16:14:29.166]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:29.166]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:29.166]                   3L)]
[16:14:29.166]             }
[16:14:29.166]             function(cond) {
[16:14:29.166]                 is_error <- inherits(cond, "error")
[16:14:29.166]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:29.166]                   NULL)
[16:14:29.166]                 if (is_error) {
[16:14:29.166]                   sessionInformation <- function() {
[16:14:29.166]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:29.166]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:29.166]                       search = base::search(), system = base::Sys.info())
[16:14:29.166]                   }
[16:14:29.166]                   ...future.conditions[[length(...future.conditions) + 
[16:14:29.166]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:29.166]                     cond$call), session = sessionInformation(), 
[16:14:29.166]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:29.166]                   signalCondition(cond)
[16:14:29.166]                 }
[16:14:29.166]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:29.166]                 "immediateCondition"))) {
[16:14:29.166]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:29.166]                   ...future.conditions[[length(...future.conditions) + 
[16:14:29.166]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:29.166]                   if (TRUE && !signal) {
[16:14:29.166]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.166]                     {
[16:14:29.166]                       inherits <- base::inherits
[16:14:29.166]                       invokeRestart <- base::invokeRestart
[16:14:29.166]                       is.null <- base::is.null
[16:14:29.166]                       muffled <- FALSE
[16:14:29.166]                       if (inherits(cond, "message")) {
[16:14:29.166]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:29.166]                         if (muffled) 
[16:14:29.166]                           invokeRestart("muffleMessage")
[16:14:29.166]                       }
[16:14:29.166]                       else if (inherits(cond, "warning")) {
[16:14:29.166]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:29.166]                         if (muffled) 
[16:14:29.166]                           invokeRestart("muffleWarning")
[16:14:29.166]                       }
[16:14:29.166]                       else if (inherits(cond, "condition")) {
[16:14:29.166]                         if (!is.null(pattern)) {
[16:14:29.166]                           computeRestarts <- base::computeRestarts
[16:14:29.166]                           grepl <- base::grepl
[16:14:29.166]                           restarts <- computeRestarts(cond)
[16:14:29.166]                           for (restart in restarts) {
[16:14:29.166]                             name <- restart$name
[16:14:29.166]                             if (is.null(name)) 
[16:14:29.166]                               next
[16:14:29.166]                             if (!grepl(pattern, name)) 
[16:14:29.166]                               next
[16:14:29.166]                             invokeRestart(restart)
[16:14:29.166]                             muffled <- TRUE
[16:14:29.166]                             break
[16:14:29.166]                           }
[16:14:29.166]                         }
[16:14:29.166]                       }
[16:14:29.166]                       invisible(muffled)
[16:14:29.166]                     }
[16:14:29.166]                     muffleCondition(cond, pattern = "^muffle")
[16:14:29.166]                   }
[16:14:29.166]                 }
[16:14:29.166]                 else {
[16:14:29.166]                   if (TRUE) {
[16:14:29.166]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.166]                     {
[16:14:29.166]                       inherits <- base::inherits
[16:14:29.166]                       invokeRestart <- base::invokeRestart
[16:14:29.166]                       is.null <- base::is.null
[16:14:29.166]                       muffled <- FALSE
[16:14:29.166]                       if (inherits(cond, "message")) {
[16:14:29.166]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:29.166]                         if (muffled) 
[16:14:29.166]                           invokeRestart("muffleMessage")
[16:14:29.166]                       }
[16:14:29.166]                       else if (inherits(cond, "warning")) {
[16:14:29.166]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:29.166]                         if (muffled) 
[16:14:29.166]                           invokeRestart("muffleWarning")
[16:14:29.166]                       }
[16:14:29.166]                       else if (inherits(cond, "condition")) {
[16:14:29.166]                         if (!is.null(pattern)) {
[16:14:29.166]                           computeRestarts <- base::computeRestarts
[16:14:29.166]                           grepl <- base::grepl
[16:14:29.166]                           restarts <- computeRestarts(cond)
[16:14:29.166]                           for (restart in restarts) {
[16:14:29.166]                             name <- restart$name
[16:14:29.166]                             if (is.null(name)) 
[16:14:29.166]                               next
[16:14:29.166]                             if (!grepl(pattern, name)) 
[16:14:29.166]                               next
[16:14:29.166]                             invokeRestart(restart)
[16:14:29.166]                             muffled <- TRUE
[16:14:29.166]                             break
[16:14:29.166]                           }
[16:14:29.166]                         }
[16:14:29.166]                       }
[16:14:29.166]                       invisible(muffled)
[16:14:29.166]                     }
[16:14:29.166]                     muffleCondition(cond, pattern = "^muffle")
[16:14:29.166]                   }
[16:14:29.166]                 }
[16:14:29.166]             }
[16:14:29.166]         }))
[16:14:29.166]     }, error = function(ex) {
[16:14:29.166]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:29.166]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:29.166]                 ...future.rng), started = ...future.startTime, 
[16:14:29.166]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:29.166]             version = "1.8"), class = "FutureResult")
[16:14:29.166]     }, finally = {
[16:14:29.166]         if (!identical(...future.workdir, getwd())) 
[16:14:29.166]             setwd(...future.workdir)
[16:14:29.166]         {
[16:14:29.166]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:29.166]                 ...future.oldOptions$nwarnings <- NULL
[16:14:29.166]             }
[16:14:29.166]             base::options(...future.oldOptions)
[16:14:29.166]             if (.Platform$OS.type == "windows") {
[16:14:29.166]                 old_names <- names(...future.oldEnvVars)
[16:14:29.166]                 envs <- base::Sys.getenv()
[16:14:29.166]                 names <- names(envs)
[16:14:29.166]                 common <- intersect(names, old_names)
[16:14:29.166]                 added <- setdiff(names, old_names)
[16:14:29.166]                 removed <- setdiff(old_names, names)
[16:14:29.166]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:29.166]                   envs[common]]
[16:14:29.166]                 NAMES <- toupper(changed)
[16:14:29.166]                 args <- list()
[16:14:29.166]                 for (kk in seq_along(NAMES)) {
[16:14:29.166]                   name <- changed[[kk]]
[16:14:29.166]                   NAME <- NAMES[[kk]]
[16:14:29.166]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.166]                     next
[16:14:29.166]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:29.166]                 }
[16:14:29.166]                 NAMES <- toupper(added)
[16:14:29.166]                 for (kk in seq_along(NAMES)) {
[16:14:29.166]                   name <- added[[kk]]
[16:14:29.166]                   NAME <- NAMES[[kk]]
[16:14:29.166]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.166]                     next
[16:14:29.166]                   args[[name]] <- ""
[16:14:29.166]                 }
[16:14:29.166]                 NAMES <- toupper(removed)
[16:14:29.166]                 for (kk in seq_along(NAMES)) {
[16:14:29.166]                   name <- removed[[kk]]
[16:14:29.166]                   NAME <- NAMES[[kk]]
[16:14:29.166]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.166]                     next
[16:14:29.166]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:29.166]                 }
[16:14:29.166]                 if (length(args) > 0) 
[16:14:29.166]                   base::do.call(base::Sys.setenv, args = args)
[16:14:29.166]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:29.166]             }
[16:14:29.166]             else {
[16:14:29.166]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:29.166]             }
[16:14:29.166]             {
[16:14:29.166]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:29.166]                   0L) {
[16:14:29.166]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:29.166]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:29.166]                   base::options(opts)
[16:14:29.166]                 }
[16:14:29.166]                 {
[16:14:29.166]                   {
[16:14:29.166]                     base::options(mc.cores = ...future.mc.cores.old)
[16:14:29.166]                     NULL
[16:14:29.166]                   }
[16:14:29.166]                   options(future.plan = NULL)
[16:14:29.166]                   if (is.na(NA_character_)) 
[16:14:29.166]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:29.166]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:29.166]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:14:29.166]                     envir = parent.frame()) 
[16:14:29.166]                   {
[16:14:29.166]                     default_workers <- missing(workers)
[16:14:29.166]                     if (is.function(workers)) 
[16:14:29.166]                       workers <- workers()
[16:14:29.166]                     workers <- structure(as.integer(workers), 
[16:14:29.166]                       class = class(workers))
[16:14:29.166]                     stop_if_not(is.finite(workers), workers >= 
[16:14:29.166]                       1L)
[16:14:29.166]                     if ((workers == 1L && !inherits(workers, 
[16:14:29.166]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:14:29.166]                       if (default_workers) 
[16:14:29.166]                         supportsMulticore(warn = TRUE)
[16:14:29.166]                       return(sequential(..., envir = envir))
[16:14:29.166]                     }
[16:14:29.166]                     oopts <- options(mc.cores = workers)
[16:14:29.166]                     on.exit(options(oopts))
[16:14:29.166]                     future <- MulticoreFuture(..., workers = workers, 
[16:14:29.166]                       envir = envir)
[16:14:29.166]                     if (!future$lazy) 
[16:14:29.166]                       future <- run(future)
[16:14:29.166]                     invisible(future)
[16:14:29.166]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:29.166]                 }
[16:14:29.166]             }
[16:14:29.166]         }
[16:14:29.166]     })
[16:14:29.166]     if (TRUE) {
[16:14:29.166]         base::sink(type = "output", split = FALSE)
[16:14:29.166]         if (TRUE) {
[16:14:29.166]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:29.166]         }
[16:14:29.166]         else {
[16:14:29.166]             ...future.result["stdout"] <- base::list(NULL)
[16:14:29.166]         }
[16:14:29.166]         base::close(...future.stdout)
[16:14:29.166]         ...future.stdout <- NULL
[16:14:29.166]     }
[16:14:29.166]     ...future.result$conditions <- ...future.conditions
[16:14:29.166]     ...future.result$finished <- base::Sys.time()
[16:14:29.166]     ...future.result
[16:14:29.166] }
[16:14:29.169] requestCore(): workers = 2
[16:14:29.171] MulticoreFuture started
[16:14:29.171] - Launch lazy future ... done
[16:14:29.171] run() for ‘MulticoreFuture’ ... done
[16:14:29.172] plan(): Setting new future strategy stack:
[16:14:29.173] List of future strategies:
[16:14:29.173] 1. sequential:
[16:14:29.173]    - args: function (..., envir = parent.frame())
[16:14:29.173]    - tweaked: FALSE
[16:14:29.173]    - call: NULL
[16:14:29.173] plan(): nbrOfWorkers() = 1
[16:14:29.181] plan(): Setting new future strategy stack:
[16:14:29.181] List of future strategies:
[16:14:29.181] 1. multicore:
[16:14:29.181]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:14:29.181]    - tweaked: FALSE
[16:14:29.181]    - call: plan(strategy)
[16:14:29.187] plan(): nbrOfWorkers() = 2
 [1] " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25"  
 [2] "[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50"  
 [3] " int [1:50] 1 2 3 4 5 6 7 8 9 10 ..."                                             
 [4] "a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 "                  
 [5] "\"Sepal.Length\"\t\"Sepal.Width\"\t\"Petal.Length\"\t\"Petal.Width\"\t\"Species\""
 [6] "\"1\"\t5.1\t3.5\t1.4\t0.2\t\"setosa\""                                            
 [7] "\"2\"\t4.9\t3\t1.4\t0.2\t\"setosa\""                                              
 [8] "\"3\"\t4.7\t3.2\t1.3\t0.2\t\"setosa\""                                            
 [9] "\"4\"\t4.6\t3.1\t1.5\t0.2\t\"setosa\""                                            
[10] "\"5\"\t5\t3.6\t1.4\t0.2\t\"setosa\""                                              
[11] "\"6\"\t5.4\t3.9\t1.7\t0.4\t\"setosa\""                                            
[12] "\"7\"\t4.6\t3.4\t1.4\t0.3\t\"setosa\""                                            
[13] "\"8\"\t5\t3.4\t1.5\t0.2\t\"setosa\""                                              
[14] "\"9\"\t4.4\t2.9\t1.4\t0.2\t\"setosa\""                                            
[15] "\"10\"\t4.9\t3.1\t1.5\t0.1\t\"setosa\""                                           
- stdout = structure(TRUE, drop = TRUE)
[16:14:29.188] getGlobalsAndPackages() ...
[16:14:29.189] Searching for globals...
[16:14:29.192] - globals found: [1] ‘print’
[16:14:29.192] Searching for globals ... DONE
[16:14:29.192] Resolving globals: FALSE
[16:14:29.192] 
[16:14:29.192] 
[16:14:29.193] getGlobalsAndPackages() ... DONE
[16:14:29.193] run() for ‘Future’ ...
[16:14:29.193] - state: ‘created’
[16:14:29.193] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:14:29.198] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:14:29.198] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:14:29.198]   - Field: ‘label’
[16:14:29.198]   - Field: ‘local’
[16:14:29.198]   - Field: ‘owner’
[16:14:29.198]   - Field: ‘envir’
[16:14:29.198]   - Field: ‘workers’
[16:14:29.198]   - Field: ‘packages’
[16:14:29.199]   - Field: ‘gc’
[16:14:29.199]   - Field: ‘job’
[16:14:29.199]   - Field: ‘conditions’
[16:14:29.199]   - Field: ‘expr’
[16:14:29.199]   - Field: ‘uuid’
[16:14:29.199]   - Field: ‘seed’
[16:14:29.199]   - Field: ‘version’
[16:14:29.199]   - Field: ‘result’
[16:14:29.200]   - Field: ‘asynchronous’
[16:14:29.200]   - Field: ‘calls’
[16:14:29.200]   - Field: ‘globals’
[16:14:29.200]   - Field: ‘stdout’
[16:14:29.200]   - Field: ‘earlySignal’
[16:14:29.200]   - Field: ‘lazy’
[16:14:29.200]   - Field: ‘state’
[16:14:29.201] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:14:29.201] - Launch lazy future ...
[16:14:29.201] Packages needed by the future expression (n = 0): <none>
[16:14:29.201] Packages needed by future strategies (n = 0): <none>
[16:14:29.202] {
[16:14:29.202]     {
[16:14:29.202]         {
[16:14:29.202]             ...future.startTime <- base::Sys.time()
[16:14:29.202]             {
[16:14:29.202]                 {
[16:14:29.202]                   {
[16:14:29.202]                     {
[16:14:29.202]                       base::local({
[16:14:29.202]                         has_future <- base::requireNamespace("future", 
[16:14:29.202]                           quietly = TRUE)
[16:14:29.202]                         if (has_future) {
[16:14:29.202]                           ns <- base::getNamespace("future")
[16:14:29.202]                           version <- ns[[".package"]][["version"]]
[16:14:29.202]                           if (is.null(version)) 
[16:14:29.202]                             version <- utils::packageVersion("future")
[16:14:29.202]                         }
[16:14:29.202]                         else {
[16:14:29.202]                           version <- NULL
[16:14:29.202]                         }
[16:14:29.202]                         if (!has_future || version < "1.8.0") {
[16:14:29.202]                           info <- base::c(r_version = base::gsub("R version ", 
[16:14:29.202]                             "", base::R.version$version.string), 
[16:14:29.202]                             platform = base::sprintf("%s (%s-bit)", 
[16:14:29.202]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:14:29.202]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:29.202]                               "release", "version")], collapse = " "), 
[16:14:29.202]                             hostname = base::Sys.info()[["nodename"]])
[16:14:29.202]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:14:29.202]                             info)
[16:14:29.202]                           info <- base::paste(info, collapse = "; ")
[16:14:29.202]                           if (!has_future) {
[16:14:29.202]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:29.202]                               info)
[16:14:29.202]                           }
[16:14:29.202]                           else {
[16:14:29.202]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:29.202]                               info, version)
[16:14:29.202]                           }
[16:14:29.202]                           base::stop(msg)
[16:14:29.202]                         }
[16:14:29.202]                       })
[16:14:29.202]                     }
[16:14:29.202]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:14:29.202]                     base::options(mc.cores = 1L)
[16:14:29.202]                   }
[16:14:29.202]                   options(future.plan = NULL)
[16:14:29.202]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:29.202]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:29.202]                 }
[16:14:29.202]                 ...future.workdir <- getwd()
[16:14:29.202]             }
[16:14:29.202]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:29.202]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:29.202]         }
[16:14:29.202]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:29.202]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:29.202]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:29.202]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:29.202]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:29.202]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:29.202]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:29.202]             base::names(...future.oldOptions))
[16:14:29.202]     }
[16:14:29.202]     if (FALSE) {
[16:14:29.202]     }
[16:14:29.202]     else {
[16:14:29.202]         if (TRUE) {
[16:14:29.202]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:29.202]                 open = "w")
[16:14:29.202]         }
[16:14:29.202]         else {
[16:14:29.202]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:29.202]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:29.202]         }
[16:14:29.202]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:29.202]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:29.202]             base::sink(type = "output", split = FALSE)
[16:14:29.202]             base::close(...future.stdout)
[16:14:29.202]         }, add = TRUE)
[16:14:29.202]     }
[16:14:29.202]     ...future.frame <- base::sys.nframe()
[16:14:29.202]     ...future.conditions <- base::list()
[16:14:29.202]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:29.202]     if (FALSE) {
[16:14:29.202]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:29.202]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:29.202]     }
[16:14:29.202]     ...future.result <- base::tryCatch({
[16:14:29.202]         base::withCallingHandlers({
[16:14:29.202]             ...future.value <- base::withVisible(base::local({
[16:14:29.202]                 withCallingHandlers({
[16:14:29.202]                   print(42)
[16:14:29.202]                 }, immediateCondition = function(cond) {
[16:14:29.202]                   save_rds <- function (object, pathname, ...) 
[16:14:29.202]                   {
[16:14:29.202]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:14:29.202]                     if (file_test("-f", pathname_tmp)) {
[16:14:29.202]                       fi_tmp <- file.info(pathname_tmp)
[16:14:29.202]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:14:29.202]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:14:29.202]                         fi_tmp[["mtime"]])
[16:14:29.202]                     }
[16:14:29.202]                     tryCatch({
[16:14:29.202]                       saveRDS(object, file = pathname_tmp, ...)
[16:14:29.202]                     }, error = function(ex) {
[16:14:29.202]                       msg <- conditionMessage(ex)
[16:14:29.202]                       fi_tmp <- file.info(pathname_tmp)
[16:14:29.202]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:14:29.202]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:14:29.202]                         fi_tmp[["mtime"]], msg)
[16:14:29.202]                       ex$message <- msg
[16:14:29.202]                       stop(ex)
[16:14:29.202]                     })
[16:14:29.202]                     stopifnot(file_test("-f", pathname_tmp))
[16:14:29.202]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:14:29.202]                     if (!res || file_test("-f", pathname_tmp)) {
[16:14:29.202]                       fi_tmp <- file.info(pathname_tmp)
[16:14:29.202]                       fi <- file.info(pathname)
[16:14:29.202]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:14:29.202]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:14:29.202]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:14:29.202]                         fi[["size"]], fi[["mtime"]])
[16:14:29.202]                       stop(msg)
[16:14:29.202]                     }
[16:14:29.202]                     invisible(pathname)
[16:14:29.202]                   }
[16:14:29.202]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:14:29.202]                     rootPath = tempdir()) 
[16:14:29.202]                   {
[16:14:29.202]                     obj <- list(time = Sys.time(), condition = cond)
[16:14:29.202]                     file <- tempfile(pattern = class(cond)[1], 
[16:14:29.202]                       tmpdir = path, fileext = ".rds")
[16:14:29.202]                     save_rds(obj, file)
[16:14:29.202]                   }
[16:14:29.202]                   saveImmediateCondition(cond, path = "/tmp/RtmpEpin5U/.future/immediateConditions")
[16:14:29.202]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.202]                   {
[16:14:29.202]                     inherits <- base::inherits
[16:14:29.202]                     invokeRestart <- base::invokeRestart
[16:14:29.202]                     is.null <- base::is.null
[16:14:29.202]                     muffled <- FALSE
[16:14:29.202]                     if (inherits(cond, "message")) {
[16:14:29.202]                       muffled <- grepl(pattern, "muffleMessage")
[16:14:29.202]                       if (muffled) 
[16:14:29.202]                         invokeRestart("muffleMessage")
[16:14:29.202]                     }
[16:14:29.202]                     else if (inherits(cond, "warning")) {
[16:14:29.202]                       muffled <- grepl(pattern, "muffleWarning")
[16:14:29.202]                       if (muffled) 
[16:14:29.202]                         invokeRestart("muffleWarning")
[16:14:29.202]                     }
[16:14:29.202]                     else if (inherits(cond, "condition")) {
[16:14:29.202]                       if (!is.null(pattern)) {
[16:14:29.202]                         computeRestarts <- base::computeRestarts
[16:14:29.202]                         grepl <- base::grepl
[16:14:29.202]                         restarts <- computeRestarts(cond)
[16:14:29.202]                         for (restart in restarts) {
[16:14:29.202]                           name <- restart$name
[16:14:29.202]                           if (is.null(name)) 
[16:14:29.202]                             next
[16:14:29.202]                           if (!grepl(pattern, name)) 
[16:14:29.202]                             next
[16:14:29.202]                           invokeRestart(restart)
[16:14:29.202]                           muffled <- TRUE
[16:14:29.202]                           break
[16:14:29.202]                         }
[16:14:29.202]                       }
[16:14:29.202]                     }
[16:14:29.202]                     invisible(muffled)
[16:14:29.202]                   }
[16:14:29.202]                   muffleCondition(cond)
[16:14:29.202]                 })
[16:14:29.202]             }))
[16:14:29.202]             future::FutureResult(value = ...future.value$value, 
[16:14:29.202]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:29.202]                   ...future.rng), globalenv = if (FALSE) 
[16:14:29.202]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:29.202]                     ...future.globalenv.names))
[16:14:29.202]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:29.202]         }, condition = base::local({
[16:14:29.202]             c <- base::c
[16:14:29.202]             inherits <- base::inherits
[16:14:29.202]             invokeRestart <- base::invokeRestart
[16:14:29.202]             length <- base::length
[16:14:29.202]             list <- base::list
[16:14:29.202]             seq.int <- base::seq.int
[16:14:29.202]             signalCondition <- base::signalCondition
[16:14:29.202]             sys.calls <- base::sys.calls
[16:14:29.202]             `[[` <- base::`[[`
[16:14:29.202]             `+` <- base::`+`
[16:14:29.202]             `<<-` <- base::`<<-`
[16:14:29.202]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:29.202]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:29.202]                   3L)]
[16:14:29.202]             }
[16:14:29.202]             function(cond) {
[16:14:29.202]                 is_error <- inherits(cond, "error")
[16:14:29.202]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:29.202]                   NULL)
[16:14:29.202]                 if (is_error) {
[16:14:29.202]                   sessionInformation <- function() {
[16:14:29.202]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:29.202]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:29.202]                       search = base::search(), system = base::Sys.info())
[16:14:29.202]                   }
[16:14:29.202]                   ...future.conditions[[length(...future.conditions) + 
[16:14:29.202]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:29.202]                     cond$call), session = sessionInformation(), 
[16:14:29.202]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:29.202]                   signalCondition(cond)
[16:14:29.202]                 }
[16:14:29.202]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:29.202]                 "immediateCondition"))) {
[16:14:29.202]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:29.202]                   ...future.conditions[[length(...future.conditions) + 
[16:14:29.202]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:29.202]                   if (TRUE && !signal) {
[16:14:29.202]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.202]                     {
[16:14:29.202]                       inherits <- base::inherits
[16:14:29.202]                       invokeRestart <- base::invokeRestart
[16:14:29.202]                       is.null <- base::is.null
[16:14:29.202]                       muffled <- FALSE
[16:14:29.202]                       if (inherits(cond, "message")) {
[16:14:29.202]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:29.202]                         if (muffled) 
[16:14:29.202]                           invokeRestart("muffleMessage")
[16:14:29.202]                       }
[16:14:29.202]                       else if (inherits(cond, "warning")) {
[16:14:29.202]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:29.202]                         if (muffled) 
[16:14:29.202]                           invokeRestart("muffleWarning")
[16:14:29.202]                       }
[16:14:29.202]                       else if (inherits(cond, "condition")) {
[16:14:29.202]                         if (!is.null(pattern)) {
[16:14:29.202]                           computeRestarts <- base::computeRestarts
[16:14:29.202]                           grepl <- base::grepl
[16:14:29.202]                           restarts <- computeRestarts(cond)
[16:14:29.202]                           for (restart in restarts) {
[16:14:29.202]                             name <- restart$name
[16:14:29.202]                             if (is.null(name)) 
[16:14:29.202]                               next
[16:14:29.202]                             if (!grepl(pattern, name)) 
[16:14:29.202]                               next
[16:14:29.202]                             invokeRestart(restart)
[16:14:29.202]                             muffled <- TRUE
[16:14:29.202]                             break
[16:14:29.202]                           }
[16:14:29.202]                         }
[16:14:29.202]                       }
[16:14:29.202]                       invisible(muffled)
[16:14:29.202]                     }
[16:14:29.202]                     muffleCondition(cond, pattern = "^muffle")
[16:14:29.202]                   }
[16:14:29.202]                 }
[16:14:29.202]                 else {
[16:14:29.202]                   if (TRUE) {
[16:14:29.202]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.202]                     {
[16:14:29.202]                       inherits <- base::inherits
[16:14:29.202]                       invokeRestart <- base::invokeRestart
[16:14:29.202]                       is.null <- base::is.null
[16:14:29.202]                       muffled <- FALSE
[16:14:29.202]                       if (inherits(cond, "message")) {
[16:14:29.202]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:29.202]                         if (muffled) 
[16:14:29.202]                           invokeRestart("muffleMessage")
[16:14:29.202]                       }
[16:14:29.202]                       else if (inherits(cond, "warning")) {
[16:14:29.202]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:29.202]                         if (muffled) 
[16:14:29.202]                           invokeRestart("muffleWarning")
[16:14:29.202]                       }
[16:14:29.202]                       else if (inherits(cond, "condition")) {
[16:14:29.202]                         if (!is.null(pattern)) {
[16:14:29.202]                           computeRestarts <- base::computeRestarts
[16:14:29.202]                           grepl <- base::grepl
[16:14:29.202]                           restarts <- computeRestarts(cond)
[16:14:29.202]                           for (restart in restarts) {
[16:14:29.202]                             name <- restart$name
[16:14:29.202]                             if (is.null(name)) 
[16:14:29.202]                               next
[16:14:29.202]                             if (!grepl(pattern, name)) 
[16:14:29.202]                               next
[16:14:29.202]                             invokeRestart(restart)
[16:14:29.202]                             muffled <- TRUE
[16:14:29.202]                             break
[16:14:29.202]                           }
[16:14:29.202]                         }
[16:14:29.202]                       }
[16:14:29.202]                       invisible(muffled)
[16:14:29.202]                     }
[16:14:29.202]                     muffleCondition(cond, pattern = "^muffle")
[16:14:29.202]                   }
[16:14:29.202]                 }
[16:14:29.202]             }
[16:14:29.202]         }))
[16:14:29.202]     }, error = function(ex) {
[16:14:29.202]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:29.202]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:29.202]                 ...future.rng), started = ...future.startTime, 
[16:14:29.202]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:29.202]             version = "1.8"), class = "FutureResult")
[16:14:29.202]     }, finally = {
[16:14:29.202]         if (!identical(...future.workdir, getwd())) 
[16:14:29.202]             setwd(...future.workdir)
[16:14:29.202]         {
[16:14:29.202]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:29.202]                 ...future.oldOptions$nwarnings <- NULL
[16:14:29.202]             }
[16:14:29.202]             base::options(...future.oldOptions)
[16:14:29.202]             if (.Platform$OS.type == "windows") {
[16:14:29.202]                 old_names <- names(...future.oldEnvVars)
[16:14:29.202]                 envs <- base::Sys.getenv()
[16:14:29.202]                 names <- names(envs)
[16:14:29.202]                 common <- intersect(names, old_names)
[16:14:29.202]                 added <- setdiff(names, old_names)
[16:14:29.202]                 removed <- setdiff(old_names, names)
[16:14:29.202]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:29.202]                   envs[common]]
[16:14:29.202]                 NAMES <- toupper(changed)
[16:14:29.202]                 args <- list()
[16:14:29.202]                 for (kk in seq_along(NAMES)) {
[16:14:29.202]                   name <- changed[[kk]]
[16:14:29.202]                   NAME <- NAMES[[kk]]
[16:14:29.202]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.202]                     next
[16:14:29.202]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:29.202]                 }
[16:14:29.202]                 NAMES <- toupper(added)
[16:14:29.202]                 for (kk in seq_along(NAMES)) {
[16:14:29.202]                   name <- added[[kk]]
[16:14:29.202]                   NAME <- NAMES[[kk]]
[16:14:29.202]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.202]                     next
[16:14:29.202]                   args[[name]] <- ""
[16:14:29.202]                 }
[16:14:29.202]                 NAMES <- toupper(removed)
[16:14:29.202]                 for (kk in seq_along(NAMES)) {
[16:14:29.202]                   name <- removed[[kk]]
[16:14:29.202]                   NAME <- NAMES[[kk]]
[16:14:29.202]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.202]                     next
[16:14:29.202]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:29.202]                 }
[16:14:29.202]                 if (length(args) > 0) 
[16:14:29.202]                   base::do.call(base::Sys.setenv, args = args)
[16:14:29.202]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:29.202]             }
[16:14:29.202]             else {
[16:14:29.202]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:29.202]             }
[16:14:29.202]             {
[16:14:29.202]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:29.202]                   0L) {
[16:14:29.202]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:29.202]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:29.202]                   base::options(opts)
[16:14:29.202]                 }
[16:14:29.202]                 {
[16:14:29.202]                   {
[16:14:29.202]                     base::options(mc.cores = ...future.mc.cores.old)
[16:14:29.202]                     NULL
[16:14:29.202]                   }
[16:14:29.202]                   options(future.plan = NULL)
[16:14:29.202]                   if (is.na(NA_character_)) 
[16:14:29.202]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:29.202]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:29.202]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:14:29.202]                     envir = parent.frame()) 
[16:14:29.202]                   {
[16:14:29.202]                     default_workers <- missing(workers)
[16:14:29.202]                     if (is.function(workers)) 
[16:14:29.202]                       workers <- workers()
[16:14:29.202]                     workers <- structure(as.integer(workers), 
[16:14:29.202]                       class = class(workers))
[16:14:29.202]                     stop_if_not(is.finite(workers), workers >= 
[16:14:29.202]                       1L)
[16:14:29.202]                     if ((workers == 1L && !inherits(workers, 
[16:14:29.202]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:14:29.202]                       if (default_workers) 
[16:14:29.202]                         supportsMulticore(warn = TRUE)
[16:14:29.202]                       return(sequential(..., envir = envir))
[16:14:29.202]                     }
[16:14:29.202]                     oopts <- options(mc.cores = workers)
[16:14:29.202]                     on.exit(options(oopts))
[16:14:29.202]                     future <- MulticoreFuture(..., workers = workers, 
[16:14:29.202]                       envir = envir)
[16:14:29.202]                     if (!future$lazy) 
[16:14:29.202]                       future <- run(future)
[16:14:29.202]                     invisible(future)
[16:14:29.202]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:29.202]                 }
[16:14:29.202]             }
[16:14:29.202]         }
[16:14:29.202]     })
[16:14:29.202]     if (TRUE) {
[16:14:29.202]         base::sink(type = "output", split = FALSE)
[16:14:29.202]         if (TRUE) {
[16:14:29.202]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:29.202]         }
[16:14:29.202]         else {
[16:14:29.202]             ...future.result["stdout"] <- base::list(NULL)
[16:14:29.202]         }
[16:14:29.202]         base::close(...future.stdout)
[16:14:29.202]         ...future.stdout <- NULL
[16:14:29.202]     }
[16:14:29.202]     ...future.result$conditions <- ...future.conditions
[16:14:29.202]     ...future.result$finished <- base::Sys.time()
[16:14:29.202]     ...future.result
[16:14:29.202] }
[16:14:29.204] requestCore(): workers = 2
[16:14:29.206] MulticoreFuture started
[16:14:29.206] - Launch lazy future ... done
[16:14:29.206] run() for ‘MulticoreFuture’ ... done
[16:14:29.207] plan(): Setting new future strategy stack:
[16:14:29.207] List of future strategies:
[16:14:29.207] 1. sequential:
[16:14:29.207]    - args: function (..., envir = parent.frame())
[16:14:29.207]    - tweaked: FALSE
[16:14:29.207]    - call: NULL
[16:14:29.208] plan(): nbrOfWorkers() = 1
[16:14:29.210] plan(): Setting new future strategy stack:
[16:14:29.210] List of future strategies:
[16:14:29.210] 1. multicore:
[16:14:29.210]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:14:29.210]    - tweaked: FALSE
[16:14:29.210]    - call: plan(strategy)
[16:14:29.215] plan(): nbrOfWorkers() = 2
[1] 42
- stdout = FALSE
[16:14:29.216] getGlobalsAndPackages() ...
[16:14:29.216] Searching for globals...
[16:14:29.220] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[16:14:29.221] Searching for globals ... DONE
[16:14:29.221] Resolving globals: FALSE
[16:14:29.221] 
[16:14:29.222] - packages: [1] ‘utils’
[16:14:29.222] getGlobalsAndPackages() ... DONE
[16:14:29.222] run() for ‘Future’ ...
[16:14:29.222] - state: ‘created’
[16:14:29.222] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:14:29.226] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:14:29.226] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:14:29.227]   - Field: ‘label’
[16:14:29.227]   - Field: ‘local’
[16:14:29.227]   - Field: ‘owner’
[16:14:29.227]   - Field: ‘envir’
[16:14:29.227]   - Field: ‘workers’
[16:14:29.227]   - Field: ‘packages’
[16:14:29.227]   - Field: ‘gc’
[16:14:29.227]   - Field: ‘job’
[16:14:29.228]   - Field: ‘conditions’
[16:14:29.228]   - Field: ‘expr’
[16:14:29.228]   - Field: ‘uuid’
[16:14:29.228]   - Field: ‘seed’
[16:14:29.228]   - Field: ‘version’
[16:14:29.228]   - Field: ‘result’
[16:14:29.228]   - Field: ‘asynchronous’
[16:14:29.228]   - Field: ‘calls’
[16:14:29.228]   - Field: ‘globals’
[16:14:29.229]   - Field: ‘stdout’
[16:14:29.229]   - Field: ‘earlySignal’
[16:14:29.229]   - Field: ‘lazy’
[16:14:29.229]   - Field: ‘state’
[16:14:29.229] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:14:29.229] - Launch lazy future ...
[16:14:29.229] Packages needed by the future expression (n = 1): ‘utils’
[16:14:29.230] Packages needed by future strategies (n = 0): <none>
[16:14:29.230] {
[16:14:29.230]     {
[16:14:29.230]         {
[16:14:29.230]             ...future.startTime <- base::Sys.time()
[16:14:29.230]             {
[16:14:29.230]                 {
[16:14:29.230]                   {
[16:14:29.230]                     {
[16:14:29.230]                       {
[16:14:29.230]                         base::local({
[16:14:29.230]                           has_future <- base::requireNamespace("future", 
[16:14:29.230]                             quietly = TRUE)
[16:14:29.230]                           if (has_future) {
[16:14:29.230]                             ns <- base::getNamespace("future")
[16:14:29.230]                             version <- ns[[".package"]][["version"]]
[16:14:29.230]                             if (is.null(version)) 
[16:14:29.230]                               version <- utils::packageVersion("future")
[16:14:29.230]                           }
[16:14:29.230]                           else {
[16:14:29.230]                             version <- NULL
[16:14:29.230]                           }
[16:14:29.230]                           if (!has_future || version < "1.8.0") {
[16:14:29.230]                             info <- base::c(r_version = base::gsub("R version ", 
[16:14:29.230]                               "", base::R.version$version.string), 
[16:14:29.230]                               platform = base::sprintf("%s (%s-bit)", 
[16:14:29.230]                                 base::R.version$platform, 8 * 
[16:14:29.230]                                   base::.Machine$sizeof.pointer), 
[16:14:29.230]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:29.230]                                 "release", "version")], collapse = " "), 
[16:14:29.230]                               hostname = base::Sys.info()[["nodename"]])
[16:14:29.230]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:14:29.230]                               info)
[16:14:29.230]                             info <- base::paste(info, collapse = "; ")
[16:14:29.230]                             if (!has_future) {
[16:14:29.230]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:29.230]                                 info)
[16:14:29.230]                             }
[16:14:29.230]                             else {
[16:14:29.230]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:29.230]                                 info, version)
[16:14:29.230]                             }
[16:14:29.230]                             base::stop(msg)
[16:14:29.230]                           }
[16:14:29.230]                         })
[16:14:29.230]                       }
[16:14:29.230]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:14:29.230]                       base::options(mc.cores = 1L)
[16:14:29.230]                     }
[16:14:29.230]                     base::local({
[16:14:29.230]                       for (pkg in "utils") {
[16:14:29.230]                         base::loadNamespace(pkg)
[16:14:29.230]                         base::library(pkg, character.only = TRUE)
[16:14:29.230]                       }
[16:14:29.230]                     })
[16:14:29.230]                   }
[16:14:29.230]                   options(future.plan = NULL)
[16:14:29.230]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:29.230]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:29.230]                 }
[16:14:29.230]                 ...future.workdir <- getwd()
[16:14:29.230]             }
[16:14:29.230]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:29.230]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:29.230]         }
[16:14:29.230]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:29.230]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:29.230]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:29.230]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:29.230]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:29.230]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:29.230]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:29.230]             base::names(...future.oldOptions))
[16:14:29.230]     }
[16:14:29.230]     if (FALSE) {
[16:14:29.230]     }
[16:14:29.230]     else {
[16:14:29.230]         if (FALSE) {
[16:14:29.230]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:29.230]                 open = "w")
[16:14:29.230]         }
[16:14:29.230]         else {
[16:14:29.230]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:29.230]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:29.230]         }
[16:14:29.230]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:29.230]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:29.230]             base::sink(type = "output", split = FALSE)
[16:14:29.230]             base::close(...future.stdout)
[16:14:29.230]         }, add = TRUE)
[16:14:29.230]     }
[16:14:29.230]     ...future.frame <- base::sys.nframe()
[16:14:29.230]     ...future.conditions <- base::list()
[16:14:29.230]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:29.230]     if (FALSE) {
[16:14:29.230]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:29.230]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:29.230]     }
[16:14:29.230]     ...future.result <- base::tryCatch({
[16:14:29.230]         base::withCallingHandlers({
[16:14:29.230]             ...future.value <- base::withVisible(base::local({
[16:14:29.230]                 withCallingHandlers({
[16:14:29.230]                   {
[16:14:29.230]                     print(1:50)
[16:14:29.230]                     str(1:50)
[16:14:29.230]                     cat(letters, sep = "-")
[16:14:29.230]                     cat(1:6, collapse = "\n")
[16:14:29.230]                     write.table(datasets::iris[1:10, ], sep = "\t")
[16:14:29.230]                     42L
[16:14:29.230]                   }
[16:14:29.230]                 }, immediateCondition = function(cond) {
[16:14:29.230]                   save_rds <- function (object, pathname, ...) 
[16:14:29.230]                   {
[16:14:29.230]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:14:29.230]                     if (file_test("-f", pathname_tmp)) {
[16:14:29.230]                       fi_tmp <- file.info(pathname_tmp)
[16:14:29.230]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:14:29.230]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:14:29.230]                         fi_tmp[["mtime"]])
[16:14:29.230]                     }
[16:14:29.230]                     tryCatch({
[16:14:29.230]                       saveRDS(object, file = pathname_tmp, ...)
[16:14:29.230]                     }, error = function(ex) {
[16:14:29.230]                       msg <- conditionMessage(ex)
[16:14:29.230]                       fi_tmp <- file.info(pathname_tmp)
[16:14:29.230]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:14:29.230]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:14:29.230]                         fi_tmp[["mtime"]], msg)
[16:14:29.230]                       ex$message <- msg
[16:14:29.230]                       stop(ex)
[16:14:29.230]                     })
[16:14:29.230]                     stopifnot(file_test("-f", pathname_tmp))
[16:14:29.230]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:14:29.230]                     if (!res || file_test("-f", pathname_tmp)) {
[16:14:29.230]                       fi_tmp <- file.info(pathname_tmp)
[16:14:29.230]                       fi <- file.info(pathname)
[16:14:29.230]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:14:29.230]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:14:29.230]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:14:29.230]                         fi[["size"]], fi[["mtime"]])
[16:14:29.230]                       stop(msg)
[16:14:29.230]                     }
[16:14:29.230]                     invisible(pathname)
[16:14:29.230]                   }
[16:14:29.230]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:14:29.230]                     rootPath = tempdir()) 
[16:14:29.230]                   {
[16:14:29.230]                     obj <- list(time = Sys.time(), condition = cond)
[16:14:29.230]                     file <- tempfile(pattern = class(cond)[1], 
[16:14:29.230]                       tmpdir = path, fileext = ".rds")
[16:14:29.230]                     save_rds(obj, file)
[16:14:29.230]                   }
[16:14:29.230]                   saveImmediateCondition(cond, path = "/tmp/RtmpEpin5U/.future/immediateConditions")
[16:14:29.230]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.230]                   {
[16:14:29.230]                     inherits <- base::inherits
[16:14:29.230]                     invokeRestart <- base::invokeRestart
[16:14:29.230]                     is.null <- base::is.null
[16:14:29.230]                     muffled <- FALSE
[16:14:29.230]                     if (inherits(cond, "message")) {
[16:14:29.230]                       muffled <- grepl(pattern, "muffleMessage")
[16:14:29.230]                       if (muffled) 
[16:14:29.230]                         invokeRestart("muffleMessage")
[16:14:29.230]                     }
[16:14:29.230]                     else if (inherits(cond, "warning")) {
[16:14:29.230]                       muffled <- grepl(pattern, "muffleWarning")
[16:14:29.230]                       if (muffled) 
[16:14:29.230]                         invokeRestart("muffleWarning")
[16:14:29.230]                     }
[16:14:29.230]                     else if (inherits(cond, "condition")) {
[16:14:29.230]                       if (!is.null(pattern)) {
[16:14:29.230]                         computeRestarts <- base::computeRestarts
[16:14:29.230]                         grepl <- base::grepl
[16:14:29.230]                         restarts <- computeRestarts(cond)
[16:14:29.230]                         for (restart in restarts) {
[16:14:29.230]                           name <- restart$name
[16:14:29.230]                           if (is.null(name)) 
[16:14:29.230]                             next
[16:14:29.230]                           if (!grepl(pattern, name)) 
[16:14:29.230]                             next
[16:14:29.230]                           invokeRestart(restart)
[16:14:29.230]                           muffled <- TRUE
[16:14:29.230]                           break
[16:14:29.230]                         }
[16:14:29.230]                       }
[16:14:29.230]                     }
[16:14:29.230]                     invisible(muffled)
[16:14:29.230]                   }
[16:14:29.230]                   muffleCondition(cond)
[16:14:29.230]                 })
[16:14:29.230]             }))
[16:14:29.230]             future::FutureResult(value = ...future.value$value, 
[16:14:29.230]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:29.230]                   ...future.rng), globalenv = if (FALSE) 
[16:14:29.230]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:29.230]                     ...future.globalenv.names))
[16:14:29.230]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:29.230]         }, condition = base::local({
[16:14:29.230]             c <- base::c
[16:14:29.230]             inherits <- base::inherits
[16:14:29.230]             invokeRestart <- base::invokeRestart
[16:14:29.230]             length <- base::length
[16:14:29.230]             list <- base::list
[16:14:29.230]             seq.int <- base::seq.int
[16:14:29.230]             signalCondition <- base::signalCondition
[16:14:29.230]             sys.calls <- base::sys.calls
[16:14:29.230]             `[[` <- base::`[[`
[16:14:29.230]             `+` <- base::`+`
[16:14:29.230]             `<<-` <- base::`<<-`
[16:14:29.230]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:29.230]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:29.230]                   3L)]
[16:14:29.230]             }
[16:14:29.230]             function(cond) {
[16:14:29.230]                 is_error <- inherits(cond, "error")
[16:14:29.230]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:29.230]                   NULL)
[16:14:29.230]                 if (is_error) {
[16:14:29.230]                   sessionInformation <- function() {
[16:14:29.230]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:29.230]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:29.230]                       search = base::search(), system = base::Sys.info())
[16:14:29.230]                   }
[16:14:29.230]                   ...future.conditions[[length(...future.conditions) + 
[16:14:29.230]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:29.230]                     cond$call), session = sessionInformation(), 
[16:14:29.230]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:29.230]                   signalCondition(cond)
[16:14:29.230]                 }
[16:14:29.230]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:29.230]                 "immediateCondition"))) {
[16:14:29.230]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:29.230]                   ...future.conditions[[length(...future.conditions) + 
[16:14:29.230]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:29.230]                   if (TRUE && !signal) {
[16:14:29.230]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.230]                     {
[16:14:29.230]                       inherits <- base::inherits
[16:14:29.230]                       invokeRestart <- base::invokeRestart
[16:14:29.230]                       is.null <- base::is.null
[16:14:29.230]                       muffled <- FALSE
[16:14:29.230]                       if (inherits(cond, "message")) {
[16:14:29.230]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:29.230]                         if (muffled) 
[16:14:29.230]                           invokeRestart("muffleMessage")
[16:14:29.230]                       }
[16:14:29.230]                       else if (inherits(cond, "warning")) {
[16:14:29.230]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:29.230]                         if (muffled) 
[16:14:29.230]                           invokeRestart("muffleWarning")
[16:14:29.230]                       }
[16:14:29.230]                       else if (inherits(cond, "condition")) {
[16:14:29.230]                         if (!is.null(pattern)) {
[16:14:29.230]                           computeRestarts <- base::computeRestarts
[16:14:29.230]                           grepl <- base::grepl
[16:14:29.230]                           restarts <- computeRestarts(cond)
[16:14:29.230]                           for (restart in restarts) {
[16:14:29.230]                             name <- restart$name
[16:14:29.230]                             if (is.null(name)) 
[16:14:29.230]                               next
[16:14:29.230]                             if (!grepl(pattern, name)) 
[16:14:29.230]                               next
[16:14:29.230]                             invokeRestart(restart)
[16:14:29.230]                             muffled <- TRUE
[16:14:29.230]                             break
[16:14:29.230]                           }
[16:14:29.230]                         }
[16:14:29.230]                       }
[16:14:29.230]                       invisible(muffled)
[16:14:29.230]                     }
[16:14:29.230]                     muffleCondition(cond, pattern = "^muffle")
[16:14:29.230]                   }
[16:14:29.230]                 }
[16:14:29.230]                 else {
[16:14:29.230]                   if (TRUE) {
[16:14:29.230]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.230]                     {
[16:14:29.230]                       inherits <- base::inherits
[16:14:29.230]                       invokeRestart <- base::invokeRestart
[16:14:29.230]                       is.null <- base::is.null
[16:14:29.230]                       muffled <- FALSE
[16:14:29.230]                       if (inherits(cond, "message")) {
[16:14:29.230]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:29.230]                         if (muffled) 
[16:14:29.230]                           invokeRestart("muffleMessage")
[16:14:29.230]                       }
[16:14:29.230]                       else if (inherits(cond, "warning")) {
[16:14:29.230]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:29.230]                         if (muffled) 
[16:14:29.230]                           invokeRestart("muffleWarning")
[16:14:29.230]                       }
[16:14:29.230]                       else if (inherits(cond, "condition")) {
[16:14:29.230]                         if (!is.null(pattern)) {
[16:14:29.230]                           computeRestarts <- base::computeRestarts
[16:14:29.230]                           grepl <- base::grepl
[16:14:29.230]                           restarts <- computeRestarts(cond)
[16:14:29.230]                           for (restart in restarts) {
[16:14:29.230]                             name <- restart$name
[16:14:29.230]                             if (is.null(name)) 
[16:14:29.230]                               next
[16:14:29.230]                             if (!grepl(pattern, name)) 
[16:14:29.230]                               next
[16:14:29.230]                             invokeRestart(restart)
[16:14:29.230]                             muffled <- TRUE
[16:14:29.230]                             break
[16:14:29.230]                           }
[16:14:29.230]                         }
[16:14:29.230]                       }
[16:14:29.230]                       invisible(muffled)
[16:14:29.230]                     }
[16:14:29.230]                     muffleCondition(cond, pattern = "^muffle")
[16:14:29.230]                   }
[16:14:29.230]                 }
[16:14:29.230]             }
[16:14:29.230]         }))
[16:14:29.230]     }, error = function(ex) {
[16:14:29.230]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:29.230]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:29.230]                 ...future.rng), started = ...future.startTime, 
[16:14:29.230]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:29.230]             version = "1.8"), class = "FutureResult")
[16:14:29.230]     }, finally = {
[16:14:29.230]         if (!identical(...future.workdir, getwd())) 
[16:14:29.230]             setwd(...future.workdir)
[16:14:29.230]         {
[16:14:29.230]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:29.230]                 ...future.oldOptions$nwarnings <- NULL
[16:14:29.230]             }
[16:14:29.230]             base::options(...future.oldOptions)
[16:14:29.230]             if (.Platform$OS.type == "windows") {
[16:14:29.230]                 old_names <- names(...future.oldEnvVars)
[16:14:29.230]                 envs <- base::Sys.getenv()
[16:14:29.230]                 names <- names(envs)
[16:14:29.230]                 common <- intersect(names, old_names)
[16:14:29.230]                 added <- setdiff(names, old_names)
[16:14:29.230]                 removed <- setdiff(old_names, names)
[16:14:29.230]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:29.230]                   envs[common]]
[16:14:29.230]                 NAMES <- toupper(changed)
[16:14:29.230]                 args <- list()
[16:14:29.230]                 for (kk in seq_along(NAMES)) {
[16:14:29.230]                   name <- changed[[kk]]
[16:14:29.230]                   NAME <- NAMES[[kk]]
[16:14:29.230]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.230]                     next
[16:14:29.230]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:29.230]                 }
[16:14:29.230]                 NAMES <- toupper(added)
[16:14:29.230]                 for (kk in seq_along(NAMES)) {
[16:14:29.230]                   name <- added[[kk]]
[16:14:29.230]                   NAME <- NAMES[[kk]]
[16:14:29.230]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.230]                     next
[16:14:29.230]                   args[[name]] <- ""
[16:14:29.230]                 }
[16:14:29.230]                 NAMES <- toupper(removed)
[16:14:29.230]                 for (kk in seq_along(NAMES)) {
[16:14:29.230]                   name <- removed[[kk]]
[16:14:29.230]                   NAME <- NAMES[[kk]]
[16:14:29.230]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.230]                     next
[16:14:29.230]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:29.230]                 }
[16:14:29.230]                 if (length(args) > 0) 
[16:14:29.230]                   base::do.call(base::Sys.setenv, args = args)
[16:14:29.230]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:29.230]             }
[16:14:29.230]             else {
[16:14:29.230]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:29.230]             }
[16:14:29.230]             {
[16:14:29.230]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:29.230]                   0L) {
[16:14:29.230]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:29.230]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:29.230]                   base::options(opts)
[16:14:29.230]                 }
[16:14:29.230]                 {
[16:14:29.230]                   {
[16:14:29.230]                     base::options(mc.cores = ...future.mc.cores.old)
[16:14:29.230]                     NULL
[16:14:29.230]                   }
[16:14:29.230]                   options(future.plan = NULL)
[16:14:29.230]                   if (is.na(NA_character_)) 
[16:14:29.230]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:29.230]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:29.230]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:14:29.230]                     envir = parent.frame()) 
[16:14:29.230]                   {
[16:14:29.230]                     default_workers <- missing(workers)
[16:14:29.230]                     if (is.function(workers)) 
[16:14:29.230]                       workers <- workers()
[16:14:29.230]                     workers <- structure(as.integer(workers), 
[16:14:29.230]                       class = class(workers))
[16:14:29.230]                     stop_if_not(is.finite(workers), workers >= 
[16:14:29.230]                       1L)
[16:14:29.230]                     if ((workers == 1L && !inherits(workers, 
[16:14:29.230]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:14:29.230]                       if (default_workers) 
[16:14:29.230]                         supportsMulticore(warn = TRUE)
[16:14:29.230]                       return(sequential(..., envir = envir))
[16:14:29.230]                     }
[16:14:29.230]                     oopts <- options(mc.cores = workers)
[16:14:29.230]                     on.exit(options(oopts))
[16:14:29.230]                     future <- MulticoreFuture(..., workers = workers, 
[16:14:29.230]                       envir = envir)
[16:14:29.230]                     if (!future$lazy) 
[16:14:29.230]                       future <- run(future)
[16:14:29.230]                     invisible(future)
[16:14:29.230]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:29.230]                 }
[16:14:29.230]             }
[16:14:29.230]         }
[16:14:29.230]     })
[16:14:29.230]     if (TRUE) {
[16:14:29.230]         base::sink(type = "output", split = FALSE)
[16:14:29.230]         if (FALSE) {
[16:14:29.230]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:29.230]         }
[16:14:29.230]         else {
[16:14:29.230]             ...future.result["stdout"] <- base::list(NULL)
[16:14:29.230]         }
[16:14:29.230]         base::close(...future.stdout)
[16:14:29.230]         ...future.stdout <- NULL
[16:14:29.230]     }
[16:14:29.230]     ...future.result$conditions <- ...future.conditions
[16:14:29.230]     ...future.result$finished <- base::Sys.time()
[16:14:29.230]     ...future.result
[16:14:29.230] }
[16:14:29.233] requestCore(): workers = 2
[16:14:29.235] MulticoreFuture started
[16:14:29.235] - Launch lazy future ... done
[16:14:29.235] run() for ‘MulticoreFuture’ ... done
[16:14:29.236] plan(): Setting new future strategy stack:
[16:14:29.236] List of future strategies:
[16:14:29.236] 1. sequential:
[16:14:29.236]    - args: function (..., envir = parent.frame())
[16:14:29.236]    - tweaked: FALSE
[16:14:29.236]    - call: NULL
[16:14:29.237] plan(): nbrOfWorkers() = 1
[16:14:29.241] plan(): Setting new future strategy stack:
[16:14:29.241] List of future strategies:
[16:14:29.241] 1. multicore:
[16:14:29.241]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:14:29.241]    - tweaked: FALSE
[16:14:29.241]    - call: plan(strategy)
[16:14:29.245] plan(): nbrOfWorkers() = 2
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-01-06 16:14:29"
 $ finished    : POSIXct[1:1], format: "2025-01-06 16:14:29"
 $ session_uuid: chr "5b5bb76b-0565-71f7-f3a0-042c81d9cbfb"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "2729ef2608da"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "2729ef2608da" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 92347
  .. ..$ time  : POSIXct[1:1], format: "2025-01-06 16:14:29"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 3 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[16:14:29.259] getGlobalsAndPackages() ...
[16:14:29.259] Searching for globals...
[16:14:29.263] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[16:14:29.263] Searching for globals ... DONE
[16:14:29.264] Resolving globals: FALSE
[16:14:29.264] 
[16:14:29.264] - packages: [1] ‘utils’
[16:14:29.264] getGlobalsAndPackages() ... DONE
[16:14:29.265] run() for ‘Future’ ...
[16:14:29.265] - state: ‘created’
[16:14:29.265] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:14:29.269] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:14:29.269] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:14:29.269]   - Field: ‘label’
[16:14:29.270]   - Field: ‘local’
[16:14:29.270]   - Field: ‘owner’
[16:14:29.270]   - Field: ‘envir’
[16:14:29.270]   - Field: ‘workers’
[16:14:29.270]   - Field: ‘packages’
[16:14:29.270]   - Field: ‘gc’
[16:14:29.270]   - Field: ‘job’
[16:14:29.270]   - Field: ‘conditions’
[16:14:29.271]   - Field: ‘expr’
[16:14:29.271]   - Field: ‘uuid’
[16:14:29.271]   - Field: ‘seed’
[16:14:29.271]   - Field: ‘version’
[16:14:29.271]   - Field: ‘result’
[16:14:29.271]   - Field: ‘asynchronous’
[16:14:29.271]   - Field: ‘calls’
[16:14:29.271]   - Field: ‘globals’
[16:14:29.271]   - Field: ‘stdout’
[16:14:29.272]   - Field: ‘earlySignal’
[16:14:29.272]   - Field: ‘lazy’
[16:14:29.272]   - Field: ‘state’
[16:14:29.272] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:14:29.272] - Launch lazy future ...
[16:14:29.272] Packages needed by the future expression (n = 1): ‘utils’
[16:14:29.272] Packages needed by future strategies (n = 0): <none>
[16:14:29.273] {
[16:14:29.273]     {
[16:14:29.273]         {
[16:14:29.273]             ...future.startTime <- base::Sys.time()
[16:14:29.273]             {
[16:14:29.273]                 {
[16:14:29.273]                   {
[16:14:29.273]                     {
[16:14:29.273]                       {
[16:14:29.273]                         base::local({
[16:14:29.273]                           has_future <- base::requireNamespace("future", 
[16:14:29.273]                             quietly = TRUE)
[16:14:29.273]                           if (has_future) {
[16:14:29.273]                             ns <- base::getNamespace("future")
[16:14:29.273]                             version <- ns[[".package"]][["version"]]
[16:14:29.273]                             if (is.null(version)) 
[16:14:29.273]                               version <- utils::packageVersion("future")
[16:14:29.273]                           }
[16:14:29.273]                           else {
[16:14:29.273]                             version <- NULL
[16:14:29.273]                           }
[16:14:29.273]                           if (!has_future || version < "1.8.0") {
[16:14:29.273]                             info <- base::c(r_version = base::gsub("R version ", 
[16:14:29.273]                               "", base::R.version$version.string), 
[16:14:29.273]                               platform = base::sprintf("%s (%s-bit)", 
[16:14:29.273]                                 base::R.version$platform, 8 * 
[16:14:29.273]                                   base::.Machine$sizeof.pointer), 
[16:14:29.273]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:29.273]                                 "release", "version")], collapse = " "), 
[16:14:29.273]                               hostname = base::Sys.info()[["nodename"]])
[16:14:29.273]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:14:29.273]                               info)
[16:14:29.273]                             info <- base::paste(info, collapse = "; ")
[16:14:29.273]                             if (!has_future) {
[16:14:29.273]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:29.273]                                 info)
[16:14:29.273]                             }
[16:14:29.273]                             else {
[16:14:29.273]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:29.273]                                 info, version)
[16:14:29.273]                             }
[16:14:29.273]                             base::stop(msg)
[16:14:29.273]                           }
[16:14:29.273]                         })
[16:14:29.273]                       }
[16:14:29.273]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:14:29.273]                       base::options(mc.cores = 1L)
[16:14:29.273]                     }
[16:14:29.273]                     base::local({
[16:14:29.273]                       for (pkg in "utils") {
[16:14:29.273]                         base::loadNamespace(pkg)
[16:14:29.273]                         base::library(pkg, character.only = TRUE)
[16:14:29.273]                       }
[16:14:29.273]                     })
[16:14:29.273]                   }
[16:14:29.273]                   options(future.plan = NULL)
[16:14:29.273]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:29.273]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:29.273]                 }
[16:14:29.273]                 ...future.workdir <- getwd()
[16:14:29.273]             }
[16:14:29.273]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:29.273]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:29.273]         }
[16:14:29.273]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:29.273]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:29.273]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:29.273]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:29.273]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:29.273]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:29.273]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:29.273]             base::names(...future.oldOptions))
[16:14:29.273]     }
[16:14:29.273]     if (FALSE) {
[16:14:29.273]     }
[16:14:29.273]     else {
[16:14:29.273]         if (FALSE) {
[16:14:29.273]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:29.273]                 open = "w")
[16:14:29.273]         }
[16:14:29.273]         else {
[16:14:29.273]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:29.273]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:29.273]         }
[16:14:29.273]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:29.273]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:29.273]             base::sink(type = "output", split = FALSE)
[16:14:29.273]             base::close(...future.stdout)
[16:14:29.273]         }, add = TRUE)
[16:14:29.273]     }
[16:14:29.273]     ...future.frame <- base::sys.nframe()
[16:14:29.273]     ...future.conditions <- base::list()
[16:14:29.273]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:29.273]     if (FALSE) {
[16:14:29.273]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:29.273]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:29.273]     }
[16:14:29.273]     ...future.result <- base::tryCatch({
[16:14:29.273]         base::withCallingHandlers({
[16:14:29.273]             ...future.value <- base::withVisible(base::local({
[16:14:29.273]                 withCallingHandlers({
[16:14:29.273]                   {
[16:14:29.273]                     print(1:50)
[16:14:29.273]                     str(1:50)
[16:14:29.273]                     cat(letters, sep = "-")
[16:14:29.273]                     cat(1:6, collapse = "\n")
[16:14:29.273]                     write.table(datasets::iris[1:10, ], sep = "\t")
[16:14:29.273]                     42L
[16:14:29.273]                   }
[16:14:29.273]                 }, immediateCondition = function(cond) {
[16:14:29.273]                   save_rds <- function (object, pathname, ...) 
[16:14:29.273]                   {
[16:14:29.273]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:14:29.273]                     if (file_test("-f", pathname_tmp)) {
[16:14:29.273]                       fi_tmp <- file.info(pathname_tmp)
[16:14:29.273]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:14:29.273]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:14:29.273]                         fi_tmp[["mtime"]])
[16:14:29.273]                     }
[16:14:29.273]                     tryCatch({
[16:14:29.273]                       saveRDS(object, file = pathname_tmp, ...)
[16:14:29.273]                     }, error = function(ex) {
[16:14:29.273]                       msg <- conditionMessage(ex)
[16:14:29.273]                       fi_tmp <- file.info(pathname_tmp)
[16:14:29.273]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:14:29.273]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:14:29.273]                         fi_tmp[["mtime"]], msg)
[16:14:29.273]                       ex$message <- msg
[16:14:29.273]                       stop(ex)
[16:14:29.273]                     })
[16:14:29.273]                     stopifnot(file_test("-f", pathname_tmp))
[16:14:29.273]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:14:29.273]                     if (!res || file_test("-f", pathname_tmp)) {
[16:14:29.273]                       fi_tmp <- file.info(pathname_tmp)
[16:14:29.273]                       fi <- file.info(pathname)
[16:14:29.273]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:14:29.273]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:14:29.273]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:14:29.273]                         fi[["size"]], fi[["mtime"]])
[16:14:29.273]                       stop(msg)
[16:14:29.273]                     }
[16:14:29.273]                     invisible(pathname)
[16:14:29.273]                   }
[16:14:29.273]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:14:29.273]                     rootPath = tempdir()) 
[16:14:29.273]                   {
[16:14:29.273]                     obj <- list(time = Sys.time(), condition = cond)
[16:14:29.273]                     file <- tempfile(pattern = class(cond)[1], 
[16:14:29.273]                       tmpdir = path, fileext = ".rds")
[16:14:29.273]                     save_rds(obj, file)
[16:14:29.273]                   }
[16:14:29.273]                   saveImmediateCondition(cond, path = "/tmp/RtmpEpin5U/.future/immediateConditions")
[16:14:29.273]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.273]                   {
[16:14:29.273]                     inherits <- base::inherits
[16:14:29.273]                     invokeRestart <- base::invokeRestart
[16:14:29.273]                     is.null <- base::is.null
[16:14:29.273]                     muffled <- FALSE
[16:14:29.273]                     if (inherits(cond, "message")) {
[16:14:29.273]                       muffled <- grepl(pattern, "muffleMessage")
[16:14:29.273]                       if (muffled) 
[16:14:29.273]                         invokeRestart("muffleMessage")
[16:14:29.273]                     }
[16:14:29.273]                     else if (inherits(cond, "warning")) {
[16:14:29.273]                       muffled <- grepl(pattern, "muffleWarning")
[16:14:29.273]                       if (muffled) 
[16:14:29.273]                         invokeRestart("muffleWarning")
[16:14:29.273]                     }
[16:14:29.273]                     else if (inherits(cond, "condition")) {
[16:14:29.273]                       if (!is.null(pattern)) {
[16:14:29.273]                         computeRestarts <- base::computeRestarts
[16:14:29.273]                         grepl <- base::grepl
[16:14:29.273]                         restarts <- computeRestarts(cond)
[16:14:29.273]                         for (restart in restarts) {
[16:14:29.273]                           name <- restart$name
[16:14:29.273]                           if (is.null(name)) 
[16:14:29.273]                             next
[16:14:29.273]                           if (!grepl(pattern, name)) 
[16:14:29.273]                             next
[16:14:29.273]                           invokeRestart(restart)
[16:14:29.273]                           muffled <- TRUE
[16:14:29.273]                           break
[16:14:29.273]                         }
[16:14:29.273]                       }
[16:14:29.273]                     }
[16:14:29.273]                     invisible(muffled)
[16:14:29.273]                   }
[16:14:29.273]                   muffleCondition(cond)
[16:14:29.273]                 })
[16:14:29.273]             }))
[16:14:29.273]             future::FutureResult(value = ...future.value$value, 
[16:14:29.273]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:29.273]                   ...future.rng), globalenv = if (FALSE) 
[16:14:29.273]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:29.273]                     ...future.globalenv.names))
[16:14:29.273]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:29.273]         }, condition = base::local({
[16:14:29.273]             c <- base::c
[16:14:29.273]             inherits <- base::inherits
[16:14:29.273]             invokeRestart <- base::invokeRestart
[16:14:29.273]             length <- base::length
[16:14:29.273]             list <- base::list
[16:14:29.273]             seq.int <- base::seq.int
[16:14:29.273]             signalCondition <- base::signalCondition
[16:14:29.273]             sys.calls <- base::sys.calls
[16:14:29.273]             `[[` <- base::`[[`
[16:14:29.273]             `+` <- base::`+`
[16:14:29.273]             `<<-` <- base::`<<-`
[16:14:29.273]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:29.273]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:29.273]                   3L)]
[16:14:29.273]             }
[16:14:29.273]             function(cond) {
[16:14:29.273]                 is_error <- inherits(cond, "error")
[16:14:29.273]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:29.273]                   NULL)
[16:14:29.273]                 if (is_error) {
[16:14:29.273]                   sessionInformation <- function() {
[16:14:29.273]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:29.273]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:29.273]                       search = base::search(), system = base::Sys.info())
[16:14:29.273]                   }
[16:14:29.273]                   ...future.conditions[[length(...future.conditions) + 
[16:14:29.273]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:29.273]                     cond$call), session = sessionInformation(), 
[16:14:29.273]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:29.273]                   signalCondition(cond)
[16:14:29.273]                 }
[16:14:29.273]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:29.273]                 "immediateCondition"))) {
[16:14:29.273]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:29.273]                   ...future.conditions[[length(...future.conditions) + 
[16:14:29.273]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:29.273]                   if (TRUE && !signal) {
[16:14:29.273]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.273]                     {
[16:14:29.273]                       inherits <- base::inherits
[16:14:29.273]                       invokeRestart <- base::invokeRestart
[16:14:29.273]                       is.null <- base::is.null
[16:14:29.273]                       muffled <- FALSE
[16:14:29.273]                       if (inherits(cond, "message")) {
[16:14:29.273]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:29.273]                         if (muffled) 
[16:14:29.273]                           invokeRestart("muffleMessage")
[16:14:29.273]                       }
[16:14:29.273]                       else if (inherits(cond, "warning")) {
[16:14:29.273]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:29.273]                         if (muffled) 
[16:14:29.273]                           invokeRestart("muffleWarning")
[16:14:29.273]                       }
[16:14:29.273]                       else if (inherits(cond, "condition")) {
[16:14:29.273]                         if (!is.null(pattern)) {
[16:14:29.273]                           computeRestarts <- base::computeRestarts
[16:14:29.273]                           grepl <- base::grepl
[16:14:29.273]                           restarts <- computeRestarts(cond)
[16:14:29.273]                           for (restart in restarts) {
[16:14:29.273]                             name <- restart$name
[16:14:29.273]                             if (is.null(name)) 
[16:14:29.273]                               next
[16:14:29.273]                             if (!grepl(pattern, name)) 
[16:14:29.273]                               next
[16:14:29.273]                             invokeRestart(restart)
[16:14:29.273]                             muffled <- TRUE
[16:14:29.273]                             break
[16:14:29.273]                           }
[16:14:29.273]                         }
[16:14:29.273]                       }
[16:14:29.273]                       invisible(muffled)
[16:14:29.273]                     }
[16:14:29.273]                     muffleCondition(cond, pattern = "^muffle")
[16:14:29.273]                   }
[16:14:29.273]                 }
[16:14:29.273]                 else {
[16:14:29.273]                   if (TRUE) {
[16:14:29.273]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.273]                     {
[16:14:29.273]                       inherits <- base::inherits
[16:14:29.273]                       invokeRestart <- base::invokeRestart
[16:14:29.273]                       is.null <- base::is.null
[16:14:29.273]                       muffled <- FALSE
[16:14:29.273]                       if (inherits(cond, "message")) {
[16:14:29.273]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:29.273]                         if (muffled) 
[16:14:29.273]                           invokeRestart("muffleMessage")
[16:14:29.273]                       }
[16:14:29.273]                       else if (inherits(cond, "warning")) {
[16:14:29.273]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:29.273]                         if (muffled) 
[16:14:29.273]                           invokeRestart("muffleWarning")
[16:14:29.273]                       }
[16:14:29.273]                       else if (inherits(cond, "condition")) {
[16:14:29.273]                         if (!is.null(pattern)) {
[16:14:29.273]                           computeRestarts <- base::computeRestarts
[16:14:29.273]                           grepl <- base::grepl
[16:14:29.273]                           restarts <- computeRestarts(cond)
[16:14:29.273]                           for (restart in restarts) {
[16:14:29.273]                             name <- restart$name
[16:14:29.273]                             if (is.null(name)) 
[16:14:29.273]                               next
[16:14:29.273]                             if (!grepl(pattern, name)) 
[16:14:29.273]                               next
[16:14:29.273]                             invokeRestart(restart)
[16:14:29.273]                             muffled <- TRUE
[16:14:29.273]                             break
[16:14:29.273]                           }
[16:14:29.273]                         }
[16:14:29.273]                       }
[16:14:29.273]                       invisible(muffled)
[16:14:29.273]                     }
[16:14:29.273]                     muffleCondition(cond, pattern = "^muffle")
[16:14:29.273]                   }
[16:14:29.273]                 }
[16:14:29.273]             }
[16:14:29.273]         }))
[16:14:29.273]     }, error = function(ex) {
[16:14:29.273]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:29.273]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:29.273]                 ...future.rng), started = ...future.startTime, 
[16:14:29.273]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:29.273]             version = "1.8"), class = "FutureResult")
[16:14:29.273]     }, finally = {
[16:14:29.273]         if (!identical(...future.workdir, getwd())) 
[16:14:29.273]             setwd(...future.workdir)
[16:14:29.273]         {
[16:14:29.273]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:29.273]                 ...future.oldOptions$nwarnings <- NULL
[16:14:29.273]             }
[16:14:29.273]             base::options(...future.oldOptions)
[16:14:29.273]             if (.Platform$OS.type == "windows") {
[16:14:29.273]                 old_names <- names(...future.oldEnvVars)
[16:14:29.273]                 envs <- base::Sys.getenv()
[16:14:29.273]                 names <- names(envs)
[16:14:29.273]                 common <- intersect(names, old_names)
[16:14:29.273]                 added <- setdiff(names, old_names)
[16:14:29.273]                 removed <- setdiff(old_names, names)
[16:14:29.273]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:29.273]                   envs[common]]
[16:14:29.273]                 NAMES <- toupper(changed)
[16:14:29.273]                 args <- list()
[16:14:29.273]                 for (kk in seq_along(NAMES)) {
[16:14:29.273]                   name <- changed[[kk]]
[16:14:29.273]                   NAME <- NAMES[[kk]]
[16:14:29.273]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.273]                     next
[16:14:29.273]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:29.273]                 }
[16:14:29.273]                 NAMES <- toupper(added)
[16:14:29.273]                 for (kk in seq_along(NAMES)) {
[16:14:29.273]                   name <- added[[kk]]
[16:14:29.273]                   NAME <- NAMES[[kk]]
[16:14:29.273]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.273]                     next
[16:14:29.273]                   args[[name]] <- ""
[16:14:29.273]                 }
[16:14:29.273]                 NAMES <- toupper(removed)
[16:14:29.273]                 for (kk in seq_along(NAMES)) {
[16:14:29.273]                   name <- removed[[kk]]
[16:14:29.273]                   NAME <- NAMES[[kk]]
[16:14:29.273]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.273]                     next
[16:14:29.273]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:29.273]                 }
[16:14:29.273]                 if (length(args) > 0) 
[16:14:29.273]                   base::do.call(base::Sys.setenv, args = args)
[16:14:29.273]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:29.273]             }
[16:14:29.273]             else {
[16:14:29.273]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:29.273]             }
[16:14:29.273]             {
[16:14:29.273]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:29.273]                   0L) {
[16:14:29.273]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:29.273]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:29.273]                   base::options(opts)
[16:14:29.273]                 }
[16:14:29.273]                 {
[16:14:29.273]                   {
[16:14:29.273]                     base::options(mc.cores = ...future.mc.cores.old)
[16:14:29.273]                     NULL
[16:14:29.273]                   }
[16:14:29.273]                   options(future.plan = NULL)
[16:14:29.273]                   if (is.na(NA_character_)) 
[16:14:29.273]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:29.273]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:29.273]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:14:29.273]                     envir = parent.frame()) 
[16:14:29.273]                   {
[16:14:29.273]                     default_workers <- missing(workers)
[16:14:29.273]                     if (is.function(workers)) 
[16:14:29.273]                       workers <- workers()
[16:14:29.273]                     workers <- structure(as.integer(workers), 
[16:14:29.273]                       class = class(workers))
[16:14:29.273]                     stop_if_not(is.finite(workers), workers >= 
[16:14:29.273]                       1L)
[16:14:29.273]                     if ((workers == 1L && !inherits(workers, 
[16:14:29.273]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:14:29.273]                       if (default_workers) 
[16:14:29.273]                         supportsMulticore(warn = TRUE)
[16:14:29.273]                       return(sequential(..., envir = envir))
[16:14:29.273]                     }
[16:14:29.273]                     oopts <- options(mc.cores = workers)
[16:14:29.273]                     on.exit(options(oopts))
[16:14:29.273]                     future <- MulticoreFuture(..., workers = workers, 
[16:14:29.273]                       envir = envir)
[16:14:29.273]                     if (!future$lazy) 
[16:14:29.273]                       future <- run(future)
[16:14:29.273]                     invisible(future)
[16:14:29.273]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:29.273]                 }
[16:14:29.273]             }
[16:14:29.273]         }
[16:14:29.273]     })
[16:14:29.273]     if (TRUE) {
[16:14:29.273]         base::sink(type = "output", split = FALSE)
[16:14:29.273]         if (FALSE) {
[16:14:29.273]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:29.273]         }
[16:14:29.273]         else {
[16:14:29.273]             ...future.result["stdout"] <- base::list(NULL)
[16:14:29.273]         }
[16:14:29.273]         base::close(...future.stdout)
[16:14:29.273]         ...future.stdout <- NULL
[16:14:29.273]     }
[16:14:29.273]     ...future.result$conditions <- ...future.conditions
[16:14:29.273]     ...future.result$finished <- base::Sys.time()
[16:14:29.273]     ...future.result
[16:14:29.273] }
[16:14:29.276] requestCore(): workers = 2
[16:14:29.277] MulticoreFuture started
[16:14:29.278] - Launch lazy future ... done
[16:14:29.278] run() for ‘MulticoreFuture’ ... done
[16:14:29.279] plan(): Setting new future strategy stack:
[16:14:29.279] List of future strategies:
[16:14:29.279] 1. sequential:
[16:14:29.279]    - args: function (..., envir = parent.frame())
[16:14:29.279]    - tweaked: FALSE
[16:14:29.279]    - call: NULL
[16:14:29.280] plan(): nbrOfWorkers() = 1
[16:14:29.283] plan(): Setting new future strategy stack:
[16:14:29.283] List of future strategies:
[16:14:29.283] 1. multicore:
[16:14:29.283]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:14:29.283]    - tweaked: FALSE
[16:14:29.283]    - call: plan(strategy)
[16:14:29.288] plan(): nbrOfWorkers() = 2
- stdout = structure(TRUE, drop = TRUE)
[16:14:29.289] getGlobalsAndPackages() ...
[16:14:29.289] Searching for globals...
[16:14:29.290] - globals found: [1] ‘print’
[16:14:29.290] Searching for globals ... DONE
[16:14:29.290] Resolving globals: FALSE
[16:14:29.290] 
[16:14:29.290] 
[16:14:29.291] getGlobalsAndPackages() ... DONE
[16:14:29.291] run() for ‘Future’ ...
[16:14:29.291] - state: ‘created’
[16:14:29.291] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:14:29.295] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:14:29.295] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:14:29.295]   - Field: ‘label’
[16:14:29.295]   - Field: ‘local’
[16:14:29.296]   - Field: ‘owner’
[16:14:29.296]   - Field: ‘envir’
[16:14:29.296]   - Field: ‘workers’
[16:14:29.296]   - Field: ‘packages’
[16:14:29.296]   - Field: ‘gc’
[16:14:29.296]   - Field: ‘job’
[16:14:29.296]   - Field: ‘conditions’
[16:14:29.296]   - Field: ‘expr’
[16:14:29.297]   - Field: ‘uuid’
[16:14:29.297]   - Field: ‘seed’
[16:14:29.297]   - Field: ‘version’
[16:14:29.297]   - Field: ‘result’
[16:14:29.297]   - Field: ‘asynchronous’
[16:14:29.297]   - Field: ‘calls’
[16:14:29.297]   - Field: ‘globals’
[16:14:29.297]   - Field: ‘stdout’
[16:14:29.297]   - Field: ‘earlySignal’
[16:14:29.298]   - Field: ‘lazy’
[16:14:29.298]   - Field: ‘state’
[16:14:29.298] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:14:29.298] - Launch lazy future ...
[16:14:29.298] Packages needed by the future expression (n = 0): <none>
[16:14:29.298] Packages needed by future strategies (n = 0): <none>
[16:14:29.299] {
[16:14:29.299]     {
[16:14:29.299]         {
[16:14:29.299]             ...future.startTime <- base::Sys.time()
[16:14:29.299]             {
[16:14:29.299]                 {
[16:14:29.299]                   {
[16:14:29.299]                     {
[16:14:29.299]                       base::local({
[16:14:29.299]                         has_future <- base::requireNamespace("future", 
[16:14:29.299]                           quietly = TRUE)
[16:14:29.299]                         if (has_future) {
[16:14:29.299]                           ns <- base::getNamespace("future")
[16:14:29.299]                           version <- ns[[".package"]][["version"]]
[16:14:29.299]                           if (is.null(version)) 
[16:14:29.299]                             version <- utils::packageVersion("future")
[16:14:29.299]                         }
[16:14:29.299]                         else {
[16:14:29.299]                           version <- NULL
[16:14:29.299]                         }
[16:14:29.299]                         if (!has_future || version < "1.8.0") {
[16:14:29.299]                           info <- base::c(r_version = base::gsub("R version ", 
[16:14:29.299]                             "", base::R.version$version.string), 
[16:14:29.299]                             platform = base::sprintf("%s (%s-bit)", 
[16:14:29.299]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:14:29.299]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:29.299]                               "release", "version")], collapse = " "), 
[16:14:29.299]                             hostname = base::Sys.info()[["nodename"]])
[16:14:29.299]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:14:29.299]                             info)
[16:14:29.299]                           info <- base::paste(info, collapse = "; ")
[16:14:29.299]                           if (!has_future) {
[16:14:29.299]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:29.299]                               info)
[16:14:29.299]                           }
[16:14:29.299]                           else {
[16:14:29.299]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:29.299]                               info, version)
[16:14:29.299]                           }
[16:14:29.299]                           base::stop(msg)
[16:14:29.299]                         }
[16:14:29.299]                       })
[16:14:29.299]                     }
[16:14:29.299]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:14:29.299]                     base::options(mc.cores = 1L)
[16:14:29.299]                   }
[16:14:29.299]                   options(future.plan = NULL)
[16:14:29.299]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:29.299]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:29.299]                 }
[16:14:29.299]                 ...future.workdir <- getwd()
[16:14:29.299]             }
[16:14:29.299]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:29.299]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:29.299]         }
[16:14:29.299]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:29.299]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:29.299]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:29.299]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:29.299]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:29.299]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:29.299]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:29.299]             base::names(...future.oldOptions))
[16:14:29.299]     }
[16:14:29.299]     if (FALSE) {
[16:14:29.299]     }
[16:14:29.299]     else {
[16:14:29.299]         if (TRUE) {
[16:14:29.299]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:29.299]                 open = "w")
[16:14:29.299]         }
[16:14:29.299]         else {
[16:14:29.299]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:29.299]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:29.299]         }
[16:14:29.299]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:29.299]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:29.299]             base::sink(type = "output", split = FALSE)
[16:14:29.299]             base::close(...future.stdout)
[16:14:29.299]         }, add = TRUE)
[16:14:29.299]     }
[16:14:29.299]     ...future.frame <- base::sys.nframe()
[16:14:29.299]     ...future.conditions <- base::list()
[16:14:29.299]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:29.299]     if (FALSE) {
[16:14:29.299]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:29.299]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:29.299]     }
[16:14:29.299]     ...future.result <- base::tryCatch({
[16:14:29.299]         base::withCallingHandlers({
[16:14:29.299]             ...future.value <- base::withVisible(base::local({
[16:14:29.299]                 withCallingHandlers({
[16:14:29.299]                   print(42)
[16:14:29.299]                 }, immediateCondition = function(cond) {
[16:14:29.299]                   save_rds <- function (object, pathname, ...) 
[16:14:29.299]                   {
[16:14:29.299]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:14:29.299]                     if (file_test("-f", pathname_tmp)) {
[16:14:29.299]                       fi_tmp <- file.info(pathname_tmp)
[16:14:29.299]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:14:29.299]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:14:29.299]                         fi_tmp[["mtime"]])
[16:14:29.299]                     }
[16:14:29.299]                     tryCatch({
[16:14:29.299]                       saveRDS(object, file = pathname_tmp, ...)
[16:14:29.299]                     }, error = function(ex) {
[16:14:29.299]                       msg <- conditionMessage(ex)
[16:14:29.299]                       fi_tmp <- file.info(pathname_tmp)
[16:14:29.299]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:14:29.299]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:14:29.299]                         fi_tmp[["mtime"]], msg)
[16:14:29.299]                       ex$message <- msg
[16:14:29.299]                       stop(ex)
[16:14:29.299]                     })
[16:14:29.299]                     stopifnot(file_test("-f", pathname_tmp))
[16:14:29.299]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:14:29.299]                     if (!res || file_test("-f", pathname_tmp)) {
[16:14:29.299]                       fi_tmp <- file.info(pathname_tmp)
[16:14:29.299]                       fi <- file.info(pathname)
[16:14:29.299]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:14:29.299]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:14:29.299]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:14:29.299]                         fi[["size"]], fi[["mtime"]])
[16:14:29.299]                       stop(msg)
[16:14:29.299]                     }
[16:14:29.299]                     invisible(pathname)
[16:14:29.299]                   }
[16:14:29.299]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:14:29.299]                     rootPath = tempdir()) 
[16:14:29.299]                   {
[16:14:29.299]                     obj <- list(time = Sys.time(), condition = cond)
[16:14:29.299]                     file <- tempfile(pattern = class(cond)[1], 
[16:14:29.299]                       tmpdir = path, fileext = ".rds")
[16:14:29.299]                     save_rds(obj, file)
[16:14:29.299]                   }
[16:14:29.299]                   saveImmediateCondition(cond, path = "/tmp/RtmpEpin5U/.future/immediateConditions")
[16:14:29.299]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.299]                   {
[16:14:29.299]                     inherits <- base::inherits
[16:14:29.299]                     invokeRestart <- base::invokeRestart
[16:14:29.299]                     is.null <- base::is.null
[16:14:29.299]                     muffled <- FALSE
[16:14:29.299]                     if (inherits(cond, "message")) {
[16:14:29.299]                       muffled <- grepl(pattern, "muffleMessage")
[16:14:29.299]                       if (muffled) 
[16:14:29.299]                         invokeRestart("muffleMessage")
[16:14:29.299]                     }
[16:14:29.299]                     else if (inherits(cond, "warning")) {
[16:14:29.299]                       muffled <- grepl(pattern, "muffleWarning")
[16:14:29.299]                       if (muffled) 
[16:14:29.299]                         invokeRestart("muffleWarning")
[16:14:29.299]                     }
[16:14:29.299]                     else if (inherits(cond, "condition")) {
[16:14:29.299]                       if (!is.null(pattern)) {
[16:14:29.299]                         computeRestarts <- base::computeRestarts
[16:14:29.299]                         grepl <- base::grepl
[16:14:29.299]                         restarts <- computeRestarts(cond)
[16:14:29.299]                         for (restart in restarts) {
[16:14:29.299]                           name <- restart$name
[16:14:29.299]                           if (is.null(name)) 
[16:14:29.299]                             next
[16:14:29.299]                           if (!grepl(pattern, name)) 
[16:14:29.299]                             next
[16:14:29.299]                           invokeRestart(restart)
[16:14:29.299]                           muffled <- TRUE
[16:14:29.299]                           break
[16:14:29.299]                         }
[16:14:29.299]                       }
[16:14:29.299]                     }
[16:14:29.299]                     invisible(muffled)
[16:14:29.299]                   }
[16:14:29.299]                   muffleCondition(cond)
[16:14:29.299]                 })
[16:14:29.299]             }))
[16:14:29.299]             future::FutureResult(value = ...future.value$value, 
[16:14:29.299]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:29.299]                   ...future.rng), globalenv = if (FALSE) 
[16:14:29.299]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:29.299]                     ...future.globalenv.names))
[16:14:29.299]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:29.299]         }, condition = base::local({
[16:14:29.299]             c <- base::c
[16:14:29.299]             inherits <- base::inherits
[16:14:29.299]             invokeRestart <- base::invokeRestart
[16:14:29.299]             length <- base::length
[16:14:29.299]             list <- base::list
[16:14:29.299]             seq.int <- base::seq.int
[16:14:29.299]             signalCondition <- base::signalCondition
[16:14:29.299]             sys.calls <- base::sys.calls
[16:14:29.299]             `[[` <- base::`[[`
[16:14:29.299]             `+` <- base::`+`
[16:14:29.299]             `<<-` <- base::`<<-`
[16:14:29.299]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:29.299]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:29.299]                   3L)]
[16:14:29.299]             }
[16:14:29.299]             function(cond) {
[16:14:29.299]                 is_error <- inherits(cond, "error")
[16:14:29.299]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:29.299]                   NULL)
[16:14:29.299]                 if (is_error) {
[16:14:29.299]                   sessionInformation <- function() {
[16:14:29.299]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:29.299]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:29.299]                       search = base::search(), system = base::Sys.info())
[16:14:29.299]                   }
[16:14:29.299]                   ...future.conditions[[length(...future.conditions) + 
[16:14:29.299]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:29.299]                     cond$call), session = sessionInformation(), 
[16:14:29.299]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:29.299]                   signalCondition(cond)
[16:14:29.299]                 }
[16:14:29.299]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:29.299]                 "immediateCondition"))) {
[16:14:29.299]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:29.299]                   ...future.conditions[[length(...future.conditions) + 
[16:14:29.299]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:29.299]                   if (TRUE && !signal) {
[16:14:29.299]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.299]                     {
[16:14:29.299]                       inherits <- base::inherits
[16:14:29.299]                       invokeRestart <- base::invokeRestart
[16:14:29.299]                       is.null <- base::is.null
[16:14:29.299]                       muffled <- FALSE
[16:14:29.299]                       if (inherits(cond, "message")) {
[16:14:29.299]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:29.299]                         if (muffled) 
[16:14:29.299]                           invokeRestart("muffleMessage")
[16:14:29.299]                       }
[16:14:29.299]                       else if (inherits(cond, "warning")) {
[16:14:29.299]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:29.299]                         if (muffled) 
[16:14:29.299]                           invokeRestart("muffleWarning")
[16:14:29.299]                       }
[16:14:29.299]                       else if (inherits(cond, "condition")) {
[16:14:29.299]                         if (!is.null(pattern)) {
[16:14:29.299]                           computeRestarts <- base::computeRestarts
[16:14:29.299]                           grepl <- base::grepl
[16:14:29.299]                           restarts <- computeRestarts(cond)
[16:14:29.299]                           for (restart in restarts) {
[16:14:29.299]                             name <- restart$name
[16:14:29.299]                             if (is.null(name)) 
[16:14:29.299]                               next
[16:14:29.299]                             if (!grepl(pattern, name)) 
[16:14:29.299]                               next
[16:14:29.299]                             invokeRestart(restart)
[16:14:29.299]                             muffled <- TRUE
[16:14:29.299]                             break
[16:14:29.299]                           }
[16:14:29.299]                         }
[16:14:29.299]                       }
[16:14:29.299]                       invisible(muffled)
[16:14:29.299]                     }
[16:14:29.299]                     muffleCondition(cond, pattern = "^muffle")
[16:14:29.299]                   }
[16:14:29.299]                 }
[16:14:29.299]                 else {
[16:14:29.299]                   if (TRUE) {
[16:14:29.299]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.299]                     {
[16:14:29.299]                       inherits <- base::inherits
[16:14:29.299]                       invokeRestart <- base::invokeRestart
[16:14:29.299]                       is.null <- base::is.null
[16:14:29.299]                       muffled <- FALSE
[16:14:29.299]                       if (inherits(cond, "message")) {
[16:14:29.299]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:29.299]                         if (muffled) 
[16:14:29.299]                           invokeRestart("muffleMessage")
[16:14:29.299]                       }
[16:14:29.299]                       else if (inherits(cond, "warning")) {
[16:14:29.299]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:29.299]                         if (muffled) 
[16:14:29.299]                           invokeRestart("muffleWarning")
[16:14:29.299]                       }
[16:14:29.299]                       else if (inherits(cond, "condition")) {
[16:14:29.299]                         if (!is.null(pattern)) {
[16:14:29.299]                           computeRestarts <- base::computeRestarts
[16:14:29.299]                           grepl <- base::grepl
[16:14:29.299]                           restarts <- computeRestarts(cond)
[16:14:29.299]                           for (restart in restarts) {
[16:14:29.299]                             name <- restart$name
[16:14:29.299]                             if (is.null(name)) 
[16:14:29.299]                               next
[16:14:29.299]                             if (!grepl(pattern, name)) 
[16:14:29.299]                               next
[16:14:29.299]                             invokeRestart(restart)
[16:14:29.299]                             muffled <- TRUE
[16:14:29.299]                             break
[16:14:29.299]                           }
[16:14:29.299]                         }
[16:14:29.299]                       }
[16:14:29.299]                       invisible(muffled)
[16:14:29.299]                     }
[16:14:29.299]                     muffleCondition(cond, pattern = "^muffle")
[16:14:29.299]                   }
[16:14:29.299]                 }
[16:14:29.299]             }
[16:14:29.299]         }))
[16:14:29.299]     }, error = function(ex) {
[16:14:29.299]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:29.299]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:29.299]                 ...future.rng), started = ...future.startTime, 
[16:14:29.299]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:29.299]             version = "1.8"), class = "FutureResult")
[16:14:29.299]     }, finally = {
[16:14:29.299]         if (!identical(...future.workdir, getwd())) 
[16:14:29.299]             setwd(...future.workdir)
[16:14:29.299]         {
[16:14:29.299]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:29.299]                 ...future.oldOptions$nwarnings <- NULL
[16:14:29.299]             }
[16:14:29.299]             base::options(...future.oldOptions)
[16:14:29.299]             if (.Platform$OS.type == "windows") {
[16:14:29.299]                 old_names <- names(...future.oldEnvVars)
[16:14:29.299]                 envs <- base::Sys.getenv()
[16:14:29.299]                 names <- names(envs)
[16:14:29.299]                 common <- intersect(names, old_names)
[16:14:29.299]                 added <- setdiff(names, old_names)
[16:14:29.299]                 removed <- setdiff(old_names, names)
[16:14:29.299]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:29.299]                   envs[common]]
[16:14:29.299]                 NAMES <- toupper(changed)
[16:14:29.299]                 args <- list()
[16:14:29.299]                 for (kk in seq_along(NAMES)) {
[16:14:29.299]                   name <- changed[[kk]]
[16:14:29.299]                   NAME <- NAMES[[kk]]
[16:14:29.299]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.299]                     next
[16:14:29.299]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:29.299]                 }
[16:14:29.299]                 NAMES <- toupper(added)
[16:14:29.299]                 for (kk in seq_along(NAMES)) {
[16:14:29.299]                   name <- added[[kk]]
[16:14:29.299]                   NAME <- NAMES[[kk]]
[16:14:29.299]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.299]                     next
[16:14:29.299]                   args[[name]] <- ""
[16:14:29.299]                 }
[16:14:29.299]                 NAMES <- toupper(removed)
[16:14:29.299]                 for (kk in seq_along(NAMES)) {
[16:14:29.299]                   name <- removed[[kk]]
[16:14:29.299]                   NAME <- NAMES[[kk]]
[16:14:29.299]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.299]                     next
[16:14:29.299]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:29.299]                 }
[16:14:29.299]                 if (length(args) > 0) 
[16:14:29.299]                   base::do.call(base::Sys.setenv, args = args)
[16:14:29.299]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:29.299]             }
[16:14:29.299]             else {
[16:14:29.299]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:29.299]             }
[16:14:29.299]             {
[16:14:29.299]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:29.299]                   0L) {
[16:14:29.299]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:29.299]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:29.299]                   base::options(opts)
[16:14:29.299]                 }
[16:14:29.299]                 {
[16:14:29.299]                   {
[16:14:29.299]                     base::options(mc.cores = ...future.mc.cores.old)
[16:14:29.299]                     NULL
[16:14:29.299]                   }
[16:14:29.299]                   options(future.plan = NULL)
[16:14:29.299]                   if (is.na(NA_character_)) 
[16:14:29.299]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:29.299]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:29.299]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:14:29.299]                     envir = parent.frame()) 
[16:14:29.299]                   {
[16:14:29.299]                     default_workers <- missing(workers)
[16:14:29.299]                     if (is.function(workers)) 
[16:14:29.299]                       workers <- workers()
[16:14:29.299]                     workers <- structure(as.integer(workers), 
[16:14:29.299]                       class = class(workers))
[16:14:29.299]                     stop_if_not(is.finite(workers), workers >= 
[16:14:29.299]                       1L)
[16:14:29.299]                     if ((workers == 1L && !inherits(workers, 
[16:14:29.299]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:14:29.299]                       if (default_workers) 
[16:14:29.299]                         supportsMulticore(warn = TRUE)
[16:14:29.299]                       return(sequential(..., envir = envir))
[16:14:29.299]                     }
[16:14:29.299]                     oopts <- options(mc.cores = workers)
[16:14:29.299]                     on.exit(options(oopts))
[16:14:29.299]                     future <- MulticoreFuture(..., workers = workers, 
[16:14:29.299]                       envir = envir)
[16:14:29.299]                     if (!future$lazy) 
[16:14:29.299]                       future <- run(future)
[16:14:29.299]                     invisible(future)
[16:14:29.299]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:29.299]                 }
[16:14:29.299]             }
[16:14:29.299]         }
[16:14:29.299]     })
[16:14:29.299]     if (TRUE) {
[16:14:29.299]         base::sink(type = "output", split = FALSE)
[16:14:29.299]         if (TRUE) {
[16:14:29.299]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:29.299]         }
[16:14:29.299]         else {
[16:14:29.299]             ...future.result["stdout"] <- base::list(NULL)
[16:14:29.299]         }
[16:14:29.299]         base::close(...future.stdout)
[16:14:29.299]         ...future.stdout <- NULL
[16:14:29.299]     }
[16:14:29.299]     ...future.result$conditions <- ...future.conditions
[16:14:29.299]     ...future.result$finished <- base::Sys.time()
[16:14:29.299]     ...future.result
[16:14:29.299] }
[16:14:29.302] requestCore(): workers = 2
[16:14:29.303] MulticoreFuture started
[16:14:29.304] - Launch lazy future ... done
[16:14:29.304] run() for ‘MulticoreFuture’ ... done
[16:14:29.304] plan(): Setting new future strategy stack:
[16:14:29.305] List of future strategies:
[16:14:29.305] 1. sequential:
[16:14:29.305]    - args: function (..., envir = parent.frame())
[16:14:29.305]    - tweaked: FALSE
[16:14:29.305]    - call: NULL
[16:14:29.306] plan(): nbrOfWorkers() = 1
[16:14:29.308] plan(): Setting new future strategy stack:
[16:14:29.308] List of future strategies:
[16:14:29.308] 1. multicore:
[16:14:29.308]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:14:29.308]    - tweaked: FALSE
[16:14:29.308]    - call: plan(strategy)
[16:14:29.317] plan(): nbrOfWorkers() = 2
[1] 42
- stdout = NA
[16:14:29.319] getGlobalsAndPackages() ...
[16:14:29.319] Searching for globals...
[16:14:29.326] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[16:14:29.326] Searching for globals ... DONE
[16:14:29.326] Resolving globals: FALSE
[16:14:29.327] 
[16:14:29.327] - packages: [1] ‘utils’
[16:14:29.327] getGlobalsAndPackages() ... DONE
[16:14:29.327] run() for ‘Future’ ...
[16:14:29.327] - state: ‘created’
[16:14:29.328] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:14:29.331] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:14:29.331] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:14:29.332]   - Field: ‘label’
[16:14:29.332]   - Field: ‘local’
[16:14:29.332]   - Field: ‘owner’
[16:14:29.332]   - Field: ‘envir’
[16:14:29.332]   - Field: ‘workers’
[16:14:29.332]   - Field: ‘packages’
[16:14:29.332]   - Field: ‘gc’
[16:14:29.333]   - Field: ‘job’
[16:14:29.333]   - Field: ‘conditions’
[16:14:29.333]   - Field: ‘expr’
[16:14:29.333]   - Field: ‘uuid’
[16:14:29.333]   - Field: ‘seed’
[16:14:29.333]   - Field: ‘version’
[16:14:29.333]   - Field: ‘result’
[16:14:29.333]   - Field: ‘asynchronous’
[16:14:29.333]   - Field: ‘calls’
[16:14:29.334]   - Field: ‘globals’
[16:14:29.334]   - Field: ‘stdout’
[16:14:29.334]   - Field: ‘earlySignal’
[16:14:29.334]   - Field: ‘lazy’
[16:14:29.334]   - Field: ‘state’
[16:14:29.334] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:14:29.334] - Launch lazy future ...
[16:14:29.335] Packages needed by the future expression (n = 1): ‘utils’
[16:14:29.335] Packages needed by future strategies (n = 0): <none>
[16:14:29.335] {
[16:14:29.335]     {
[16:14:29.335]         {
[16:14:29.335]             ...future.startTime <- base::Sys.time()
[16:14:29.335]             {
[16:14:29.335]                 {
[16:14:29.335]                   {
[16:14:29.335]                     {
[16:14:29.335]                       {
[16:14:29.335]                         base::local({
[16:14:29.335]                           has_future <- base::requireNamespace("future", 
[16:14:29.335]                             quietly = TRUE)
[16:14:29.335]                           if (has_future) {
[16:14:29.335]                             ns <- base::getNamespace("future")
[16:14:29.335]                             version <- ns[[".package"]][["version"]]
[16:14:29.335]                             if (is.null(version)) 
[16:14:29.335]                               version <- utils::packageVersion("future")
[16:14:29.335]                           }
[16:14:29.335]                           else {
[16:14:29.335]                             version <- NULL
[16:14:29.335]                           }
[16:14:29.335]                           if (!has_future || version < "1.8.0") {
[16:14:29.335]                             info <- base::c(r_version = base::gsub("R version ", 
[16:14:29.335]                               "", base::R.version$version.string), 
[16:14:29.335]                               platform = base::sprintf("%s (%s-bit)", 
[16:14:29.335]                                 base::R.version$platform, 8 * 
[16:14:29.335]                                   base::.Machine$sizeof.pointer), 
[16:14:29.335]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:29.335]                                 "release", "version")], collapse = " "), 
[16:14:29.335]                               hostname = base::Sys.info()[["nodename"]])
[16:14:29.335]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:14:29.335]                               info)
[16:14:29.335]                             info <- base::paste(info, collapse = "; ")
[16:14:29.335]                             if (!has_future) {
[16:14:29.335]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:29.335]                                 info)
[16:14:29.335]                             }
[16:14:29.335]                             else {
[16:14:29.335]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:29.335]                                 info, version)
[16:14:29.335]                             }
[16:14:29.335]                             base::stop(msg)
[16:14:29.335]                           }
[16:14:29.335]                         })
[16:14:29.335]                       }
[16:14:29.335]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:14:29.335]                       base::options(mc.cores = 1L)
[16:14:29.335]                     }
[16:14:29.335]                     base::local({
[16:14:29.335]                       for (pkg in "utils") {
[16:14:29.335]                         base::loadNamespace(pkg)
[16:14:29.335]                         base::library(pkg, character.only = TRUE)
[16:14:29.335]                       }
[16:14:29.335]                     })
[16:14:29.335]                   }
[16:14:29.335]                   options(future.plan = NULL)
[16:14:29.335]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:29.335]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:29.335]                 }
[16:14:29.335]                 ...future.workdir <- getwd()
[16:14:29.335]             }
[16:14:29.335]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:29.335]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:29.335]         }
[16:14:29.335]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:29.335]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:29.335]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:29.335]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:29.335]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:29.335]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:29.335]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:29.335]             base::names(...future.oldOptions))
[16:14:29.335]     }
[16:14:29.335]     if (TRUE) {
[16:14:29.335]     }
[16:14:29.335]     else {
[16:14:29.335]         if (NA) {
[16:14:29.335]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:29.335]                 open = "w")
[16:14:29.335]         }
[16:14:29.335]         else {
[16:14:29.335]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:29.335]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:29.335]         }
[16:14:29.335]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:29.335]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:29.335]             base::sink(type = "output", split = FALSE)
[16:14:29.335]             base::close(...future.stdout)
[16:14:29.335]         }, add = TRUE)
[16:14:29.335]     }
[16:14:29.335]     ...future.frame <- base::sys.nframe()
[16:14:29.335]     ...future.conditions <- base::list()
[16:14:29.335]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:29.335]     if (FALSE) {
[16:14:29.335]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:29.335]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:29.335]     }
[16:14:29.335]     ...future.result <- base::tryCatch({
[16:14:29.335]         base::withCallingHandlers({
[16:14:29.335]             ...future.value <- base::withVisible(base::local({
[16:14:29.335]                 withCallingHandlers({
[16:14:29.335]                   {
[16:14:29.335]                     print(1:50)
[16:14:29.335]                     str(1:50)
[16:14:29.335]                     cat(letters, sep = "-")
[16:14:29.335]                     cat(1:6, collapse = "\n")
[16:14:29.335]                     write.table(datasets::iris[1:10, ], sep = "\t")
[16:14:29.335]                     42L
[16:14:29.335]                   }
[16:14:29.335]                 }, immediateCondition = function(cond) {
[16:14:29.335]                   save_rds <- function (object, pathname, ...) 
[16:14:29.335]                   {
[16:14:29.335]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:14:29.335]                     if (file_test("-f", pathname_tmp)) {
[16:14:29.335]                       fi_tmp <- file.info(pathname_tmp)
[16:14:29.335]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:14:29.335]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:14:29.335]                         fi_tmp[["mtime"]])
[16:14:29.335]                     }
[16:14:29.335]                     tryCatch({
[16:14:29.335]                       saveRDS(object, file = pathname_tmp, ...)
[16:14:29.335]                     }, error = function(ex) {
[16:14:29.335]                       msg <- conditionMessage(ex)
[16:14:29.335]                       fi_tmp <- file.info(pathname_tmp)
[16:14:29.335]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:14:29.335]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:14:29.335]                         fi_tmp[["mtime"]], msg)
[16:14:29.335]                       ex$message <- msg
[16:14:29.335]                       stop(ex)
[16:14:29.335]                     })
[16:14:29.335]                     stopifnot(file_test("-f", pathname_tmp))
[16:14:29.335]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:14:29.335]                     if (!res || file_test("-f", pathname_tmp)) {
[16:14:29.335]                       fi_tmp <- file.info(pathname_tmp)
[16:14:29.335]                       fi <- file.info(pathname)
[16:14:29.335]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:14:29.335]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:14:29.335]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:14:29.335]                         fi[["size"]], fi[["mtime"]])
[16:14:29.335]                       stop(msg)
[16:14:29.335]                     }
[16:14:29.335]                     invisible(pathname)
[16:14:29.335]                   }
[16:14:29.335]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:14:29.335]                     rootPath = tempdir()) 
[16:14:29.335]                   {
[16:14:29.335]                     obj <- list(time = Sys.time(), condition = cond)
[16:14:29.335]                     file <- tempfile(pattern = class(cond)[1], 
[16:14:29.335]                       tmpdir = path, fileext = ".rds")
[16:14:29.335]                     save_rds(obj, file)
[16:14:29.335]                   }
[16:14:29.335]                   saveImmediateCondition(cond, path = "/tmp/RtmpEpin5U/.future/immediateConditions")
[16:14:29.335]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.335]                   {
[16:14:29.335]                     inherits <- base::inherits
[16:14:29.335]                     invokeRestart <- base::invokeRestart
[16:14:29.335]                     is.null <- base::is.null
[16:14:29.335]                     muffled <- FALSE
[16:14:29.335]                     if (inherits(cond, "message")) {
[16:14:29.335]                       muffled <- grepl(pattern, "muffleMessage")
[16:14:29.335]                       if (muffled) 
[16:14:29.335]                         invokeRestart("muffleMessage")
[16:14:29.335]                     }
[16:14:29.335]                     else if (inherits(cond, "warning")) {
[16:14:29.335]                       muffled <- grepl(pattern, "muffleWarning")
[16:14:29.335]                       if (muffled) 
[16:14:29.335]                         invokeRestart("muffleWarning")
[16:14:29.335]                     }
[16:14:29.335]                     else if (inherits(cond, "condition")) {
[16:14:29.335]                       if (!is.null(pattern)) {
[16:14:29.335]                         computeRestarts <- base::computeRestarts
[16:14:29.335]                         grepl <- base::grepl
[16:14:29.335]                         restarts <- computeRestarts(cond)
[16:14:29.335]                         for (restart in restarts) {
[16:14:29.335]                           name <- restart$name
[16:14:29.335]                           if (is.null(name)) 
[16:14:29.335]                             next
[16:14:29.335]                           if (!grepl(pattern, name)) 
[16:14:29.335]                             next
[16:14:29.335]                           invokeRestart(restart)
[16:14:29.335]                           muffled <- TRUE
[16:14:29.335]                           break
[16:14:29.335]                         }
[16:14:29.335]                       }
[16:14:29.335]                     }
[16:14:29.335]                     invisible(muffled)
[16:14:29.335]                   }
[16:14:29.335]                   muffleCondition(cond)
[16:14:29.335]                 })
[16:14:29.335]             }))
[16:14:29.335]             future::FutureResult(value = ...future.value$value, 
[16:14:29.335]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:29.335]                   ...future.rng), globalenv = if (FALSE) 
[16:14:29.335]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:29.335]                     ...future.globalenv.names))
[16:14:29.335]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:29.335]         }, condition = base::local({
[16:14:29.335]             c <- base::c
[16:14:29.335]             inherits <- base::inherits
[16:14:29.335]             invokeRestart <- base::invokeRestart
[16:14:29.335]             length <- base::length
[16:14:29.335]             list <- base::list
[16:14:29.335]             seq.int <- base::seq.int
[16:14:29.335]             signalCondition <- base::signalCondition
[16:14:29.335]             sys.calls <- base::sys.calls
[16:14:29.335]             `[[` <- base::`[[`
[16:14:29.335]             `+` <- base::`+`
[16:14:29.335]             `<<-` <- base::`<<-`
[16:14:29.335]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:29.335]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:29.335]                   3L)]
[16:14:29.335]             }
[16:14:29.335]             function(cond) {
[16:14:29.335]                 is_error <- inherits(cond, "error")
[16:14:29.335]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:29.335]                   NULL)
[16:14:29.335]                 if (is_error) {
[16:14:29.335]                   sessionInformation <- function() {
[16:14:29.335]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:29.335]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:29.335]                       search = base::search(), system = base::Sys.info())
[16:14:29.335]                   }
[16:14:29.335]                   ...future.conditions[[length(...future.conditions) + 
[16:14:29.335]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:29.335]                     cond$call), session = sessionInformation(), 
[16:14:29.335]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:29.335]                   signalCondition(cond)
[16:14:29.335]                 }
[16:14:29.335]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:29.335]                 "immediateCondition"))) {
[16:14:29.335]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:29.335]                   ...future.conditions[[length(...future.conditions) + 
[16:14:29.335]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:29.335]                   if (TRUE && !signal) {
[16:14:29.335]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.335]                     {
[16:14:29.335]                       inherits <- base::inherits
[16:14:29.335]                       invokeRestart <- base::invokeRestart
[16:14:29.335]                       is.null <- base::is.null
[16:14:29.335]                       muffled <- FALSE
[16:14:29.335]                       if (inherits(cond, "message")) {
[16:14:29.335]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:29.335]                         if (muffled) 
[16:14:29.335]                           invokeRestart("muffleMessage")
[16:14:29.335]                       }
[16:14:29.335]                       else if (inherits(cond, "warning")) {
[16:14:29.335]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:29.335]                         if (muffled) 
[16:14:29.335]                           invokeRestart("muffleWarning")
[16:14:29.335]                       }
[16:14:29.335]                       else if (inherits(cond, "condition")) {
[16:14:29.335]                         if (!is.null(pattern)) {
[16:14:29.335]                           computeRestarts <- base::computeRestarts
[16:14:29.335]                           grepl <- base::grepl
[16:14:29.335]                           restarts <- computeRestarts(cond)
[16:14:29.335]                           for (restart in restarts) {
[16:14:29.335]                             name <- restart$name
[16:14:29.335]                             if (is.null(name)) 
[16:14:29.335]                               next
[16:14:29.335]                             if (!grepl(pattern, name)) 
[16:14:29.335]                               next
[16:14:29.335]                             invokeRestart(restart)
[16:14:29.335]                             muffled <- TRUE
[16:14:29.335]                             break
[16:14:29.335]                           }
[16:14:29.335]                         }
[16:14:29.335]                       }
[16:14:29.335]                       invisible(muffled)
[16:14:29.335]                     }
[16:14:29.335]                     muffleCondition(cond, pattern = "^muffle")
[16:14:29.335]                   }
[16:14:29.335]                 }
[16:14:29.335]                 else {
[16:14:29.335]                   if (TRUE) {
[16:14:29.335]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.335]                     {
[16:14:29.335]                       inherits <- base::inherits
[16:14:29.335]                       invokeRestart <- base::invokeRestart
[16:14:29.335]                       is.null <- base::is.null
[16:14:29.335]                       muffled <- FALSE
[16:14:29.335]                       if (inherits(cond, "message")) {
[16:14:29.335]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:29.335]                         if (muffled) 
[16:14:29.335]                           invokeRestart("muffleMessage")
[16:14:29.335]                       }
[16:14:29.335]                       else if (inherits(cond, "warning")) {
[16:14:29.335]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:29.335]                         if (muffled) 
[16:14:29.335]                           invokeRestart("muffleWarning")
[16:14:29.335]                       }
[16:14:29.335]                       else if (inherits(cond, "condition")) {
[16:14:29.335]                         if (!is.null(pattern)) {
[16:14:29.335]                           computeRestarts <- base::computeRestarts
[16:14:29.335]                           grepl <- base::grepl
[16:14:29.335]                           restarts <- computeRestarts(cond)
[16:14:29.335]                           for (restart in restarts) {
[16:14:29.335]                             name <- restart$name
[16:14:29.335]                             if (is.null(name)) 
[16:14:29.335]                               next
[16:14:29.335]                             if (!grepl(pattern, name)) 
[16:14:29.335]                               next
[16:14:29.335]                             invokeRestart(restart)
[16:14:29.335]                             muffled <- TRUE
[16:14:29.335]                             break
[16:14:29.335]                           }
[16:14:29.335]                         }
[16:14:29.335]                       }
[16:14:29.335]                       invisible(muffled)
[16:14:29.335]                     }
[16:14:29.335]                     muffleCondition(cond, pattern = "^muffle")
[16:14:29.335]                   }
[16:14:29.335]                 }
[16:14:29.335]             }
[16:14:29.335]         }))
[16:14:29.335]     }, error = function(ex) {
[16:14:29.335]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:29.335]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:29.335]                 ...future.rng), started = ...future.startTime, 
[16:14:29.335]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:29.335]             version = "1.8"), class = "FutureResult")
[16:14:29.335]     }, finally = {
[16:14:29.335]         if (!identical(...future.workdir, getwd())) 
[16:14:29.335]             setwd(...future.workdir)
[16:14:29.335]         {
[16:14:29.335]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:29.335]                 ...future.oldOptions$nwarnings <- NULL
[16:14:29.335]             }
[16:14:29.335]             base::options(...future.oldOptions)
[16:14:29.335]             if (.Platform$OS.type == "windows") {
[16:14:29.335]                 old_names <- names(...future.oldEnvVars)
[16:14:29.335]                 envs <- base::Sys.getenv()
[16:14:29.335]                 names <- names(envs)
[16:14:29.335]                 common <- intersect(names, old_names)
[16:14:29.335]                 added <- setdiff(names, old_names)
[16:14:29.335]                 removed <- setdiff(old_names, names)
[16:14:29.335]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:29.335]                   envs[common]]
[16:14:29.335]                 NAMES <- toupper(changed)
[16:14:29.335]                 args <- list()
[16:14:29.335]                 for (kk in seq_along(NAMES)) {
[16:14:29.335]                   name <- changed[[kk]]
[16:14:29.335]                   NAME <- NAMES[[kk]]
[16:14:29.335]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.335]                     next
[16:14:29.335]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:29.335]                 }
[16:14:29.335]                 NAMES <- toupper(added)
[16:14:29.335]                 for (kk in seq_along(NAMES)) {
[16:14:29.335]                   name <- added[[kk]]
[16:14:29.335]                   NAME <- NAMES[[kk]]
[16:14:29.335]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.335]                     next
[16:14:29.335]                   args[[name]] <- ""
[16:14:29.335]                 }
[16:14:29.335]                 NAMES <- toupper(removed)
[16:14:29.335]                 for (kk in seq_along(NAMES)) {
[16:14:29.335]                   name <- removed[[kk]]
[16:14:29.335]                   NAME <- NAMES[[kk]]
[16:14:29.335]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.335]                     next
[16:14:29.335]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:29.335]                 }
[16:14:29.335]                 if (length(args) > 0) 
[16:14:29.335]                   base::do.call(base::Sys.setenv, args = args)
[16:14:29.335]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:29.335]             }
[16:14:29.335]             else {
[16:14:29.335]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:29.335]             }
[16:14:29.335]             {
[16:14:29.335]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:29.335]                   0L) {
[16:14:29.335]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:29.335]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:29.335]                   base::options(opts)
[16:14:29.335]                 }
[16:14:29.335]                 {
[16:14:29.335]                   {
[16:14:29.335]                     base::options(mc.cores = ...future.mc.cores.old)
[16:14:29.335]                     NULL
[16:14:29.335]                   }
[16:14:29.335]                   options(future.plan = NULL)
[16:14:29.335]                   if (is.na(NA_character_)) 
[16:14:29.335]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:29.335]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:29.335]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:14:29.335]                     envir = parent.frame()) 
[16:14:29.335]                   {
[16:14:29.335]                     default_workers <- missing(workers)
[16:14:29.335]                     if (is.function(workers)) 
[16:14:29.335]                       workers <- workers()
[16:14:29.335]                     workers <- structure(as.integer(workers), 
[16:14:29.335]                       class = class(workers))
[16:14:29.335]                     stop_if_not(is.finite(workers), workers >= 
[16:14:29.335]                       1L)
[16:14:29.335]                     if ((workers == 1L && !inherits(workers, 
[16:14:29.335]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:14:29.335]                       if (default_workers) 
[16:14:29.335]                         supportsMulticore(warn = TRUE)
[16:14:29.335]                       return(sequential(..., envir = envir))
[16:14:29.335]                     }
[16:14:29.335]                     oopts <- options(mc.cores = workers)
[16:14:29.335]                     on.exit(options(oopts))
[16:14:29.335]                     future <- MulticoreFuture(..., workers = workers, 
[16:14:29.335]                       envir = envir)
[16:14:29.335]                     if (!future$lazy) 
[16:14:29.335]                       future <- run(future)
[16:14:29.335]                     invisible(future)
[16:14:29.335]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:29.335]                 }
[16:14:29.335]             }
[16:14:29.335]         }
[16:14:29.335]     })
[16:14:29.335]     if (FALSE) {
[16:14:29.335]         base::sink(type = "output", split = FALSE)
[16:14:29.335]         if (NA) {
[16:14:29.335]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:29.335]         }
[16:14:29.335]         else {
[16:14:29.335]             ...future.result["stdout"] <- base::list(NULL)
[16:14:29.335]         }
[16:14:29.335]         base::close(...future.stdout)
[16:14:29.335]         ...future.stdout <- NULL
[16:14:29.335]     }
[16:14:29.335]     ...future.result$conditions <- ...future.conditions
[16:14:29.335]     ...future.result$finished <- base::Sys.time()
[16:14:29.335]     ...future.result
[16:14:29.335] }
[16:14:29.338] requestCore(): workers = 2
[16:14:29.339] MulticoreFuture started
[16:14:29.340] - Launch lazy future ... done
[16:14:29.340] run() for ‘MulticoreFuture’ ... done
[16:14:29.341] plan(): Setting new future strategy stack:
[16:14:29.341] List of future strategies:
[16:14:29.341] 1. sequential:
[16:14:29.341]    - args: function (..., envir = parent.frame())
[16:14:29.341]    - tweaked: FALSE
[16:14:29.341]    - call: NULL
[16:14:29.342] plan(): nbrOfWorkers() = 1
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
[16:14:29.346] plan(): Setting new future strategy stack:
[16:14:29.346] List of future strategies:
[16:14:29.346] 1. multicore:
[16:14:29.346]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:14:29.346]    - tweaked: FALSE
[16:14:29.346]    - call: plan(strategy)
[16:14:29.351] plan(): nbrOfWorkers() = 2
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-01-06 16:14:29"
 $ finished    : POSIXct[1:1], format: "2025-01-06 16:14:29"
 $ session_uuid: chr "35199a69-f898-2d65-d555-d7aecf464e50"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "2729ef2608da"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "2729ef2608da" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 92362
  .. ..$ time  : POSIXct[1:1], format: "2025-01-06 16:14:29"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 3 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[16:14:29.361] getGlobalsAndPackages() ...
[16:14:29.361] Searching for globals...
[16:14:29.367] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[16:14:29.367] Searching for globals ... DONE
[16:14:29.367] Resolving globals: FALSE
[16:14:29.368] 
[16:14:29.368] - packages: [1] ‘utils’
[16:14:29.368] getGlobalsAndPackages() ... DONE
[16:14:29.369] run() for ‘Future’ ...
[16:14:29.369] - state: ‘created’
[16:14:29.369] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:14:29.373] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:14:29.374] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:14:29.374]   - Field: ‘label’
[16:14:29.374]   - Field: ‘local’
[16:14:29.374]   - Field: ‘owner’
[16:14:29.374]   - Field: ‘envir’
[16:14:29.374]   - Field: ‘workers’
[16:14:29.374]   - Field: ‘packages’
[16:14:29.375]   - Field: ‘gc’
[16:14:29.375]   - Field: ‘job’
[16:14:29.375]   - Field: ‘conditions’
[16:14:29.375]   - Field: ‘expr’
[16:14:29.375]   - Field: ‘uuid’
[16:14:29.375]   - Field: ‘seed’
[16:14:29.375]   - Field: ‘version’
[16:14:29.375]   - Field: ‘result’
[16:14:29.375]   - Field: ‘asynchronous’
[16:14:29.376]   - Field: ‘calls’
[16:14:29.376]   - Field: ‘globals’
[16:14:29.376]   - Field: ‘stdout’
[16:14:29.376]   - Field: ‘earlySignal’
[16:14:29.376]   - Field: ‘lazy’
[16:14:29.376]   - Field: ‘state’
[16:14:29.376] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:14:29.376] - Launch lazy future ...
[16:14:29.377] Packages needed by the future expression (n = 1): ‘utils’
[16:14:29.377] Packages needed by future strategies (n = 0): <none>
[16:14:29.378] {
[16:14:29.378]     {
[16:14:29.378]         {
[16:14:29.378]             ...future.startTime <- base::Sys.time()
[16:14:29.378]             {
[16:14:29.378]                 {
[16:14:29.378]                   {
[16:14:29.378]                     {
[16:14:29.378]                       {
[16:14:29.378]                         base::local({
[16:14:29.378]                           has_future <- base::requireNamespace("future", 
[16:14:29.378]                             quietly = TRUE)
[16:14:29.378]                           if (has_future) {
[16:14:29.378]                             ns <- base::getNamespace("future")
[16:14:29.378]                             version <- ns[[".package"]][["version"]]
[16:14:29.378]                             if (is.null(version)) 
[16:14:29.378]                               version <- utils::packageVersion("future")
[16:14:29.378]                           }
[16:14:29.378]                           else {
[16:14:29.378]                             version <- NULL
[16:14:29.378]                           }
[16:14:29.378]                           if (!has_future || version < "1.8.0") {
[16:14:29.378]                             info <- base::c(r_version = base::gsub("R version ", 
[16:14:29.378]                               "", base::R.version$version.string), 
[16:14:29.378]                               platform = base::sprintf("%s (%s-bit)", 
[16:14:29.378]                                 base::R.version$platform, 8 * 
[16:14:29.378]                                   base::.Machine$sizeof.pointer), 
[16:14:29.378]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:29.378]                                 "release", "version")], collapse = " "), 
[16:14:29.378]                               hostname = base::Sys.info()[["nodename"]])
[16:14:29.378]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:14:29.378]                               info)
[16:14:29.378]                             info <- base::paste(info, collapse = "; ")
[16:14:29.378]                             if (!has_future) {
[16:14:29.378]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:29.378]                                 info)
[16:14:29.378]                             }
[16:14:29.378]                             else {
[16:14:29.378]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:29.378]                                 info, version)
[16:14:29.378]                             }
[16:14:29.378]                             base::stop(msg)
[16:14:29.378]                           }
[16:14:29.378]                         })
[16:14:29.378]                       }
[16:14:29.378]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:14:29.378]                       base::options(mc.cores = 1L)
[16:14:29.378]                     }
[16:14:29.378]                     base::local({
[16:14:29.378]                       for (pkg in "utils") {
[16:14:29.378]                         base::loadNamespace(pkg)
[16:14:29.378]                         base::library(pkg, character.only = TRUE)
[16:14:29.378]                       }
[16:14:29.378]                     })
[16:14:29.378]                   }
[16:14:29.378]                   options(future.plan = NULL)
[16:14:29.378]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:29.378]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:29.378]                 }
[16:14:29.378]                 ...future.workdir <- getwd()
[16:14:29.378]             }
[16:14:29.378]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:29.378]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:29.378]         }
[16:14:29.378]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:29.378]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:29.378]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:29.378]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:29.378]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:29.378]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:29.378]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:29.378]             base::names(...future.oldOptions))
[16:14:29.378]     }
[16:14:29.378]     if (TRUE) {
[16:14:29.378]     }
[16:14:29.378]     else {
[16:14:29.378]         if (NA) {
[16:14:29.378]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:29.378]                 open = "w")
[16:14:29.378]         }
[16:14:29.378]         else {
[16:14:29.378]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:29.378]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:29.378]         }
[16:14:29.378]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:29.378]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:29.378]             base::sink(type = "output", split = FALSE)
[16:14:29.378]             base::close(...future.stdout)
[16:14:29.378]         }, add = TRUE)
[16:14:29.378]     }
[16:14:29.378]     ...future.frame <- base::sys.nframe()
[16:14:29.378]     ...future.conditions <- base::list()
[16:14:29.378]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:29.378]     if (FALSE) {
[16:14:29.378]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:29.378]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:29.378]     }
[16:14:29.378]     ...future.result <- base::tryCatch({
[16:14:29.378]         base::withCallingHandlers({
[16:14:29.378]             ...future.value <- base::withVisible(base::local({
[16:14:29.378]                 withCallingHandlers({
[16:14:29.378]                   {
[16:14:29.378]                     print(1:50)
[16:14:29.378]                     str(1:50)
[16:14:29.378]                     cat(letters, sep = "-")
[16:14:29.378]                     cat(1:6, collapse = "\n")
[16:14:29.378]                     write.table(datasets::iris[1:10, ], sep = "\t")
[16:14:29.378]                     42L
[16:14:29.378]                   }
[16:14:29.378]                 }, immediateCondition = function(cond) {
[16:14:29.378]                   save_rds <- function (object, pathname, ...) 
[16:14:29.378]                   {
[16:14:29.378]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:14:29.378]                     if (file_test("-f", pathname_tmp)) {
[16:14:29.378]                       fi_tmp <- file.info(pathname_tmp)
[16:14:29.378]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:14:29.378]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:14:29.378]                         fi_tmp[["mtime"]])
[16:14:29.378]                     }
[16:14:29.378]                     tryCatch({
[16:14:29.378]                       saveRDS(object, file = pathname_tmp, ...)
[16:14:29.378]                     }, error = function(ex) {
[16:14:29.378]                       msg <- conditionMessage(ex)
[16:14:29.378]                       fi_tmp <- file.info(pathname_tmp)
[16:14:29.378]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:14:29.378]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:14:29.378]                         fi_tmp[["mtime"]], msg)
[16:14:29.378]                       ex$message <- msg
[16:14:29.378]                       stop(ex)
[16:14:29.378]                     })
[16:14:29.378]                     stopifnot(file_test("-f", pathname_tmp))
[16:14:29.378]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:14:29.378]                     if (!res || file_test("-f", pathname_tmp)) {
[16:14:29.378]                       fi_tmp <- file.info(pathname_tmp)
[16:14:29.378]                       fi <- file.info(pathname)
[16:14:29.378]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:14:29.378]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:14:29.378]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:14:29.378]                         fi[["size"]], fi[["mtime"]])
[16:14:29.378]                       stop(msg)
[16:14:29.378]                     }
[16:14:29.378]                     invisible(pathname)
[16:14:29.378]                   }
[16:14:29.378]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:14:29.378]                     rootPath = tempdir()) 
[16:14:29.378]                   {
[16:14:29.378]                     obj <- list(time = Sys.time(), condition = cond)
[16:14:29.378]                     file <- tempfile(pattern = class(cond)[1], 
[16:14:29.378]                       tmpdir = path, fileext = ".rds")
[16:14:29.378]                     save_rds(obj, file)
[16:14:29.378]                   }
[16:14:29.378]                   saveImmediateCondition(cond, path = "/tmp/RtmpEpin5U/.future/immediateConditions")
[16:14:29.378]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.378]                   {
[16:14:29.378]                     inherits <- base::inherits
[16:14:29.378]                     invokeRestart <- base::invokeRestart
[16:14:29.378]                     is.null <- base::is.null
[16:14:29.378]                     muffled <- FALSE
[16:14:29.378]                     if (inherits(cond, "message")) {
[16:14:29.378]                       muffled <- grepl(pattern, "muffleMessage")
[16:14:29.378]                       if (muffled) 
[16:14:29.378]                         invokeRestart("muffleMessage")
[16:14:29.378]                     }
[16:14:29.378]                     else if (inherits(cond, "warning")) {
[16:14:29.378]                       muffled <- grepl(pattern, "muffleWarning")
[16:14:29.378]                       if (muffled) 
[16:14:29.378]                         invokeRestart("muffleWarning")
[16:14:29.378]                     }
[16:14:29.378]                     else if (inherits(cond, "condition")) {
[16:14:29.378]                       if (!is.null(pattern)) {
[16:14:29.378]                         computeRestarts <- base::computeRestarts
[16:14:29.378]                         grepl <- base::grepl
[16:14:29.378]                         restarts <- computeRestarts(cond)
[16:14:29.378]                         for (restart in restarts) {
[16:14:29.378]                           name <- restart$name
[16:14:29.378]                           if (is.null(name)) 
[16:14:29.378]                             next
[16:14:29.378]                           if (!grepl(pattern, name)) 
[16:14:29.378]                             next
[16:14:29.378]                           invokeRestart(restart)
[16:14:29.378]                           muffled <- TRUE
[16:14:29.378]                           break
[16:14:29.378]                         }
[16:14:29.378]                       }
[16:14:29.378]                     }
[16:14:29.378]                     invisible(muffled)
[16:14:29.378]                   }
[16:14:29.378]                   muffleCondition(cond)
[16:14:29.378]                 })
[16:14:29.378]             }))
[16:14:29.378]             future::FutureResult(value = ...future.value$value, 
[16:14:29.378]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:29.378]                   ...future.rng), globalenv = if (FALSE) 
[16:14:29.378]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:29.378]                     ...future.globalenv.names))
[16:14:29.378]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:29.378]         }, condition = base::local({
[16:14:29.378]             c <- base::c
[16:14:29.378]             inherits <- base::inherits
[16:14:29.378]             invokeRestart <- base::invokeRestart
[16:14:29.378]             length <- base::length
[16:14:29.378]             list <- base::list
[16:14:29.378]             seq.int <- base::seq.int
[16:14:29.378]             signalCondition <- base::signalCondition
[16:14:29.378]             sys.calls <- base::sys.calls
[16:14:29.378]             `[[` <- base::`[[`
[16:14:29.378]             `+` <- base::`+`
[16:14:29.378]             `<<-` <- base::`<<-`
[16:14:29.378]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:29.378]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:29.378]                   3L)]
[16:14:29.378]             }
[16:14:29.378]             function(cond) {
[16:14:29.378]                 is_error <- inherits(cond, "error")
[16:14:29.378]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:29.378]                   NULL)
[16:14:29.378]                 if (is_error) {
[16:14:29.378]                   sessionInformation <- function() {
[16:14:29.378]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:29.378]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:29.378]                       search = base::search(), system = base::Sys.info())
[16:14:29.378]                   }
[16:14:29.378]                   ...future.conditions[[length(...future.conditions) + 
[16:14:29.378]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:29.378]                     cond$call), session = sessionInformation(), 
[16:14:29.378]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:29.378]                   signalCondition(cond)
[16:14:29.378]                 }
[16:14:29.378]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:29.378]                 "immediateCondition"))) {
[16:14:29.378]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:29.378]                   ...future.conditions[[length(...future.conditions) + 
[16:14:29.378]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:29.378]                   if (TRUE && !signal) {
[16:14:29.378]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.378]                     {
[16:14:29.378]                       inherits <- base::inherits
[16:14:29.378]                       invokeRestart <- base::invokeRestart
[16:14:29.378]                       is.null <- base::is.null
[16:14:29.378]                       muffled <- FALSE
[16:14:29.378]                       if (inherits(cond, "message")) {
[16:14:29.378]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:29.378]                         if (muffled) 
[16:14:29.378]                           invokeRestart("muffleMessage")
[16:14:29.378]                       }
[16:14:29.378]                       else if (inherits(cond, "warning")) {
[16:14:29.378]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:29.378]                         if (muffled) 
[16:14:29.378]                           invokeRestart("muffleWarning")
[16:14:29.378]                       }
[16:14:29.378]                       else if (inherits(cond, "condition")) {
[16:14:29.378]                         if (!is.null(pattern)) {
[16:14:29.378]                           computeRestarts <- base::computeRestarts
[16:14:29.378]                           grepl <- base::grepl
[16:14:29.378]                           restarts <- computeRestarts(cond)
[16:14:29.378]                           for (restart in restarts) {
[16:14:29.378]                             name <- restart$name
[16:14:29.378]                             if (is.null(name)) 
[16:14:29.378]                               next
[16:14:29.378]                             if (!grepl(pattern, name)) 
[16:14:29.378]                               next
[16:14:29.378]                             invokeRestart(restart)
[16:14:29.378]                             muffled <- TRUE
[16:14:29.378]                             break
[16:14:29.378]                           }
[16:14:29.378]                         }
[16:14:29.378]                       }
[16:14:29.378]                       invisible(muffled)
[16:14:29.378]                     }
[16:14:29.378]                     muffleCondition(cond, pattern = "^muffle")
[16:14:29.378]                   }
[16:14:29.378]                 }
[16:14:29.378]                 else {
[16:14:29.378]                   if (TRUE) {
[16:14:29.378]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.378]                     {
[16:14:29.378]                       inherits <- base::inherits
[16:14:29.378]                       invokeRestart <- base::invokeRestart
[16:14:29.378]                       is.null <- base::is.null
[16:14:29.378]                       muffled <- FALSE
[16:14:29.378]                       if (inherits(cond, "message")) {
[16:14:29.378]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:29.378]                         if (muffled) 
[16:14:29.378]                           invokeRestart("muffleMessage")
[16:14:29.378]                       }
[16:14:29.378]                       else if (inherits(cond, "warning")) {
[16:14:29.378]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:29.378]                         if (muffled) 
[16:14:29.378]                           invokeRestart("muffleWarning")
[16:14:29.378]                       }
[16:14:29.378]                       else if (inherits(cond, "condition")) {
[16:14:29.378]                         if (!is.null(pattern)) {
[16:14:29.378]                           computeRestarts <- base::computeRestarts
[16:14:29.378]                           grepl <- base::grepl
[16:14:29.378]                           restarts <- computeRestarts(cond)
[16:14:29.378]                           for (restart in restarts) {
[16:14:29.378]                             name <- restart$name
[16:14:29.378]                             if (is.null(name)) 
[16:14:29.378]                               next
[16:14:29.378]                             if (!grepl(pattern, name)) 
[16:14:29.378]                               next
[16:14:29.378]                             invokeRestart(restart)
[16:14:29.378]                             muffled <- TRUE
[16:14:29.378]                             break
[16:14:29.378]                           }
[16:14:29.378]                         }
[16:14:29.378]                       }
[16:14:29.378]                       invisible(muffled)
[16:14:29.378]                     }
[16:14:29.378]                     muffleCondition(cond, pattern = "^muffle")
[16:14:29.378]                   }
[16:14:29.378]                 }
[16:14:29.378]             }
[16:14:29.378]         }))
[16:14:29.378]     }, error = function(ex) {
[16:14:29.378]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:29.378]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:29.378]                 ...future.rng), started = ...future.startTime, 
[16:14:29.378]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:29.378]             version = "1.8"), class = "FutureResult")
[16:14:29.378]     }, finally = {
[16:14:29.378]         if (!identical(...future.workdir, getwd())) 
[16:14:29.378]             setwd(...future.workdir)
[16:14:29.378]         {
[16:14:29.378]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:29.378]                 ...future.oldOptions$nwarnings <- NULL
[16:14:29.378]             }
[16:14:29.378]             base::options(...future.oldOptions)
[16:14:29.378]             if (.Platform$OS.type == "windows") {
[16:14:29.378]                 old_names <- names(...future.oldEnvVars)
[16:14:29.378]                 envs <- base::Sys.getenv()
[16:14:29.378]                 names <- names(envs)
[16:14:29.378]                 common <- intersect(names, old_names)
[16:14:29.378]                 added <- setdiff(names, old_names)
[16:14:29.378]                 removed <- setdiff(old_names, names)
[16:14:29.378]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:29.378]                   envs[common]]
[16:14:29.378]                 NAMES <- toupper(changed)
[16:14:29.378]                 args <- list()
[16:14:29.378]                 for (kk in seq_along(NAMES)) {
[16:14:29.378]                   name <- changed[[kk]]
[16:14:29.378]                   NAME <- NAMES[[kk]]
[16:14:29.378]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.378]                     next
[16:14:29.378]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:29.378]                 }
[16:14:29.378]                 NAMES <- toupper(added)
[16:14:29.378]                 for (kk in seq_along(NAMES)) {
[16:14:29.378]                   name <- added[[kk]]
[16:14:29.378]                   NAME <- NAMES[[kk]]
[16:14:29.378]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.378]                     next
[16:14:29.378]                   args[[name]] <- ""
[16:14:29.378]                 }
[16:14:29.378]                 NAMES <- toupper(removed)
[16:14:29.378]                 for (kk in seq_along(NAMES)) {
[16:14:29.378]                   name <- removed[[kk]]
[16:14:29.378]                   NAME <- NAMES[[kk]]
[16:14:29.378]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.378]                     next
[16:14:29.378]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:29.378]                 }
[16:14:29.378]                 if (length(args) > 0) 
[16:14:29.378]                   base::do.call(base::Sys.setenv, args = args)
[16:14:29.378]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:29.378]             }
[16:14:29.378]             else {
[16:14:29.378]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:29.378]             }
[16:14:29.378]             {
[16:14:29.378]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:29.378]                   0L) {
[16:14:29.378]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:29.378]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:29.378]                   base::options(opts)
[16:14:29.378]                 }
[16:14:29.378]                 {
[16:14:29.378]                   {
[16:14:29.378]                     base::options(mc.cores = ...future.mc.cores.old)
[16:14:29.378]                     NULL
[16:14:29.378]                   }
[16:14:29.378]                   options(future.plan = NULL)
[16:14:29.378]                   if (is.na(NA_character_)) 
[16:14:29.378]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:29.378]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:29.378]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:14:29.378]                     envir = parent.frame()) 
[16:14:29.378]                   {
[16:14:29.378]                     default_workers <- missing(workers)
[16:14:29.378]                     if (is.function(workers)) 
[16:14:29.378]                       workers <- workers()
[16:14:29.378]                     workers <- structure(as.integer(workers), 
[16:14:29.378]                       class = class(workers))
[16:14:29.378]                     stop_if_not(is.finite(workers), workers >= 
[16:14:29.378]                       1L)
[16:14:29.378]                     if ((workers == 1L && !inherits(workers, 
[16:14:29.378]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:14:29.378]                       if (default_workers) 
[16:14:29.378]                         supportsMulticore(warn = TRUE)
[16:14:29.378]                       return(sequential(..., envir = envir))
[16:14:29.378]                     }
[16:14:29.378]                     oopts <- options(mc.cores = workers)
[16:14:29.378]                     on.exit(options(oopts))
[16:14:29.378]                     future <- MulticoreFuture(..., workers = workers, 
[16:14:29.378]                       envir = envir)
[16:14:29.378]                     if (!future$lazy) 
[16:14:29.378]                       future <- run(future)
[16:14:29.378]                     invisible(future)
[16:14:29.378]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:29.378]                 }
[16:14:29.378]             }
[16:14:29.378]         }
[16:14:29.378]     })
[16:14:29.378]     if (FALSE) {
[16:14:29.378]         base::sink(type = "output", split = FALSE)
[16:14:29.378]         if (NA) {
[16:14:29.378]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:29.378]         }
[16:14:29.378]         else {
[16:14:29.378]             ...future.result["stdout"] <- base::list(NULL)
[16:14:29.378]         }
[16:14:29.378]         base::close(...future.stdout)
[16:14:29.378]         ...future.stdout <- NULL
[16:14:29.378]     }
[16:14:29.378]     ...future.result$conditions <- ...future.conditions
[16:14:29.378]     ...future.result$finished <- base::Sys.time()
[16:14:29.378]     ...future.result
[16:14:29.378] }
[16:14:29.380] requestCore(): workers = 2
[16:14:29.382] MulticoreFuture started
[16:14:29.382] - Launch lazy future ... done
[16:14:29.382] run() for ‘MulticoreFuture’ ... done
[16:14:29.383] plan(): Setting new future strategy stack:
[16:14:29.384] List of future strategies:
[16:14:29.384] 1. sequential:
[16:14:29.384]    - args: function (..., envir = parent.frame())
[16:14:29.384]    - tweaked: FALSE
[16:14:29.384]    - call: NULL
[16:14:29.384] plan(): nbrOfWorkers() = 1
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
[16:14:29.388] plan(): Setting new future strategy stack:
[16:14:29.388] List of future strategies:
[16:14:29.388] 1. multicore:
[16:14:29.388]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:14:29.388]    - tweaked: FALSE
[16:14:29.388]    - call: plan(strategy)
[16:14:29.393] plan(): nbrOfWorkers() = 2
- stdout = structure(TRUE, drop = TRUE)
[16:14:29.394] getGlobalsAndPackages() ...
[16:14:29.394] Searching for globals...
[16:14:29.395] - globals found: [1] ‘print’
[16:14:29.395] Searching for globals ... DONE
[16:14:29.395] Resolving globals: FALSE
[16:14:29.396] 
[16:14:29.396] 
[16:14:29.396] getGlobalsAndPackages() ... DONE
[16:14:29.396] run() for ‘Future’ ...
[16:14:29.396] - state: ‘created’
[16:14:29.396] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:14:29.400] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:14:29.401] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:14:29.401]   - Field: ‘label’
[16:14:29.401]   - Field: ‘local’
[16:14:29.401]   - Field: ‘owner’
[16:14:29.401]   - Field: ‘envir’
[16:14:29.401]   - Field: ‘workers’
[16:14:29.401]   - Field: ‘packages’
[16:14:29.401]   - Field: ‘gc’
[16:14:29.402]   - Field: ‘job’
[16:14:29.402]   - Field: ‘conditions’
[16:14:29.402]   - Field: ‘expr’
[16:14:29.402]   - Field: ‘uuid’
[16:14:29.402]   - Field: ‘seed’
[16:14:29.402]   - Field: ‘version’
[16:14:29.402]   - Field: ‘result’
[16:14:29.402]   - Field: ‘asynchronous’
[16:14:29.402]   - Field: ‘calls’
[16:14:29.403]   - Field: ‘globals’
[16:14:29.403]   - Field: ‘stdout’
[16:14:29.403]   - Field: ‘earlySignal’
[16:14:29.403]   - Field: ‘lazy’
[16:14:29.403]   - Field: ‘state’
[16:14:29.403] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:14:29.403] - Launch lazy future ...
[16:14:29.404] Packages needed by the future expression (n = 0): <none>
[16:14:29.404] Packages needed by future strategies (n = 0): <none>
[16:14:29.404] {
[16:14:29.404]     {
[16:14:29.404]         {
[16:14:29.404]             ...future.startTime <- base::Sys.time()
[16:14:29.404]             {
[16:14:29.404]                 {
[16:14:29.404]                   {
[16:14:29.404]                     {
[16:14:29.404]                       base::local({
[16:14:29.404]                         has_future <- base::requireNamespace("future", 
[16:14:29.404]                           quietly = TRUE)
[16:14:29.404]                         if (has_future) {
[16:14:29.404]                           ns <- base::getNamespace("future")
[16:14:29.404]                           version <- ns[[".package"]][["version"]]
[16:14:29.404]                           if (is.null(version)) 
[16:14:29.404]                             version <- utils::packageVersion("future")
[16:14:29.404]                         }
[16:14:29.404]                         else {
[16:14:29.404]                           version <- NULL
[16:14:29.404]                         }
[16:14:29.404]                         if (!has_future || version < "1.8.0") {
[16:14:29.404]                           info <- base::c(r_version = base::gsub("R version ", 
[16:14:29.404]                             "", base::R.version$version.string), 
[16:14:29.404]                             platform = base::sprintf("%s (%s-bit)", 
[16:14:29.404]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:14:29.404]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:29.404]                               "release", "version")], collapse = " "), 
[16:14:29.404]                             hostname = base::Sys.info()[["nodename"]])
[16:14:29.404]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:14:29.404]                             info)
[16:14:29.404]                           info <- base::paste(info, collapse = "; ")
[16:14:29.404]                           if (!has_future) {
[16:14:29.404]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:29.404]                               info)
[16:14:29.404]                           }
[16:14:29.404]                           else {
[16:14:29.404]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:29.404]                               info, version)
[16:14:29.404]                           }
[16:14:29.404]                           base::stop(msg)
[16:14:29.404]                         }
[16:14:29.404]                       })
[16:14:29.404]                     }
[16:14:29.404]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:14:29.404]                     base::options(mc.cores = 1L)
[16:14:29.404]                   }
[16:14:29.404]                   options(future.plan = NULL)
[16:14:29.404]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:29.404]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:29.404]                 }
[16:14:29.404]                 ...future.workdir <- getwd()
[16:14:29.404]             }
[16:14:29.404]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:29.404]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:29.404]         }
[16:14:29.404]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:29.404]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:29.404]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:29.404]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:29.404]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:29.404]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:29.404]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:29.404]             base::names(...future.oldOptions))
[16:14:29.404]     }
[16:14:29.404]     if (FALSE) {
[16:14:29.404]     }
[16:14:29.404]     else {
[16:14:29.404]         if (TRUE) {
[16:14:29.404]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:29.404]                 open = "w")
[16:14:29.404]         }
[16:14:29.404]         else {
[16:14:29.404]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:29.404]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:29.404]         }
[16:14:29.404]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:29.404]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:29.404]             base::sink(type = "output", split = FALSE)
[16:14:29.404]             base::close(...future.stdout)
[16:14:29.404]         }, add = TRUE)
[16:14:29.404]     }
[16:14:29.404]     ...future.frame <- base::sys.nframe()
[16:14:29.404]     ...future.conditions <- base::list()
[16:14:29.404]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:29.404]     if (FALSE) {
[16:14:29.404]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:29.404]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:29.404]     }
[16:14:29.404]     ...future.result <- base::tryCatch({
[16:14:29.404]         base::withCallingHandlers({
[16:14:29.404]             ...future.value <- base::withVisible(base::local({
[16:14:29.404]                 withCallingHandlers({
[16:14:29.404]                   print(42)
[16:14:29.404]                 }, immediateCondition = function(cond) {
[16:14:29.404]                   save_rds <- function (object, pathname, ...) 
[16:14:29.404]                   {
[16:14:29.404]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:14:29.404]                     if (file_test("-f", pathname_tmp)) {
[16:14:29.404]                       fi_tmp <- file.info(pathname_tmp)
[16:14:29.404]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:14:29.404]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:14:29.404]                         fi_tmp[["mtime"]])
[16:14:29.404]                     }
[16:14:29.404]                     tryCatch({
[16:14:29.404]                       saveRDS(object, file = pathname_tmp, ...)
[16:14:29.404]                     }, error = function(ex) {
[16:14:29.404]                       msg <- conditionMessage(ex)
[16:14:29.404]                       fi_tmp <- file.info(pathname_tmp)
[16:14:29.404]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:14:29.404]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:14:29.404]                         fi_tmp[["mtime"]], msg)
[16:14:29.404]                       ex$message <- msg
[16:14:29.404]                       stop(ex)
[16:14:29.404]                     })
[16:14:29.404]                     stopifnot(file_test("-f", pathname_tmp))
[16:14:29.404]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:14:29.404]                     if (!res || file_test("-f", pathname_tmp)) {
[16:14:29.404]                       fi_tmp <- file.info(pathname_tmp)
[16:14:29.404]                       fi <- file.info(pathname)
[16:14:29.404]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:14:29.404]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:14:29.404]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:14:29.404]                         fi[["size"]], fi[["mtime"]])
[16:14:29.404]                       stop(msg)
[16:14:29.404]                     }
[16:14:29.404]                     invisible(pathname)
[16:14:29.404]                   }
[16:14:29.404]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:14:29.404]                     rootPath = tempdir()) 
[16:14:29.404]                   {
[16:14:29.404]                     obj <- list(time = Sys.time(), condition = cond)
[16:14:29.404]                     file <- tempfile(pattern = class(cond)[1], 
[16:14:29.404]                       tmpdir = path, fileext = ".rds")
[16:14:29.404]                     save_rds(obj, file)
[16:14:29.404]                   }
[16:14:29.404]                   saveImmediateCondition(cond, path = "/tmp/RtmpEpin5U/.future/immediateConditions")
[16:14:29.404]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.404]                   {
[16:14:29.404]                     inherits <- base::inherits
[16:14:29.404]                     invokeRestart <- base::invokeRestart
[16:14:29.404]                     is.null <- base::is.null
[16:14:29.404]                     muffled <- FALSE
[16:14:29.404]                     if (inherits(cond, "message")) {
[16:14:29.404]                       muffled <- grepl(pattern, "muffleMessage")
[16:14:29.404]                       if (muffled) 
[16:14:29.404]                         invokeRestart("muffleMessage")
[16:14:29.404]                     }
[16:14:29.404]                     else if (inherits(cond, "warning")) {
[16:14:29.404]                       muffled <- grepl(pattern, "muffleWarning")
[16:14:29.404]                       if (muffled) 
[16:14:29.404]                         invokeRestart("muffleWarning")
[16:14:29.404]                     }
[16:14:29.404]                     else if (inherits(cond, "condition")) {
[16:14:29.404]                       if (!is.null(pattern)) {
[16:14:29.404]                         computeRestarts <- base::computeRestarts
[16:14:29.404]                         grepl <- base::grepl
[16:14:29.404]                         restarts <- computeRestarts(cond)
[16:14:29.404]                         for (restart in restarts) {
[16:14:29.404]                           name <- restart$name
[16:14:29.404]                           if (is.null(name)) 
[16:14:29.404]                             next
[16:14:29.404]                           if (!grepl(pattern, name)) 
[16:14:29.404]                             next
[16:14:29.404]                           invokeRestart(restart)
[16:14:29.404]                           muffled <- TRUE
[16:14:29.404]                           break
[16:14:29.404]                         }
[16:14:29.404]                       }
[16:14:29.404]                     }
[16:14:29.404]                     invisible(muffled)
[16:14:29.404]                   }
[16:14:29.404]                   muffleCondition(cond)
[16:14:29.404]                 })
[16:14:29.404]             }))
[16:14:29.404]             future::FutureResult(value = ...future.value$value, 
[16:14:29.404]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:29.404]                   ...future.rng), globalenv = if (FALSE) 
[16:14:29.404]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:29.404]                     ...future.globalenv.names))
[16:14:29.404]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:29.404]         }, condition = base::local({
[16:14:29.404]             c <- base::c
[16:14:29.404]             inherits <- base::inherits
[16:14:29.404]             invokeRestart <- base::invokeRestart
[16:14:29.404]             length <- base::length
[16:14:29.404]             list <- base::list
[16:14:29.404]             seq.int <- base::seq.int
[16:14:29.404]             signalCondition <- base::signalCondition
[16:14:29.404]             sys.calls <- base::sys.calls
[16:14:29.404]             `[[` <- base::`[[`
[16:14:29.404]             `+` <- base::`+`
[16:14:29.404]             `<<-` <- base::`<<-`
[16:14:29.404]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:29.404]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:29.404]                   3L)]
[16:14:29.404]             }
[16:14:29.404]             function(cond) {
[16:14:29.404]                 is_error <- inherits(cond, "error")
[16:14:29.404]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:29.404]                   NULL)
[16:14:29.404]                 if (is_error) {
[16:14:29.404]                   sessionInformation <- function() {
[16:14:29.404]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:29.404]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:29.404]                       search = base::search(), system = base::Sys.info())
[16:14:29.404]                   }
[16:14:29.404]                   ...future.conditions[[length(...future.conditions) + 
[16:14:29.404]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:29.404]                     cond$call), session = sessionInformation(), 
[16:14:29.404]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:29.404]                   signalCondition(cond)
[16:14:29.404]                 }
[16:14:29.404]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:29.404]                 "immediateCondition"))) {
[16:14:29.404]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:29.404]                   ...future.conditions[[length(...future.conditions) + 
[16:14:29.404]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:29.404]                   if (TRUE && !signal) {
[16:14:29.404]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.404]                     {
[16:14:29.404]                       inherits <- base::inherits
[16:14:29.404]                       invokeRestart <- base::invokeRestart
[16:14:29.404]                       is.null <- base::is.null
[16:14:29.404]                       muffled <- FALSE
[16:14:29.404]                       if (inherits(cond, "message")) {
[16:14:29.404]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:29.404]                         if (muffled) 
[16:14:29.404]                           invokeRestart("muffleMessage")
[16:14:29.404]                       }
[16:14:29.404]                       else if (inherits(cond, "warning")) {
[16:14:29.404]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:29.404]                         if (muffled) 
[16:14:29.404]                           invokeRestart("muffleWarning")
[16:14:29.404]                       }
[16:14:29.404]                       else if (inherits(cond, "condition")) {
[16:14:29.404]                         if (!is.null(pattern)) {
[16:14:29.404]                           computeRestarts <- base::computeRestarts
[16:14:29.404]                           grepl <- base::grepl
[16:14:29.404]                           restarts <- computeRestarts(cond)
[16:14:29.404]                           for (restart in restarts) {
[16:14:29.404]                             name <- restart$name
[16:14:29.404]                             if (is.null(name)) 
[16:14:29.404]                               next
[16:14:29.404]                             if (!grepl(pattern, name)) 
[16:14:29.404]                               next
[16:14:29.404]                             invokeRestart(restart)
[16:14:29.404]                             muffled <- TRUE
[16:14:29.404]                             break
[16:14:29.404]                           }
[16:14:29.404]                         }
[16:14:29.404]                       }
[16:14:29.404]                       invisible(muffled)
[16:14:29.404]                     }
[16:14:29.404]                     muffleCondition(cond, pattern = "^muffle")
[16:14:29.404]                   }
[16:14:29.404]                 }
[16:14:29.404]                 else {
[16:14:29.404]                   if (TRUE) {
[16:14:29.404]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.404]                     {
[16:14:29.404]                       inherits <- base::inherits
[16:14:29.404]                       invokeRestart <- base::invokeRestart
[16:14:29.404]                       is.null <- base::is.null
[16:14:29.404]                       muffled <- FALSE
[16:14:29.404]                       if (inherits(cond, "message")) {
[16:14:29.404]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:29.404]                         if (muffled) 
[16:14:29.404]                           invokeRestart("muffleMessage")
[16:14:29.404]                       }
[16:14:29.404]                       else if (inherits(cond, "warning")) {
[16:14:29.404]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:29.404]                         if (muffled) 
[16:14:29.404]                           invokeRestart("muffleWarning")
[16:14:29.404]                       }
[16:14:29.404]                       else if (inherits(cond, "condition")) {
[16:14:29.404]                         if (!is.null(pattern)) {
[16:14:29.404]                           computeRestarts <- base::computeRestarts
[16:14:29.404]                           grepl <- base::grepl
[16:14:29.404]                           restarts <- computeRestarts(cond)
[16:14:29.404]                           for (restart in restarts) {
[16:14:29.404]                             name <- restart$name
[16:14:29.404]                             if (is.null(name)) 
[16:14:29.404]                               next
[16:14:29.404]                             if (!grepl(pattern, name)) 
[16:14:29.404]                               next
[16:14:29.404]                             invokeRestart(restart)
[16:14:29.404]                             muffled <- TRUE
[16:14:29.404]                             break
[16:14:29.404]                           }
[16:14:29.404]                         }
[16:14:29.404]                       }
[16:14:29.404]                       invisible(muffled)
[16:14:29.404]                     }
[16:14:29.404]                     muffleCondition(cond, pattern = "^muffle")
[16:14:29.404]                   }
[16:14:29.404]                 }
[16:14:29.404]             }
[16:14:29.404]         }))
[16:14:29.404]     }, error = function(ex) {
[16:14:29.404]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:29.404]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:29.404]                 ...future.rng), started = ...future.startTime, 
[16:14:29.404]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:29.404]             version = "1.8"), class = "FutureResult")
[16:14:29.404]     }, finally = {
[16:14:29.404]         if (!identical(...future.workdir, getwd())) 
[16:14:29.404]             setwd(...future.workdir)
[16:14:29.404]         {
[16:14:29.404]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:29.404]                 ...future.oldOptions$nwarnings <- NULL
[16:14:29.404]             }
[16:14:29.404]             base::options(...future.oldOptions)
[16:14:29.404]             if (.Platform$OS.type == "windows") {
[16:14:29.404]                 old_names <- names(...future.oldEnvVars)
[16:14:29.404]                 envs <- base::Sys.getenv()
[16:14:29.404]                 names <- names(envs)
[16:14:29.404]                 common <- intersect(names, old_names)
[16:14:29.404]                 added <- setdiff(names, old_names)
[16:14:29.404]                 removed <- setdiff(old_names, names)
[16:14:29.404]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:29.404]                   envs[common]]
[16:14:29.404]                 NAMES <- toupper(changed)
[16:14:29.404]                 args <- list()
[16:14:29.404]                 for (kk in seq_along(NAMES)) {
[16:14:29.404]                   name <- changed[[kk]]
[16:14:29.404]                   NAME <- NAMES[[kk]]
[16:14:29.404]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.404]                     next
[16:14:29.404]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:29.404]                 }
[16:14:29.404]                 NAMES <- toupper(added)
[16:14:29.404]                 for (kk in seq_along(NAMES)) {
[16:14:29.404]                   name <- added[[kk]]
[16:14:29.404]                   NAME <- NAMES[[kk]]
[16:14:29.404]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.404]                     next
[16:14:29.404]                   args[[name]] <- ""
[16:14:29.404]                 }
[16:14:29.404]                 NAMES <- toupper(removed)
[16:14:29.404]                 for (kk in seq_along(NAMES)) {
[16:14:29.404]                   name <- removed[[kk]]
[16:14:29.404]                   NAME <- NAMES[[kk]]
[16:14:29.404]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.404]                     next
[16:14:29.404]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:29.404]                 }
[16:14:29.404]                 if (length(args) > 0) 
[16:14:29.404]                   base::do.call(base::Sys.setenv, args = args)
[16:14:29.404]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:29.404]             }
[16:14:29.404]             else {
[16:14:29.404]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:29.404]             }
[16:14:29.404]             {
[16:14:29.404]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:29.404]                   0L) {
[16:14:29.404]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:29.404]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:29.404]                   base::options(opts)
[16:14:29.404]                 }
[16:14:29.404]                 {
[16:14:29.404]                   {
[16:14:29.404]                     base::options(mc.cores = ...future.mc.cores.old)
[16:14:29.404]                     NULL
[16:14:29.404]                   }
[16:14:29.404]                   options(future.plan = NULL)
[16:14:29.404]                   if (is.na(NA_character_)) 
[16:14:29.404]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:29.404]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:29.404]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:14:29.404]                     envir = parent.frame()) 
[16:14:29.404]                   {
[16:14:29.404]                     default_workers <- missing(workers)
[16:14:29.404]                     if (is.function(workers)) 
[16:14:29.404]                       workers <- workers()
[16:14:29.404]                     workers <- structure(as.integer(workers), 
[16:14:29.404]                       class = class(workers))
[16:14:29.404]                     stop_if_not(is.finite(workers), workers >= 
[16:14:29.404]                       1L)
[16:14:29.404]                     if ((workers == 1L && !inherits(workers, 
[16:14:29.404]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:14:29.404]                       if (default_workers) 
[16:14:29.404]                         supportsMulticore(warn = TRUE)
[16:14:29.404]                       return(sequential(..., envir = envir))
[16:14:29.404]                     }
[16:14:29.404]                     oopts <- options(mc.cores = workers)
[16:14:29.404]                     on.exit(options(oopts))
[16:14:29.404]                     future <- MulticoreFuture(..., workers = workers, 
[16:14:29.404]                       envir = envir)
[16:14:29.404]                     if (!future$lazy) 
[16:14:29.404]                       future <- run(future)
[16:14:29.404]                     invisible(future)
[16:14:29.404]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:29.404]                 }
[16:14:29.404]             }
[16:14:29.404]         }
[16:14:29.404]     })
[16:14:29.404]     if (TRUE) {
[16:14:29.404]         base::sink(type = "output", split = FALSE)
[16:14:29.404]         if (TRUE) {
[16:14:29.404]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:29.404]         }
[16:14:29.404]         else {
[16:14:29.404]             ...future.result["stdout"] <- base::list(NULL)
[16:14:29.404]         }
[16:14:29.404]         base::close(...future.stdout)
[16:14:29.404]         ...future.stdout <- NULL
[16:14:29.404]     }
[16:14:29.404]     ...future.result$conditions <- ...future.conditions
[16:14:29.404]     ...future.result$finished <- base::Sys.time()
[16:14:29.404]     ...future.result
[16:14:29.404] }
[16:14:29.407] requestCore(): workers = 2
[16:14:29.409] MulticoreFuture started
[16:14:29.409] - Launch lazy future ... done
[16:14:29.409] run() for ‘MulticoreFuture’ ... done
[16:14:29.410] plan(): Setting new future strategy stack:
[16:14:29.410] List of future strategies:
[16:14:29.410] 1. sequential:
[16:14:29.410]    - args: function (..., envir = parent.frame())
[16:14:29.410]    - tweaked: FALSE
[16:14:29.410]    - call: NULL
[16:14:29.411] plan(): nbrOfWorkers() = 1
[16:14:29.413] plan(): Setting new future strategy stack:
[16:14:29.413] List of future strategies:
[16:14:29.413] 1. multicore:
[16:14:29.413]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:14:29.413]    - tweaked: FALSE
[16:14:29.413]    - call: plan(strategy)
[16:14:29.418] plan(): nbrOfWorkers() = 2
[1] 42
multicore ... done
multisession ...
[16:14:29.419] plan(): Setting new future strategy stack:
[16:14:29.419] List of future strategies:
[16:14:29.419] 1. multisession:
[16:14:29.419]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:14:29.419]    - tweaked: FALSE
[16:14:29.419]    - call: plan(strategy)
[16:14:29.420] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:14:29.420] multisession:
[16:14:29.420] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:14:29.420] - tweaked: FALSE
[16:14:29.420] - call: plan(strategy)
[16:14:29.427] getGlobalsAndPackages() ...
[16:14:29.427] Not searching for globals
[16:14:29.427] - globals: [0] <none>
[16:14:29.427] getGlobalsAndPackages() ... DONE
[16:14:29.428] [local output] makeClusterPSOCK() ...
[16:14:29.466] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:14:29.472] [local output] Base port: 11074
[16:14:29.472] [local output] Getting setup options for 2 cluster nodes ...
[16:14:29.472] [local output]  - Node 1 of 2 ...
[16:14:29.472] [local output] localMachine=TRUE => revtunnel=FALSE

[16:14:29.473] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpEpin5U/worker.rank=1.parallelly.parent=92308.168941ebdfe4c.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpEpin5U/worker.rank=1.parallelly.parent=92308.168941ebdfe4c.pid")'’
[16:14:29.659] - Possible to infer worker's PID: TRUE
[16:14:29.660] [local output] Rscript port: 11074

[16:14:29.660] [local output]  - Node 2 of 2 ...
[16:14:29.661] [local output] localMachine=TRUE => revtunnel=FALSE

[16:14:29.661] [local output] Rscript port: 11074

[16:14:29.661] [local output] Getting setup options for 2 cluster nodes ... done
[16:14:29.662] [local output]  - Parallel setup requested for some PSOCK nodes
[16:14:29.662] [local output] Setting up PSOCK nodes in parallel
[16:14:29.662] List of 36
[16:14:29.662]  $ worker          : chr "localhost"
[16:14:29.662]   ..- attr(*, "localhost")= logi TRUE
[16:14:29.662]  $ master          : chr "localhost"
[16:14:29.662]  $ port            : int 11074
[16:14:29.662]  $ connectTimeout  : num 120
[16:14:29.662]  $ timeout         : num 2592000
[16:14:29.662]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:14:29.662]  $ homogeneous     : logi TRUE
[16:14:29.662]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:14:29.662]  $ rscript_envs    : NULL
[16:14:29.662]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:14:29.662]  $ rscript_startup : NULL
[16:14:29.662]  $ rscript_sh      : chr "sh"
[16:14:29.662]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:14:29.662]  $ methods         : logi TRUE
[16:14:29.662]  $ socketOptions   : chr "no-delay"
[16:14:29.662]  $ useXDR          : logi FALSE
[16:14:29.662]  $ outfile         : chr "/dev/null"
[16:14:29.662]  $ renice          : int NA
[16:14:29.662]  $ rshcmd          : NULL
[16:14:29.662]  $ user            : chr(0) 
[16:14:29.662]  $ revtunnel       : logi FALSE
[16:14:29.662]  $ rshlogfile      : NULL
[16:14:29.662]  $ rshopts         : chr(0) 
[16:14:29.662]  $ rank            : int 1
[16:14:29.662]  $ manual          : logi FALSE
[16:14:29.662]  $ dryrun          : logi FALSE
[16:14:29.662]  $ quiet           : logi FALSE
[16:14:29.662]  $ setup_strategy  : chr "parallel"
[16:14:29.662]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:14:29.662]  $ pidfile         : chr "/tmp/RtmpEpin5U/worker.rank=1.parallelly.parent=92308.168941ebdfe4c.pid"
[16:14:29.662]  $ rshcmd_label    : NULL
[16:14:29.662]  $ rsh_call        : NULL
[16:14:29.662]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:14:29.662]  $ localMachine    : logi TRUE
[16:14:29.662]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:14:29.662]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:14:29.662]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:14:29.662]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:14:29.662]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:14:29.662]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:14:29.662]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:14:29.662]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:14:29.662]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:14:29.662]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:14:29.662]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:14:29.662]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:14:29.662]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:14:29.662]  $ arguments       :List of 28
[16:14:29.662]   ..$ worker          : chr "localhost"
[16:14:29.662]   ..$ master          : NULL
[16:14:29.662]   ..$ port            : int 11074
[16:14:29.662]   ..$ connectTimeout  : num 120
[16:14:29.662]   ..$ timeout         : num 2592000
[16:14:29.662]   ..$ rscript         : NULL
[16:14:29.662]   ..$ homogeneous     : NULL
[16:14:29.662]   ..$ rscript_args    : NULL
[16:14:29.662]   ..$ rscript_envs    : NULL
[16:14:29.662]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:14:29.662]   ..$ rscript_startup : NULL
[16:14:29.662]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:14:29.662]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:14:29.662]   ..$ methods         : logi TRUE
[16:14:29.662]   ..$ socketOptions   : chr "no-delay"
[16:14:29.662]   ..$ useXDR          : logi FALSE
[16:14:29.662]   ..$ outfile         : chr "/dev/null"
[16:14:29.662]   ..$ renice          : int NA
[16:14:29.662]   ..$ rshcmd          : NULL
[16:14:29.662]   ..$ user            : NULL
[16:14:29.662]   ..$ revtunnel       : logi NA
[16:14:29.662]   ..$ rshlogfile      : NULL
[16:14:29.662]   ..$ rshopts         : NULL
[16:14:29.662]   ..$ rank            : int 1
[16:14:29.662]   ..$ manual          : logi FALSE
[16:14:29.662]   ..$ dryrun          : logi FALSE
[16:14:29.662]   ..$ quiet           : logi FALSE
[16:14:29.662]   ..$ setup_strategy  : chr "parallel"
[16:14:29.662]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:14:29.679] [local output] System call to launch all workers:
[16:14:29.679] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpEpin5U/worker.rank=1.parallelly.parent=92308.168941ebdfe4c.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11074 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:14:29.679] [local output] Starting PSOCK main server
[16:14:29.680] [local output] Workers launched
[16:14:29.681] [local output] Waiting for workers to connect back
[16:14:29.681]  - [local output] 0 workers out of 2 ready
[16:14:29.927]  - [local output] 0 workers out of 2 ready
[16:14:29.928]  - [local output] 1 workers out of 2 ready
[16:14:29.928]  - [local output] 2 workers out of 2 ready
[16:14:29.928] [local output] Launching of workers completed
[16:14:29.928] [local output] Collecting session information from workers
[16:14:29.929] [local output]  - Worker #1 of 2
[16:14:29.930] [local output]  - Worker #2 of 2
[16:14:29.930] [local output] makeClusterPSOCK() ... done
[16:14:29.942] Packages needed by the future expression (n = 0): <none>
[16:14:29.942] Packages needed by future strategies (n = 0): <none>
[16:14:29.942] {
[16:14:29.942]     {
[16:14:29.942]         {
[16:14:29.942]             ...future.startTime <- base::Sys.time()
[16:14:29.942]             {
[16:14:29.942]                 {
[16:14:29.942]                   {
[16:14:29.942]                     {
[16:14:29.942]                       base::local({
[16:14:29.942]                         has_future <- base::requireNamespace("future", 
[16:14:29.942]                           quietly = TRUE)
[16:14:29.942]                         if (has_future) {
[16:14:29.942]                           ns <- base::getNamespace("future")
[16:14:29.942]                           version <- ns[[".package"]][["version"]]
[16:14:29.942]                           if (is.null(version)) 
[16:14:29.942]                             version <- utils::packageVersion("future")
[16:14:29.942]                         }
[16:14:29.942]                         else {
[16:14:29.942]                           version <- NULL
[16:14:29.942]                         }
[16:14:29.942]                         if (!has_future || version < "1.8.0") {
[16:14:29.942]                           info <- base::c(r_version = base::gsub("R version ", 
[16:14:29.942]                             "", base::R.version$version.string), 
[16:14:29.942]                             platform = base::sprintf("%s (%s-bit)", 
[16:14:29.942]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:14:29.942]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:29.942]                               "release", "version")], collapse = " "), 
[16:14:29.942]                             hostname = base::Sys.info()[["nodename"]])
[16:14:29.942]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:14:29.942]                             info)
[16:14:29.942]                           info <- base::paste(info, collapse = "; ")
[16:14:29.942]                           if (!has_future) {
[16:14:29.942]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:29.942]                               info)
[16:14:29.942]                           }
[16:14:29.942]                           else {
[16:14:29.942]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:29.942]                               info, version)
[16:14:29.942]                           }
[16:14:29.942]                           base::stop(msg)
[16:14:29.942]                         }
[16:14:29.942]                       })
[16:14:29.942]                     }
[16:14:29.942]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:14:29.942]                     base::options(mc.cores = 1L)
[16:14:29.942]                   }
[16:14:29.942]                   options(future.plan = NULL)
[16:14:29.942]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:29.942]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:29.942]                 }
[16:14:29.942]                 ...future.workdir <- getwd()
[16:14:29.942]             }
[16:14:29.942]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:29.942]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:29.942]         }
[16:14:29.942]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:29.942]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:29.942]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:29.942]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:29.942]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:29.942]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:29.942]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:29.942]             base::names(...future.oldOptions))
[16:14:29.942]     }
[16:14:29.942]     if (FALSE) {
[16:14:29.942]     }
[16:14:29.942]     else {
[16:14:29.942]         if (TRUE) {
[16:14:29.942]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:29.942]                 open = "w")
[16:14:29.942]         }
[16:14:29.942]         else {
[16:14:29.942]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:29.942]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:29.942]         }
[16:14:29.942]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:29.942]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:29.942]             base::sink(type = "output", split = FALSE)
[16:14:29.942]             base::close(...future.stdout)
[16:14:29.942]         }, add = TRUE)
[16:14:29.942]     }
[16:14:29.942]     ...future.frame <- base::sys.nframe()
[16:14:29.942]     ...future.conditions <- base::list()
[16:14:29.942]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:29.942]     if (FALSE) {
[16:14:29.942]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:29.942]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:29.942]     }
[16:14:29.942]     ...future.result <- base::tryCatch({
[16:14:29.942]         base::withCallingHandlers({
[16:14:29.942]             ...future.value <- base::withVisible(base::local({
[16:14:29.942]                 ...future.makeSendCondition <- local({
[16:14:29.942]                   sendCondition <- NULL
[16:14:29.942]                   function(frame = 1L) {
[16:14:29.942]                     if (is.function(sendCondition)) 
[16:14:29.942]                       return(sendCondition)
[16:14:29.942]                     ns <- getNamespace("parallel")
[16:14:29.942]                     if (exists("sendData", mode = "function", 
[16:14:29.942]                       envir = ns)) {
[16:14:29.942]                       parallel_sendData <- get("sendData", mode = "function", 
[16:14:29.942]                         envir = ns)
[16:14:29.942]                       envir <- sys.frame(frame)
[16:14:29.942]                       master <- NULL
[16:14:29.942]                       while (!identical(envir, .GlobalEnv) && 
[16:14:29.942]                         !identical(envir, emptyenv())) {
[16:14:29.942]                         if (exists("master", mode = "list", envir = envir, 
[16:14:29.942]                           inherits = FALSE)) {
[16:14:29.942]                           master <- get("master", mode = "list", 
[16:14:29.942]                             envir = envir, inherits = FALSE)
[16:14:29.942]                           if (inherits(master, c("SOCKnode", 
[16:14:29.942]                             "SOCK0node"))) {
[16:14:29.942]                             sendCondition <<- function(cond) {
[16:14:29.942]                               data <- list(type = "VALUE", value = cond, 
[16:14:29.942]                                 success = TRUE)
[16:14:29.942]                               parallel_sendData(master, data)
[16:14:29.942]                             }
[16:14:29.942]                             return(sendCondition)
[16:14:29.942]                           }
[16:14:29.942]                         }
[16:14:29.942]                         frame <- frame + 1L
[16:14:29.942]                         envir <- sys.frame(frame)
[16:14:29.942]                       }
[16:14:29.942]                     }
[16:14:29.942]                     sendCondition <<- function(cond) NULL
[16:14:29.942]                   }
[16:14:29.942]                 })
[16:14:29.942]                 withCallingHandlers({
[16:14:29.942]                   NA
[16:14:29.942]                 }, immediateCondition = function(cond) {
[16:14:29.942]                   sendCondition <- ...future.makeSendCondition()
[16:14:29.942]                   sendCondition(cond)
[16:14:29.942]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.942]                   {
[16:14:29.942]                     inherits <- base::inherits
[16:14:29.942]                     invokeRestart <- base::invokeRestart
[16:14:29.942]                     is.null <- base::is.null
[16:14:29.942]                     muffled <- FALSE
[16:14:29.942]                     if (inherits(cond, "message")) {
[16:14:29.942]                       muffled <- grepl(pattern, "muffleMessage")
[16:14:29.942]                       if (muffled) 
[16:14:29.942]                         invokeRestart("muffleMessage")
[16:14:29.942]                     }
[16:14:29.942]                     else if (inherits(cond, "warning")) {
[16:14:29.942]                       muffled <- grepl(pattern, "muffleWarning")
[16:14:29.942]                       if (muffled) 
[16:14:29.942]                         invokeRestart("muffleWarning")
[16:14:29.942]                     }
[16:14:29.942]                     else if (inherits(cond, "condition")) {
[16:14:29.942]                       if (!is.null(pattern)) {
[16:14:29.942]                         computeRestarts <- base::computeRestarts
[16:14:29.942]                         grepl <- base::grepl
[16:14:29.942]                         restarts <- computeRestarts(cond)
[16:14:29.942]                         for (restart in restarts) {
[16:14:29.942]                           name <- restart$name
[16:14:29.942]                           if (is.null(name)) 
[16:14:29.942]                             next
[16:14:29.942]                           if (!grepl(pattern, name)) 
[16:14:29.942]                             next
[16:14:29.942]                           invokeRestart(restart)
[16:14:29.942]                           muffled <- TRUE
[16:14:29.942]                           break
[16:14:29.942]                         }
[16:14:29.942]                       }
[16:14:29.942]                     }
[16:14:29.942]                     invisible(muffled)
[16:14:29.942]                   }
[16:14:29.942]                   muffleCondition(cond)
[16:14:29.942]                 })
[16:14:29.942]             }))
[16:14:29.942]             future::FutureResult(value = ...future.value$value, 
[16:14:29.942]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:29.942]                   ...future.rng), globalenv = if (FALSE) 
[16:14:29.942]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:29.942]                     ...future.globalenv.names))
[16:14:29.942]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:29.942]         }, condition = base::local({
[16:14:29.942]             c <- base::c
[16:14:29.942]             inherits <- base::inherits
[16:14:29.942]             invokeRestart <- base::invokeRestart
[16:14:29.942]             length <- base::length
[16:14:29.942]             list <- base::list
[16:14:29.942]             seq.int <- base::seq.int
[16:14:29.942]             signalCondition <- base::signalCondition
[16:14:29.942]             sys.calls <- base::sys.calls
[16:14:29.942]             `[[` <- base::`[[`
[16:14:29.942]             `+` <- base::`+`
[16:14:29.942]             `<<-` <- base::`<<-`
[16:14:29.942]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:29.942]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:29.942]                   3L)]
[16:14:29.942]             }
[16:14:29.942]             function(cond) {
[16:14:29.942]                 is_error <- inherits(cond, "error")
[16:14:29.942]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:29.942]                   NULL)
[16:14:29.942]                 if (is_error) {
[16:14:29.942]                   sessionInformation <- function() {
[16:14:29.942]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:29.942]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:29.942]                       search = base::search(), system = base::Sys.info())
[16:14:29.942]                   }
[16:14:29.942]                   ...future.conditions[[length(...future.conditions) + 
[16:14:29.942]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:29.942]                     cond$call), session = sessionInformation(), 
[16:14:29.942]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:29.942]                   signalCondition(cond)
[16:14:29.942]                 }
[16:14:29.942]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:29.942]                 "immediateCondition"))) {
[16:14:29.942]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:29.942]                   ...future.conditions[[length(...future.conditions) + 
[16:14:29.942]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:29.942]                   if (TRUE && !signal) {
[16:14:29.942]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.942]                     {
[16:14:29.942]                       inherits <- base::inherits
[16:14:29.942]                       invokeRestart <- base::invokeRestart
[16:14:29.942]                       is.null <- base::is.null
[16:14:29.942]                       muffled <- FALSE
[16:14:29.942]                       if (inherits(cond, "message")) {
[16:14:29.942]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:29.942]                         if (muffled) 
[16:14:29.942]                           invokeRestart("muffleMessage")
[16:14:29.942]                       }
[16:14:29.942]                       else if (inherits(cond, "warning")) {
[16:14:29.942]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:29.942]                         if (muffled) 
[16:14:29.942]                           invokeRestart("muffleWarning")
[16:14:29.942]                       }
[16:14:29.942]                       else if (inherits(cond, "condition")) {
[16:14:29.942]                         if (!is.null(pattern)) {
[16:14:29.942]                           computeRestarts <- base::computeRestarts
[16:14:29.942]                           grepl <- base::grepl
[16:14:29.942]                           restarts <- computeRestarts(cond)
[16:14:29.942]                           for (restart in restarts) {
[16:14:29.942]                             name <- restart$name
[16:14:29.942]                             if (is.null(name)) 
[16:14:29.942]                               next
[16:14:29.942]                             if (!grepl(pattern, name)) 
[16:14:29.942]                               next
[16:14:29.942]                             invokeRestart(restart)
[16:14:29.942]                             muffled <- TRUE
[16:14:29.942]                             break
[16:14:29.942]                           }
[16:14:29.942]                         }
[16:14:29.942]                       }
[16:14:29.942]                       invisible(muffled)
[16:14:29.942]                     }
[16:14:29.942]                     muffleCondition(cond, pattern = "^muffle")
[16:14:29.942]                   }
[16:14:29.942]                 }
[16:14:29.942]                 else {
[16:14:29.942]                   if (TRUE) {
[16:14:29.942]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:29.942]                     {
[16:14:29.942]                       inherits <- base::inherits
[16:14:29.942]                       invokeRestart <- base::invokeRestart
[16:14:29.942]                       is.null <- base::is.null
[16:14:29.942]                       muffled <- FALSE
[16:14:29.942]                       if (inherits(cond, "message")) {
[16:14:29.942]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:29.942]                         if (muffled) 
[16:14:29.942]                           invokeRestart("muffleMessage")
[16:14:29.942]                       }
[16:14:29.942]                       else if (inherits(cond, "warning")) {
[16:14:29.942]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:29.942]                         if (muffled) 
[16:14:29.942]                           invokeRestart("muffleWarning")
[16:14:29.942]                       }
[16:14:29.942]                       else if (inherits(cond, "condition")) {
[16:14:29.942]                         if (!is.null(pattern)) {
[16:14:29.942]                           computeRestarts <- base::computeRestarts
[16:14:29.942]                           grepl <- base::grepl
[16:14:29.942]                           restarts <- computeRestarts(cond)
[16:14:29.942]                           for (restart in restarts) {
[16:14:29.942]                             name <- restart$name
[16:14:29.942]                             if (is.null(name)) 
[16:14:29.942]                               next
[16:14:29.942]                             if (!grepl(pattern, name)) 
[16:14:29.942]                               next
[16:14:29.942]                             invokeRestart(restart)
[16:14:29.942]                             muffled <- TRUE
[16:14:29.942]                             break
[16:14:29.942]                           }
[16:14:29.942]                         }
[16:14:29.942]                       }
[16:14:29.942]                       invisible(muffled)
[16:14:29.942]                     }
[16:14:29.942]                     muffleCondition(cond, pattern = "^muffle")
[16:14:29.942]                   }
[16:14:29.942]                 }
[16:14:29.942]             }
[16:14:29.942]         }))
[16:14:29.942]     }, error = function(ex) {
[16:14:29.942]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:29.942]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:29.942]                 ...future.rng), started = ...future.startTime, 
[16:14:29.942]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:29.942]             version = "1.8"), class = "FutureResult")
[16:14:29.942]     }, finally = {
[16:14:29.942]         if (!identical(...future.workdir, getwd())) 
[16:14:29.942]             setwd(...future.workdir)
[16:14:29.942]         {
[16:14:29.942]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:29.942]                 ...future.oldOptions$nwarnings <- NULL
[16:14:29.942]             }
[16:14:29.942]             base::options(...future.oldOptions)
[16:14:29.942]             if (.Platform$OS.type == "windows") {
[16:14:29.942]                 old_names <- names(...future.oldEnvVars)
[16:14:29.942]                 envs <- base::Sys.getenv()
[16:14:29.942]                 names <- names(envs)
[16:14:29.942]                 common <- intersect(names, old_names)
[16:14:29.942]                 added <- setdiff(names, old_names)
[16:14:29.942]                 removed <- setdiff(old_names, names)
[16:14:29.942]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:29.942]                   envs[common]]
[16:14:29.942]                 NAMES <- toupper(changed)
[16:14:29.942]                 args <- list()
[16:14:29.942]                 for (kk in seq_along(NAMES)) {
[16:14:29.942]                   name <- changed[[kk]]
[16:14:29.942]                   NAME <- NAMES[[kk]]
[16:14:29.942]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.942]                     next
[16:14:29.942]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:29.942]                 }
[16:14:29.942]                 NAMES <- toupper(added)
[16:14:29.942]                 for (kk in seq_along(NAMES)) {
[16:14:29.942]                   name <- added[[kk]]
[16:14:29.942]                   NAME <- NAMES[[kk]]
[16:14:29.942]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.942]                     next
[16:14:29.942]                   args[[name]] <- ""
[16:14:29.942]                 }
[16:14:29.942]                 NAMES <- toupper(removed)
[16:14:29.942]                 for (kk in seq_along(NAMES)) {
[16:14:29.942]                   name <- removed[[kk]]
[16:14:29.942]                   NAME <- NAMES[[kk]]
[16:14:29.942]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:29.942]                     next
[16:14:29.942]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:29.942]                 }
[16:14:29.942]                 if (length(args) > 0) 
[16:14:29.942]                   base::do.call(base::Sys.setenv, args = args)
[16:14:29.942]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:29.942]             }
[16:14:29.942]             else {
[16:14:29.942]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:29.942]             }
[16:14:29.942]             {
[16:14:29.942]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:29.942]                   0L) {
[16:14:29.942]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:29.942]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:29.942]                   base::options(opts)
[16:14:29.942]                 }
[16:14:29.942]                 {
[16:14:29.942]                   {
[16:14:29.942]                     base::options(mc.cores = ...future.mc.cores.old)
[16:14:29.942]                     NULL
[16:14:29.942]                   }
[16:14:29.942]                   options(future.plan = NULL)
[16:14:29.942]                   if (is.na(NA_character_)) 
[16:14:29.942]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:29.942]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:29.942]                   future::plan(list(function (..., workers = availableCores(), 
[16:14:29.942]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:14:29.942]                     envir = parent.frame()) 
[16:14:29.942]                   {
[16:14:29.942]                     if (is.function(workers)) 
[16:14:29.942]                       workers <- workers()
[16:14:29.942]                     workers <- structure(as.integer(workers), 
[16:14:29.942]                       class = class(workers))
[16:14:29.942]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:14:29.942]                       workers >= 1)
[16:14:29.942]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:14:29.942]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:14:29.942]                     }
[16:14:29.942]                     future <- MultisessionFuture(..., workers = workers, 
[16:14:29.942]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:14:29.942]                       envir = envir)
[16:14:29.942]                     if (!future$lazy) 
[16:14:29.942]                       future <- run(future)
[16:14:29.942]                     invisible(future)
[16:14:29.942]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:29.942]                 }
[16:14:29.942]             }
[16:14:29.942]         }
[16:14:29.942]     })
[16:14:29.942]     if (TRUE) {
[16:14:29.942]         base::sink(type = "output", split = FALSE)
[16:14:29.942]         if (TRUE) {
[16:14:29.942]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:29.942]         }
[16:14:29.942]         else {
[16:14:29.942]             ...future.result["stdout"] <- base::list(NULL)
[16:14:29.942]         }
[16:14:29.942]         base::close(...future.stdout)
[16:14:29.942]         ...future.stdout <- NULL
[16:14:29.942]     }
[16:14:29.942]     ...future.result$conditions <- ...future.conditions
[16:14:29.942]     ...future.result$finished <- base::Sys.time()
[16:14:29.942]     ...future.result
[16:14:29.942] }
[16:14:30.013] MultisessionFuture started
[16:14:30.013] result() for ClusterFuture ...
[16:14:30.014] receiveMessageFromWorker() for ClusterFuture ...
[16:14:30.015] - Validating connection of MultisessionFuture
[16:14:30.045] - received message: FutureResult
[16:14:30.046] - Received FutureResult
[16:14:30.046] - Erased future from FutureRegistry
[16:14:30.046] result() for ClusterFuture ...
[16:14:30.046] - result already collected: FutureResult
[16:14:30.046] result() for ClusterFuture ... done
[16:14:30.046] receiveMessageFromWorker() for ClusterFuture ... done
[16:14:30.046] result() for ClusterFuture ... done
[16:14:30.046] result() for ClusterFuture ...
[16:14:30.047] - result already collected: FutureResult
[16:14:30.047] result() for ClusterFuture ... done
[16:14:30.047] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:14:30.051] plan(): nbrOfWorkers() = 2
- stdout = TRUE
[16:14:30.051] getGlobalsAndPackages() ...
[16:14:30.051] Searching for globals...
[16:14:30.055] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[16:14:30.055] Searching for globals ... DONE
[16:14:30.055] Resolving globals: FALSE
[16:14:30.056] 
[16:14:30.056] - packages: [1] ‘utils’
[16:14:30.056] getGlobalsAndPackages() ... DONE
[16:14:30.056] run() for ‘Future’ ...
[16:14:30.057] - state: ‘created’
[16:14:30.057] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:14:30.072] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:14:30.072] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:14:30.072]   - Field: ‘node’
[16:14:30.072]   - Field: ‘label’
[16:14:30.072]   - Field: ‘local’
[16:14:30.072]   - Field: ‘owner’
[16:14:30.072]   - Field: ‘envir’
[16:14:30.072]   - Field: ‘workers’
[16:14:30.073]   - Field: ‘packages’
[16:14:30.073]   - Field: ‘gc’
[16:14:30.073]   - Field: ‘conditions’
[16:14:30.073]   - Field: ‘persistent’
[16:14:30.073]   - Field: ‘expr’
[16:14:30.073]   - Field: ‘uuid’
[16:14:30.073]   - Field: ‘seed’
[16:14:30.073]   - Field: ‘version’
[16:14:30.073]   - Field: ‘result’
[16:14:30.074]   - Field: ‘asynchronous’
[16:14:30.074]   - Field: ‘calls’
[16:14:30.074]   - Field: ‘globals’
[16:14:30.074]   - Field: ‘stdout’
[16:14:30.074]   - Field: ‘earlySignal’
[16:14:30.074]   - Field: ‘lazy’
[16:14:30.074]   - Field: ‘state’
[16:14:30.074] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:14:30.075] - Launch lazy future ...
[16:14:30.075] Packages needed by the future expression (n = 1): ‘utils’
[16:14:30.075] Packages needed by future strategies (n = 0): <none>
[16:14:30.076] {
[16:14:30.076]     {
[16:14:30.076]         {
[16:14:30.076]             ...future.startTime <- base::Sys.time()
[16:14:30.076]             {
[16:14:30.076]                 {
[16:14:30.076]                   {
[16:14:30.076]                     {
[16:14:30.076]                       {
[16:14:30.076]                         base::local({
[16:14:30.076]                           has_future <- base::requireNamespace("future", 
[16:14:30.076]                             quietly = TRUE)
[16:14:30.076]                           if (has_future) {
[16:14:30.076]                             ns <- base::getNamespace("future")
[16:14:30.076]                             version <- ns[[".package"]][["version"]]
[16:14:30.076]                             if (is.null(version)) 
[16:14:30.076]                               version <- utils::packageVersion("future")
[16:14:30.076]                           }
[16:14:30.076]                           else {
[16:14:30.076]                             version <- NULL
[16:14:30.076]                           }
[16:14:30.076]                           if (!has_future || version < "1.8.0") {
[16:14:30.076]                             info <- base::c(r_version = base::gsub("R version ", 
[16:14:30.076]                               "", base::R.version$version.string), 
[16:14:30.076]                               platform = base::sprintf("%s (%s-bit)", 
[16:14:30.076]                                 base::R.version$platform, 8 * 
[16:14:30.076]                                   base::.Machine$sizeof.pointer), 
[16:14:30.076]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:30.076]                                 "release", "version")], collapse = " "), 
[16:14:30.076]                               hostname = base::Sys.info()[["nodename"]])
[16:14:30.076]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:14:30.076]                               info)
[16:14:30.076]                             info <- base::paste(info, collapse = "; ")
[16:14:30.076]                             if (!has_future) {
[16:14:30.076]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:30.076]                                 info)
[16:14:30.076]                             }
[16:14:30.076]                             else {
[16:14:30.076]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:30.076]                                 info, version)
[16:14:30.076]                             }
[16:14:30.076]                             base::stop(msg)
[16:14:30.076]                           }
[16:14:30.076]                         })
[16:14:30.076]                       }
[16:14:30.076]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:14:30.076]                       base::options(mc.cores = 1L)
[16:14:30.076]                     }
[16:14:30.076]                     base::local({
[16:14:30.076]                       for (pkg in "utils") {
[16:14:30.076]                         base::loadNamespace(pkg)
[16:14:30.076]                         base::library(pkg, character.only = TRUE)
[16:14:30.076]                       }
[16:14:30.076]                     })
[16:14:30.076]                   }
[16:14:30.076]                   options(future.plan = NULL)
[16:14:30.076]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:30.076]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:30.076]                 }
[16:14:30.076]                 ...future.workdir <- getwd()
[16:14:30.076]             }
[16:14:30.076]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:30.076]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:30.076]         }
[16:14:30.076]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:30.076]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:30.076]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:30.076]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:30.076]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:30.076]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:30.076]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:30.076]             base::names(...future.oldOptions))
[16:14:30.076]     }
[16:14:30.076]     if (FALSE) {
[16:14:30.076]     }
[16:14:30.076]     else {
[16:14:30.076]         if (TRUE) {
[16:14:30.076]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:30.076]                 open = "w")
[16:14:30.076]         }
[16:14:30.076]         else {
[16:14:30.076]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:30.076]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:30.076]         }
[16:14:30.076]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:30.076]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:30.076]             base::sink(type = "output", split = FALSE)
[16:14:30.076]             base::close(...future.stdout)
[16:14:30.076]         }, add = TRUE)
[16:14:30.076]     }
[16:14:30.076]     ...future.frame <- base::sys.nframe()
[16:14:30.076]     ...future.conditions <- base::list()
[16:14:30.076]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:30.076]     if (FALSE) {
[16:14:30.076]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:30.076]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:30.076]     }
[16:14:30.076]     ...future.result <- base::tryCatch({
[16:14:30.076]         base::withCallingHandlers({
[16:14:30.076]             ...future.value <- base::withVisible(base::local({
[16:14:30.076]                 ...future.makeSendCondition <- local({
[16:14:30.076]                   sendCondition <- NULL
[16:14:30.076]                   function(frame = 1L) {
[16:14:30.076]                     if (is.function(sendCondition)) 
[16:14:30.076]                       return(sendCondition)
[16:14:30.076]                     ns <- getNamespace("parallel")
[16:14:30.076]                     if (exists("sendData", mode = "function", 
[16:14:30.076]                       envir = ns)) {
[16:14:30.076]                       parallel_sendData <- get("sendData", mode = "function", 
[16:14:30.076]                         envir = ns)
[16:14:30.076]                       envir <- sys.frame(frame)
[16:14:30.076]                       master <- NULL
[16:14:30.076]                       while (!identical(envir, .GlobalEnv) && 
[16:14:30.076]                         !identical(envir, emptyenv())) {
[16:14:30.076]                         if (exists("master", mode = "list", envir = envir, 
[16:14:30.076]                           inherits = FALSE)) {
[16:14:30.076]                           master <- get("master", mode = "list", 
[16:14:30.076]                             envir = envir, inherits = FALSE)
[16:14:30.076]                           if (inherits(master, c("SOCKnode", 
[16:14:30.076]                             "SOCK0node"))) {
[16:14:30.076]                             sendCondition <<- function(cond) {
[16:14:30.076]                               data <- list(type = "VALUE", value = cond, 
[16:14:30.076]                                 success = TRUE)
[16:14:30.076]                               parallel_sendData(master, data)
[16:14:30.076]                             }
[16:14:30.076]                             return(sendCondition)
[16:14:30.076]                           }
[16:14:30.076]                         }
[16:14:30.076]                         frame <- frame + 1L
[16:14:30.076]                         envir <- sys.frame(frame)
[16:14:30.076]                       }
[16:14:30.076]                     }
[16:14:30.076]                     sendCondition <<- function(cond) NULL
[16:14:30.076]                   }
[16:14:30.076]                 })
[16:14:30.076]                 withCallingHandlers({
[16:14:30.076]                   {
[16:14:30.076]                     print(1:50)
[16:14:30.076]                     str(1:50)
[16:14:30.076]                     cat(letters, sep = "-")
[16:14:30.076]                     cat(1:6, collapse = "\n")
[16:14:30.076]                     write.table(datasets::iris[1:10, ], sep = "\t")
[16:14:30.076]                     42L
[16:14:30.076]                   }
[16:14:30.076]                 }, immediateCondition = function(cond) {
[16:14:30.076]                   sendCondition <- ...future.makeSendCondition()
[16:14:30.076]                   sendCondition(cond)
[16:14:30.076]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:30.076]                   {
[16:14:30.076]                     inherits <- base::inherits
[16:14:30.076]                     invokeRestart <- base::invokeRestart
[16:14:30.076]                     is.null <- base::is.null
[16:14:30.076]                     muffled <- FALSE
[16:14:30.076]                     if (inherits(cond, "message")) {
[16:14:30.076]                       muffled <- grepl(pattern, "muffleMessage")
[16:14:30.076]                       if (muffled) 
[16:14:30.076]                         invokeRestart("muffleMessage")
[16:14:30.076]                     }
[16:14:30.076]                     else if (inherits(cond, "warning")) {
[16:14:30.076]                       muffled <- grepl(pattern, "muffleWarning")
[16:14:30.076]                       if (muffled) 
[16:14:30.076]                         invokeRestart("muffleWarning")
[16:14:30.076]                     }
[16:14:30.076]                     else if (inherits(cond, "condition")) {
[16:14:30.076]                       if (!is.null(pattern)) {
[16:14:30.076]                         computeRestarts <- base::computeRestarts
[16:14:30.076]                         grepl <- base::grepl
[16:14:30.076]                         restarts <- computeRestarts(cond)
[16:14:30.076]                         for (restart in restarts) {
[16:14:30.076]                           name <- restart$name
[16:14:30.076]                           if (is.null(name)) 
[16:14:30.076]                             next
[16:14:30.076]                           if (!grepl(pattern, name)) 
[16:14:30.076]                             next
[16:14:30.076]                           invokeRestart(restart)
[16:14:30.076]                           muffled <- TRUE
[16:14:30.076]                           break
[16:14:30.076]                         }
[16:14:30.076]                       }
[16:14:30.076]                     }
[16:14:30.076]                     invisible(muffled)
[16:14:30.076]                   }
[16:14:30.076]                   muffleCondition(cond)
[16:14:30.076]                 })
[16:14:30.076]             }))
[16:14:30.076]             future::FutureResult(value = ...future.value$value, 
[16:14:30.076]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:30.076]                   ...future.rng), globalenv = if (FALSE) 
[16:14:30.076]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:30.076]                     ...future.globalenv.names))
[16:14:30.076]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:30.076]         }, condition = base::local({
[16:14:30.076]             c <- base::c
[16:14:30.076]             inherits <- base::inherits
[16:14:30.076]             invokeRestart <- base::invokeRestart
[16:14:30.076]             length <- base::length
[16:14:30.076]             list <- base::list
[16:14:30.076]             seq.int <- base::seq.int
[16:14:30.076]             signalCondition <- base::signalCondition
[16:14:30.076]             sys.calls <- base::sys.calls
[16:14:30.076]             `[[` <- base::`[[`
[16:14:30.076]             `+` <- base::`+`
[16:14:30.076]             `<<-` <- base::`<<-`
[16:14:30.076]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:30.076]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:30.076]                   3L)]
[16:14:30.076]             }
[16:14:30.076]             function(cond) {
[16:14:30.076]                 is_error <- inherits(cond, "error")
[16:14:30.076]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:30.076]                   NULL)
[16:14:30.076]                 if (is_error) {
[16:14:30.076]                   sessionInformation <- function() {
[16:14:30.076]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:30.076]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:30.076]                       search = base::search(), system = base::Sys.info())
[16:14:30.076]                   }
[16:14:30.076]                   ...future.conditions[[length(...future.conditions) + 
[16:14:30.076]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:30.076]                     cond$call), session = sessionInformation(), 
[16:14:30.076]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:30.076]                   signalCondition(cond)
[16:14:30.076]                 }
[16:14:30.076]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:30.076]                 "immediateCondition"))) {
[16:14:30.076]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:30.076]                   ...future.conditions[[length(...future.conditions) + 
[16:14:30.076]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:30.076]                   if (TRUE && !signal) {
[16:14:30.076]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:30.076]                     {
[16:14:30.076]                       inherits <- base::inherits
[16:14:30.076]                       invokeRestart <- base::invokeRestart
[16:14:30.076]                       is.null <- base::is.null
[16:14:30.076]                       muffled <- FALSE
[16:14:30.076]                       if (inherits(cond, "message")) {
[16:14:30.076]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:30.076]                         if (muffled) 
[16:14:30.076]                           invokeRestart("muffleMessage")
[16:14:30.076]                       }
[16:14:30.076]                       else if (inherits(cond, "warning")) {
[16:14:30.076]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:30.076]                         if (muffled) 
[16:14:30.076]                           invokeRestart("muffleWarning")
[16:14:30.076]                       }
[16:14:30.076]                       else if (inherits(cond, "condition")) {
[16:14:30.076]                         if (!is.null(pattern)) {
[16:14:30.076]                           computeRestarts <- base::computeRestarts
[16:14:30.076]                           grepl <- base::grepl
[16:14:30.076]                           restarts <- computeRestarts(cond)
[16:14:30.076]                           for (restart in restarts) {
[16:14:30.076]                             name <- restart$name
[16:14:30.076]                             if (is.null(name)) 
[16:14:30.076]                               next
[16:14:30.076]                             if (!grepl(pattern, name)) 
[16:14:30.076]                               next
[16:14:30.076]                             invokeRestart(restart)
[16:14:30.076]                             muffled <- TRUE
[16:14:30.076]                             break
[16:14:30.076]                           }
[16:14:30.076]                         }
[16:14:30.076]                       }
[16:14:30.076]                       invisible(muffled)
[16:14:30.076]                     }
[16:14:30.076]                     muffleCondition(cond, pattern = "^muffle")
[16:14:30.076]                   }
[16:14:30.076]                 }
[16:14:30.076]                 else {
[16:14:30.076]                   if (TRUE) {
[16:14:30.076]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:30.076]                     {
[16:14:30.076]                       inherits <- base::inherits
[16:14:30.076]                       invokeRestart <- base::invokeRestart
[16:14:30.076]                       is.null <- base::is.null
[16:14:30.076]                       muffled <- FALSE
[16:14:30.076]                       if (inherits(cond, "message")) {
[16:14:30.076]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:30.076]                         if (muffled) 
[16:14:30.076]                           invokeRestart("muffleMessage")
[16:14:30.076]                       }
[16:14:30.076]                       else if (inherits(cond, "warning")) {
[16:14:30.076]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:30.076]                         if (muffled) 
[16:14:30.076]                           invokeRestart("muffleWarning")
[16:14:30.076]                       }
[16:14:30.076]                       else if (inherits(cond, "condition")) {
[16:14:30.076]                         if (!is.null(pattern)) {
[16:14:30.076]                           computeRestarts <- base::computeRestarts
[16:14:30.076]                           grepl <- base::grepl
[16:14:30.076]                           restarts <- computeRestarts(cond)
[16:14:30.076]                           for (restart in restarts) {
[16:14:30.076]                             name <- restart$name
[16:14:30.076]                             if (is.null(name)) 
[16:14:30.076]                               next
[16:14:30.076]                             if (!grepl(pattern, name)) 
[16:14:30.076]                               next
[16:14:30.076]                             invokeRestart(restart)
[16:14:30.076]                             muffled <- TRUE
[16:14:30.076]                             break
[16:14:30.076]                           }
[16:14:30.076]                         }
[16:14:30.076]                       }
[16:14:30.076]                       invisible(muffled)
[16:14:30.076]                     }
[16:14:30.076]                     muffleCondition(cond, pattern = "^muffle")
[16:14:30.076]                   }
[16:14:30.076]                 }
[16:14:30.076]             }
[16:14:30.076]         }))
[16:14:30.076]     }, error = function(ex) {
[16:14:30.076]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:30.076]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:30.076]                 ...future.rng), started = ...future.startTime, 
[16:14:30.076]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:30.076]             version = "1.8"), class = "FutureResult")
[16:14:30.076]     }, finally = {
[16:14:30.076]         if (!identical(...future.workdir, getwd())) 
[16:14:30.076]             setwd(...future.workdir)
[16:14:30.076]         {
[16:14:30.076]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:30.076]                 ...future.oldOptions$nwarnings <- NULL
[16:14:30.076]             }
[16:14:30.076]             base::options(...future.oldOptions)
[16:14:30.076]             if (.Platform$OS.type == "windows") {
[16:14:30.076]                 old_names <- names(...future.oldEnvVars)
[16:14:30.076]                 envs <- base::Sys.getenv()
[16:14:30.076]                 names <- names(envs)
[16:14:30.076]                 common <- intersect(names, old_names)
[16:14:30.076]                 added <- setdiff(names, old_names)
[16:14:30.076]                 removed <- setdiff(old_names, names)
[16:14:30.076]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:30.076]                   envs[common]]
[16:14:30.076]                 NAMES <- toupper(changed)
[16:14:30.076]                 args <- list()
[16:14:30.076]                 for (kk in seq_along(NAMES)) {
[16:14:30.076]                   name <- changed[[kk]]
[16:14:30.076]                   NAME <- NAMES[[kk]]
[16:14:30.076]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:30.076]                     next
[16:14:30.076]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:30.076]                 }
[16:14:30.076]                 NAMES <- toupper(added)
[16:14:30.076]                 for (kk in seq_along(NAMES)) {
[16:14:30.076]                   name <- added[[kk]]
[16:14:30.076]                   NAME <- NAMES[[kk]]
[16:14:30.076]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:30.076]                     next
[16:14:30.076]                   args[[name]] <- ""
[16:14:30.076]                 }
[16:14:30.076]                 NAMES <- toupper(removed)
[16:14:30.076]                 for (kk in seq_along(NAMES)) {
[16:14:30.076]                   name <- removed[[kk]]
[16:14:30.076]                   NAME <- NAMES[[kk]]
[16:14:30.076]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:30.076]                     next
[16:14:30.076]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:30.076]                 }
[16:14:30.076]                 if (length(args) > 0) 
[16:14:30.076]                   base::do.call(base::Sys.setenv, args = args)
[16:14:30.076]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:30.076]             }
[16:14:30.076]             else {
[16:14:30.076]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:30.076]             }
[16:14:30.076]             {
[16:14:30.076]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:30.076]                   0L) {
[16:14:30.076]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:30.076]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:30.076]                   base::options(opts)
[16:14:30.076]                 }
[16:14:30.076]                 {
[16:14:30.076]                   {
[16:14:30.076]                     base::options(mc.cores = ...future.mc.cores.old)
[16:14:30.076]                     NULL
[16:14:30.076]                   }
[16:14:30.076]                   options(future.plan = NULL)
[16:14:30.076]                   if (is.na(NA_character_)) 
[16:14:30.076]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:30.076]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:30.076]                   future::plan(list(function (..., workers = availableCores(), 
[16:14:30.076]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:14:30.076]                     envir = parent.frame()) 
[16:14:30.076]                   {
[16:14:30.076]                     if (is.function(workers)) 
[16:14:30.076]                       workers <- workers()
[16:14:30.076]                     workers <- structure(as.integer(workers), 
[16:14:30.076]                       class = class(workers))
[16:14:30.076]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:14:30.076]                       workers >= 1)
[16:14:30.076]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:14:30.076]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:14:30.076]                     }
[16:14:30.076]                     future <- MultisessionFuture(..., workers = workers, 
[16:14:30.076]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:14:30.076]                       envir = envir)
[16:14:30.076]                     if (!future$lazy) 
[16:14:30.076]                       future <- run(future)
[16:14:30.076]                     invisible(future)
[16:14:30.076]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:30.076]                 }
[16:14:30.076]             }
[16:14:30.076]         }
[16:14:30.076]     })
[16:14:30.076]     if (TRUE) {
[16:14:30.076]         base::sink(type = "output", split = FALSE)
[16:14:30.076]         if (TRUE) {
[16:14:30.076]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:30.076]         }
[16:14:30.076]         else {
[16:14:30.076]             ...future.result["stdout"] <- base::list(NULL)
[16:14:30.076]         }
[16:14:30.076]         base::close(...future.stdout)
[16:14:30.076]         ...future.stdout <- NULL
[16:14:30.076]     }
[16:14:30.076]     ...future.result$conditions <- ...future.conditions
[16:14:30.076]     ...future.result$finished <- base::Sys.time()
[16:14:30.076]     ...future.result
[16:14:30.076] }
[16:14:30.079] MultisessionFuture started
[16:14:30.079] - Launch lazy future ... done
[16:14:30.080] run() for ‘MultisessionFuture’ ... done
[16:14:30.080] result() for ClusterFuture ...
[16:14:30.080] receiveMessageFromWorker() for ClusterFuture ...
[16:14:30.080] - Validating connection of MultisessionFuture
[16:14:30.128] - received message: FutureResult
[16:14:30.128] - Received FutureResult
[16:14:30.129] - Erased future from FutureRegistry
[16:14:30.129] result() for ClusterFuture ...
[16:14:30.129] - result already collected: FutureResult
[16:14:30.129] result() for ClusterFuture ... done
[16:14:30.129] receiveMessageFromWorker() for ClusterFuture ... done
[16:14:30.129] result() for ClusterFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : chr " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 3"| __truncated__
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-01-06 16:14:30"
 $ finished    : POSIXct[1:1], format: "2025-01-06 16:14:30"
 $ session_uuid: chr "725930bb-1bfc-1e75-76a7-4452e9fc425d"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "2729ef2608da"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "2729ef2608da" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 92408
  .. ..$ time  : POSIXct[1:1], format: "2025-01-06 16:14:29"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 3 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[16:14:30.139] result() for ClusterFuture ...
[16:14:30.139] - result already collected: FutureResult
[16:14:30.139] result() for ClusterFuture ... done
[16:14:30.139] result() for ClusterFuture ...
[16:14:30.139] - result already collected: FutureResult
[16:14:30.139] result() for ClusterFuture ... done
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
FutureResult:
value: ‘integer’
visible: TRUE
stdout: character
conditions: [n = 0] 
RNG used: FALSE
duration: 0.008374929 secs (started 2025-01-06 16:14:30.120239)
version: 1.8
[16:14:30.140] getGlobalsAndPackages() ...
[16:14:30.140] Searching for globals...
[16:14:30.144] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[16:14:30.144] Searching for globals ... DONE
[16:14:30.144] Resolving globals: FALSE
[16:14:30.145] 
[16:14:30.145] - packages: [1] ‘utils’
[16:14:30.145] getGlobalsAndPackages() ... DONE
[16:14:30.145] run() for ‘Future’ ...
[16:14:30.145] - state: ‘created’
[16:14:30.146] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:14:30.161] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:14:30.161] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:14:30.161]   - Field: ‘node’
[16:14:30.161]   - Field: ‘label’
[16:14:30.161]   - Field: ‘local’
[16:14:30.161]   - Field: ‘owner’
[16:14:30.161]   - Field: ‘envir’
[16:14:30.161]   - Field: ‘workers’
[16:14:30.162]   - Field: ‘packages’
[16:14:30.162]   - Field: ‘gc’
[16:14:30.162]   - Field: ‘conditions’
[16:14:30.162]   - Field: ‘persistent’
[16:14:30.162]   - Field: ‘expr’
[16:14:30.162]   - Field: ‘uuid’
[16:14:30.162]   - Field: ‘seed’
[16:14:30.162]   - Field: ‘version’
[16:14:30.162]   - Field: ‘result’
[16:14:30.163]   - Field: ‘asynchronous’
[16:14:30.163]   - Field: ‘calls’
[16:14:30.163]   - Field: ‘globals’
[16:14:30.163]   - Field: ‘stdout’
[16:14:30.163]   - Field: ‘earlySignal’
[16:14:30.163]   - Field: ‘lazy’
[16:14:30.163]   - Field: ‘state’
[16:14:30.163] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:14:30.163] - Launch lazy future ...
[16:14:30.164] Packages needed by the future expression (n = 1): ‘utils’
[16:14:30.164] Packages needed by future strategies (n = 0): <none>
[16:14:30.165] {
[16:14:30.165]     {
[16:14:30.165]         {
[16:14:30.165]             ...future.startTime <- base::Sys.time()
[16:14:30.165]             {
[16:14:30.165]                 {
[16:14:30.165]                   {
[16:14:30.165]                     {
[16:14:30.165]                       {
[16:14:30.165]                         base::local({
[16:14:30.165]                           has_future <- base::requireNamespace("future", 
[16:14:30.165]                             quietly = TRUE)
[16:14:30.165]                           if (has_future) {
[16:14:30.165]                             ns <- base::getNamespace("future")
[16:14:30.165]                             version <- ns[[".package"]][["version"]]
[16:14:30.165]                             if (is.null(version)) 
[16:14:30.165]                               version <- utils::packageVersion("future")
[16:14:30.165]                           }
[16:14:30.165]                           else {
[16:14:30.165]                             version <- NULL
[16:14:30.165]                           }
[16:14:30.165]                           if (!has_future || version < "1.8.0") {
[16:14:30.165]                             info <- base::c(r_version = base::gsub("R version ", 
[16:14:30.165]                               "", base::R.version$version.string), 
[16:14:30.165]                               platform = base::sprintf("%s (%s-bit)", 
[16:14:30.165]                                 base::R.version$platform, 8 * 
[16:14:30.165]                                   base::.Machine$sizeof.pointer), 
[16:14:30.165]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:30.165]                                 "release", "version")], collapse = " "), 
[16:14:30.165]                               hostname = base::Sys.info()[["nodename"]])
[16:14:30.165]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:14:30.165]                               info)
[16:14:30.165]                             info <- base::paste(info, collapse = "; ")
[16:14:30.165]                             if (!has_future) {
[16:14:30.165]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:30.165]                                 info)
[16:14:30.165]                             }
[16:14:30.165]                             else {
[16:14:30.165]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:30.165]                                 info, version)
[16:14:30.165]                             }
[16:14:30.165]                             base::stop(msg)
[16:14:30.165]                           }
[16:14:30.165]                         })
[16:14:30.165]                       }
[16:14:30.165]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:14:30.165]                       base::options(mc.cores = 1L)
[16:14:30.165]                     }
[16:14:30.165]                     base::local({
[16:14:30.165]                       for (pkg in "utils") {
[16:14:30.165]                         base::loadNamespace(pkg)
[16:14:30.165]                         base::library(pkg, character.only = TRUE)
[16:14:30.165]                       }
[16:14:30.165]                     })
[16:14:30.165]                   }
[16:14:30.165]                   options(future.plan = NULL)
[16:14:30.165]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:30.165]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:30.165]                 }
[16:14:30.165]                 ...future.workdir <- getwd()
[16:14:30.165]             }
[16:14:30.165]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:30.165]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:30.165]         }
[16:14:30.165]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:30.165]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:30.165]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:30.165]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:30.165]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:30.165]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:30.165]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:30.165]             base::names(...future.oldOptions))
[16:14:30.165]     }
[16:14:30.165]     if (FALSE) {
[16:14:30.165]     }
[16:14:30.165]     else {
[16:14:30.165]         if (TRUE) {
[16:14:30.165]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:30.165]                 open = "w")
[16:14:30.165]         }
[16:14:30.165]         else {
[16:14:30.165]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:30.165]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:30.165]         }
[16:14:30.165]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:30.165]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:30.165]             base::sink(type = "output", split = FALSE)
[16:14:30.165]             base::close(...future.stdout)
[16:14:30.165]         }, add = TRUE)
[16:14:30.165]     }
[16:14:30.165]     ...future.frame <- base::sys.nframe()
[16:14:30.165]     ...future.conditions <- base::list()
[16:14:30.165]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:30.165]     if (FALSE) {
[16:14:30.165]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:30.165]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:30.165]     }
[16:14:30.165]     ...future.result <- base::tryCatch({
[16:14:30.165]         base::withCallingHandlers({
[16:14:30.165]             ...future.value <- base::withVisible(base::local({
[16:14:30.165]                 ...future.makeSendCondition <- local({
[16:14:30.165]                   sendCondition <- NULL
[16:14:30.165]                   function(frame = 1L) {
[16:14:30.165]                     if (is.function(sendCondition)) 
[16:14:30.165]                       return(sendCondition)
[16:14:30.165]                     ns <- getNamespace("parallel")
[16:14:30.165]                     if (exists("sendData", mode = "function", 
[16:14:30.165]                       envir = ns)) {
[16:14:30.165]                       parallel_sendData <- get("sendData", mode = "function", 
[16:14:30.165]                         envir = ns)
[16:14:30.165]                       envir <- sys.frame(frame)
[16:14:30.165]                       master <- NULL
[16:14:30.165]                       while (!identical(envir, .GlobalEnv) && 
[16:14:30.165]                         !identical(envir, emptyenv())) {
[16:14:30.165]                         if (exists("master", mode = "list", envir = envir, 
[16:14:30.165]                           inherits = FALSE)) {
[16:14:30.165]                           master <- get("master", mode = "list", 
[16:14:30.165]                             envir = envir, inherits = FALSE)
[16:14:30.165]                           if (inherits(master, c("SOCKnode", 
[16:14:30.165]                             "SOCK0node"))) {
[16:14:30.165]                             sendCondition <<- function(cond) {
[16:14:30.165]                               data <- list(type = "VALUE", value = cond, 
[16:14:30.165]                                 success = TRUE)
[16:14:30.165]                               parallel_sendData(master, data)
[16:14:30.165]                             }
[16:14:30.165]                             return(sendCondition)
[16:14:30.165]                           }
[16:14:30.165]                         }
[16:14:30.165]                         frame <- frame + 1L
[16:14:30.165]                         envir <- sys.frame(frame)
[16:14:30.165]                       }
[16:14:30.165]                     }
[16:14:30.165]                     sendCondition <<- function(cond) NULL
[16:14:30.165]                   }
[16:14:30.165]                 })
[16:14:30.165]                 withCallingHandlers({
[16:14:30.165]                   {
[16:14:30.165]                     print(1:50)
[16:14:30.165]                     str(1:50)
[16:14:30.165]                     cat(letters, sep = "-")
[16:14:30.165]                     cat(1:6, collapse = "\n")
[16:14:30.165]                     write.table(datasets::iris[1:10, ], sep = "\t")
[16:14:30.165]                     42L
[16:14:30.165]                   }
[16:14:30.165]                 }, immediateCondition = function(cond) {
[16:14:30.165]                   sendCondition <- ...future.makeSendCondition()
[16:14:30.165]                   sendCondition(cond)
[16:14:30.165]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:30.165]                   {
[16:14:30.165]                     inherits <- base::inherits
[16:14:30.165]                     invokeRestart <- base::invokeRestart
[16:14:30.165]                     is.null <- base::is.null
[16:14:30.165]                     muffled <- FALSE
[16:14:30.165]                     if (inherits(cond, "message")) {
[16:14:30.165]                       muffled <- grepl(pattern, "muffleMessage")
[16:14:30.165]                       if (muffled) 
[16:14:30.165]                         invokeRestart("muffleMessage")
[16:14:30.165]                     }
[16:14:30.165]                     else if (inherits(cond, "warning")) {
[16:14:30.165]                       muffled <- grepl(pattern, "muffleWarning")
[16:14:30.165]                       if (muffled) 
[16:14:30.165]                         invokeRestart("muffleWarning")
[16:14:30.165]                     }
[16:14:30.165]                     else if (inherits(cond, "condition")) {
[16:14:30.165]                       if (!is.null(pattern)) {
[16:14:30.165]                         computeRestarts <- base::computeRestarts
[16:14:30.165]                         grepl <- base::grepl
[16:14:30.165]                         restarts <- computeRestarts(cond)
[16:14:30.165]                         for (restart in restarts) {
[16:14:30.165]                           name <- restart$name
[16:14:30.165]                           if (is.null(name)) 
[16:14:30.165]                             next
[16:14:30.165]                           if (!grepl(pattern, name)) 
[16:14:30.165]                             next
[16:14:30.165]                           invokeRestart(restart)
[16:14:30.165]                           muffled <- TRUE
[16:14:30.165]                           break
[16:14:30.165]                         }
[16:14:30.165]                       }
[16:14:30.165]                     }
[16:14:30.165]                     invisible(muffled)
[16:14:30.165]                   }
[16:14:30.165]                   muffleCondition(cond)
[16:14:30.165]                 })
[16:14:30.165]             }))
[16:14:30.165]             future::FutureResult(value = ...future.value$value, 
[16:14:30.165]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:30.165]                   ...future.rng), globalenv = if (FALSE) 
[16:14:30.165]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:30.165]                     ...future.globalenv.names))
[16:14:30.165]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:30.165]         }, condition = base::local({
[16:14:30.165]             c <- base::c
[16:14:30.165]             inherits <- base::inherits
[16:14:30.165]             invokeRestart <- base::invokeRestart
[16:14:30.165]             length <- base::length
[16:14:30.165]             list <- base::list
[16:14:30.165]             seq.int <- base::seq.int
[16:14:30.165]             signalCondition <- base::signalCondition
[16:14:30.165]             sys.calls <- base::sys.calls
[16:14:30.165]             `[[` <- base::`[[`
[16:14:30.165]             `+` <- base::`+`
[16:14:30.165]             `<<-` <- base::`<<-`
[16:14:30.165]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:30.165]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:30.165]                   3L)]
[16:14:30.165]             }
[16:14:30.165]             function(cond) {
[16:14:30.165]                 is_error <- inherits(cond, "error")
[16:14:30.165]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:30.165]                   NULL)
[16:14:30.165]                 if (is_error) {
[16:14:30.165]                   sessionInformation <- function() {
[16:14:30.165]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:30.165]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:30.165]                       search = base::search(), system = base::Sys.info())
[16:14:30.165]                   }
[16:14:30.165]                   ...future.conditions[[length(...future.conditions) + 
[16:14:30.165]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:30.165]                     cond$call), session = sessionInformation(), 
[16:14:30.165]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:30.165]                   signalCondition(cond)
[16:14:30.165]                 }
[16:14:30.165]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:30.165]                 "immediateCondition"))) {
[16:14:30.165]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:30.165]                   ...future.conditions[[length(...future.conditions) + 
[16:14:30.165]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:30.165]                   if (TRUE && !signal) {
[16:14:30.165]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:30.165]                     {
[16:14:30.165]                       inherits <- base::inherits
[16:14:30.165]                       invokeRestart <- base::invokeRestart
[16:14:30.165]                       is.null <- base::is.null
[16:14:30.165]                       muffled <- FALSE
[16:14:30.165]                       if (inherits(cond, "message")) {
[16:14:30.165]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:30.165]                         if (muffled) 
[16:14:30.165]                           invokeRestart("muffleMessage")
[16:14:30.165]                       }
[16:14:30.165]                       else if (inherits(cond, "warning")) {
[16:14:30.165]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:30.165]                         if (muffled) 
[16:14:30.165]                           invokeRestart("muffleWarning")
[16:14:30.165]                       }
[16:14:30.165]                       else if (inherits(cond, "condition")) {
[16:14:30.165]                         if (!is.null(pattern)) {
[16:14:30.165]                           computeRestarts <- base::computeRestarts
[16:14:30.165]                           grepl <- base::grepl
[16:14:30.165]                           restarts <- computeRestarts(cond)
[16:14:30.165]                           for (restart in restarts) {
[16:14:30.165]                             name <- restart$name
[16:14:30.165]                             if (is.null(name)) 
[16:14:30.165]                               next
[16:14:30.165]                             if (!grepl(pattern, name)) 
[16:14:30.165]                               next
[16:14:30.165]                             invokeRestart(restart)
[16:14:30.165]                             muffled <- TRUE
[16:14:30.165]                             break
[16:14:30.165]                           }
[16:14:30.165]                         }
[16:14:30.165]                       }
[16:14:30.165]                       invisible(muffled)
[16:14:30.165]                     }
[16:14:30.165]                     muffleCondition(cond, pattern = "^muffle")
[16:14:30.165]                   }
[16:14:30.165]                 }
[16:14:30.165]                 else {
[16:14:30.165]                   if (TRUE) {
[16:14:30.165]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:30.165]                     {
[16:14:30.165]                       inherits <- base::inherits
[16:14:30.165]                       invokeRestart <- base::invokeRestart
[16:14:30.165]                       is.null <- base::is.null
[16:14:30.165]                       muffled <- FALSE
[16:14:30.165]                       if (inherits(cond, "message")) {
[16:14:30.165]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:30.165]                         if (muffled) 
[16:14:30.165]                           invokeRestart("muffleMessage")
[16:14:30.165]                       }
[16:14:30.165]                       else if (inherits(cond, "warning")) {
[16:14:30.165]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:30.165]                         if (muffled) 
[16:14:30.165]                           invokeRestart("muffleWarning")
[16:14:30.165]                       }
[16:14:30.165]                       else if (inherits(cond, "condition")) {
[16:14:30.165]                         if (!is.null(pattern)) {
[16:14:30.165]                           computeRestarts <- base::computeRestarts
[16:14:30.165]                           grepl <- base::grepl
[16:14:30.165]                           restarts <- computeRestarts(cond)
[16:14:30.165]                           for (restart in restarts) {
[16:14:30.165]                             name <- restart$name
[16:14:30.165]                             if (is.null(name)) 
[16:14:30.165]                               next
[16:14:30.165]                             if (!grepl(pattern, name)) 
[16:14:30.165]                               next
[16:14:30.165]                             invokeRestart(restart)
[16:14:30.165]                             muffled <- TRUE
[16:14:30.165]                             break
[16:14:30.165]                           }
[16:14:30.165]                         }
[16:14:30.165]                       }
[16:14:30.165]                       invisible(muffled)
[16:14:30.165]                     }
[16:14:30.165]                     muffleCondition(cond, pattern = "^muffle")
[16:14:30.165]                   }
[16:14:30.165]                 }
[16:14:30.165]             }
[16:14:30.165]         }))
[16:14:30.165]     }, error = function(ex) {
[16:14:30.165]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:30.165]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:30.165]                 ...future.rng), started = ...future.startTime, 
[16:14:30.165]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:30.165]             version = "1.8"), class = "FutureResult")
[16:14:30.165]     }, finally = {
[16:14:30.165]         if (!identical(...future.workdir, getwd())) 
[16:14:30.165]             setwd(...future.workdir)
[16:14:30.165]         {
[16:14:30.165]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:30.165]                 ...future.oldOptions$nwarnings <- NULL
[16:14:30.165]             }
[16:14:30.165]             base::options(...future.oldOptions)
[16:14:30.165]             if (.Platform$OS.type == "windows") {
[16:14:30.165]                 old_names <- names(...future.oldEnvVars)
[16:14:30.165]                 envs <- base::Sys.getenv()
[16:14:30.165]                 names <- names(envs)
[16:14:30.165]                 common <- intersect(names, old_names)
[16:14:30.165]                 added <- setdiff(names, old_names)
[16:14:30.165]                 removed <- setdiff(old_names, names)
[16:14:30.165]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:30.165]                   envs[common]]
[16:14:30.165]                 NAMES <- toupper(changed)
[16:14:30.165]                 args <- list()
[16:14:30.165]                 for (kk in seq_along(NAMES)) {
[16:14:30.165]                   name <- changed[[kk]]
[16:14:30.165]                   NAME <- NAMES[[kk]]
[16:14:30.165]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:30.165]                     next
[16:14:30.165]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:30.165]                 }
[16:14:30.165]                 NAMES <- toupper(added)
[16:14:30.165]                 for (kk in seq_along(NAMES)) {
[16:14:30.165]                   name <- added[[kk]]
[16:14:30.165]                   NAME <- NAMES[[kk]]
[16:14:30.165]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:30.165]                     next
[16:14:30.165]                   args[[name]] <- ""
[16:14:30.165]                 }
[16:14:30.165]                 NAMES <- toupper(removed)
[16:14:30.165]                 for (kk in seq_along(NAMES)) {
[16:14:30.165]                   name <- removed[[kk]]
[16:14:30.165]                   NAME <- NAMES[[kk]]
[16:14:30.165]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:30.165]                     next
[16:14:30.165]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:30.165]                 }
[16:14:30.165]                 if (length(args) > 0) 
[16:14:30.165]                   base::do.call(base::Sys.setenv, args = args)
[16:14:30.165]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:30.165]             }
[16:14:30.165]             else {
[16:14:30.165]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:30.165]             }
[16:14:30.165]             {
[16:14:30.165]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:30.165]                   0L) {
[16:14:30.165]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:30.165]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:30.165]                   base::options(opts)
[16:14:30.165]                 }
[16:14:30.165]                 {
[16:14:30.165]                   {
[16:14:30.165]                     base::options(mc.cores = ...future.mc.cores.old)
[16:14:30.165]                     NULL
[16:14:30.165]                   }
[16:14:30.165]                   options(future.plan = NULL)
[16:14:30.165]                   if (is.na(NA_character_)) 
[16:14:30.165]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:30.165]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:30.165]                   future::plan(list(function (..., workers = availableCores(), 
[16:14:30.165]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:14:30.165]                     envir = parent.frame()) 
[16:14:30.165]                   {
[16:14:30.165]                     if (is.function(workers)) 
[16:14:30.165]                       workers <- workers()
[16:14:30.165]                     workers <- structure(as.integer(workers), 
[16:14:30.165]                       class = class(workers))
[16:14:30.165]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:14:30.165]                       workers >= 1)
[16:14:30.165]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:14:30.165]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:14:30.165]                     }
[16:14:30.165]                     future <- MultisessionFuture(..., workers = workers, 
[16:14:30.165]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:14:30.165]                       envir = envir)
[16:14:30.165]                     if (!future$lazy) 
[16:14:30.165]                       future <- run(future)
[16:14:30.165]                     invisible(future)
[16:14:30.165]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:30.165]                 }
[16:14:30.165]             }
[16:14:30.165]         }
[16:14:30.165]     })
[16:14:30.165]     if (TRUE) {
[16:14:30.165]         base::sink(type = "output", split = FALSE)
[16:14:30.165]         if (TRUE) {
[16:14:30.165]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:30.165]         }
[16:14:30.165]         else {
[16:14:30.165]             ...future.result["stdout"] <- base::list(NULL)
[16:14:30.165]         }
[16:14:30.165]         base::close(...future.stdout)
[16:14:30.165]         ...future.stdout <- NULL
[16:14:30.165]     }
[16:14:30.165]     ...future.result$conditions <- ...future.conditions
[16:14:30.165]     ...future.result$finished <- base::Sys.time()
[16:14:30.165]     ...future.result
[16:14:30.165] }
[16:14:30.168] MultisessionFuture started
[16:14:30.168] - Launch lazy future ... done
[16:14:30.169] run() for ‘MultisessionFuture’ ... done
[16:14:30.169] result() for ClusterFuture ...
[16:14:30.169] receiveMessageFromWorker() for ClusterFuture ...
[16:14:30.169] - Validating connection of MultisessionFuture
[16:14:30.217] - received message: FutureResult
[16:14:30.219] - Received FutureResult
[16:14:30.220] - Erased future from FutureRegistry
[16:14:30.220] result() for ClusterFuture ...
[16:14:30.220] - result already collected: FutureResult
[16:14:30.220] result() for ClusterFuture ... done
[16:14:30.220] receiveMessageFromWorker() for ClusterFuture ... done
[16:14:30.220] result() for ClusterFuture ... done
[16:14:30.220] result() for ClusterFuture ...
[16:14:30.220] - result already collected: FutureResult
[16:14:30.220] result() for ClusterFuture ... done
 [1] " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25"  
 [2] "[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50"  
 [3] " int [1:50] 1 2 3 4 5 6 7 8 9 10 ..."                                             
 [4] "a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 "                  
 [5] "\"Sepal.Length\"\t\"Sepal.Width\"\t\"Petal.Length\"\t\"Petal.Width\"\t\"Species\""
 [6] "\"1\"\t5.1\t3.5\t1.4\t0.2\t\"setosa\""                                            
 [7] "\"2\"\t4.9\t3\t1.4\t0.2\t\"setosa\""                                              
 [8] "\"3\"\t4.7\t3.2\t1.3\t0.2\t\"setosa\""                                            
 [9] "\"4\"\t4.6\t3.1\t1.5\t0.2\t\"setosa\""                                            
[10] "\"5\"\t5\t3.6\t1.4\t0.2\t\"setosa\""                                              
[11] "\"6\"\t5.4\t3.9\t1.7\t0.4\t\"setosa\""                                            
[12] "\"7\"\t4.6\t3.4\t1.4\t0.3\t\"setosa\""                                            
[13] "\"8\"\t5\t3.4\t1.5\t0.2\t\"setosa\""                                              
[14] "\"9\"\t4.4\t2.9\t1.4\t0.2\t\"setosa\""                                            
[15] "\"10\"\t4.9\t3.1\t1.5\t0.1\t\"setosa\""                                           
- stdout = structure(TRUE, drop = TRUE)
[16:14:30.221] getGlobalsAndPackages() ...
[16:14:30.221] Searching for globals...
[16:14:30.221] - globals found: [1] ‘print’
[16:14:30.222] Searching for globals ... DONE
[16:14:30.222] Resolving globals: FALSE
[16:14:30.222] 
[16:14:30.222] 
[16:14:30.222] getGlobalsAndPackages() ... DONE
[16:14:30.222] run() for ‘Future’ ...
[16:14:30.222] - state: ‘created’
[16:14:30.222] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:14:30.236] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:14:30.237] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:14:30.237]   - Field: ‘node’
[16:14:30.237]   - Field: ‘label’
[16:14:30.237]   - Field: ‘local’
[16:14:30.237]   - Field: ‘owner’
[16:14:30.237]   - Field: ‘envir’
[16:14:30.237]   - Field: ‘workers’
[16:14:30.237]   - Field: ‘packages’
[16:14:30.237]   - Field: ‘gc’
[16:14:30.237]   - Field: ‘conditions’
[16:14:30.238]   - Field: ‘persistent’
[16:14:30.238]   - Field: ‘expr’
[16:14:30.238]   - Field: ‘uuid’
[16:14:30.238]   - Field: ‘seed’
[16:14:30.238]   - Field: ‘version’
[16:14:30.238]   - Field: ‘result’
[16:14:30.238]   - Field: ‘asynchronous’
[16:14:30.238]   - Field: ‘calls’
[16:14:30.238]   - Field: ‘globals’
[16:14:30.238]   - Field: ‘stdout’
[16:14:30.238]   - Field: ‘earlySignal’
[16:14:30.239]   - Field: ‘lazy’
[16:14:30.239]   - Field: ‘state’
[16:14:30.239] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:14:30.239] - Launch lazy future ...
[16:14:30.239] Packages needed by the future expression (n = 0): <none>
[16:14:30.239] Packages needed by future strategies (n = 0): <none>
[16:14:30.240] {
[16:14:30.240]     {
[16:14:30.240]         {
[16:14:30.240]             ...future.startTime <- base::Sys.time()
[16:14:30.240]             {
[16:14:30.240]                 {
[16:14:30.240]                   {
[16:14:30.240]                     {
[16:14:30.240]                       base::local({
[16:14:30.240]                         has_future <- base::requireNamespace("future", 
[16:14:30.240]                           quietly = TRUE)
[16:14:30.240]                         if (has_future) {
[16:14:30.240]                           ns <- base::getNamespace("future")
[16:14:30.240]                           version <- ns[[".package"]][["version"]]
[16:14:30.240]                           if (is.null(version)) 
[16:14:30.240]                             version <- utils::packageVersion("future")
[16:14:30.240]                         }
[16:14:30.240]                         else {
[16:14:30.240]                           version <- NULL
[16:14:30.240]                         }
[16:14:30.240]                         if (!has_future || version < "1.8.0") {
[16:14:30.240]                           info <- base::c(r_version = base::gsub("R version ", 
[16:14:30.240]                             "", base::R.version$version.string), 
[16:14:30.240]                             platform = base::sprintf("%s (%s-bit)", 
[16:14:30.240]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:14:30.240]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:30.240]                               "release", "version")], collapse = " "), 
[16:14:30.240]                             hostname = base::Sys.info()[["nodename"]])
[16:14:30.240]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:14:30.240]                             info)
[16:14:30.240]                           info <- base::paste(info, collapse = "; ")
[16:14:30.240]                           if (!has_future) {
[16:14:30.240]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:30.240]                               info)
[16:14:30.240]                           }
[16:14:30.240]                           else {
[16:14:30.240]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:30.240]                               info, version)
[16:14:30.240]                           }
[16:14:30.240]                           base::stop(msg)
[16:14:30.240]                         }
[16:14:30.240]                       })
[16:14:30.240]                     }
[16:14:30.240]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:14:30.240]                     base::options(mc.cores = 1L)
[16:14:30.240]                   }
[16:14:30.240]                   options(future.plan = NULL)
[16:14:30.240]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:30.240]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:30.240]                 }
[16:14:30.240]                 ...future.workdir <- getwd()
[16:14:30.240]             }
[16:14:30.240]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:30.240]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:30.240]         }
[16:14:30.240]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:30.240]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:30.240]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:30.240]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:30.240]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:30.240]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:30.240]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:30.240]             base::names(...future.oldOptions))
[16:14:30.240]     }
[16:14:30.240]     if (FALSE) {
[16:14:30.240]     }
[16:14:30.240]     else {
[16:14:30.240]         if (TRUE) {
[16:14:30.240]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:30.240]                 open = "w")
[16:14:30.240]         }
[16:14:30.240]         else {
[16:14:30.240]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:30.240]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:30.240]         }
[16:14:30.240]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:30.240]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:30.240]             base::sink(type = "output", split = FALSE)
[16:14:30.240]             base::close(...future.stdout)
[16:14:30.240]         }, add = TRUE)
[16:14:30.240]     }
[16:14:30.240]     ...future.frame <- base::sys.nframe()
[16:14:30.240]     ...future.conditions <- base::list()
[16:14:30.240]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:30.240]     if (FALSE) {
[16:14:30.240]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:30.240]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:30.240]     }
[16:14:30.240]     ...future.result <- base::tryCatch({
[16:14:30.240]         base::withCallingHandlers({
[16:14:30.240]             ...future.value <- base::withVisible(base::local({
[16:14:30.240]                 ...future.makeSendCondition <- local({
[16:14:30.240]                   sendCondition <- NULL
[16:14:30.240]                   function(frame = 1L) {
[16:14:30.240]                     if (is.function(sendCondition)) 
[16:14:30.240]                       return(sendCondition)
[16:14:30.240]                     ns <- getNamespace("parallel")
[16:14:30.240]                     if (exists("sendData", mode = "function", 
[16:14:30.240]                       envir = ns)) {
[16:14:30.240]                       parallel_sendData <- get("sendData", mode = "function", 
[16:14:30.240]                         envir = ns)
[16:14:30.240]                       envir <- sys.frame(frame)
[16:14:30.240]                       master <- NULL
[16:14:30.240]                       while (!identical(envir, .GlobalEnv) && 
[16:14:30.240]                         !identical(envir, emptyenv())) {
[16:14:30.240]                         if (exists("master", mode = "list", envir = envir, 
[16:14:30.240]                           inherits = FALSE)) {
[16:14:30.240]                           master <- get("master", mode = "list", 
[16:14:30.240]                             envir = envir, inherits = FALSE)
[16:14:30.240]                           if (inherits(master, c("SOCKnode", 
[16:14:30.240]                             "SOCK0node"))) {
[16:14:30.240]                             sendCondition <<- function(cond) {
[16:14:30.240]                               data <- list(type = "VALUE", value = cond, 
[16:14:30.240]                                 success = TRUE)
[16:14:30.240]                               parallel_sendData(master, data)
[16:14:30.240]                             }
[16:14:30.240]                             return(sendCondition)
[16:14:30.240]                           }
[16:14:30.240]                         }
[16:14:30.240]                         frame <- frame + 1L
[16:14:30.240]                         envir <- sys.frame(frame)
[16:14:30.240]                       }
[16:14:30.240]                     }
[16:14:30.240]                     sendCondition <<- function(cond) NULL
[16:14:30.240]                   }
[16:14:30.240]                 })
[16:14:30.240]                 withCallingHandlers({
[16:14:30.240]                   print(42)
[16:14:30.240]                 }, immediateCondition = function(cond) {
[16:14:30.240]                   sendCondition <- ...future.makeSendCondition()
[16:14:30.240]                   sendCondition(cond)
[16:14:30.240]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:30.240]                   {
[16:14:30.240]                     inherits <- base::inherits
[16:14:30.240]                     invokeRestart <- base::invokeRestart
[16:14:30.240]                     is.null <- base::is.null
[16:14:30.240]                     muffled <- FALSE
[16:14:30.240]                     if (inherits(cond, "message")) {
[16:14:30.240]                       muffled <- grepl(pattern, "muffleMessage")
[16:14:30.240]                       if (muffled) 
[16:14:30.240]                         invokeRestart("muffleMessage")
[16:14:30.240]                     }
[16:14:30.240]                     else if (inherits(cond, "warning")) {
[16:14:30.240]                       muffled <- grepl(pattern, "muffleWarning")
[16:14:30.240]                       if (muffled) 
[16:14:30.240]                         invokeRestart("muffleWarning")
[16:14:30.240]                     }
[16:14:30.240]                     else if (inherits(cond, "condition")) {
[16:14:30.240]                       if (!is.null(pattern)) {
[16:14:30.240]                         computeRestarts <- base::computeRestarts
[16:14:30.240]                         grepl <- base::grepl
[16:14:30.240]                         restarts <- computeRestarts(cond)
[16:14:30.240]                         for (restart in restarts) {
[16:14:30.240]                           name <- restart$name
[16:14:30.240]                           if (is.null(name)) 
[16:14:30.240]                             next
[16:14:30.240]                           if (!grepl(pattern, name)) 
[16:14:30.240]                             next
[16:14:30.240]                           invokeRestart(restart)
[16:14:30.240]                           muffled <- TRUE
[16:14:30.240]                           break
[16:14:30.240]                         }
[16:14:30.240]                       }
[16:14:30.240]                     }
[16:14:30.240]                     invisible(muffled)
[16:14:30.240]                   }
[16:14:30.240]                   muffleCondition(cond)
[16:14:30.240]                 })
[16:14:30.240]             }))
[16:14:30.240]             future::FutureResult(value = ...future.value$value, 
[16:14:30.240]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:30.240]                   ...future.rng), globalenv = if (FALSE) 
[16:14:30.240]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:30.240]                     ...future.globalenv.names))
[16:14:30.240]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:30.240]         }, condition = base::local({
[16:14:30.240]             c <- base::c
[16:14:30.240]             inherits <- base::inherits
[16:14:30.240]             invokeRestart <- base::invokeRestart
[16:14:30.240]             length <- base::length
[16:14:30.240]             list <- base::list
[16:14:30.240]             seq.int <- base::seq.int
[16:14:30.240]             signalCondition <- base::signalCondition
[16:14:30.240]             sys.calls <- base::sys.calls
[16:14:30.240]             `[[` <- base::`[[`
[16:14:30.240]             `+` <- base::`+`
[16:14:30.240]             `<<-` <- base::`<<-`
[16:14:30.240]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:30.240]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:30.240]                   3L)]
[16:14:30.240]             }
[16:14:30.240]             function(cond) {
[16:14:30.240]                 is_error <- inherits(cond, "error")
[16:14:30.240]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:30.240]                   NULL)
[16:14:30.240]                 if (is_error) {
[16:14:30.240]                   sessionInformation <- function() {
[16:14:30.240]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:30.240]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:30.240]                       search = base::search(), system = base::Sys.info())
[16:14:30.240]                   }
[16:14:30.240]                   ...future.conditions[[length(...future.conditions) + 
[16:14:30.240]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:30.240]                     cond$call), session = sessionInformation(), 
[16:14:30.240]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:30.240]                   signalCondition(cond)
[16:14:30.240]                 }
[16:14:30.240]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:30.240]                 "immediateCondition"))) {
[16:14:30.240]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:30.240]                   ...future.conditions[[length(...future.conditions) + 
[16:14:30.240]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:30.240]                   if (TRUE && !signal) {
[16:14:30.240]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:30.240]                     {
[16:14:30.240]                       inherits <- base::inherits
[16:14:30.240]                       invokeRestart <- base::invokeRestart
[16:14:30.240]                       is.null <- base::is.null
[16:14:30.240]                       muffled <- FALSE
[16:14:30.240]                       if (inherits(cond, "message")) {
[16:14:30.240]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:30.240]                         if (muffled) 
[16:14:30.240]                           invokeRestart("muffleMessage")
[16:14:30.240]                       }
[16:14:30.240]                       else if (inherits(cond, "warning")) {
[16:14:30.240]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:30.240]                         if (muffled) 
[16:14:30.240]                           invokeRestart("muffleWarning")
[16:14:30.240]                       }
[16:14:30.240]                       else if (inherits(cond, "condition")) {
[16:14:30.240]                         if (!is.null(pattern)) {
[16:14:30.240]                           computeRestarts <- base::computeRestarts
[16:14:30.240]                           grepl <- base::grepl
[16:14:30.240]                           restarts <- computeRestarts(cond)
[16:14:30.240]                           for (restart in restarts) {
[16:14:30.240]                             name <- restart$name
[16:14:30.240]                             if (is.null(name)) 
[16:14:30.240]                               next
[16:14:30.240]                             if (!grepl(pattern, name)) 
[16:14:30.240]                               next
[16:14:30.240]                             invokeRestart(restart)
[16:14:30.240]                             muffled <- TRUE
[16:14:30.240]                             break
[16:14:30.240]                           }
[16:14:30.240]                         }
[16:14:30.240]                       }
[16:14:30.240]                       invisible(muffled)
[16:14:30.240]                     }
[16:14:30.240]                     muffleCondition(cond, pattern = "^muffle")
[16:14:30.240]                   }
[16:14:30.240]                 }
[16:14:30.240]                 else {
[16:14:30.240]                   if (TRUE) {
[16:14:30.240]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:30.240]                     {
[16:14:30.240]                       inherits <- base::inherits
[16:14:30.240]                       invokeRestart <- base::invokeRestart
[16:14:30.240]                       is.null <- base::is.null
[16:14:30.240]                       muffled <- FALSE
[16:14:30.240]                       if (inherits(cond, "message")) {
[16:14:30.240]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:30.240]                         if (muffled) 
[16:14:30.240]                           invokeRestart("muffleMessage")
[16:14:30.240]                       }
[16:14:30.240]                       else if (inherits(cond, "warning")) {
[16:14:30.240]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:30.240]                         if (muffled) 
[16:14:30.240]                           invokeRestart("muffleWarning")
[16:14:30.240]                       }
[16:14:30.240]                       else if (inherits(cond, "condition")) {
[16:14:30.240]                         if (!is.null(pattern)) {
[16:14:30.240]                           computeRestarts <- base::computeRestarts
[16:14:30.240]                           grepl <- base::grepl
[16:14:30.240]                           restarts <- computeRestarts(cond)
[16:14:30.240]                           for (restart in restarts) {
[16:14:30.240]                             name <- restart$name
[16:14:30.240]                             if (is.null(name)) 
[16:14:30.240]                               next
[16:14:30.240]                             if (!grepl(pattern, name)) 
[16:14:30.240]                               next
[16:14:30.240]                             invokeRestart(restart)
[16:14:30.240]                             muffled <- TRUE
[16:14:30.240]                             break
[16:14:30.240]                           }
[16:14:30.240]                         }
[16:14:30.240]                       }
[16:14:30.240]                       invisible(muffled)
[16:14:30.240]                     }
[16:14:30.240]                     muffleCondition(cond, pattern = "^muffle")
[16:14:30.240]                   }
[16:14:30.240]                 }
[16:14:30.240]             }
[16:14:30.240]         }))
[16:14:30.240]     }, error = function(ex) {
[16:14:30.240]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:30.240]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:30.240]                 ...future.rng), started = ...future.startTime, 
[16:14:30.240]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:30.240]             version = "1.8"), class = "FutureResult")
[16:14:30.240]     }, finally = {
[16:14:30.240]         if (!identical(...future.workdir, getwd())) 
[16:14:30.240]             setwd(...future.workdir)
[16:14:30.240]         {
[16:14:30.240]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:30.240]                 ...future.oldOptions$nwarnings <- NULL
[16:14:30.240]             }
[16:14:30.240]             base::options(...future.oldOptions)
[16:14:30.240]             if (.Platform$OS.type == "windows") {
[16:14:30.240]                 old_names <- names(...future.oldEnvVars)
[16:14:30.240]                 envs <- base::Sys.getenv()
[16:14:30.240]                 names <- names(envs)
[16:14:30.240]                 common <- intersect(names, old_names)
[16:14:30.240]                 added <- setdiff(names, old_names)
[16:14:30.240]                 removed <- setdiff(old_names, names)
[16:14:30.240]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:30.240]                   envs[common]]
[16:14:30.240]                 NAMES <- toupper(changed)
[16:14:30.240]                 args <- list()
[16:14:30.240]                 for (kk in seq_along(NAMES)) {
[16:14:30.240]                   name <- changed[[kk]]
[16:14:30.240]                   NAME <- NAMES[[kk]]
[16:14:30.240]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:30.240]                     next
[16:14:30.240]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:30.240]                 }
[16:14:30.240]                 NAMES <- toupper(added)
[16:14:30.240]                 for (kk in seq_along(NAMES)) {
[16:14:30.240]                   name <- added[[kk]]
[16:14:30.240]                   NAME <- NAMES[[kk]]
[16:14:30.240]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:30.240]                     next
[16:14:30.240]                   args[[name]] <- ""
[16:14:30.240]                 }
[16:14:30.240]                 NAMES <- toupper(removed)
[16:14:30.240]                 for (kk in seq_along(NAMES)) {
[16:14:30.240]                   name <- removed[[kk]]
[16:14:30.240]                   NAME <- NAMES[[kk]]
[16:14:30.240]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:30.240]                     next
[16:14:30.240]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:30.240]                 }
[16:14:30.240]                 if (length(args) > 0) 
[16:14:30.240]                   base::do.call(base::Sys.setenv, args = args)
[16:14:30.240]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:30.240]             }
[16:14:30.240]             else {
[16:14:30.240]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:30.240]             }
[16:14:30.240]             {
[16:14:30.240]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:30.240]                   0L) {
[16:14:30.240]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:30.240]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:30.240]                   base::options(opts)
[16:14:30.240]                 }
[16:14:30.240]                 {
[16:14:30.240]                   {
[16:14:30.240]                     base::options(mc.cores = ...future.mc.cores.old)
[16:14:30.240]                     NULL
[16:14:30.240]                   }
[16:14:30.240]                   options(future.plan = NULL)
[16:14:30.240]                   if (is.na(NA_character_)) 
[16:14:30.240]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:30.240]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:30.240]                   future::plan(list(function (..., workers = availableCores(), 
[16:14:30.240]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:14:30.240]                     envir = parent.frame()) 
[16:14:30.240]                   {
[16:14:30.240]                     if (is.function(workers)) 
[16:14:30.240]                       workers <- workers()
[16:14:30.240]                     workers <- structure(as.integer(workers), 
[16:14:30.240]                       class = class(workers))
[16:14:30.240]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:14:30.240]                       workers >= 1)
[16:14:30.240]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:14:30.240]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:14:30.240]                     }
[16:14:30.240]                     future <- MultisessionFuture(..., workers = workers, 
[16:14:30.240]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:14:30.240]                       envir = envir)
[16:14:30.240]                     if (!future$lazy) 
[16:14:30.240]                       future <- run(future)
[16:14:30.240]                     invisible(future)
[16:14:30.240]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:30.240]                 }
[16:14:30.240]             }
[16:14:30.240]         }
[16:14:30.240]     })
[16:14:30.240]     if (TRUE) {
[16:14:30.240]         base::sink(type = "output", split = FALSE)
[16:14:30.240]         if (TRUE) {
[16:14:30.240]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:30.240]         }
[16:14:30.240]         else {
[16:14:30.240]             ...future.result["stdout"] <- base::list(NULL)
[16:14:30.240]         }
[16:14:30.240]         base::close(...future.stdout)
[16:14:30.240]         ...future.stdout <- NULL
[16:14:30.240]     }
[16:14:30.240]     ...future.result$conditions <- ...future.conditions
[16:14:30.240]     ...future.result$finished <- base::Sys.time()
[16:14:30.240]     ...future.result
[16:14:30.240] }
[16:14:30.243] MultisessionFuture started
[16:14:30.243] - Launch lazy future ... done
[16:14:30.243] run() for ‘MultisessionFuture’ ... done
[16:14:30.243] result() for ClusterFuture ...
[16:14:30.243] receiveMessageFromWorker() for ClusterFuture ...
[16:14:30.243] - Validating connection of MultisessionFuture
[16:14:30.288] - received message: FutureResult
[16:14:30.288] - Received FutureResult
[16:14:30.288] - Erased future from FutureRegistry
[16:14:30.289] result() for ClusterFuture ...
[16:14:30.289] - result already collected: FutureResult
[16:14:30.289] result() for ClusterFuture ... done
[16:14:30.289] receiveMessageFromWorker() for ClusterFuture ... done
[16:14:30.289] result() for ClusterFuture ... done
[16:14:30.289] result() for ClusterFuture ...
[16:14:30.289] - result already collected: FutureResult
[16:14:30.289] result() for ClusterFuture ... done
[16:14:30.289] result() for ClusterFuture ...
[16:14:30.289] - result already collected: FutureResult
[16:14:30.289] result() for ClusterFuture ... done
[1] 42
[16:14:30.290] result() for ClusterFuture ...
[16:14:30.290] - result already collected: FutureResult
[16:14:30.290] result() for ClusterFuture ... done
- stdout = FALSE
[16:14:30.290] getGlobalsAndPackages() ...
[16:14:30.290] Searching for globals...
[16:14:30.293] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[16:14:30.293] Searching for globals ... DONE
[16:14:30.293] Resolving globals: FALSE
[16:14:30.294] 
[16:14:30.294] - packages: [1] ‘utils’
[16:14:30.294] getGlobalsAndPackages() ... DONE
[16:14:30.294] run() for ‘Future’ ...
[16:14:30.294] - state: ‘created’
[16:14:30.294] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:14:30.309] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:14:30.309] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:14:30.309]   - Field: ‘node’
[16:14:30.309]   - Field: ‘label’
[16:14:30.309]   - Field: ‘local’
[16:14:30.309]   - Field: ‘owner’
[16:14:30.309]   - Field: ‘envir’
[16:14:30.310]   - Field: ‘workers’
[16:14:30.310]   - Field: ‘packages’
[16:14:30.310]   - Field: ‘gc’
[16:14:30.310]   - Field: ‘conditions’
[16:14:30.310]   - Field: ‘persistent’
[16:14:30.310]   - Field: ‘expr’
[16:14:30.310]   - Field: ‘uuid’
[16:14:30.310]   - Field: ‘seed’
[16:14:30.310]   - Field: ‘version’
[16:14:30.310]   - Field: ‘result’
[16:14:30.311]   - Field: ‘asynchronous’
[16:14:30.311]   - Field: ‘calls’
[16:14:30.311]   - Field: ‘globals’
[16:14:30.311]   - Field: ‘stdout’
[16:14:30.311]   - Field: ‘earlySignal’
[16:14:30.311]   - Field: ‘lazy’
[16:14:30.311]   - Field: ‘state’
[16:14:30.311] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:14:30.311] - Launch lazy future ...
[16:14:30.311] Packages needed by the future expression (n = 1): ‘utils’
[16:14:30.312] Packages needed by future strategies (n = 0): <none>
[16:14:30.312] {
[16:14:30.312]     {
[16:14:30.312]         {
[16:14:30.312]             ...future.startTime <- base::Sys.time()
[16:14:30.312]             {
[16:14:30.312]                 {
[16:14:30.312]                   {
[16:14:30.312]                     {
[16:14:30.312]                       {
[16:14:30.312]                         base::local({
[16:14:30.312]                           has_future <- base::requireNamespace("future", 
[16:14:30.312]                             quietly = TRUE)
[16:14:30.312]                           if (has_future) {
[16:14:30.312]                             ns <- base::getNamespace("future")
[16:14:30.312]                             version <- ns[[".package"]][["version"]]
[16:14:30.312]                             if (is.null(version)) 
[16:14:30.312]                               version <- utils::packageVersion("future")
[16:14:30.312]                           }
[16:14:30.312]                           else {
[16:14:30.312]                             version <- NULL
[16:14:30.312]                           }
[16:14:30.312]                           if (!has_future || version < "1.8.0") {
[16:14:30.312]                             info <- base::c(r_version = base::gsub("R version ", 
[16:14:30.312]                               "", base::R.version$version.string), 
[16:14:30.312]                               platform = base::sprintf("%s (%s-bit)", 
[16:14:30.312]                                 base::R.version$platform, 8 * 
[16:14:30.312]                                   base::.Machine$sizeof.pointer), 
[16:14:30.312]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:30.312]                                 "release", "version")], collapse = " "), 
[16:14:30.312]                               hostname = base::Sys.info()[["nodename"]])
[16:14:30.312]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:14:30.312]                               info)
[16:14:30.312]                             info <- base::paste(info, collapse = "; ")
[16:14:30.312]                             if (!has_future) {
[16:14:30.312]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:30.312]                                 info)
[16:14:30.312]                             }
[16:14:30.312]                             else {
[16:14:30.312]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:30.312]                                 info, version)
[16:14:30.312]                             }
[16:14:30.312]                             base::stop(msg)
[16:14:30.312]                           }
[16:14:30.312]                         })
[16:14:30.312]                       }
[16:14:30.312]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:14:30.312]                       base::options(mc.cores = 1L)
[16:14:30.312]                     }
[16:14:30.312]                     base::local({
[16:14:30.312]                       for (pkg in "utils") {
[16:14:30.312]                         base::loadNamespace(pkg)
[16:14:30.312]                         base::library(pkg, character.only = TRUE)
[16:14:30.312]                       }
[16:14:30.312]                     })
[16:14:30.312]                   }
[16:14:30.312]                   options(future.plan = NULL)
[16:14:30.312]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:30.312]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:30.312]                 }
[16:14:30.312]                 ...future.workdir <- getwd()
[16:14:30.312]             }
[16:14:30.312]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:30.312]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:30.312]         }
[16:14:30.312]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:30.312]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:30.312]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:30.312]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:30.312]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:30.312]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:30.312]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:30.312]             base::names(...future.oldOptions))
[16:14:30.312]     }
[16:14:30.312]     if (FALSE) {
[16:14:30.312]     }
[16:14:30.312]     else {
[16:14:30.312]         if (FALSE) {
[16:14:30.312]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:30.312]                 open = "w")
[16:14:30.312]         }
[16:14:30.312]         else {
[16:14:30.312]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:30.312]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:30.312]         }
[16:14:30.312]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:30.312]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:30.312]             base::sink(type = "output", split = FALSE)
[16:14:30.312]             base::close(...future.stdout)
[16:14:30.312]         }, add = TRUE)
[16:14:30.312]     }
[16:14:30.312]     ...future.frame <- base::sys.nframe()
[16:14:30.312]     ...future.conditions <- base::list()
[16:14:30.312]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:30.312]     if (FALSE) {
[16:14:30.312]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:30.312]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:30.312]     }
[16:14:30.312]     ...future.result <- base::tryCatch({
[16:14:30.312]         base::withCallingHandlers({
[16:14:30.312]             ...future.value <- base::withVisible(base::local({
[16:14:30.312]                 ...future.makeSendCondition <- local({
[16:14:30.312]                   sendCondition <- NULL
[16:14:30.312]                   function(frame = 1L) {
[16:14:30.312]                     if (is.function(sendCondition)) 
[16:14:30.312]                       return(sendCondition)
[16:14:30.312]                     ns <- getNamespace("parallel")
[16:14:30.312]                     if (exists("sendData", mode = "function", 
[16:14:30.312]                       envir = ns)) {
[16:14:30.312]                       parallel_sendData <- get("sendData", mode = "function", 
[16:14:30.312]                         envir = ns)
[16:14:30.312]                       envir <- sys.frame(frame)
[16:14:30.312]                       master <- NULL
[16:14:30.312]                       while (!identical(envir, .GlobalEnv) && 
[16:14:30.312]                         !identical(envir, emptyenv())) {
[16:14:30.312]                         if (exists("master", mode = "list", envir = envir, 
[16:14:30.312]                           inherits = FALSE)) {
[16:14:30.312]                           master <- get("master", mode = "list", 
[16:14:30.312]                             envir = envir, inherits = FALSE)
[16:14:30.312]                           if (inherits(master, c("SOCKnode", 
[16:14:30.312]                             "SOCK0node"))) {
[16:14:30.312]                             sendCondition <<- function(cond) {
[16:14:30.312]                               data <- list(type = "VALUE", value = cond, 
[16:14:30.312]                                 success = TRUE)
[16:14:30.312]                               parallel_sendData(master, data)
[16:14:30.312]                             }
[16:14:30.312]                             return(sendCondition)
[16:14:30.312]                           }
[16:14:30.312]                         }
[16:14:30.312]                         frame <- frame + 1L
[16:14:30.312]                         envir <- sys.frame(frame)
[16:14:30.312]                       }
[16:14:30.312]                     }
[16:14:30.312]                     sendCondition <<- function(cond) NULL
[16:14:30.312]                   }
[16:14:30.312]                 })
[16:14:30.312]                 withCallingHandlers({
[16:14:30.312]                   {
[16:14:30.312]                     print(1:50)
[16:14:30.312]                     str(1:50)
[16:14:30.312]                     cat(letters, sep = "-")
[16:14:30.312]                     cat(1:6, collapse = "\n")
[16:14:30.312]                     write.table(datasets::iris[1:10, ], sep = "\t")
[16:14:30.312]                     42L
[16:14:30.312]                   }
[16:14:30.312]                 }, immediateCondition = function(cond) {
[16:14:30.312]                   sendCondition <- ...future.makeSendCondition()
[16:14:30.312]                   sendCondition(cond)
[16:14:30.312]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:30.312]                   {
[16:14:30.312]                     inherits <- base::inherits
[16:14:30.312]                     invokeRestart <- base::invokeRestart
[16:14:30.312]                     is.null <- base::is.null
[16:14:30.312]                     muffled <- FALSE
[16:14:30.312]                     if (inherits(cond, "message")) {
[16:14:30.312]                       muffled <- grepl(pattern, "muffleMessage")
[16:14:30.312]                       if (muffled) 
[16:14:30.312]                         invokeRestart("muffleMessage")
[16:14:30.312]                     }
[16:14:30.312]                     else if (inherits(cond, "warning")) {
[16:14:30.312]                       muffled <- grepl(pattern, "muffleWarning")
[16:14:30.312]                       if (muffled) 
[16:14:30.312]                         invokeRestart("muffleWarning")
[16:14:30.312]                     }
[16:14:30.312]                     else if (inherits(cond, "condition")) {
[16:14:30.312]                       if (!is.null(pattern)) {
[16:14:30.312]                         computeRestarts <- base::computeRestarts
[16:14:30.312]                         grepl <- base::grepl
[16:14:30.312]                         restarts <- computeRestarts(cond)
[16:14:30.312]                         for (restart in restarts) {
[16:14:30.312]                           name <- restart$name
[16:14:30.312]                           if (is.null(name)) 
[16:14:30.312]                             next
[16:14:30.312]                           if (!grepl(pattern, name)) 
[16:14:30.312]                             next
[16:14:30.312]                           invokeRestart(restart)
[16:14:30.312]                           muffled <- TRUE
[16:14:30.312]                           break
[16:14:30.312]                         }
[16:14:30.312]                       }
[16:14:30.312]                     }
[16:14:30.312]                     invisible(muffled)
[16:14:30.312]                   }
[16:14:30.312]                   muffleCondition(cond)
[16:14:30.312]                 })
[16:14:30.312]             }))
[16:14:30.312]             future::FutureResult(value = ...future.value$value, 
[16:14:30.312]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:30.312]                   ...future.rng), globalenv = if (FALSE) 
[16:14:30.312]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:30.312]                     ...future.globalenv.names))
[16:14:30.312]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:30.312]         }, condition = base::local({
[16:14:30.312]             c <- base::c
[16:14:30.312]             inherits <- base::inherits
[16:14:30.312]             invokeRestart <- base::invokeRestart
[16:14:30.312]             length <- base::length
[16:14:30.312]             list <- base::list
[16:14:30.312]             seq.int <- base::seq.int
[16:14:30.312]             signalCondition <- base::signalCondition
[16:14:30.312]             sys.calls <- base::sys.calls
[16:14:30.312]             `[[` <- base::`[[`
[16:14:30.312]             `+` <- base::`+`
[16:14:30.312]             `<<-` <- base::`<<-`
[16:14:30.312]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:30.312]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:30.312]                   3L)]
[16:14:30.312]             }
[16:14:30.312]             function(cond) {
[16:14:30.312]                 is_error <- inherits(cond, "error")
[16:14:30.312]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:30.312]                   NULL)
[16:14:30.312]                 if (is_error) {
[16:14:30.312]                   sessionInformation <- function() {
[16:14:30.312]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:30.312]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:30.312]                       search = base::search(), system = base::Sys.info())
[16:14:30.312]                   }
[16:14:30.312]                   ...future.conditions[[length(...future.conditions) + 
[16:14:30.312]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:30.312]                     cond$call), session = sessionInformation(), 
[16:14:30.312]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:30.312]                   signalCondition(cond)
[16:14:30.312]                 }
[16:14:30.312]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:30.312]                 "immediateCondition"))) {
[16:14:30.312]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:30.312]                   ...future.conditions[[length(...future.conditions) + 
[16:14:30.312]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:30.312]                   if (TRUE && !signal) {
[16:14:30.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:30.312]                     {
[16:14:30.312]                       inherits <- base::inherits
[16:14:30.312]                       invokeRestart <- base::invokeRestart
[16:14:30.312]                       is.null <- base::is.null
[16:14:30.312]                       muffled <- FALSE
[16:14:30.312]                       if (inherits(cond, "message")) {
[16:14:30.312]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:30.312]                         if (muffled) 
[16:14:30.312]                           invokeRestart("muffleMessage")
[16:14:30.312]                       }
[16:14:30.312]                       else if (inherits(cond, "warning")) {
[16:14:30.312]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:30.312]                         if (muffled) 
[16:14:30.312]                           invokeRestart("muffleWarning")
[16:14:30.312]                       }
[16:14:30.312]                       else if (inherits(cond, "condition")) {
[16:14:30.312]                         if (!is.null(pattern)) {
[16:14:30.312]                           computeRestarts <- base::computeRestarts
[16:14:30.312]                           grepl <- base::grepl
[16:14:30.312]                           restarts <- computeRestarts(cond)
[16:14:30.312]                           for (restart in restarts) {
[16:14:30.312]                             name <- restart$name
[16:14:30.312]                             if (is.null(name)) 
[16:14:30.312]                               next
[16:14:30.312]                             if (!grepl(pattern, name)) 
[16:14:30.312]                               next
[16:14:30.312]                             invokeRestart(restart)
[16:14:30.312]                             muffled <- TRUE
[16:14:30.312]                             break
[16:14:30.312]                           }
[16:14:30.312]                         }
[16:14:30.312]                       }
[16:14:30.312]                       invisible(muffled)
[16:14:30.312]                     }
[16:14:30.312]                     muffleCondition(cond, pattern = "^muffle")
[16:14:30.312]                   }
[16:14:30.312]                 }
[16:14:30.312]                 else {
[16:14:30.312]                   if (TRUE) {
[16:14:30.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:30.312]                     {
[16:14:30.312]                       inherits <- base::inherits
[16:14:30.312]                       invokeRestart <- base::invokeRestart
[16:14:30.312]                       is.null <- base::is.null
[16:14:30.312]                       muffled <- FALSE
[16:14:30.312]                       if (inherits(cond, "message")) {
[16:14:30.312]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:30.312]                         if (muffled) 
[16:14:30.312]                           invokeRestart("muffleMessage")
[16:14:30.312]                       }
[16:14:30.312]                       else if (inherits(cond, "warning")) {
[16:14:30.312]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:30.312]                         if (muffled) 
[16:14:30.312]                           invokeRestart("muffleWarning")
[16:14:30.312]                       }
[16:14:30.312]                       else if (inherits(cond, "condition")) {
[16:14:30.312]                         if (!is.null(pattern)) {
[16:14:30.312]                           computeRestarts <- base::computeRestarts
[16:14:30.312]                           grepl <- base::grepl
[16:14:30.312]                           restarts <- computeRestarts(cond)
[16:14:30.312]                           for (restart in restarts) {
[16:14:30.312]                             name <- restart$name
[16:14:30.312]                             if (is.null(name)) 
[16:14:30.312]                               next
[16:14:30.312]                             if (!grepl(pattern, name)) 
[16:14:30.312]                               next
[16:14:30.312]                             invokeRestart(restart)
[16:14:30.312]                             muffled <- TRUE
[16:14:30.312]                             break
[16:14:30.312]                           }
[16:14:30.312]                         }
[16:14:30.312]                       }
[16:14:30.312]                       invisible(muffled)
[16:14:30.312]                     }
[16:14:30.312]                     muffleCondition(cond, pattern = "^muffle")
[16:14:30.312]                   }
[16:14:30.312]                 }
[16:14:30.312]             }
[16:14:30.312]         }))
[16:14:30.312]     }, error = function(ex) {
[16:14:30.312]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:30.312]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:30.312]                 ...future.rng), started = ...future.startTime, 
[16:14:30.312]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:30.312]             version = "1.8"), class = "FutureResult")
[16:14:30.312]     }, finally = {
[16:14:30.312]         if (!identical(...future.workdir, getwd())) 
[16:14:30.312]             setwd(...future.workdir)
[16:14:30.312]         {
[16:14:30.312]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:30.312]                 ...future.oldOptions$nwarnings <- NULL
[16:14:30.312]             }
[16:14:30.312]             base::options(...future.oldOptions)
[16:14:30.312]             if (.Platform$OS.type == "windows") {
[16:14:30.312]                 old_names <- names(...future.oldEnvVars)
[16:14:30.312]                 envs <- base::Sys.getenv()
[16:14:30.312]                 names <- names(envs)
[16:14:30.312]                 common <- intersect(names, old_names)
[16:14:30.312]                 added <- setdiff(names, old_names)
[16:14:30.312]                 removed <- setdiff(old_names, names)
[16:14:30.312]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:30.312]                   envs[common]]
[16:14:30.312]                 NAMES <- toupper(changed)
[16:14:30.312]                 args <- list()
[16:14:30.312]                 for (kk in seq_along(NAMES)) {
[16:14:30.312]                   name <- changed[[kk]]
[16:14:30.312]                   NAME <- NAMES[[kk]]
[16:14:30.312]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:30.312]                     next
[16:14:30.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:30.312]                 }
[16:14:30.312]                 NAMES <- toupper(added)
[16:14:30.312]                 for (kk in seq_along(NAMES)) {
[16:14:30.312]                   name <- added[[kk]]
[16:14:30.312]                   NAME <- NAMES[[kk]]
[16:14:30.312]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:30.312]                     next
[16:14:30.312]                   args[[name]] <- ""
[16:14:30.312]                 }
[16:14:30.312]                 NAMES <- toupper(removed)
[16:14:30.312]                 for (kk in seq_along(NAMES)) {
[16:14:30.312]                   name <- removed[[kk]]
[16:14:30.312]                   NAME <- NAMES[[kk]]
[16:14:30.312]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:30.312]                     next
[16:14:30.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:30.312]                 }
[16:14:30.312]                 if (length(args) > 0) 
[16:14:30.312]                   base::do.call(base::Sys.setenv, args = args)
[16:14:30.312]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:30.312]             }
[16:14:30.312]             else {
[16:14:30.312]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:30.312]             }
[16:14:30.312]             {
[16:14:30.312]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:30.312]                   0L) {
[16:14:30.312]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:30.312]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:30.312]                   base::options(opts)
[16:14:30.312]                 }
[16:14:30.312]                 {
[16:14:30.312]                   {
[16:14:30.312]                     base::options(mc.cores = ...future.mc.cores.old)
[16:14:30.312]                     NULL
[16:14:30.312]                   }
[16:14:30.312]                   options(future.plan = NULL)
[16:14:30.312]                   if (is.na(NA_character_)) 
[16:14:30.312]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:30.312]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:30.312]                   future::plan(list(function (..., workers = availableCores(), 
[16:14:30.312]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:14:30.312]                     envir = parent.frame()) 
[16:14:30.312]                   {
[16:14:30.312]                     if (is.function(workers)) 
[16:14:30.312]                       workers <- workers()
[16:14:30.312]                     workers <- structure(as.integer(workers), 
[16:14:30.312]                       class = class(workers))
[16:14:30.312]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:14:30.312]                       workers >= 1)
[16:14:30.312]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:14:30.312]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:14:30.312]                     }
[16:14:30.312]                     future <- MultisessionFuture(..., workers = workers, 
[16:14:30.312]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:14:30.312]                       envir = envir)
[16:14:30.312]                     if (!future$lazy) 
[16:14:30.312]                       future <- run(future)
[16:14:30.312]                     invisible(future)
[16:14:30.312]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:30.312]                 }
[16:14:30.312]             }
[16:14:30.312]         }
[16:14:30.312]     })
[16:14:30.312]     if (TRUE) {
[16:14:30.312]         base::sink(type = "output", split = FALSE)
[16:14:30.312]         if (FALSE) {
[16:14:30.312]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:30.312]         }
[16:14:30.312]         else {
[16:14:30.312]             ...future.result["stdout"] <- base::list(NULL)
[16:14:30.312]         }
[16:14:30.312]         base::close(...future.stdout)
[16:14:30.312]         ...future.stdout <- NULL
[16:14:30.312]     }
[16:14:30.312]     ...future.result$conditions <- ...future.conditions
[16:14:30.312]     ...future.result$finished <- base::Sys.time()
[16:14:30.312]     ...future.result
[16:14:30.312] }
[16:14:30.315] MultisessionFuture started
[16:14:30.315] - Launch lazy future ... done
[16:14:30.315] run() for ‘MultisessionFuture’ ... done
[16:14:30.315] result() for ClusterFuture ...
[16:14:30.315] receiveMessageFromWorker() for ClusterFuture ...
[16:14:30.316] - Validating connection of MultisessionFuture
[16:14:30.361] - received message: FutureResult
[16:14:30.361] - Received FutureResult
[16:14:30.361] - Erased future from FutureRegistry
[16:14:30.361] result() for ClusterFuture ...
[16:14:30.361] - result already collected: FutureResult
[16:14:30.361] result() for ClusterFuture ... done
[16:14:30.361] receiveMessageFromWorker() for ClusterFuture ... done
[16:14:30.362] result() for ClusterFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-01-06 16:14:30"
 $ finished    : POSIXct[1:1], format: "2025-01-06 16:14:30"
 $ session_uuid: chr "725930bb-1bfc-1e75-76a7-4452e9fc425d"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "2729ef2608da"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "2729ef2608da" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 92408
  .. ..$ time  : POSIXct[1:1], format: "2025-01-06 16:14:29"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 3 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[16:14:30.369] result() for ClusterFuture ...
[16:14:30.369] - result already collected: FutureResult
[16:14:30.369] result() for ClusterFuture ... done
[16:14:30.369] result() for ClusterFuture ...
[16:14:30.369] - result already collected: FutureResult
[16:14:30.370] result() for ClusterFuture ... done
[16:14:30.370] getGlobalsAndPackages() ...
[16:14:30.370] Searching for globals...
[16:14:30.373] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[16:14:30.373] Searching for globals ... DONE
[16:14:30.373] Resolving globals: FALSE
[16:14:30.374] 
[16:14:30.374] - packages: [1] ‘utils’
[16:14:30.374] getGlobalsAndPackages() ... DONE
[16:14:30.374] run() for ‘Future’ ...
[16:14:30.374] - state: ‘created’
[16:14:30.374] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:14:30.388] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:14:30.388] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:14:30.389]   - Field: ‘node’
[16:14:30.389]   - Field: ‘label’
[16:14:30.389]   - Field: ‘local’
[16:14:30.389]   - Field: ‘owner’
[16:14:30.389]   - Field: ‘envir’
[16:14:30.389]   - Field: ‘workers’
[16:14:30.389]   - Field: ‘packages’
[16:14:30.389]   - Field: ‘gc’
[16:14:30.389]   - Field: ‘conditions’
[16:14:30.389]   - Field: ‘persistent’
[16:14:30.389]   - Field: ‘expr’
[16:14:30.390]   - Field: ‘uuid’
[16:14:30.390]   - Field: ‘seed’
[16:14:30.390]   - Field: ‘version’
[16:14:30.390]   - Field: ‘result’
[16:14:30.390]   - Field: ‘asynchronous’
[16:14:30.390]   - Field: ‘calls’
[16:14:30.390]   - Field: ‘globals’
[16:14:30.390]   - Field: ‘stdout’
[16:14:30.390]   - Field: ‘earlySignal’
[16:14:30.390]   - Field: ‘lazy’
[16:14:30.390]   - Field: ‘state’
[16:14:30.391] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:14:30.391] - Launch lazy future ...
[16:14:30.391] Packages needed by the future expression (n = 1): ‘utils’
[16:14:30.391] Packages needed by future strategies (n = 0): <none>
[16:14:30.391] {
[16:14:30.391]     {
[16:14:30.391]         {
[16:14:30.391]             ...future.startTime <- base::Sys.time()
[16:14:30.391]             {
[16:14:30.391]                 {
[16:14:30.391]                   {
[16:14:30.391]                     {
[16:14:30.391]                       {
[16:14:30.391]                         base::local({
[16:14:30.391]                           has_future <- base::requireNamespace("future", 
[16:14:30.391]                             quietly = TRUE)
[16:14:30.391]                           if (has_future) {
[16:14:30.391]                             ns <- base::getNamespace("future")
[16:14:30.391]                             version <- ns[[".package"]][["version"]]
[16:14:30.391]                             if (is.null(version)) 
[16:14:30.391]                               version <- utils::packageVersion("future")
[16:14:30.391]                           }
[16:14:30.391]                           else {
[16:14:30.391]                             version <- NULL
[16:14:30.391]                           }
[16:14:30.391]                           if (!has_future || version < "1.8.0") {
[16:14:30.391]                             info <- base::c(r_version = base::gsub("R version ", 
[16:14:30.391]                               "", base::R.version$version.string), 
[16:14:30.391]                               platform = base::sprintf("%s (%s-bit)", 
[16:14:30.391]                                 base::R.version$platform, 8 * 
[16:14:30.391]                                   base::.Machine$sizeof.pointer), 
[16:14:30.391]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:30.391]                                 "release", "version")], collapse = " "), 
[16:14:30.391]                               hostname = base::Sys.info()[["nodename"]])
[16:14:30.391]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:14:30.391]                               info)
[16:14:30.391]                             info <- base::paste(info, collapse = "; ")
[16:14:30.391]                             if (!has_future) {
[16:14:30.391]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:30.391]                                 info)
[16:14:30.391]                             }
[16:14:30.391]                             else {
[16:14:30.391]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:30.391]                                 info, version)
[16:14:30.391]                             }
[16:14:30.391]                             base::stop(msg)
[16:14:30.391]                           }
[16:14:30.391]                         })
[16:14:30.391]                       }
[16:14:30.391]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:14:30.391]                       base::options(mc.cores = 1L)
[16:14:30.391]                     }
[16:14:30.391]                     base::local({
[16:14:30.391]                       for (pkg in "utils") {
[16:14:30.391]                         base::loadNamespace(pkg)
[16:14:30.391]                         base::library(pkg, character.only = TRUE)
[16:14:30.391]                       }
[16:14:30.391]                     })
[16:14:30.391]                   }
[16:14:30.391]                   options(future.plan = NULL)
[16:14:30.391]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:30.391]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:30.391]                 }
[16:14:30.391]                 ...future.workdir <- getwd()
[16:14:30.391]             }
[16:14:30.391]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:30.391]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:30.391]         }
[16:14:30.391]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:30.391]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:30.391]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:30.391]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:30.391]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:30.391]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:30.391]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:30.391]             base::names(...future.oldOptions))
[16:14:30.391]     }
[16:14:30.391]     if (FALSE) {
[16:14:30.391]     }
[16:14:30.391]     else {
[16:14:30.391]         if (FALSE) {
[16:14:30.391]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:30.391]                 open = "w")
[16:14:30.391]         }
[16:14:30.391]         else {
[16:14:30.391]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:30.391]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:30.391]         }
[16:14:30.391]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:30.391]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:30.391]             base::sink(type = "output", split = FALSE)
[16:14:30.391]             base::close(...future.stdout)
[16:14:30.391]         }, add = TRUE)
[16:14:30.391]     }
[16:14:30.391]     ...future.frame <- base::sys.nframe()
[16:14:30.391]     ...future.conditions <- base::list()
[16:14:30.391]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:30.391]     if (FALSE) {
[16:14:30.391]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:30.391]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:30.391]     }
[16:14:30.391]     ...future.result <- base::tryCatch({
[16:14:30.391]         base::withCallingHandlers({
[16:14:30.391]             ...future.value <- base::withVisible(base::local({
[16:14:30.391]                 ...future.makeSendCondition <- local({
[16:14:30.391]                   sendCondition <- NULL
[16:14:30.391]                   function(frame = 1L) {
[16:14:30.391]                     if (is.function(sendCondition)) 
[16:14:30.391]                       return(sendCondition)
[16:14:30.391]                     ns <- getNamespace("parallel")
[16:14:30.391]                     if (exists("sendData", mode = "function", 
[16:14:30.391]                       envir = ns)) {
[16:14:30.391]                       parallel_sendData <- get("sendData", mode = "function", 
[16:14:30.391]                         envir = ns)
[16:14:30.391]                       envir <- sys.frame(frame)
[16:14:30.391]                       master <- NULL
[16:14:30.391]                       while (!identical(envir, .GlobalEnv) && 
[16:14:30.391]                         !identical(envir, emptyenv())) {
[16:14:30.391]                         if (exists("master", mode = "list", envir = envir, 
[16:14:30.391]                           inherits = FALSE)) {
[16:14:30.391]                           master <- get("master", mode = "list", 
[16:14:30.391]                             envir = envir, inherits = FALSE)
[16:14:30.391]                           if (inherits(master, c("SOCKnode", 
[16:14:30.391]                             "SOCK0node"))) {
[16:14:30.391]                             sendCondition <<- function(cond) {
[16:14:30.391]                               data <- list(type = "VALUE", value = cond, 
[16:14:30.391]                                 success = TRUE)
[16:14:30.391]                               parallel_sendData(master, data)
[16:14:30.391]                             }
[16:14:30.391]                             return(sendCondition)
[16:14:30.391]                           }
[16:14:30.391]                         }
[16:14:30.391]                         frame <- frame + 1L
[16:14:30.391]                         envir <- sys.frame(frame)
[16:14:30.391]                       }
[16:14:30.391]                     }
[16:14:30.391]                     sendCondition <<- function(cond) NULL
[16:14:30.391]                   }
[16:14:30.391]                 })
[16:14:30.391]                 withCallingHandlers({
[16:14:30.391]                   {
[16:14:30.391]                     print(1:50)
[16:14:30.391]                     str(1:50)
[16:14:30.391]                     cat(letters, sep = "-")
[16:14:30.391]                     cat(1:6, collapse = "\n")
[16:14:30.391]                     write.table(datasets::iris[1:10, ], sep = "\t")
[16:14:30.391]                     42L
[16:14:30.391]                   }
[16:14:30.391]                 }, immediateCondition = function(cond) {
[16:14:30.391]                   sendCondition <- ...future.makeSendCondition()
[16:14:30.391]                   sendCondition(cond)
[16:14:30.391]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:30.391]                   {
[16:14:30.391]                     inherits <- base::inherits
[16:14:30.391]                     invokeRestart <- base::invokeRestart
[16:14:30.391]                     is.null <- base::is.null
[16:14:30.391]                     muffled <- FALSE
[16:14:30.391]                     if (inherits(cond, "message")) {
[16:14:30.391]                       muffled <- grepl(pattern, "muffleMessage")
[16:14:30.391]                       if (muffled) 
[16:14:30.391]                         invokeRestart("muffleMessage")
[16:14:30.391]                     }
[16:14:30.391]                     else if (inherits(cond, "warning")) {
[16:14:30.391]                       muffled <- grepl(pattern, "muffleWarning")
[16:14:30.391]                       if (muffled) 
[16:14:30.391]                         invokeRestart("muffleWarning")
[16:14:30.391]                     }
[16:14:30.391]                     else if (inherits(cond, "condition")) {
[16:14:30.391]                       if (!is.null(pattern)) {
[16:14:30.391]                         computeRestarts <- base::computeRestarts
[16:14:30.391]                         grepl <- base::grepl
[16:14:30.391]                         restarts <- computeRestarts(cond)
[16:14:30.391]                         for (restart in restarts) {
[16:14:30.391]                           name <- restart$name
[16:14:30.391]                           if (is.null(name)) 
[16:14:30.391]                             next
[16:14:30.391]                           if (!grepl(pattern, name)) 
[16:14:30.391]                             next
[16:14:30.391]                           invokeRestart(restart)
[16:14:30.391]                           muffled <- TRUE
[16:14:30.391]                           break
[16:14:30.391]                         }
[16:14:30.391]                       }
[16:14:30.391]                     }
[16:14:30.391]                     invisible(muffled)
[16:14:30.391]                   }
[16:14:30.391]                   muffleCondition(cond)
[16:14:30.391]                 })
[16:14:30.391]             }))
[16:14:30.391]             future::FutureResult(value = ...future.value$value, 
[16:14:30.391]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:30.391]                   ...future.rng), globalenv = if (FALSE) 
[16:14:30.391]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:30.391]                     ...future.globalenv.names))
[16:14:30.391]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:30.391]         }, condition = base::local({
[16:14:30.391]             c <- base::c
[16:14:30.391]             inherits <- base::inherits
[16:14:30.391]             invokeRestart <- base::invokeRestart
[16:14:30.391]             length <- base::length
[16:14:30.391]             list <- base::list
[16:14:30.391]             seq.int <- base::seq.int
[16:14:30.391]             signalCondition <- base::signalCondition
[16:14:30.391]             sys.calls <- base::sys.calls
[16:14:30.391]             `[[` <- base::`[[`
[16:14:30.391]             `+` <- base::`+`
[16:14:30.391]             `<<-` <- base::`<<-`
[16:14:30.391]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:30.391]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:30.391]                   3L)]
[16:14:30.391]             }
[16:14:30.391]             function(cond) {
[16:14:30.391]                 is_error <- inherits(cond, "error")
[16:14:30.391]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:30.391]                   NULL)
[16:14:30.391]                 if (is_error) {
[16:14:30.391]                   sessionInformation <- function() {
[16:14:30.391]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:30.391]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:30.391]                       search = base::search(), system = base::Sys.info())
[16:14:30.391]                   }
[16:14:30.391]                   ...future.conditions[[length(...future.conditions) + 
[16:14:30.391]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:30.391]                     cond$call), session = sessionInformation(), 
[16:14:30.391]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:30.391]                   signalCondition(cond)
[16:14:30.391]                 }
[16:14:30.391]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:30.391]                 "immediateCondition"))) {
[16:14:30.391]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:30.391]                   ...future.conditions[[length(...future.conditions) + 
[16:14:30.391]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:30.391]                   if (TRUE && !signal) {
[16:14:30.391]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:30.391]                     {
[16:14:30.391]                       inherits <- base::inherits
[16:14:30.391]                       invokeRestart <- base::invokeRestart
[16:14:30.391]                       is.null <- base::is.null
[16:14:30.391]                       muffled <- FALSE
[16:14:30.391]                       if (inherits(cond, "message")) {
[16:14:30.391]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:30.391]                         if (muffled) 
[16:14:30.391]                           invokeRestart("muffleMessage")
[16:14:30.391]                       }
[16:14:30.391]                       else if (inherits(cond, "warning")) {
[16:14:30.391]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:30.391]                         if (muffled) 
[16:14:30.391]                           invokeRestart("muffleWarning")
[16:14:30.391]                       }
[16:14:30.391]                       else if (inherits(cond, "condition")) {
[16:14:30.391]                         if (!is.null(pattern)) {
[16:14:30.391]                           computeRestarts <- base::computeRestarts
[16:14:30.391]                           grepl <- base::grepl
[16:14:30.391]                           restarts <- computeRestarts(cond)
[16:14:30.391]                           for (restart in restarts) {
[16:14:30.391]                             name <- restart$name
[16:14:30.391]                             if (is.null(name)) 
[16:14:30.391]                               next
[16:14:30.391]                             if (!grepl(pattern, name)) 
[16:14:30.391]                               next
[16:14:30.391]                             invokeRestart(restart)
[16:14:30.391]                             muffled <- TRUE
[16:14:30.391]                             break
[16:14:30.391]                           }
[16:14:30.391]                         }
[16:14:30.391]                       }
[16:14:30.391]                       invisible(muffled)
[16:14:30.391]                     }
[16:14:30.391]                     muffleCondition(cond, pattern = "^muffle")
[16:14:30.391]                   }
[16:14:30.391]                 }
[16:14:30.391]                 else {
[16:14:30.391]                   if (TRUE) {
[16:14:30.391]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:30.391]                     {
[16:14:30.391]                       inherits <- base::inherits
[16:14:30.391]                       invokeRestart <- base::invokeRestart
[16:14:30.391]                       is.null <- base::is.null
[16:14:30.391]                       muffled <- FALSE
[16:14:30.391]                       if (inherits(cond, "message")) {
[16:14:30.391]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:30.391]                         if (muffled) 
[16:14:30.391]                           invokeRestart("muffleMessage")
[16:14:30.391]                       }
[16:14:30.391]                       else if (inherits(cond, "warning")) {
[16:14:30.391]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:30.391]                         if (muffled) 
[16:14:30.391]                           invokeRestart("muffleWarning")
[16:14:30.391]                       }
[16:14:30.391]                       else if (inherits(cond, "condition")) {
[16:14:30.391]                         if (!is.null(pattern)) {
[16:14:30.391]                           computeRestarts <- base::computeRestarts
[16:14:30.391]                           grepl <- base::grepl
[16:14:30.391]                           restarts <- computeRestarts(cond)
[16:14:30.391]                           for (restart in restarts) {
[16:14:30.391]                             name <- restart$name
[16:14:30.391]                             if (is.null(name)) 
[16:14:30.391]                               next
[16:14:30.391]                             if (!grepl(pattern, name)) 
[16:14:30.391]                               next
[16:14:30.391]                             invokeRestart(restart)
[16:14:30.391]                             muffled <- TRUE
[16:14:30.391]                             break
[16:14:30.391]                           }
[16:14:30.391]                         }
[16:14:30.391]                       }
[16:14:30.391]                       invisible(muffled)
[16:14:30.391]                     }
[16:14:30.391]                     muffleCondition(cond, pattern = "^muffle")
[16:14:30.391]                   }
[16:14:30.391]                 }
[16:14:30.391]             }
[16:14:30.391]         }))
[16:14:30.391]     }, error = function(ex) {
[16:14:30.391]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:30.391]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:30.391]                 ...future.rng), started = ...future.startTime, 
[16:14:30.391]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:30.391]             version = "1.8"), class = "FutureResult")
[16:14:30.391]     }, finally = {
[16:14:30.391]         if (!identical(...future.workdir, getwd())) 
[16:14:30.391]             setwd(...future.workdir)
[16:14:30.391]         {
[16:14:30.391]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:30.391]                 ...future.oldOptions$nwarnings <- NULL
[16:14:30.391]             }
[16:14:30.391]             base::options(...future.oldOptions)
[16:14:30.391]             if (.Platform$OS.type == "windows") {
[16:14:30.391]                 old_names <- names(...future.oldEnvVars)
[16:14:30.391]                 envs <- base::Sys.getenv()
[16:14:30.391]                 names <- names(envs)
[16:14:30.391]                 common <- intersect(names, old_names)
[16:14:30.391]                 added <- setdiff(names, old_names)
[16:14:30.391]                 removed <- setdiff(old_names, names)
[16:14:30.391]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:30.391]                   envs[common]]
[16:14:30.391]                 NAMES <- toupper(changed)
[16:14:30.391]                 args <- list()
[16:14:30.391]                 for (kk in seq_along(NAMES)) {
[16:14:30.391]                   name <- changed[[kk]]
[16:14:30.391]                   NAME <- NAMES[[kk]]
[16:14:30.391]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:30.391]                     next
[16:14:30.391]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:30.391]                 }
[16:14:30.391]                 NAMES <- toupper(added)
[16:14:30.391]                 for (kk in seq_along(NAMES)) {
[16:14:30.391]                   name <- added[[kk]]
[16:14:30.391]                   NAME <- NAMES[[kk]]
[16:14:30.391]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:30.391]                     next
[16:14:30.391]                   args[[name]] <- ""
[16:14:30.391]                 }
[16:14:30.391]                 NAMES <- toupper(removed)
[16:14:30.391]                 for (kk in seq_along(NAMES)) {
[16:14:30.391]                   name <- removed[[kk]]
[16:14:30.391]                   NAME <- NAMES[[kk]]
[16:14:30.391]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:30.391]                     next
[16:14:30.391]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:30.391]                 }
[16:14:30.391]                 if (length(args) > 0) 
[16:14:30.391]                   base::do.call(base::Sys.setenv, args = args)
[16:14:30.391]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:30.391]             }
[16:14:30.391]             else {
[16:14:30.391]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:30.391]             }
[16:14:30.391]             {
[16:14:30.391]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:30.391]                   0L) {
[16:14:30.391]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:30.391]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:30.391]                   base::options(opts)
[16:14:30.391]                 }
[16:14:30.391]                 {
[16:14:30.391]                   {
[16:14:30.391]                     base::options(mc.cores = ...future.mc.cores.old)
[16:14:30.391]                     NULL
[16:14:30.391]                   }
[16:14:30.391]                   options(future.plan = NULL)
[16:14:30.391]                   if (is.na(NA_character_)) 
[16:14:30.391]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:30.391]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:30.391]                   future::plan(list(function (..., workers = availableCores(), 
[16:14:30.391]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:14:30.391]                     envir = parent.frame()) 
[16:14:30.391]                   {
[16:14:30.391]                     if (is.function(workers)) 
[16:14:30.391]                       workers <- workers()
[16:14:30.391]                     workers <- structure(as.integer(workers), 
[16:14:30.391]                       class = class(workers))
[16:14:30.391]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:14:30.391]                       workers >= 1)
[16:14:30.391]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:14:30.391]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:14:30.391]                     }
[16:14:30.391]                     future <- MultisessionFuture(..., workers = workers, 
[16:14:30.391]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:14:30.391]                       envir = envir)
[16:14:30.391]                     if (!future$lazy) 
[16:14:30.391]                       future <- run(future)
[16:14:30.391]                     invisible(future)
[16:14:30.391]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:30.391]                 }
[16:14:30.391]             }
[16:14:30.391]         }
[16:14:30.391]     })
[16:14:30.391]     if (TRUE) {
[16:14:30.391]         base::sink(type = "output", split = FALSE)
[16:14:30.391]         if (FALSE) {
[16:14:30.391]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:30.391]         }
[16:14:30.391]         else {
[16:14:30.391]             ...future.result["stdout"] <- base::list(NULL)
[16:14:30.391]         }
[16:14:30.391]         base::close(...future.stdout)
[16:14:30.391]         ...future.stdout <- NULL
[16:14:30.391]     }
[16:14:30.391]     ...future.result$conditions <- ...future.conditions
[16:14:30.391]     ...future.result$finished <- base::Sys.time()
[16:14:30.391]     ...future.result
[16:14:30.391] }
[16:14:30.394] MultisessionFuture started
[16:14:30.395] - Launch lazy future ... done
[16:14:30.395] run() for ‘MultisessionFuture’ ... done
[16:14:30.395] result() for ClusterFuture ...
[16:14:30.395] receiveMessageFromWorker() for ClusterFuture ...
[16:14:30.395] - Validating connection of MultisessionFuture
[16:14:30.441] - received message: FutureResult
[16:14:30.441] - Received FutureResult
[16:14:30.441] - Erased future from FutureRegistry
[16:14:30.441] result() for ClusterFuture ...
[16:14:30.441] - result already collected: FutureResult
[16:14:30.441] result() for ClusterFuture ... done
[16:14:30.442] receiveMessageFromWorker() for ClusterFuture ... done
[16:14:30.442] result() for ClusterFuture ... done
[16:14:30.442] result() for ClusterFuture ...
[16:14:30.442] - result already collected: FutureResult
[16:14:30.442] result() for ClusterFuture ... done
- stdout = structure(TRUE, drop = TRUE)
[16:14:30.442] getGlobalsAndPackages() ...
[16:14:30.442] Searching for globals...
[16:14:30.443] - globals found: [1] ‘print’
[16:14:30.443] Searching for globals ... DONE
[16:14:30.443] Resolving globals: FALSE
[16:14:30.443] 
[16:14:30.443] 
[16:14:30.443] getGlobalsAndPackages() ... DONE
[16:14:30.444] run() for ‘Future’ ...
[16:14:30.444] - state: ‘created’
[16:14:30.444] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:14:30.458] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:14:30.458] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:14:30.458]   - Field: ‘node’
[16:14:30.458]   - Field: ‘label’
[16:14:30.458]   - Field: ‘local’
[16:14:30.458]   - Field: ‘owner’
[16:14:30.458]   - Field: ‘envir’
[16:14:30.459]   - Field: ‘workers’
[16:14:30.459]   - Field: ‘packages’
[16:14:30.459]   - Field: ‘gc’
[16:14:30.459]   - Field: ‘conditions’
[16:14:30.459]   - Field: ‘persistent’
[16:14:30.459]   - Field: ‘expr’
[16:14:30.459]   - Field: ‘uuid’
[16:14:30.459]   - Field: ‘seed’
[16:14:30.459]   - Field: ‘version’
[16:14:30.459]   - Field: ‘result’
[16:14:30.459]   - Field: ‘asynchronous’
[16:14:30.460]   - Field: ‘calls’
[16:14:30.460]   - Field: ‘globals’
[16:14:30.460]   - Field: ‘stdout’
[16:14:30.460]   - Field: ‘earlySignal’
[16:14:30.460]   - Field: ‘lazy’
[16:14:30.460]   - Field: ‘state’
[16:14:30.460] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:14:30.460] - Launch lazy future ...
[16:14:30.460] Packages needed by the future expression (n = 0): <none>
[16:14:30.461] Packages needed by future strategies (n = 0): <none>
[16:14:30.461] {
[16:14:30.461]     {
[16:14:30.461]         {
[16:14:30.461]             ...future.startTime <- base::Sys.time()
[16:14:30.461]             {
[16:14:30.461]                 {
[16:14:30.461]                   {
[16:14:30.461]                     {
[16:14:30.461]                       base::local({
[16:14:30.461]                         has_future <- base::requireNamespace("future", 
[16:14:30.461]                           quietly = TRUE)
[16:14:30.461]                         if (has_future) {
[16:14:30.461]                           ns <- base::getNamespace("future")
[16:14:30.461]                           version <- ns[[".package"]][["version"]]
[16:14:30.461]                           if (is.null(version)) 
[16:14:30.461]                             version <- utils::packageVersion("future")
[16:14:30.461]                         }
[16:14:30.461]                         else {
[16:14:30.461]                           version <- NULL
[16:14:30.461]                         }
[16:14:30.461]                         if (!has_future || version < "1.8.0") {
[16:14:30.461]                           info <- base::c(r_version = base::gsub("R version ", 
[16:14:30.461]                             "", base::R.version$version.string), 
[16:14:30.461]                             platform = base::sprintf("%s (%s-bit)", 
[16:14:30.461]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:14:30.461]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:30.461]                               "release", "version")], collapse = " "), 
[16:14:30.461]                             hostname = base::Sys.info()[["nodename"]])
[16:14:30.461]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:14:30.461]                             info)
[16:14:30.461]                           info <- base::paste(info, collapse = "; ")
[16:14:30.461]                           if (!has_future) {
[16:14:30.461]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:30.461]                               info)
[16:14:30.461]                           }
[16:14:30.461]                           else {
[16:14:30.461]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:30.461]                               info, version)
[16:14:30.461]                           }
[16:14:30.461]                           base::stop(msg)
[16:14:30.461]                         }
[16:14:30.461]                       })
[16:14:30.461]                     }
[16:14:30.461]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:14:30.461]                     base::options(mc.cores = 1L)
[16:14:30.461]                   }
[16:14:30.461]                   options(future.plan = NULL)
[16:14:30.461]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:30.461]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:30.461]                 }
[16:14:30.461]                 ...future.workdir <- getwd()
[16:14:30.461]             }
[16:14:30.461]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:30.461]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:30.461]         }
[16:14:30.461]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:30.461]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:30.461]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:30.461]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:30.461]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:30.461]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:30.461]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:30.461]             base::names(...future.oldOptions))
[16:14:30.461]     }
[16:14:30.461]     if (FALSE) {
[16:14:30.461]     }
[16:14:30.461]     else {
[16:14:30.461]         if (TRUE) {
[16:14:30.461]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:30.461]                 open = "w")
[16:14:30.461]         }
[16:14:30.461]         else {
[16:14:30.461]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:30.461]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:30.461]         }
[16:14:30.461]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:30.461]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:30.461]             base::sink(type = "output", split = FALSE)
[16:14:30.461]             base::close(...future.stdout)
[16:14:30.461]         }, add = TRUE)
[16:14:30.461]     }
[16:14:30.461]     ...future.frame <- base::sys.nframe()
[16:14:30.461]     ...future.conditions <- base::list()
[16:14:30.461]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:30.461]     if (FALSE) {
[16:14:30.461]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:30.461]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:30.461]     }
[16:14:30.461]     ...future.result <- base::tryCatch({
[16:14:30.461]         base::withCallingHandlers({
[16:14:30.461]             ...future.value <- base::withVisible(base::local({
[16:14:30.461]                 ...future.makeSendCondition <- local({
[16:14:30.461]                   sendCondition <- NULL
[16:14:30.461]                   function(frame = 1L) {
[16:14:30.461]                     if (is.function(sendCondition)) 
[16:14:30.461]                       return(sendCondition)
[16:14:30.461]                     ns <- getNamespace("parallel")
[16:14:30.461]                     if (exists("sendData", mode = "function", 
[16:14:30.461]                       envir = ns)) {
[16:14:30.461]                       parallel_sendData <- get("sendData", mode = "function", 
[16:14:30.461]                         envir = ns)
[16:14:30.461]                       envir <- sys.frame(frame)
[16:14:30.461]                       master <- NULL
[16:14:30.461]                       while (!identical(envir, .GlobalEnv) && 
[16:14:30.461]                         !identical(envir, emptyenv())) {
[16:14:30.461]                         if (exists("master", mode = "list", envir = envir, 
[16:14:30.461]                           inherits = FALSE)) {
[16:14:30.461]                           master <- get("master", mode = "list", 
[16:14:30.461]                             envir = envir, inherits = FALSE)
[16:14:30.461]                           if (inherits(master, c("SOCKnode", 
[16:14:30.461]                             "SOCK0node"))) {
[16:14:30.461]                             sendCondition <<- function(cond) {
[16:14:30.461]                               data <- list(type = "VALUE", value = cond, 
[16:14:30.461]                                 success = TRUE)
[16:14:30.461]                               parallel_sendData(master, data)
[16:14:30.461]                             }
[16:14:30.461]                             return(sendCondition)
[16:14:30.461]                           }
[16:14:30.461]                         }
[16:14:30.461]                         frame <- frame + 1L
[16:14:30.461]                         envir <- sys.frame(frame)
[16:14:30.461]                       }
[16:14:30.461]                     }
[16:14:30.461]                     sendCondition <<- function(cond) NULL
[16:14:30.461]                   }
[16:14:30.461]                 })
[16:14:30.461]                 withCallingHandlers({
[16:14:30.461]                   print(42)
[16:14:30.461]                 }, immediateCondition = function(cond) {
[16:14:30.461]                   sendCondition <- ...future.makeSendCondition()
[16:14:30.461]                   sendCondition(cond)
[16:14:30.461]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:30.461]                   {
[16:14:30.461]                     inherits <- base::inherits
[16:14:30.461]                     invokeRestart <- base::invokeRestart
[16:14:30.461]                     is.null <- base::is.null
[16:14:30.461]                     muffled <- FALSE
[16:14:30.461]                     if (inherits(cond, "message")) {
[16:14:30.461]                       muffled <- grepl(pattern, "muffleMessage")
[16:14:30.461]                       if (muffled) 
[16:14:30.461]                         invokeRestart("muffleMessage")
[16:14:30.461]                     }
[16:14:30.461]                     else if (inherits(cond, "warning")) {
[16:14:30.461]                       muffled <- grepl(pattern, "muffleWarning")
[16:14:30.461]                       if (muffled) 
[16:14:30.461]                         invokeRestart("muffleWarning")
[16:14:30.461]                     }
[16:14:30.461]                     else if (inherits(cond, "condition")) {
[16:14:30.461]                       if (!is.null(pattern)) {
[16:14:30.461]                         computeRestarts <- base::computeRestarts
[16:14:30.461]                         grepl <- base::grepl
[16:14:30.461]                         restarts <- computeRestarts(cond)
[16:14:30.461]                         for (restart in restarts) {
[16:14:30.461]                           name <- restart$name
[16:14:30.461]                           if (is.null(name)) 
[16:14:30.461]                             next
[16:14:30.461]                           if (!grepl(pattern, name)) 
[16:14:30.461]                             next
[16:14:30.461]                           invokeRestart(restart)
[16:14:30.461]                           muffled <- TRUE
[16:14:30.461]                           break
[16:14:30.461]                         }
[16:14:30.461]                       }
[16:14:30.461]                     }
[16:14:30.461]                     invisible(muffled)
[16:14:30.461]                   }
[16:14:30.461]                   muffleCondition(cond)
[16:14:30.461]                 })
[16:14:30.461]             }))
[16:14:30.461]             future::FutureResult(value = ...future.value$value, 
[16:14:30.461]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:30.461]                   ...future.rng), globalenv = if (FALSE) 
[16:14:30.461]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:30.461]                     ...future.globalenv.names))
[16:14:30.461]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:30.461]         }, condition = base::local({
[16:14:30.461]             c <- base::c
[16:14:30.461]             inherits <- base::inherits
[16:14:30.461]             invokeRestart <- base::invokeRestart
[16:14:30.461]             length <- base::length
[16:14:30.461]             list <- base::list
[16:14:30.461]             seq.int <- base::seq.int
[16:14:30.461]             signalCondition <- base::signalCondition
[16:14:30.461]             sys.calls <- base::sys.calls
[16:14:30.461]             `[[` <- base::`[[`
[16:14:30.461]             `+` <- base::`+`
[16:14:30.461]             `<<-` <- base::`<<-`
[16:14:30.461]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:30.461]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:30.461]                   3L)]
[16:14:30.461]             }
[16:14:30.461]             function(cond) {
[16:14:30.461]                 is_error <- inherits(cond, "error")
[16:14:30.461]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:30.461]                   NULL)
[16:14:30.461]                 if (is_error) {
[16:14:30.461]                   sessionInformation <- function() {
[16:14:30.461]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:30.461]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:30.461]                       search = base::search(), system = base::Sys.info())
[16:14:30.461]                   }
[16:14:30.461]                   ...future.conditions[[length(...future.conditions) + 
[16:14:30.461]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:30.461]                     cond$call), session = sessionInformation(), 
[16:14:30.461]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:30.461]                   signalCondition(cond)
[16:14:30.461]                 }
[16:14:30.461]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:30.461]                 "immediateCondition"))) {
[16:14:30.461]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:30.461]                   ...future.conditions[[length(...future.conditions) + 
[16:14:30.461]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:30.461]                   if (TRUE && !signal) {
[16:14:30.461]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:30.461]                     {
[16:14:30.461]                       inherits <- base::inherits
[16:14:30.461]                       invokeRestart <- base::invokeRestart
[16:14:30.461]                       is.null <- base::is.null
[16:14:30.461]                       muffled <- FALSE
[16:14:30.461]                       if (inherits(cond, "message")) {
[16:14:30.461]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:30.461]                         if (muffled) 
[16:14:30.461]                           invokeRestart("muffleMessage")
[16:14:30.461]                       }
[16:14:30.461]                       else if (inherits(cond, "warning")) {
[16:14:30.461]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:30.461]                         if (muffled) 
[16:14:30.461]                           invokeRestart("muffleWarning")
[16:14:30.461]                       }
[16:14:30.461]                       else if (inherits(cond, "condition")) {
[16:14:30.461]                         if (!is.null(pattern)) {
[16:14:30.461]                           computeRestarts <- base::computeRestarts
[16:14:30.461]                           grepl <- base::grepl
[16:14:30.461]                           restarts <- computeRestarts(cond)
[16:14:30.461]                           for (restart in restarts) {
[16:14:30.461]                             name <- restart$name
[16:14:30.461]                             if (is.null(name)) 
[16:14:30.461]                               next
[16:14:30.461]                             if (!grepl(pattern, name)) 
[16:14:30.461]                               next
[16:14:30.461]                             invokeRestart(restart)
[16:14:30.461]                             muffled <- TRUE
[16:14:30.461]                             break
[16:14:30.461]                           }
[16:14:30.461]                         }
[16:14:30.461]                       }
[16:14:30.461]                       invisible(muffled)
[16:14:30.461]                     }
[16:14:30.461]                     muffleCondition(cond, pattern = "^muffle")
[16:14:30.461]                   }
[16:14:30.461]                 }
[16:14:30.461]                 else {
[16:14:30.461]                   if (TRUE) {
[16:14:30.461]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:30.461]                     {
[16:14:30.461]                       inherits <- base::inherits
[16:14:30.461]                       invokeRestart <- base::invokeRestart
[16:14:30.461]                       is.null <- base::is.null
[16:14:30.461]                       muffled <- FALSE
[16:14:30.461]                       if (inherits(cond, "message")) {
[16:14:30.461]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:30.461]                         if (muffled) 
[16:14:30.461]                           invokeRestart("muffleMessage")
[16:14:30.461]                       }
[16:14:30.461]                       else if (inherits(cond, "warning")) {
[16:14:30.461]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:30.461]                         if (muffled) 
[16:14:30.461]                           invokeRestart("muffleWarning")
[16:14:30.461]                       }
[16:14:30.461]                       else if (inherits(cond, "condition")) {
[16:14:30.461]                         if (!is.null(pattern)) {
[16:14:30.461]                           computeRestarts <- base::computeRestarts
[16:14:30.461]                           grepl <- base::grepl
[16:14:30.461]                           restarts <- computeRestarts(cond)
[16:14:30.461]                           for (restart in restarts) {
[16:14:30.461]                             name <- restart$name
[16:14:30.461]                             if (is.null(name)) 
[16:14:30.461]                               next
[16:14:30.461]                             if (!grepl(pattern, name)) 
[16:14:30.461]                               next
[16:14:30.461]                             invokeRestart(restart)
[16:14:30.461]                             muffled <- TRUE
[16:14:30.461]                             break
[16:14:30.461]                           }
[16:14:30.461]                         }
[16:14:30.461]                       }
[16:14:30.461]                       invisible(muffled)
[16:14:30.461]                     }
[16:14:30.461]                     muffleCondition(cond, pattern = "^muffle")
[16:14:30.461]                   }
[16:14:30.461]                 }
[16:14:30.461]             }
[16:14:30.461]         }))
[16:14:30.461]     }, error = function(ex) {
[16:14:30.461]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:30.461]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:30.461]                 ...future.rng), started = ...future.startTime, 
[16:14:30.461]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:30.461]             version = "1.8"), class = "FutureResult")
[16:14:30.461]     }, finally = {
[16:14:30.461]         if (!identical(...future.workdir, getwd())) 
[16:14:30.461]             setwd(...future.workdir)
[16:14:30.461]         {
[16:14:30.461]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:30.461]                 ...future.oldOptions$nwarnings <- NULL
[16:14:30.461]             }
[16:14:30.461]             base::options(...future.oldOptions)
[16:14:30.461]             if (.Platform$OS.type == "windows") {
[16:14:30.461]                 old_names <- names(...future.oldEnvVars)
[16:14:30.461]                 envs <- base::Sys.getenv()
[16:14:30.461]                 names <- names(envs)
[16:14:30.461]                 common <- intersect(names, old_names)
[16:14:30.461]                 added <- setdiff(names, old_names)
[16:14:30.461]                 removed <- setdiff(old_names, names)
[16:14:30.461]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:30.461]                   envs[common]]
[16:14:30.461]                 NAMES <- toupper(changed)
[16:14:30.461]                 args <- list()
[16:14:30.461]                 for (kk in seq_along(NAMES)) {
[16:14:30.461]                   name <- changed[[kk]]
[16:14:30.461]                   NAME <- NAMES[[kk]]
[16:14:30.461]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:30.461]                     next
[16:14:30.461]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:30.461]                 }
[16:14:30.461]                 NAMES <- toupper(added)
[16:14:30.461]                 for (kk in seq_along(NAMES)) {
[16:14:30.461]                   name <- added[[kk]]
[16:14:30.461]                   NAME <- NAMES[[kk]]
[16:14:30.461]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:30.461]                     next
[16:14:30.461]                   args[[name]] <- ""
[16:14:30.461]                 }
[16:14:30.461]                 NAMES <- toupper(removed)
[16:14:30.461]                 for (kk in seq_along(NAMES)) {
[16:14:30.461]                   name <- removed[[kk]]
[16:14:30.461]                   NAME <- NAMES[[kk]]
[16:14:30.461]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:30.461]                     next
[16:14:30.461]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:30.461]                 }
[16:14:30.461]                 if (length(args) > 0) 
[16:14:30.461]                   base::do.call(base::Sys.setenv, args = args)
[16:14:30.461]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:30.461]             }
[16:14:30.461]             else {
[16:14:30.461]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:30.461]             }
[16:14:30.461]             {
[16:14:30.461]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:30.461]                   0L) {
[16:14:30.461]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:30.461]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:30.461]                   base::options(opts)
[16:14:30.461]                 }
[16:14:30.461]                 {
[16:14:30.461]                   {
[16:14:30.461]                     base::options(mc.cores = ...future.mc.cores.old)
[16:14:30.461]                     NULL
[16:14:30.461]                   }
[16:14:30.461]                   options(future.plan = NULL)
[16:14:30.461]                   if (is.na(NA_character_)) 
[16:14:30.461]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:30.461]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:30.461]                   future::plan(list(function (..., workers = availableCores(), 
[16:14:30.461]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:14:30.461]                     envir = parent.frame()) 
[16:14:30.461]                   {
[16:14:30.461]                     if (is.function(workers)) 
[16:14:30.461]                       workers <- workers()
[16:14:30.461]                     workers <- structure(as.integer(workers), 
[16:14:30.461]                       class = class(workers))
[16:14:30.461]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:14:30.461]                       workers >= 1)
[16:14:30.461]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:14:30.461]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:14:30.461]                     }
[16:14:30.461]                     future <- MultisessionFuture(..., workers = workers, 
[16:14:30.461]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:14:30.461]                       envir = envir)
[16:14:30.461]                     if (!future$lazy) 
[16:14:30.461]                       future <- run(future)
[16:14:30.461]                     invisible(future)
[16:14:30.461]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:30.461]                 }
[16:14:30.461]             }
[16:14:30.461]         }
[16:14:30.461]     })
[16:14:30.461]     if (TRUE) {
[16:14:30.461]         base::sink(type = "output", split = FALSE)
[16:14:30.461]         if (TRUE) {
[16:14:30.461]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:30.461]         }
[16:14:30.461]         else {
[16:14:30.461]             ...future.result["stdout"] <- base::list(NULL)
[16:14:30.461]         }
[16:14:30.461]         base::close(...future.stdout)
[16:14:30.461]         ...future.stdout <- NULL
[16:14:30.461]     }
[16:14:30.461]     ...future.result$conditions <- ...future.conditions
[16:14:30.461]     ...future.result$finished <- base::Sys.time()
[16:14:30.461]     ...future.result
[16:14:30.461] }
[16:14:30.464] MultisessionFuture started
[16:14:30.464] - Launch lazy future ... done
[16:14:30.464] run() for ‘MultisessionFuture’ ... done
[16:14:30.465] result() for ClusterFuture ...
[16:14:30.465] receiveMessageFromWorker() for ClusterFuture ...
[16:14:30.465] - Validating connection of MultisessionFuture
[16:14:30.512] - received message: FutureResult
[16:14:30.512] - Received FutureResult
[16:14:30.512] - Erased future from FutureRegistry
[16:14:30.513] result() for ClusterFuture ...
[16:14:30.513] - result already collected: FutureResult
[16:14:30.513] result() for ClusterFuture ... done
[16:14:30.513] receiveMessageFromWorker() for ClusterFuture ... done
[16:14:30.513] result() for ClusterFuture ... done
[16:14:30.513] result() for ClusterFuture ...
[16:14:30.513] - result already collected: FutureResult
[16:14:30.513] result() for ClusterFuture ... done
[16:14:30.513] result() for ClusterFuture ...
[16:14:30.513] - result already collected: FutureResult
[16:14:30.513] result() for ClusterFuture ... done
[1] 42
[16:14:30.514] result() for ClusterFuture ...
[16:14:30.514] - result already collected: FutureResult
[16:14:30.514] result() for ClusterFuture ... done
- stdout = NA
[16:14:30.514] getGlobalsAndPackages() ...
[16:14:30.514] Searching for globals...
[16:14:30.517] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[16:14:30.517] Searching for globals ... DONE
[16:14:30.517] Resolving globals: FALSE
[16:14:30.518] 
[16:14:30.518] - packages: [1] ‘utils’
[16:14:30.518] getGlobalsAndPackages() ... DONE
[16:14:30.518] run() for ‘Future’ ...
[16:14:30.518] - state: ‘created’
[16:14:30.518] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:14:30.533] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:14:30.533] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:14:30.533]   - Field: ‘node’
[16:14:30.533]   - Field: ‘label’
[16:14:30.533]   - Field: ‘local’
[16:14:30.533]   - Field: ‘owner’
[16:14:30.533]   - Field: ‘envir’
[16:14:30.534]   - Field: ‘workers’
[16:14:30.534]   - Field: ‘packages’
[16:14:30.534]   - Field: ‘gc’
[16:14:30.535]   - Field: ‘conditions’
[16:14:30.536]   - Field: ‘persistent’
[16:14:30.536]   - Field: ‘expr’
[16:14:30.536]   - Field: ‘uuid’
[16:14:30.536]   - Field: ‘seed’
[16:14:30.536]   - Field: ‘version’
[16:14:30.536]   - Field: ‘result’
[16:14:30.536]   - Field: ‘asynchronous’
[16:14:30.536]   - Field: ‘calls’
[16:14:30.536]   - Field: ‘globals’
[16:14:30.536]   - Field: ‘stdout’
[16:14:30.537]   - Field: ‘earlySignal’
[16:14:30.537]   - Field: ‘lazy’
[16:14:30.537]   - Field: ‘state’
[16:14:30.537] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:14:30.537] - Launch lazy future ...
[16:14:30.537] Packages needed by the future expression (n = 1): ‘utils’
[16:14:30.537] Packages needed by future strategies (n = 0): <none>
[16:14:30.538] {
[16:14:30.538]     {
[16:14:30.538]         {
[16:14:30.538]             ...future.startTime <- base::Sys.time()
[16:14:30.538]             {
[16:14:30.538]                 {
[16:14:30.538]                   {
[16:14:30.538]                     {
[16:14:30.538]                       {
[16:14:30.538]                         base::local({
[16:14:30.538]                           has_future <- base::requireNamespace("future", 
[16:14:30.538]                             quietly = TRUE)
[16:14:30.538]                           if (has_future) {
[16:14:30.538]                             ns <- base::getNamespace("future")
[16:14:30.538]                             version <- ns[[".package"]][["version"]]
[16:14:30.538]                             if (is.null(version)) 
[16:14:30.538]                               version <- utils::packageVersion("future")
[16:14:30.538]                           }
[16:14:30.538]                           else {
[16:14:30.538]                             version <- NULL
[16:14:30.538]                           }
[16:14:30.538]                           if (!has_future || version < "1.8.0") {
[16:14:30.538]                             info <- base::c(r_version = base::gsub("R version ", 
[16:14:30.538]                               "", base::R.version$version.string), 
[16:14:30.538]                               platform = base::sprintf("%s (%s-bit)", 
[16:14:30.538]                                 base::R.version$platform, 8 * 
[16:14:30.538]                                   base::.Machine$sizeof.pointer), 
[16:14:30.538]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:30.538]                                 "release", "version")], collapse = " "), 
[16:14:30.538]                               hostname = base::Sys.info()[["nodename"]])
[16:14:30.538]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:14:30.538]                               info)
[16:14:30.538]                             info <- base::paste(info, collapse = "; ")
[16:14:30.538]                             if (!has_future) {
[16:14:30.538]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:30.538]                                 info)
[16:14:30.538]                             }
[16:14:30.538]                             else {
[16:14:30.538]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:30.538]                                 info, version)
[16:14:30.538]                             }
[16:14:30.538]                             base::stop(msg)
[16:14:30.538]                           }
[16:14:30.538]                         })
[16:14:30.538]                       }
[16:14:30.538]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:14:30.538]                       base::options(mc.cores = 1L)
[16:14:30.538]                     }
[16:14:30.538]                     base::local({
[16:14:30.538]                       for (pkg in "utils") {
[16:14:30.538]                         base::loadNamespace(pkg)
[16:14:30.538]                         base::library(pkg, character.only = TRUE)
[16:14:30.538]                       }
[16:14:30.538]                     })
[16:14:30.538]                   }
[16:14:30.538]                   options(future.plan = NULL)
[16:14:30.538]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:30.538]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:30.538]                 }
[16:14:30.538]                 ...future.workdir <- getwd()
[16:14:30.538]             }
[16:14:30.538]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:30.538]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:30.538]         }
[16:14:30.538]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:30.538]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:30.538]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:30.538]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:30.538]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:30.538]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:30.538]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:30.538]             base::names(...future.oldOptions))
[16:14:30.538]     }
[16:14:30.538]     if (TRUE) {
[16:14:30.538]     }
[16:14:30.538]     else {
[16:14:30.538]         if (NA) {
[16:14:30.538]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:30.538]                 open = "w")
[16:14:30.538]         }
[16:14:30.538]         else {
[16:14:30.538]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:30.538]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:30.538]         }
[16:14:30.538]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:30.538]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:30.538]             base::sink(type = "output", split = FALSE)
[16:14:30.538]             base::close(...future.stdout)
[16:14:30.538]         }, add = TRUE)
[16:14:30.538]     }
[16:14:30.538]     ...future.frame <- base::sys.nframe()
[16:14:30.538]     ...future.conditions <- base::list()
[16:14:30.538]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:30.538]     if (FALSE) {
[16:14:30.538]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:30.538]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:30.538]     }
[16:14:30.538]     ...future.result <- base::tryCatch({
[16:14:30.538]         base::withCallingHandlers({
[16:14:30.538]             ...future.value <- base::withVisible(base::local({
[16:14:30.538]                 ...future.makeSendCondition <- local({
[16:14:30.538]                   sendCondition <- NULL
[16:14:30.538]                   function(frame = 1L) {
[16:14:30.538]                     if (is.function(sendCondition)) 
[16:14:30.538]                       return(sendCondition)
[16:14:30.538]                     ns <- getNamespace("parallel")
[16:14:30.538]                     if (exists("sendData", mode = "function", 
[16:14:30.538]                       envir = ns)) {
[16:14:30.538]                       parallel_sendData <- get("sendData", mode = "function", 
[16:14:30.538]                         envir = ns)
[16:14:30.538]                       envir <- sys.frame(frame)
[16:14:30.538]                       master <- NULL
[16:14:30.538]                       while (!identical(envir, .GlobalEnv) && 
[16:14:30.538]                         !identical(envir, emptyenv())) {
[16:14:30.538]                         if (exists("master", mode = "list", envir = envir, 
[16:14:30.538]                           inherits = FALSE)) {
[16:14:30.538]                           master <- get("master", mode = "list", 
[16:14:30.538]                             envir = envir, inherits = FALSE)
[16:14:30.538]                           if (inherits(master, c("SOCKnode", 
[16:14:30.538]                             "SOCK0node"))) {
[16:14:30.538]                             sendCondition <<- function(cond) {
[16:14:30.538]                               data <- list(type = "VALUE", value = cond, 
[16:14:30.538]                                 success = TRUE)
[16:14:30.538]                               parallel_sendData(master, data)
[16:14:30.538]                             }
[16:14:30.538]                             return(sendCondition)
[16:14:30.538]                           }
[16:14:30.538]                         }
[16:14:30.538]                         frame <- frame + 1L
[16:14:30.538]                         envir <- sys.frame(frame)
[16:14:30.538]                       }
[16:14:30.538]                     }
[16:14:30.538]                     sendCondition <<- function(cond) NULL
[16:14:30.538]                   }
[16:14:30.538]                 })
[16:14:30.538]                 withCallingHandlers({
[16:14:30.538]                   {
[16:14:30.538]                     print(1:50)
[16:14:30.538]                     str(1:50)
[16:14:30.538]                     cat(letters, sep = "-")
[16:14:30.538]                     cat(1:6, collapse = "\n")
[16:14:30.538]                     write.table(datasets::iris[1:10, ], sep = "\t")
[16:14:30.538]                     42L
[16:14:30.538]                   }
[16:14:30.538]                 }, immediateCondition = function(cond) {
[16:14:30.538]                   sendCondition <- ...future.makeSendCondition()
[16:14:30.538]                   sendCondition(cond)
[16:14:30.538]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:30.538]                   {
[16:14:30.538]                     inherits <- base::inherits
[16:14:30.538]                     invokeRestart <- base::invokeRestart
[16:14:30.538]                     is.null <- base::is.null
[16:14:30.538]                     muffled <- FALSE
[16:14:30.538]                     if (inherits(cond, "message")) {
[16:14:30.538]                       muffled <- grepl(pattern, "muffleMessage")
[16:14:30.538]                       if (muffled) 
[16:14:30.538]                         invokeRestart("muffleMessage")
[16:14:30.538]                     }
[16:14:30.538]                     else if (inherits(cond, "warning")) {
[16:14:30.538]                       muffled <- grepl(pattern, "muffleWarning")
[16:14:30.538]                       if (muffled) 
[16:14:30.538]                         invokeRestart("muffleWarning")
[16:14:30.538]                     }
[16:14:30.538]                     else if (inherits(cond, "condition")) {
[16:14:30.538]                       if (!is.null(pattern)) {
[16:14:30.538]                         computeRestarts <- base::computeRestarts
[16:14:30.538]                         grepl <- base::grepl
[16:14:30.538]                         restarts <- computeRestarts(cond)
[16:14:30.538]                         for (restart in restarts) {
[16:14:30.538]                           name <- restart$name
[16:14:30.538]                           if (is.null(name)) 
[16:14:30.538]                             next
[16:14:30.538]                           if (!grepl(pattern, name)) 
[16:14:30.538]                             next
[16:14:30.538]                           invokeRestart(restart)
[16:14:30.538]                           muffled <- TRUE
[16:14:30.538]                           break
[16:14:30.538]                         }
[16:14:30.538]                       }
[16:14:30.538]                     }
[16:14:30.538]                     invisible(muffled)
[16:14:30.538]                   }
[16:14:30.538]                   muffleCondition(cond)
[16:14:30.538]                 })
[16:14:30.538]             }))
[16:14:30.538]             future::FutureResult(value = ...future.value$value, 
[16:14:30.538]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:30.538]                   ...future.rng), globalenv = if (FALSE) 
[16:14:30.538]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:30.538]                     ...future.globalenv.names))
[16:14:30.538]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:30.538]         }, condition = base::local({
[16:14:30.538]             c <- base::c
[16:14:30.538]             inherits <- base::inherits
[16:14:30.538]             invokeRestart <- base::invokeRestart
[16:14:30.538]             length <- base::length
[16:14:30.538]             list <- base::list
[16:14:30.538]             seq.int <- base::seq.int
[16:14:30.538]             signalCondition <- base::signalCondition
[16:14:30.538]             sys.calls <- base::sys.calls
[16:14:30.538]             `[[` <- base::`[[`
[16:14:30.538]             `+` <- base::`+`
[16:14:30.538]             `<<-` <- base::`<<-`
[16:14:30.538]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:30.538]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:30.538]                   3L)]
[16:14:30.538]             }
[16:14:30.538]             function(cond) {
[16:14:30.538]                 is_error <- inherits(cond, "error")
[16:14:30.538]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:30.538]                   NULL)
[16:14:30.538]                 if (is_error) {
[16:14:30.538]                   sessionInformation <- function() {
[16:14:30.538]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:30.538]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:30.538]                       search = base::search(), system = base::Sys.info())
[16:14:30.538]                   }
[16:14:30.538]                   ...future.conditions[[length(...future.conditions) + 
[16:14:30.538]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:30.538]                     cond$call), session = sessionInformation(), 
[16:14:30.538]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:30.538]                   signalCondition(cond)
[16:14:30.538]                 }
[16:14:30.538]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:30.538]                 "immediateCondition"))) {
[16:14:30.538]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:30.538]                   ...future.conditions[[length(...future.conditions) + 
[16:14:30.538]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:30.538]                   if (TRUE && !signal) {
[16:14:30.538]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:30.538]                     {
[16:14:30.538]                       inherits <- base::inherits
[16:14:30.538]                       invokeRestart <- base::invokeRestart
[16:14:30.538]                       is.null <- base::is.null
[16:14:30.538]                       muffled <- FALSE
[16:14:30.538]                       if (inherits(cond, "message")) {
[16:14:30.538]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:30.538]                         if (muffled) 
[16:14:30.538]                           invokeRestart("muffleMessage")
[16:14:30.538]                       }
[16:14:30.538]                       else if (inherits(cond, "warning")) {
[16:14:30.538]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:30.538]                         if (muffled) 
[16:14:30.538]                           invokeRestart("muffleWarning")
[16:14:30.538]                       }
[16:14:30.538]                       else if (inherits(cond, "condition")) {
[16:14:30.538]                         if (!is.null(pattern)) {
[16:14:30.538]                           computeRestarts <- base::computeRestarts
[16:14:30.538]                           grepl <- base::grepl
[16:14:30.538]                           restarts <- computeRestarts(cond)
[16:14:30.538]                           for (restart in restarts) {
[16:14:30.538]                             name <- restart$name
[16:14:30.538]                             if (is.null(name)) 
[16:14:30.538]                               next
[16:14:30.538]                             if (!grepl(pattern, name)) 
[16:14:30.538]                               next
[16:14:30.538]                             invokeRestart(restart)
[16:14:30.538]                             muffled <- TRUE
[16:14:30.538]                             break
[16:14:30.538]                           }
[16:14:30.538]                         }
[16:14:30.538]                       }
[16:14:30.538]                       invisible(muffled)
[16:14:30.538]                     }
[16:14:30.538]                     muffleCondition(cond, pattern = "^muffle")
[16:14:30.538]                   }
[16:14:30.538]                 }
[16:14:30.538]                 else {
[16:14:30.538]                   if (TRUE) {
[16:14:30.538]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:30.538]                     {
[16:14:30.538]                       inherits <- base::inherits
[16:14:30.538]                       invokeRestart <- base::invokeRestart
[16:14:30.538]                       is.null <- base::is.null
[16:14:30.538]                       muffled <- FALSE
[16:14:30.538]                       if (inherits(cond, "message")) {
[16:14:30.538]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:30.538]                         if (muffled) 
[16:14:30.538]                           invokeRestart("muffleMessage")
[16:14:30.538]                       }
[16:14:30.538]                       else if (inherits(cond, "warning")) {
[16:14:30.538]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:30.538]                         if (muffled) 
[16:14:30.538]                           invokeRestart("muffleWarning")
[16:14:30.538]                       }
[16:14:30.538]                       else if (inherits(cond, "condition")) {
[16:14:30.538]                         if (!is.null(pattern)) {
[16:14:30.538]                           computeRestarts <- base::computeRestarts
[16:14:30.538]                           grepl <- base::grepl
[16:14:30.538]                           restarts <- computeRestarts(cond)
[16:14:30.538]                           for (restart in restarts) {
[16:14:30.538]                             name <- restart$name
[16:14:30.538]                             if (is.null(name)) 
[16:14:30.538]                               next
[16:14:30.538]                             if (!grepl(pattern, name)) 
[16:14:30.538]                               next
[16:14:30.538]                             invokeRestart(restart)
[16:14:30.538]                             muffled <- TRUE
[16:14:30.538]                             break
[16:14:30.538]                           }
[16:14:30.538]                         }
[16:14:30.538]                       }
[16:14:30.538]                       invisible(muffled)
[16:14:30.538]                     }
[16:14:30.538]                     muffleCondition(cond, pattern = "^muffle")
[16:14:30.538]                   }
[16:14:30.538]                 }
[16:14:30.538]             }
[16:14:30.538]         }))
[16:14:30.538]     }, error = function(ex) {
[16:14:30.538]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:30.538]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:30.538]                 ...future.rng), started = ...future.startTime, 
[16:14:30.538]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:30.538]             version = "1.8"), class = "FutureResult")
[16:14:30.538]     }, finally = {
[16:14:30.538]         if (!identical(...future.workdir, getwd())) 
[16:14:30.538]             setwd(...future.workdir)
[16:14:30.538]         {
[16:14:30.538]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:30.538]                 ...future.oldOptions$nwarnings <- NULL
[16:14:30.538]             }
[16:14:30.538]             base::options(...future.oldOptions)
[16:14:30.538]             if (.Platform$OS.type == "windows") {
[16:14:30.538]                 old_names <- names(...future.oldEnvVars)
[16:14:30.538]                 envs <- base::Sys.getenv()
[16:14:30.538]                 names <- names(envs)
[16:14:30.538]                 common <- intersect(names, old_names)
[16:14:30.538]                 added <- setdiff(names, old_names)
[16:14:30.538]                 removed <- setdiff(old_names, names)
[16:14:30.538]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:30.538]                   envs[common]]
[16:14:30.538]                 NAMES <- toupper(changed)
[16:14:30.538]                 args <- list()
[16:14:30.538]                 for (kk in seq_along(NAMES)) {
[16:14:30.538]                   name <- changed[[kk]]
[16:14:30.538]                   NAME <- NAMES[[kk]]
[16:14:30.538]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:30.538]                     next
[16:14:30.538]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:30.538]                 }
[16:14:30.538]                 NAMES <- toupper(added)
[16:14:30.538]                 for (kk in seq_along(NAMES)) {
[16:14:30.538]                   name <- added[[kk]]
[16:14:30.538]                   NAME <- NAMES[[kk]]
[16:14:30.538]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:30.538]                     next
[16:14:30.538]                   args[[name]] <- ""
[16:14:30.538]                 }
[16:14:30.538]                 NAMES <- toupper(removed)
[16:14:30.538]                 for (kk in seq_along(NAMES)) {
[16:14:30.538]                   name <- removed[[kk]]
[16:14:30.538]                   NAME <- NAMES[[kk]]
[16:14:30.538]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:30.538]                     next
[16:14:30.538]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:30.538]                 }
[16:14:30.538]                 if (length(args) > 0) 
[16:14:30.538]                   base::do.call(base::Sys.setenv, args = args)
[16:14:30.538]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:30.538]             }
[16:14:30.538]             else {
[16:14:30.538]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:30.538]             }
[16:14:30.538]             {
[16:14:30.538]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:30.538]                   0L) {
[16:14:30.538]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:30.538]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:30.538]                   base::options(opts)
[16:14:30.538]                 }
[16:14:30.538]                 {
[16:14:30.538]                   {
[16:14:30.538]                     base::options(mc.cores = ...future.mc.cores.old)
[16:14:30.538]                     NULL
[16:14:30.538]                   }
[16:14:30.538]                   options(future.plan = NULL)
[16:14:30.538]                   if (is.na(NA_character_)) 
[16:14:30.538]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:30.538]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:30.538]                   future::plan(list(function (..., workers = availableCores(), 
[16:14:30.538]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:14:30.538]                     envir = parent.frame()) 
[16:14:30.538]                   {
[16:14:30.538]                     if (is.function(workers)) 
[16:14:30.538]                       workers <- workers()
[16:14:30.538]                     workers <- structure(as.integer(workers), 
[16:14:30.538]                       class = class(workers))
[16:14:30.538]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:14:30.538]                       workers >= 1)
[16:14:30.538]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:14:30.538]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:14:30.538]                     }
[16:14:30.538]                     future <- MultisessionFuture(..., workers = workers, 
[16:14:30.538]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:14:30.538]                       envir = envir)
[16:14:30.538]                     if (!future$lazy) 
[16:14:30.538]                       future <- run(future)
[16:14:30.538]                     invisible(future)
[16:14:30.538]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:30.538]                 }
[16:14:30.538]             }
[16:14:30.538]         }
[16:14:30.538]     })
[16:14:30.538]     if (FALSE) {
[16:14:30.538]         base::sink(type = "output", split = FALSE)
[16:14:30.538]         if (NA) {
[16:14:30.538]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:30.538]         }
[16:14:30.538]         else {
[16:14:30.538]             ...future.result["stdout"] <- base::list(NULL)
[16:14:30.538]         }
[16:14:30.538]         base::close(...future.stdout)
[16:14:30.538]         ...future.stdout <- NULL
[16:14:30.538]     }
[16:14:30.538]     ...future.result$conditions <- ...future.conditions
[16:14:30.538]     ...future.result$finished <- base::Sys.time()
[16:14:30.538]     ...future.result
[16:14:30.538] }
[16:14:30.541] MultisessionFuture started
[16:14:30.541] - Launch lazy future ... done
[16:14:30.541] run() for ‘MultisessionFuture’ ... done
[16:14:30.541] result() for ClusterFuture ...
[16:14:30.541] receiveMessageFromWorker() for ClusterFuture ...
[16:14:30.541] - Validating connection of MultisessionFuture
[16:14:30.589] - received message: FutureResult
[16:14:30.589] - Received FutureResult
[16:14:30.589] - Erased future from FutureRegistry
[16:14:30.589] result() for ClusterFuture ...
[16:14:30.589] - result already collected: FutureResult
[16:14:30.589] result() for ClusterFuture ... done
[16:14:30.589] receiveMessageFromWorker() for ClusterFuture ... done
[16:14:30.590] result() for ClusterFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-01-06 16:14:30"
 $ finished    : POSIXct[1:1], format: "2025-01-06 16:14:30"
 $ session_uuid: chr "725930bb-1bfc-1e75-76a7-4452e9fc425d"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "2729ef2608da"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "2729ef2608da" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 92408
  .. ..$ time  : POSIXct[1:1], format: "2025-01-06 16:14:29"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 3 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[16:14:30.597] result() for ClusterFuture ...
[16:14:30.597] - result already collected: FutureResult
[16:14:30.597] result() for ClusterFuture ... done
[16:14:30.597] result() for ClusterFuture ...
[16:14:30.597] - result already collected: FutureResult
[16:14:30.597] result() for ClusterFuture ... done
[16:14:30.598] getGlobalsAndPackages() ...
[16:14:30.598] Searching for globals...
[16:14:30.601] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[16:14:30.601] Searching for globals ... DONE
[16:14:30.601] Resolving globals: FALSE
[16:14:30.601] 
[16:14:30.601] - packages: [1] ‘utils’
[16:14:30.601] getGlobalsAndPackages() ... DONE
[16:14:30.602] run() for ‘Future’ ...
[16:14:30.602] - state: ‘created’
[16:14:30.602] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:14:30.616] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:14:30.616] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:14:30.616]   - Field: ‘node’
[16:14:30.617]   - Field: ‘label’
[16:14:30.617]   - Field: ‘local’
[16:14:30.617]   - Field: ‘owner’
[16:14:30.617]   - Field: ‘envir’
[16:14:30.617]   - Field: ‘workers’
[16:14:30.617]   - Field: ‘packages’
[16:14:30.617]   - Field: ‘gc’
[16:14:30.617]   - Field: ‘conditions’
[16:14:30.617]   - Field: ‘persistent’
[16:14:30.617]   - Field: ‘expr’
[16:14:30.617]   - Field: ‘uuid’
[16:14:30.618]   - Field: ‘seed’
[16:14:30.618]   - Field: ‘version’
[16:14:30.618]   - Field: ‘result’
[16:14:30.618]   - Field: ‘asynchronous’
[16:14:30.618]   - Field: ‘calls’
[16:14:30.618]   - Field: ‘globals’
[16:14:30.618]   - Field: ‘stdout’
[16:14:30.618]   - Field: ‘earlySignal’
[16:14:30.618]   - Field: ‘lazy’
[16:14:30.618]   - Field: ‘state’
[16:14:30.618] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:14:30.619] - Launch lazy future ...
[16:14:30.619] Packages needed by the future expression (n = 1): ‘utils’
[16:14:30.619] Packages needed by future strategies (n = 0): <none>
[16:14:30.619] {
[16:14:30.619]     {
[16:14:30.619]         {
[16:14:30.619]             ...future.startTime <- base::Sys.time()
[16:14:30.619]             {
[16:14:30.619]                 {
[16:14:30.619]                   {
[16:14:30.619]                     {
[16:14:30.619]                       {
[16:14:30.619]                         base::local({
[16:14:30.619]                           has_future <- base::requireNamespace("future", 
[16:14:30.619]                             quietly = TRUE)
[16:14:30.619]                           if (has_future) {
[16:14:30.619]                             ns <- base::getNamespace("future")
[16:14:30.619]                             version <- ns[[".package"]][["version"]]
[16:14:30.619]                             if (is.null(version)) 
[16:14:30.619]                               version <- utils::packageVersion("future")
[16:14:30.619]                           }
[16:14:30.619]                           else {
[16:14:30.619]                             version <- NULL
[16:14:30.619]                           }
[16:14:30.619]                           if (!has_future || version < "1.8.0") {
[16:14:30.619]                             info <- base::c(r_version = base::gsub("R version ", 
[16:14:30.619]                               "", base::R.version$version.string), 
[16:14:30.619]                               platform = base::sprintf("%s (%s-bit)", 
[16:14:30.619]                                 base::R.version$platform, 8 * 
[16:14:30.619]                                   base::.Machine$sizeof.pointer), 
[16:14:30.619]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:30.619]                                 "release", "version")], collapse = " "), 
[16:14:30.619]                               hostname = base::Sys.info()[["nodename"]])
[16:14:30.619]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:14:30.619]                               info)
[16:14:30.619]                             info <- base::paste(info, collapse = "; ")
[16:14:30.619]                             if (!has_future) {
[16:14:30.619]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:30.619]                                 info)
[16:14:30.619]                             }
[16:14:30.619]                             else {
[16:14:30.619]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:30.619]                                 info, version)
[16:14:30.619]                             }
[16:14:30.619]                             base::stop(msg)
[16:14:30.619]                           }
[16:14:30.619]                         })
[16:14:30.619]                       }
[16:14:30.619]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:14:30.619]                       base::options(mc.cores = 1L)
[16:14:30.619]                     }
[16:14:30.619]                     base::local({
[16:14:30.619]                       for (pkg in "utils") {
[16:14:30.619]                         base::loadNamespace(pkg)
[16:14:30.619]                         base::library(pkg, character.only = TRUE)
[16:14:30.619]                       }
[16:14:30.619]                     })
[16:14:30.619]                   }
[16:14:30.619]                   options(future.plan = NULL)
[16:14:30.619]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:30.619]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:30.619]                 }
[16:14:30.619]                 ...future.workdir <- getwd()
[16:14:30.619]             }
[16:14:30.619]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:30.619]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:30.619]         }
[16:14:30.619]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:30.619]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:30.619]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:30.619]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:30.619]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:30.619]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:30.619]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:30.619]             base::names(...future.oldOptions))
[16:14:30.619]     }
[16:14:30.619]     if (TRUE) {
[16:14:30.619]     }
[16:14:30.619]     else {
[16:14:30.619]         if (NA) {
[16:14:30.619]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:30.619]                 open = "w")
[16:14:30.619]         }
[16:14:30.619]         else {
[16:14:30.619]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:30.619]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:30.619]         }
[16:14:30.619]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:30.619]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:30.619]             base::sink(type = "output", split = FALSE)
[16:14:30.619]             base::close(...future.stdout)
[16:14:30.619]         }, add = TRUE)
[16:14:30.619]     }
[16:14:30.619]     ...future.frame <- base::sys.nframe()
[16:14:30.619]     ...future.conditions <- base::list()
[16:14:30.619]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:30.619]     if (FALSE) {
[16:14:30.619]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:30.619]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:30.619]     }
[16:14:30.619]     ...future.result <- base::tryCatch({
[16:14:30.619]         base::withCallingHandlers({
[16:14:30.619]             ...future.value <- base::withVisible(base::local({
[16:14:30.619]                 ...future.makeSendCondition <- local({
[16:14:30.619]                   sendCondition <- NULL
[16:14:30.619]                   function(frame = 1L) {
[16:14:30.619]                     if (is.function(sendCondition)) 
[16:14:30.619]                       return(sendCondition)
[16:14:30.619]                     ns <- getNamespace("parallel")
[16:14:30.619]                     if (exists("sendData", mode = "function", 
[16:14:30.619]                       envir = ns)) {
[16:14:30.619]                       parallel_sendData <- get("sendData", mode = "function", 
[16:14:30.619]                         envir = ns)
[16:14:30.619]                       envir <- sys.frame(frame)
[16:14:30.619]                       master <- NULL
[16:14:30.619]                       while (!identical(envir, .GlobalEnv) && 
[16:14:30.619]                         !identical(envir, emptyenv())) {
[16:14:30.619]                         if (exists("master", mode = "list", envir = envir, 
[16:14:30.619]                           inherits = FALSE)) {
[16:14:30.619]                           master <- get("master", mode = "list", 
[16:14:30.619]                             envir = envir, inherits = FALSE)
[16:14:30.619]                           if (inherits(master, c("SOCKnode", 
[16:14:30.619]                             "SOCK0node"))) {
[16:14:30.619]                             sendCondition <<- function(cond) {
[16:14:30.619]                               data <- list(type = "VALUE", value = cond, 
[16:14:30.619]                                 success = TRUE)
[16:14:30.619]                               parallel_sendData(master, data)
[16:14:30.619]                             }
[16:14:30.619]                             return(sendCondition)
[16:14:30.619]                           }
[16:14:30.619]                         }
[16:14:30.619]                         frame <- frame + 1L
[16:14:30.619]                         envir <- sys.frame(frame)
[16:14:30.619]                       }
[16:14:30.619]                     }
[16:14:30.619]                     sendCondition <<- function(cond) NULL
[16:14:30.619]                   }
[16:14:30.619]                 })
[16:14:30.619]                 withCallingHandlers({
[16:14:30.619]                   {
[16:14:30.619]                     print(1:50)
[16:14:30.619]                     str(1:50)
[16:14:30.619]                     cat(letters, sep = "-")
[16:14:30.619]                     cat(1:6, collapse = "\n")
[16:14:30.619]                     write.table(datasets::iris[1:10, ], sep = "\t")
[16:14:30.619]                     42L
[16:14:30.619]                   }
[16:14:30.619]                 }, immediateCondition = function(cond) {
[16:14:30.619]                   sendCondition <- ...future.makeSendCondition()
[16:14:30.619]                   sendCondition(cond)
[16:14:30.619]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:30.619]                   {
[16:14:30.619]                     inherits <- base::inherits
[16:14:30.619]                     invokeRestart <- base::invokeRestart
[16:14:30.619]                     is.null <- base::is.null
[16:14:30.619]                     muffled <- FALSE
[16:14:30.619]                     if (inherits(cond, "message")) {
[16:14:30.619]                       muffled <- grepl(pattern, "muffleMessage")
[16:14:30.619]                       if (muffled) 
[16:14:30.619]                         invokeRestart("muffleMessage")
[16:14:30.619]                     }
[16:14:30.619]                     else if (inherits(cond, "warning")) {
[16:14:30.619]                       muffled <- grepl(pattern, "muffleWarning")
[16:14:30.619]                       if (muffled) 
[16:14:30.619]                         invokeRestart("muffleWarning")
[16:14:30.619]                     }
[16:14:30.619]                     else if (inherits(cond, "condition")) {
[16:14:30.619]                       if (!is.null(pattern)) {
[16:14:30.619]                         computeRestarts <- base::computeRestarts
[16:14:30.619]                         grepl <- base::grepl
[16:14:30.619]                         restarts <- computeRestarts(cond)
[16:14:30.619]                         for (restart in restarts) {
[16:14:30.619]                           name <- restart$name
[16:14:30.619]                           if (is.null(name)) 
[16:14:30.619]                             next
[16:14:30.619]                           if (!grepl(pattern, name)) 
[16:14:30.619]                             next
[16:14:30.619]                           invokeRestart(restart)
[16:14:30.619]                           muffled <- TRUE
[16:14:30.619]                           break
[16:14:30.619]                         }
[16:14:30.619]                       }
[16:14:30.619]                     }
[16:14:30.619]                     invisible(muffled)
[16:14:30.619]                   }
[16:14:30.619]                   muffleCondition(cond)
[16:14:30.619]                 })
[16:14:30.619]             }))
[16:14:30.619]             future::FutureResult(value = ...future.value$value, 
[16:14:30.619]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:30.619]                   ...future.rng), globalenv = if (FALSE) 
[16:14:30.619]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:30.619]                     ...future.globalenv.names))
[16:14:30.619]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:30.619]         }, condition = base::local({
[16:14:30.619]             c <- base::c
[16:14:30.619]             inherits <- base::inherits
[16:14:30.619]             invokeRestart <- base::invokeRestart
[16:14:30.619]             length <- base::length
[16:14:30.619]             list <- base::list
[16:14:30.619]             seq.int <- base::seq.int
[16:14:30.619]             signalCondition <- base::signalCondition
[16:14:30.619]             sys.calls <- base::sys.calls
[16:14:30.619]             `[[` <- base::`[[`
[16:14:30.619]             `+` <- base::`+`
[16:14:30.619]             `<<-` <- base::`<<-`
[16:14:30.619]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:30.619]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:30.619]                   3L)]
[16:14:30.619]             }
[16:14:30.619]             function(cond) {
[16:14:30.619]                 is_error <- inherits(cond, "error")
[16:14:30.619]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:30.619]                   NULL)
[16:14:30.619]                 if (is_error) {
[16:14:30.619]                   sessionInformation <- function() {
[16:14:30.619]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:30.619]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:30.619]                       search = base::search(), system = base::Sys.info())
[16:14:30.619]                   }
[16:14:30.619]                   ...future.conditions[[length(...future.conditions) + 
[16:14:30.619]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:30.619]                     cond$call), session = sessionInformation(), 
[16:14:30.619]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:30.619]                   signalCondition(cond)
[16:14:30.619]                 }
[16:14:30.619]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:30.619]                 "immediateCondition"))) {
[16:14:30.619]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:30.619]                   ...future.conditions[[length(...future.conditions) + 
[16:14:30.619]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:30.619]                   if (TRUE && !signal) {
[16:14:30.619]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:30.619]                     {
[16:14:30.619]                       inherits <- base::inherits
[16:14:30.619]                       invokeRestart <- base::invokeRestart
[16:14:30.619]                       is.null <- base::is.null
[16:14:30.619]                       muffled <- FALSE
[16:14:30.619]                       if (inherits(cond, "message")) {
[16:14:30.619]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:30.619]                         if (muffled) 
[16:14:30.619]                           invokeRestart("muffleMessage")
[16:14:30.619]                       }
[16:14:30.619]                       else if (inherits(cond, "warning")) {
[16:14:30.619]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:30.619]                         if (muffled) 
[16:14:30.619]                           invokeRestart("muffleWarning")
[16:14:30.619]                       }
[16:14:30.619]                       else if (inherits(cond, "condition")) {
[16:14:30.619]                         if (!is.null(pattern)) {
[16:14:30.619]                           computeRestarts <- base::computeRestarts
[16:14:30.619]                           grepl <- base::grepl
[16:14:30.619]                           restarts <- computeRestarts(cond)
[16:14:30.619]                           for (restart in restarts) {
[16:14:30.619]                             name <- restart$name
[16:14:30.619]                             if (is.null(name)) 
[16:14:30.619]                               next
[16:14:30.619]                             if (!grepl(pattern, name)) 
[16:14:30.619]                               next
[16:14:30.619]                             invokeRestart(restart)
[16:14:30.619]                             muffled <- TRUE
[16:14:30.619]                             break
[16:14:30.619]                           }
[16:14:30.619]                         }
[16:14:30.619]                       }
[16:14:30.619]                       invisible(muffled)
[16:14:30.619]                     }
[16:14:30.619]                     muffleCondition(cond, pattern = "^muffle")
[16:14:30.619]                   }
[16:14:30.619]                 }
[16:14:30.619]                 else {
[16:14:30.619]                   if (TRUE) {
[16:14:30.619]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:30.619]                     {
[16:14:30.619]                       inherits <- base::inherits
[16:14:30.619]                       invokeRestart <- base::invokeRestart
[16:14:30.619]                       is.null <- base::is.null
[16:14:30.619]                       muffled <- FALSE
[16:14:30.619]                       if (inherits(cond, "message")) {
[16:14:30.619]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:30.619]                         if (muffled) 
[16:14:30.619]                           invokeRestart("muffleMessage")
[16:14:30.619]                       }
[16:14:30.619]                       else if (inherits(cond, "warning")) {
[16:14:30.619]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:30.619]                         if (muffled) 
[16:14:30.619]                           invokeRestart("muffleWarning")
[16:14:30.619]                       }
[16:14:30.619]                       else if (inherits(cond, "condition")) {
[16:14:30.619]                         if (!is.null(pattern)) {
[16:14:30.619]                           computeRestarts <- base::computeRestarts
[16:14:30.619]                           grepl <- base::grepl
[16:14:30.619]                           restarts <- computeRestarts(cond)
[16:14:30.619]                           for (restart in restarts) {
[16:14:30.619]                             name <- restart$name
[16:14:30.619]                             if (is.null(name)) 
[16:14:30.619]                               next
[16:14:30.619]                             if (!grepl(pattern, name)) 
[16:14:30.619]                               next
[16:14:30.619]                             invokeRestart(restart)
[16:14:30.619]                             muffled <- TRUE
[16:14:30.619]                             break
[16:14:30.619]                           }
[16:14:30.619]                         }
[16:14:30.619]                       }
[16:14:30.619]                       invisible(muffled)
[16:14:30.619]                     }
[16:14:30.619]                     muffleCondition(cond, pattern = "^muffle")
[16:14:30.619]                   }
[16:14:30.619]                 }
[16:14:30.619]             }
[16:14:30.619]         }))
[16:14:30.619]     }, error = function(ex) {
[16:14:30.619]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:30.619]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:30.619]                 ...future.rng), started = ...future.startTime, 
[16:14:30.619]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:30.619]             version = "1.8"), class = "FutureResult")
[16:14:30.619]     }, finally = {
[16:14:30.619]         if (!identical(...future.workdir, getwd())) 
[16:14:30.619]             setwd(...future.workdir)
[16:14:30.619]         {
[16:14:30.619]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:30.619]                 ...future.oldOptions$nwarnings <- NULL
[16:14:30.619]             }
[16:14:30.619]             base::options(...future.oldOptions)
[16:14:30.619]             if (.Platform$OS.type == "windows") {
[16:14:30.619]                 old_names <- names(...future.oldEnvVars)
[16:14:30.619]                 envs <- base::Sys.getenv()
[16:14:30.619]                 names <- names(envs)
[16:14:30.619]                 common <- intersect(names, old_names)
[16:14:30.619]                 added <- setdiff(names, old_names)
[16:14:30.619]                 removed <- setdiff(old_names, names)
[16:14:30.619]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:30.619]                   envs[common]]
[16:14:30.619]                 NAMES <- toupper(changed)
[16:14:30.619]                 args <- list()
[16:14:30.619]                 for (kk in seq_along(NAMES)) {
[16:14:30.619]                   name <- changed[[kk]]
[16:14:30.619]                   NAME <- NAMES[[kk]]
[16:14:30.619]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:30.619]                     next
[16:14:30.619]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:30.619]                 }
[16:14:30.619]                 NAMES <- toupper(added)
[16:14:30.619]                 for (kk in seq_along(NAMES)) {
[16:14:30.619]                   name <- added[[kk]]
[16:14:30.619]                   NAME <- NAMES[[kk]]
[16:14:30.619]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:30.619]                     next
[16:14:30.619]                   args[[name]] <- ""
[16:14:30.619]                 }
[16:14:30.619]                 NAMES <- toupper(removed)
[16:14:30.619]                 for (kk in seq_along(NAMES)) {
[16:14:30.619]                   name <- removed[[kk]]
[16:14:30.619]                   NAME <- NAMES[[kk]]
[16:14:30.619]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:30.619]                     next
[16:14:30.619]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:30.619]                 }
[16:14:30.619]                 if (length(args) > 0) 
[16:14:30.619]                   base::do.call(base::Sys.setenv, args = args)
[16:14:30.619]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:30.619]             }
[16:14:30.619]             else {
[16:14:30.619]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:30.619]             }
[16:14:30.619]             {
[16:14:30.619]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:30.619]                   0L) {
[16:14:30.619]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:30.619]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:30.619]                   base::options(opts)
[16:14:30.619]                 }
[16:14:30.619]                 {
[16:14:30.619]                   {
[16:14:30.619]                     base::options(mc.cores = ...future.mc.cores.old)
[16:14:30.619]                     NULL
[16:14:30.619]                   }
[16:14:30.619]                   options(future.plan = NULL)
[16:14:30.619]                   if (is.na(NA_character_)) 
[16:14:30.619]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:30.619]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:30.619]                   future::plan(list(function (..., workers = availableCores(), 
[16:14:30.619]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:14:30.619]                     envir = parent.frame()) 
[16:14:30.619]                   {
[16:14:30.619]                     if (is.function(workers)) 
[16:14:30.619]                       workers <- workers()
[16:14:30.619]                     workers <- structure(as.integer(workers), 
[16:14:30.619]                       class = class(workers))
[16:14:30.619]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:14:30.619]                       workers >= 1)
[16:14:30.619]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:14:30.619]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:14:30.619]                     }
[16:14:30.619]                     future <- MultisessionFuture(..., workers = workers, 
[16:14:30.619]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:14:30.619]                       envir = envir)
[16:14:30.619]                     if (!future$lazy) 
[16:14:30.619]                       future <- run(future)
[16:14:30.619]                     invisible(future)
[16:14:30.619]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:30.619]                 }
[16:14:30.619]             }
[16:14:30.619]         }
[16:14:30.619]     })
[16:14:30.619]     if (FALSE) {
[16:14:30.619]         base::sink(type = "output", split = FALSE)
[16:14:30.619]         if (NA) {
[16:14:30.619]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:30.619]         }
[16:14:30.619]         else {
[16:14:30.619]             ...future.result["stdout"] <- base::list(NULL)
[16:14:30.619]         }
[16:14:30.619]         base::close(...future.stdout)
[16:14:30.619]         ...future.stdout <- NULL
[16:14:30.619]     }
[16:14:30.619]     ...future.result$conditions <- ...future.conditions
[16:14:30.619]     ...future.result$finished <- base::Sys.time()
[16:14:30.619]     ...future.result
[16:14:30.619] }
[16:14:30.622] MultisessionFuture started
[16:14:30.623] - Launch lazy future ... done
[16:14:30.623] run() for ‘MultisessionFuture’ ... done
[16:14:30.623] result() for ClusterFuture ...
[16:14:30.623] receiveMessageFromWorker() for ClusterFuture ...
[16:14:30.623] - Validating connection of MultisessionFuture
[16:14:30.669] - received message: FutureResult
[16:14:30.669] - Received FutureResult
[16:14:30.669] - Erased future from FutureRegistry
[16:14:30.669] result() for ClusterFuture ...
[16:14:30.669] - result already collected: FutureResult
[16:14:30.670] result() for ClusterFuture ... done
[16:14:30.670] receiveMessageFromWorker() for ClusterFuture ... done
[16:14:30.670] result() for ClusterFuture ... done
[16:14:30.670] result() for ClusterFuture ...
[16:14:30.670] - result already collected: FutureResult
[16:14:30.670] result() for ClusterFuture ... done
- stdout = structure(TRUE, drop = TRUE)
[16:14:30.670] getGlobalsAndPackages() ...
[16:14:30.670] Searching for globals...
[16:14:30.671] - globals found: [1] ‘print’
[16:14:30.671] Searching for globals ... DONE
[16:14:30.671] Resolving globals: FALSE
[16:14:30.671] 
[16:14:30.671] 
[16:14:30.671] getGlobalsAndPackages() ... DONE
[16:14:30.672] run() for ‘Future’ ...
[16:14:30.672] - state: ‘created’
[16:14:30.672] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:14:30.686] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:14:30.686] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:14:30.686]   - Field: ‘node’
[16:14:30.686]   - Field: ‘label’
[16:14:30.686]   - Field: ‘local’
[16:14:30.686]   - Field: ‘owner’
[16:14:30.687]   - Field: ‘envir’
[16:14:30.687]   - Field: ‘workers’
[16:14:30.687]   - Field: ‘packages’
[16:14:30.687]   - Field: ‘gc’
[16:14:30.687]   - Field: ‘conditions’
[16:14:30.687]   - Field: ‘persistent’
[16:14:30.687]   - Field: ‘expr’
[16:14:30.687]   - Field: ‘uuid’
[16:14:30.687]   - Field: ‘seed’
[16:14:30.687]   - Field: ‘version’
[16:14:30.687]   - Field: ‘result’
[16:14:30.688]   - Field: ‘asynchronous’
[16:14:30.688]   - Field: ‘calls’
[16:14:30.688]   - Field: ‘globals’
[16:14:30.688]   - Field: ‘stdout’
[16:14:30.688]   - Field: ‘earlySignal’
[16:14:30.688]   - Field: ‘lazy’
[16:14:30.688]   - Field: ‘state’
[16:14:30.688] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:14:30.688] - Launch lazy future ...
[16:14:30.689] Packages needed by the future expression (n = 0): <none>
[16:14:30.689] Packages needed by future strategies (n = 0): <none>
[16:14:30.689] {
[16:14:30.689]     {
[16:14:30.689]         {
[16:14:30.689]             ...future.startTime <- base::Sys.time()
[16:14:30.689]             {
[16:14:30.689]                 {
[16:14:30.689]                   {
[16:14:30.689]                     {
[16:14:30.689]                       base::local({
[16:14:30.689]                         has_future <- base::requireNamespace("future", 
[16:14:30.689]                           quietly = TRUE)
[16:14:30.689]                         if (has_future) {
[16:14:30.689]                           ns <- base::getNamespace("future")
[16:14:30.689]                           version <- ns[[".package"]][["version"]]
[16:14:30.689]                           if (is.null(version)) 
[16:14:30.689]                             version <- utils::packageVersion("future")
[16:14:30.689]                         }
[16:14:30.689]                         else {
[16:14:30.689]                           version <- NULL
[16:14:30.689]                         }
[16:14:30.689]                         if (!has_future || version < "1.8.0") {
[16:14:30.689]                           info <- base::c(r_version = base::gsub("R version ", 
[16:14:30.689]                             "", base::R.version$version.string), 
[16:14:30.689]                             platform = base::sprintf("%s (%s-bit)", 
[16:14:30.689]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:14:30.689]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:30.689]                               "release", "version")], collapse = " "), 
[16:14:30.689]                             hostname = base::Sys.info()[["nodename"]])
[16:14:30.689]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:14:30.689]                             info)
[16:14:30.689]                           info <- base::paste(info, collapse = "; ")
[16:14:30.689]                           if (!has_future) {
[16:14:30.689]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:30.689]                               info)
[16:14:30.689]                           }
[16:14:30.689]                           else {
[16:14:30.689]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:30.689]                               info, version)
[16:14:30.689]                           }
[16:14:30.689]                           base::stop(msg)
[16:14:30.689]                         }
[16:14:30.689]                       })
[16:14:30.689]                     }
[16:14:30.689]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:14:30.689]                     base::options(mc.cores = 1L)
[16:14:30.689]                   }
[16:14:30.689]                   options(future.plan = NULL)
[16:14:30.689]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:30.689]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:30.689]                 }
[16:14:30.689]                 ...future.workdir <- getwd()
[16:14:30.689]             }
[16:14:30.689]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:30.689]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:30.689]         }
[16:14:30.689]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:30.689]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:30.689]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:30.689]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:30.689]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:30.689]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:30.689]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:30.689]             base::names(...future.oldOptions))
[16:14:30.689]     }
[16:14:30.689]     if (FALSE) {
[16:14:30.689]     }
[16:14:30.689]     else {
[16:14:30.689]         if (TRUE) {
[16:14:30.689]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:30.689]                 open = "w")
[16:14:30.689]         }
[16:14:30.689]         else {
[16:14:30.689]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:30.689]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:30.689]         }
[16:14:30.689]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:30.689]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:30.689]             base::sink(type = "output", split = FALSE)
[16:14:30.689]             base::close(...future.stdout)
[16:14:30.689]         }, add = TRUE)
[16:14:30.689]     }
[16:14:30.689]     ...future.frame <- base::sys.nframe()
[16:14:30.689]     ...future.conditions <- base::list()
[16:14:30.689]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:30.689]     if (FALSE) {
[16:14:30.689]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:30.689]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:30.689]     }
[16:14:30.689]     ...future.result <- base::tryCatch({
[16:14:30.689]         base::withCallingHandlers({
[16:14:30.689]             ...future.value <- base::withVisible(base::local({
[16:14:30.689]                 ...future.makeSendCondition <- local({
[16:14:30.689]                   sendCondition <- NULL
[16:14:30.689]                   function(frame = 1L) {
[16:14:30.689]                     if (is.function(sendCondition)) 
[16:14:30.689]                       return(sendCondition)
[16:14:30.689]                     ns <- getNamespace("parallel")
[16:14:30.689]                     if (exists("sendData", mode = "function", 
[16:14:30.689]                       envir = ns)) {
[16:14:30.689]                       parallel_sendData <- get("sendData", mode = "function", 
[16:14:30.689]                         envir = ns)
[16:14:30.689]                       envir <- sys.frame(frame)
[16:14:30.689]                       master <- NULL
[16:14:30.689]                       while (!identical(envir, .GlobalEnv) && 
[16:14:30.689]                         !identical(envir, emptyenv())) {
[16:14:30.689]                         if (exists("master", mode = "list", envir = envir, 
[16:14:30.689]                           inherits = FALSE)) {
[16:14:30.689]                           master <- get("master", mode = "list", 
[16:14:30.689]                             envir = envir, inherits = FALSE)
[16:14:30.689]                           if (inherits(master, c("SOCKnode", 
[16:14:30.689]                             "SOCK0node"))) {
[16:14:30.689]                             sendCondition <<- function(cond) {
[16:14:30.689]                               data <- list(type = "VALUE", value = cond, 
[16:14:30.689]                                 success = TRUE)
[16:14:30.689]                               parallel_sendData(master, data)
[16:14:30.689]                             }
[16:14:30.689]                             return(sendCondition)
[16:14:30.689]                           }
[16:14:30.689]                         }
[16:14:30.689]                         frame <- frame + 1L
[16:14:30.689]                         envir <- sys.frame(frame)
[16:14:30.689]                       }
[16:14:30.689]                     }
[16:14:30.689]                     sendCondition <<- function(cond) NULL
[16:14:30.689]                   }
[16:14:30.689]                 })
[16:14:30.689]                 withCallingHandlers({
[16:14:30.689]                   print(42)
[16:14:30.689]                 }, immediateCondition = function(cond) {
[16:14:30.689]                   sendCondition <- ...future.makeSendCondition()
[16:14:30.689]                   sendCondition(cond)
[16:14:30.689]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:30.689]                   {
[16:14:30.689]                     inherits <- base::inherits
[16:14:30.689]                     invokeRestart <- base::invokeRestart
[16:14:30.689]                     is.null <- base::is.null
[16:14:30.689]                     muffled <- FALSE
[16:14:30.689]                     if (inherits(cond, "message")) {
[16:14:30.689]                       muffled <- grepl(pattern, "muffleMessage")
[16:14:30.689]                       if (muffled) 
[16:14:30.689]                         invokeRestart("muffleMessage")
[16:14:30.689]                     }
[16:14:30.689]                     else if (inherits(cond, "warning")) {
[16:14:30.689]                       muffled <- grepl(pattern, "muffleWarning")
[16:14:30.689]                       if (muffled) 
[16:14:30.689]                         invokeRestart("muffleWarning")
[16:14:30.689]                     }
[16:14:30.689]                     else if (inherits(cond, "condition")) {
[16:14:30.689]                       if (!is.null(pattern)) {
[16:14:30.689]                         computeRestarts <- base::computeRestarts
[16:14:30.689]                         grepl <- base::grepl
[16:14:30.689]                         restarts <- computeRestarts(cond)
[16:14:30.689]                         for (restart in restarts) {
[16:14:30.689]                           name <- restart$name
[16:14:30.689]                           if (is.null(name)) 
[16:14:30.689]                             next
[16:14:30.689]                           if (!grepl(pattern, name)) 
[16:14:30.689]                             next
[16:14:30.689]                           invokeRestart(restart)
[16:14:30.689]                           muffled <- TRUE
[16:14:30.689]                           break
[16:14:30.689]                         }
[16:14:30.689]                       }
[16:14:30.689]                     }
[16:14:30.689]                     invisible(muffled)
[16:14:30.689]                   }
[16:14:30.689]                   muffleCondition(cond)
[16:14:30.689]                 })
[16:14:30.689]             }))
[16:14:30.689]             future::FutureResult(value = ...future.value$value, 
[16:14:30.689]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:30.689]                   ...future.rng), globalenv = if (FALSE) 
[16:14:30.689]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:30.689]                     ...future.globalenv.names))
[16:14:30.689]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:30.689]         }, condition = base::local({
[16:14:30.689]             c <- base::c
[16:14:30.689]             inherits <- base::inherits
[16:14:30.689]             invokeRestart <- base::invokeRestart
[16:14:30.689]             length <- base::length
[16:14:30.689]             list <- base::list
[16:14:30.689]             seq.int <- base::seq.int
[16:14:30.689]             signalCondition <- base::signalCondition
[16:14:30.689]             sys.calls <- base::sys.calls
[16:14:30.689]             `[[` <- base::`[[`
[16:14:30.689]             `+` <- base::`+`
[16:14:30.689]             `<<-` <- base::`<<-`
[16:14:30.689]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:30.689]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:30.689]                   3L)]
[16:14:30.689]             }
[16:14:30.689]             function(cond) {
[16:14:30.689]                 is_error <- inherits(cond, "error")
[16:14:30.689]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:30.689]                   NULL)
[16:14:30.689]                 if (is_error) {
[16:14:30.689]                   sessionInformation <- function() {
[16:14:30.689]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:30.689]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:30.689]                       search = base::search(), system = base::Sys.info())
[16:14:30.689]                   }
[16:14:30.689]                   ...future.conditions[[length(...future.conditions) + 
[16:14:30.689]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:30.689]                     cond$call), session = sessionInformation(), 
[16:14:30.689]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:30.689]                   signalCondition(cond)
[16:14:30.689]                 }
[16:14:30.689]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:30.689]                 "immediateCondition"))) {
[16:14:30.689]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:30.689]                   ...future.conditions[[length(...future.conditions) + 
[16:14:30.689]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:30.689]                   if (TRUE && !signal) {
[16:14:30.689]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:30.689]                     {
[16:14:30.689]                       inherits <- base::inherits
[16:14:30.689]                       invokeRestart <- base::invokeRestart
[16:14:30.689]                       is.null <- base::is.null
[16:14:30.689]                       muffled <- FALSE
[16:14:30.689]                       if (inherits(cond, "message")) {
[16:14:30.689]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:30.689]                         if (muffled) 
[16:14:30.689]                           invokeRestart("muffleMessage")
[16:14:30.689]                       }
[16:14:30.689]                       else if (inherits(cond, "warning")) {
[16:14:30.689]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:30.689]                         if (muffled) 
[16:14:30.689]                           invokeRestart("muffleWarning")
[16:14:30.689]                       }
[16:14:30.689]                       else if (inherits(cond, "condition")) {
[16:14:30.689]                         if (!is.null(pattern)) {
[16:14:30.689]                           computeRestarts <- base::computeRestarts
[16:14:30.689]                           grepl <- base::grepl
[16:14:30.689]                           restarts <- computeRestarts(cond)
[16:14:30.689]                           for (restart in restarts) {
[16:14:30.689]                             name <- restart$name
[16:14:30.689]                             if (is.null(name)) 
[16:14:30.689]                               next
[16:14:30.689]                             if (!grepl(pattern, name)) 
[16:14:30.689]                               next
[16:14:30.689]                             invokeRestart(restart)
[16:14:30.689]                             muffled <- TRUE
[16:14:30.689]                             break
[16:14:30.689]                           }
[16:14:30.689]                         }
[16:14:30.689]                       }
[16:14:30.689]                       invisible(muffled)
[16:14:30.689]                     }
[16:14:30.689]                     muffleCondition(cond, pattern = "^muffle")
[16:14:30.689]                   }
[16:14:30.689]                 }
[16:14:30.689]                 else {
[16:14:30.689]                   if (TRUE) {
[16:14:30.689]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:30.689]                     {
[16:14:30.689]                       inherits <- base::inherits
[16:14:30.689]                       invokeRestart <- base::invokeRestart
[16:14:30.689]                       is.null <- base::is.null
[16:14:30.689]                       muffled <- FALSE
[16:14:30.689]                       if (inherits(cond, "message")) {
[16:14:30.689]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:30.689]                         if (muffled) 
[16:14:30.689]                           invokeRestart("muffleMessage")
[16:14:30.689]                       }
[16:14:30.689]                       else if (inherits(cond, "warning")) {
[16:14:30.689]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:30.689]                         if (muffled) 
[16:14:30.689]                           invokeRestart("muffleWarning")
[16:14:30.689]                       }
[16:14:30.689]                       else if (inherits(cond, "condition")) {
[16:14:30.689]                         if (!is.null(pattern)) {
[16:14:30.689]                           computeRestarts <- base::computeRestarts
[16:14:30.689]                           grepl <- base::grepl
[16:14:30.689]                           restarts <- computeRestarts(cond)
[16:14:30.689]                           for (restart in restarts) {
[16:14:30.689]                             name <- restart$name
[16:14:30.689]                             if (is.null(name)) 
[16:14:30.689]                               next
[16:14:30.689]                             if (!grepl(pattern, name)) 
[16:14:30.689]                               next
[16:14:30.689]                             invokeRestart(restart)
[16:14:30.689]                             muffled <- TRUE
[16:14:30.689]                             break
[16:14:30.689]                           }
[16:14:30.689]                         }
[16:14:30.689]                       }
[16:14:30.689]                       invisible(muffled)
[16:14:30.689]                     }
[16:14:30.689]                     muffleCondition(cond, pattern = "^muffle")
[16:14:30.689]                   }
[16:14:30.689]                 }
[16:14:30.689]             }
[16:14:30.689]         }))
[16:14:30.689]     }, error = function(ex) {
[16:14:30.689]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:30.689]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:30.689]                 ...future.rng), started = ...future.startTime, 
[16:14:30.689]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:30.689]             version = "1.8"), class = "FutureResult")
[16:14:30.689]     }, finally = {
[16:14:30.689]         if (!identical(...future.workdir, getwd())) 
[16:14:30.689]             setwd(...future.workdir)
[16:14:30.689]         {
[16:14:30.689]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:30.689]                 ...future.oldOptions$nwarnings <- NULL
[16:14:30.689]             }
[16:14:30.689]             base::options(...future.oldOptions)
[16:14:30.689]             if (.Platform$OS.type == "windows") {
[16:14:30.689]                 old_names <- names(...future.oldEnvVars)
[16:14:30.689]                 envs <- base::Sys.getenv()
[16:14:30.689]                 names <- names(envs)
[16:14:30.689]                 common <- intersect(names, old_names)
[16:14:30.689]                 added <- setdiff(names, old_names)
[16:14:30.689]                 removed <- setdiff(old_names, names)
[16:14:30.689]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:30.689]                   envs[common]]
[16:14:30.689]                 NAMES <- toupper(changed)
[16:14:30.689]                 args <- list()
[16:14:30.689]                 for (kk in seq_along(NAMES)) {
[16:14:30.689]                   name <- changed[[kk]]
[16:14:30.689]                   NAME <- NAMES[[kk]]
[16:14:30.689]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:30.689]                     next
[16:14:30.689]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:30.689]                 }
[16:14:30.689]                 NAMES <- toupper(added)
[16:14:30.689]                 for (kk in seq_along(NAMES)) {
[16:14:30.689]                   name <- added[[kk]]
[16:14:30.689]                   NAME <- NAMES[[kk]]
[16:14:30.689]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:30.689]                     next
[16:14:30.689]                   args[[name]] <- ""
[16:14:30.689]                 }
[16:14:30.689]                 NAMES <- toupper(removed)
[16:14:30.689]                 for (kk in seq_along(NAMES)) {
[16:14:30.689]                   name <- removed[[kk]]
[16:14:30.689]                   NAME <- NAMES[[kk]]
[16:14:30.689]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:30.689]                     next
[16:14:30.689]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:30.689]                 }
[16:14:30.689]                 if (length(args) > 0) 
[16:14:30.689]                   base::do.call(base::Sys.setenv, args = args)
[16:14:30.689]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:30.689]             }
[16:14:30.689]             else {
[16:14:30.689]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:30.689]             }
[16:14:30.689]             {
[16:14:30.689]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:30.689]                   0L) {
[16:14:30.689]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:30.689]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:30.689]                   base::options(opts)
[16:14:30.689]                 }
[16:14:30.689]                 {
[16:14:30.689]                   {
[16:14:30.689]                     base::options(mc.cores = ...future.mc.cores.old)
[16:14:30.689]                     NULL
[16:14:30.689]                   }
[16:14:30.689]                   options(future.plan = NULL)
[16:14:30.689]                   if (is.na(NA_character_)) 
[16:14:30.689]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:30.689]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:30.689]                   future::plan(list(function (..., workers = availableCores(), 
[16:14:30.689]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:14:30.689]                     envir = parent.frame()) 
[16:14:30.689]                   {
[16:14:30.689]                     if (is.function(workers)) 
[16:14:30.689]                       workers <- workers()
[16:14:30.689]                     workers <- structure(as.integer(workers), 
[16:14:30.689]                       class = class(workers))
[16:14:30.689]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:14:30.689]                       workers >= 1)
[16:14:30.689]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:14:30.689]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:14:30.689]                     }
[16:14:30.689]                     future <- MultisessionFuture(..., workers = workers, 
[16:14:30.689]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:14:30.689]                       envir = envir)
[16:14:30.689]                     if (!future$lazy) 
[16:14:30.689]                       future <- run(future)
[16:14:30.689]                     invisible(future)
[16:14:30.689]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:30.689]                 }
[16:14:30.689]             }
[16:14:30.689]         }
[16:14:30.689]     })
[16:14:30.689]     if (TRUE) {
[16:14:30.689]         base::sink(type = "output", split = FALSE)
[16:14:30.689]         if (TRUE) {
[16:14:30.689]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:30.689]         }
[16:14:30.689]         else {
[16:14:30.689]             ...future.result["stdout"] <- base::list(NULL)
[16:14:30.689]         }
[16:14:30.689]         base::close(...future.stdout)
[16:14:30.689]         ...future.stdout <- NULL
[16:14:30.689]     }
[16:14:30.689]     ...future.result$conditions <- ...future.conditions
[16:14:30.689]     ...future.result$finished <- base::Sys.time()
[16:14:30.689]     ...future.result
[16:14:30.689] }
[16:14:30.692] MultisessionFuture started
[16:14:30.692] - Launch lazy future ... done
[16:14:30.692] run() for ‘MultisessionFuture’ ... done
[16:14:30.692] result() for ClusterFuture ...
[16:14:30.692] receiveMessageFromWorker() for ClusterFuture ...
[16:14:30.692] - Validating connection of MultisessionFuture
[16:14:30.742] - received message: FutureResult
[16:14:30.742] - Received FutureResult
[16:14:30.742] - Erased future from FutureRegistry
[16:14:30.742] result() for ClusterFuture ...
[16:14:30.742] - result already collected: FutureResult
[16:14:30.743] result() for ClusterFuture ... done
[16:14:30.743] receiveMessageFromWorker() for ClusterFuture ... done
[16:14:30.743] result() for ClusterFuture ... done
[16:14:30.743] result() for ClusterFuture ...
[16:14:30.743] - result already collected: FutureResult
[16:14:30.743] result() for ClusterFuture ... done
[16:14:30.743] result() for ClusterFuture ...
[16:14:30.743] - result already collected: FutureResult
[16:14:30.743] result() for ClusterFuture ... done
[1] 42
[16:14:30.743] result() for ClusterFuture ...
[16:14:30.744] - result already collected: FutureResult
[16:14:30.744] result() for ClusterFuture ... done
multisession ... done
Testing with 2 cores ... done
> 
> message("*** Standard output ... DONE")
*** Standard output ... DONE
> 
> source("incl/end.R")
[16:14:30.744] plan(): Setting new future strategy stack:
[16:14:30.744] List of future strategies:
[16:14:30.744] 1. FutureStrategy:
[16:14:30.744]    - args: function (..., envir = parent.frame())
[16:14:30.744]    - tweaked: FALSE
[16:14:30.744]    - call: future::plan(oplan)
[16:14:30.745] plan(): nbrOfWorkers() = 1
> 
