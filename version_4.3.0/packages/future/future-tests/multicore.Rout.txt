
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[17:42:57.267] plan(): Setting new future strategy stack:
[17:42:57.268] List of future strategies:
[17:42:57.268] 1. sequential:
[17:42:57.268]    - args: function (..., envir = parent.frame())
[17:42:57.268]    - tweaked: FALSE
[17:42:57.268]    - call: future::plan("sequential")
[17:42:57.281] plan(): nbrOfWorkers() = 1
> library("listenv")
> plan(multicore)
[17:42:57.294] plan(): Setting new future strategy stack:
[17:42:57.294] List of future strategies:
[17:42:57.294] 1. multicore:
[17:42:57.294]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:57.294]    - tweaked: FALSE
[17:42:57.294]    - call: plan(multicore)
[17:42:57.308] plan(): nbrOfWorkers() = 2
> 
> message("*** multicore() ...")
*** multicore() ...
> 
> for (cores in 1:min(2L, availableCores("multicore"))) {
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   if (!supportsMulticore()) {
+     message(sprintf("Multicore futures are not supporting on '%s'. Falling back to use synchronous sequential futures", .Platform$OS.type))
+   }
+ 
+   nworkers <- nbrOfWorkers()
+   message("Number of workers: ", nworkers)
+   stopifnot(nworkers == cores)
+   
+   for (globals in c(FALSE, TRUE)) {
+ 
+     message(sprintf("*** multicore(..., globals = %s) without globals", globals))
+   
+     f <- multicore({
+       42L
+     }, globals = globals)
+     stopifnot(inherits(f, "MulticoreFuture") || ((cores ==1 || !supportsMulticore()) && inherits(f, "SequentialFuture")))
+   
+     print(resolved(f))
+     y <- value(f)
+     print(y)
+     stopifnot(y == 42L)
+   
+   
+     message(sprintf("*** multicore(..., globals = %s) with globals", globals))
+     ## A global variable
+     a <- 0
+     f <- multicore({
+       b <- 3
+       c <- 2
+       a * b * c
+     }, globals = globals)
+     print(f)
+   
+   
+     ## A multicore future is evaluated in a separated
+     ## forked process.  Changing the value of a global
+     ## variable should not affect the result of the
+     ## future.
+     a <- 7  ## Make sure globals are frozen
+     v <- value(f)
+     print(v)
+     stopifnot(v == 0)
+   
+   
+     message(sprintf("*** multicore(..., globals = %s) with globals and blocking", globals))
+     x <- listenv()
+     for (ii in 1:4) {
+       message(sprintf(" - Creating multicore future #%d ...", ii))
+       x[[ii]] <- multicore({ ii }, globals = globals)
+     }
+     message(sprintf(" - Resolving %d multicore futures", length(x)))
+     v <- sapply(x, FUN = value)
+     stopifnot(all(v == 1:4))
+   
+   
+     message(sprintf("*** multicore(..., globals = %s) and errors", globals))
+     f <- multicore({
+       stop("Whoops!")
+       1
+     }, globals = globals)
+     print(f)
+     v <- value(f, signal = FALSE)
+     print(v)
+     stopifnot(inherits(v, "simpleError"))
+   
+     res <- try(value(f), silent = TRUE)
+     print(res)
+     stopifnot(inherits(res, "try-error"))
+   
+     ## Error is repeated
+     res <- try(value(f), silent = TRUE)
+     print(res)
+     stopifnot(inherits(res, "try-error"))
+ 
+     ## Custom error class
+     f <- multicore({
+       stop(structure(list(message = "boom"),
+                      class = c("MyError", "error", "condition")))
+     })
+     print(f)
+     v <- value(f, signal = FALSE)
+     print(v)
+     stopifnot(inherits(v, "error"), inherits(v, "MyError"))
+   
+     ## Make sure error is signaled
+     res <- tryCatch(value(f), error = identity)
+     stopifnot(inherits(res, "error"))
+   
+     ## Issue #200: Custom condition class attributes are lost 
+     stopifnot(inherits(res, "MyError"))    
+   } # for (globals ...)
+ 
+ 
+   message("*** multicore(..., workers = 1L) ...")
+ 
+   a <- 2
+   b <- 3
+   yTruth <- a * b
+ 
+   f <- multicore({ a * b }, globals = TRUE, workers = 1L)
+   rm(list = c("a", "b"))
+ 
+   v <- value(f)
+   print(v)
+   stopifnot(v == yTruth)
+ 
+   message("*** multicore(..., workers = 1L) ... DONE")
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
Number of workers: 1
*** multicore(..., globals = FALSE) without globals
[17:42:57.365] getGlobalsAndPackages() ...
[17:42:57.365] Not searching for globals
[17:42:57.365] - globals: [0] <none>
[17:42:57.366] getGlobalsAndPackages() ... DONE
[17:42:57.367] Packages needed by the future expression (n = 0): <none>
[17:42:57.367] Packages needed by future strategies (n = 0): <none>
[17:42:57.368] {
[17:42:57.368]     {
[17:42:57.368]         {
[17:42:57.368]             ...future.startTime <- base::Sys.time()
[17:42:57.368]             {
[17:42:57.368]                 {
[17:42:57.368]                   {
[17:42:57.368]                     base::local({
[17:42:57.368]                       has_future <- base::requireNamespace("future", 
[17:42:57.368]                         quietly = TRUE)
[17:42:57.368]                       if (has_future) {
[17:42:57.368]                         ns <- base::getNamespace("future")
[17:42:57.368]                         version <- ns[[".package"]][["version"]]
[17:42:57.368]                         if (is.null(version)) 
[17:42:57.368]                           version <- utils::packageVersion("future")
[17:42:57.368]                       }
[17:42:57.368]                       else {
[17:42:57.368]                         version <- NULL
[17:42:57.368]                       }
[17:42:57.368]                       if (!has_future || version < "1.8.0") {
[17:42:57.368]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:57.368]                           "", base::R.version$version.string), 
[17:42:57.368]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:57.368]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:57.368]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:57.368]                             "release", "version")], collapse = " "), 
[17:42:57.368]                           hostname = base::Sys.info()[["nodename"]])
[17:42:57.368]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:57.368]                           info)
[17:42:57.368]                         info <- base::paste(info, collapse = "; ")
[17:42:57.368]                         if (!has_future) {
[17:42:57.368]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:57.368]                             info)
[17:42:57.368]                         }
[17:42:57.368]                         else {
[17:42:57.368]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:57.368]                             info, version)
[17:42:57.368]                         }
[17:42:57.368]                         base::stop(msg)
[17:42:57.368]                       }
[17:42:57.368]                     })
[17:42:57.368]                   }
[17:42:57.368]                   options(future.plan = NULL)
[17:42:57.368]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.368]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:57.368]                 }
[17:42:57.368]                 ...future.workdir <- getwd()
[17:42:57.368]             }
[17:42:57.368]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:57.368]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:57.368]         }
[17:42:57.368]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:57.368]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:57.368]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:57.368]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:57.368]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:57.368]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:57.368]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:57.368]             base::names(...future.oldOptions))
[17:42:57.368]     }
[17:42:57.368]     if (FALSE) {
[17:42:57.368]     }
[17:42:57.368]     else {
[17:42:57.368]         if (TRUE) {
[17:42:57.368]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:57.368]                 open = "w")
[17:42:57.368]         }
[17:42:57.368]         else {
[17:42:57.368]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:57.368]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:57.368]         }
[17:42:57.368]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:57.368]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:57.368]             base::sink(type = "output", split = FALSE)
[17:42:57.368]             base::close(...future.stdout)
[17:42:57.368]         }, add = TRUE)
[17:42:57.368]     }
[17:42:57.368]     ...future.frame <- base::sys.nframe()
[17:42:57.368]     ...future.conditions <- base::list()
[17:42:57.368]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:57.368]     if (FALSE) {
[17:42:57.368]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:57.368]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:57.368]     }
[17:42:57.368]     ...future.result <- base::tryCatch({
[17:42:57.368]         base::withCallingHandlers({
[17:42:57.368]             ...future.value <- base::withVisible(base::local({
[17:42:57.368]                 42L
[17:42:57.368]             }))
[17:42:57.368]             future::FutureResult(value = ...future.value$value, 
[17:42:57.368]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.368]                   ...future.rng), globalenv = if (FALSE) 
[17:42:57.368]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:57.368]                     ...future.globalenv.names))
[17:42:57.368]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:57.368]         }, condition = base::local({
[17:42:57.368]             c <- base::c
[17:42:57.368]             inherits <- base::inherits
[17:42:57.368]             invokeRestart <- base::invokeRestart
[17:42:57.368]             length <- base::length
[17:42:57.368]             list <- base::list
[17:42:57.368]             seq.int <- base::seq.int
[17:42:57.368]             signalCondition <- base::signalCondition
[17:42:57.368]             sys.calls <- base::sys.calls
[17:42:57.368]             `[[` <- base::`[[`
[17:42:57.368]             `+` <- base::`+`
[17:42:57.368]             `<<-` <- base::`<<-`
[17:42:57.368]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:57.368]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:57.368]                   3L)]
[17:42:57.368]             }
[17:42:57.368]             function(cond) {
[17:42:57.368]                 is_error <- inherits(cond, "error")
[17:42:57.368]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:57.368]                   NULL)
[17:42:57.368]                 if (is_error) {
[17:42:57.368]                   sessionInformation <- function() {
[17:42:57.368]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:57.368]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:57.368]                       search = base::search(), system = base::Sys.info())
[17:42:57.368]                   }
[17:42:57.368]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.368]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:57.368]                     cond$call), session = sessionInformation(), 
[17:42:57.368]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:57.368]                   signalCondition(cond)
[17:42:57.368]                 }
[17:42:57.368]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:57.368]                 "immediateCondition"))) {
[17:42:57.368]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:57.368]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.368]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:57.368]                   if (TRUE && !signal) {
[17:42:57.368]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.368]                     {
[17:42:57.368]                       inherits <- base::inherits
[17:42:57.368]                       invokeRestart <- base::invokeRestart
[17:42:57.368]                       is.null <- base::is.null
[17:42:57.368]                       muffled <- FALSE
[17:42:57.368]                       if (inherits(cond, "message")) {
[17:42:57.368]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.368]                         if (muffled) 
[17:42:57.368]                           invokeRestart("muffleMessage")
[17:42:57.368]                       }
[17:42:57.368]                       else if (inherits(cond, "warning")) {
[17:42:57.368]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.368]                         if (muffled) 
[17:42:57.368]                           invokeRestart("muffleWarning")
[17:42:57.368]                       }
[17:42:57.368]                       else if (inherits(cond, "condition")) {
[17:42:57.368]                         if (!is.null(pattern)) {
[17:42:57.368]                           computeRestarts <- base::computeRestarts
[17:42:57.368]                           grepl <- base::grepl
[17:42:57.368]                           restarts <- computeRestarts(cond)
[17:42:57.368]                           for (restart in restarts) {
[17:42:57.368]                             name <- restart$name
[17:42:57.368]                             if (is.null(name)) 
[17:42:57.368]                               next
[17:42:57.368]                             if (!grepl(pattern, name)) 
[17:42:57.368]                               next
[17:42:57.368]                             invokeRestart(restart)
[17:42:57.368]                             muffled <- TRUE
[17:42:57.368]                             break
[17:42:57.368]                           }
[17:42:57.368]                         }
[17:42:57.368]                       }
[17:42:57.368]                       invisible(muffled)
[17:42:57.368]                     }
[17:42:57.368]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.368]                   }
[17:42:57.368]                 }
[17:42:57.368]                 else {
[17:42:57.368]                   if (TRUE) {
[17:42:57.368]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.368]                     {
[17:42:57.368]                       inherits <- base::inherits
[17:42:57.368]                       invokeRestart <- base::invokeRestart
[17:42:57.368]                       is.null <- base::is.null
[17:42:57.368]                       muffled <- FALSE
[17:42:57.368]                       if (inherits(cond, "message")) {
[17:42:57.368]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.368]                         if (muffled) 
[17:42:57.368]                           invokeRestart("muffleMessage")
[17:42:57.368]                       }
[17:42:57.368]                       else if (inherits(cond, "warning")) {
[17:42:57.368]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.368]                         if (muffled) 
[17:42:57.368]                           invokeRestart("muffleWarning")
[17:42:57.368]                       }
[17:42:57.368]                       else if (inherits(cond, "condition")) {
[17:42:57.368]                         if (!is.null(pattern)) {
[17:42:57.368]                           computeRestarts <- base::computeRestarts
[17:42:57.368]                           grepl <- base::grepl
[17:42:57.368]                           restarts <- computeRestarts(cond)
[17:42:57.368]                           for (restart in restarts) {
[17:42:57.368]                             name <- restart$name
[17:42:57.368]                             if (is.null(name)) 
[17:42:57.368]                               next
[17:42:57.368]                             if (!grepl(pattern, name)) 
[17:42:57.368]                               next
[17:42:57.368]                             invokeRestart(restart)
[17:42:57.368]                             muffled <- TRUE
[17:42:57.368]                             break
[17:42:57.368]                           }
[17:42:57.368]                         }
[17:42:57.368]                       }
[17:42:57.368]                       invisible(muffled)
[17:42:57.368]                     }
[17:42:57.368]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.368]                   }
[17:42:57.368]                 }
[17:42:57.368]             }
[17:42:57.368]         }))
[17:42:57.368]     }, error = function(ex) {
[17:42:57.368]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:57.368]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.368]                 ...future.rng), started = ...future.startTime, 
[17:42:57.368]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:57.368]             version = "1.8"), class = "FutureResult")
[17:42:57.368]     }, finally = {
[17:42:57.368]         if (!identical(...future.workdir, getwd())) 
[17:42:57.368]             setwd(...future.workdir)
[17:42:57.368]         {
[17:42:57.368]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:57.368]                 ...future.oldOptions$nwarnings <- NULL
[17:42:57.368]             }
[17:42:57.368]             base::options(...future.oldOptions)
[17:42:57.368]             if (.Platform$OS.type == "windows") {
[17:42:57.368]                 old_names <- names(...future.oldEnvVars)
[17:42:57.368]                 envs <- base::Sys.getenv()
[17:42:57.368]                 names <- names(envs)
[17:42:57.368]                 common <- intersect(names, old_names)
[17:42:57.368]                 added <- setdiff(names, old_names)
[17:42:57.368]                 removed <- setdiff(old_names, names)
[17:42:57.368]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:57.368]                   envs[common]]
[17:42:57.368]                 NAMES <- toupper(changed)
[17:42:57.368]                 args <- list()
[17:42:57.368]                 for (kk in seq_along(NAMES)) {
[17:42:57.368]                   name <- changed[[kk]]
[17:42:57.368]                   NAME <- NAMES[[kk]]
[17:42:57.368]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.368]                     next
[17:42:57.368]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.368]                 }
[17:42:57.368]                 NAMES <- toupper(added)
[17:42:57.368]                 for (kk in seq_along(NAMES)) {
[17:42:57.368]                   name <- added[[kk]]
[17:42:57.368]                   NAME <- NAMES[[kk]]
[17:42:57.368]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.368]                     next
[17:42:57.368]                   args[[name]] <- ""
[17:42:57.368]                 }
[17:42:57.368]                 NAMES <- toupper(removed)
[17:42:57.368]                 for (kk in seq_along(NAMES)) {
[17:42:57.368]                   name <- removed[[kk]]
[17:42:57.368]                   NAME <- NAMES[[kk]]
[17:42:57.368]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.368]                     next
[17:42:57.368]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.368]                 }
[17:42:57.368]                 if (length(args) > 0) 
[17:42:57.368]                   base::do.call(base::Sys.setenv, args = args)
[17:42:57.368]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:57.368]             }
[17:42:57.368]             else {
[17:42:57.368]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:57.368]             }
[17:42:57.368]             {
[17:42:57.368]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:57.368]                   0L) {
[17:42:57.368]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:57.368]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:57.368]                   base::options(opts)
[17:42:57.368]                 }
[17:42:57.368]                 {
[17:42:57.368]                   {
[17:42:57.368]                     NULL
[17:42:57.368]                     RNGkind("Mersenne-Twister")
[17:42:57.368]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:57.368]                       inherits = FALSE)
[17:42:57.368]                   }
[17:42:57.368]                   options(future.plan = NULL)
[17:42:57.368]                   if (is.na(NA_character_)) 
[17:42:57.368]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.368]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:57.368]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:57.368]                     envir = parent.frame()) 
[17:42:57.368]                   {
[17:42:57.368]                     default_workers <- missing(workers)
[17:42:57.368]                     if (is.function(workers)) 
[17:42:57.368]                       workers <- workers()
[17:42:57.368]                     workers <- structure(as.integer(workers), 
[17:42:57.368]                       class = class(workers))
[17:42:57.368]                     stop_if_not(is.finite(workers), workers >= 
[17:42:57.368]                       1L)
[17:42:57.368]                     if ((workers == 1L && !inherits(workers, 
[17:42:57.368]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:57.368]                       if (default_workers) 
[17:42:57.368]                         supportsMulticore(warn = TRUE)
[17:42:57.368]                       return(sequential(..., envir = envir))
[17:42:57.368]                     }
[17:42:57.368]                     oopts <- options(mc.cores = workers)
[17:42:57.368]                     on.exit(options(oopts))
[17:42:57.368]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:57.368]                       envir = envir)
[17:42:57.368]                     if (!future$lazy) 
[17:42:57.368]                       future <- run(future)
[17:42:57.368]                     invisible(future)
[17:42:57.368]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:57.368]                 }
[17:42:57.368]             }
[17:42:57.368]         }
[17:42:57.368]     })
[17:42:57.368]     if (TRUE) {
[17:42:57.368]         base::sink(type = "output", split = FALSE)
[17:42:57.368]         if (TRUE) {
[17:42:57.368]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:57.368]         }
[17:42:57.368]         else {
[17:42:57.368]             ...future.result["stdout"] <- base::list(NULL)
[17:42:57.368]         }
[17:42:57.368]         base::close(...future.stdout)
[17:42:57.368]         ...future.stdout <- NULL
[17:42:57.368]     }
[17:42:57.368]     ...future.result$conditions <- ...future.conditions
[17:42:57.368]     ...future.result$finished <- base::Sys.time()
[17:42:57.368]     ...future.result
[17:42:57.368] }
[17:42:57.370] plan(): Setting new future strategy stack:
[17:42:57.370] List of future strategies:
[17:42:57.370] 1. sequential:
[17:42:57.370]    - args: function (..., envir = parent.frame())
[17:42:57.370]    - tweaked: FALSE
[17:42:57.370]    - call: NULL
[17:42:57.370] plan(): nbrOfWorkers() = 1
[17:42:57.372] plan(): Setting new future strategy stack:
[17:42:57.372] List of future strategies:
[17:42:57.372] 1. multicore:
[17:42:57.372]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:57.372]    - tweaked: FALSE
[17:42:57.372]    - call: plan(multicore)
[17:42:57.375] plan(): nbrOfWorkers() = 1
[17:42:57.375] SequentialFuture started (and completed)
[17:42:57.376] resolved() for ‘SequentialFuture’ ...
[17:42:57.376] - state: ‘finished’
[17:42:57.376] - run: TRUE
[17:42:57.376] - result: ‘FutureResult’
[17:42:57.376] resolved() for ‘SequentialFuture’ ... done
[1] TRUE
[1] 42
*** multicore(..., globals = FALSE) with globals
[17:42:57.380] getGlobalsAndPackages() ...
[17:42:57.380] Not searching for globals
[17:42:57.380] - globals: [0] <none>
[17:42:57.381] getGlobalsAndPackages() ... DONE
[17:42:57.381] Packages needed by the future expression (n = 0): <none>
[17:42:57.381] Packages needed by future strategies (n = 0): <none>
[17:42:57.381] {
[17:42:57.381]     {
[17:42:57.381]         {
[17:42:57.381]             ...future.startTime <- base::Sys.time()
[17:42:57.381]             {
[17:42:57.381]                 {
[17:42:57.381]                   {
[17:42:57.381]                     base::local({
[17:42:57.381]                       has_future <- base::requireNamespace("future", 
[17:42:57.381]                         quietly = TRUE)
[17:42:57.381]                       if (has_future) {
[17:42:57.381]                         ns <- base::getNamespace("future")
[17:42:57.381]                         version <- ns[[".package"]][["version"]]
[17:42:57.381]                         if (is.null(version)) 
[17:42:57.381]                           version <- utils::packageVersion("future")
[17:42:57.381]                       }
[17:42:57.381]                       else {
[17:42:57.381]                         version <- NULL
[17:42:57.381]                       }
[17:42:57.381]                       if (!has_future || version < "1.8.0") {
[17:42:57.381]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:57.381]                           "", base::R.version$version.string), 
[17:42:57.381]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:57.381]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:57.381]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:57.381]                             "release", "version")], collapse = " "), 
[17:42:57.381]                           hostname = base::Sys.info()[["nodename"]])
[17:42:57.381]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:57.381]                           info)
[17:42:57.381]                         info <- base::paste(info, collapse = "; ")
[17:42:57.381]                         if (!has_future) {
[17:42:57.381]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:57.381]                             info)
[17:42:57.381]                         }
[17:42:57.381]                         else {
[17:42:57.381]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:57.381]                             info, version)
[17:42:57.381]                         }
[17:42:57.381]                         base::stop(msg)
[17:42:57.381]                       }
[17:42:57.381]                     })
[17:42:57.381]                   }
[17:42:57.381]                   options(future.plan = NULL)
[17:42:57.381]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.381]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:57.381]                 }
[17:42:57.381]                 ...future.workdir <- getwd()
[17:42:57.381]             }
[17:42:57.381]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:57.381]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:57.381]         }
[17:42:57.381]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:57.381]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:57.381]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:57.381]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:57.381]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:57.381]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:57.381]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:57.381]             base::names(...future.oldOptions))
[17:42:57.381]     }
[17:42:57.381]     if (FALSE) {
[17:42:57.381]     }
[17:42:57.381]     else {
[17:42:57.381]         if (TRUE) {
[17:42:57.381]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:57.381]                 open = "w")
[17:42:57.381]         }
[17:42:57.381]         else {
[17:42:57.381]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:57.381]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:57.381]         }
[17:42:57.381]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:57.381]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:57.381]             base::sink(type = "output", split = FALSE)
[17:42:57.381]             base::close(...future.stdout)
[17:42:57.381]         }, add = TRUE)
[17:42:57.381]     }
[17:42:57.381]     ...future.frame <- base::sys.nframe()
[17:42:57.381]     ...future.conditions <- base::list()
[17:42:57.381]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:57.381]     if (FALSE) {
[17:42:57.381]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:57.381]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:57.381]     }
[17:42:57.381]     ...future.result <- base::tryCatch({
[17:42:57.381]         base::withCallingHandlers({
[17:42:57.381]             ...future.value <- base::withVisible(base::local({
[17:42:57.381]                 b <- 3
[17:42:57.381]                 c <- 2
[17:42:57.381]                 a * b * c
[17:42:57.381]             }))
[17:42:57.381]             future::FutureResult(value = ...future.value$value, 
[17:42:57.381]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.381]                   ...future.rng), globalenv = if (FALSE) 
[17:42:57.381]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:57.381]                     ...future.globalenv.names))
[17:42:57.381]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:57.381]         }, condition = base::local({
[17:42:57.381]             c <- base::c
[17:42:57.381]             inherits <- base::inherits
[17:42:57.381]             invokeRestart <- base::invokeRestart
[17:42:57.381]             length <- base::length
[17:42:57.381]             list <- base::list
[17:42:57.381]             seq.int <- base::seq.int
[17:42:57.381]             signalCondition <- base::signalCondition
[17:42:57.381]             sys.calls <- base::sys.calls
[17:42:57.381]             `[[` <- base::`[[`
[17:42:57.381]             `+` <- base::`+`
[17:42:57.381]             `<<-` <- base::`<<-`
[17:42:57.381]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:57.381]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:57.381]                   3L)]
[17:42:57.381]             }
[17:42:57.381]             function(cond) {
[17:42:57.381]                 is_error <- inherits(cond, "error")
[17:42:57.381]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:57.381]                   NULL)
[17:42:57.381]                 if (is_error) {
[17:42:57.381]                   sessionInformation <- function() {
[17:42:57.381]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:57.381]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:57.381]                       search = base::search(), system = base::Sys.info())
[17:42:57.381]                   }
[17:42:57.381]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.381]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:57.381]                     cond$call), session = sessionInformation(), 
[17:42:57.381]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:57.381]                   signalCondition(cond)
[17:42:57.381]                 }
[17:42:57.381]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:57.381]                 "immediateCondition"))) {
[17:42:57.381]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:57.381]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.381]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:57.381]                   if (TRUE && !signal) {
[17:42:57.381]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.381]                     {
[17:42:57.381]                       inherits <- base::inherits
[17:42:57.381]                       invokeRestart <- base::invokeRestart
[17:42:57.381]                       is.null <- base::is.null
[17:42:57.381]                       muffled <- FALSE
[17:42:57.381]                       if (inherits(cond, "message")) {
[17:42:57.381]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.381]                         if (muffled) 
[17:42:57.381]                           invokeRestart("muffleMessage")
[17:42:57.381]                       }
[17:42:57.381]                       else if (inherits(cond, "warning")) {
[17:42:57.381]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.381]                         if (muffled) 
[17:42:57.381]                           invokeRestart("muffleWarning")
[17:42:57.381]                       }
[17:42:57.381]                       else if (inherits(cond, "condition")) {
[17:42:57.381]                         if (!is.null(pattern)) {
[17:42:57.381]                           computeRestarts <- base::computeRestarts
[17:42:57.381]                           grepl <- base::grepl
[17:42:57.381]                           restarts <- computeRestarts(cond)
[17:42:57.381]                           for (restart in restarts) {
[17:42:57.381]                             name <- restart$name
[17:42:57.381]                             if (is.null(name)) 
[17:42:57.381]                               next
[17:42:57.381]                             if (!grepl(pattern, name)) 
[17:42:57.381]                               next
[17:42:57.381]                             invokeRestart(restart)
[17:42:57.381]                             muffled <- TRUE
[17:42:57.381]                             break
[17:42:57.381]                           }
[17:42:57.381]                         }
[17:42:57.381]                       }
[17:42:57.381]                       invisible(muffled)
[17:42:57.381]                     }
[17:42:57.381]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.381]                   }
[17:42:57.381]                 }
[17:42:57.381]                 else {
[17:42:57.381]                   if (TRUE) {
[17:42:57.381]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.381]                     {
[17:42:57.381]                       inherits <- base::inherits
[17:42:57.381]                       invokeRestart <- base::invokeRestart
[17:42:57.381]                       is.null <- base::is.null
[17:42:57.381]                       muffled <- FALSE
[17:42:57.381]                       if (inherits(cond, "message")) {
[17:42:57.381]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.381]                         if (muffled) 
[17:42:57.381]                           invokeRestart("muffleMessage")
[17:42:57.381]                       }
[17:42:57.381]                       else if (inherits(cond, "warning")) {
[17:42:57.381]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.381]                         if (muffled) 
[17:42:57.381]                           invokeRestart("muffleWarning")
[17:42:57.381]                       }
[17:42:57.381]                       else if (inherits(cond, "condition")) {
[17:42:57.381]                         if (!is.null(pattern)) {
[17:42:57.381]                           computeRestarts <- base::computeRestarts
[17:42:57.381]                           grepl <- base::grepl
[17:42:57.381]                           restarts <- computeRestarts(cond)
[17:42:57.381]                           for (restart in restarts) {
[17:42:57.381]                             name <- restart$name
[17:42:57.381]                             if (is.null(name)) 
[17:42:57.381]                               next
[17:42:57.381]                             if (!grepl(pattern, name)) 
[17:42:57.381]                               next
[17:42:57.381]                             invokeRestart(restart)
[17:42:57.381]                             muffled <- TRUE
[17:42:57.381]                             break
[17:42:57.381]                           }
[17:42:57.381]                         }
[17:42:57.381]                       }
[17:42:57.381]                       invisible(muffled)
[17:42:57.381]                     }
[17:42:57.381]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.381]                   }
[17:42:57.381]                 }
[17:42:57.381]             }
[17:42:57.381]         }))
[17:42:57.381]     }, error = function(ex) {
[17:42:57.381]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:57.381]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.381]                 ...future.rng), started = ...future.startTime, 
[17:42:57.381]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:57.381]             version = "1.8"), class = "FutureResult")
[17:42:57.381]     }, finally = {
[17:42:57.381]         if (!identical(...future.workdir, getwd())) 
[17:42:57.381]             setwd(...future.workdir)
[17:42:57.381]         {
[17:42:57.381]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:57.381]                 ...future.oldOptions$nwarnings <- NULL
[17:42:57.381]             }
[17:42:57.381]             base::options(...future.oldOptions)
[17:42:57.381]             if (.Platform$OS.type == "windows") {
[17:42:57.381]                 old_names <- names(...future.oldEnvVars)
[17:42:57.381]                 envs <- base::Sys.getenv()
[17:42:57.381]                 names <- names(envs)
[17:42:57.381]                 common <- intersect(names, old_names)
[17:42:57.381]                 added <- setdiff(names, old_names)
[17:42:57.381]                 removed <- setdiff(old_names, names)
[17:42:57.381]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:57.381]                   envs[common]]
[17:42:57.381]                 NAMES <- toupper(changed)
[17:42:57.381]                 args <- list()
[17:42:57.381]                 for (kk in seq_along(NAMES)) {
[17:42:57.381]                   name <- changed[[kk]]
[17:42:57.381]                   NAME <- NAMES[[kk]]
[17:42:57.381]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.381]                     next
[17:42:57.381]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.381]                 }
[17:42:57.381]                 NAMES <- toupper(added)
[17:42:57.381]                 for (kk in seq_along(NAMES)) {
[17:42:57.381]                   name <- added[[kk]]
[17:42:57.381]                   NAME <- NAMES[[kk]]
[17:42:57.381]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.381]                     next
[17:42:57.381]                   args[[name]] <- ""
[17:42:57.381]                 }
[17:42:57.381]                 NAMES <- toupper(removed)
[17:42:57.381]                 for (kk in seq_along(NAMES)) {
[17:42:57.381]                   name <- removed[[kk]]
[17:42:57.381]                   NAME <- NAMES[[kk]]
[17:42:57.381]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.381]                     next
[17:42:57.381]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.381]                 }
[17:42:57.381]                 if (length(args) > 0) 
[17:42:57.381]                   base::do.call(base::Sys.setenv, args = args)
[17:42:57.381]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:57.381]             }
[17:42:57.381]             else {
[17:42:57.381]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:57.381]             }
[17:42:57.381]             {
[17:42:57.381]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:57.381]                   0L) {
[17:42:57.381]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:57.381]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:57.381]                   base::options(opts)
[17:42:57.381]                 }
[17:42:57.381]                 {
[17:42:57.381]                   {
[17:42:57.381]                     NULL
[17:42:57.381]                     RNGkind("Mersenne-Twister")
[17:42:57.381]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:57.381]                       inherits = FALSE)
[17:42:57.381]                   }
[17:42:57.381]                   options(future.plan = NULL)
[17:42:57.381]                   if (is.na(NA_character_)) 
[17:42:57.381]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.381]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:57.381]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:57.381]                     envir = parent.frame()) 
[17:42:57.381]                   {
[17:42:57.381]                     default_workers <- missing(workers)
[17:42:57.381]                     if (is.function(workers)) 
[17:42:57.381]                       workers <- workers()
[17:42:57.381]                     workers <- structure(as.integer(workers), 
[17:42:57.381]                       class = class(workers))
[17:42:57.381]                     stop_if_not(is.finite(workers), workers >= 
[17:42:57.381]                       1L)
[17:42:57.381]                     if ((workers == 1L && !inherits(workers, 
[17:42:57.381]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:57.381]                       if (default_workers) 
[17:42:57.381]                         supportsMulticore(warn = TRUE)
[17:42:57.381]                       return(sequential(..., envir = envir))
[17:42:57.381]                     }
[17:42:57.381]                     oopts <- options(mc.cores = workers)
[17:42:57.381]                     on.exit(options(oopts))
[17:42:57.381]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:57.381]                       envir = envir)
[17:42:57.381]                     if (!future$lazy) 
[17:42:57.381]                       future <- run(future)
[17:42:57.381]                     invisible(future)
[17:42:57.381]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:57.381]                 }
[17:42:57.381]             }
[17:42:57.381]         }
[17:42:57.381]     })
[17:42:57.381]     if (TRUE) {
[17:42:57.381]         base::sink(type = "output", split = FALSE)
[17:42:57.381]         if (TRUE) {
[17:42:57.381]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:57.381]         }
[17:42:57.381]         else {
[17:42:57.381]             ...future.result["stdout"] <- base::list(NULL)
[17:42:57.381]         }
[17:42:57.381]         base::close(...future.stdout)
[17:42:57.381]         ...future.stdout <- NULL
[17:42:57.381]     }
[17:42:57.381]     ...future.result$conditions <- ...future.conditions
[17:42:57.381]     ...future.result$finished <- base::Sys.time()
[17:42:57.381]     ...future.result
[17:42:57.381] }
[17:42:57.383] plan(): Setting new future strategy stack:
[17:42:57.383] List of future strategies:
[17:42:57.383] 1. sequential:
[17:42:57.383]    - args: function (..., envir = parent.frame())
[17:42:57.383]    - tweaked: FALSE
[17:42:57.383]    - call: NULL
[17:42:57.385] plan(): nbrOfWorkers() = 1
[17:42:57.386] plan(): Setting new future strategy stack:
[17:42:57.386] List of future strategies:
[17:42:57.386] 1. multicore:
[17:42:57.386]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:57.386]    - tweaked: FALSE
[17:42:57.386]    - call: plan(multicore)
[17:42:57.390] plan(): nbrOfWorkers() = 1
[17:42:57.390] SequentialFuture started (and completed)
SequentialFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 56 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: 56280105-ab48-3cfb-51ca-f6f685381758
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[1] 0
*** multicore(..., globals = FALSE) with globals and blocking
 - Creating multicore future #1 ...
[17:42:57.394] getGlobalsAndPackages() ...
[17:42:57.394] Not searching for globals
[17:42:57.395] - globals: [0] <none>
[17:42:57.395] getGlobalsAndPackages() ... DONE
[17:42:57.395] Packages needed by the future expression (n = 0): <none>
[17:42:57.395] Packages needed by future strategies (n = 0): <none>
[17:42:57.396] {
[17:42:57.396]     {
[17:42:57.396]         {
[17:42:57.396]             ...future.startTime <- base::Sys.time()
[17:42:57.396]             {
[17:42:57.396]                 {
[17:42:57.396]                   {
[17:42:57.396]                     base::local({
[17:42:57.396]                       has_future <- base::requireNamespace("future", 
[17:42:57.396]                         quietly = TRUE)
[17:42:57.396]                       if (has_future) {
[17:42:57.396]                         ns <- base::getNamespace("future")
[17:42:57.396]                         version <- ns[[".package"]][["version"]]
[17:42:57.396]                         if (is.null(version)) 
[17:42:57.396]                           version <- utils::packageVersion("future")
[17:42:57.396]                       }
[17:42:57.396]                       else {
[17:42:57.396]                         version <- NULL
[17:42:57.396]                       }
[17:42:57.396]                       if (!has_future || version < "1.8.0") {
[17:42:57.396]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:57.396]                           "", base::R.version$version.string), 
[17:42:57.396]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:57.396]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:57.396]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:57.396]                             "release", "version")], collapse = " "), 
[17:42:57.396]                           hostname = base::Sys.info()[["nodename"]])
[17:42:57.396]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:57.396]                           info)
[17:42:57.396]                         info <- base::paste(info, collapse = "; ")
[17:42:57.396]                         if (!has_future) {
[17:42:57.396]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:57.396]                             info)
[17:42:57.396]                         }
[17:42:57.396]                         else {
[17:42:57.396]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:57.396]                             info, version)
[17:42:57.396]                         }
[17:42:57.396]                         base::stop(msg)
[17:42:57.396]                       }
[17:42:57.396]                     })
[17:42:57.396]                   }
[17:42:57.396]                   options(future.plan = NULL)
[17:42:57.396]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.396]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:57.396]                 }
[17:42:57.396]                 ...future.workdir <- getwd()
[17:42:57.396]             }
[17:42:57.396]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:57.396]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:57.396]         }
[17:42:57.396]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:57.396]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:57.396]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:57.396]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:57.396]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:57.396]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:57.396]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:57.396]             base::names(...future.oldOptions))
[17:42:57.396]     }
[17:42:57.396]     if (FALSE) {
[17:42:57.396]     }
[17:42:57.396]     else {
[17:42:57.396]         if (TRUE) {
[17:42:57.396]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:57.396]                 open = "w")
[17:42:57.396]         }
[17:42:57.396]         else {
[17:42:57.396]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:57.396]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:57.396]         }
[17:42:57.396]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:57.396]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:57.396]             base::sink(type = "output", split = FALSE)
[17:42:57.396]             base::close(...future.stdout)
[17:42:57.396]         }, add = TRUE)
[17:42:57.396]     }
[17:42:57.396]     ...future.frame <- base::sys.nframe()
[17:42:57.396]     ...future.conditions <- base::list()
[17:42:57.396]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:57.396]     if (FALSE) {
[17:42:57.396]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:57.396]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:57.396]     }
[17:42:57.396]     ...future.result <- base::tryCatch({
[17:42:57.396]         base::withCallingHandlers({
[17:42:57.396]             ...future.value <- base::withVisible(base::local({
[17:42:57.396]                 ii
[17:42:57.396]             }))
[17:42:57.396]             future::FutureResult(value = ...future.value$value, 
[17:42:57.396]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.396]                   ...future.rng), globalenv = if (FALSE) 
[17:42:57.396]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:57.396]                     ...future.globalenv.names))
[17:42:57.396]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:57.396]         }, condition = base::local({
[17:42:57.396]             c <- base::c
[17:42:57.396]             inherits <- base::inherits
[17:42:57.396]             invokeRestart <- base::invokeRestart
[17:42:57.396]             length <- base::length
[17:42:57.396]             list <- base::list
[17:42:57.396]             seq.int <- base::seq.int
[17:42:57.396]             signalCondition <- base::signalCondition
[17:42:57.396]             sys.calls <- base::sys.calls
[17:42:57.396]             `[[` <- base::`[[`
[17:42:57.396]             `+` <- base::`+`
[17:42:57.396]             `<<-` <- base::`<<-`
[17:42:57.396]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:57.396]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:57.396]                   3L)]
[17:42:57.396]             }
[17:42:57.396]             function(cond) {
[17:42:57.396]                 is_error <- inherits(cond, "error")
[17:42:57.396]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:57.396]                   NULL)
[17:42:57.396]                 if (is_error) {
[17:42:57.396]                   sessionInformation <- function() {
[17:42:57.396]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:57.396]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:57.396]                       search = base::search(), system = base::Sys.info())
[17:42:57.396]                   }
[17:42:57.396]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.396]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:57.396]                     cond$call), session = sessionInformation(), 
[17:42:57.396]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:57.396]                   signalCondition(cond)
[17:42:57.396]                 }
[17:42:57.396]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:57.396]                 "immediateCondition"))) {
[17:42:57.396]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:57.396]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.396]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:57.396]                   if (TRUE && !signal) {
[17:42:57.396]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.396]                     {
[17:42:57.396]                       inherits <- base::inherits
[17:42:57.396]                       invokeRestart <- base::invokeRestart
[17:42:57.396]                       is.null <- base::is.null
[17:42:57.396]                       muffled <- FALSE
[17:42:57.396]                       if (inherits(cond, "message")) {
[17:42:57.396]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.396]                         if (muffled) 
[17:42:57.396]                           invokeRestart("muffleMessage")
[17:42:57.396]                       }
[17:42:57.396]                       else if (inherits(cond, "warning")) {
[17:42:57.396]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.396]                         if (muffled) 
[17:42:57.396]                           invokeRestart("muffleWarning")
[17:42:57.396]                       }
[17:42:57.396]                       else if (inherits(cond, "condition")) {
[17:42:57.396]                         if (!is.null(pattern)) {
[17:42:57.396]                           computeRestarts <- base::computeRestarts
[17:42:57.396]                           grepl <- base::grepl
[17:42:57.396]                           restarts <- computeRestarts(cond)
[17:42:57.396]                           for (restart in restarts) {
[17:42:57.396]                             name <- restart$name
[17:42:57.396]                             if (is.null(name)) 
[17:42:57.396]                               next
[17:42:57.396]                             if (!grepl(pattern, name)) 
[17:42:57.396]                               next
[17:42:57.396]                             invokeRestart(restart)
[17:42:57.396]                             muffled <- TRUE
[17:42:57.396]                             break
[17:42:57.396]                           }
[17:42:57.396]                         }
[17:42:57.396]                       }
[17:42:57.396]                       invisible(muffled)
[17:42:57.396]                     }
[17:42:57.396]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.396]                   }
[17:42:57.396]                 }
[17:42:57.396]                 else {
[17:42:57.396]                   if (TRUE) {
[17:42:57.396]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.396]                     {
[17:42:57.396]                       inherits <- base::inherits
[17:42:57.396]                       invokeRestart <- base::invokeRestart
[17:42:57.396]                       is.null <- base::is.null
[17:42:57.396]                       muffled <- FALSE
[17:42:57.396]                       if (inherits(cond, "message")) {
[17:42:57.396]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.396]                         if (muffled) 
[17:42:57.396]                           invokeRestart("muffleMessage")
[17:42:57.396]                       }
[17:42:57.396]                       else if (inherits(cond, "warning")) {
[17:42:57.396]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.396]                         if (muffled) 
[17:42:57.396]                           invokeRestart("muffleWarning")
[17:42:57.396]                       }
[17:42:57.396]                       else if (inherits(cond, "condition")) {
[17:42:57.396]                         if (!is.null(pattern)) {
[17:42:57.396]                           computeRestarts <- base::computeRestarts
[17:42:57.396]                           grepl <- base::grepl
[17:42:57.396]                           restarts <- computeRestarts(cond)
[17:42:57.396]                           for (restart in restarts) {
[17:42:57.396]                             name <- restart$name
[17:42:57.396]                             if (is.null(name)) 
[17:42:57.396]                               next
[17:42:57.396]                             if (!grepl(pattern, name)) 
[17:42:57.396]                               next
[17:42:57.396]                             invokeRestart(restart)
[17:42:57.396]                             muffled <- TRUE
[17:42:57.396]                             break
[17:42:57.396]                           }
[17:42:57.396]                         }
[17:42:57.396]                       }
[17:42:57.396]                       invisible(muffled)
[17:42:57.396]                     }
[17:42:57.396]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.396]                   }
[17:42:57.396]                 }
[17:42:57.396]             }
[17:42:57.396]         }))
[17:42:57.396]     }, error = function(ex) {
[17:42:57.396]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:57.396]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.396]                 ...future.rng), started = ...future.startTime, 
[17:42:57.396]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:57.396]             version = "1.8"), class = "FutureResult")
[17:42:57.396]     }, finally = {
[17:42:57.396]         if (!identical(...future.workdir, getwd())) 
[17:42:57.396]             setwd(...future.workdir)
[17:42:57.396]         {
[17:42:57.396]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:57.396]                 ...future.oldOptions$nwarnings <- NULL
[17:42:57.396]             }
[17:42:57.396]             base::options(...future.oldOptions)
[17:42:57.396]             if (.Platform$OS.type == "windows") {
[17:42:57.396]                 old_names <- names(...future.oldEnvVars)
[17:42:57.396]                 envs <- base::Sys.getenv()
[17:42:57.396]                 names <- names(envs)
[17:42:57.396]                 common <- intersect(names, old_names)
[17:42:57.396]                 added <- setdiff(names, old_names)
[17:42:57.396]                 removed <- setdiff(old_names, names)
[17:42:57.396]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:57.396]                   envs[common]]
[17:42:57.396]                 NAMES <- toupper(changed)
[17:42:57.396]                 args <- list()
[17:42:57.396]                 for (kk in seq_along(NAMES)) {
[17:42:57.396]                   name <- changed[[kk]]
[17:42:57.396]                   NAME <- NAMES[[kk]]
[17:42:57.396]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.396]                     next
[17:42:57.396]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.396]                 }
[17:42:57.396]                 NAMES <- toupper(added)
[17:42:57.396]                 for (kk in seq_along(NAMES)) {
[17:42:57.396]                   name <- added[[kk]]
[17:42:57.396]                   NAME <- NAMES[[kk]]
[17:42:57.396]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.396]                     next
[17:42:57.396]                   args[[name]] <- ""
[17:42:57.396]                 }
[17:42:57.396]                 NAMES <- toupper(removed)
[17:42:57.396]                 for (kk in seq_along(NAMES)) {
[17:42:57.396]                   name <- removed[[kk]]
[17:42:57.396]                   NAME <- NAMES[[kk]]
[17:42:57.396]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.396]                     next
[17:42:57.396]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.396]                 }
[17:42:57.396]                 if (length(args) > 0) 
[17:42:57.396]                   base::do.call(base::Sys.setenv, args = args)
[17:42:57.396]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:57.396]             }
[17:42:57.396]             else {
[17:42:57.396]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:57.396]             }
[17:42:57.396]             {
[17:42:57.396]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:57.396]                   0L) {
[17:42:57.396]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:57.396]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:57.396]                   base::options(opts)
[17:42:57.396]                 }
[17:42:57.396]                 {
[17:42:57.396]                   {
[17:42:57.396]                     NULL
[17:42:57.396]                     RNGkind("Mersenne-Twister")
[17:42:57.396]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:57.396]                       inherits = FALSE)
[17:42:57.396]                   }
[17:42:57.396]                   options(future.plan = NULL)
[17:42:57.396]                   if (is.na(NA_character_)) 
[17:42:57.396]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.396]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:57.396]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:57.396]                     envir = parent.frame()) 
[17:42:57.396]                   {
[17:42:57.396]                     default_workers <- missing(workers)
[17:42:57.396]                     if (is.function(workers)) 
[17:42:57.396]                       workers <- workers()
[17:42:57.396]                     workers <- structure(as.integer(workers), 
[17:42:57.396]                       class = class(workers))
[17:42:57.396]                     stop_if_not(is.finite(workers), workers >= 
[17:42:57.396]                       1L)
[17:42:57.396]                     if ((workers == 1L && !inherits(workers, 
[17:42:57.396]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:57.396]                       if (default_workers) 
[17:42:57.396]                         supportsMulticore(warn = TRUE)
[17:42:57.396]                       return(sequential(..., envir = envir))
[17:42:57.396]                     }
[17:42:57.396]                     oopts <- options(mc.cores = workers)
[17:42:57.396]                     on.exit(options(oopts))
[17:42:57.396]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:57.396]                       envir = envir)
[17:42:57.396]                     if (!future$lazy) 
[17:42:57.396]                       future <- run(future)
[17:42:57.396]                     invisible(future)
[17:42:57.396]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:57.396]                 }
[17:42:57.396]             }
[17:42:57.396]         }
[17:42:57.396]     })
[17:42:57.396]     if (TRUE) {
[17:42:57.396]         base::sink(type = "output", split = FALSE)
[17:42:57.396]         if (TRUE) {
[17:42:57.396]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:57.396]         }
[17:42:57.396]         else {
[17:42:57.396]             ...future.result["stdout"] <- base::list(NULL)
[17:42:57.396]         }
[17:42:57.396]         base::close(...future.stdout)
[17:42:57.396]         ...future.stdout <- NULL
[17:42:57.396]     }
[17:42:57.396]     ...future.result$conditions <- ...future.conditions
[17:42:57.396]     ...future.result$finished <- base::Sys.time()
[17:42:57.396]     ...future.result
[17:42:57.396] }
[17:42:57.397] plan(): Setting new future strategy stack:
[17:42:57.397] List of future strategies:
[17:42:57.397] 1. sequential:
[17:42:57.397]    - args: function (..., envir = parent.frame())
[17:42:57.397]    - tweaked: FALSE
[17:42:57.397]    - call: NULL
[17:42:57.398] plan(): nbrOfWorkers() = 1
[17:42:57.399] plan(): Setting new future strategy stack:
[17:42:57.399] List of future strategies:
[17:42:57.399] 1. multicore:
[17:42:57.399]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:57.399]    - tweaked: FALSE
[17:42:57.399]    - call: plan(multicore)
[17:42:57.402] plan(): nbrOfWorkers() = 1
[17:42:57.402] SequentialFuture started (and completed)
 - Creating multicore future #2 ...
[17:42:57.406] getGlobalsAndPackages() ...
[17:42:57.406] Not searching for globals
[17:42:57.406] - globals: [0] <none>
[17:42:57.407] getGlobalsAndPackages() ... DONE
[17:42:57.407] Packages needed by the future expression (n = 0): <none>
[17:42:57.407] Packages needed by future strategies (n = 0): <none>
[17:42:57.408] {
[17:42:57.408]     {
[17:42:57.408]         {
[17:42:57.408]             ...future.startTime <- base::Sys.time()
[17:42:57.408]             {
[17:42:57.408]                 {
[17:42:57.408]                   {
[17:42:57.408]                     base::local({
[17:42:57.408]                       has_future <- base::requireNamespace("future", 
[17:42:57.408]                         quietly = TRUE)
[17:42:57.408]                       if (has_future) {
[17:42:57.408]                         ns <- base::getNamespace("future")
[17:42:57.408]                         version <- ns[[".package"]][["version"]]
[17:42:57.408]                         if (is.null(version)) 
[17:42:57.408]                           version <- utils::packageVersion("future")
[17:42:57.408]                       }
[17:42:57.408]                       else {
[17:42:57.408]                         version <- NULL
[17:42:57.408]                       }
[17:42:57.408]                       if (!has_future || version < "1.8.0") {
[17:42:57.408]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:57.408]                           "", base::R.version$version.string), 
[17:42:57.408]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:57.408]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:57.408]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:57.408]                             "release", "version")], collapse = " "), 
[17:42:57.408]                           hostname = base::Sys.info()[["nodename"]])
[17:42:57.408]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:57.408]                           info)
[17:42:57.408]                         info <- base::paste(info, collapse = "; ")
[17:42:57.408]                         if (!has_future) {
[17:42:57.408]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:57.408]                             info)
[17:42:57.408]                         }
[17:42:57.408]                         else {
[17:42:57.408]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:57.408]                             info, version)
[17:42:57.408]                         }
[17:42:57.408]                         base::stop(msg)
[17:42:57.408]                       }
[17:42:57.408]                     })
[17:42:57.408]                   }
[17:42:57.408]                   options(future.plan = NULL)
[17:42:57.408]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.408]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:57.408]                 }
[17:42:57.408]                 ...future.workdir <- getwd()
[17:42:57.408]             }
[17:42:57.408]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:57.408]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:57.408]         }
[17:42:57.408]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:57.408]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:57.408]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:57.408]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:57.408]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:57.408]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:57.408]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:57.408]             base::names(...future.oldOptions))
[17:42:57.408]     }
[17:42:57.408]     if (FALSE) {
[17:42:57.408]     }
[17:42:57.408]     else {
[17:42:57.408]         if (TRUE) {
[17:42:57.408]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:57.408]                 open = "w")
[17:42:57.408]         }
[17:42:57.408]         else {
[17:42:57.408]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:57.408]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:57.408]         }
[17:42:57.408]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:57.408]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:57.408]             base::sink(type = "output", split = FALSE)
[17:42:57.408]             base::close(...future.stdout)
[17:42:57.408]         }, add = TRUE)
[17:42:57.408]     }
[17:42:57.408]     ...future.frame <- base::sys.nframe()
[17:42:57.408]     ...future.conditions <- base::list()
[17:42:57.408]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:57.408]     if (FALSE) {
[17:42:57.408]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:57.408]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:57.408]     }
[17:42:57.408]     ...future.result <- base::tryCatch({
[17:42:57.408]         base::withCallingHandlers({
[17:42:57.408]             ...future.value <- base::withVisible(base::local({
[17:42:57.408]                 ii
[17:42:57.408]             }))
[17:42:57.408]             future::FutureResult(value = ...future.value$value, 
[17:42:57.408]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.408]                   ...future.rng), globalenv = if (FALSE) 
[17:42:57.408]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:57.408]                     ...future.globalenv.names))
[17:42:57.408]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:57.408]         }, condition = base::local({
[17:42:57.408]             c <- base::c
[17:42:57.408]             inherits <- base::inherits
[17:42:57.408]             invokeRestart <- base::invokeRestart
[17:42:57.408]             length <- base::length
[17:42:57.408]             list <- base::list
[17:42:57.408]             seq.int <- base::seq.int
[17:42:57.408]             signalCondition <- base::signalCondition
[17:42:57.408]             sys.calls <- base::sys.calls
[17:42:57.408]             `[[` <- base::`[[`
[17:42:57.408]             `+` <- base::`+`
[17:42:57.408]             `<<-` <- base::`<<-`
[17:42:57.408]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:57.408]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:57.408]                   3L)]
[17:42:57.408]             }
[17:42:57.408]             function(cond) {
[17:42:57.408]                 is_error <- inherits(cond, "error")
[17:42:57.408]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:57.408]                   NULL)
[17:42:57.408]                 if (is_error) {
[17:42:57.408]                   sessionInformation <- function() {
[17:42:57.408]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:57.408]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:57.408]                       search = base::search(), system = base::Sys.info())
[17:42:57.408]                   }
[17:42:57.408]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.408]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:57.408]                     cond$call), session = sessionInformation(), 
[17:42:57.408]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:57.408]                   signalCondition(cond)
[17:42:57.408]                 }
[17:42:57.408]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:57.408]                 "immediateCondition"))) {
[17:42:57.408]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:57.408]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.408]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:57.408]                   if (TRUE && !signal) {
[17:42:57.408]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.408]                     {
[17:42:57.408]                       inherits <- base::inherits
[17:42:57.408]                       invokeRestart <- base::invokeRestart
[17:42:57.408]                       is.null <- base::is.null
[17:42:57.408]                       muffled <- FALSE
[17:42:57.408]                       if (inherits(cond, "message")) {
[17:42:57.408]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.408]                         if (muffled) 
[17:42:57.408]                           invokeRestart("muffleMessage")
[17:42:57.408]                       }
[17:42:57.408]                       else if (inherits(cond, "warning")) {
[17:42:57.408]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.408]                         if (muffled) 
[17:42:57.408]                           invokeRestart("muffleWarning")
[17:42:57.408]                       }
[17:42:57.408]                       else if (inherits(cond, "condition")) {
[17:42:57.408]                         if (!is.null(pattern)) {
[17:42:57.408]                           computeRestarts <- base::computeRestarts
[17:42:57.408]                           grepl <- base::grepl
[17:42:57.408]                           restarts <- computeRestarts(cond)
[17:42:57.408]                           for (restart in restarts) {
[17:42:57.408]                             name <- restart$name
[17:42:57.408]                             if (is.null(name)) 
[17:42:57.408]                               next
[17:42:57.408]                             if (!grepl(pattern, name)) 
[17:42:57.408]                               next
[17:42:57.408]                             invokeRestart(restart)
[17:42:57.408]                             muffled <- TRUE
[17:42:57.408]                             break
[17:42:57.408]                           }
[17:42:57.408]                         }
[17:42:57.408]                       }
[17:42:57.408]                       invisible(muffled)
[17:42:57.408]                     }
[17:42:57.408]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.408]                   }
[17:42:57.408]                 }
[17:42:57.408]                 else {
[17:42:57.408]                   if (TRUE) {
[17:42:57.408]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.408]                     {
[17:42:57.408]                       inherits <- base::inherits
[17:42:57.408]                       invokeRestart <- base::invokeRestart
[17:42:57.408]                       is.null <- base::is.null
[17:42:57.408]                       muffled <- FALSE
[17:42:57.408]                       if (inherits(cond, "message")) {
[17:42:57.408]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.408]                         if (muffled) 
[17:42:57.408]                           invokeRestart("muffleMessage")
[17:42:57.408]                       }
[17:42:57.408]                       else if (inherits(cond, "warning")) {
[17:42:57.408]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.408]                         if (muffled) 
[17:42:57.408]                           invokeRestart("muffleWarning")
[17:42:57.408]                       }
[17:42:57.408]                       else if (inherits(cond, "condition")) {
[17:42:57.408]                         if (!is.null(pattern)) {
[17:42:57.408]                           computeRestarts <- base::computeRestarts
[17:42:57.408]                           grepl <- base::grepl
[17:42:57.408]                           restarts <- computeRestarts(cond)
[17:42:57.408]                           for (restart in restarts) {
[17:42:57.408]                             name <- restart$name
[17:42:57.408]                             if (is.null(name)) 
[17:42:57.408]                               next
[17:42:57.408]                             if (!grepl(pattern, name)) 
[17:42:57.408]                               next
[17:42:57.408]                             invokeRestart(restart)
[17:42:57.408]                             muffled <- TRUE
[17:42:57.408]                             break
[17:42:57.408]                           }
[17:42:57.408]                         }
[17:42:57.408]                       }
[17:42:57.408]                       invisible(muffled)
[17:42:57.408]                     }
[17:42:57.408]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.408]                   }
[17:42:57.408]                 }
[17:42:57.408]             }
[17:42:57.408]         }))
[17:42:57.408]     }, error = function(ex) {
[17:42:57.408]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:57.408]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.408]                 ...future.rng), started = ...future.startTime, 
[17:42:57.408]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:57.408]             version = "1.8"), class = "FutureResult")
[17:42:57.408]     }, finally = {
[17:42:57.408]         if (!identical(...future.workdir, getwd())) 
[17:42:57.408]             setwd(...future.workdir)
[17:42:57.408]         {
[17:42:57.408]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:57.408]                 ...future.oldOptions$nwarnings <- NULL
[17:42:57.408]             }
[17:42:57.408]             base::options(...future.oldOptions)
[17:42:57.408]             if (.Platform$OS.type == "windows") {
[17:42:57.408]                 old_names <- names(...future.oldEnvVars)
[17:42:57.408]                 envs <- base::Sys.getenv()
[17:42:57.408]                 names <- names(envs)
[17:42:57.408]                 common <- intersect(names, old_names)
[17:42:57.408]                 added <- setdiff(names, old_names)
[17:42:57.408]                 removed <- setdiff(old_names, names)
[17:42:57.408]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:57.408]                   envs[common]]
[17:42:57.408]                 NAMES <- toupper(changed)
[17:42:57.408]                 args <- list()
[17:42:57.408]                 for (kk in seq_along(NAMES)) {
[17:42:57.408]                   name <- changed[[kk]]
[17:42:57.408]                   NAME <- NAMES[[kk]]
[17:42:57.408]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.408]                     next
[17:42:57.408]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.408]                 }
[17:42:57.408]                 NAMES <- toupper(added)
[17:42:57.408]                 for (kk in seq_along(NAMES)) {
[17:42:57.408]                   name <- added[[kk]]
[17:42:57.408]                   NAME <- NAMES[[kk]]
[17:42:57.408]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.408]                     next
[17:42:57.408]                   args[[name]] <- ""
[17:42:57.408]                 }
[17:42:57.408]                 NAMES <- toupper(removed)
[17:42:57.408]                 for (kk in seq_along(NAMES)) {
[17:42:57.408]                   name <- removed[[kk]]
[17:42:57.408]                   NAME <- NAMES[[kk]]
[17:42:57.408]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.408]                     next
[17:42:57.408]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.408]                 }
[17:42:57.408]                 if (length(args) > 0) 
[17:42:57.408]                   base::do.call(base::Sys.setenv, args = args)
[17:42:57.408]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:57.408]             }
[17:42:57.408]             else {
[17:42:57.408]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:57.408]             }
[17:42:57.408]             {
[17:42:57.408]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:57.408]                   0L) {
[17:42:57.408]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:57.408]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:57.408]                   base::options(opts)
[17:42:57.408]                 }
[17:42:57.408]                 {
[17:42:57.408]                   {
[17:42:57.408]                     NULL
[17:42:57.408]                     RNGkind("Mersenne-Twister")
[17:42:57.408]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:57.408]                       inherits = FALSE)
[17:42:57.408]                   }
[17:42:57.408]                   options(future.plan = NULL)
[17:42:57.408]                   if (is.na(NA_character_)) 
[17:42:57.408]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.408]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:57.408]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:57.408]                     envir = parent.frame()) 
[17:42:57.408]                   {
[17:42:57.408]                     default_workers <- missing(workers)
[17:42:57.408]                     if (is.function(workers)) 
[17:42:57.408]                       workers <- workers()
[17:42:57.408]                     workers <- structure(as.integer(workers), 
[17:42:57.408]                       class = class(workers))
[17:42:57.408]                     stop_if_not(is.finite(workers), workers >= 
[17:42:57.408]                       1L)
[17:42:57.408]                     if ((workers == 1L && !inherits(workers, 
[17:42:57.408]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:57.408]                       if (default_workers) 
[17:42:57.408]                         supportsMulticore(warn = TRUE)
[17:42:57.408]                       return(sequential(..., envir = envir))
[17:42:57.408]                     }
[17:42:57.408]                     oopts <- options(mc.cores = workers)
[17:42:57.408]                     on.exit(options(oopts))
[17:42:57.408]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:57.408]                       envir = envir)
[17:42:57.408]                     if (!future$lazy) 
[17:42:57.408]                       future <- run(future)
[17:42:57.408]                     invisible(future)
[17:42:57.408]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:57.408]                 }
[17:42:57.408]             }
[17:42:57.408]         }
[17:42:57.408]     })
[17:42:57.408]     if (TRUE) {
[17:42:57.408]         base::sink(type = "output", split = FALSE)
[17:42:57.408]         if (TRUE) {
[17:42:57.408]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:57.408]         }
[17:42:57.408]         else {
[17:42:57.408]             ...future.result["stdout"] <- base::list(NULL)
[17:42:57.408]         }
[17:42:57.408]         base::close(...future.stdout)
[17:42:57.408]         ...future.stdout <- NULL
[17:42:57.408]     }
[17:42:57.408]     ...future.result$conditions <- ...future.conditions
[17:42:57.408]     ...future.result$finished <- base::Sys.time()
[17:42:57.408]     ...future.result
[17:42:57.408] }
[17:42:57.410] plan(): Setting new future strategy stack:
[17:42:57.410] List of future strategies:
[17:42:57.410] 1. sequential:
[17:42:57.410]    - args: function (..., envir = parent.frame())
[17:42:57.410]    - tweaked: FALSE
[17:42:57.410]    - call: NULL
[17:42:57.410] plan(): nbrOfWorkers() = 1
[17:42:57.411] plan(): Setting new future strategy stack:
[17:42:57.411] List of future strategies:
[17:42:57.411] 1. multicore:
[17:42:57.411]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:57.411]    - tweaked: FALSE
[17:42:57.411]    - call: plan(multicore)
[17:42:57.414] plan(): nbrOfWorkers() = 1
[17:42:57.414] SequentialFuture started (and completed)
 - Creating multicore future #3 ...
[17:42:57.418] getGlobalsAndPackages() ...
[17:42:57.418] Not searching for globals
[17:42:57.418] - globals: [0] <none>
[17:42:57.418] getGlobalsAndPackages() ... DONE
[17:42:57.418] Packages needed by the future expression (n = 0): <none>
[17:42:57.418] Packages needed by future strategies (n = 0): <none>
[17:42:57.419] {
[17:42:57.419]     {
[17:42:57.419]         {
[17:42:57.419]             ...future.startTime <- base::Sys.time()
[17:42:57.419]             {
[17:42:57.419]                 {
[17:42:57.419]                   {
[17:42:57.419]                     base::local({
[17:42:57.419]                       has_future <- base::requireNamespace("future", 
[17:42:57.419]                         quietly = TRUE)
[17:42:57.419]                       if (has_future) {
[17:42:57.419]                         ns <- base::getNamespace("future")
[17:42:57.419]                         version <- ns[[".package"]][["version"]]
[17:42:57.419]                         if (is.null(version)) 
[17:42:57.419]                           version <- utils::packageVersion("future")
[17:42:57.419]                       }
[17:42:57.419]                       else {
[17:42:57.419]                         version <- NULL
[17:42:57.419]                       }
[17:42:57.419]                       if (!has_future || version < "1.8.0") {
[17:42:57.419]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:57.419]                           "", base::R.version$version.string), 
[17:42:57.419]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:57.419]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:57.419]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:57.419]                             "release", "version")], collapse = " "), 
[17:42:57.419]                           hostname = base::Sys.info()[["nodename"]])
[17:42:57.419]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:57.419]                           info)
[17:42:57.419]                         info <- base::paste(info, collapse = "; ")
[17:42:57.419]                         if (!has_future) {
[17:42:57.419]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:57.419]                             info)
[17:42:57.419]                         }
[17:42:57.419]                         else {
[17:42:57.419]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:57.419]                             info, version)
[17:42:57.419]                         }
[17:42:57.419]                         base::stop(msg)
[17:42:57.419]                       }
[17:42:57.419]                     })
[17:42:57.419]                   }
[17:42:57.419]                   options(future.plan = NULL)
[17:42:57.419]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.419]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:57.419]                 }
[17:42:57.419]                 ...future.workdir <- getwd()
[17:42:57.419]             }
[17:42:57.419]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:57.419]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:57.419]         }
[17:42:57.419]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:57.419]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:57.419]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:57.419]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:57.419]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:57.419]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:57.419]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:57.419]             base::names(...future.oldOptions))
[17:42:57.419]     }
[17:42:57.419]     if (FALSE) {
[17:42:57.419]     }
[17:42:57.419]     else {
[17:42:57.419]         if (TRUE) {
[17:42:57.419]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:57.419]                 open = "w")
[17:42:57.419]         }
[17:42:57.419]         else {
[17:42:57.419]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:57.419]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:57.419]         }
[17:42:57.419]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:57.419]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:57.419]             base::sink(type = "output", split = FALSE)
[17:42:57.419]             base::close(...future.stdout)
[17:42:57.419]         }, add = TRUE)
[17:42:57.419]     }
[17:42:57.419]     ...future.frame <- base::sys.nframe()
[17:42:57.419]     ...future.conditions <- base::list()
[17:42:57.419]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:57.419]     if (FALSE) {
[17:42:57.419]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:57.419]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:57.419]     }
[17:42:57.419]     ...future.result <- base::tryCatch({
[17:42:57.419]         base::withCallingHandlers({
[17:42:57.419]             ...future.value <- base::withVisible(base::local({
[17:42:57.419]                 ii
[17:42:57.419]             }))
[17:42:57.419]             future::FutureResult(value = ...future.value$value, 
[17:42:57.419]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.419]                   ...future.rng), globalenv = if (FALSE) 
[17:42:57.419]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:57.419]                     ...future.globalenv.names))
[17:42:57.419]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:57.419]         }, condition = base::local({
[17:42:57.419]             c <- base::c
[17:42:57.419]             inherits <- base::inherits
[17:42:57.419]             invokeRestart <- base::invokeRestart
[17:42:57.419]             length <- base::length
[17:42:57.419]             list <- base::list
[17:42:57.419]             seq.int <- base::seq.int
[17:42:57.419]             signalCondition <- base::signalCondition
[17:42:57.419]             sys.calls <- base::sys.calls
[17:42:57.419]             `[[` <- base::`[[`
[17:42:57.419]             `+` <- base::`+`
[17:42:57.419]             `<<-` <- base::`<<-`
[17:42:57.419]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:57.419]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:57.419]                   3L)]
[17:42:57.419]             }
[17:42:57.419]             function(cond) {
[17:42:57.419]                 is_error <- inherits(cond, "error")
[17:42:57.419]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:57.419]                   NULL)
[17:42:57.419]                 if (is_error) {
[17:42:57.419]                   sessionInformation <- function() {
[17:42:57.419]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:57.419]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:57.419]                       search = base::search(), system = base::Sys.info())
[17:42:57.419]                   }
[17:42:57.419]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.419]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:57.419]                     cond$call), session = sessionInformation(), 
[17:42:57.419]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:57.419]                   signalCondition(cond)
[17:42:57.419]                 }
[17:42:57.419]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:57.419]                 "immediateCondition"))) {
[17:42:57.419]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:57.419]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.419]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:57.419]                   if (TRUE && !signal) {
[17:42:57.419]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.419]                     {
[17:42:57.419]                       inherits <- base::inherits
[17:42:57.419]                       invokeRestart <- base::invokeRestart
[17:42:57.419]                       is.null <- base::is.null
[17:42:57.419]                       muffled <- FALSE
[17:42:57.419]                       if (inherits(cond, "message")) {
[17:42:57.419]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.419]                         if (muffled) 
[17:42:57.419]                           invokeRestart("muffleMessage")
[17:42:57.419]                       }
[17:42:57.419]                       else if (inherits(cond, "warning")) {
[17:42:57.419]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.419]                         if (muffled) 
[17:42:57.419]                           invokeRestart("muffleWarning")
[17:42:57.419]                       }
[17:42:57.419]                       else if (inherits(cond, "condition")) {
[17:42:57.419]                         if (!is.null(pattern)) {
[17:42:57.419]                           computeRestarts <- base::computeRestarts
[17:42:57.419]                           grepl <- base::grepl
[17:42:57.419]                           restarts <- computeRestarts(cond)
[17:42:57.419]                           for (restart in restarts) {
[17:42:57.419]                             name <- restart$name
[17:42:57.419]                             if (is.null(name)) 
[17:42:57.419]                               next
[17:42:57.419]                             if (!grepl(pattern, name)) 
[17:42:57.419]                               next
[17:42:57.419]                             invokeRestart(restart)
[17:42:57.419]                             muffled <- TRUE
[17:42:57.419]                             break
[17:42:57.419]                           }
[17:42:57.419]                         }
[17:42:57.419]                       }
[17:42:57.419]                       invisible(muffled)
[17:42:57.419]                     }
[17:42:57.419]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.419]                   }
[17:42:57.419]                 }
[17:42:57.419]                 else {
[17:42:57.419]                   if (TRUE) {
[17:42:57.419]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.419]                     {
[17:42:57.419]                       inherits <- base::inherits
[17:42:57.419]                       invokeRestart <- base::invokeRestart
[17:42:57.419]                       is.null <- base::is.null
[17:42:57.419]                       muffled <- FALSE
[17:42:57.419]                       if (inherits(cond, "message")) {
[17:42:57.419]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.419]                         if (muffled) 
[17:42:57.419]                           invokeRestart("muffleMessage")
[17:42:57.419]                       }
[17:42:57.419]                       else if (inherits(cond, "warning")) {
[17:42:57.419]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.419]                         if (muffled) 
[17:42:57.419]                           invokeRestart("muffleWarning")
[17:42:57.419]                       }
[17:42:57.419]                       else if (inherits(cond, "condition")) {
[17:42:57.419]                         if (!is.null(pattern)) {
[17:42:57.419]                           computeRestarts <- base::computeRestarts
[17:42:57.419]                           grepl <- base::grepl
[17:42:57.419]                           restarts <- computeRestarts(cond)
[17:42:57.419]                           for (restart in restarts) {
[17:42:57.419]                             name <- restart$name
[17:42:57.419]                             if (is.null(name)) 
[17:42:57.419]                               next
[17:42:57.419]                             if (!grepl(pattern, name)) 
[17:42:57.419]                               next
[17:42:57.419]                             invokeRestart(restart)
[17:42:57.419]                             muffled <- TRUE
[17:42:57.419]                             break
[17:42:57.419]                           }
[17:42:57.419]                         }
[17:42:57.419]                       }
[17:42:57.419]                       invisible(muffled)
[17:42:57.419]                     }
[17:42:57.419]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.419]                   }
[17:42:57.419]                 }
[17:42:57.419]             }
[17:42:57.419]         }))
[17:42:57.419]     }, error = function(ex) {
[17:42:57.419]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:57.419]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.419]                 ...future.rng), started = ...future.startTime, 
[17:42:57.419]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:57.419]             version = "1.8"), class = "FutureResult")
[17:42:57.419]     }, finally = {
[17:42:57.419]         if (!identical(...future.workdir, getwd())) 
[17:42:57.419]             setwd(...future.workdir)
[17:42:57.419]         {
[17:42:57.419]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:57.419]                 ...future.oldOptions$nwarnings <- NULL
[17:42:57.419]             }
[17:42:57.419]             base::options(...future.oldOptions)
[17:42:57.419]             if (.Platform$OS.type == "windows") {
[17:42:57.419]                 old_names <- names(...future.oldEnvVars)
[17:42:57.419]                 envs <- base::Sys.getenv()
[17:42:57.419]                 names <- names(envs)
[17:42:57.419]                 common <- intersect(names, old_names)
[17:42:57.419]                 added <- setdiff(names, old_names)
[17:42:57.419]                 removed <- setdiff(old_names, names)
[17:42:57.419]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:57.419]                   envs[common]]
[17:42:57.419]                 NAMES <- toupper(changed)
[17:42:57.419]                 args <- list()
[17:42:57.419]                 for (kk in seq_along(NAMES)) {
[17:42:57.419]                   name <- changed[[kk]]
[17:42:57.419]                   NAME <- NAMES[[kk]]
[17:42:57.419]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.419]                     next
[17:42:57.419]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.419]                 }
[17:42:57.419]                 NAMES <- toupper(added)
[17:42:57.419]                 for (kk in seq_along(NAMES)) {
[17:42:57.419]                   name <- added[[kk]]
[17:42:57.419]                   NAME <- NAMES[[kk]]
[17:42:57.419]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.419]                     next
[17:42:57.419]                   args[[name]] <- ""
[17:42:57.419]                 }
[17:42:57.419]                 NAMES <- toupper(removed)
[17:42:57.419]                 for (kk in seq_along(NAMES)) {
[17:42:57.419]                   name <- removed[[kk]]
[17:42:57.419]                   NAME <- NAMES[[kk]]
[17:42:57.419]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.419]                     next
[17:42:57.419]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.419]                 }
[17:42:57.419]                 if (length(args) > 0) 
[17:42:57.419]                   base::do.call(base::Sys.setenv, args = args)
[17:42:57.419]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:57.419]             }
[17:42:57.419]             else {
[17:42:57.419]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:57.419]             }
[17:42:57.419]             {
[17:42:57.419]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:57.419]                   0L) {
[17:42:57.419]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:57.419]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:57.419]                   base::options(opts)
[17:42:57.419]                 }
[17:42:57.419]                 {
[17:42:57.419]                   {
[17:42:57.419]                     NULL
[17:42:57.419]                     RNGkind("Mersenne-Twister")
[17:42:57.419]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:57.419]                       inherits = FALSE)
[17:42:57.419]                   }
[17:42:57.419]                   options(future.plan = NULL)
[17:42:57.419]                   if (is.na(NA_character_)) 
[17:42:57.419]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.419]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:57.419]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:57.419]                     envir = parent.frame()) 
[17:42:57.419]                   {
[17:42:57.419]                     default_workers <- missing(workers)
[17:42:57.419]                     if (is.function(workers)) 
[17:42:57.419]                       workers <- workers()
[17:42:57.419]                     workers <- structure(as.integer(workers), 
[17:42:57.419]                       class = class(workers))
[17:42:57.419]                     stop_if_not(is.finite(workers), workers >= 
[17:42:57.419]                       1L)
[17:42:57.419]                     if ((workers == 1L && !inherits(workers, 
[17:42:57.419]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:57.419]                       if (default_workers) 
[17:42:57.419]                         supportsMulticore(warn = TRUE)
[17:42:57.419]                       return(sequential(..., envir = envir))
[17:42:57.419]                     }
[17:42:57.419]                     oopts <- options(mc.cores = workers)
[17:42:57.419]                     on.exit(options(oopts))
[17:42:57.419]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:57.419]                       envir = envir)
[17:42:57.419]                     if (!future$lazy) 
[17:42:57.419]                       future <- run(future)
[17:42:57.419]                     invisible(future)
[17:42:57.419]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:57.419]                 }
[17:42:57.419]             }
[17:42:57.419]         }
[17:42:57.419]     })
[17:42:57.419]     if (TRUE) {
[17:42:57.419]         base::sink(type = "output", split = FALSE)
[17:42:57.419]         if (TRUE) {
[17:42:57.419]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:57.419]         }
[17:42:57.419]         else {
[17:42:57.419]             ...future.result["stdout"] <- base::list(NULL)
[17:42:57.419]         }
[17:42:57.419]         base::close(...future.stdout)
[17:42:57.419]         ...future.stdout <- NULL
[17:42:57.419]     }
[17:42:57.419]     ...future.result$conditions <- ...future.conditions
[17:42:57.419]     ...future.result$finished <- base::Sys.time()
[17:42:57.419]     ...future.result
[17:42:57.419] }
[17:42:57.421] plan(): Setting new future strategy stack:
[17:42:57.421] List of future strategies:
[17:42:57.421] 1. sequential:
[17:42:57.421]    - args: function (..., envir = parent.frame())
[17:42:57.421]    - tweaked: FALSE
[17:42:57.421]    - call: NULL
[17:42:57.421] plan(): nbrOfWorkers() = 1
[17:42:57.422] plan(): Setting new future strategy stack:
[17:42:57.422] List of future strategies:
[17:42:57.422] 1. multicore:
[17:42:57.422]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:57.422]    - tweaked: FALSE
[17:42:57.422]    - call: plan(multicore)
[17:42:57.425] plan(): nbrOfWorkers() = 1
[17:42:57.426] SequentialFuture started (and completed)
 - Creating multicore future #4 ...
[17:42:57.429] getGlobalsAndPackages() ...
[17:42:57.429] Not searching for globals
[17:42:57.429] - globals: [0] <none>
[17:42:57.429] getGlobalsAndPackages() ... DONE
[17:42:57.429] Packages needed by the future expression (n = 0): <none>
[17:42:57.430] Packages needed by future strategies (n = 0): <none>
[17:42:57.430] {
[17:42:57.430]     {
[17:42:57.430]         {
[17:42:57.430]             ...future.startTime <- base::Sys.time()
[17:42:57.430]             {
[17:42:57.430]                 {
[17:42:57.430]                   {
[17:42:57.430]                     base::local({
[17:42:57.430]                       has_future <- base::requireNamespace("future", 
[17:42:57.430]                         quietly = TRUE)
[17:42:57.430]                       if (has_future) {
[17:42:57.430]                         ns <- base::getNamespace("future")
[17:42:57.430]                         version <- ns[[".package"]][["version"]]
[17:42:57.430]                         if (is.null(version)) 
[17:42:57.430]                           version <- utils::packageVersion("future")
[17:42:57.430]                       }
[17:42:57.430]                       else {
[17:42:57.430]                         version <- NULL
[17:42:57.430]                       }
[17:42:57.430]                       if (!has_future || version < "1.8.0") {
[17:42:57.430]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:57.430]                           "", base::R.version$version.string), 
[17:42:57.430]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:57.430]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:57.430]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:57.430]                             "release", "version")], collapse = " "), 
[17:42:57.430]                           hostname = base::Sys.info()[["nodename"]])
[17:42:57.430]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:57.430]                           info)
[17:42:57.430]                         info <- base::paste(info, collapse = "; ")
[17:42:57.430]                         if (!has_future) {
[17:42:57.430]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:57.430]                             info)
[17:42:57.430]                         }
[17:42:57.430]                         else {
[17:42:57.430]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:57.430]                             info, version)
[17:42:57.430]                         }
[17:42:57.430]                         base::stop(msg)
[17:42:57.430]                       }
[17:42:57.430]                     })
[17:42:57.430]                   }
[17:42:57.430]                   options(future.plan = NULL)
[17:42:57.430]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.430]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:57.430]                 }
[17:42:57.430]                 ...future.workdir <- getwd()
[17:42:57.430]             }
[17:42:57.430]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:57.430]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:57.430]         }
[17:42:57.430]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:57.430]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:57.430]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:57.430]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:57.430]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:57.430]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:57.430]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:57.430]             base::names(...future.oldOptions))
[17:42:57.430]     }
[17:42:57.430]     if (FALSE) {
[17:42:57.430]     }
[17:42:57.430]     else {
[17:42:57.430]         if (TRUE) {
[17:42:57.430]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:57.430]                 open = "w")
[17:42:57.430]         }
[17:42:57.430]         else {
[17:42:57.430]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:57.430]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:57.430]         }
[17:42:57.430]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:57.430]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:57.430]             base::sink(type = "output", split = FALSE)
[17:42:57.430]             base::close(...future.stdout)
[17:42:57.430]         }, add = TRUE)
[17:42:57.430]     }
[17:42:57.430]     ...future.frame <- base::sys.nframe()
[17:42:57.430]     ...future.conditions <- base::list()
[17:42:57.430]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:57.430]     if (FALSE) {
[17:42:57.430]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:57.430]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:57.430]     }
[17:42:57.430]     ...future.result <- base::tryCatch({
[17:42:57.430]         base::withCallingHandlers({
[17:42:57.430]             ...future.value <- base::withVisible(base::local({
[17:42:57.430]                 ii
[17:42:57.430]             }))
[17:42:57.430]             future::FutureResult(value = ...future.value$value, 
[17:42:57.430]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.430]                   ...future.rng), globalenv = if (FALSE) 
[17:42:57.430]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:57.430]                     ...future.globalenv.names))
[17:42:57.430]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:57.430]         }, condition = base::local({
[17:42:57.430]             c <- base::c
[17:42:57.430]             inherits <- base::inherits
[17:42:57.430]             invokeRestart <- base::invokeRestart
[17:42:57.430]             length <- base::length
[17:42:57.430]             list <- base::list
[17:42:57.430]             seq.int <- base::seq.int
[17:42:57.430]             signalCondition <- base::signalCondition
[17:42:57.430]             sys.calls <- base::sys.calls
[17:42:57.430]             `[[` <- base::`[[`
[17:42:57.430]             `+` <- base::`+`
[17:42:57.430]             `<<-` <- base::`<<-`
[17:42:57.430]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:57.430]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:57.430]                   3L)]
[17:42:57.430]             }
[17:42:57.430]             function(cond) {
[17:42:57.430]                 is_error <- inherits(cond, "error")
[17:42:57.430]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:57.430]                   NULL)
[17:42:57.430]                 if (is_error) {
[17:42:57.430]                   sessionInformation <- function() {
[17:42:57.430]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:57.430]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:57.430]                       search = base::search(), system = base::Sys.info())
[17:42:57.430]                   }
[17:42:57.430]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.430]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:57.430]                     cond$call), session = sessionInformation(), 
[17:42:57.430]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:57.430]                   signalCondition(cond)
[17:42:57.430]                 }
[17:42:57.430]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:57.430]                 "immediateCondition"))) {
[17:42:57.430]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:57.430]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.430]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:57.430]                   if (TRUE && !signal) {
[17:42:57.430]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.430]                     {
[17:42:57.430]                       inherits <- base::inherits
[17:42:57.430]                       invokeRestart <- base::invokeRestart
[17:42:57.430]                       is.null <- base::is.null
[17:42:57.430]                       muffled <- FALSE
[17:42:57.430]                       if (inherits(cond, "message")) {
[17:42:57.430]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.430]                         if (muffled) 
[17:42:57.430]                           invokeRestart("muffleMessage")
[17:42:57.430]                       }
[17:42:57.430]                       else if (inherits(cond, "warning")) {
[17:42:57.430]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.430]                         if (muffled) 
[17:42:57.430]                           invokeRestart("muffleWarning")
[17:42:57.430]                       }
[17:42:57.430]                       else if (inherits(cond, "condition")) {
[17:42:57.430]                         if (!is.null(pattern)) {
[17:42:57.430]                           computeRestarts <- base::computeRestarts
[17:42:57.430]                           grepl <- base::grepl
[17:42:57.430]                           restarts <- computeRestarts(cond)
[17:42:57.430]                           for (restart in restarts) {
[17:42:57.430]                             name <- restart$name
[17:42:57.430]                             if (is.null(name)) 
[17:42:57.430]                               next
[17:42:57.430]                             if (!grepl(pattern, name)) 
[17:42:57.430]                               next
[17:42:57.430]                             invokeRestart(restart)
[17:42:57.430]                             muffled <- TRUE
[17:42:57.430]                             break
[17:42:57.430]                           }
[17:42:57.430]                         }
[17:42:57.430]                       }
[17:42:57.430]                       invisible(muffled)
[17:42:57.430]                     }
[17:42:57.430]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.430]                   }
[17:42:57.430]                 }
[17:42:57.430]                 else {
[17:42:57.430]                   if (TRUE) {
[17:42:57.430]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.430]                     {
[17:42:57.430]                       inherits <- base::inherits
[17:42:57.430]                       invokeRestart <- base::invokeRestart
[17:42:57.430]                       is.null <- base::is.null
[17:42:57.430]                       muffled <- FALSE
[17:42:57.430]                       if (inherits(cond, "message")) {
[17:42:57.430]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.430]                         if (muffled) 
[17:42:57.430]                           invokeRestart("muffleMessage")
[17:42:57.430]                       }
[17:42:57.430]                       else if (inherits(cond, "warning")) {
[17:42:57.430]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.430]                         if (muffled) 
[17:42:57.430]                           invokeRestart("muffleWarning")
[17:42:57.430]                       }
[17:42:57.430]                       else if (inherits(cond, "condition")) {
[17:42:57.430]                         if (!is.null(pattern)) {
[17:42:57.430]                           computeRestarts <- base::computeRestarts
[17:42:57.430]                           grepl <- base::grepl
[17:42:57.430]                           restarts <- computeRestarts(cond)
[17:42:57.430]                           for (restart in restarts) {
[17:42:57.430]                             name <- restart$name
[17:42:57.430]                             if (is.null(name)) 
[17:42:57.430]                               next
[17:42:57.430]                             if (!grepl(pattern, name)) 
[17:42:57.430]                               next
[17:42:57.430]                             invokeRestart(restart)
[17:42:57.430]                             muffled <- TRUE
[17:42:57.430]                             break
[17:42:57.430]                           }
[17:42:57.430]                         }
[17:42:57.430]                       }
[17:42:57.430]                       invisible(muffled)
[17:42:57.430]                     }
[17:42:57.430]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.430]                   }
[17:42:57.430]                 }
[17:42:57.430]             }
[17:42:57.430]         }))
[17:42:57.430]     }, error = function(ex) {
[17:42:57.430]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:57.430]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.430]                 ...future.rng), started = ...future.startTime, 
[17:42:57.430]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:57.430]             version = "1.8"), class = "FutureResult")
[17:42:57.430]     }, finally = {
[17:42:57.430]         if (!identical(...future.workdir, getwd())) 
[17:42:57.430]             setwd(...future.workdir)
[17:42:57.430]         {
[17:42:57.430]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:57.430]                 ...future.oldOptions$nwarnings <- NULL
[17:42:57.430]             }
[17:42:57.430]             base::options(...future.oldOptions)
[17:42:57.430]             if (.Platform$OS.type == "windows") {
[17:42:57.430]                 old_names <- names(...future.oldEnvVars)
[17:42:57.430]                 envs <- base::Sys.getenv()
[17:42:57.430]                 names <- names(envs)
[17:42:57.430]                 common <- intersect(names, old_names)
[17:42:57.430]                 added <- setdiff(names, old_names)
[17:42:57.430]                 removed <- setdiff(old_names, names)
[17:42:57.430]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:57.430]                   envs[common]]
[17:42:57.430]                 NAMES <- toupper(changed)
[17:42:57.430]                 args <- list()
[17:42:57.430]                 for (kk in seq_along(NAMES)) {
[17:42:57.430]                   name <- changed[[kk]]
[17:42:57.430]                   NAME <- NAMES[[kk]]
[17:42:57.430]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.430]                     next
[17:42:57.430]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.430]                 }
[17:42:57.430]                 NAMES <- toupper(added)
[17:42:57.430]                 for (kk in seq_along(NAMES)) {
[17:42:57.430]                   name <- added[[kk]]
[17:42:57.430]                   NAME <- NAMES[[kk]]
[17:42:57.430]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.430]                     next
[17:42:57.430]                   args[[name]] <- ""
[17:42:57.430]                 }
[17:42:57.430]                 NAMES <- toupper(removed)
[17:42:57.430]                 for (kk in seq_along(NAMES)) {
[17:42:57.430]                   name <- removed[[kk]]
[17:42:57.430]                   NAME <- NAMES[[kk]]
[17:42:57.430]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.430]                     next
[17:42:57.430]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.430]                 }
[17:42:57.430]                 if (length(args) > 0) 
[17:42:57.430]                   base::do.call(base::Sys.setenv, args = args)
[17:42:57.430]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:57.430]             }
[17:42:57.430]             else {
[17:42:57.430]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:57.430]             }
[17:42:57.430]             {
[17:42:57.430]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:57.430]                   0L) {
[17:42:57.430]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:57.430]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:57.430]                   base::options(opts)
[17:42:57.430]                 }
[17:42:57.430]                 {
[17:42:57.430]                   {
[17:42:57.430]                     NULL
[17:42:57.430]                     RNGkind("Mersenne-Twister")
[17:42:57.430]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:57.430]                       inherits = FALSE)
[17:42:57.430]                   }
[17:42:57.430]                   options(future.plan = NULL)
[17:42:57.430]                   if (is.na(NA_character_)) 
[17:42:57.430]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.430]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:57.430]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:57.430]                     envir = parent.frame()) 
[17:42:57.430]                   {
[17:42:57.430]                     default_workers <- missing(workers)
[17:42:57.430]                     if (is.function(workers)) 
[17:42:57.430]                       workers <- workers()
[17:42:57.430]                     workers <- structure(as.integer(workers), 
[17:42:57.430]                       class = class(workers))
[17:42:57.430]                     stop_if_not(is.finite(workers), workers >= 
[17:42:57.430]                       1L)
[17:42:57.430]                     if ((workers == 1L && !inherits(workers, 
[17:42:57.430]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:57.430]                       if (default_workers) 
[17:42:57.430]                         supportsMulticore(warn = TRUE)
[17:42:57.430]                       return(sequential(..., envir = envir))
[17:42:57.430]                     }
[17:42:57.430]                     oopts <- options(mc.cores = workers)
[17:42:57.430]                     on.exit(options(oopts))
[17:42:57.430]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:57.430]                       envir = envir)
[17:42:57.430]                     if (!future$lazy) 
[17:42:57.430]                       future <- run(future)
[17:42:57.430]                     invisible(future)
[17:42:57.430]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:57.430]                 }
[17:42:57.430]             }
[17:42:57.430]         }
[17:42:57.430]     })
[17:42:57.430]     if (TRUE) {
[17:42:57.430]         base::sink(type = "output", split = FALSE)
[17:42:57.430]         if (TRUE) {
[17:42:57.430]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:57.430]         }
[17:42:57.430]         else {
[17:42:57.430]             ...future.result["stdout"] <- base::list(NULL)
[17:42:57.430]         }
[17:42:57.430]         base::close(...future.stdout)
[17:42:57.430]         ...future.stdout <- NULL
[17:42:57.430]     }
[17:42:57.430]     ...future.result$conditions <- ...future.conditions
[17:42:57.430]     ...future.result$finished <- base::Sys.time()
[17:42:57.430]     ...future.result
[17:42:57.430] }
[17:42:57.432] plan(): Setting new future strategy stack:
[17:42:57.432] List of future strategies:
[17:42:57.432] 1. sequential:
[17:42:57.432]    - args: function (..., envir = parent.frame())
[17:42:57.432]    - tweaked: FALSE
[17:42:57.432]    - call: NULL
[17:42:57.432] plan(): nbrOfWorkers() = 1
[17:42:57.433] plan(): Setting new future strategy stack:
[17:42:57.433] List of future strategies:
[17:42:57.433] 1. multicore:
[17:42:57.433]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:57.433]    - tweaked: FALSE
[17:42:57.433]    - call: plan(multicore)
[17:42:57.437] plan(): nbrOfWorkers() = 1
[17:42:57.437] SequentialFuture started (and completed)
 - Resolving 4 multicore futures
*** multicore(..., globals = FALSE) and errors
[17:42:57.441] getGlobalsAndPackages() ...
[17:42:57.442] Not searching for globals
[17:42:57.442] - globals: [0] <none>
[17:42:57.442] getGlobalsAndPackages() ... DONE
[17:42:57.442] Packages needed by the future expression (n = 0): <none>
[17:42:57.442] Packages needed by future strategies (n = 0): <none>
[17:42:57.443] {
[17:42:57.443]     {
[17:42:57.443]         {
[17:42:57.443]             ...future.startTime <- base::Sys.time()
[17:42:57.443]             {
[17:42:57.443]                 {
[17:42:57.443]                   {
[17:42:57.443]                     base::local({
[17:42:57.443]                       has_future <- base::requireNamespace("future", 
[17:42:57.443]                         quietly = TRUE)
[17:42:57.443]                       if (has_future) {
[17:42:57.443]                         ns <- base::getNamespace("future")
[17:42:57.443]                         version <- ns[[".package"]][["version"]]
[17:42:57.443]                         if (is.null(version)) 
[17:42:57.443]                           version <- utils::packageVersion("future")
[17:42:57.443]                       }
[17:42:57.443]                       else {
[17:42:57.443]                         version <- NULL
[17:42:57.443]                       }
[17:42:57.443]                       if (!has_future || version < "1.8.0") {
[17:42:57.443]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:57.443]                           "", base::R.version$version.string), 
[17:42:57.443]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:57.443]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:57.443]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:57.443]                             "release", "version")], collapse = " "), 
[17:42:57.443]                           hostname = base::Sys.info()[["nodename"]])
[17:42:57.443]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:57.443]                           info)
[17:42:57.443]                         info <- base::paste(info, collapse = "; ")
[17:42:57.443]                         if (!has_future) {
[17:42:57.443]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:57.443]                             info)
[17:42:57.443]                         }
[17:42:57.443]                         else {
[17:42:57.443]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:57.443]                             info, version)
[17:42:57.443]                         }
[17:42:57.443]                         base::stop(msg)
[17:42:57.443]                       }
[17:42:57.443]                     })
[17:42:57.443]                   }
[17:42:57.443]                   options(future.plan = NULL)
[17:42:57.443]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.443]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:57.443]                 }
[17:42:57.443]                 ...future.workdir <- getwd()
[17:42:57.443]             }
[17:42:57.443]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:57.443]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:57.443]         }
[17:42:57.443]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:57.443]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:57.443]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:57.443]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:57.443]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:57.443]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:57.443]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:57.443]             base::names(...future.oldOptions))
[17:42:57.443]     }
[17:42:57.443]     if (FALSE) {
[17:42:57.443]     }
[17:42:57.443]     else {
[17:42:57.443]         if (TRUE) {
[17:42:57.443]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:57.443]                 open = "w")
[17:42:57.443]         }
[17:42:57.443]         else {
[17:42:57.443]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:57.443]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:57.443]         }
[17:42:57.443]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:57.443]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:57.443]             base::sink(type = "output", split = FALSE)
[17:42:57.443]             base::close(...future.stdout)
[17:42:57.443]         }, add = TRUE)
[17:42:57.443]     }
[17:42:57.443]     ...future.frame <- base::sys.nframe()
[17:42:57.443]     ...future.conditions <- base::list()
[17:42:57.443]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:57.443]     if (FALSE) {
[17:42:57.443]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:57.443]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:57.443]     }
[17:42:57.443]     ...future.result <- base::tryCatch({
[17:42:57.443]         base::withCallingHandlers({
[17:42:57.443]             ...future.value <- base::withVisible(base::local({
[17:42:57.443]                 stop("Whoops!")
[17:42:57.443]                 1
[17:42:57.443]             }))
[17:42:57.443]             future::FutureResult(value = ...future.value$value, 
[17:42:57.443]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.443]                   ...future.rng), globalenv = if (FALSE) 
[17:42:57.443]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:57.443]                     ...future.globalenv.names))
[17:42:57.443]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:57.443]         }, condition = base::local({
[17:42:57.443]             c <- base::c
[17:42:57.443]             inherits <- base::inherits
[17:42:57.443]             invokeRestart <- base::invokeRestart
[17:42:57.443]             length <- base::length
[17:42:57.443]             list <- base::list
[17:42:57.443]             seq.int <- base::seq.int
[17:42:57.443]             signalCondition <- base::signalCondition
[17:42:57.443]             sys.calls <- base::sys.calls
[17:42:57.443]             `[[` <- base::`[[`
[17:42:57.443]             `+` <- base::`+`
[17:42:57.443]             `<<-` <- base::`<<-`
[17:42:57.443]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:57.443]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:57.443]                   3L)]
[17:42:57.443]             }
[17:42:57.443]             function(cond) {
[17:42:57.443]                 is_error <- inherits(cond, "error")
[17:42:57.443]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:57.443]                   NULL)
[17:42:57.443]                 if (is_error) {
[17:42:57.443]                   sessionInformation <- function() {
[17:42:57.443]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:57.443]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:57.443]                       search = base::search(), system = base::Sys.info())
[17:42:57.443]                   }
[17:42:57.443]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.443]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:57.443]                     cond$call), session = sessionInformation(), 
[17:42:57.443]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:57.443]                   signalCondition(cond)
[17:42:57.443]                 }
[17:42:57.443]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:57.443]                 "immediateCondition"))) {
[17:42:57.443]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:57.443]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.443]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:57.443]                   if (TRUE && !signal) {
[17:42:57.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.443]                     {
[17:42:57.443]                       inherits <- base::inherits
[17:42:57.443]                       invokeRestart <- base::invokeRestart
[17:42:57.443]                       is.null <- base::is.null
[17:42:57.443]                       muffled <- FALSE
[17:42:57.443]                       if (inherits(cond, "message")) {
[17:42:57.443]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.443]                         if (muffled) 
[17:42:57.443]                           invokeRestart("muffleMessage")
[17:42:57.443]                       }
[17:42:57.443]                       else if (inherits(cond, "warning")) {
[17:42:57.443]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.443]                         if (muffled) 
[17:42:57.443]                           invokeRestart("muffleWarning")
[17:42:57.443]                       }
[17:42:57.443]                       else if (inherits(cond, "condition")) {
[17:42:57.443]                         if (!is.null(pattern)) {
[17:42:57.443]                           computeRestarts <- base::computeRestarts
[17:42:57.443]                           grepl <- base::grepl
[17:42:57.443]                           restarts <- computeRestarts(cond)
[17:42:57.443]                           for (restart in restarts) {
[17:42:57.443]                             name <- restart$name
[17:42:57.443]                             if (is.null(name)) 
[17:42:57.443]                               next
[17:42:57.443]                             if (!grepl(pattern, name)) 
[17:42:57.443]                               next
[17:42:57.443]                             invokeRestart(restart)
[17:42:57.443]                             muffled <- TRUE
[17:42:57.443]                             break
[17:42:57.443]                           }
[17:42:57.443]                         }
[17:42:57.443]                       }
[17:42:57.443]                       invisible(muffled)
[17:42:57.443]                     }
[17:42:57.443]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.443]                   }
[17:42:57.443]                 }
[17:42:57.443]                 else {
[17:42:57.443]                   if (TRUE) {
[17:42:57.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.443]                     {
[17:42:57.443]                       inherits <- base::inherits
[17:42:57.443]                       invokeRestart <- base::invokeRestart
[17:42:57.443]                       is.null <- base::is.null
[17:42:57.443]                       muffled <- FALSE
[17:42:57.443]                       if (inherits(cond, "message")) {
[17:42:57.443]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.443]                         if (muffled) 
[17:42:57.443]                           invokeRestart("muffleMessage")
[17:42:57.443]                       }
[17:42:57.443]                       else if (inherits(cond, "warning")) {
[17:42:57.443]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.443]                         if (muffled) 
[17:42:57.443]                           invokeRestart("muffleWarning")
[17:42:57.443]                       }
[17:42:57.443]                       else if (inherits(cond, "condition")) {
[17:42:57.443]                         if (!is.null(pattern)) {
[17:42:57.443]                           computeRestarts <- base::computeRestarts
[17:42:57.443]                           grepl <- base::grepl
[17:42:57.443]                           restarts <- computeRestarts(cond)
[17:42:57.443]                           for (restart in restarts) {
[17:42:57.443]                             name <- restart$name
[17:42:57.443]                             if (is.null(name)) 
[17:42:57.443]                               next
[17:42:57.443]                             if (!grepl(pattern, name)) 
[17:42:57.443]                               next
[17:42:57.443]                             invokeRestart(restart)
[17:42:57.443]                             muffled <- TRUE
[17:42:57.443]                             break
[17:42:57.443]                           }
[17:42:57.443]                         }
[17:42:57.443]                       }
[17:42:57.443]                       invisible(muffled)
[17:42:57.443]                     }
[17:42:57.443]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.443]                   }
[17:42:57.443]                 }
[17:42:57.443]             }
[17:42:57.443]         }))
[17:42:57.443]     }, error = function(ex) {
[17:42:57.443]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:57.443]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.443]                 ...future.rng), started = ...future.startTime, 
[17:42:57.443]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:57.443]             version = "1.8"), class = "FutureResult")
[17:42:57.443]     }, finally = {
[17:42:57.443]         if (!identical(...future.workdir, getwd())) 
[17:42:57.443]             setwd(...future.workdir)
[17:42:57.443]         {
[17:42:57.443]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:57.443]                 ...future.oldOptions$nwarnings <- NULL
[17:42:57.443]             }
[17:42:57.443]             base::options(...future.oldOptions)
[17:42:57.443]             if (.Platform$OS.type == "windows") {
[17:42:57.443]                 old_names <- names(...future.oldEnvVars)
[17:42:57.443]                 envs <- base::Sys.getenv()
[17:42:57.443]                 names <- names(envs)
[17:42:57.443]                 common <- intersect(names, old_names)
[17:42:57.443]                 added <- setdiff(names, old_names)
[17:42:57.443]                 removed <- setdiff(old_names, names)
[17:42:57.443]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:57.443]                   envs[common]]
[17:42:57.443]                 NAMES <- toupper(changed)
[17:42:57.443]                 args <- list()
[17:42:57.443]                 for (kk in seq_along(NAMES)) {
[17:42:57.443]                   name <- changed[[kk]]
[17:42:57.443]                   NAME <- NAMES[[kk]]
[17:42:57.443]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.443]                     next
[17:42:57.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.443]                 }
[17:42:57.443]                 NAMES <- toupper(added)
[17:42:57.443]                 for (kk in seq_along(NAMES)) {
[17:42:57.443]                   name <- added[[kk]]
[17:42:57.443]                   NAME <- NAMES[[kk]]
[17:42:57.443]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.443]                     next
[17:42:57.443]                   args[[name]] <- ""
[17:42:57.443]                 }
[17:42:57.443]                 NAMES <- toupper(removed)
[17:42:57.443]                 for (kk in seq_along(NAMES)) {
[17:42:57.443]                   name <- removed[[kk]]
[17:42:57.443]                   NAME <- NAMES[[kk]]
[17:42:57.443]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.443]                     next
[17:42:57.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.443]                 }
[17:42:57.443]                 if (length(args) > 0) 
[17:42:57.443]                   base::do.call(base::Sys.setenv, args = args)
[17:42:57.443]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:57.443]             }
[17:42:57.443]             else {
[17:42:57.443]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:57.443]             }
[17:42:57.443]             {
[17:42:57.443]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:57.443]                   0L) {
[17:42:57.443]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:57.443]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:57.443]                   base::options(opts)
[17:42:57.443]                 }
[17:42:57.443]                 {
[17:42:57.443]                   {
[17:42:57.443]                     NULL
[17:42:57.443]                     RNGkind("Mersenne-Twister")
[17:42:57.443]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:57.443]                       inherits = FALSE)
[17:42:57.443]                   }
[17:42:57.443]                   options(future.plan = NULL)
[17:42:57.443]                   if (is.na(NA_character_)) 
[17:42:57.443]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.443]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:57.443]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:57.443]                     envir = parent.frame()) 
[17:42:57.443]                   {
[17:42:57.443]                     default_workers <- missing(workers)
[17:42:57.443]                     if (is.function(workers)) 
[17:42:57.443]                       workers <- workers()
[17:42:57.443]                     workers <- structure(as.integer(workers), 
[17:42:57.443]                       class = class(workers))
[17:42:57.443]                     stop_if_not(is.finite(workers), workers >= 
[17:42:57.443]                       1L)
[17:42:57.443]                     if ((workers == 1L && !inherits(workers, 
[17:42:57.443]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:57.443]                       if (default_workers) 
[17:42:57.443]                         supportsMulticore(warn = TRUE)
[17:42:57.443]                       return(sequential(..., envir = envir))
[17:42:57.443]                     }
[17:42:57.443]                     oopts <- options(mc.cores = workers)
[17:42:57.443]                     on.exit(options(oopts))
[17:42:57.443]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:57.443]                       envir = envir)
[17:42:57.443]                     if (!future$lazy) 
[17:42:57.443]                       future <- run(future)
[17:42:57.443]                     invisible(future)
[17:42:57.443]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:57.443]                 }
[17:42:57.443]             }
[17:42:57.443]         }
[17:42:57.443]     })
[17:42:57.443]     if (TRUE) {
[17:42:57.443]         base::sink(type = "output", split = FALSE)
[17:42:57.443]         if (TRUE) {
[17:42:57.443]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:57.443]         }
[17:42:57.443]         else {
[17:42:57.443]             ...future.result["stdout"] <- base::list(NULL)
[17:42:57.443]         }
[17:42:57.443]         base::close(...future.stdout)
[17:42:57.443]         ...future.stdout <- NULL
[17:42:57.443]     }
[17:42:57.443]     ...future.result$conditions <- ...future.conditions
[17:42:57.443]     ...future.result$finished <- base::Sys.time()
[17:42:57.443]     ...future.result
[17:42:57.443] }
[17:42:57.445] plan(): Setting new future strategy stack:
[17:42:57.445] List of future strategies:
[17:42:57.445] 1. sequential:
[17:42:57.445]    - args: function (..., envir = parent.frame())
[17:42:57.445]    - tweaked: FALSE
[17:42:57.445]    - call: NULL
[17:42:57.445] plan(): nbrOfWorkers() = 1
[17:42:57.446] plan(): Setting new future strategy stack:
[17:42:57.446] List of future strategies:
[17:42:57.446] 1. multicore:
[17:42:57.446]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:57.446]    - tweaked: FALSE
[17:42:57.446]    - call: plan(multicore)
[17:42:57.450] plan(): nbrOfWorkers() = 1
[17:42:57.450] SequentialFuture started (and completed)
[17:42:57.450] signalConditions() ...
[17:42:57.452]  - include = ‘immediateCondition’
[17:42:57.452]  - exclude = 
[17:42:57.452]  - resignal = FALSE
[17:42:57.452]  - Number of conditions: 1
[17:42:57.452] signalConditions() ... done
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 0 bytes of class ‘NULL’
Conditions captured: [n=1] ‘simpleError’
Early signaling: FALSE
Owner process: 56280105-ab48-3cfb-51ca-f6f685381758
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:57.453] signalConditions() ...
[17:42:57.453]  - include = ‘immediateCondition’
[17:42:57.453]  - exclude = 
[17:42:57.453]  - resignal = FALSE
[17:42:57.453]  - Number of conditions: 1
[17:42:57.453] signalConditions() ... done
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[17:42:57.454] signalConditions() ...
[17:42:57.454]  - include = ‘immediateCondition’
[17:42:57.454]  - exclude = 
[17:42:57.454]  - resignal = FALSE
[17:42:57.454]  - Number of conditions: 1
[17:42:57.454] signalConditions() ... done
[17:42:57.454] Future state: ‘finished’
[17:42:57.454] signalConditions() ...
[17:42:57.454]  - include = ‘condition’
[17:42:57.455]  - exclude = ‘immediateCondition’
[17:42:57.455]  - resignal = TRUE
[17:42:57.455]  - Number of conditions: 1
[17:42:57.455]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:42:57.455] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[17:42:57.455] signalConditions() ...
[17:42:57.455]  - include = ‘immediateCondition’
[17:42:57.456]  - exclude = 
[17:42:57.456]  - resignal = FALSE
[17:42:57.456]  - Number of conditions: 1
[17:42:57.456] signalConditions() ... done
[17:42:57.456] Future state: ‘finished’
[17:42:57.456] signalConditions() ...
[17:42:57.456]  - include = ‘condition’
[17:42:57.456]  - exclude = ‘immediateCondition’
[17:42:57.456]  - resignal = TRUE
[17:42:57.456]  - Number of conditions: 1
[17:42:57.456]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:42:57.457] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[17:42:57.460] getGlobalsAndPackages() ...
[17:42:57.460] Searching for globals...
[17:42:57.467] - globals found: [5] ‘{’, ‘stop’, ‘structure’, ‘list’, ‘c’
[17:42:57.467] Searching for globals ... DONE
[17:42:57.467] Resolving globals: FALSE
[17:42:57.468] 
[17:42:57.468] 
[17:42:57.468] getGlobalsAndPackages() ... DONE
[17:42:57.469] Packages needed by the future expression (n = 0): <none>
[17:42:57.469] Packages needed by future strategies (n = 0): <none>
[17:42:57.469] {
[17:42:57.469]     {
[17:42:57.469]         {
[17:42:57.469]             ...future.startTime <- base::Sys.time()
[17:42:57.469]             {
[17:42:57.469]                 {
[17:42:57.469]                   {
[17:42:57.469]                     base::local({
[17:42:57.469]                       has_future <- base::requireNamespace("future", 
[17:42:57.469]                         quietly = TRUE)
[17:42:57.469]                       if (has_future) {
[17:42:57.469]                         ns <- base::getNamespace("future")
[17:42:57.469]                         version <- ns[[".package"]][["version"]]
[17:42:57.469]                         if (is.null(version)) 
[17:42:57.469]                           version <- utils::packageVersion("future")
[17:42:57.469]                       }
[17:42:57.469]                       else {
[17:42:57.469]                         version <- NULL
[17:42:57.469]                       }
[17:42:57.469]                       if (!has_future || version < "1.8.0") {
[17:42:57.469]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:57.469]                           "", base::R.version$version.string), 
[17:42:57.469]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:57.469]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:57.469]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:57.469]                             "release", "version")], collapse = " "), 
[17:42:57.469]                           hostname = base::Sys.info()[["nodename"]])
[17:42:57.469]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:57.469]                           info)
[17:42:57.469]                         info <- base::paste(info, collapse = "; ")
[17:42:57.469]                         if (!has_future) {
[17:42:57.469]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:57.469]                             info)
[17:42:57.469]                         }
[17:42:57.469]                         else {
[17:42:57.469]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:57.469]                             info, version)
[17:42:57.469]                         }
[17:42:57.469]                         base::stop(msg)
[17:42:57.469]                       }
[17:42:57.469]                     })
[17:42:57.469]                   }
[17:42:57.469]                   options(future.plan = NULL)
[17:42:57.469]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.469]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:57.469]                 }
[17:42:57.469]                 ...future.workdir <- getwd()
[17:42:57.469]             }
[17:42:57.469]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:57.469]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:57.469]         }
[17:42:57.469]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:57.469]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:57.469]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:57.469]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:57.469]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:57.469]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:57.469]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:57.469]             base::names(...future.oldOptions))
[17:42:57.469]     }
[17:42:57.469]     if (FALSE) {
[17:42:57.469]     }
[17:42:57.469]     else {
[17:42:57.469]         if (TRUE) {
[17:42:57.469]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:57.469]                 open = "w")
[17:42:57.469]         }
[17:42:57.469]         else {
[17:42:57.469]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:57.469]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:57.469]         }
[17:42:57.469]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:57.469]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:57.469]             base::sink(type = "output", split = FALSE)
[17:42:57.469]             base::close(...future.stdout)
[17:42:57.469]         }, add = TRUE)
[17:42:57.469]     }
[17:42:57.469]     ...future.frame <- base::sys.nframe()
[17:42:57.469]     ...future.conditions <- base::list()
[17:42:57.469]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:57.469]     if (FALSE) {
[17:42:57.469]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:57.469]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:57.469]     }
[17:42:57.469]     ...future.result <- base::tryCatch({
[17:42:57.469]         base::withCallingHandlers({
[17:42:57.469]             ...future.value <- base::withVisible(base::local({
[17:42:57.469]                 stop(structure(list(message = "boom"), class = c("MyError", 
[17:42:57.469]                   "error", "condition")))
[17:42:57.469]             }))
[17:42:57.469]             future::FutureResult(value = ...future.value$value, 
[17:42:57.469]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.469]                   ...future.rng), globalenv = if (FALSE) 
[17:42:57.469]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:57.469]                     ...future.globalenv.names))
[17:42:57.469]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:57.469]         }, condition = base::local({
[17:42:57.469]             c <- base::c
[17:42:57.469]             inherits <- base::inherits
[17:42:57.469]             invokeRestart <- base::invokeRestart
[17:42:57.469]             length <- base::length
[17:42:57.469]             list <- base::list
[17:42:57.469]             seq.int <- base::seq.int
[17:42:57.469]             signalCondition <- base::signalCondition
[17:42:57.469]             sys.calls <- base::sys.calls
[17:42:57.469]             `[[` <- base::`[[`
[17:42:57.469]             `+` <- base::`+`
[17:42:57.469]             `<<-` <- base::`<<-`
[17:42:57.469]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:57.469]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:57.469]                   3L)]
[17:42:57.469]             }
[17:42:57.469]             function(cond) {
[17:42:57.469]                 is_error <- inherits(cond, "error")
[17:42:57.469]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:57.469]                   NULL)
[17:42:57.469]                 if (is_error) {
[17:42:57.469]                   sessionInformation <- function() {
[17:42:57.469]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:57.469]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:57.469]                       search = base::search(), system = base::Sys.info())
[17:42:57.469]                   }
[17:42:57.469]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.469]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:57.469]                     cond$call), session = sessionInformation(), 
[17:42:57.469]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:57.469]                   signalCondition(cond)
[17:42:57.469]                 }
[17:42:57.469]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:57.469]                 "immediateCondition"))) {
[17:42:57.469]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:57.469]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.469]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:57.469]                   if (TRUE && !signal) {
[17:42:57.469]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.469]                     {
[17:42:57.469]                       inherits <- base::inherits
[17:42:57.469]                       invokeRestart <- base::invokeRestart
[17:42:57.469]                       is.null <- base::is.null
[17:42:57.469]                       muffled <- FALSE
[17:42:57.469]                       if (inherits(cond, "message")) {
[17:42:57.469]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.469]                         if (muffled) 
[17:42:57.469]                           invokeRestart("muffleMessage")
[17:42:57.469]                       }
[17:42:57.469]                       else if (inherits(cond, "warning")) {
[17:42:57.469]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.469]                         if (muffled) 
[17:42:57.469]                           invokeRestart("muffleWarning")
[17:42:57.469]                       }
[17:42:57.469]                       else if (inherits(cond, "condition")) {
[17:42:57.469]                         if (!is.null(pattern)) {
[17:42:57.469]                           computeRestarts <- base::computeRestarts
[17:42:57.469]                           grepl <- base::grepl
[17:42:57.469]                           restarts <- computeRestarts(cond)
[17:42:57.469]                           for (restart in restarts) {
[17:42:57.469]                             name <- restart$name
[17:42:57.469]                             if (is.null(name)) 
[17:42:57.469]                               next
[17:42:57.469]                             if (!grepl(pattern, name)) 
[17:42:57.469]                               next
[17:42:57.469]                             invokeRestart(restart)
[17:42:57.469]                             muffled <- TRUE
[17:42:57.469]                             break
[17:42:57.469]                           }
[17:42:57.469]                         }
[17:42:57.469]                       }
[17:42:57.469]                       invisible(muffled)
[17:42:57.469]                     }
[17:42:57.469]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.469]                   }
[17:42:57.469]                 }
[17:42:57.469]                 else {
[17:42:57.469]                   if (TRUE) {
[17:42:57.469]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.469]                     {
[17:42:57.469]                       inherits <- base::inherits
[17:42:57.469]                       invokeRestart <- base::invokeRestart
[17:42:57.469]                       is.null <- base::is.null
[17:42:57.469]                       muffled <- FALSE
[17:42:57.469]                       if (inherits(cond, "message")) {
[17:42:57.469]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.469]                         if (muffled) 
[17:42:57.469]                           invokeRestart("muffleMessage")
[17:42:57.469]                       }
[17:42:57.469]                       else if (inherits(cond, "warning")) {
[17:42:57.469]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.469]                         if (muffled) 
[17:42:57.469]                           invokeRestart("muffleWarning")
[17:42:57.469]                       }
[17:42:57.469]                       else if (inherits(cond, "condition")) {
[17:42:57.469]                         if (!is.null(pattern)) {
[17:42:57.469]                           computeRestarts <- base::computeRestarts
[17:42:57.469]                           grepl <- base::grepl
[17:42:57.469]                           restarts <- computeRestarts(cond)
[17:42:57.469]                           for (restart in restarts) {
[17:42:57.469]                             name <- restart$name
[17:42:57.469]                             if (is.null(name)) 
[17:42:57.469]                               next
[17:42:57.469]                             if (!grepl(pattern, name)) 
[17:42:57.469]                               next
[17:42:57.469]                             invokeRestart(restart)
[17:42:57.469]                             muffled <- TRUE
[17:42:57.469]                             break
[17:42:57.469]                           }
[17:42:57.469]                         }
[17:42:57.469]                       }
[17:42:57.469]                       invisible(muffled)
[17:42:57.469]                     }
[17:42:57.469]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.469]                   }
[17:42:57.469]                 }
[17:42:57.469]             }
[17:42:57.469]         }))
[17:42:57.469]     }, error = function(ex) {
[17:42:57.469]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:57.469]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.469]                 ...future.rng), started = ...future.startTime, 
[17:42:57.469]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:57.469]             version = "1.8"), class = "FutureResult")
[17:42:57.469]     }, finally = {
[17:42:57.469]         if (!identical(...future.workdir, getwd())) 
[17:42:57.469]             setwd(...future.workdir)
[17:42:57.469]         {
[17:42:57.469]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:57.469]                 ...future.oldOptions$nwarnings <- NULL
[17:42:57.469]             }
[17:42:57.469]             base::options(...future.oldOptions)
[17:42:57.469]             if (.Platform$OS.type == "windows") {
[17:42:57.469]                 old_names <- names(...future.oldEnvVars)
[17:42:57.469]                 envs <- base::Sys.getenv()
[17:42:57.469]                 names <- names(envs)
[17:42:57.469]                 common <- intersect(names, old_names)
[17:42:57.469]                 added <- setdiff(names, old_names)
[17:42:57.469]                 removed <- setdiff(old_names, names)
[17:42:57.469]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:57.469]                   envs[common]]
[17:42:57.469]                 NAMES <- toupper(changed)
[17:42:57.469]                 args <- list()
[17:42:57.469]                 for (kk in seq_along(NAMES)) {
[17:42:57.469]                   name <- changed[[kk]]
[17:42:57.469]                   NAME <- NAMES[[kk]]
[17:42:57.469]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.469]                     next
[17:42:57.469]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.469]                 }
[17:42:57.469]                 NAMES <- toupper(added)
[17:42:57.469]                 for (kk in seq_along(NAMES)) {
[17:42:57.469]                   name <- added[[kk]]
[17:42:57.469]                   NAME <- NAMES[[kk]]
[17:42:57.469]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.469]                     next
[17:42:57.469]                   args[[name]] <- ""
[17:42:57.469]                 }
[17:42:57.469]                 NAMES <- toupper(removed)
[17:42:57.469]                 for (kk in seq_along(NAMES)) {
[17:42:57.469]                   name <- removed[[kk]]
[17:42:57.469]                   NAME <- NAMES[[kk]]
[17:42:57.469]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.469]                     next
[17:42:57.469]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.469]                 }
[17:42:57.469]                 if (length(args) > 0) 
[17:42:57.469]                   base::do.call(base::Sys.setenv, args = args)
[17:42:57.469]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:57.469]             }
[17:42:57.469]             else {
[17:42:57.469]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:57.469]             }
[17:42:57.469]             {
[17:42:57.469]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:57.469]                   0L) {
[17:42:57.469]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:57.469]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:57.469]                   base::options(opts)
[17:42:57.469]                 }
[17:42:57.469]                 {
[17:42:57.469]                   {
[17:42:57.469]                     NULL
[17:42:57.469]                     RNGkind("Mersenne-Twister")
[17:42:57.469]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:57.469]                       inherits = FALSE)
[17:42:57.469]                   }
[17:42:57.469]                   options(future.plan = NULL)
[17:42:57.469]                   if (is.na(NA_character_)) 
[17:42:57.469]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.469]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:57.469]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:57.469]                     envir = parent.frame()) 
[17:42:57.469]                   {
[17:42:57.469]                     default_workers <- missing(workers)
[17:42:57.469]                     if (is.function(workers)) 
[17:42:57.469]                       workers <- workers()
[17:42:57.469]                     workers <- structure(as.integer(workers), 
[17:42:57.469]                       class = class(workers))
[17:42:57.469]                     stop_if_not(is.finite(workers), workers >= 
[17:42:57.469]                       1L)
[17:42:57.469]                     if ((workers == 1L && !inherits(workers, 
[17:42:57.469]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:57.469]                       if (default_workers) 
[17:42:57.469]                         supportsMulticore(warn = TRUE)
[17:42:57.469]                       return(sequential(..., envir = envir))
[17:42:57.469]                     }
[17:42:57.469]                     oopts <- options(mc.cores = workers)
[17:42:57.469]                     on.exit(options(oopts))
[17:42:57.469]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:57.469]                       envir = envir)
[17:42:57.469]                     if (!future$lazy) 
[17:42:57.469]                       future <- run(future)
[17:42:57.469]                     invisible(future)
[17:42:57.469]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:57.469]                 }
[17:42:57.469]             }
[17:42:57.469]         }
[17:42:57.469]     })
[17:42:57.469]     if (TRUE) {
[17:42:57.469]         base::sink(type = "output", split = FALSE)
[17:42:57.469]         if (TRUE) {
[17:42:57.469]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:57.469]         }
[17:42:57.469]         else {
[17:42:57.469]             ...future.result["stdout"] <- base::list(NULL)
[17:42:57.469]         }
[17:42:57.469]         base::close(...future.stdout)
[17:42:57.469]         ...future.stdout <- NULL
[17:42:57.469]     }
[17:42:57.469]     ...future.result$conditions <- ...future.conditions
[17:42:57.469]     ...future.result$finished <- base::Sys.time()
[17:42:57.469]     ...future.result
[17:42:57.469] }
[17:42:57.471] plan(): Setting new future strategy stack:
[17:42:57.471] List of future strategies:
[17:42:57.471] 1. sequential:
[17:42:57.471]    - args: function (..., envir = parent.frame())
[17:42:57.471]    - tweaked: FALSE
[17:42:57.471]    - call: NULL
[17:42:57.472] plan(): nbrOfWorkers() = 1
[17:42:57.473] plan(): Setting new future strategy stack:
[17:42:57.473] List of future strategies:
[17:42:57.473] 1. multicore:
[17:42:57.473]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:57.473]    - tweaked: FALSE
[17:42:57.473]    - call: plan(multicore)
[17:42:57.476] plan(): nbrOfWorkers() = 1
[17:42:57.476] SequentialFuture started (and completed)
[17:42:57.477] signalConditions() ...
[17:42:57.477]  - include = ‘immediateCondition’
[17:42:57.477]  - exclude = 
[17:42:57.477]  - resignal = FALSE
[17:42:57.477]  - Number of conditions: 1
[17:42:57.477] signalConditions() ... done
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 0 bytes of class ‘NULL’
Conditions captured: [n=1] ‘MyError’
Early signaling: FALSE
Owner process: 56280105-ab48-3cfb-51ca-f6f685381758
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:57.478] signalConditions() ...
[17:42:57.478]  - include = ‘immediateCondition’
[17:42:57.478]  - exclude = 
[17:42:57.478]  - resignal = FALSE
[17:42:57.478]  - Number of conditions: 1
[17:42:57.478] signalConditions() ... done
<MyError: boom>
[17:42:57.478] signalConditions() ...
[17:42:57.478]  - include = ‘immediateCondition’
[17:42:57.479]  - exclude = 
[17:42:57.479]  - resignal = FALSE
[17:42:57.479]  - Number of conditions: 1
[17:42:57.479] signalConditions() ... done
[17:42:57.479] Future state: ‘finished’
[17:42:57.479] signalConditions() ...
[17:42:57.479]  - include = ‘condition’
[17:42:57.479]  - exclude = ‘immediateCondition’
[17:42:57.479]  - resignal = TRUE
[17:42:57.479]  - Number of conditions: 1
[17:42:57.480]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[17:42:57.480] signalConditions() ... done
*** multicore(..., globals = TRUE) without globals
[17:42:57.483] getGlobalsAndPackages() ...
[17:42:57.483] Searching for globals...
[17:42:57.484] - globals found: [1] ‘{’
[17:42:57.484] Searching for globals ... DONE
[17:42:57.484] Resolving globals: FALSE
[17:42:57.484] 
[17:42:57.484] 
[17:42:57.484] getGlobalsAndPackages() ... DONE
[17:42:57.485] Packages needed by the future expression (n = 0): <none>
[17:42:57.485] Packages needed by future strategies (n = 0): <none>
[17:42:57.485] {
[17:42:57.485]     {
[17:42:57.485]         {
[17:42:57.485]             ...future.startTime <- base::Sys.time()
[17:42:57.485]             {
[17:42:57.485]                 {
[17:42:57.485]                   {
[17:42:57.485]                     base::local({
[17:42:57.485]                       has_future <- base::requireNamespace("future", 
[17:42:57.485]                         quietly = TRUE)
[17:42:57.485]                       if (has_future) {
[17:42:57.485]                         ns <- base::getNamespace("future")
[17:42:57.485]                         version <- ns[[".package"]][["version"]]
[17:42:57.485]                         if (is.null(version)) 
[17:42:57.485]                           version <- utils::packageVersion("future")
[17:42:57.485]                       }
[17:42:57.485]                       else {
[17:42:57.485]                         version <- NULL
[17:42:57.485]                       }
[17:42:57.485]                       if (!has_future || version < "1.8.0") {
[17:42:57.485]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:57.485]                           "", base::R.version$version.string), 
[17:42:57.485]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:57.485]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:57.485]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:57.485]                             "release", "version")], collapse = " "), 
[17:42:57.485]                           hostname = base::Sys.info()[["nodename"]])
[17:42:57.485]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:57.485]                           info)
[17:42:57.485]                         info <- base::paste(info, collapse = "; ")
[17:42:57.485]                         if (!has_future) {
[17:42:57.485]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:57.485]                             info)
[17:42:57.485]                         }
[17:42:57.485]                         else {
[17:42:57.485]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:57.485]                             info, version)
[17:42:57.485]                         }
[17:42:57.485]                         base::stop(msg)
[17:42:57.485]                       }
[17:42:57.485]                     })
[17:42:57.485]                   }
[17:42:57.485]                   options(future.plan = NULL)
[17:42:57.485]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.485]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:57.485]                 }
[17:42:57.485]                 ...future.workdir <- getwd()
[17:42:57.485]             }
[17:42:57.485]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:57.485]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:57.485]         }
[17:42:57.485]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:57.485]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:57.485]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:57.485]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:57.485]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:57.485]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:57.485]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:57.485]             base::names(...future.oldOptions))
[17:42:57.485]     }
[17:42:57.485]     if (FALSE) {
[17:42:57.485]     }
[17:42:57.485]     else {
[17:42:57.485]         if (TRUE) {
[17:42:57.485]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:57.485]                 open = "w")
[17:42:57.485]         }
[17:42:57.485]         else {
[17:42:57.485]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:57.485]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:57.485]         }
[17:42:57.485]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:57.485]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:57.485]             base::sink(type = "output", split = FALSE)
[17:42:57.485]             base::close(...future.stdout)
[17:42:57.485]         }, add = TRUE)
[17:42:57.485]     }
[17:42:57.485]     ...future.frame <- base::sys.nframe()
[17:42:57.485]     ...future.conditions <- base::list()
[17:42:57.485]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:57.485]     if (FALSE) {
[17:42:57.485]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:57.485]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:57.485]     }
[17:42:57.485]     ...future.result <- base::tryCatch({
[17:42:57.485]         base::withCallingHandlers({
[17:42:57.485]             ...future.value <- base::withVisible(base::local({
[17:42:57.485]                 42L
[17:42:57.485]             }))
[17:42:57.485]             future::FutureResult(value = ...future.value$value, 
[17:42:57.485]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.485]                   ...future.rng), globalenv = if (FALSE) 
[17:42:57.485]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:57.485]                     ...future.globalenv.names))
[17:42:57.485]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:57.485]         }, condition = base::local({
[17:42:57.485]             c <- base::c
[17:42:57.485]             inherits <- base::inherits
[17:42:57.485]             invokeRestart <- base::invokeRestart
[17:42:57.485]             length <- base::length
[17:42:57.485]             list <- base::list
[17:42:57.485]             seq.int <- base::seq.int
[17:42:57.485]             signalCondition <- base::signalCondition
[17:42:57.485]             sys.calls <- base::sys.calls
[17:42:57.485]             `[[` <- base::`[[`
[17:42:57.485]             `+` <- base::`+`
[17:42:57.485]             `<<-` <- base::`<<-`
[17:42:57.485]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:57.485]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:57.485]                   3L)]
[17:42:57.485]             }
[17:42:57.485]             function(cond) {
[17:42:57.485]                 is_error <- inherits(cond, "error")
[17:42:57.485]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:57.485]                   NULL)
[17:42:57.485]                 if (is_error) {
[17:42:57.485]                   sessionInformation <- function() {
[17:42:57.485]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:57.485]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:57.485]                       search = base::search(), system = base::Sys.info())
[17:42:57.485]                   }
[17:42:57.485]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.485]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:57.485]                     cond$call), session = sessionInformation(), 
[17:42:57.485]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:57.485]                   signalCondition(cond)
[17:42:57.485]                 }
[17:42:57.485]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:57.485]                 "immediateCondition"))) {
[17:42:57.485]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:57.485]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.485]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:57.485]                   if (TRUE && !signal) {
[17:42:57.485]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.485]                     {
[17:42:57.485]                       inherits <- base::inherits
[17:42:57.485]                       invokeRestart <- base::invokeRestart
[17:42:57.485]                       is.null <- base::is.null
[17:42:57.485]                       muffled <- FALSE
[17:42:57.485]                       if (inherits(cond, "message")) {
[17:42:57.485]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.485]                         if (muffled) 
[17:42:57.485]                           invokeRestart("muffleMessage")
[17:42:57.485]                       }
[17:42:57.485]                       else if (inherits(cond, "warning")) {
[17:42:57.485]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.485]                         if (muffled) 
[17:42:57.485]                           invokeRestart("muffleWarning")
[17:42:57.485]                       }
[17:42:57.485]                       else if (inherits(cond, "condition")) {
[17:42:57.485]                         if (!is.null(pattern)) {
[17:42:57.485]                           computeRestarts <- base::computeRestarts
[17:42:57.485]                           grepl <- base::grepl
[17:42:57.485]                           restarts <- computeRestarts(cond)
[17:42:57.485]                           for (restart in restarts) {
[17:42:57.485]                             name <- restart$name
[17:42:57.485]                             if (is.null(name)) 
[17:42:57.485]                               next
[17:42:57.485]                             if (!grepl(pattern, name)) 
[17:42:57.485]                               next
[17:42:57.485]                             invokeRestart(restart)
[17:42:57.485]                             muffled <- TRUE
[17:42:57.485]                             break
[17:42:57.485]                           }
[17:42:57.485]                         }
[17:42:57.485]                       }
[17:42:57.485]                       invisible(muffled)
[17:42:57.485]                     }
[17:42:57.485]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.485]                   }
[17:42:57.485]                 }
[17:42:57.485]                 else {
[17:42:57.485]                   if (TRUE) {
[17:42:57.485]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.485]                     {
[17:42:57.485]                       inherits <- base::inherits
[17:42:57.485]                       invokeRestart <- base::invokeRestart
[17:42:57.485]                       is.null <- base::is.null
[17:42:57.485]                       muffled <- FALSE
[17:42:57.485]                       if (inherits(cond, "message")) {
[17:42:57.485]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.485]                         if (muffled) 
[17:42:57.485]                           invokeRestart("muffleMessage")
[17:42:57.485]                       }
[17:42:57.485]                       else if (inherits(cond, "warning")) {
[17:42:57.485]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.485]                         if (muffled) 
[17:42:57.485]                           invokeRestart("muffleWarning")
[17:42:57.485]                       }
[17:42:57.485]                       else if (inherits(cond, "condition")) {
[17:42:57.485]                         if (!is.null(pattern)) {
[17:42:57.485]                           computeRestarts <- base::computeRestarts
[17:42:57.485]                           grepl <- base::grepl
[17:42:57.485]                           restarts <- computeRestarts(cond)
[17:42:57.485]                           for (restart in restarts) {
[17:42:57.485]                             name <- restart$name
[17:42:57.485]                             if (is.null(name)) 
[17:42:57.485]                               next
[17:42:57.485]                             if (!grepl(pattern, name)) 
[17:42:57.485]                               next
[17:42:57.485]                             invokeRestart(restart)
[17:42:57.485]                             muffled <- TRUE
[17:42:57.485]                             break
[17:42:57.485]                           }
[17:42:57.485]                         }
[17:42:57.485]                       }
[17:42:57.485]                       invisible(muffled)
[17:42:57.485]                     }
[17:42:57.485]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.485]                   }
[17:42:57.485]                 }
[17:42:57.485]             }
[17:42:57.485]         }))
[17:42:57.485]     }, error = function(ex) {
[17:42:57.485]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:57.485]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.485]                 ...future.rng), started = ...future.startTime, 
[17:42:57.485]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:57.485]             version = "1.8"), class = "FutureResult")
[17:42:57.485]     }, finally = {
[17:42:57.485]         if (!identical(...future.workdir, getwd())) 
[17:42:57.485]             setwd(...future.workdir)
[17:42:57.485]         {
[17:42:57.485]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:57.485]                 ...future.oldOptions$nwarnings <- NULL
[17:42:57.485]             }
[17:42:57.485]             base::options(...future.oldOptions)
[17:42:57.485]             if (.Platform$OS.type == "windows") {
[17:42:57.485]                 old_names <- names(...future.oldEnvVars)
[17:42:57.485]                 envs <- base::Sys.getenv()
[17:42:57.485]                 names <- names(envs)
[17:42:57.485]                 common <- intersect(names, old_names)
[17:42:57.485]                 added <- setdiff(names, old_names)
[17:42:57.485]                 removed <- setdiff(old_names, names)
[17:42:57.485]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:57.485]                   envs[common]]
[17:42:57.485]                 NAMES <- toupper(changed)
[17:42:57.485]                 args <- list()
[17:42:57.485]                 for (kk in seq_along(NAMES)) {
[17:42:57.485]                   name <- changed[[kk]]
[17:42:57.485]                   NAME <- NAMES[[kk]]
[17:42:57.485]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.485]                     next
[17:42:57.485]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.485]                 }
[17:42:57.485]                 NAMES <- toupper(added)
[17:42:57.485]                 for (kk in seq_along(NAMES)) {
[17:42:57.485]                   name <- added[[kk]]
[17:42:57.485]                   NAME <- NAMES[[kk]]
[17:42:57.485]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.485]                     next
[17:42:57.485]                   args[[name]] <- ""
[17:42:57.485]                 }
[17:42:57.485]                 NAMES <- toupper(removed)
[17:42:57.485]                 for (kk in seq_along(NAMES)) {
[17:42:57.485]                   name <- removed[[kk]]
[17:42:57.485]                   NAME <- NAMES[[kk]]
[17:42:57.485]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.485]                     next
[17:42:57.485]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.485]                 }
[17:42:57.485]                 if (length(args) > 0) 
[17:42:57.485]                   base::do.call(base::Sys.setenv, args = args)
[17:42:57.485]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:57.485]             }
[17:42:57.485]             else {
[17:42:57.485]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:57.485]             }
[17:42:57.485]             {
[17:42:57.485]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:57.485]                   0L) {
[17:42:57.485]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:57.485]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:57.485]                   base::options(opts)
[17:42:57.485]                 }
[17:42:57.485]                 {
[17:42:57.485]                   {
[17:42:57.485]                     NULL
[17:42:57.485]                     RNGkind("Mersenne-Twister")
[17:42:57.485]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:57.485]                       inherits = FALSE)
[17:42:57.485]                   }
[17:42:57.485]                   options(future.plan = NULL)
[17:42:57.485]                   if (is.na(NA_character_)) 
[17:42:57.485]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.485]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:57.485]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:57.485]                     envir = parent.frame()) 
[17:42:57.485]                   {
[17:42:57.485]                     default_workers <- missing(workers)
[17:42:57.485]                     if (is.function(workers)) 
[17:42:57.485]                       workers <- workers()
[17:42:57.485]                     workers <- structure(as.integer(workers), 
[17:42:57.485]                       class = class(workers))
[17:42:57.485]                     stop_if_not(is.finite(workers), workers >= 
[17:42:57.485]                       1L)
[17:42:57.485]                     if ((workers == 1L && !inherits(workers, 
[17:42:57.485]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:57.485]                       if (default_workers) 
[17:42:57.485]                         supportsMulticore(warn = TRUE)
[17:42:57.485]                       return(sequential(..., envir = envir))
[17:42:57.485]                     }
[17:42:57.485]                     oopts <- options(mc.cores = workers)
[17:42:57.485]                     on.exit(options(oopts))
[17:42:57.485]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:57.485]                       envir = envir)
[17:42:57.485]                     if (!future$lazy) 
[17:42:57.485]                       future <- run(future)
[17:42:57.485]                     invisible(future)
[17:42:57.485]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:57.485]                 }
[17:42:57.485]             }
[17:42:57.485]         }
[17:42:57.485]     })
[17:42:57.485]     if (TRUE) {
[17:42:57.485]         base::sink(type = "output", split = FALSE)
[17:42:57.485]         if (TRUE) {
[17:42:57.485]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:57.485]         }
[17:42:57.485]         else {
[17:42:57.485]             ...future.result["stdout"] <- base::list(NULL)
[17:42:57.485]         }
[17:42:57.485]         base::close(...future.stdout)
[17:42:57.485]         ...future.stdout <- NULL
[17:42:57.485]     }
[17:42:57.485]     ...future.result$conditions <- ...future.conditions
[17:42:57.485]     ...future.result$finished <- base::Sys.time()
[17:42:57.485]     ...future.result
[17:42:57.485] }
[17:42:57.487] plan(): Setting new future strategy stack:
[17:42:57.487] List of future strategies:
[17:42:57.487] 1. sequential:
[17:42:57.487]    - args: function (..., envir = parent.frame())
[17:42:57.487]    - tweaked: FALSE
[17:42:57.487]    - call: NULL
[17:42:57.487] plan(): nbrOfWorkers() = 1
[17:42:57.488] plan(): Setting new future strategy stack:
[17:42:57.488] List of future strategies:
[17:42:57.488] 1. multicore:
[17:42:57.488]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:57.488]    - tweaked: FALSE
[17:42:57.488]    - call: plan(multicore)
[17:42:57.492] plan(): nbrOfWorkers() = 1
[17:42:57.492] SequentialFuture started (and completed)
[17:42:57.492] resolved() for ‘SequentialFuture’ ...
[17:42:57.492] - state: ‘finished’
[17:42:57.492] - run: TRUE
[17:42:57.493] - result: ‘FutureResult’
[17:42:57.493] resolved() for ‘SequentialFuture’ ... done
[1] TRUE
[1] 42
*** multicore(..., globals = TRUE) with globals
[17:42:57.496] getGlobalsAndPackages() ...
[17:42:57.496] Searching for globals...
[17:42:57.500] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘a’
[17:42:57.501] Searching for globals ... DONE
[17:42:57.501] Resolving globals: FALSE
[17:42:57.501] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:57.502] The total size of the 1 globals exported for future expression (‘{; b <- 3; c <- 2; a * b * c; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[17:42:57.502] - globals: [1] ‘a’
[17:42:57.502] 
[17:42:57.502] getGlobalsAndPackages() ... DONE
[17:42:57.502] Packages needed by the future expression (n = 0): <none>
[17:42:57.503] Packages needed by future strategies (n = 0): <none>
[17:42:57.503] {
[17:42:57.503]     {
[17:42:57.503]         {
[17:42:57.503]             ...future.startTime <- base::Sys.time()
[17:42:57.503]             {
[17:42:57.503]                 {
[17:42:57.503]                   {
[17:42:57.503]                     base::local({
[17:42:57.503]                       has_future <- base::requireNamespace("future", 
[17:42:57.503]                         quietly = TRUE)
[17:42:57.503]                       if (has_future) {
[17:42:57.503]                         ns <- base::getNamespace("future")
[17:42:57.503]                         version <- ns[[".package"]][["version"]]
[17:42:57.503]                         if (is.null(version)) 
[17:42:57.503]                           version <- utils::packageVersion("future")
[17:42:57.503]                       }
[17:42:57.503]                       else {
[17:42:57.503]                         version <- NULL
[17:42:57.503]                       }
[17:42:57.503]                       if (!has_future || version < "1.8.0") {
[17:42:57.503]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:57.503]                           "", base::R.version$version.string), 
[17:42:57.503]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:57.503]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:57.503]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:57.503]                             "release", "version")], collapse = " "), 
[17:42:57.503]                           hostname = base::Sys.info()[["nodename"]])
[17:42:57.503]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:57.503]                           info)
[17:42:57.503]                         info <- base::paste(info, collapse = "; ")
[17:42:57.503]                         if (!has_future) {
[17:42:57.503]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:57.503]                             info)
[17:42:57.503]                         }
[17:42:57.503]                         else {
[17:42:57.503]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:57.503]                             info, version)
[17:42:57.503]                         }
[17:42:57.503]                         base::stop(msg)
[17:42:57.503]                       }
[17:42:57.503]                     })
[17:42:57.503]                   }
[17:42:57.503]                   options(future.plan = NULL)
[17:42:57.503]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.503]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:57.503]                 }
[17:42:57.503]                 ...future.workdir <- getwd()
[17:42:57.503]             }
[17:42:57.503]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:57.503]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:57.503]         }
[17:42:57.503]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:57.503]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:57.503]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:57.503]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:57.503]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:57.503]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:57.503]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:57.503]             base::names(...future.oldOptions))
[17:42:57.503]     }
[17:42:57.503]     if (FALSE) {
[17:42:57.503]     }
[17:42:57.503]     else {
[17:42:57.503]         if (TRUE) {
[17:42:57.503]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:57.503]                 open = "w")
[17:42:57.503]         }
[17:42:57.503]         else {
[17:42:57.503]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:57.503]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:57.503]         }
[17:42:57.503]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:57.503]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:57.503]             base::sink(type = "output", split = FALSE)
[17:42:57.503]             base::close(...future.stdout)
[17:42:57.503]         }, add = TRUE)
[17:42:57.503]     }
[17:42:57.503]     ...future.frame <- base::sys.nframe()
[17:42:57.503]     ...future.conditions <- base::list()
[17:42:57.503]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:57.503]     if (FALSE) {
[17:42:57.503]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:57.503]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:57.503]     }
[17:42:57.503]     ...future.result <- base::tryCatch({
[17:42:57.503]         base::withCallingHandlers({
[17:42:57.503]             ...future.value <- base::withVisible(base::local({
[17:42:57.503]                 b <- 3
[17:42:57.503]                 c <- 2
[17:42:57.503]                 a * b * c
[17:42:57.503]             }))
[17:42:57.503]             future::FutureResult(value = ...future.value$value, 
[17:42:57.503]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.503]                   ...future.rng), globalenv = if (FALSE) 
[17:42:57.503]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:57.503]                     ...future.globalenv.names))
[17:42:57.503]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:57.503]         }, condition = base::local({
[17:42:57.503]             c <- base::c
[17:42:57.503]             inherits <- base::inherits
[17:42:57.503]             invokeRestart <- base::invokeRestart
[17:42:57.503]             length <- base::length
[17:42:57.503]             list <- base::list
[17:42:57.503]             seq.int <- base::seq.int
[17:42:57.503]             signalCondition <- base::signalCondition
[17:42:57.503]             sys.calls <- base::sys.calls
[17:42:57.503]             `[[` <- base::`[[`
[17:42:57.503]             `+` <- base::`+`
[17:42:57.503]             `<<-` <- base::`<<-`
[17:42:57.503]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:57.503]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:57.503]                   3L)]
[17:42:57.503]             }
[17:42:57.503]             function(cond) {
[17:42:57.503]                 is_error <- inherits(cond, "error")
[17:42:57.503]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:57.503]                   NULL)
[17:42:57.503]                 if (is_error) {
[17:42:57.503]                   sessionInformation <- function() {
[17:42:57.503]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:57.503]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:57.503]                       search = base::search(), system = base::Sys.info())
[17:42:57.503]                   }
[17:42:57.503]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.503]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:57.503]                     cond$call), session = sessionInformation(), 
[17:42:57.503]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:57.503]                   signalCondition(cond)
[17:42:57.503]                 }
[17:42:57.503]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:57.503]                 "immediateCondition"))) {
[17:42:57.503]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:57.503]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.503]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:57.503]                   if (TRUE && !signal) {
[17:42:57.503]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.503]                     {
[17:42:57.503]                       inherits <- base::inherits
[17:42:57.503]                       invokeRestart <- base::invokeRestart
[17:42:57.503]                       is.null <- base::is.null
[17:42:57.503]                       muffled <- FALSE
[17:42:57.503]                       if (inherits(cond, "message")) {
[17:42:57.503]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.503]                         if (muffled) 
[17:42:57.503]                           invokeRestart("muffleMessage")
[17:42:57.503]                       }
[17:42:57.503]                       else if (inherits(cond, "warning")) {
[17:42:57.503]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.503]                         if (muffled) 
[17:42:57.503]                           invokeRestart("muffleWarning")
[17:42:57.503]                       }
[17:42:57.503]                       else if (inherits(cond, "condition")) {
[17:42:57.503]                         if (!is.null(pattern)) {
[17:42:57.503]                           computeRestarts <- base::computeRestarts
[17:42:57.503]                           grepl <- base::grepl
[17:42:57.503]                           restarts <- computeRestarts(cond)
[17:42:57.503]                           for (restart in restarts) {
[17:42:57.503]                             name <- restart$name
[17:42:57.503]                             if (is.null(name)) 
[17:42:57.503]                               next
[17:42:57.503]                             if (!grepl(pattern, name)) 
[17:42:57.503]                               next
[17:42:57.503]                             invokeRestart(restart)
[17:42:57.503]                             muffled <- TRUE
[17:42:57.503]                             break
[17:42:57.503]                           }
[17:42:57.503]                         }
[17:42:57.503]                       }
[17:42:57.503]                       invisible(muffled)
[17:42:57.503]                     }
[17:42:57.503]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.503]                   }
[17:42:57.503]                 }
[17:42:57.503]                 else {
[17:42:57.503]                   if (TRUE) {
[17:42:57.503]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.503]                     {
[17:42:57.503]                       inherits <- base::inherits
[17:42:57.503]                       invokeRestart <- base::invokeRestart
[17:42:57.503]                       is.null <- base::is.null
[17:42:57.503]                       muffled <- FALSE
[17:42:57.503]                       if (inherits(cond, "message")) {
[17:42:57.503]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.503]                         if (muffled) 
[17:42:57.503]                           invokeRestart("muffleMessage")
[17:42:57.503]                       }
[17:42:57.503]                       else if (inherits(cond, "warning")) {
[17:42:57.503]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.503]                         if (muffled) 
[17:42:57.503]                           invokeRestart("muffleWarning")
[17:42:57.503]                       }
[17:42:57.503]                       else if (inherits(cond, "condition")) {
[17:42:57.503]                         if (!is.null(pattern)) {
[17:42:57.503]                           computeRestarts <- base::computeRestarts
[17:42:57.503]                           grepl <- base::grepl
[17:42:57.503]                           restarts <- computeRestarts(cond)
[17:42:57.503]                           for (restart in restarts) {
[17:42:57.503]                             name <- restart$name
[17:42:57.503]                             if (is.null(name)) 
[17:42:57.503]                               next
[17:42:57.503]                             if (!grepl(pattern, name)) 
[17:42:57.503]                               next
[17:42:57.503]                             invokeRestart(restart)
[17:42:57.503]                             muffled <- TRUE
[17:42:57.503]                             break
[17:42:57.503]                           }
[17:42:57.503]                         }
[17:42:57.503]                       }
[17:42:57.503]                       invisible(muffled)
[17:42:57.503]                     }
[17:42:57.503]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.503]                   }
[17:42:57.503]                 }
[17:42:57.503]             }
[17:42:57.503]         }))
[17:42:57.503]     }, error = function(ex) {
[17:42:57.503]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:57.503]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.503]                 ...future.rng), started = ...future.startTime, 
[17:42:57.503]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:57.503]             version = "1.8"), class = "FutureResult")
[17:42:57.503]     }, finally = {
[17:42:57.503]         if (!identical(...future.workdir, getwd())) 
[17:42:57.503]             setwd(...future.workdir)
[17:42:57.503]         {
[17:42:57.503]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:57.503]                 ...future.oldOptions$nwarnings <- NULL
[17:42:57.503]             }
[17:42:57.503]             base::options(...future.oldOptions)
[17:42:57.503]             if (.Platform$OS.type == "windows") {
[17:42:57.503]                 old_names <- names(...future.oldEnvVars)
[17:42:57.503]                 envs <- base::Sys.getenv()
[17:42:57.503]                 names <- names(envs)
[17:42:57.503]                 common <- intersect(names, old_names)
[17:42:57.503]                 added <- setdiff(names, old_names)
[17:42:57.503]                 removed <- setdiff(old_names, names)
[17:42:57.503]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:57.503]                   envs[common]]
[17:42:57.503]                 NAMES <- toupper(changed)
[17:42:57.503]                 args <- list()
[17:42:57.503]                 for (kk in seq_along(NAMES)) {
[17:42:57.503]                   name <- changed[[kk]]
[17:42:57.503]                   NAME <- NAMES[[kk]]
[17:42:57.503]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.503]                     next
[17:42:57.503]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.503]                 }
[17:42:57.503]                 NAMES <- toupper(added)
[17:42:57.503]                 for (kk in seq_along(NAMES)) {
[17:42:57.503]                   name <- added[[kk]]
[17:42:57.503]                   NAME <- NAMES[[kk]]
[17:42:57.503]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.503]                     next
[17:42:57.503]                   args[[name]] <- ""
[17:42:57.503]                 }
[17:42:57.503]                 NAMES <- toupper(removed)
[17:42:57.503]                 for (kk in seq_along(NAMES)) {
[17:42:57.503]                   name <- removed[[kk]]
[17:42:57.503]                   NAME <- NAMES[[kk]]
[17:42:57.503]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.503]                     next
[17:42:57.503]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.503]                 }
[17:42:57.503]                 if (length(args) > 0) 
[17:42:57.503]                   base::do.call(base::Sys.setenv, args = args)
[17:42:57.503]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:57.503]             }
[17:42:57.503]             else {
[17:42:57.503]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:57.503]             }
[17:42:57.503]             {
[17:42:57.503]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:57.503]                   0L) {
[17:42:57.503]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:57.503]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:57.503]                   base::options(opts)
[17:42:57.503]                 }
[17:42:57.503]                 {
[17:42:57.503]                   {
[17:42:57.503]                     NULL
[17:42:57.503]                     RNGkind("Mersenne-Twister")
[17:42:57.503]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:57.503]                       inherits = FALSE)
[17:42:57.503]                   }
[17:42:57.503]                   options(future.plan = NULL)
[17:42:57.503]                   if (is.na(NA_character_)) 
[17:42:57.503]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.503]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:57.503]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:57.503]                     envir = parent.frame()) 
[17:42:57.503]                   {
[17:42:57.503]                     default_workers <- missing(workers)
[17:42:57.503]                     if (is.function(workers)) 
[17:42:57.503]                       workers <- workers()
[17:42:57.503]                     workers <- structure(as.integer(workers), 
[17:42:57.503]                       class = class(workers))
[17:42:57.503]                     stop_if_not(is.finite(workers), workers >= 
[17:42:57.503]                       1L)
[17:42:57.503]                     if ((workers == 1L && !inherits(workers, 
[17:42:57.503]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:57.503]                       if (default_workers) 
[17:42:57.503]                         supportsMulticore(warn = TRUE)
[17:42:57.503]                       return(sequential(..., envir = envir))
[17:42:57.503]                     }
[17:42:57.503]                     oopts <- options(mc.cores = workers)
[17:42:57.503]                     on.exit(options(oopts))
[17:42:57.503]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:57.503]                       envir = envir)
[17:42:57.503]                     if (!future$lazy) 
[17:42:57.503]                       future <- run(future)
[17:42:57.503]                     invisible(future)
[17:42:57.503]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:57.503]                 }
[17:42:57.503]             }
[17:42:57.503]         }
[17:42:57.503]     })
[17:42:57.503]     if (TRUE) {
[17:42:57.503]         base::sink(type = "output", split = FALSE)
[17:42:57.503]         if (TRUE) {
[17:42:57.503]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:57.503]         }
[17:42:57.503]         else {
[17:42:57.503]             ...future.result["stdout"] <- base::list(NULL)
[17:42:57.503]         }
[17:42:57.503]         base::close(...future.stdout)
[17:42:57.503]         ...future.stdout <- NULL
[17:42:57.503]     }
[17:42:57.503]     ...future.result$conditions <- ...future.conditions
[17:42:57.503]     ...future.result$finished <- base::Sys.time()
[17:42:57.503]     ...future.result
[17:42:57.503] }
[17:42:57.505] assign_globals() ...
[17:42:57.505] List of 1
[17:42:57.505]  $ a: num 0
[17:42:57.505]  - attr(*, "where")=List of 1
[17:42:57.505]   ..$ a:<environment: R_EmptyEnv> 
[17:42:57.505]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:57.505]  - attr(*, "resolved")= logi FALSE
[17:42:57.505]  - attr(*, "total_size")= num 56
[17:42:57.510] - copied ‘a’ to environment
[17:42:57.510] assign_globals() ... done
[17:42:57.510] plan(): Setting new future strategy stack:
[17:42:57.510] List of future strategies:
[17:42:57.510] 1. sequential:
[17:42:57.510]    - args: function (..., envir = parent.frame())
[17:42:57.510]    - tweaked: FALSE
[17:42:57.510]    - call: NULL
[17:42:57.511] plan(): nbrOfWorkers() = 1
[17:42:57.511] plan(): Setting new future strategy stack:
[17:42:57.511] List of future strategies:
[17:42:57.511] 1. multicore:
[17:42:57.511]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:57.511]    - tweaked: FALSE
[17:42:57.511]    - call: plan(multicore)
[17:42:57.515] plan(): nbrOfWorkers() = 1
[17:42:57.515] SequentialFuture started (and completed)
SequentialFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: 1 objects totaling 56 bytes (numeric ‘a’ of 56 bytes)
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 56 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: 56280105-ab48-3cfb-51ca-f6f685381758
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[1] 0
*** multicore(..., globals = TRUE) with globals and blocking
 - Creating multicore future #1 ...
[17:42:57.520] getGlobalsAndPackages() ...
[17:42:57.520] Searching for globals...
[17:42:57.520] - globals found: [2] ‘{’, ‘ii’
[17:42:57.521] Searching for globals ... DONE
[17:42:57.521] Resolving globals: FALSE
[17:42:57.521] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:57.521] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:42:57.521] - globals: [1] ‘ii’
[17:42:57.522] 
[17:42:57.522] getGlobalsAndPackages() ... DONE
[17:42:57.522] Packages needed by the future expression (n = 0): <none>
[17:42:57.522] Packages needed by future strategies (n = 0): <none>
[17:42:57.523] {
[17:42:57.523]     {
[17:42:57.523]         {
[17:42:57.523]             ...future.startTime <- base::Sys.time()
[17:42:57.523]             {
[17:42:57.523]                 {
[17:42:57.523]                   {
[17:42:57.523]                     base::local({
[17:42:57.523]                       has_future <- base::requireNamespace("future", 
[17:42:57.523]                         quietly = TRUE)
[17:42:57.523]                       if (has_future) {
[17:42:57.523]                         ns <- base::getNamespace("future")
[17:42:57.523]                         version <- ns[[".package"]][["version"]]
[17:42:57.523]                         if (is.null(version)) 
[17:42:57.523]                           version <- utils::packageVersion("future")
[17:42:57.523]                       }
[17:42:57.523]                       else {
[17:42:57.523]                         version <- NULL
[17:42:57.523]                       }
[17:42:57.523]                       if (!has_future || version < "1.8.0") {
[17:42:57.523]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:57.523]                           "", base::R.version$version.string), 
[17:42:57.523]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:57.523]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:57.523]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:57.523]                             "release", "version")], collapse = " "), 
[17:42:57.523]                           hostname = base::Sys.info()[["nodename"]])
[17:42:57.523]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:57.523]                           info)
[17:42:57.523]                         info <- base::paste(info, collapse = "; ")
[17:42:57.523]                         if (!has_future) {
[17:42:57.523]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:57.523]                             info)
[17:42:57.523]                         }
[17:42:57.523]                         else {
[17:42:57.523]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:57.523]                             info, version)
[17:42:57.523]                         }
[17:42:57.523]                         base::stop(msg)
[17:42:57.523]                       }
[17:42:57.523]                     })
[17:42:57.523]                   }
[17:42:57.523]                   options(future.plan = NULL)
[17:42:57.523]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.523]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:57.523]                 }
[17:42:57.523]                 ...future.workdir <- getwd()
[17:42:57.523]             }
[17:42:57.523]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:57.523]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:57.523]         }
[17:42:57.523]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:57.523]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:57.523]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:57.523]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:57.523]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:57.523]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:57.523]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:57.523]             base::names(...future.oldOptions))
[17:42:57.523]     }
[17:42:57.523]     if (FALSE) {
[17:42:57.523]     }
[17:42:57.523]     else {
[17:42:57.523]         if (TRUE) {
[17:42:57.523]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:57.523]                 open = "w")
[17:42:57.523]         }
[17:42:57.523]         else {
[17:42:57.523]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:57.523]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:57.523]         }
[17:42:57.523]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:57.523]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:57.523]             base::sink(type = "output", split = FALSE)
[17:42:57.523]             base::close(...future.stdout)
[17:42:57.523]         }, add = TRUE)
[17:42:57.523]     }
[17:42:57.523]     ...future.frame <- base::sys.nframe()
[17:42:57.523]     ...future.conditions <- base::list()
[17:42:57.523]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:57.523]     if (FALSE) {
[17:42:57.523]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:57.523]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:57.523]     }
[17:42:57.523]     ...future.result <- base::tryCatch({
[17:42:57.523]         base::withCallingHandlers({
[17:42:57.523]             ...future.value <- base::withVisible(base::local({
[17:42:57.523]                 ii
[17:42:57.523]             }))
[17:42:57.523]             future::FutureResult(value = ...future.value$value, 
[17:42:57.523]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.523]                   ...future.rng), globalenv = if (FALSE) 
[17:42:57.523]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:57.523]                     ...future.globalenv.names))
[17:42:57.523]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:57.523]         }, condition = base::local({
[17:42:57.523]             c <- base::c
[17:42:57.523]             inherits <- base::inherits
[17:42:57.523]             invokeRestart <- base::invokeRestart
[17:42:57.523]             length <- base::length
[17:42:57.523]             list <- base::list
[17:42:57.523]             seq.int <- base::seq.int
[17:42:57.523]             signalCondition <- base::signalCondition
[17:42:57.523]             sys.calls <- base::sys.calls
[17:42:57.523]             `[[` <- base::`[[`
[17:42:57.523]             `+` <- base::`+`
[17:42:57.523]             `<<-` <- base::`<<-`
[17:42:57.523]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:57.523]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:57.523]                   3L)]
[17:42:57.523]             }
[17:42:57.523]             function(cond) {
[17:42:57.523]                 is_error <- inherits(cond, "error")
[17:42:57.523]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:57.523]                   NULL)
[17:42:57.523]                 if (is_error) {
[17:42:57.523]                   sessionInformation <- function() {
[17:42:57.523]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:57.523]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:57.523]                       search = base::search(), system = base::Sys.info())
[17:42:57.523]                   }
[17:42:57.523]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.523]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:57.523]                     cond$call), session = sessionInformation(), 
[17:42:57.523]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:57.523]                   signalCondition(cond)
[17:42:57.523]                 }
[17:42:57.523]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:57.523]                 "immediateCondition"))) {
[17:42:57.523]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:57.523]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.523]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:57.523]                   if (TRUE && !signal) {
[17:42:57.523]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.523]                     {
[17:42:57.523]                       inherits <- base::inherits
[17:42:57.523]                       invokeRestart <- base::invokeRestart
[17:42:57.523]                       is.null <- base::is.null
[17:42:57.523]                       muffled <- FALSE
[17:42:57.523]                       if (inherits(cond, "message")) {
[17:42:57.523]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.523]                         if (muffled) 
[17:42:57.523]                           invokeRestart("muffleMessage")
[17:42:57.523]                       }
[17:42:57.523]                       else if (inherits(cond, "warning")) {
[17:42:57.523]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.523]                         if (muffled) 
[17:42:57.523]                           invokeRestart("muffleWarning")
[17:42:57.523]                       }
[17:42:57.523]                       else if (inherits(cond, "condition")) {
[17:42:57.523]                         if (!is.null(pattern)) {
[17:42:57.523]                           computeRestarts <- base::computeRestarts
[17:42:57.523]                           grepl <- base::grepl
[17:42:57.523]                           restarts <- computeRestarts(cond)
[17:42:57.523]                           for (restart in restarts) {
[17:42:57.523]                             name <- restart$name
[17:42:57.523]                             if (is.null(name)) 
[17:42:57.523]                               next
[17:42:57.523]                             if (!grepl(pattern, name)) 
[17:42:57.523]                               next
[17:42:57.523]                             invokeRestart(restart)
[17:42:57.523]                             muffled <- TRUE
[17:42:57.523]                             break
[17:42:57.523]                           }
[17:42:57.523]                         }
[17:42:57.523]                       }
[17:42:57.523]                       invisible(muffled)
[17:42:57.523]                     }
[17:42:57.523]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.523]                   }
[17:42:57.523]                 }
[17:42:57.523]                 else {
[17:42:57.523]                   if (TRUE) {
[17:42:57.523]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.523]                     {
[17:42:57.523]                       inherits <- base::inherits
[17:42:57.523]                       invokeRestart <- base::invokeRestart
[17:42:57.523]                       is.null <- base::is.null
[17:42:57.523]                       muffled <- FALSE
[17:42:57.523]                       if (inherits(cond, "message")) {
[17:42:57.523]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.523]                         if (muffled) 
[17:42:57.523]                           invokeRestart("muffleMessage")
[17:42:57.523]                       }
[17:42:57.523]                       else if (inherits(cond, "warning")) {
[17:42:57.523]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.523]                         if (muffled) 
[17:42:57.523]                           invokeRestart("muffleWarning")
[17:42:57.523]                       }
[17:42:57.523]                       else if (inherits(cond, "condition")) {
[17:42:57.523]                         if (!is.null(pattern)) {
[17:42:57.523]                           computeRestarts <- base::computeRestarts
[17:42:57.523]                           grepl <- base::grepl
[17:42:57.523]                           restarts <- computeRestarts(cond)
[17:42:57.523]                           for (restart in restarts) {
[17:42:57.523]                             name <- restart$name
[17:42:57.523]                             if (is.null(name)) 
[17:42:57.523]                               next
[17:42:57.523]                             if (!grepl(pattern, name)) 
[17:42:57.523]                               next
[17:42:57.523]                             invokeRestart(restart)
[17:42:57.523]                             muffled <- TRUE
[17:42:57.523]                             break
[17:42:57.523]                           }
[17:42:57.523]                         }
[17:42:57.523]                       }
[17:42:57.523]                       invisible(muffled)
[17:42:57.523]                     }
[17:42:57.523]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.523]                   }
[17:42:57.523]                 }
[17:42:57.523]             }
[17:42:57.523]         }))
[17:42:57.523]     }, error = function(ex) {
[17:42:57.523]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:57.523]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.523]                 ...future.rng), started = ...future.startTime, 
[17:42:57.523]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:57.523]             version = "1.8"), class = "FutureResult")
[17:42:57.523]     }, finally = {
[17:42:57.523]         if (!identical(...future.workdir, getwd())) 
[17:42:57.523]             setwd(...future.workdir)
[17:42:57.523]         {
[17:42:57.523]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:57.523]                 ...future.oldOptions$nwarnings <- NULL
[17:42:57.523]             }
[17:42:57.523]             base::options(...future.oldOptions)
[17:42:57.523]             if (.Platform$OS.type == "windows") {
[17:42:57.523]                 old_names <- names(...future.oldEnvVars)
[17:42:57.523]                 envs <- base::Sys.getenv()
[17:42:57.523]                 names <- names(envs)
[17:42:57.523]                 common <- intersect(names, old_names)
[17:42:57.523]                 added <- setdiff(names, old_names)
[17:42:57.523]                 removed <- setdiff(old_names, names)
[17:42:57.523]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:57.523]                   envs[common]]
[17:42:57.523]                 NAMES <- toupper(changed)
[17:42:57.523]                 args <- list()
[17:42:57.523]                 for (kk in seq_along(NAMES)) {
[17:42:57.523]                   name <- changed[[kk]]
[17:42:57.523]                   NAME <- NAMES[[kk]]
[17:42:57.523]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.523]                     next
[17:42:57.523]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.523]                 }
[17:42:57.523]                 NAMES <- toupper(added)
[17:42:57.523]                 for (kk in seq_along(NAMES)) {
[17:42:57.523]                   name <- added[[kk]]
[17:42:57.523]                   NAME <- NAMES[[kk]]
[17:42:57.523]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.523]                     next
[17:42:57.523]                   args[[name]] <- ""
[17:42:57.523]                 }
[17:42:57.523]                 NAMES <- toupper(removed)
[17:42:57.523]                 for (kk in seq_along(NAMES)) {
[17:42:57.523]                   name <- removed[[kk]]
[17:42:57.523]                   NAME <- NAMES[[kk]]
[17:42:57.523]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.523]                     next
[17:42:57.523]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.523]                 }
[17:42:57.523]                 if (length(args) > 0) 
[17:42:57.523]                   base::do.call(base::Sys.setenv, args = args)
[17:42:57.523]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:57.523]             }
[17:42:57.523]             else {
[17:42:57.523]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:57.523]             }
[17:42:57.523]             {
[17:42:57.523]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:57.523]                   0L) {
[17:42:57.523]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:57.523]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:57.523]                   base::options(opts)
[17:42:57.523]                 }
[17:42:57.523]                 {
[17:42:57.523]                   {
[17:42:57.523]                     NULL
[17:42:57.523]                     RNGkind("Mersenne-Twister")
[17:42:57.523]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:57.523]                       inherits = FALSE)
[17:42:57.523]                   }
[17:42:57.523]                   options(future.plan = NULL)
[17:42:57.523]                   if (is.na(NA_character_)) 
[17:42:57.523]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.523]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:57.523]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:57.523]                     envir = parent.frame()) 
[17:42:57.523]                   {
[17:42:57.523]                     default_workers <- missing(workers)
[17:42:57.523]                     if (is.function(workers)) 
[17:42:57.523]                       workers <- workers()
[17:42:57.523]                     workers <- structure(as.integer(workers), 
[17:42:57.523]                       class = class(workers))
[17:42:57.523]                     stop_if_not(is.finite(workers), workers >= 
[17:42:57.523]                       1L)
[17:42:57.523]                     if ((workers == 1L && !inherits(workers, 
[17:42:57.523]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:57.523]                       if (default_workers) 
[17:42:57.523]                         supportsMulticore(warn = TRUE)
[17:42:57.523]                       return(sequential(..., envir = envir))
[17:42:57.523]                     }
[17:42:57.523]                     oopts <- options(mc.cores = workers)
[17:42:57.523]                     on.exit(options(oopts))
[17:42:57.523]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:57.523]                       envir = envir)
[17:42:57.523]                     if (!future$lazy) 
[17:42:57.523]                       future <- run(future)
[17:42:57.523]                     invisible(future)
[17:42:57.523]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:57.523]                 }
[17:42:57.523]             }
[17:42:57.523]         }
[17:42:57.523]     })
[17:42:57.523]     if (TRUE) {
[17:42:57.523]         base::sink(type = "output", split = FALSE)
[17:42:57.523]         if (TRUE) {
[17:42:57.523]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:57.523]         }
[17:42:57.523]         else {
[17:42:57.523]             ...future.result["stdout"] <- base::list(NULL)
[17:42:57.523]         }
[17:42:57.523]         base::close(...future.stdout)
[17:42:57.523]         ...future.stdout <- NULL
[17:42:57.523]     }
[17:42:57.523]     ...future.result$conditions <- ...future.conditions
[17:42:57.523]     ...future.result$finished <- base::Sys.time()
[17:42:57.523]     ...future.result
[17:42:57.523] }
[17:42:57.524] assign_globals() ...
[17:42:57.524] List of 1
[17:42:57.524]  $ ii: int 1
[17:42:57.524]  - attr(*, "where")=List of 1
[17:42:57.524]   ..$ ii:<environment: R_EmptyEnv> 
[17:42:57.524]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:57.524]  - attr(*, "resolved")= logi FALSE
[17:42:57.524]  - attr(*, "total_size")= num 56
[17:42:57.527] - copied ‘ii’ to environment
[17:42:57.527] assign_globals() ... done
[17:42:57.527] plan(): Setting new future strategy stack:
[17:42:57.527] List of future strategies:
[17:42:57.527] 1. sequential:
[17:42:57.527]    - args: function (..., envir = parent.frame())
[17:42:57.527]    - tweaked: FALSE
[17:42:57.527]    - call: NULL
[17:42:57.528] plan(): nbrOfWorkers() = 1
[17:42:57.528] plan(): Setting new future strategy stack:
[17:42:57.528] List of future strategies:
[17:42:57.528] 1. multicore:
[17:42:57.528]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:57.528]    - tweaked: FALSE
[17:42:57.528]    - call: plan(multicore)
[17:42:57.532] plan(): nbrOfWorkers() = 1
[17:42:57.532] SequentialFuture started (and completed)
 - Creating multicore future #2 ...
[17:42:57.535] getGlobalsAndPackages() ...
[17:42:57.536] Searching for globals...
[17:42:57.536] - globals found: [2] ‘{’, ‘ii’
[17:42:57.536] Searching for globals ... DONE
[17:42:57.537] Resolving globals: FALSE
[17:42:57.537] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:57.537] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:42:57.537] - globals: [1] ‘ii’
[17:42:57.537] 
[17:42:57.538] getGlobalsAndPackages() ... DONE
[17:42:57.538] Packages needed by the future expression (n = 0): <none>
[17:42:57.538] Packages needed by future strategies (n = 0): <none>
[17:42:57.538] {
[17:42:57.538]     {
[17:42:57.538]         {
[17:42:57.538]             ...future.startTime <- base::Sys.time()
[17:42:57.538]             {
[17:42:57.538]                 {
[17:42:57.538]                   {
[17:42:57.538]                     base::local({
[17:42:57.538]                       has_future <- base::requireNamespace("future", 
[17:42:57.538]                         quietly = TRUE)
[17:42:57.538]                       if (has_future) {
[17:42:57.538]                         ns <- base::getNamespace("future")
[17:42:57.538]                         version <- ns[[".package"]][["version"]]
[17:42:57.538]                         if (is.null(version)) 
[17:42:57.538]                           version <- utils::packageVersion("future")
[17:42:57.538]                       }
[17:42:57.538]                       else {
[17:42:57.538]                         version <- NULL
[17:42:57.538]                       }
[17:42:57.538]                       if (!has_future || version < "1.8.0") {
[17:42:57.538]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:57.538]                           "", base::R.version$version.string), 
[17:42:57.538]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:57.538]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:57.538]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:57.538]                             "release", "version")], collapse = " "), 
[17:42:57.538]                           hostname = base::Sys.info()[["nodename"]])
[17:42:57.538]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:57.538]                           info)
[17:42:57.538]                         info <- base::paste(info, collapse = "; ")
[17:42:57.538]                         if (!has_future) {
[17:42:57.538]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:57.538]                             info)
[17:42:57.538]                         }
[17:42:57.538]                         else {
[17:42:57.538]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:57.538]                             info, version)
[17:42:57.538]                         }
[17:42:57.538]                         base::stop(msg)
[17:42:57.538]                       }
[17:42:57.538]                     })
[17:42:57.538]                   }
[17:42:57.538]                   options(future.plan = NULL)
[17:42:57.538]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.538]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:57.538]                 }
[17:42:57.538]                 ...future.workdir <- getwd()
[17:42:57.538]             }
[17:42:57.538]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:57.538]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:57.538]         }
[17:42:57.538]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:57.538]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:57.538]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:57.538]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:57.538]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:57.538]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:57.538]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:57.538]             base::names(...future.oldOptions))
[17:42:57.538]     }
[17:42:57.538]     if (FALSE) {
[17:42:57.538]     }
[17:42:57.538]     else {
[17:42:57.538]         if (TRUE) {
[17:42:57.538]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:57.538]                 open = "w")
[17:42:57.538]         }
[17:42:57.538]         else {
[17:42:57.538]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:57.538]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:57.538]         }
[17:42:57.538]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:57.538]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:57.538]             base::sink(type = "output", split = FALSE)
[17:42:57.538]             base::close(...future.stdout)
[17:42:57.538]         }, add = TRUE)
[17:42:57.538]     }
[17:42:57.538]     ...future.frame <- base::sys.nframe()
[17:42:57.538]     ...future.conditions <- base::list()
[17:42:57.538]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:57.538]     if (FALSE) {
[17:42:57.538]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:57.538]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:57.538]     }
[17:42:57.538]     ...future.result <- base::tryCatch({
[17:42:57.538]         base::withCallingHandlers({
[17:42:57.538]             ...future.value <- base::withVisible(base::local({
[17:42:57.538]                 ii
[17:42:57.538]             }))
[17:42:57.538]             future::FutureResult(value = ...future.value$value, 
[17:42:57.538]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.538]                   ...future.rng), globalenv = if (FALSE) 
[17:42:57.538]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:57.538]                     ...future.globalenv.names))
[17:42:57.538]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:57.538]         }, condition = base::local({
[17:42:57.538]             c <- base::c
[17:42:57.538]             inherits <- base::inherits
[17:42:57.538]             invokeRestart <- base::invokeRestart
[17:42:57.538]             length <- base::length
[17:42:57.538]             list <- base::list
[17:42:57.538]             seq.int <- base::seq.int
[17:42:57.538]             signalCondition <- base::signalCondition
[17:42:57.538]             sys.calls <- base::sys.calls
[17:42:57.538]             `[[` <- base::`[[`
[17:42:57.538]             `+` <- base::`+`
[17:42:57.538]             `<<-` <- base::`<<-`
[17:42:57.538]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:57.538]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:57.538]                   3L)]
[17:42:57.538]             }
[17:42:57.538]             function(cond) {
[17:42:57.538]                 is_error <- inherits(cond, "error")
[17:42:57.538]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:57.538]                   NULL)
[17:42:57.538]                 if (is_error) {
[17:42:57.538]                   sessionInformation <- function() {
[17:42:57.538]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:57.538]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:57.538]                       search = base::search(), system = base::Sys.info())
[17:42:57.538]                   }
[17:42:57.538]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.538]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:57.538]                     cond$call), session = sessionInformation(), 
[17:42:57.538]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:57.538]                   signalCondition(cond)
[17:42:57.538]                 }
[17:42:57.538]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:57.538]                 "immediateCondition"))) {
[17:42:57.538]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:57.538]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.538]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:57.538]                   if (TRUE && !signal) {
[17:42:57.538]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.538]                     {
[17:42:57.538]                       inherits <- base::inherits
[17:42:57.538]                       invokeRestart <- base::invokeRestart
[17:42:57.538]                       is.null <- base::is.null
[17:42:57.538]                       muffled <- FALSE
[17:42:57.538]                       if (inherits(cond, "message")) {
[17:42:57.538]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.538]                         if (muffled) 
[17:42:57.538]                           invokeRestart("muffleMessage")
[17:42:57.538]                       }
[17:42:57.538]                       else if (inherits(cond, "warning")) {
[17:42:57.538]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.538]                         if (muffled) 
[17:42:57.538]                           invokeRestart("muffleWarning")
[17:42:57.538]                       }
[17:42:57.538]                       else if (inherits(cond, "condition")) {
[17:42:57.538]                         if (!is.null(pattern)) {
[17:42:57.538]                           computeRestarts <- base::computeRestarts
[17:42:57.538]                           grepl <- base::grepl
[17:42:57.538]                           restarts <- computeRestarts(cond)
[17:42:57.538]                           for (restart in restarts) {
[17:42:57.538]                             name <- restart$name
[17:42:57.538]                             if (is.null(name)) 
[17:42:57.538]                               next
[17:42:57.538]                             if (!grepl(pattern, name)) 
[17:42:57.538]                               next
[17:42:57.538]                             invokeRestart(restart)
[17:42:57.538]                             muffled <- TRUE
[17:42:57.538]                             break
[17:42:57.538]                           }
[17:42:57.538]                         }
[17:42:57.538]                       }
[17:42:57.538]                       invisible(muffled)
[17:42:57.538]                     }
[17:42:57.538]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.538]                   }
[17:42:57.538]                 }
[17:42:57.538]                 else {
[17:42:57.538]                   if (TRUE) {
[17:42:57.538]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.538]                     {
[17:42:57.538]                       inherits <- base::inherits
[17:42:57.538]                       invokeRestart <- base::invokeRestart
[17:42:57.538]                       is.null <- base::is.null
[17:42:57.538]                       muffled <- FALSE
[17:42:57.538]                       if (inherits(cond, "message")) {
[17:42:57.538]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.538]                         if (muffled) 
[17:42:57.538]                           invokeRestart("muffleMessage")
[17:42:57.538]                       }
[17:42:57.538]                       else if (inherits(cond, "warning")) {
[17:42:57.538]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.538]                         if (muffled) 
[17:42:57.538]                           invokeRestart("muffleWarning")
[17:42:57.538]                       }
[17:42:57.538]                       else if (inherits(cond, "condition")) {
[17:42:57.538]                         if (!is.null(pattern)) {
[17:42:57.538]                           computeRestarts <- base::computeRestarts
[17:42:57.538]                           grepl <- base::grepl
[17:42:57.538]                           restarts <- computeRestarts(cond)
[17:42:57.538]                           for (restart in restarts) {
[17:42:57.538]                             name <- restart$name
[17:42:57.538]                             if (is.null(name)) 
[17:42:57.538]                               next
[17:42:57.538]                             if (!grepl(pattern, name)) 
[17:42:57.538]                               next
[17:42:57.538]                             invokeRestart(restart)
[17:42:57.538]                             muffled <- TRUE
[17:42:57.538]                             break
[17:42:57.538]                           }
[17:42:57.538]                         }
[17:42:57.538]                       }
[17:42:57.538]                       invisible(muffled)
[17:42:57.538]                     }
[17:42:57.538]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.538]                   }
[17:42:57.538]                 }
[17:42:57.538]             }
[17:42:57.538]         }))
[17:42:57.538]     }, error = function(ex) {
[17:42:57.538]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:57.538]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.538]                 ...future.rng), started = ...future.startTime, 
[17:42:57.538]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:57.538]             version = "1.8"), class = "FutureResult")
[17:42:57.538]     }, finally = {
[17:42:57.538]         if (!identical(...future.workdir, getwd())) 
[17:42:57.538]             setwd(...future.workdir)
[17:42:57.538]         {
[17:42:57.538]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:57.538]                 ...future.oldOptions$nwarnings <- NULL
[17:42:57.538]             }
[17:42:57.538]             base::options(...future.oldOptions)
[17:42:57.538]             if (.Platform$OS.type == "windows") {
[17:42:57.538]                 old_names <- names(...future.oldEnvVars)
[17:42:57.538]                 envs <- base::Sys.getenv()
[17:42:57.538]                 names <- names(envs)
[17:42:57.538]                 common <- intersect(names, old_names)
[17:42:57.538]                 added <- setdiff(names, old_names)
[17:42:57.538]                 removed <- setdiff(old_names, names)
[17:42:57.538]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:57.538]                   envs[common]]
[17:42:57.538]                 NAMES <- toupper(changed)
[17:42:57.538]                 args <- list()
[17:42:57.538]                 for (kk in seq_along(NAMES)) {
[17:42:57.538]                   name <- changed[[kk]]
[17:42:57.538]                   NAME <- NAMES[[kk]]
[17:42:57.538]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.538]                     next
[17:42:57.538]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.538]                 }
[17:42:57.538]                 NAMES <- toupper(added)
[17:42:57.538]                 for (kk in seq_along(NAMES)) {
[17:42:57.538]                   name <- added[[kk]]
[17:42:57.538]                   NAME <- NAMES[[kk]]
[17:42:57.538]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.538]                     next
[17:42:57.538]                   args[[name]] <- ""
[17:42:57.538]                 }
[17:42:57.538]                 NAMES <- toupper(removed)
[17:42:57.538]                 for (kk in seq_along(NAMES)) {
[17:42:57.538]                   name <- removed[[kk]]
[17:42:57.538]                   NAME <- NAMES[[kk]]
[17:42:57.538]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.538]                     next
[17:42:57.538]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.538]                 }
[17:42:57.538]                 if (length(args) > 0) 
[17:42:57.538]                   base::do.call(base::Sys.setenv, args = args)
[17:42:57.538]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:57.538]             }
[17:42:57.538]             else {
[17:42:57.538]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:57.538]             }
[17:42:57.538]             {
[17:42:57.538]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:57.538]                   0L) {
[17:42:57.538]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:57.538]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:57.538]                   base::options(opts)
[17:42:57.538]                 }
[17:42:57.538]                 {
[17:42:57.538]                   {
[17:42:57.538]                     NULL
[17:42:57.538]                     RNGkind("Mersenne-Twister")
[17:42:57.538]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:57.538]                       inherits = FALSE)
[17:42:57.538]                   }
[17:42:57.538]                   options(future.plan = NULL)
[17:42:57.538]                   if (is.na(NA_character_)) 
[17:42:57.538]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.538]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:57.538]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:57.538]                     envir = parent.frame()) 
[17:42:57.538]                   {
[17:42:57.538]                     default_workers <- missing(workers)
[17:42:57.538]                     if (is.function(workers)) 
[17:42:57.538]                       workers <- workers()
[17:42:57.538]                     workers <- structure(as.integer(workers), 
[17:42:57.538]                       class = class(workers))
[17:42:57.538]                     stop_if_not(is.finite(workers), workers >= 
[17:42:57.538]                       1L)
[17:42:57.538]                     if ((workers == 1L && !inherits(workers, 
[17:42:57.538]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:57.538]                       if (default_workers) 
[17:42:57.538]                         supportsMulticore(warn = TRUE)
[17:42:57.538]                       return(sequential(..., envir = envir))
[17:42:57.538]                     }
[17:42:57.538]                     oopts <- options(mc.cores = workers)
[17:42:57.538]                     on.exit(options(oopts))
[17:42:57.538]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:57.538]                       envir = envir)
[17:42:57.538]                     if (!future$lazy) 
[17:42:57.538]                       future <- run(future)
[17:42:57.538]                     invisible(future)
[17:42:57.538]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:57.538]                 }
[17:42:57.538]             }
[17:42:57.538]         }
[17:42:57.538]     })
[17:42:57.538]     if (TRUE) {
[17:42:57.538]         base::sink(type = "output", split = FALSE)
[17:42:57.538]         if (TRUE) {
[17:42:57.538]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:57.538]         }
[17:42:57.538]         else {
[17:42:57.538]             ...future.result["stdout"] <- base::list(NULL)
[17:42:57.538]         }
[17:42:57.538]         base::close(...future.stdout)
[17:42:57.538]         ...future.stdout <- NULL
[17:42:57.538]     }
[17:42:57.538]     ...future.result$conditions <- ...future.conditions
[17:42:57.538]     ...future.result$finished <- base::Sys.time()
[17:42:57.538]     ...future.result
[17:42:57.538] }
[17:42:57.540] assign_globals() ...
[17:42:57.540] List of 1
[17:42:57.540]  $ ii: int 2
[17:42:57.540]  - attr(*, "where")=List of 1
[17:42:57.540]   ..$ ii:<environment: R_EmptyEnv> 
[17:42:57.540]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:57.540]  - attr(*, "resolved")= logi FALSE
[17:42:57.540]  - attr(*, "total_size")= num 56
[17:42:57.545] - copied ‘ii’ to environment
[17:42:57.545] assign_globals() ... done
[17:42:57.545] plan(): Setting new future strategy stack:
[17:42:57.545] List of future strategies:
[17:42:57.545] 1. sequential:
[17:42:57.545]    - args: function (..., envir = parent.frame())
[17:42:57.545]    - tweaked: FALSE
[17:42:57.545]    - call: NULL
[17:42:57.545] plan(): nbrOfWorkers() = 1
[17:42:57.546] plan(): Setting new future strategy stack:
[17:42:57.546] List of future strategies:
[17:42:57.546] 1. multicore:
[17:42:57.546]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:57.546]    - tweaked: FALSE
[17:42:57.546]    - call: plan(multicore)
[17:42:57.550] plan(): nbrOfWorkers() = 1
[17:42:57.550] SequentialFuture started (and completed)
 - Creating multicore future #3 ...
[17:42:57.554] getGlobalsAndPackages() ...
[17:42:57.554] Searching for globals...
[17:42:57.554] - globals found: [2] ‘{’, ‘ii’
[17:42:57.554] Searching for globals ... DONE
[17:42:57.555] Resolving globals: FALSE
[17:42:57.555] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:57.555] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:42:57.555] - globals: [1] ‘ii’
[17:42:57.556] 
[17:42:57.556] getGlobalsAndPackages() ... DONE
[17:42:57.556] Packages needed by the future expression (n = 0): <none>
[17:42:57.556] Packages needed by future strategies (n = 0): <none>
[17:42:57.556] {
[17:42:57.556]     {
[17:42:57.556]         {
[17:42:57.556]             ...future.startTime <- base::Sys.time()
[17:42:57.556]             {
[17:42:57.556]                 {
[17:42:57.556]                   {
[17:42:57.556]                     base::local({
[17:42:57.556]                       has_future <- base::requireNamespace("future", 
[17:42:57.556]                         quietly = TRUE)
[17:42:57.556]                       if (has_future) {
[17:42:57.556]                         ns <- base::getNamespace("future")
[17:42:57.556]                         version <- ns[[".package"]][["version"]]
[17:42:57.556]                         if (is.null(version)) 
[17:42:57.556]                           version <- utils::packageVersion("future")
[17:42:57.556]                       }
[17:42:57.556]                       else {
[17:42:57.556]                         version <- NULL
[17:42:57.556]                       }
[17:42:57.556]                       if (!has_future || version < "1.8.0") {
[17:42:57.556]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:57.556]                           "", base::R.version$version.string), 
[17:42:57.556]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:57.556]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:57.556]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:57.556]                             "release", "version")], collapse = " "), 
[17:42:57.556]                           hostname = base::Sys.info()[["nodename"]])
[17:42:57.556]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:57.556]                           info)
[17:42:57.556]                         info <- base::paste(info, collapse = "; ")
[17:42:57.556]                         if (!has_future) {
[17:42:57.556]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:57.556]                             info)
[17:42:57.556]                         }
[17:42:57.556]                         else {
[17:42:57.556]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:57.556]                             info, version)
[17:42:57.556]                         }
[17:42:57.556]                         base::stop(msg)
[17:42:57.556]                       }
[17:42:57.556]                     })
[17:42:57.556]                   }
[17:42:57.556]                   options(future.plan = NULL)
[17:42:57.556]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.556]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:57.556]                 }
[17:42:57.556]                 ...future.workdir <- getwd()
[17:42:57.556]             }
[17:42:57.556]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:57.556]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:57.556]         }
[17:42:57.556]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:57.556]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:57.556]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:57.556]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:57.556]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:57.556]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:57.556]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:57.556]             base::names(...future.oldOptions))
[17:42:57.556]     }
[17:42:57.556]     if (FALSE) {
[17:42:57.556]     }
[17:42:57.556]     else {
[17:42:57.556]         if (TRUE) {
[17:42:57.556]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:57.556]                 open = "w")
[17:42:57.556]         }
[17:42:57.556]         else {
[17:42:57.556]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:57.556]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:57.556]         }
[17:42:57.556]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:57.556]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:57.556]             base::sink(type = "output", split = FALSE)
[17:42:57.556]             base::close(...future.stdout)
[17:42:57.556]         }, add = TRUE)
[17:42:57.556]     }
[17:42:57.556]     ...future.frame <- base::sys.nframe()
[17:42:57.556]     ...future.conditions <- base::list()
[17:42:57.556]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:57.556]     if (FALSE) {
[17:42:57.556]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:57.556]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:57.556]     }
[17:42:57.556]     ...future.result <- base::tryCatch({
[17:42:57.556]         base::withCallingHandlers({
[17:42:57.556]             ...future.value <- base::withVisible(base::local({
[17:42:57.556]                 ii
[17:42:57.556]             }))
[17:42:57.556]             future::FutureResult(value = ...future.value$value, 
[17:42:57.556]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.556]                   ...future.rng), globalenv = if (FALSE) 
[17:42:57.556]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:57.556]                     ...future.globalenv.names))
[17:42:57.556]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:57.556]         }, condition = base::local({
[17:42:57.556]             c <- base::c
[17:42:57.556]             inherits <- base::inherits
[17:42:57.556]             invokeRestart <- base::invokeRestart
[17:42:57.556]             length <- base::length
[17:42:57.556]             list <- base::list
[17:42:57.556]             seq.int <- base::seq.int
[17:42:57.556]             signalCondition <- base::signalCondition
[17:42:57.556]             sys.calls <- base::sys.calls
[17:42:57.556]             `[[` <- base::`[[`
[17:42:57.556]             `+` <- base::`+`
[17:42:57.556]             `<<-` <- base::`<<-`
[17:42:57.556]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:57.556]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:57.556]                   3L)]
[17:42:57.556]             }
[17:42:57.556]             function(cond) {
[17:42:57.556]                 is_error <- inherits(cond, "error")
[17:42:57.556]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:57.556]                   NULL)
[17:42:57.556]                 if (is_error) {
[17:42:57.556]                   sessionInformation <- function() {
[17:42:57.556]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:57.556]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:57.556]                       search = base::search(), system = base::Sys.info())
[17:42:57.556]                   }
[17:42:57.556]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.556]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:57.556]                     cond$call), session = sessionInformation(), 
[17:42:57.556]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:57.556]                   signalCondition(cond)
[17:42:57.556]                 }
[17:42:57.556]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:57.556]                 "immediateCondition"))) {
[17:42:57.556]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:57.556]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.556]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:57.556]                   if (TRUE && !signal) {
[17:42:57.556]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.556]                     {
[17:42:57.556]                       inherits <- base::inherits
[17:42:57.556]                       invokeRestart <- base::invokeRestart
[17:42:57.556]                       is.null <- base::is.null
[17:42:57.556]                       muffled <- FALSE
[17:42:57.556]                       if (inherits(cond, "message")) {
[17:42:57.556]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.556]                         if (muffled) 
[17:42:57.556]                           invokeRestart("muffleMessage")
[17:42:57.556]                       }
[17:42:57.556]                       else if (inherits(cond, "warning")) {
[17:42:57.556]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.556]                         if (muffled) 
[17:42:57.556]                           invokeRestart("muffleWarning")
[17:42:57.556]                       }
[17:42:57.556]                       else if (inherits(cond, "condition")) {
[17:42:57.556]                         if (!is.null(pattern)) {
[17:42:57.556]                           computeRestarts <- base::computeRestarts
[17:42:57.556]                           grepl <- base::grepl
[17:42:57.556]                           restarts <- computeRestarts(cond)
[17:42:57.556]                           for (restart in restarts) {
[17:42:57.556]                             name <- restart$name
[17:42:57.556]                             if (is.null(name)) 
[17:42:57.556]                               next
[17:42:57.556]                             if (!grepl(pattern, name)) 
[17:42:57.556]                               next
[17:42:57.556]                             invokeRestart(restart)
[17:42:57.556]                             muffled <- TRUE
[17:42:57.556]                             break
[17:42:57.556]                           }
[17:42:57.556]                         }
[17:42:57.556]                       }
[17:42:57.556]                       invisible(muffled)
[17:42:57.556]                     }
[17:42:57.556]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.556]                   }
[17:42:57.556]                 }
[17:42:57.556]                 else {
[17:42:57.556]                   if (TRUE) {
[17:42:57.556]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.556]                     {
[17:42:57.556]                       inherits <- base::inherits
[17:42:57.556]                       invokeRestart <- base::invokeRestart
[17:42:57.556]                       is.null <- base::is.null
[17:42:57.556]                       muffled <- FALSE
[17:42:57.556]                       if (inherits(cond, "message")) {
[17:42:57.556]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.556]                         if (muffled) 
[17:42:57.556]                           invokeRestart("muffleMessage")
[17:42:57.556]                       }
[17:42:57.556]                       else if (inherits(cond, "warning")) {
[17:42:57.556]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.556]                         if (muffled) 
[17:42:57.556]                           invokeRestart("muffleWarning")
[17:42:57.556]                       }
[17:42:57.556]                       else if (inherits(cond, "condition")) {
[17:42:57.556]                         if (!is.null(pattern)) {
[17:42:57.556]                           computeRestarts <- base::computeRestarts
[17:42:57.556]                           grepl <- base::grepl
[17:42:57.556]                           restarts <- computeRestarts(cond)
[17:42:57.556]                           for (restart in restarts) {
[17:42:57.556]                             name <- restart$name
[17:42:57.556]                             if (is.null(name)) 
[17:42:57.556]                               next
[17:42:57.556]                             if (!grepl(pattern, name)) 
[17:42:57.556]                               next
[17:42:57.556]                             invokeRestart(restart)
[17:42:57.556]                             muffled <- TRUE
[17:42:57.556]                             break
[17:42:57.556]                           }
[17:42:57.556]                         }
[17:42:57.556]                       }
[17:42:57.556]                       invisible(muffled)
[17:42:57.556]                     }
[17:42:57.556]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.556]                   }
[17:42:57.556]                 }
[17:42:57.556]             }
[17:42:57.556]         }))
[17:42:57.556]     }, error = function(ex) {
[17:42:57.556]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:57.556]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.556]                 ...future.rng), started = ...future.startTime, 
[17:42:57.556]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:57.556]             version = "1.8"), class = "FutureResult")
[17:42:57.556]     }, finally = {
[17:42:57.556]         if (!identical(...future.workdir, getwd())) 
[17:42:57.556]             setwd(...future.workdir)
[17:42:57.556]         {
[17:42:57.556]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:57.556]                 ...future.oldOptions$nwarnings <- NULL
[17:42:57.556]             }
[17:42:57.556]             base::options(...future.oldOptions)
[17:42:57.556]             if (.Platform$OS.type == "windows") {
[17:42:57.556]                 old_names <- names(...future.oldEnvVars)
[17:42:57.556]                 envs <- base::Sys.getenv()
[17:42:57.556]                 names <- names(envs)
[17:42:57.556]                 common <- intersect(names, old_names)
[17:42:57.556]                 added <- setdiff(names, old_names)
[17:42:57.556]                 removed <- setdiff(old_names, names)
[17:42:57.556]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:57.556]                   envs[common]]
[17:42:57.556]                 NAMES <- toupper(changed)
[17:42:57.556]                 args <- list()
[17:42:57.556]                 for (kk in seq_along(NAMES)) {
[17:42:57.556]                   name <- changed[[kk]]
[17:42:57.556]                   NAME <- NAMES[[kk]]
[17:42:57.556]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.556]                     next
[17:42:57.556]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.556]                 }
[17:42:57.556]                 NAMES <- toupper(added)
[17:42:57.556]                 for (kk in seq_along(NAMES)) {
[17:42:57.556]                   name <- added[[kk]]
[17:42:57.556]                   NAME <- NAMES[[kk]]
[17:42:57.556]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.556]                     next
[17:42:57.556]                   args[[name]] <- ""
[17:42:57.556]                 }
[17:42:57.556]                 NAMES <- toupper(removed)
[17:42:57.556]                 for (kk in seq_along(NAMES)) {
[17:42:57.556]                   name <- removed[[kk]]
[17:42:57.556]                   NAME <- NAMES[[kk]]
[17:42:57.556]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.556]                     next
[17:42:57.556]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.556]                 }
[17:42:57.556]                 if (length(args) > 0) 
[17:42:57.556]                   base::do.call(base::Sys.setenv, args = args)
[17:42:57.556]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:57.556]             }
[17:42:57.556]             else {
[17:42:57.556]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:57.556]             }
[17:42:57.556]             {
[17:42:57.556]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:57.556]                   0L) {
[17:42:57.556]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:57.556]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:57.556]                   base::options(opts)
[17:42:57.556]                 }
[17:42:57.556]                 {
[17:42:57.556]                   {
[17:42:57.556]                     NULL
[17:42:57.556]                     RNGkind("Mersenne-Twister")
[17:42:57.556]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:57.556]                       inherits = FALSE)
[17:42:57.556]                   }
[17:42:57.556]                   options(future.plan = NULL)
[17:42:57.556]                   if (is.na(NA_character_)) 
[17:42:57.556]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.556]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:57.556]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:57.556]                     envir = parent.frame()) 
[17:42:57.556]                   {
[17:42:57.556]                     default_workers <- missing(workers)
[17:42:57.556]                     if (is.function(workers)) 
[17:42:57.556]                       workers <- workers()
[17:42:57.556]                     workers <- structure(as.integer(workers), 
[17:42:57.556]                       class = class(workers))
[17:42:57.556]                     stop_if_not(is.finite(workers), workers >= 
[17:42:57.556]                       1L)
[17:42:57.556]                     if ((workers == 1L && !inherits(workers, 
[17:42:57.556]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:57.556]                       if (default_workers) 
[17:42:57.556]                         supportsMulticore(warn = TRUE)
[17:42:57.556]                       return(sequential(..., envir = envir))
[17:42:57.556]                     }
[17:42:57.556]                     oopts <- options(mc.cores = workers)
[17:42:57.556]                     on.exit(options(oopts))
[17:42:57.556]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:57.556]                       envir = envir)
[17:42:57.556]                     if (!future$lazy) 
[17:42:57.556]                       future <- run(future)
[17:42:57.556]                     invisible(future)
[17:42:57.556]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:57.556]                 }
[17:42:57.556]             }
[17:42:57.556]         }
[17:42:57.556]     })
[17:42:57.556]     if (TRUE) {
[17:42:57.556]         base::sink(type = "output", split = FALSE)
[17:42:57.556]         if (TRUE) {
[17:42:57.556]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:57.556]         }
[17:42:57.556]         else {
[17:42:57.556]             ...future.result["stdout"] <- base::list(NULL)
[17:42:57.556]         }
[17:42:57.556]         base::close(...future.stdout)
[17:42:57.556]         ...future.stdout <- NULL
[17:42:57.556]     }
[17:42:57.556]     ...future.result$conditions <- ...future.conditions
[17:42:57.556]     ...future.result$finished <- base::Sys.time()
[17:42:57.556]     ...future.result
[17:42:57.556] }
[17:42:57.558] assign_globals() ...
[17:42:57.558] List of 1
[17:42:57.558]  $ ii: int 3
[17:42:57.558]  - attr(*, "where")=List of 1
[17:42:57.558]   ..$ ii:<environment: R_EmptyEnv> 
[17:42:57.558]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:57.558]  - attr(*, "resolved")= logi FALSE
[17:42:57.558]  - attr(*, "total_size")= num 56
[17:42:57.560] - copied ‘ii’ to environment
[17:42:57.560] assign_globals() ... done
[17:42:57.561] plan(): Setting new future strategy stack:
[17:42:57.561] List of future strategies:
[17:42:57.561] 1. sequential:
[17:42:57.561]    - args: function (..., envir = parent.frame())
[17:42:57.561]    - tweaked: FALSE
[17:42:57.561]    - call: NULL
[17:42:57.561] plan(): nbrOfWorkers() = 1
[17:42:57.562] plan(): Setting new future strategy stack:
[17:42:57.562] List of future strategies:
[17:42:57.562] 1. multicore:
[17:42:57.562]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:57.562]    - tweaked: FALSE
[17:42:57.562]    - call: plan(multicore)
[17:42:57.565] plan(): nbrOfWorkers() = 1
[17:42:57.566] SequentialFuture started (and completed)
 - Creating multicore future #4 ...
[17:42:57.569] getGlobalsAndPackages() ...
[17:42:57.569] Searching for globals...
[17:42:57.570] - globals found: [2] ‘{’, ‘ii’
[17:42:57.570] Searching for globals ... DONE
[17:42:57.570] Resolving globals: FALSE
[17:42:57.570] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:57.570] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:42:57.571] - globals: [1] ‘ii’
[17:42:57.571] 
[17:42:57.571] getGlobalsAndPackages() ... DONE
[17:42:57.571] Packages needed by the future expression (n = 0): <none>
[17:42:57.571] Packages needed by future strategies (n = 0): <none>
[17:42:57.572] {
[17:42:57.572]     {
[17:42:57.572]         {
[17:42:57.572]             ...future.startTime <- base::Sys.time()
[17:42:57.572]             {
[17:42:57.572]                 {
[17:42:57.572]                   {
[17:42:57.572]                     base::local({
[17:42:57.572]                       has_future <- base::requireNamespace("future", 
[17:42:57.572]                         quietly = TRUE)
[17:42:57.572]                       if (has_future) {
[17:42:57.572]                         ns <- base::getNamespace("future")
[17:42:57.572]                         version <- ns[[".package"]][["version"]]
[17:42:57.572]                         if (is.null(version)) 
[17:42:57.572]                           version <- utils::packageVersion("future")
[17:42:57.572]                       }
[17:42:57.572]                       else {
[17:42:57.572]                         version <- NULL
[17:42:57.572]                       }
[17:42:57.572]                       if (!has_future || version < "1.8.0") {
[17:42:57.572]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:57.572]                           "", base::R.version$version.string), 
[17:42:57.572]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:57.572]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:57.572]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:57.572]                             "release", "version")], collapse = " "), 
[17:42:57.572]                           hostname = base::Sys.info()[["nodename"]])
[17:42:57.572]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:57.572]                           info)
[17:42:57.572]                         info <- base::paste(info, collapse = "; ")
[17:42:57.572]                         if (!has_future) {
[17:42:57.572]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:57.572]                             info)
[17:42:57.572]                         }
[17:42:57.572]                         else {
[17:42:57.572]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:57.572]                             info, version)
[17:42:57.572]                         }
[17:42:57.572]                         base::stop(msg)
[17:42:57.572]                       }
[17:42:57.572]                     })
[17:42:57.572]                   }
[17:42:57.572]                   options(future.plan = NULL)
[17:42:57.572]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.572]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:57.572]                 }
[17:42:57.572]                 ...future.workdir <- getwd()
[17:42:57.572]             }
[17:42:57.572]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:57.572]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:57.572]         }
[17:42:57.572]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:57.572]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:57.572]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:57.572]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:57.572]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:57.572]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:57.572]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:57.572]             base::names(...future.oldOptions))
[17:42:57.572]     }
[17:42:57.572]     if (FALSE) {
[17:42:57.572]     }
[17:42:57.572]     else {
[17:42:57.572]         if (TRUE) {
[17:42:57.572]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:57.572]                 open = "w")
[17:42:57.572]         }
[17:42:57.572]         else {
[17:42:57.572]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:57.572]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:57.572]         }
[17:42:57.572]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:57.572]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:57.572]             base::sink(type = "output", split = FALSE)
[17:42:57.572]             base::close(...future.stdout)
[17:42:57.572]         }, add = TRUE)
[17:42:57.572]     }
[17:42:57.572]     ...future.frame <- base::sys.nframe()
[17:42:57.572]     ...future.conditions <- base::list()
[17:42:57.572]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:57.572]     if (FALSE) {
[17:42:57.572]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:57.572]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:57.572]     }
[17:42:57.572]     ...future.result <- base::tryCatch({
[17:42:57.572]         base::withCallingHandlers({
[17:42:57.572]             ...future.value <- base::withVisible(base::local({
[17:42:57.572]                 ii
[17:42:57.572]             }))
[17:42:57.572]             future::FutureResult(value = ...future.value$value, 
[17:42:57.572]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.572]                   ...future.rng), globalenv = if (FALSE) 
[17:42:57.572]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:57.572]                     ...future.globalenv.names))
[17:42:57.572]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:57.572]         }, condition = base::local({
[17:42:57.572]             c <- base::c
[17:42:57.572]             inherits <- base::inherits
[17:42:57.572]             invokeRestart <- base::invokeRestart
[17:42:57.572]             length <- base::length
[17:42:57.572]             list <- base::list
[17:42:57.572]             seq.int <- base::seq.int
[17:42:57.572]             signalCondition <- base::signalCondition
[17:42:57.572]             sys.calls <- base::sys.calls
[17:42:57.572]             `[[` <- base::`[[`
[17:42:57.572]             `+` <- base::`+`
[17:42:57.572]             `<<-` <- base::`<<-`
[17:42:57.572]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:57.572]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:57.572]                   3L)]
[17:42:57.572]             }
[17:42:57.572]             function(cond) {
[17:42:57.572]                 is_error <- inherits(cond, "error")
[17:42:57.572]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:57.572]                   NULL)
[17:42:57.572]                 if (is_error) {
[17:42:57.572]                   sessionInformation <- function() {
[17:42:57.572]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:57.572]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:57.572]                       search = base::search(), system = base::Sys.info())
[17:42:57.572]                   }
[17:42:57.572]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.572]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:57.572]                     cond$call), session = sessionInformation(), 
[17:42:57.572]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:57.572]                   signalCondition(cond)
[17:42:57.572]                 }
[17:42:57.572]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:57.572]                 "immediateCondition"))) {
[17:42:57.572]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:57.572]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.572]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:57.572]                   if (TRUE && !signal) {
[17:42:57.572]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.572]                     {
[17:42:57.572]                       inherits <- base::inherits
[17:42:57.572]                       invokeRestart <- base::invokeRestart
[17:42:57.572]                       is.null <- base::is.null
[17:42:57.572]                       muffled <- FALSE
[17:42:57.572]                       if (inherits(cond, "message")) {
[17:42:57.572]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.572]                         if (muffled) 
[17:42:57.572]                           invokeRestart("muffleMessage")
[17:42:57.572]                       }
[17:42:57.572]                       else if (inherits(cond, "warning")) {
[17:42:57.572]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.572]                         if (muffled) 
[17:42:57.572]                           invokeRestart("muffleWarning")
[17:42:57.572]                       }
[17:42:57.572]                       else if (inherits(cond, "condition")) {
[17:42:57.572]                         if (!is.null(pattern)) {
[17:42:57.572]                           computeRestarts <- base::computeRestarts
[17:42:57.572]                           grepl <- base::grepl
[17:42:57.572]                           restarts <- computeRestarts(cond)
[17:42:57.572]                           for (restart in restarts) {
[17:42:57.572]                             name <- restart$name
[17:42:57.572]                             if (is.null(name)) 
[17:42:57.572]                               next
[17:42:57.572]                             if (!grepl(pattern, name)) 
[17:42:57.572]                               next
[17:42:57.572]                             invokeRestart(restart)
[17:42:57.572]                             muffled <- TRUE
[17:42:57.572]                             break
[17:42:57.572]                           }
[17:42:57.572]                         }
[17:42:57.572]                       }
[17:42:57.572]                       invisible(muffled)
[17:42:57.572]                     }
[17:42:57.572]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.572]                   }
[17:42:57.572]                 }
[17:42:57.572]                 else {
[17:42:57.572]                   if (TRUE) {
[17:42:57.572]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.572]                     {
[17:42:57.572]                       inherits <- base::inherits
[17:42:57.572]                       invokeRestart <- base::invokeRestart
[17:42:57.572]                       is.null <- base::is.null
[17:42:57.572]                       muffled <- FALSE
[17:42:57.572]                       if (inherits(cond, "message")) {
[17:42:57.572]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.572]                         if (muffled) 
[17:42:57.572]                           invokeRestart("muffleMessage")
[17:42:57.572]                       }
[17:42:57.572]                       else if (inherits(cond, "warning")) {
[17:42:57.572]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.572]                         if (muffled) 
[17:42:57.572]                           invokeRestart("muffleWarning")
[17:42:57.572]                       }
[17:42:57.572]                       else if (inherits(cond, "condition")) {
[17:42:57.572]                         if (!is.null(pattern)) {
[17:42:57.572]                           computeRestarts <- base::computeRestarts
[17:42:57.572]                           grepl <- base::grepl
[17:42:57.572]                           restarts <- computeRestarts(cond)
[17:42:57.572]                           for (restart in restarts) {
[17:42:57.572]                             name <- restart$name
[17:42:57.572]                             if (is.null(name)) 
[17:42:57.572]                               next
[17:42:57.572]                             if (!grepl(pattern, name)) 
[17:42:57.572]                               next
[17:42:57.572]                             invokeRestart(restart)
[17:42:57.572]                             muffled <- TRUE
[17:42:57.572]                             break
[17:42:57.572]                           }
[17:42:57.572]                         }
[17:42:57.572]                       }
[17:42:57.572]                       invisible(muffled)
[17:42:57.572]                     }
[17:42:57.572]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.572]                   }
[17:42:57.572]                 }
[17:42:57.572]             }
[17:42:57.572]         }))
[17:42:57.572]     }, error = function(ex) {
[17:42:57.572]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:57.572]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.572]                 ...future.rng), started = ...future.startTime, 
[17:42:57.572]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:57.572]             version = "1.8"), class = "FutureResult")
[17:42:57.572]     }, finally = {
[17:42:57.572]         if (!identical(...future.workdir, getwd())) 
[17:42:57.572]             setwd(...future.workdir)
[17:42:57.572]         {
[17:42:57.572]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:57.572]                 ...future.oldOptions$nwarnings <- NULL
[17:42:57.572]             }
[17:42:57.572]             base::options(...future.oldOptions)
[17:42:57.572]             if (.Platform$OS.type == "windows") {
[17:42:57.572]                 old_names <- names(...future.oldEnvVars)
[17:42:57.572]                 envs <- base::Sys.getenv()
[17:42:57.572]                 names <- names(envs)
[17:42:57.572]                 common <- intersect(names, old_names)
[17:42:57.572]                 added <- setdiff(names, old_names)
[17:42:57.572]                 removed <- setdiff(old_names, names)
[17:42:57.572]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:57.572]                   envs[common]]
[17:42:57.572]                 NAMES <- toupper(changed)
[17:42:57.572]                 args <- list()
[17:42:57.572]                 for (kk in seq_along(NAMES)) {
[17:42:57.572]                   name <- changed[[kk]]
[17:42:57.572]                   NAME <- NAMES[[kk]]
[17:42:57.572]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.572]                     next
[17:42:57.572]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.572]                 }
[17:42:57.572]                 NAMES <- toupper(added)
[17:42:57.572]                 for (kk in seq_along(NAMES)) {
[17:42:57.572]                   name <- added[[kk]]
[17:42:57.572]                   NAME <- NAMES[[kk]]
[17:42:57.572]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.572]                     next
[17:42:57.572]                   args[[name]] <- ""
[17:42:57.572]                 }
[17:42:57.572]                 NAMES <- toupper(removed)
[17:42:57.572]                 for (kk in seq_along(NAMES)) {
[17:42:57.572]                   name <- removed[[kk]]
[17:42:57.572]                   NAME <- NAMES[[kk]]
[17:42:57.572]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.572]                     next
[17:42:57.572]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.572]                 }
[17:42:57.572]                 if (length(args) > 0) 
[17:42:57.572]                   base::do.call(base::Sys.setenv, args = args)
[17:42:57.572]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:57.572]             }
[17:42:57.572]             else {
[17:42:57.572]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:57.572]             }
[17:42:57.572]             {
[17:42:57.572]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:57.572]                   0L) {
[17:42:57.572]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:57.572]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:57.572]                   base::options(opts)
[17:42:57.572]                 }
[17:42:57.572]                 {
[17:42:57.572]                   {
[17:42:57.572]                     NULL
[17:42:57.572]                     RNGkind("Mersenne-Twister")
[17:42:57.572]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:57.572]                       inherits = FALSE)
[17:42:57.572]                   }
[17:42:57.572]                   options(future.plan = NULL)
[17:42:57.572]                   if (is.na(NA_character_)) 
[17:42:57.572]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.572]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:57.572]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:57.572]                     envir = parent.frame()) 
[17:42:57.572]                   {
[17:42:57.572]                     default_workers <- missing(workers)
[17:42:57.572]                     if (is.function(workers)) 
[17:42:57.572]                       workers <- workers()
[17:42:57.572]                     workers <- structure(as.integer(workers), 
[17:42:57.572]                       class = class(workers))
[17:42:57.572]                     stop_if_not(is.finite(workers), workers >= 
[17:42:57.572]                       1L)
[17:42:57.572]                     if ((workers == 1L && !inherits(workers, 
[17:42:57.572]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:57.572]                       if (default_workers) 
[17:42:57.572]                         supportsMulticore(warn = TRUE)
[17:42:57.572]                       return(sequential(..., envir = envir))
[17:42:57.572]                     }
[17:42:57.572]                     oopts <- options(mc.cores = workers)
[17:42:57.572]                     on.exit(options(oopts))
[17:42:57.572]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:57.572]                       envir = envir)
[17:42:57.572]                     if (!future$lazy) 
[17:42:57.572]                       future <- run(future)
[17:42:57.572]                     invisible(future)
[17:42:57.572]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:57.572]                 }
[17:42:57.572]             }
[17:42:57.572]         }
[17:42:57.572]     })
[17:42:57.572]     if (TRUE) {
[17:42:57.572]         base::sink(type = "output", split = FALSE)
[17:42:57.572]         if (TRUE) {
[17:42:57.572]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:57.572]         }
[17:42:57.572]         else {
[17:42:57.572]             ...future.result["stdout"] <- base::list(NULL)
[17:42:57.572]         }
[17:42:57.572]         base::close(...future.stdout)
[17:42:57.572]         ...future.stdout <- NULL
[17:42:57.572]     }
[17:42:57.572]     ...future.result$conditions <- ...future.conditions
[17:42:57.572]     ...future.result$finished <- base::Sys.time()
[17:42:57.572]     ...future.result
[17:42:57.572] }
[17:42:57.573] assign_globals() ...
[17:42:57.573] List of 1
[17:42:57.573]  $ ii: int 4
[17:42:57.573]  - attr(*, "where")=List of 1
[17:42:57.573]   ..$ ii:<environment: R_EmptyEnv> 
[17:42:57.573]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:57.573]  - attr(*, "resolved")= logi FALSE
[17:42:57.573]  - attr(*, "total_size")= num 56
[17:42:57.576] - copied ‘ii’ to environment
[17:42:57.576] assign_globals() ... done
[17:42:57.576] plan(): Setting new future strategy stack:
[17:42:57.576] List of future strategies:
[17:42:57.576] 1. sequential:
[17:42:57.576]    - args: function (..., envir = parent.frame())
[17:42:57.576]    - tweaked: FALSE
[17:42:57.576]    - call: NULL
[17:42:57.576] plan(): nbrOfWorkers() = 1
[17:42:57.577] plan(): Setting new future strategy stack:
[17:42:57.577] List of future strategies:
[17:42:57.577] 1. multicore:
[17:42:57.577]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:57.577]    - tweaked: FALSE
[17:42:57.577]    - call: plan(multicore)
[17:42:57.581] plan(): nbrOfWorkers() = 1
[17:42:57.581] SequentialFuture started (and completed)
 - Resolving 4 multicore futures
*** multicore(..., globals = TRUE) and errors
[17:42:57.585] getGlobalsAndPackages() ...
[17:42:57.585] Searching for globals...
[17:42:57.586] - globals found: [2] ‘{’, ‘stop’
[17:42:57.588] Searching for globals ... DONE
[17:42:57.588] Resolving globals: FALSE
[17:42:57.588] 
[17:42:57.588] 
[17:42:57.589] getGlobalsAndPackages() ... DONE
[17:42:57.589] Packages needed by the future expression (n = 0): <none>
[17:42:57.589] Packages needed by future strategies (n = 0): <none>
[17:42:57.589] {
[17:42:57.589]     {
[17:42:57.589]         {
[17:42:57.589]             ...future.startTime <- base::Sys.time()
[17:42:57.589]             {
[17:42:57.589]                 {
[17:42:57.589]                   {
[17:42:57.589]                     base::local({
[17:42:57.589]                       has_future <- base::requireNamespace("future", 
[17:42:57.589]                         quietly = TRUE)
[17:42:57.589]                       if (has_future) {
[17:42:57.589]                         ns <- base::getNamespace("future")
[17:42:57.589]                         version <- ns[[".package"]][["version"]]
[17:42:57.589]                         if (is.null(version)) 
[17:42:57.589]                           version <- utils::packageVersion("future")
[17:42:57.589]                       }
[17:42:57.589]                       else {
[17:42:57.589]                         version <- NULL
[17:42:57.589]                       }
[17:42:57.589]                       if (!has_future || version < "1.8.0") {
[17:42:57.589]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:57.589]                           "", base::R.version$version.string), 
[17:42:57.589]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:57.589]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:57.589]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:57.589]                             "release", "version")], collapse = " "), 
[17:42:57.589]                           hostname = base::Sys.info()[["nodename"]])
[17:42:57.589]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:57.589]                           info)
[17:42:57.589]                         info <- base::paste(info, collapse = "; ")
[17:42:57.589]                         if (!has_future) {
[17:42:57.589]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:57.589]                             info)
[17:42:57.589]                         }
[17:42:57.589]                         else {
[17:42:57.589]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:57.589]                             info, version)
[17:42:57.589]                         }
[17:42:57.589]                         base::stop(msg)
[17:42:57.589]                       }
[17:42:57.589]                     })
[17:42:57.589]                   }
[17:42:57.589]                   options(future.plan = NULL)
[17:42:57.589]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.589]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:57.589]                 }
[17:42:57.589]                 ...future.workdir <- getwd()
[17:42:57.589]             }
[17:42:57.589]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:57.589]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:57.589]         }
[17:42:57.589]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:57.589]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:57.589]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:57.589]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:57.589]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:57.589]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:57.589]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:57.589]             base::names(...future.oldOptions))
[17:42:57.589]     }
[17:42:57.589]     if (FALSE) {
[17:42:57.589]     }
[17:42:57.589]     else {
[17:42:57.589]         if (TRUE) {
[17:42:57.589]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:57.589]                 open = "w")
[17:42:57.589]         }
[17:42:57.589]         else {
[17:42:57.589]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:57.589]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:57.589]         }
[17:42:57.589]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:57.589]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:57.589]             base::sink(type = "output", split = FALSE)
[17:42:57.589]             base::close(...future.stdout)
[17:42:57.589]         }, add = TRUE)
[17:42:57.589]     }
[17:42:57.589]     ...future.frame <- base::sys.nframe()
[17:42:57.589]     ...future.conditions <- base::list()
[17:42:57.589]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:57.589]     if (FALSE) {
[17:42:57.589]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:57.589]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:57.589]     }
[17:42:57.589]     ...future.result <- base::tryCatch({
[17:42:57.589]         base::withCallingHandlers({
[17:42:57.589]             ...future.value <- base::withVisible(base::local({
[17:42:57.589]                 stop("Whoops!")
[17:42:57.589]                 1
[17:42:57.589]             }))
[17:42:57.589]             future::FutureResult(value = ...future.value$value, 
[17:42:57.589]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.589]                   ...future.rng), globalenv = if (FALSE) 
[17:42:57.589]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:57.589]                     ...future.globalenv.names))
[17:42:57.589]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:57.589]         }, condition = base::local({
[17:42:57.589]             c <- base::c
[17:42:57.589]             inherits <- base::inherits
[17:42:57.589]             invokeRestart <- base::invokeRestart
[17:42:57.589]             length <- base::length
[17:42:57.589]             list <- base::list
[17:42:57.589]             seq.int <- base::seq.int
[17:42:57.589]             signalCondition <- base::signalCondition
[17:42:57.589]             sys.calls <- base::sys.calls
[17:42:57.589]             `[[` <- base::`[[`
[17:42:57.589]             `+` <- base::`+`
[17:42:57.589]             `<<-` <- base::`<<-`
[17:42:57.589]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:57.589]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:57.589]                   3L)]
[17:42:57.589]             }
[17:42:57.589]             function(cond) {
[17:42:57.589]                 is_error <- inherits(cond, "error")
[17:42:57.589]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:57.589]                   NULL)
[17:42:57.589]                 if (is_error) {
[17:42:57.589]                   sessionInformation <- function() {
[17:42:57.589]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:57.589]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:57.589]                       search = base::search(), system = base::Sys.info())
[17:42:57.589]                   }
[17:42:57.589]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.589]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:57.589]                     cond$call), session = sessionInformation(), 
[17:42:57.589]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:57.589]                   signalCondition(cond)
[17:42:57.589]                 }
[17:42:57.589]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:57.589]                 "immediateCondition"))) {
[17:42:57.589]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:57.589]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.589]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:57.589]                   if (TRUE && !signal) {
[17:42:57.589]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.589]                     {
[17:42:57.589]                       inherits <- base::inherits
[17:42:57.589]                       invokeRestart <- base::invokeRestart
[17:42:57.589]                       is.null <- base::is.null
[17:42:57.589]                       muffled <- FALSE
[17:42:57.589]                       if (inherits(cond, "message")) {
[17:42:57.589]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.589]                         if (muffled) 
[17:42:57.589]                           invokeRestart("muffleMessage")
[17:42:57.589]                       }
[17:42:57.589]                       else if (inherits(cond, "warning")) {
[17:42:57.589]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.589]                         if (muffled) 
[17:42:57.589]                           invokeRestart("muffleWarning")
[17:42:57.589]                       }
[17:42:57.589]                       else if (inherits(cond, "condition")) {
[17:42:57.589]                         if (!is.null(pattern)) {
[17:42:57.589]                           computeRestarts <- base::computeRestarts
[17:42:57.589]                           grepl <- base::grepl
[17:42:57.589]                           restarts <- computeRestarts(cond)
[17:42:57.589]                           for (restart in restarts) {
[17:42:57.589]                             name <- restart$name
[17:42:57.589]                             if (is.null(name)) 
[17:42:57.589]                               next
[17:42:57.589]                             if (!grepl(pattern, name)) 
[17:42:57.589]                               next
[17:42:57.589]                             invokeRestart(restart)
[17:42:57.589]                             muffled <- TRUE
[17:42:57.589]                             break
[17:42:57.589]                           }
[17:42:57.589]                         }
[17:42:57.589]                       }
[17:42:57.589]                       invisible(muffled)
[17:42:57.589]                     }
[17:42:57.589]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.589]                   }
[17:42:57.589]                 }
[17:42:57.589]                 else {
[17:42:57.589]                   if (TRUE) {
[17:42:57.589]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.589]                     {
[17:42:57.589]                       inherits <- base::inherits
[17:42:57.589]                       invokeRestart <- base::invokeRestart
[17:42:57.589]                       is.null <- base::is.null
[17:42:57.589]                       muffled <- FALSE
[17:42:57.589]                       if (inherits(cond, "message")) {
[17:42:57.589]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.589]                         if (muffled) 
[17:42:57.589]                           invokeRestart("muffleMessage")
[17:42:57.589]                       }
[17:42:57.589]                       else if (inherits(cond, "warning")) {
[17:42:57.589]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.589]                         if (muffled) 
[17:42:57.589]                           invokeRestart("muffleWarning")
[17:42:57.589]                       }
[17:42:57.589]                       else if (inherits(cond, "condition")) {
[17:42:57.589]                         if (!is.null(pattern)) {
[17:42:57.589]                           computeRestarts <- base::computeRestarts
[17:42:57.589]                           grepl <- base::grepl
[17:42:57.589]                           restarts <- computeRestarts(cond)
[17:42:57.589]                           for (restart in restarts) {
[17:42:57.589]                             name <- restart$name
[17:42:57.589]                             if (is.null(name)) 
[17:42:57.589]                               next
[17:42:57.589]                             if (!grepl(pattern, name)) 
[17:42:57.589]                               next
[17:42:57.589]                             invokeRestart(restart)
[17:42:57.589]                             muffled <- TRUE
[17:42:57.589]                             break
[17:42:57.589]                           }
[17:42:57.589]                         }
[17:42:57.589]                       }
[17:42:57.589]                       invisible(muffled)
[17:42:57.589]                     }
[17:42:57.589]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.589]                   }
[17:42:57.589]                 }
[17:42:57.589]             }
[17:42:57.589]         }))
[17:42:57.589]     }, error = function(ex) {
[17:42:57.589]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:57.589]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.589]                 ...future.rng), started = ...future.startTime, 
[17:42:57.589]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:57.589]             version = "1.8"), class = "FutureResult")
[17:42:57.589]     }, finally = {
[17:42:57.589]         if (!identical(...future.workdir, getwd())) 
[17:42:57.589]             setwd(...future.workdir)
[17:42:57.589]         {
[17:42:57.589]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:57.589]                 ...future.oldOptions$nwarnings <- NULL
[17:42:57.589]             }
[17:42:57.589]             base::options(...future.oldOptions)
[17:42:57.589]             if (.Platform$OS.type == "windows") {
[17:42:57.589]                 old_names <- names(...future.oldEnvVars)
[17:42:57.589]                 envs <- base::Sys.getenv()
[17:42:57.589]                 names <- names(envs)
[17:42:57.589]                 common <- intersect(names, old_names)
[17:42:57.589]                 added <- setdiff(names, old_names)
[17:42:57.589]                 removed <- setdiff(old_names, names)
[17:42:57.589]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:57.589]                   envs[common]]
[17:42:57.589]                 NAMES <- toupper(changed)
[17:42:57.589]                 args <- list()
[17:42:57.589]                 for (kk in seq_along(NAMES)) {
[17:42:57.589]                   name <- changed[[kk]]
[17:42:57.589]                   NAME <- NAMES[[kk]]
[17:42:57.589]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.589]                     next
[17:42:57.589]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.589]                 }
[17:42:57.589]                 NAMES <- toupper(added)
[17:42:57.589]                 for (kk in seq_along(NAMES)) {
[17:42:57.589]                   name <- added[[kk]]
[17:42:57.589]                   NAME <- NAMES[[kk]]
[17:42:57.589]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.589]                     next
[17:42:57.589]                   args[[name]] <- ""
[17:42:57.589]                 }
[17:42:57.589]                 NAMES <- toupper(removed)
[17:42:57.589]                 for (kk in seq_along(NAMES)) {
[17:42:57.589]                   name <- removed[[kk]]
[17:42:57.589]                   NAME <- NAMES[[kk]]
[17:42:57.589]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.589]                     next
[17:42:57.589]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.589]                 }
[17:42:57.589]                 if (length(args) > 0) 
[17:42:57.589]                   base::do.call(base::Sys.setenv, args = args)
[17:42:57.589]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:57.589]             }
[17:42:57.589]             else {
[17:42:57.589]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:57.589]             }
[17:42:57.589]             {
[17:42:57.589]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:57.589]                   0L) {
[17:42:57.589]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:57.589]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:57.589]                   base::options(opts)
[17:42:57.589]                 }
[17:42:57.589]                 {
[17:42:57.589]                   {
[17:42:57.589]                     NULL
[17:42:57.589]                     RNGkind("Mersenne-Twister")
[17:42:57.589]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:57.589]                       inherits = FALSE)
[17:42:57.589]                   }
[17:42:57.589]                   options(future.plan = NULL)
[17:42:57.589]                   if (is.na(NA_character_)) 
[17:42:57.589]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.589]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:57.589]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:57.589]                     envir = parent.frame()) 
[17:42:57.589]                   {
[17:42:57.589]                     default_workers <- missing(workers)
[17:42:57.589]                     if (is.function(workers)) 
[17:42:57.589]                       workers <- workers()
[17:42:57.589]                     workers <- structure(as.integer(workers), 
[17:42:57.589]                       class = class(workers))
[17:42:57.589]                     stop_if_not(is.finite(workers), workers >= 
[17:42:57.589]                       1L)
[17:42:57.589]                     if ((workers == 1L && !inherits(workers, 
[17:42:57.589]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:57.589]                       if (default_workers) 
[17:42:57.589]                         supportsMulticore(warn = TRUE)
[17:42:57.589]                       return(sequential(..., envir = envir))
[17:42:57.589]                     }
[17:42:57.589]                     oopts <- options(mc.cores = workers)
[17:42:57.589]                     on.exit(options(oopts))
[17:42:57.589]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:57.589]                       envir = envir)
[17:42:57.589]                     if (!future$lazy) 
[17:42:57.589]                       future <- run(future)
[17:42:57.589]                     invisible(future)
[17:42:57.589]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:57.589]                 }
[17:42:57.589]             }
[17:42:57.589]         }
[17:42:57.589]     })
[17:42:57.589]     if (TRUE) {
[17:42:57.589]         base::sink(type = "output", split = FALSE)
[17:42:57.589]         if (TRUE) {
[17:42:57.589]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:57.589]         }
[17:42:57.589]         else {
[17:42:57.589]             ...future.result["stdout"] <- base::list(NULL)
[17:42:57.589]         }
[17:42:57.589]         base::close(...future.stdout)
[17:42:57.589]         ...future.stdout <- NULL
[17:42:57.589]     }
[17:42:57.589]     ...future.result$conditions <- ...future.conditions
[17:42:57.589]     ...future.result$finished <- base::Sys.time()
[17:42:57.589]     ...future.result
[17:42:57.589] }
[17:42:57.591] plan(): Setting new future strategy stack:
[17:42:57.591] List of future strategies:
[17:42:57.591] 1. sequential:
[17:42:57.591]    - args: function (..., envir = parent.frame())
[17:42:57.591]    - tweaked: FALSE
[17:42:57.591]    - call: NULL
[17:42:57.592] plan(): nbrOfWorkers() = 1
[17:42:57.593] plan(): Setting new future strategy stack:
[17:42:57.593] List of future strategies:
[17:42:57.593] 1. multicore:
[17:42:57.593]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:57.593]    - tweaked: FALSE
[17:42:57.593]    - call: plan(multicore)
[17:42:57.596] plan(): nbrOfWorkers() = 1
[17:42:57.596] SequentialFuture started (and completed)
[17:42:57.597] signalConditions() ...
[17:42:57.597]  - include = ‘immediateCondition’
[17:42:57.597]  - exclude = 
[17:42:57.597]  - resignal = FALSE
[17:42:57.597]  - Number of conditions: 1
[17:42:57.597] signalConditions() ... done
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 0 bytes of class ‘NULL’
Conditions captured: [n=1] ‘simpleError’
Early signaling: FALSE
Owner process: 56280105-ab48-3cfb-51ca-f6f685381758
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:57.598] signalConditions() ...
[17:42:57.598]  - include = ‘immediateCondition’
[17:42:57.598]  - exclude = 
[17:42:57.598]  - resignal = FALSE
[17:42:57.598]  - Number of conditions: 1
[17:42:57.598] signalConditions() ... done
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[17:42:57.598] signalConditions() ...
[17:42:57.598]  - include = ‘immediateCondition’
[17:42:57.598]  - exclude = 
[17:42:57.599]  - resignal = FALSE
[17:42:57.599]  - Number of conditions: 1
[17:42:57.599] signalConditions() ... done
[17:42:57.599] Future state: ‘finished’
[17:42:57.599] signalConditions() ...
[17:42:57.599]  - include = ‘condition’
[17:42:57.599]  - exclude = ‘immediateCondition’
[17:42:57.599]  - resignal = TRUE
[17:42:57.599]  - Number of conditions: 1
[17:42:57.599]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:42:57.600] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[17:42:57.600] signalConditions() ...
[17:42:57.600]  - include = ‘immediateCondition’
[17:42:57.600]  - exclude = 
[17:42:57.600]  - resignal = FALSE
[17:42:57.600]  - Number of conditions: 1
[17:42:57.600] signalConditions() ... done
[17:42:57.601] Future state: ‘finished’
[17:42:57.601] signalConditions() ...
[17:42:57.601]  - include = ‘condition’
[17:42:57.601]  - exclude = ‘immediateCondition’
[17:42:57.601]  - resignal = TRUE
[17:42:57.601]  - Number of conditions: 1
[17:42:57.601]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:42:57.601] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[17:42:57.605] getGlobalsAndPackages() ...
[17:42:57.605] Searching for globals...
[17:42:57.606] - globals found: [5] ‘{’, ‘stop’, ‘structure’, ‘list’, ‘c’
[17:42:57.606] Searching for globals ... DONE
[17:42:57.607] Resolving globals: FALSE
[17:42:57.607] 
[17:42:57.607] 
[17:42:57.607] getGlobalsAndPackages() ... DONE
[17:42:57.608] Packages needed by the future expression (n = 0): <none>
[17:42:57.608] Packages needed by future strategies (n = 0): <none>
[17:42:57.608] {
[17:42:57.608]     {
[17:42:57.608]         {
[17:42:57.608]             ...future.startTime <- base::Sys.time()
[17:42:57.608]             {
[17:42:57.608]                 {
[17:42:57.608]                   {
[17:42:57.608]                     base::local({
[17:42:57.608]                       has_future <- base::requireNamespace("future", 
[17:42:57.608]                         quietly = TRUE)
[17:42:57.608]                       if (has_future) {
[17:42:57.608]                         ns <- base::getNamespace("future")
[17:42:57.608]                         version <- ns[[".package"]][["version"]]
[17:42:57.608]                         if (is.null(version)) 
[17:42:57.608]                           version <- utils::packageVersion("future")
[17:42:57.608]                       }
[17:42:57.608]                       else {
[17:42:57.608]                         version <- NULL
[17:42:57.608]                       }
[17:42:57.608]                       if (!has_future || version < "1.8.0") {
[17:42:57.608]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:57.608]                           "", base::R.version$version.string), 
[17:42:57.608]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:57.608]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:57.608]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:57.608]                             "release", "version")], collapse = " "), 
[17:42:57.608]                           hostname = base::Sys.info()[["nodename"]])
[17:42:57.608]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:57.608]                           info)
[17:42:57.608]                         info <- base::paste(info, collapse = "; ")
[17:42:57.608]                         if (!has_future) {
[17:42:57.608]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:57.608]                             info)
[17:42:57.608]                         }
[17:42:57.608]                         else {
[17:42:57.608]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:57.608]                             info, version)
[17:42:57.608]                         }
[17:42:57.608]                         base::stop(msg)
[17:42:57.608]                       }
[17:42:57.608]                     })
[17:42:57.608]                   }
[17:42:57.608]                   options(future.plan = NULL)
[17:42:57.608]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.608]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:57.608]                 }
[17:42:57.608]                 ...future.workdir <- getwd()
[17:42:57.608]             }
[17:42:57.608]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:57.608]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:57.608]         }
[17:42:57.608]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:57.608]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:57.608]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:57.608]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:57.608]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:57.608]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:57.608]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:57.608]             base::names(...future.oldOptions))
[17:42:57.608]     }
[17:42:57.608]     if (FALSE) {
[17:42:57.608]     }
[17:42:57.608]     else {
[17:42:57.608]         if (TRUE) {
[17:42:57.608]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:57.608]                 open = "w")
[17:42:57.608]         }
[17:42:57.608]         else {
[17:42:57.608]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:57.608]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:57.608]         }
[17:42:57.608]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:57.608]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:57.608]             base::sink(type = "output", split = FALSE)
[17:42:57.608]             base::close(...future.stdout)
[17:42:57.608]         }, add = TRUE)
[17:42:57.608]     }
[17:42:57.608]     ...future.frame <- base::sys.nframe()
[17:42:57.608]     ...future.conditions <- base::list()
[17:42:57.608]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:57.608]     if (FALSE) {
[17:42:57.608]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:57.608]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:57.608]     }
[17:42:57.608]     ...future.result <- base::tryCatch({
[17:42:57.608]         base::withCallingHandlers({
[17:42:57.608]             ...future.value <- base::withVisible(base::local({
[17:42:57.608]                 stop(structure(list(message = "boom"), class = c("MyError", 
[17:42:57.608]                   "error", "condition")))
[17:42:57.608]             }))
[17:42:57.608]             future::FutureResult(value = ...future.value$value, 
[17:42:57.608]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.608]                   ...future.rng), globalenv = if (FALSE) 
[17:42:57.608]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:57.608]                     ...future.globalenv.names))
[17:42:57.608]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:57.608]         }, condition = base::local({
[17:42:57.608]             c <- base::c
[17:42:57.608]             inherits <- base::inherits
[17:42:57.608]             invokeRestart <- base::invokeRestart
[17:42:57.608]             length <- base::length
[17:42:57.608]             list <- base::list
[17:42:57.608]             seq.int <- base::seq.int
[17:42:57.608]             signalCondition <- base::signalCondition
[17:42:57.608]             sys.calls <- base::sys.calls
[17:42:57.608]             `[[` <- base::`[[`
[17:42:57.608]             `+` <- base::`+`
[17:42:57.608]             `<<-` <- base::`<<-`
[17:42:57.608]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:57.608]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:57.608]                   3L)]
[17:42:57.608]             }
[17:42:57.608]             function(cond) {
[17:42:57.608]                 is_error <- inherits(cond, "error")
[17:42:57.608]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:57.608]                   NULL)
[17:42:57.608]                 if (is_error) {
[17:42:57.608]                   sessionInformation <- function() {
[17:42:57.608]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:57.608]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:57.608]                       search = base::search(), system = base::Sys.info())
[17:42:57.608]                   }
[17:42:57.608]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.608]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:57.608]                     cond$call), session = sessionInformation(), 
[17:42:57.608]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:57.608]                   signalCondition(cond)
[17:42:57.608]                 }
[17:42:57.608]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:57.608]                 "immediateCondition"))) {
[17:42:57.608]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:57.608]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.608]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:57.608]                   if (TRUE && !signal) {
[17:42:57.608]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.608]                     {
[17:42:57.608]                       inherits <- base::inherits
[17:42:57.608]                       invokeRestart <- base::invokeRestart
[17:42:57.608]                       is.null <- base::is.null
[17:42:57.608]                       muffled <- FALSE
[17:42:57.608]                       if (inherits(cond, "message")) {
[17:42:57.608]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.608]                         if (muffled) 
[17:42:57.608]                           invokeRestart("muffleMessage")
[17:42:57.608]                       }
[17:42:57.608]                       else if (inherits(cond, "warning")) {
[17:42:57.608]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.608]                         if (muffled) 
[17:42:57.608]                           invokeRestart("muffleWarning")
[17:42:57.608]                       }
[17:42:57.608]                       else if (inherits(cond, "condition")) {
[17:42:57.608]                         if (!is.null(pattern)) {
[17:42:57.608]                           computeRestarts <- base::computeRestarts
[17:42:57.608]                           grepl <- base::grepl
[17:42:57.608]                           restarts <- computeRestarts(cond)
[17:42:57.608]                           for (restart in restarts) {
[17:42:57.608]                             name <- restart$name
[17:42:57.608]                             if (is.null(name)) 
[17:42:57.608]                               next
[17:42:57.608]                             if (!grepl(pattern, name)) 
[17:42:57.608]                               next
[17:42:57.608]                             invokeRestart(restart)
[17:42:57.608]                             muffled <- TRUE
[17:42:57.608]                             break
[17:42:57.608]                           }
[17:42:57.608]                         }
[17:42:57.608]                       }
[17:42:57.608]                       invisible(muffled)
[17:42:57.608]                     }
[17:42:57.608]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.608]                   }
[17:42:57.608]                 }
[17:42:57.608]                 else {
[17:42:57.608]                   if (TRUE) {
[17:42:57.608]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.608]                     {
[17:42:57.608]                       inherits <- base::inherits
[17:42:57.608]                       invokeRestart <- base::invokeRestart
[17:42:57.608]                       is.null <- base::is.null
[17:42:57.608]                       muffled <- FALSE
[17:42:57.608]                       if (inherits(cond, "message")) {
[17:42:57.608]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.608]                         if (muffled) 
[17:42:57.608]                           invokeRestart("muffleMessage")
[17:42:57.608]                       }
[17:42:57.608]                       else if (inherits(cond, "warning")) {
[17:42:57.608]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.608]                         if (muffled) 
[17:42:57.608]                           invokeRestart("muffleWarning")
[17:42:57.608]                       }
[17:42:57.608]                       else if (inherits(cond, "condition")) {
[17:42:57.608]                         if (!is.null(pattern)) {
[17:42:57.608]                           computeRestarts <- base::computeRestarts
[17:42:57.608]                           grepl <- base::grepl
[17:42:57.608]                           restarts <- computeRestarts(cond)
[17:42:57.608]                           for (restart in restarts) {
[17:42:57.608]                             name <- restart$name
[17:42:57.608]                             if (is.null(name)) 
[17:42:57.608]                               next
[17:42:57.608]                             if (!grepl(pattern, name)) 
[17:42:57.608]                               next
[17:42:57.608]                             invokeRestart(restart)
[17:42:57.608]                             muffled <- TRUE
[17:42:57.608]                             break
[17:42:57.608]                           }
[17:42:57.608]                         }
[17:42:57.608]                       }
[17:42:57.608]                       invisible(muffled)
[17:42:57.608]                     }
[17:42:57.608]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.608]                   }
[17:42:57.608]                 }
[17:42:57.608]             }
[17:42:57.608]         }))
[17:42:57.608]     }, error = function(ex) {
[17:42:57.608]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:57.608]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.608]                 ...future.rng), started = ...future.startTime, 
[17:42:57.608]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:57.608]             version = "1.8"), class = "FutureResult")
[17:42:57.608]     }, finally = {
[17:42:57.608]         if (!identical(...future.workdir, getwd())) 
[17:42:57.608]             setwd(...future.workdir)
[17:42:57.608]         {
[17:42:57.608]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:57.608]                 ...future.oldOptions$nwarnings <- NULL
[17:42:57.608]             }
[17:42:57.608]             base::options(...future.oldOptions)
[17:42:57.608]             if (.Platform$OS.type == "windows") {
[17:42:57.608]                 old_names <- names(...future.oldEnvVars)
[17:42:57.608]                 envs <- base::Sys.getenv()
[17:42:57.608]                 names <- names(envs)
[17:42:57.608]                 common <- intersect(names, old_names)
[17:42:57.608]                 added <- setdiff(names, old_names)
[17:42:57.608]                 removed <- setdiff(old_names, names)
[17:42:57.608]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:57.608]                   envs[common]]
[17:42:57.608]                 NAMES <- toupper(changed)
[17:42:57.608]                 args <- list()
[17:42:57.608]                 for (kk in seq_along(NAMES)) {
[17:42:57.608]                   name <- changed[[kk]]
[17:42:57.608]                   NAME <- NAMES[[kk]]
[17:42:57.608]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.608]                     next
[17:42:57.608]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.608]                 }
[17:42:57.608]                 NAMES <- toupper(added)
[17:42:57.608]                 for (kk in seq_along(NAMES)) {
[17:42:57.608]                   name <- added[[kk]]
[17:42:57.608]                   NAME <- NAMES[[kk]]
[17:42:57.608]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.608]                     next
[17:42:57.608]                   args[[name]] <- ""
[17:42:57.608]                 }
[17:42:57.608]                 NAMES <- toupper(removed)
[17:42:57.608]                 for (kk in seq_along(NAMES)) {
[17:42:57.608]                   name <- removed[[kk]]
[17:42:57.608]                   NAME <- NAMES[[kk]]
[17:42:57.608]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.608]                     next
[17:42:57.608]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.608]                 }
[17:42:57.608]                 if (length(args) > 0) 
[17:42:57.608]                   base::do.call(base::Sys.setenv, args = args)
[17:42:57.608]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:57.608]             }
[17:42:57.608]             else {
[17:42:57.608]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:57.608]             }
[17:42:57.608]             {
[17:42:57.608]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:57.608]                   0L) {
[17:42:57.608]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:57.608]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:57.608]                   base::options(opts)
[17:42:57.608]                 }
[17:42:57.608]                 {
[17:42:57.608]                   {
[17:42:57.608]                     NULL
[17:42:57.608]                     RNGkind("Mersenne-Twister")
[17:42:57.608]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:57.608]                       inherits = FALSE)
[17:42:57.608]                   }
[17:42:57.608]                   options(future.plan = NULL)
[17:42:57.608]                   if (is.na(NA_character_)) 
[17:42:57.608]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.608]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:57.608]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:57.608]                     envir = parent.frame()) 
[17:42:57.608]                   {
[17:42:57.608]                     default_workers <- missing(workers)
[17:42:57.608]                     if (is.function(workers)) 
[17:42:57.608]                       workers <- workers()
[17:42:57.608]                     workers <- structure(as.integer(workers), 
[17:42:57.608]                       class = class(workers))
[17:42:57.608]                     stop_if_not(is.finite(workers), workers >= 
[17:42:57.608]                       1L)
[17:42:57.608]                     if ((workers == 1L && !inherits(workers, 
[17:42:57.608]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:57.608]                       if (default_workers) 
[17:42:57.608]                         supportsMulticore(warn = TRUE)
[17:42:57.608]                       return(sequential(..., envir = envir))
[17:42:57.608]                     }
[17:42:57.608]                     oopts <- options(mc.cores = workers)
[17:42:57.608]                     on.exit(options(oopts))
[17:42:57.608]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:57.608]                       envir = envir)
[17:42:57.608]                     if (!future$lazy) 
[17:42:57.608]                       future <- run(future)
[17:42:57.608]                     invisible(future)
[17:42:57.608]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:57.608]                 }
[17:42:57.608]             }
[17:42:57.608]         }
[17:42:57.608]     })
[17:42:57.608]     if (TRUE) {
[17:42:57.608]         base::sink(type = "output", split = FALSE)
[17:42:57.608]         if (TRUE) {
[17:42:57.608]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:57.608]         }
[17:42:57.608]         else {
[17:42:57.608]             ...future.result["stdout"] <- base::list(NULL)
[17:42:57.608]         }
[17:42:57.608]         base::close(...future.stdout)
[17:42:57.608]         ...future.stdout <- NULL
[17:42:57.608]     }
[17:42:57.608]     ...future.result$conditions <- ...future.conditions
[17:42:57.608]     ...future.result$finished <- base::Sys.time()
[17:42:57.608]     ...future.result
[17:42:57.608] }
[17:42:57.610] plan(): Setting new future strategy stack:
[17:42:57.610] List of future strategies:
[17:42:57.610] 1. sequential:
[17:42:57.610]    - args: function (..., envir = parent.frame())
[17:42:57.610]    - tweaked: FALSE
[17:42:57.610]    - call: NULL
[17:42:57.610] plan(): nbrOfWorkers() = 1
[17:42:57.611] plan(): Setting new future strategy stack:
[17:42:57.611] List of future strategies:
[17:42:57.611] 1. multicore:
[17:42:57.611]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:57.611]    - tweaked: FALSE
[17:42:57.611]    - call: plan(multicore)
[17:42:57.615] plan(): nbrOfWorkers() = 1
[17:42:57.615] SequentialFuture started (and completed)
[17:42:57.615] signalConditions() ...
[17:42:57.615]  - include = ‘immediateCondition’
[17:42:57.615]  - exclude = 
[17:42:57.615]  - resignal = FALSE
[17:42:57.616]  - Number of conditions: 1
[17:42:57.616] signalConditions() ... done
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 0 bytes of class ‘NULL’
Conditions captured: [n=1] ‘MyError’
Early signaling: FALSE
Owner process: 56280105-ab48-3cfb-51ca-f6f685381758
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:57.616] signalConditions() ...
[17:42:57.616]  - include = ‘immediateCondition’
[17:42:57.616]  - exclude = 
[17:42:57.616]  - resignal = FALSE
[17:42:57.617]  - Number of conditions: 1
[17:42:57.617] signalConditions() ... done
<MyError: boom>
[17:42:57.617] signalConditions() ...
[17:42:57.617]  - include = ‘immediateCondition’
[17:42:57.617]  - exclude = 
[17:42:57.617]  - resignal = FALSE
[17:42:57.617]  - Number of conditions: 1
[17:42:57.617] signalConditions() ... done
[17:42:57.617] Future state: ‘finished’
[17:42:57.618] signalConditions() ...
[17:42:57.618]  - include = ‘condition’
[17:42:57.618]  - exclude = ‘immediateCondition’
[17:42:57.618]  - resignal = TRUE
[17:42:57.618]  - Number of conditions: 1
[17:42:57.618]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[17:42:57.618] signalConditions() ... done
*** multicore(..., workers = 1L) ...
[17:42:57.618] getGlobalsAndPackages() ...
[17:42:57.619] Searching for globals...
[17:42:57.620] - globals found: [4] ‘{’, ‘*’, ‘a’, ‘b’
[17:42:57.620] Searching for globals ... DONE
[17:42:57.620] Resolving globals: FALSE
[17:42:57.620] The total size of the 2 globals is 112 bytes (112 bytes)
[17:42:57.621] The total size of the 2 globals exported for future expression (‘{; a * b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘b’ (56 bytes of class ‘numeric’)
[17:42:57.621] - globals: [2] ‘a’, ‘b’
[17:42:57.621] 
[17:42:57.621] getGlobalsAndPackages() ... DONE
[17:42:57.621] Packages needed by the future expression (n = 0): <none>
[17:42:57.621] Packages needed by future strategies (n = 0): <none>
[17:42:57.622] {
[17:42:57.622]     {
[17:42:57.622]         {
[17:42:57.622]             ...future.startTime <- base::Sys.time()
[17:42:57.622]             {
[17:42:57.622]                 {
[17:42:57.622]                   {
[17:42:57.622]                     base::local({
[17:42:57.622]                       has_future <- base::requireNamespace("future", 
[17:42:57.622]                         quietly = TRUE)
[17:42:57.622]                       if (has_future) {
[17:42:57.622]                         ns <- base::getNamespace("future")
[17:42:57.622]                         version <- ns[[".package"]][["version"]]
[17:42:57.622]                         if (is.null(version)) 
[17:42:57.622]                           version <- utils::packageVersion("future")
[17:42:57.622]                       }
[17:42:57.622]                       else {
[17:42:57.622]                         version <- NULL
[17:42:57.622]                       }
[17:42:57.622]                       if (!has_future || version < "1.8.0") {
[17:42:57.622]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:57.622]                           "", base::R.version$version.string), 
[17:42:57.622]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:57.622]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:57.622]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:57.622]                             "release", "version")], collapse = " "), 
[17:42:57.622]                           hostname = base::Sys.info()[["nodename"]])
[17:42:57.622]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:57.622]                           info)
[17:42:57.622]                         info <- base::paste(info, collapse = "; ")
[17:42:57.622]                         if (!has_future) {
[17:42:57.622]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:57.622]                             info)
[17:42:57.622]                         }
[17:42:57.622]                         else {
[17:42:57.622]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:57.622]                             info, version)
[17:42:57.622]                         }
[17:42:57.622]                         base::stop(msg)
[17:42:57.622]                       }
[17:42:57.622]                     })
[17:42:57.622]                   }
[17:42:57.622]                   options(future.plan = NULL)
[17:42:57.622]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.622]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:57.622]                 }
[17:42:57.622]                 ...future.workdir <- getwd()
[17:42:57.622]             }
[17:42:57.622]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:57.622]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:57.622]         }
[17:42:57.622]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:57.622]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:57.622]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:57.622]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:57.622]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:57.622]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:57.622]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:57.622]             base::names(...future.oldOptions))
[17:42:57.622]     }
[17:42:57.622]     if (FALSE) {
[17:42:57.622]     }
[17:42:57.622]     else {
[17:42:57.622]         if (TRUE) {
[17:42:57.622]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:57.622]                 open = "w")
[17:42:57.622]         }
[17:42:57.622]         else {
[17:42:57.622]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:57.622]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:57.622]         }
[17:42:57.622]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:57.622]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:57.622]             base::sink(type = "output", split = FALSE)
[17:42:57.622]             base::close(...future.stdout)
[17:42:57.622]         }, add = TRUE)
[17:42:57.622]     }
[17:42:57.622]     ...future.frame <- base::sys.nframe()
[17:42:57.622]     ...future.conditions <- base::list()
[17:42:57.622]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:57.622]     if (FALSE) {
[17:42:57.622]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:57.622]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:57.622]     }
[17:42:57.622]     ...future.result <- base::tryCatch({
[17:42:57.622]         base::withCallingHandlers({
[17:42:57.622]             ...future.value <- base::withVisible(base::local({
[17:42:57.622]                 a * b
[17:42:57.622]             }))
[17:42:57.622]             future::FutureResult(value = ...future.value$value, 
[17:42:57.622]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.622]                   ...future.rng), globalenv = if (FALSE) 
[17:42:57.622]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:57.622]                     ...future.globalenv.names))
[17:42:57.622]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:57.622]         }, condition = base::local({
[17:42:57.622]             c <- base::c
[17:42:57.622]             inherits <- base::inherits
[17:42:57.622]             invokeRestart <- base::invokeRestart
[17:42:57.622]             length <- base::length
[17:42:57.622]             list <- base::list
[17:42:57.622]             seq.int <- base::seq.int
[17:42:57.622]             signalCondition <- base::signalCondition
[17:42:57.622]             sys.calls <- base::sys.calls
[17:42:57.622]             `[[` <- base::`[[`
[17:42:57.622]             `+` <- base::`+`
[17:42:57.622]             `<<-` <- base::`<<-`
[17:42:57.622]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:57.622]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:57.622]                   3L)]
[17:42:57.622]             }
[17:42:57.622]             function(cond) {
[17:42:57.622]                 is_error <- inherits(cond, "error")
[17:42:57.622]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:57.622]                   NULL)
[17:42:57.622]                 if (is_error) {
[17:42:57.622]                   sessionInformation <- function() {
[17:42:57.622]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:57.622]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:57.622]                       search = base::search(), system = base::Sys.info())
[17:42:57.622]                   }
[17:42:57.622]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.622]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:57.622]                     cond$call), session = sessionInformation(), 
[17:42:57.622]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:57.622]                   signalCondition(cond)
[17:42:57.622]                 }
[17:42:57.622]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:57.622]                 "immediateCondition"))) {
[17:42:57.622]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:57.622]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.622]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:57.622]                   if (TRUE && !signal) {
[17:42:57.622]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.622]                     {
[17:42:57.622]                       inherits <- base::inherits
[17:42:57.622]                       invokeRestart <- base::invokeRestart
[17:42:57.622]                       is.null <- base::is.null
[17:42:57.622]                       muffled <- FALSE
[17:42:57.622]                       if (inherits(cond, "message")) {
[17:42:57.622]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.622]                         if (muffled) 
[17:42:57.622]                           invokeRestart("muffleMessage")
[17:42:57.622]                       }
[17:42:57.622]                       else if (inherits(cond, "warning")) {
[17:42:57.622]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.622]                         if (muffled) 
[17:42:57.622]                           invokeRestart("muffleWarning")
[17:42:57.622]                       }
[17:42:57.622]                       else if (inherits(cond, "condition")) {
[17:42:57.622]                         if (!is.null(pattern)) {
[17:42:57.622]                           computeRestarts <- base::computeRestarts
[17:42:57.622]                           grepl <- base::grepl
[17:42:57.622]                           restarts <- computeRestarts(cond)
[17:42:57.622]                           for (restart in restarts) {
[17:42:57.622]                             name <- restart$name
[17:42:57.622]                             if (is.null(name)) 
[17:42:57.622]                               next
[17:42:57.622]                             if (!grepl(pattern, name)) 
[17:42:57.622]                               next
[17:42:57.622]                             invokeRestart(restart)
[17:42:57.622]                             muffled <- TRUE
[17:42:57.622]                             break
[17:42:57.622]                           }
[17:42:57.622]                         }
[17:42:57.622]                       }
[17:42:57.622]                       invisible(muffled)
[17:42:57.622]                     }
[17:42:57.622]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.622]                   }
[17:42:57.622]                 }
[17:42:57.622]                 else {
[17:42:57.622]                   if (TRUE) {
[17:42:57.622]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.622]                     {
[17:42:57.622]                       inherits <- base::inherits
[17:42:57.622]                       invokeRestart <- base::invokeRestart
[17:42:57.622]                       is.null <- base::is.null
[17:42:57.622]                       muffled <- FALSE
[17:42:57.622]                       if (inherits(cond, "message")) {
[17:42:57.622]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.622]                         if (muffled) 
[17:42:57.622]                           invokeRestart("muffleMessage")
[17:42:57.622]                       }
[17:42:57.622]                       else if (inherits(cond, "warning")) {
[17:42:57.622]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.622]                         if (muffled) 
[17:42:57.622]                           invokeRestart("muffleWarning")
[17:42:57.622]                       }
[17:42:57.622]                       else if (inherits(cond, "condition")) {
[17:42:57.622]                         if (!is.null(pattern)) {
[17:42:57.622]                           computeRestarts <- base::computeRestarts
[17:42:57.622]                           grepl <- base::grepl
[17:42:57.622]                           restarts <- computeRestarts(cond)
[17:42:57.622]                           for (restart in restarts) {
[17:42:57.622]                             name <- restart$name
[17:42:57.622]                             if (is.null(name)) 
[17:42:57.622]                               next
[17:42:57.622]                             if (!grepl(pattern, name)) 
[17:42:57.622]                               next
[17:42:57.622]                             invokeRestart(restart)
[17:42:57.622]                             muffled <- TRUE
[17:42:57.622]                             break
[17:42:57.622]                           }
[17:42:57.622]                         }
[17:42:57.622]                       }
[17:42:57.622]                       invisible(muffled)
[17:42:57.622]                     }
[17:42:57.622]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.622]                   }
[17:42:57.622]                 }
[17:42:57.622]             }
[17:42:57.622]         }))
[17:42:57.622]     }, error = function(ex) {
[17:42:57.622]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:57.622]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.622]                 ...future.rng), started = ...future.startTime, 
[17:42:57.622]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:57.622]             version = "1.8"), class = "FutureResult")
[17:42:57.622]     }, finally = {
[17:42:57.622]         if (!identical(...future.workdir, getwd())) 
[17:42:57.622]             setwd(...future.workdir)
[17:42:57.622]         {
[17:42:57.622]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:57.622]                 ...future.oldOptions$nwarnings <- NULL
[17:42:57.622]             }
[17:42:57.622]             base::options(...future.oldOptions)
[17:42:57.622]             if (.Platform$OS.type == "windows") {
[17:42:57.622]                 old_names <- names(...future.oldEnvVars)
[17:42:57.622]                 envs <- base::Sys.getenv()
[17:42:57.622]                 names <- names(envs)
[17:42:57.622]                 common <- intersect(names, old_names)
[17:42:57.622]                 added <- setdiff(names, old_names)
[17:42:57.622]                 removed <- setdiff(old_names, names)
[17:42:57.622]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:57.622]                   envs[common]]
[17:42:57.622]                 NAMES <- toupper(changed)
[17:42:57.622]                 args <- list()
[17:42:57.622]                 for (kk in seq_along(NAMES)) {
[17:42:57.622]                   name <- changed[[kk]]
[17:42:57.622]                   NAME <- NAMES[[kk]]
[17:42:57.622]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.622]                     next
[17:42:57.622]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.622]                 }
[17:42:57.622]                 NAMES <- toupper(added)
[17:42:57.622]                 for (kk in seq_along(NAMES)) {
[17:42:57.622]                   name <- added[[kk]]
[17:42:57.622]                   NAME <- NAMES[[kk]]
[17:42:57.622]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.622]                     next
[17:42:57.622]                   args[[name]] <- ""
[17:42:57.622]                 }
[17:42:57.622]                 NAMES <- toupper(removed)
[17:42:57.622]                 for (kk in seq_along(NAMES)) {
[17:42:57.622]                   name <- removed[[kk]]
[17:42:57.622]                   NAME <- NAMES[[kk]]
[17:42:57.622]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.622]                     next
[17:42:57.622]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.622]                 }
[17:42:57.622]                 if (length(args) > 0) 
[17:42:57.622]                   base::do.call(base::Sys.setenv, args = args)
[17:42:57.622]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:57.622]             }
[17:42:57.622]             else {
[17:42:57.622]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:57.622]             }
[17:42:57.622]             {
[17:42:57.622]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:57.622]                   0L) {
[17:42:57.622]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:57.622]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:57.622]                   base::options(opts)
[17:42:57.622]                 }
[17:42:57.622]                 {
[17:42:57.622]                   {
[17:42:57.622]                     NULL
[17:42:57.622]                     RNGkind("Mersenne-Twister")
[17:42:57.622]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:57.622]                       inherits = FALSE)
[17:42:57.622]                   }
[17:42:57.622]                   options(future.plan = NULL)
[17:42:57.622]                   if (is.na(NA_character_)) 
[17:42:57.622]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.622]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:57.622]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:57.622]                     envir = parent.frame()) 
[17:42:57.622]                   {
[17:42:57.622]                     default_workers <- missing(workers)
[17:42:57.622]                     if (is.function(workers)) 
[17:42:57.622]                       workers <- workers()
[17:42:57.622]                     workers <- structure(as.integer(workers), 
[17:42:57.622]                       class = class(workers))
[17:42:57.622]                     stop_if_not(is.finite(workers), workers >= 
[17:42:57.622]                       1L)
[17:42:57.622]                     if ((workers == 1L && !inherits(workers, 
[17:42:57.622]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:57.622]                       if (default_workers) 
[17:42:57.622]                         supportsMulticore(warn = TRUE)
[17:42:57.622]                       return(sequential(..., envir = envir))
[17:42:57.622]                     }
[17:42:57.622]                     oopts <- options(mc.cores = workers)
[17:42:57.622]                     on.exit(options(oopts))
[17:42:57.622]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:57.622]                       envir = envir)
[17:42:57.622]                     if (!future$lazy) 
[17:42:57.622]                       future <- run(future)
[17:42:57.622]                     invisible(future)
[17:42:57.622]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:57.622]                 }
[17:42:57.622]             }
[17:42:57.622]         }
[17:42:57.622]     })
[17:42:57.622]     if (TRUE) {
[17:42:57.622]         base::sink(type = "output", split = FALSE)
[17:42:57.622]         if (TRUE) {
[17:42:57.622]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:57.622]         }
[17:42:57.622]         else {
[17:42:57.622]             ...future.result["stdout"] <- base::list(NULL)
[17:42:57.622]         }
[17:42:57.622]         base::close(...future.stdout)
[17:42:57.622]         ...future.stdout <- NULL
[17:42:57.622]     }
[17:42:57.622]     ...future.result$conditions <- ...future.conditions
[17:42:57.622]     ...future.result$finished <- base::Sys.time()
[17:42:57.622]     ...future.result
[17:42:57.622] }
[17:42:57.624] assign_globals() ...
[17:42:57.624] List of 2
[17:42:57.624]  $ a: num 2
[17:42:57.624]  $ b: num 3
[17:42:57.624]  - attr(*, "where")=List of 2
[17:42:57.624]   ..$ a:<environment: R_EmptyEnv> 
[17:42:57.624]   ..$ b:<environment: R_EmptyEnv> 
[17:42:57.624]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:57.624]  - attr(*, "resolved")= logi FALSE
[17:42:57.624]  - attr(*, "total_size")= num 112
[17:42:57.628] - copied ‘a’ to environment
[17:42:57.628] - copied ‘b’ to environment
[17:42:57.628] assign_globals() ... done
[17:42:57.629] plan(): Setting new future strategy stack:
[17:42:57.629] List of future strategies:
[17:42:57.629] 1. sequential:
[17:42:57.629]    - args: function (..., envir = parent.frame())
[17:42:57.629]    - tweaked: FALSE
[17:42:57.629]    - call: NULL
[17:42:57.629] plan(): nbrOfWorkers() = 1
[17:42:57.630] plan(): Setting new future strategy stack:
[17:42:57.630] List of future strategies:
[17:42:57.630] 1. multicore:
[17:42:57.630]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:57.630]    - tweaked: FALSE
[17:42:57.630]    - call: plan(multicore)
[17:42:57.633] plan(): nbrOfWorkers() = 1
[17:42:57.634] SequentialFuture started (and completed)
[1] 6
*** multicore(..., workers = 1L) ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
Number of workers: 2
*** multicore(..., globals = FALSE) without globals
[17:42:57.641] getGlobalsAndPackages() ...
[17:42:57.641] Not searching for globals
[17:42:57.641] - globals: [0] <none>
[17:42:57.641] getGlobalsAndPackages() ... DONE
[17:42:57.642] Packages needed by the future expression (n = 0): <none>
[17:42:57.642] Packages needed by future strategies (n = 0): <none>
[17:42:57.643] {
[17:42:57.643]     {
[17:42:57.643]         {
[17:42:57.643]             ...future.startTime <- base::Sys.time()
[17:42:57.643]             {
[17:42:57.643]                 {
[17:42:57.643]                   {
[17:42:57.643]                     {
[17:42:57.643]                       base::local({
[17:42:57.643]                         has_future <- base::requireNamespace("future", 
[17:42:57.643]                           quietly = TRUE)
[17:42:57.643]                         if (has_future) {
[17:42:57.643]                           ns <- base::getNamespace("future")
[17:42:57.643]                           version <- ns[[".package"]][["version"]]
[17:42:57.643]                           if (is.null(version)) 
[17:42:57.643]                             version <- utils::packageVersion("future")
[17:42:57.643]                         }
[17:42:57.643]                         else {
[17:42:57.643]                           version <- NULL
[17:42:57.643]                         }
[17:42:57.643]                         if (!has_future || version < "1.8.0") {
[17:42:57.643]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:57.643]                             "", base::R.version$version.string), 
[17:42:57.643]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:57.643]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:57.643]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:57.643]                               "release", "version")], collapse = " "), 
[17:42:57.643]                             hostname = base::Sys.info()[["nodename"]])
[17:42:57.643]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:57.643]                             info)
[17:42:57.643]                           info <- base::paste(info, collapse = "; ")
[17:42:57.643]                           if (!has_future) {
[17:42:57.643]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:57.643]                               info)
[17:42:57.643]                           }
[17:42:57.643]                           else {
[17:42:57.643]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:57.643]                               info, version)
[17:42:57.643]                           }
[17:42:57.643]                           base::stop(msg)
[17:42:57.643]                         }
[17:42:57.643]                       })
[17:42:57.643]                     }
[17:42:57.643]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:57.643]                     base::options(mc.cores = 1L)
[17:42:57.643]                   }
[17:42:57.643]                   options(future.plan = NULL)
[17:42:57.643]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.643]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:57.643]                 }
[17:42:57.643]                 ...future.workdir <- getwd()
[17:42:57.643]             }
[17:42:57.643]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:57.643]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:57.643]         }
[17:42:57.643]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:57.643]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:57.643]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:57.643]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:57.643]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:57.643]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:57.643]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:57.643]             base::names(...future.oldOptions))
[17:42:57.643]     }
[17:42:57.643]     if (FALSE) {
[17:42:57.643]     }
[17:42:57.643]     else {
[17:42:57.643]         if (TRUE) {
[17:42:57.643]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:57.643]                 open = "w")
[17:42:57.643]         }
[17:42:57.643]         else {
[17:42:57.643]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:57.643]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:57.643]         }
[17:42:57.643]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:57.643]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:57.643]             base::sink(type = "output", split = FALSE)
[17:42:57.643]             base::close(...future.stdout)
[17:42:57.643]         }, add = TRUE)
[17:42:57.643]     }
[17:42:57.643]     ...future.frame <- base::sys.nframe()
[17:42:57.643]     ...future.conditions <- base::list()
[17:42:57.643]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:57.643]     if (FALSE) {
[17:42:57.643]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:57.643]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:57.643]     }
[17:42:57.643]     ...future.result <- base::tryCatch({
[17:42:57.643]         base::withCallingHandlers({
[17:42:57.643]             ...future.value <- base::withVisible(base::local({
[17:42:57.643]                 withCallingHandlers({
[17:42:57.643]                   {
[17:42:57.643]                     42L
[17:42:57.643]                   }
[17:42:57.643]                 }, immediateCondition = function(cond) {
[17:42:57.643]                   save_rds <- function (object, pathname, ...) 
[17:42:57.643]                   {
[17:42:57.643]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:57.643]                     if (file_test("-f", pathname_tmp)) {
[17:42:57.643]                       fi_tmp <- file.info(pathname_tmp)
[17:42:57.643]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:57.643]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:57.643]                         fi_tmp[["mtime"]])
[17:42:57.643]                     }
[17:42:57.643]                     tryCatch({
[17:42:57.643]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:57.643]                     }, error = function(ex) {
[17:42:57.643]                       msg <- conditionMessage(ex)
[17:42:57.643]                       fi_tmp <- file.info(pathname_tmp)
[17:42:57.643]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:57.643]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:57.643]                         fi_tmp[["mtime"]], msg)
[17:42:57.643]                       ex$message <- msg
[17:42:57.643]                       stop(ex)
[17:42:57.643]                     })
[17:42:57.643]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:57.643]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:57.643]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:57.643]                       fi_tmp <- file.info(pathname_tmp)
[17:42:57.643]                       fi <- file.info(pathname)
[17:42:57.643]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:57.643]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:57.643]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:57.643]                         fi[["size"]], fi[["mtime"]])
[17:42:57.643]                       stop(msg)
[17:42:57.643]                     }
[17:42:57.643]                     invisible(pathname)
[17:42:57.643]                   }
[17:42:57.643]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:57.643]                     rootPath = tempdir()) 
[17:42:57.643]                   {
[17:42:57.643]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:57.643]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:57.643]                       tmpdir = path, fileext = ".rds")
[17:42:57.643]                     save_rds(obj, file)
[17:42:57.643]                   }
[17:42:57.643]                   saveImmediateCondition(cond, path = "/tmp/Rtmpie37tE/.future/immediateConditions")
[17:42:57.643]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.643]                   {
[17:42:57.643]                     inherits <- base::inherits
[17:42:57.643]                     invokeRestart <- base::invokeRestart
[17:42:57.643]                     is.null <- base::is.null
[17:42:57.643]                     muffled <- FALSE
[17:42:57.643]                     if (inherits(cond, "message")) {
[17:42:57.643]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:57.643]                       if (muffled) 
[17:42:57.643]                         invokeRestart("muffleMessage")
[17:42:57.643]                     }
[17:42:57.643]                     else if (inherits(cond, "warning")) {
[17:42:57.643]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:57.643]                       if (muffled) 
[17:42:57.643]                         invokeRestart("muffleWarning")
[17:42:57.643]                     }
[17:42:57.643]                     else if (inherits(cond, "condition")) {
[17:42:57.643]                       if (!is.null(pattern)) {
[17:42:57.643]                         computeRestarts <- base::computeRestarts
[17:42:57.643]                         grepl <- base::grepl
[17:42:57.643]                         restarts <- computeRestarts(cond)
[17:42:57.643]                         for (restart in restarts) {
[17:42:57.643]                           name <- restart$name
[17:42:57.643]                           if (is.null(name)) 
[17:42:57.643]                             next
[17:42:57.643]                           if (!grepl(pattern, name)) 
[17:42:57.643]                             next
[17:42:57.643]                           invokeRestart(restart)
[17:42:57.643]                           muffled <- TRUE
[17:42:57.643]                           break
[17:42:57.643]                         }
[17:42:57.643]                       }
[17:42:57.643]                     }
[17:42:57.643]                     invisible(muffled)
[17:42:57.643]                   }
[17:42:57.643]                   muffleCondition(cond)
[17:42:57.643]                 })
[17:42:57.643]             }))
[17:42:57.643]             future::FutureResult(value = ...future.value$value, 
[17:42:57.643]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.643]                   ...future.rng), globalenv = if (FALSE) 
[17:42:57.643]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:57.643]                     ...future.globalenv.names))
[17:42:57.643]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:57.643]         }, condition = base::local({
[17:42:57.643]             c <- base::c
[17:42:57.643]             inherits <- base::inherits
[17:42:57.643]             invokeRestart <- base::invokeRestart
[17:42:57.643]             length <- base::length
[17:42:57.643]             list <- base::list
[17:42:57.643]             seq.int <- base::seq.int
[17:42:57.643]             signalCondition <- base::signalCondition
[17:42:57.643]             sys.calls <- base::sys.calls
[17:42:57.643]             `[[` <- base::`[[`
[17:42:57.643]             `+` <- base::`+`
[17:42:57.643]             `<<-` <- base::`<<-`
[17:42:57.643]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:57.643]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:57.643]                   3L)]
[17:42:57.643]             }
[17:42:57.643]             function(cond) {
[17:42:57.643]                 is_error <- inherits(cond, "error")
[17:42:57.643]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:57.643]                   NULL)
[17:42:57.643]                 if (is_error) {
[17:42:57.643]                   sessionInformation <- function() {
[17:42:57.643]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:57.643]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:57.643]                       search = base::search(), system = base::Sys.info())
[17:42:57.643]                   }
[17:42:57.643]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.643]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:57.643]                     cond$call), session = sessionInformation(), 
[17:42:57.643]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:57.643]                   signalCondition(cond)
[17:42:57.643]                 }
[17:42:57.643]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:57.643]                 "immediateCondition"))) {
[17:42:57.643]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:57.643]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.643]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:57.643]                   if (TRUE && !signal) {
[17:42:57.643]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.643]                     {
[17:42:57.643]                       inherits <- base::inherits
[17:42:57.643]                       invokeRestart <- base::invokeRestart
[17:42:57.643]                       is.null <- base::is.null
[17:42:57.643]                       muffled <- FALSE
[17:42:57.643]                       if (inherits(cond, "message")) {
[17:42:57.643]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.643]                         if (muffled) 
[17:42:57.643]                           invokeRestart("muffleMessage")
[17:42:57.643]                       }
[17:42:57.643]                       else if (inherits(cond, "warning")) {
[17:42:57.643]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.643]                         if (muffled) 
[17:42:57.643]                           invokeRestart("muffleWarning")
[17:42:57.643]                       }
[17:42:57.643]                       else if (inherits(cond, "condition")) {
[17:42:57.643]                         if (!is.null(pattern)) {
[17:42:57.643]                           computeRestarts <- base::computeRestarts
[17:42:57.643]                           grepl <- base::grepl
[17:42:57.643]                           restarts <- computeRestarts(cond)
[17:42:57.643]                           for (restart in restarts) {
[17:42:57.643]                             name <- restart$name
[17:42:57.643]                             if (is.null(name)) 
[17:42:57.643]                               next
[17:42:57.643]                             if (!grepl(pattern, name)) 
[17:42:57.643]                               next
[17:42:57.643]                             invokeRestart(restart)
[17:42:57.643]                             muffled <- TRUE
[17:42:57.643]                             break
[17:42:57.643]                           }
[17:42:57.643]                         }
[17:42:57.643]                       }
[17:42:57.643]                       invisible(muffled)
[17:42:57.643]                     }
[17:42:57.643]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.643]                   }
[17:42:57.643]                 }
[17:42:57.643]                 else {
[17:42:57.643]                   if (TRUE) {
[17:42:57.643]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.643]                     {
[17:42:57.643]                       inherits <- base::inherits
[17:42:57.643]                       invokeRestart <- base::invokeRestart
[17:42:57.643]                       is.null <- base::is.null
[17:42:57.643]                       muffled <- FALSE
[17:42:57.643]                       if (inherits(cond, "message")) {
[17:42:57.643]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.643]                         if (muffled) 
[17:42:57.643]                           invokeRestart("muffleMessage")
[17:42:57.643]                       }
[17:42:57.643]                       else if (inherits(cond, "warning")) {
[17:42:57.643]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.643]                         if (muffled) 
[17:42:57.643]                           invokeRestart("muffleWarning")
[17:42:57.643]                       }
[17:42:57.643]                       else if (inherits(cond, "condition")) {
[17:42:57.643]                         if (!is.null(pattern)) {
[17:42:57.643]                           computeRestarts <- base::computeRestarts
[17:42:57.643]                           grepl <- base::grepl
[17:42:57.643]                           restarts <- computeRestarts(cond)
[17:42:57.643]                           for (restart in restarts) {
[17:42:57.643]                             name <- restart$name
[17:42:57.643]                             if (is.null(name)) 
[17:42:57.643]                               next
[17:42:57.643]                             if (!grepl(pattern, name)) 
[17:42:57.643]                               next
[17:42:57.643]                             invokeRestart(restart)
[17:42:57.643]                             muffled <- TRUE
[17:42:57.643]                             break
[17:42:57.643]                           }
[17:42:57.643]                         }
[17:42:57.643]                       }
[17:42:57.643]                       invisible(muffled)
[17:42:57.643]                     }
[17:42:57.643]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.643]                   }
[17:42:57.643]                 }
[17:42:57.643]             }
[17:42:57.643]         }))
[17:42:57.643]     }, error = function(ex) {
[17:42:57.643]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:57.643]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.643]                 ...future.rng), started = ...future.startTime, 
[17:42:57.643]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:57.643]             version = "1.8"), class = "FutureResult")
[17:42:57.643]     }, finally = {
[17:42:57.643]         if (!identical(...future.workdir, getwd())) 
[17:42:57.643]             setwd(...future.workdir)
[17:42:57.643]         {
[17:42:57.643]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:57.643]                 ...future.oldOptions$nwarnings <- NULL
[17:42:57.643]             }
[17:42:57.643]             base::options(...future.oldOptions)
[17:42:57.643]             if (.Platform$OS.type == "windows") {
[17:42:57.643]                 old_names <- names(...future.oldEnvVars)
[17:42:57.643]                 envs <- base::Sys.getenv()
[17:42:57.643]                 names <- names(envs)
[17:42:57.643]                 common <- intersect(names, old_names)
[17:42:57.643]                 added <- setdiff(names, old_names)
[17:42:57.643]                 removed <- setdiff(old_names, names)
[17:42:57.643]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:57.643]                   envs[common]]
[17:42:57.643]                 NAMES <- toupper(changed)
[17:42:57.643]                 args <- list()
[17:42:57.643]                 for (kk in seq_along(NAMES)) {
[17:42:57.643]                   name <- changed[[kk]]
[17:42:57.643]                   NAME <- NAMES[[kk]]
[17:42:57.643]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.643]                     next
[17:42:57.643]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.643]                 }
[17:42:57.643]                 NAMES <- toupper(added)
[17:42:57.643]                 for (kk in seq_along(NAMES)) {
[17:42:57.643]                   name <- added[[kk]]
[17:42:57.643]                   NAME <- NAMES[[kk]]
[17:42:57.643]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.643]                     next
[17:42:57.643]                   args[[name]] <- ""
[17:42:57.643]                 }
[17:42:57.643]                 NAMES <- toupper(removed)
[17:42:57.643]                 for (kk in seq_along(NAMES)) {
[17:42:57.643]                   name <- removed[[kk]]
[17:42:57.643]                   NAME <- NAMES[[kk]]
[17:42:57.643]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.643]                     next
[17:42:57.643]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.643]                 }
[17:42:57.643]                 if (length(args) > 0) 
[17:42:57.643]                   base::do.call(base::Sys.setenv, args = args)
[17:42:57.643]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:57.643]             }
[17:42:57.643]             else {
[17:42:57.643]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:57.643]             }
[17:42:57.643]             {
[17:42:57.643]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:57.643]                   0L) {
[17:42:57.643]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:57.643]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:57.643]                   base::options(opts)
[17:42:57.643]                 }
[17:42:57.643]                 {
[17:42:57.643]                   {
[17:42:57.643]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:57.643]                     NULL
[17:42:57.643]                   }
[17:42:57.643]                   options(future.plan = NULL)
[17:42:57.643]                   if (is.na(NA_character_)) 
[17:42:57.643]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.643]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:57.643]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:57.643]                     envir = parent.frame()) 
[17:42:57.643]                   {
[17:42:57.643]                     default_workers <- missing(workers)
[17:42:57.643]                     if (is.function(workers)) 
[17:42:57.643]                       workers <- workers()
[17:42:57.643]                     workers <- structure(as.integer(workers), 
[17:42:57.643]                       class = class(workers))
[17:42:57.643]                     stop_if_not(is.finite(workers), workers >= 
[17:42:57.643]                       1L)
[17:42:57.643]                     if ((workers == 1L && !inherits(workers, 
[17:42:57.643]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:57.643]                       if (default_workers) 
[17:42:57.643]                         supportsMulticore(warn = TRUE)
[17:42:57.643]                       return(sequential(..., envir = envir))
[17:42:57.643]                     }
[17:42:57.643]                     oopts <- options(mc.cores = workers)
[17:42:57.643]                     on.exit(options(oopts))
[17:42:57.643]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:57.643]                       envir = envir)
[17:42:57.643]                     if (!future$lazy) 
[17:42:57.643]                       future <- run(future)
[17:42:57.643]                     invisible(future)
[17:42:57.643]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:57.643]                 }
[17:42:57.643]             }
[17:42:57.643]         }
[17:42:57.643]     })
[17:42:57.643]     if (TRUE) {
[17:42:57.643]         base::sink(type = "output", split = FALSE)
[17:42:57.643]         if (TRUE) {
[17:42:57.643]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:57.643]         }
[17:42:57.643]         else {
[17:42:57.643]             ...future.result["stdout"] <- base::list(NULL)
[17:42:57.643]         }
[17:42:57.643]         base::close(...future.stdout)
[17:42:57.643]         ...future.stdout <- NULL
[17:42:57.643]     }
[17:42:57.643]     ...future.result$conditions <- ...future.conditions
[17:42:57.643]     ...future.result$finished <- base::Sys.time()
[17:42:57.643]     ...future.result
[17:42:57.643] }
[17:42:57.645] requestCore(): workers = 2
[17:42:57.648] MulticoreFuture started
[17:42:57.649] plan(): Setting new future strategy stack:
[17:42:57.649] List of future strategies:
[17:42:57.649] 1. sequential:
[17:42:57.649]    - args: function (..., envir = parent.frame())
[17:42:57.649]    - tweaked: FALSE
[17:42:57.649]    - call: NULL
[17:42:57.650] plan(): nbrOfWorkers() = 1
[17:42:57.652] plan(): Setting new future strategy stack:
[17:42:57.652] List of future strategies:
[17:42:57.652] 1. multicore:
[17:42:57.652]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:57.652]    - tweaked: FALSE
[17:42:57.652]    - call: plan(multicore)
[17:42:57.657] plan(): nbrOfWorkers() = 2
[1] TRUE
[1] 42
*** multicore(..., globals = FALSE) with globals
[17:42:57.667] getGlobalsAndPackages() ...
[17:42:57.667] Not searching for globals
[17:42:57.668] - globals: [0] <none>
[17:42:57.668] getGlobalsAndPackages() ... DONE
[17:42:57.668] Packages needed by the future expression (n = 0): <none>
[17:42:57.668] Packages needed by future strategies (n = 0): <none>
[17:42:57.669] {
[17:42:57.669]     {
[17:42:57.669]         {
[17:42:57.669]             ...future.startTime <- base::Sys.time()
[17:42:57.669]             {
[17:42:57.669]                 {
[17:42:57.669]                   {
[17:42:57.669]                     {
[17:42:57.669]                       base::local({
[17:42:57.669]                         has_future <- base::requireNamespace("future", 
[17:42:57.669]                           quietly = TRUE)
[17:42:57.669]                         if (has_future) {
[17:42:57.669]                           ns <- base::getNamespace("future")
[17:42:57.669]                           version <- ns[[".package"]][["version"]]
[17:42:57.669]                           if (is.null(version)) 
[17:42:57.669]                             version <- utils::packageVersion("future")
[17:42:57.669]                         }
[17:42:57.669]                         else {
[17:42:57.669]                           version <- NULL
[17:42:57.669]                         }
[17:42:57.669]                         if (!has_future || version < "1.8.0") {
[17:42:57.669]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:57.669]                             "", base::R.version$version.string), 
[17:42:57.669]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:57.669]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:57.669]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:57.669]                               "release", "version")], collapse = " "), 
[17:42:57.669]                             hostname = base::Sys.info()[["nodename"]])
[17:42:57.669]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:57.669]                             info)
[17:42:57.669]                           info <- base::paste(info, collapse = "; ")
[17:42:57.669]                           if (!has_future) {
[17:42:57.669]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:57.669]                               info)
[17:42:57.669]                           }
[17:42:57.669]                           else {
[17:42:57.669]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:57.669]                               info, version)
[17:42:57.669]                           }
[17:42:57.669]                           base::stop(msg)
[17:42:57.669]                         }
[17:42:57.669]                       })
[17:42:57.669]                     }
[17:42:57.669]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:57.669]                     base::options(mc.cores = 1L)
[17:42:57.669]                   }
[17:42:57.669]                   options(future.plan = NULL)
[17:42:57.669]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.669]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:57.669]                 }
[17:42:57.669]                 ...future.workdir <- getwd()
[17:42:57.669]             }
[17:42:57.669]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:57.669]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:57.669]         }
[17:42:57.669]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:57.669]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:57.669]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:57.669]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:57.669]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:57.669]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:57.669]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:57.669]             base::names(...future.oldOptions))
[17:42:57.669]     }
[17:42:57.669]     if (FALSE) {
[17:42:57.669]     }
[17:42:57.669]     else {
[17:42:57.669]         if (TRUE) {
[17:42:57.669]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:57.669]                 open = "w")
[17:42:57.669]         }
[17:42:57.669]         else {
[17:42:57.669]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:57.669]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:57.669]         }
[17:42:57.669]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:57.669]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:57.669]             base::sink(type = "output", split = FALSE)
[17:42:57.669]             base::close(...future.stdout)
[17:42:57.669]         }, add = TRUE)
[17:42:57.669]     }
[17:42:57.669]     ...future.frame <- base::sys.nframe()
[17:42:57.669]     ...future.conditions <- base::list()
[17:42:57.669]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:57.669]     if (FALSE) {
[17:42:57.669]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:57.669]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:57.669]     }
[17:42:57.669]     ...future.result <- base::tryCatch({
[17:42:57.669]         base::withCallingHandlers({
[17:42:57.669]             ...future.value <- base::withVisible(base::local({
[17:42:57.669]                 withCallingHandlers({
[17:42:57.669]                   {
[17:42:57.669]                     b <- 3
[17:42:57.669]                     c <- 2
[17:42:57.669]                     a * b * c
[17:42:57.669]                   }
[17:42:57.669]                 }, immediateCondition = function(cond) {
[17:42:57.669]                   save_rds <- function (object, pathname, ...) 
[17:42:57.669]                   {
[17:42:57.669]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:57.669]                     if (file_test("-f", pathname_tmp)) {
[17:42:57.669]                       fi_tmp <- file.info(pathname_tmp)
[17:42:57.669]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:57.669]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:57.669]                         fi_tmp[["mtime"]])
[17:42:57.669]                     }
[17:42:57.669]                     tryCatch({
[17:42:57.669]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:57.669]                     }, error = function(ex) {
[17:42:57.669]                       msg <- conditionMessage(ex)
[17:42:57.669]                       fi_tmp <- file.info(pathname_tmp)
[17:42:57.669]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:57.669]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:57.669]                         fi_tmp[["mtime"]], msg)
[17:42:57.669]                       ex$message <- msg
[17:42:57.669]                       stop(ex)
[17:42:57.669]                     })
[17:42:57.669]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:57.669]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:57.669]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:57.669]                       fi_tmp <- file.info(pathname_tmp)
[17:42:57.669]                       fi <- file.info(pathname)
[17:42:57.669]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:57.669]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:57.669]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:57.669]                         fi[["size"]], fi[["mtime"]])
[17:42:57.669]                       stop(msg)
[17:42:57.669]                     }
[17:42:57.669]                     invisible(pathname)
[17:42:57.669]                   }
[17:42:57.669]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:57.669]                     rootPath = tempdir()) 
[17:42:57.669]                   {
[17:42:57.669]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:57.669]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:57.669]                       tmpdir = path, fileext = ".rds")
[17:42:57.669]                     save_rds(obj, file)
[17:42:57.669]                   }
[17:42:57.669]                   saveImmediateCondition(cond, path = "/tmp/Rtmpie37tE/.future/immediateConditions")
[17:42:57.669]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.669]                   {
[17:42:57.669]                     inherits <- base::inherits
[17:42:57.669]                     invokeRestart <- base::invokeRestart
[17:42:57.669]                     is.null <- base::is.null
[17:42:57.669]                     muffled <- FALSE
[17:42:57.669]                     if (inherits(cond, "message")) {
[17:42:57.669]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:57.669]                       if (muffled) 
[17:42:57.669]                         invokeRestart("muffleMessage")
[17:42:57.669]                     }
[17:42:57.669]                     else if (inherits(cond, "warning")) {
[17:42:57.669]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:57.669]                       if (muffled) 
[17:42:57.669]                         invokeRestart("muffleWarning")
[17:42:57.669]                     }
[17:42:57.669]                     else if (inherits(cond, "condition")) {
[17:42:57.669]                       if (!is.null(pattern)) {
[17:42:57.669]                         computeRestarts <- base::computeRestarts
[17:42:57.669]                         grepl <- base::grepl
[17:42:57.669]                         restarts <- computeRestarts(cond)
[17:42:57.669]                         for (restart in restarts) {
[17:42:57.669]                           name <- restart$name
[17:42:57.669]                           if (is.null(name)) 
[17:42:57.669]                             next
[17:42:57.669]                           if (!grepl(pattern, name)) 
[17:42:57.669]                             next
[17:42:57.669]                           invokeRestart(restart)
[17:42:57.669]                           muffled <- TRUE
[17:42:57.669]                           break
[17:42:57.669]                         }
[17:42:57.669]                       }
[17:42:57.669]                     }
[17:42:57.669]                     invisible(muffled)
[17:42:57.669]                   }
[17:42:57.669]                   muffleCondition(cond)
[17:42:57.669]                 })
[17:42:57.669]             }))
[17:42:57.669]             future::FutureResult(value = ...future.value$value, 
[17:42:57.669]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.669]                   ...future.rng), globalenv = if (FALSE) 
[17:42:57.669]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:57.669]                     ...future.globalenv.names))
[17:42:57.669]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:57.669]         }, condition = base::local({
[17:42:57.669]             c <- base::c
[17:42:57.669]             inherits <- base::inherits
[17:42:57.669]             invokeRestart <- base::invokeRestart
[17:42:57.669]             length <- base::length
[17:42:57.669]             list <- base::list
[17:42:57.669]             seq.int <- base::seq.int
[17:42:57.669]             signalCondition <- base::signalCondition
[17:42:57.669]             sys.calls <- base::sys.calls
[17:42:57.669]             `[[` <- base::`[[`
[17:42:57.669]             `+` <- base::`+`
[17:42:57.669]             `<<-` <- base::`<<-`
[17:42:57.669]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:57.669]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:57.669]                   3L)]
[17:42:57.669]             }
[17:42:57.669]             function(cond) {
[17:42:57.669]                 is_error <- inherits(cond, "error")
[17:42:57.669]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:57.669]                   NULL)
[17:42:57.669]                 if (is_error) {
[17:42:57.669]                   sessionInformation <- function() {
[17:42:57.669]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:57.669]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:57.669]                       search = base::search(), system = base::Sys.info())
[17:42:57.669]                   }
[17:42:57.669]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.669]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:57.669]                     cond$call), session = sessionInformation(), 
[17:42:57.669]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:57.669]                   signalCondition(cond)
[17:42:57.669]                 }
[17:42:57.669]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:57.669]                 "immediateCondition"))) {
[17:42:57.669]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:57.669]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.669]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:57.669]                   if (TRUE && !signal) {
[17:42:57.669]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.669]                     {
[17:42:57.669]                       inherits <- base::inherits
[17:42:57.669]                       invokeRestart <- base::invokeRestart
[17:42:57.669]                       is.null <- base::is.null
[17:42:57.669]                       muffled <- FALSE
[17:42:57.669]                       if (inherits(cond, "message")) {
[17:42:57.669]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.669]                         if (muffled) 
[17:42:57.669]                           invokeRestart("muffleMessage")
[17:42:57.669]                       }
[17:42:57.669]                       else if (inherits(cond, "warning")) {
[17:42:57.669]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.669]                         if (muffled) 
[17:42:57.669]                           invokeRestart("muffleWarning")
[17:42:57.669]                       }
[17:42:57.669]                       else if (inherits(cond, "condition")) {
[17:42:57.669]                         if (!is.null(pattern)) {
[17:42:57.669]                           computeRestarts <- base::computeRestarts
[17:42:57.669]                           grepl <- base::grepl
[17:42:57.669]                           restarts <- computeRestarts(cond)
[17:42:57.669]                           for (restart in restarts) {
[17:42:57.669]                             name <- restart$name
[17:42:57.669]                             if (is.null(name)) 
[17:42:57.669]                               next
[17:42:57.669]                             if (!grepl(pattern, name)) 
[17:42:57.669]                               next
[17:42:57.669]                             invokeRestart(restart)
[17:42:57.669]                             muffled <- TRUE
[17:42:57.669]                             break
[17:42:57.669]                           }
[17:42:57.669]                         }
[17:42:57.669]                       }
[17:42:57.669]                       invisible(muffled)
[17:42:57.669]                     }
[17:42:57.669]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.669]                   }
[17:42:57.669]                 }
[17:42:57.669]                 else {
[17:42:57.669]                   if (TRUE) {
[17:42:57.669]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.669]                     {
[17:42:57.669]                       inherits <- base::inherits
[17:42:57.669]                       invokeRestart <- base::invokeRestart
[17:42:57.669]                       is.null <- base::is.null
[17:42:57.669]                       muffled <- FALSE
[17:42:57.669]                       if (inherits(cond, "message")) {
[17:42:57.669]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.669]                         if (muffled) 
[17:42:57.669]                           invokeRestart("muffleMessage")
[17:42:57.669]                       }
[17:42:57.669]                       else if (inherits(cond, "warning")) {
[17:42:57.669]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.669]                         if (muffled) 
[17:42:57.669]                           invokeRestart("muffleWarning")
[17:42:57.669]                       }
[17:42:57.669]                       else if (inherits(cond, "condition")) {
[17:42:57.669]                         if (!is.null(pattern)) {
[17:42:57.669]                           computeRestarts <- base::computeRestarts
[17:42:57.669]                           grepl <- base::grepl
[17:42:57.669]                           restarts <- computeRestarts(cond)
[17:42:57.669]                           for (restart in restarts) {
[17:42:57.669]                             name <- restart$name
[17:42:57.669]                             if (is.null(name)) 
[17:42:57.669]                               next
[17:42:57.669]                             if (!grepl(pattern, name)) 
[17:42:57.669]                               next
[17:42:57.669]                             invokeRestart(restart)
[17:42:57.669]                             muffled <- TRUE
[17:42:57.669]                             break
[17:42:57.669]                           }
[17:42:57.669]                         }
[17:42:57.669]                       }
[17:42:57.669]                       invisible(muffled)
[17:42:57.669]                     }
[17:42:57.669]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.669]                   }
[17:42:57.669]                 }
[17:42:57.669]             }
[17:42:57.669]         }))
[17:42:57.669]     }, error = function(ex) {
[17:42:57.669]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:57.669]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.669]                 ...future.rng), started = ...future.startTime, 
[17:42:57.669]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:57.669]             version = "1.8"), class = "FutureResult")
[17:42:57.669]     }, finally = {
[17:42:57.669]         if (!identical(...future.workdir, getwd())) 
[17:42:57.669]             setwd(...future.workdir)
[17:42:57.669]         {
[17:42:57.669]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:57.669]                 ...future.oldOptions$nwarnings <- NULL
[17:42:57.669]             }
[17:42:57.669]             base::options(...future.oldOptions)
[17:42:57.669]             if (.Platform$OS.type == "windows") {
[17:42:57.669]                 old_names <- names(...future.oldEnvVars)
[17:42:57.669]                 envs <- base::Sys.getenv()
[17:42:57.669]                 names <- names(envs)
[17:42:57.669]                 common <- intersect(names, old_names)
[17:42:57.669]                 added <- setdiff(names, old_names)
[17:42:57.669]                 removed <- setdiff(old_names, names)
[17:42:57.669]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:57.669]                   envs[common]]
[17:42:57.669]                 NAMES <- toupper(changed)
[17:42:57.669]                 args <- list()
[17:42:57.669]                 for (kk in seq_along(NAMES)) {
[17:42:57.669]                   name <- changed[[kk]]
[17:42:57.669]                   NAME <- NAMES[[kk]]
[17:42:57.669]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.669]                     next
[17:42:57.669]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.669]                 }
[17:42:57.669]                 NAMES <- toupper(added)
[17:42:57.669]                 for (kk in seq_along(NAMES)) {
[17:42:57.669]                   name <- added[[kk]]
[17:42:57.669]                   NAME <- NAMES[[kk]]
[17:42:57.669]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.669]                     next
[17:42:57.669]                   args[[name]] <- ""
[17:42:57.669]                 }
[17:42:57.669]                 NAMES <- toupper(removed)
[17:42:57.669]                 for (kk in seq_along(NAMES)) {
[17:42:57.669]                   name <- removed[[kk]]
[17:42:57.669]                   NAME <- NAMES[[kk]]
[17:42:57.669]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.669]                     next
[17:42:57.669]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.669]                 }
[17:42:57.669]                 if (length(args) > 0) 
[17:42:57.669]                   base::do.call(base::Sys.setenv, args = args)
[17:42:57.669]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:57.669]             }
[17:42:57.669]             else {
[17:42:57.669]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:57.669]             }
[17:42:57.669]             {
[17:42:57.669]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:57.669]                   0L) {
[17:42:57.669]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:57.669]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:57.669]                   base::options(opts)
[17:42:57.669]                 }
[17:42:57.669]                 {
[17:42:57.669]                   {
[17:42:57.669]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:57.669]                     NULL
[17:42:57.669]                   }
[17:42:57.669]                   options(future.plan = NULL)
[17:42:57.669]                   if (is.na(NA_character_)) 
[17:42:57.669]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.669]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:57.669]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:57.669]                     envir = parent.frame()) 
[17:42:57.669]                   {
[17:42:57.669]                     default_workers <- missing(workers)
[17:42:57.669]                     if (is.function(workers)) 
[17:42:57.669]                       workers <- workers()
[17:42:57.669]                     workers <- structure(as.integer(workers), 
[17:42:57.669]                       class = class(workers))
[17:42:57.669]                     stop_if_not(is.finite(workers), workers >= 
[17:42:57.669]                       1L)
[17:42:57.669]                     if ((workers == 1L && !inherits(workers, 
[17:42:57.669]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:57.669]                       if (default_workers) 
[17:42:57.669]                         supportsMulticore(warn = TRUE)
[17:42:57.669]                       return(sequential(..., envir = envir))
[17:42:57.669]                     }
[17:42:57.669]                     oopts <- options(mc.cores = workers)
[17:42:57.669]                     on.exit(options(oopts))
[17:42:57.669]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:57.669]                       envir = envir)
[17:42:57.669]                     if (!future$lazy) 
[17:42:57.669]                       future <- run(future)
[17:42:57.669]                     invisible(future)
[17:42:57.669]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:57.669]                 }
[17:42:57.669]             }
[17:42:57.669]         }
[17:42:57.669]     })
[17:42:57.669]     if (TRUE) {
[17:42:57.669]         base::sink(type = "output", split = FALSE)
[17:42:57.669]         if (TRUE) {
[17:42:57.669]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:57.669]         }
[17:42:57.669]         else {
[17:42:57.669]             ...future.result["stdout"] <- base::list(NULL)
[17:42:57.669]         }
[17:42:57.669]         base::close(...future.stdout)
[17:42:57.669]         ...future.stdout <- NULL
[17:42:57.669]     }
[17:42:57.669]     ...future.result$conditions <- ...future.conditions
[17:42:57.669]     ...future.result$finished <- base::Sys.time()
[17:42:57.669]     ...future.result
[17:42:57.669] }
[17:42:57.672] requestCore(): workers = 2
[17:42:57.674] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:42:57.675] plan(): Setting new future strategy stack:
[17:42:57.675] List of future strategies:
[17:42:57.675] 1. sequential:
[17:42:57.675]    - args: function (..., envir = parent.frame())
[17:42:57.675]    - tweaked: FALSE
[17:42:57.675]    - call: NULL
[17:42:57.676] plan(): nbrOfWorkers() = 1
[17:42:57.678] plan(): Setting new future strategy stack:
[17:42:57.678] List of future strategies:
[17:42:57.678] 1. multicore:
[17:42:57.678]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:57.678]    - tweaked: FALSE
[17:42:57.678]    - call: plan(multicore)
[17:42:57.683] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 56280105-ab48-3cfb-51ca-f6f685381758
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[1] 0
*** multicore(..., globals = FALSE) with globals and blocking
 - Creating multicore future #1 ...
[17:42:57.689] getGlobalsAndPackages() ...
[17:42:57.689] Not searching for globals
[17:42:57.689] - globals: [0] <none>
[17:42:57.689] getGlobalsAndPackages() ... DONE
[17:42:57.690] Packages needed by the future expression (n = 0): <none>
[17:42:57.690] Packages needed by future strategies (n = 0): <none>
[17:42:57.690] {
[17:42:57.690]     {
[17:42:57.690]         {
[17:42:57.690]             ...future.startTime <- base::Sys.time()
[17:42:57.690]             {
[17:42:57.690]                 {
[17:42:57.690]                   {
[17:42:57.690]                     {
[17:42:57.690]                       base::local({
[17:42:57.690]                         has_future <- base::requireNamespace("future", 
[17:42:57.690]                           quietly = TRUE)
[17:42:57.690]                         if (has_future) {
[17:42:57.690]                           ns <- base::getNamespace("future")
[17:42:57.690]                           version <- ns[[".package"]][["version"]]
[17:42:57.690]                           if (is.null(version)) 
[17:42:57.690]                             version <- utils::packageVersion("future")
[17:42:57.690]                         }
[17:42:57.690]                         else {
[17:42:57.690]                           version <- NULL
[17:42:57.690]                         }
[17:42:57.690]                         if (!has_future || version < "1.8.0") {
[17:42:57.690]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:57.690]                             "", base::R.version$version.string), 
[17:42:57.690]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:57.690]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:57.690]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:57.690]                               "release", "version")], collapse = " "), 
[17:42:57.690]                             hostname = base::Sys.info()[["nodename"]])
[17:42:57.690]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:57.690]                             info)
[17:42:57.690]                           info <- base::paste(info, collapse = "; ")
[17:42:57.690]                           if (!has_future) {
[17:42:57.690]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:57.690]                               info)
[17:42:57.690]                           }
[17:42:57.690]                           else {
[17:42:57.690]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:57.690]                               info, version)
[17:42:57.690]                           }
[17:42:57.690]                           base::stop(msg)
[17:42:57.690]                         }
[17:42:57.690]                       })
[17:42:57.690]                     }
[17:42:57.690]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:57.690]                     base::options(mc.cores = 1L)
[17:42:57.690]                   }
[17:42:57.690]                   options(future.plan = NULL)
[17:42:57.690]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.690]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:57.690]                 }
[17:42:57.690]                 ...future.workdir <- getwd()
[17:42:57.690]             }
[17:42:57.690]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:57.690]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:57.690]         }
[17:42:57.690]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:57.690]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:57.690]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:57.690]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:57.690]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:57.690]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:57.690]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:57.690]             base::names(...future.oldOptions))
[17:42:57.690]     }
[17:42:57.690]     if (FALSE) {
[17:42:57.690]     }
[17:42:57.690]     else {
[17:42:57.690]         if (TRUE) {
[17:42:57.690]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:57.690]                 open = "w")
[17:42:57.690]         }
[17:42:57.690]         else {
[17:42:57.690]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:57.690]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:57.690]         }
[17:42:57.690]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:57.690]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:57.690]             base::sink(type = "output", split = FALSE)
[17:42:57.690]             base::close(...future.stdout)
[17:42:57.690]         }, add = TRUE)
[17:42:57.690]     }
[17:42:57.690]     ...future.frame <- base::sys.nframe()
[17:42:57.690]     ...future.conditions <- base::list()
[17:42:57.690]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:57.690]     if (FALSE) {
[17:42:57.690]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:57.690]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:57.690]     }
[17:42:57.690]     ...future.result <- base::tryCatch({
[17:42:57.690]         base::withCallingHandlers({
[17:42:57.690]             ...future.value <- base::withVisible(base::local({
[17:42:57.690]                 withCallingHandlers({
[17:42:57.690]                   {
[17:42:57.690]                     ii
[17:42:57.690]                   }
[17:42:57.690]                 }, immediateCondition = function(cond) {
[17:42:57.690]                   save_rds <- function (object, pathname, ...) 
[17:42:57.690]                   {
[17:42:57.690]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:57.690]                     if (file_test("-f", pathname_tmp)) {
[17:42:57.690]                       fi_tmp <- file.info(pathname_tmp)
[17:42:57.690]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:57.690]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:57.690]                         fi_tmp[["mtime"]])
[17:42:57.690]                     }
[17:42:57.690]                     tryCatch({
[17:42:57.690]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:57.690]                     }, error = function(ex) {
[17:42:57.690]                       msg <- conditionMessage(ex)
[17:42:57.690]                       fi_tmp <- file.info(pathname_tmp)
[17:42:57.690]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:57.690]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:57.690]                         fi_tmp[["mtime"]], msg)
[17:42:57.690]                       ex$message <- msg
[17:42:57.690]                       stop(ex)
[17:42:57.690]                     })
[17:42:57.690]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:57.690]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:57.690]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:57.690]                       fi_tmp <- file.info(pathname_tmp)
[17:42:57.690]                       fi <- file.info(pathname)
[17:42:57.690]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:57.690]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:57.690]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:57.690]                         fi[["size"]], fi[["mtime"]])
[17:42:57.690]                       stop(msg)
[17:42:57.690]                     }
[17:42:57.690]                     invisible(pathname)
[17:42:57.690]                   }
[17:42:57.690]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:57.690]                     rootPath = tempdir()) 
[17:42:57.690]                   {
[17:42:57.690]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:57.690]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:57.690]                       tmpdir = path, fileext = ".rds")
[17:42:57.690]                     save_rds(obj, file)
[17:42:57.690]                   }
[17:42:57.690]                   saveImmediateCondition(cond, path = "/tmp/Rtmpie37tE/.future/immediateConditions")
[17:42:57.690]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.690]                   {
[17:42:57.690]                     inherits <- base::inherits
[17:42:57.690]                     invokeRestart <- base::invokeRestart
[17:42:57.690]                     is.null <- base::is.null
[17:42:57.690]                     muffled <- FALSE
[17:42:57.690]                     if (inherits(cond, "message")) {
[17:42:57.690]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:57.690]                       if (muffled) 
[17:42:57.690]                         invokeRestart("muffleMessage")
[17:42:57.690]                     }
[17:42:57.690]                     else if (inherits(cond, "warning")) {
[17:42:57.690]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:57.690]                       if (muffled) 
[17:42:57.690]                         invokeRestart("muffleWarning")
[17:42:57.690]                     }
[17:42:57.690]                     else if (inherits(cond, "condition")) {
[17:42:57.690]                       if (!is.null(pattern)) {
[17:42:57.690]                         computeRestarts <- base::computeRestarts
[17:42:57.690]                         grepl <- base::grepl
[17:42:57.690]                         restarts <- computeRestarts(cond)
[17:42:57.690]                         for (restart in restarts) {
[17:42:57.690]                           name <- restart$name
[17:42:57.690]                           if (is.null(name)) 
[17:42:57.690]                             next
[17:42:57.690]                           if (!grepl(pattern, name)) 
[17:42:57.690]                             next
[17:42:57.690]                           invokeRestart(restart)
[17:42:57.690]                           muffled <- TRUE
[17:42:57.690]                           break
[17:42:57.690]                         }
[17:42:57.690]                       }
[17:42:57.690]                     }
[17:42:57.690]                     invisible(muffled)
[17:42:57.690]                   }
[17:42:57.690]                   muffleCondition(cond)
[17:42:57.690]                 })
[17:42:57.690]             }))
[17:42:57.690]             future::FutureResult(value = ...future.value$value, 
[17:42:57.690]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.690]                   ...future.rng), globalenv = if (FALSE) 
[17:42:57.690]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:57.690]                     ...future.globalenv.names))
[17:42:57.690]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:57.690]         }, condition = base::local({
[17:42:57.690]             c <- base::c
[17:42:57.690]             inherits <- base::inherits
[17:42:57.690]             invokeRestart <- base::invokeRestart
[17:42:57.690]             length <- base::length
[17:42:57.690]             list <- base::list
[17:42:57.690]             seq.int <- base::seq.int
[17:42:57.690]             signalCondition <- base::signalCondition
[17:42:57.690]             sys.calls <- base::sys.calls
[17:42:57.690]             `[[` <- base::`[[`
[17:42:57.690]             `+` <- base::`+`
[17:42:57.690]             `<<-` <- base::`<<-`
[17:42:57.690]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:57.690]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:57.690]                   3L)]
[17:42:57.690]             }
[17:42:57.690]             function(cond) {
[17:42:57.690]                 is_error <- inherits(cond, "error")
[17:42:57.690]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:57.690]                   NULL)
[17:42:57.690]                 if (is_error) {
[17:42:57.690]                   sessionInformation <- function() {
[17:42:57.690]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:57.690]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:57.690]                       search = base::search(), system = base::Sys.info())
[17:42:57.690]                   }
[17:42:57.690]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.690]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:57.690]                     cond$call), session = sessionInformation(), 
[17:42:57.690]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:57.690]                   signalCondition(cond)
[17:42:57.690]                 }
[17:42:57.690]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:57.690]                 "immediateCondition"))) {
[17:42:57.690]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:57.690]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.690]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:57.690]                   if (TRUE && !signal) {
[17:42:57.690]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.690]                     {
[17:42:57.690]                       inherits <- base::inherits
[17:42:57.690]                       invokeRestart <- base::invokeRestart
[17:42:57.690]                       is.null <- base::is.null
[17:42:57.690]                       muffled <- FALSE
[17:42:57.690]                       if (inherits(cond, "message")) {
[17:42:57.690]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.690]                         if (muffled) 
[17:42:57.690]                           invokeRestart("muffleMessage")
[17:42:57.690]                       }
[17:42:57.690]                       else if (inherits(cond, "warning")) {
[17:42:57.690]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.690]                         if (muffled) 
[17:42:57.690]                           invokeRestart("muffleWarning")
[17:42:57.690]                       }
[17:42:57.690]                       else if (inherits(cond, "condition")) {
[17:42:57.690]                         if (!is.null(pattern)) {
[17:42:57.690]                           computeRestarts <- base::computeRestarts
[17:42:57.690]                           grepl <- base::grepl
[17:42:57.690]                           restarts <- computeRestarts(cond)
[17:42:57.690]                           for (restart in restarts) {
[17:42:57.690]                             name <- restart$name
[17:42:57.690]                             if (is.null(name)) 
[17:42:57.690]                               next
[17:42:57.690]                             if (!grepl(pattern, name)) 
[17:42:57.690]                               next
[17:42:57.690]                             invokeRestart(restart)
[17:42:57.690]                             muffled <- TRUE
[17:42:57.690]                             break
[17:42:57.690]                           }
[17:42:57.690]                         }
[17:42:57.690]                       }
[17:42:57.690]                       invisible(muffled)
[17:42:57.690]                     }
[17:42:57.690]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.690]                   }
[17:42:57.690]                 }
[17:42:57.690]                 else {
[17:42:57.690]                   if (TRUE) {
[17:42:57.690]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.690]                     {
[17:42:57.690]                       inherits <- base::inherits
[17:42:57.690]                       invokeRestart <- base::invokeRestart
[17:42:57.690]                       is.null <- base::is.null
[17:42:57.690]                       muffled <- FALSE
[17:42:57.690]                       if (inherits(cond, "message")) {
[17:42:57.690]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.690]                         if (muffled) 
[17:42:57.690]                           invokeRestart("muffleMessage")
[17:42:57.690]                       }
[17:42:57.690]                       else if (inherits(cond, "warning")) {
[17:42:57.690]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.690]                         if (muffled) 
[17:42:57.690]                           invokeRestart("muffleWarning")
[17:42:57.690]                       }
[17:42:57.690]                       else if (inherits(cond, "condition")) {
[17:42:57.690]                         if (!is.null(pattern)) {
[17:42:57.690]                           computeRestarts <- base::computeRestarts
[17:42:57.690]                           grepl <- base::grepl
[17:42:57.690]                           restarts <- computeRestarts(cond)
[17:42:57.690]                           for (restart in restarts) {
[17:42:57.690]                             name <- restart$name
[17:42:57.690]                             if (is.null(name)) 
[17:42:57.690]                               next
[17:42:57.690]                             if (!grepl(pattern, name)) 
[17:42:57.690]                               next
[17:42:57.690]                             invokeRestart(restart)
[17:42:57.690]                             muffled <- TRUE
[17:42:57.690]                             break
[17:42:57.690]                           }
[17:42:57.690]                         }
[17:42:57.690]                       }
[17:42:57.690]                       invisible(muffled)
[17:42:57.690]                     }
[17:42:57.690]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.690]                   }
[17:42:57.690]                 }
[17:42:57.690]             }
[17:42:57.690]         }))
[17:42:57.690]     }, error = function(ex) {
[17:42:57.690]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:57.690]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.690]                 ...future.rng), started = ...future.startTime, 
[17:42:57.690]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:57.690]             version = "1.8"), class = "FutureResult")
[17:42:57.690]     }, finally = {
[17:42:57.690]         if (!identical(...future.workdir, getwd())) 
[17:42:57.690]             setwd(...future.workdir)
[17:42:57.690]         {
[17:42:57.690]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:57.690]                 ...future.oldOptions$nwarnings <- NULL
[17:42:57.690]             }
[17:42:57.690]             base::options(...future.oldOptions)
[17:42:57.690]             if (.Platform$OS.type == "windows") {
[17:42:57.690]                 old_names <- names(...future.oldEnvVars)
[17:42:57.690]                 envs <- base::Sys.getenv()
[17:42:57.690]                 names <- names(envs)
[17:42:57.690]                 common <- intersect(names, old_names)
[17:42:57.690]                 added <- setdiff(names, old_names)
[17:42:57.690]                 removed <- setdiff(old_names, names)
[17:42:57.690]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:57.690]                   envs[common]]
[17:42:57.690]                 NAMES <- toupper(changed)
[17:42:57.690]                 args <- list()
[17:42:57.690]                 for (kk in seq_along(NAMES)) {
[17:42:57.690]                   name <- changed[[kk]]
[17:42:57.690]                   NAME <- NAMES[[kk]]
[17:42:57.690]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.690]                     next
[17:42:57.690]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.690]                 }
[17:42:57.690]                 NAMES <- toupper(added)
[17:42:57.690]                 for (kk in seq_along(NAMES)) {
[17:42:57.690]                   name <- added[[kk]]
[17:42:57.690]                   NAME <- NAMES[[kk]]
[17:42:57.690]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.690]                     next
[17:42:57.690]                   args[[name]] <- ""
[17:42:57.690]                 }
[17:42:57.690]                 NAMES <- toupper(removed)
[17:42:57.690]                 for (kk in seq_along(NAMES)) {
[17:42:57.690]                   name <- removed[[kk]]
[17:42:57.690]                   NAME <- NAMES[[kk]]
[17:42:57.690]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.690]                     next
[17:42:57.690]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.690]                 }
[17:42:57.690]                 if (length(args) > 0) 
[17:42:57.690]                   base::do.call(base::Sys.setenv, args = args)
[17:42:57.690]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:57.690]             }
[17:42:57.690]             else {
[17:42:57.690]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:57.690]             }
[17:42:57.690]             {
[17:42:57.690]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:57.690]                   0L) {
[17:42:57.690]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:57.690]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:57.690]                   base::options(opts)
[17:42:57.690]                 }
[17:42:57.690]                 {
[17:42:57.690]                   {
[17:42:57.690]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:57.690]                     NULL
[17:42:57.690]                   }
[17:42:57.690]                   options(future.plan = NULL)
[17:42:57.690]                   if (is.na(NA_character_)) 
[17:42:57.690]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.690]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:57.690]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:57.690]                     envir = parent.frame()) 
[17:42:57.690]                   {
[17:42:57.690]                     default_workers <- missing(workers)
[17:42:57.690]                     if (is.function(workers)) 
[17:42:57.690]                       workers <- workers()
[17:42:57.690]                     workers <- structure(as.integer(workers), 
[17:42:57.690]                       class = class(workers))
[17:42:57.690]                     stop_if_not(is.finite(workers), workers >= 
[17:42:57.690]                       1L)
[17:42:57.690]                     if ((workers == 1L && !inherits(workers, 
[17:42:57.690]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:57.690]                       if (default_workers) 
[17:42:57.690]                         supportsMulticore(warn = TRUE)
[17:42:57.690]                       return(sequential(..., envir = envir))
[17:42:57.690]                     }
[17:42:57.690]                     oopts <- options(mc.cores = workers)
[17:42:57.690]                     on.exit(options(oopts))
[17:42:57.690]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:57.690]                       envir = envir)
[17:42:57.690]                     if (!future$lazy) 
[17:42:57.690]                       future <- run(future)
[17:42:57.690]                     invisible(future)
[17:42:57.690]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:57.690]                 }
[17:42:57.690]             }
[17:42:57.690]         }
[17:42:57.690]     })
[17:42:57.690]     if (TRUE) {
[17:42:57.690]         base::sink(type = "output", split = FALSE)
[17:42:57.690]         if (TRUE) {
[17:42:57.690]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:57.690]         }
[17:42:57.690]         else {
[17:42:57.690]             ...future.result["stdout"] <- base::list(NULL)
[17:42:57.690]         }
[17:42:57.690]         base::close(...future.stdout)
[17:42:57.690]         ...future.stdout <- NULL
[17:42:57.690]     }
[17:42:57.690]     ...future.result$conditions <- ...future.conditions
[17:42:57.690]     ...future.result$finished <- base::Sys.time()
[17:42:57.690]     ...future.result
[17:42:57.690] }
[17:42:57.693] requestCore(): workers = 2
[17:42:57.695] MulticoreFuture started
 - Creating multicore future #2 ...
[17:42:57.696] plan(): Setting new future strategy stack:
[17:42:57.696] List of future strategies:
[17:42:57.696] 1. sequential:
[17:42:57.696]    - args: function (..., envir = parent.frame())
[17:42:57.696]    - tweaked: FALSE
[17:42:57.696]    - call: NULL
[17:42:57.697] plan(): nbrOfWorkers() = 1
[17:42:57.699] plan(): Setting new future strategy stack:
[17:42:57.699] List of future strategies:
[17:42:57.699] 1. multicore:
[17:42:57.699]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:57.699]    - tweaked: FALSE
[17:42:57.699]    - call: plan(multicore)
[17:42:57.701] getGlobalsAndPackages() ...
[17:42:57.701] Not searching for globals
[17:42:57.701] - globals: [0] <none>
[17:42:57.701] getGlobalsAndPackages() ... DONE
[17:42:57.702] Packages needed by the future expression (n = 0): <none>
[17:42:57.702] Packages needed by future strategies (n = 0): <none>
[17:42:57.704] plan(): nbrOfWorkers() = 2
[17:42:57.703] {
[17:42:57.703]     {
[17:42:57.703]         {
[17:42:57.703]             ...future.startTime <- base::Sys.time()
[17:42:57.703]             {
[17:42:57.703]                 {
[17:42:57.703]                   {
[17:42:57.703]                     {
[17:42:57.703]                       base::local({
[17:42:57.703]                         has_future <- base::requireNamespace("future", 
[17:42:57.703]                           quietly = TRUE)
[17:42:57.703]                         if (has_future) {
[17:42:57.703]                           ns <- base::getNamespace("future")
[17:42:57.703]                           version <- ns[[".package"]][["version"]]
[17:42:57.703]                           if (is.null(version)) 
[17:42:57.703]                             version <- utils::packageVersion("future")
[17:42:57.703]                         }
[17:42:57.703]                         else {
[17:42:57.703]                           version <- NULL
[17:42:57.703]                         }
[17:42:57.703]                         if (!has_future || version < "1.8.0") {
[17:42:57.703]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:57.703]                             "", base::R.version$version.string), 
[17:42:57.703]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:57.703]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:57.703]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:57.703]                               "release", "version")], collapse = " "), 
[17:42:57.703]                             hostname = base::Sys.info()[["nodename"]])
[17:42:57.703]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:57.703]                             info)
[17:42:57.703]                           info <- base::paste(info, collapse = "; ")
[17:42:57.703]                           if (!has_future) {
[17:42:57.703]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:57.703]                               info)
[17:42:57.703]                           }
[17:42:57.703]                           else {
[17:42:57.703]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:57.703]                               info, version)
[17:42:57.703]                           }
[17:42:57.703]                           base::stop(msg)
[17:42:57.703]                         }
[17:42:57.703]                       })
[17:42:57.703]                     }
[17:42:57.703]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:57.703]                     base::options(mc.cores = 1L)
[17:42:57.703]                   }
[17:42:57.703]                   options(future.plan = NULL)
[17:42:57.703]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.703]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:57.703]                 }
[17:42:57.703]                 ...future.workdir <- getwd()
[17:42:57.703]             }
[17:42:57.703]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:57.703]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:57.703]         }
[17:42:57.703]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:57.703]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:57.703]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:57.703]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:57.703]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:57.703]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:57.703]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:57.703]             base::names(...future.oldOptions))
[17:42:57.703]     }
[17:42:57.703]     if (FALSE) {
[17:42:57.703]     }
[17:42:57.703]     else {
[17:42:57.703]         if (TRUE) {
[17:42:57.703]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:57.703]                 open = "w")
[17:42:57.703]         }
[17:42:57.703]         else {
[17:42:57.703]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:57.703]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:57.703]         }
[17:42:57.703]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:57.703]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:57.703]             base::sink(type = "output", split = FALSE)
[17:42:57.703]             base::close(...future.stdout)
[17:42:57.703]         }, add = TRUE)
[17:42:57.703]     }
[17:42:57.703]     ...future.frame <- base::sys.nframe()
[17:42:57.703]     ...future.conditions <- base::list()
[17:42:57.703]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:57.703]     if (FALSE) {
[17:42:57.703]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:57.703]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:57.703]     }
[17:42:57.703]     ...future.result <- base::tryCatch({
[17:42:57.703]         base::withCallingHandlers({
[17:42:57.703]             ...future.value <- base::withVisible(base::local({
[17:42:57.703]                 withCallingHandlers({
[17:42:57.703]                   {
[17:42:57.703]                     ii
[17:42:57.703]                   }
[17:42:57.703]                 }, immediateCondition = function(cond) {
[17:42:57.703]                   save_rds <- function (object, pathname, ...) 
[17:42:57.703]                   {
[17:42:57.703]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:57.703]                     if (file_test("-f", pathname_tmp)) {
[17:42:57.703]                       fi_tmp <- file.info(pathname_tmp)
[17:42:57.703]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:57.703]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:57.703]                         fi_tmp[["mtime"]])
[17:42:57.703]                     }
[17:42:57.703]                     tryCatch({
[17:42:57.703]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:57.703]                     }, error = function(ex) {
[17:42:57.703]                       msg <- conditionMessage(ex)
[17:42:57.703]                       fi_tmp <- file.info(pathname_tmp)
[17:42:57.703]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:57.703]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:57.703]                         fi_tmp[["mtime"]], msg)
[17:42:57.703]                       ex$message <- msg
[17:42:57.703]                       stop(ex)
[17:42:57.703]                     })
[17:42:57.703]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:57.703]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:57.703]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:57.703]                       fi_tmp <- file.info(pathname_tmp)
[17:42:57.703]                       fi <- file.info(pathname)
[17:42:57.703]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:57.703]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:57.703]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:57.703]                         fi[["size"]], fi[["mtime"]])
[17:42:57.703]                       stop(msg)
[17:42:57.703]                     }
[17:42:57.703]                     invisible(pathname)
[17:42:57.703]                   }
[17:42:57.703]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:57.703]                     rootPath = tempdir()) 
[17:42:57.703]                   {
[17:42:57.703]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:57.703]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:57.703]                       tmpdir = path, fileext = ".rds")
[17:42:57.703]                     save_rds(obj, file)
[17:42:57.703]                   }
[17:42:57.703]                   saveImmediateCondition(cond, path = "/tmp/Rtmpie37tE/.future/immediateConditions")
[17:42:57.703]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.703]                   {
[17:42:57.703]                     inherits <- base::inherits
[17:42:57.703]                     invokeRestart <- base::invokeRestart
[17:42:57.703]                     is.null <- base::is.null
[17:42:57.703]                     muffled <- FALSE
[17:42:57.703]                     if (inherits(cond, "message")) {
[17:42:57.703]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:57.703]                       if (muffled) 
[17:42:57.703]                         invokeRestart("muffleMessage")
[17:42:57.703]                     }
[17:42:57.703]                     else if (inherits(cond, "warning")) {
[17:42:57.703]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:57.703]                       if (muffled) 
[17:42:57.703]                         invokeRestart("muffleWarning")
[17:42:57.703]                     }
[17:42:57.703]                     else if (inherits(cond, "condition")) {
[17:42:57.703]                       if (!is.null(pattern)) {
[17:42:57.703]                         computeRestarts <- base::computeRestarts
[17:42:57.703]                         grepl <- base::grepl
[17:42:57.703]                         restarts <- computeRestarts(cond)
[17:42:57.703]                         for (restart in restarts) {
[17:42:57.703]                           name <- restart$name
[17:42:57.703]                           if (is.null(name)) 
[17:42:57.703]                             next
[17:42:57.703]                           if (!grepl(pattern, name)) 
[17:42:57.703]                             next
[17:42:57.703]                           invokeRestart(restart)
[17:42:57.703]                           muffled <- TRUE
[17:42:57.703]                           break
[17:42:57.703]                         }
[17:42:57.703]                       }
[17:42:57.703]                     }
[17:42:57.703]                     invisible(muffled)
[17:42:57.703]                   }
[17:42:57.703]                   muffleCondition(cond)
[17:42:57.703]                 })
[17:42:57.703]             }))
[17:42:57.703]             future::FutureResult(value = ...future.value$value, 
[17:42:57.703]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.703]                   ...future.rng), globalenv = if (FALSE) 
[17:42:57.703]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:57.703]                     ...future.globalenv.names))
[17:42:57.703]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:57.703]         }, condition = base::local({
[17:42:57.703]             c <- base::c
[17:42:57.703]             inherits <- base::inherits
[17:42:57.703]             invokeRestart <- base::invokeRestart
[17:42:57.703]             length <- base::length
[17:42:57.703]             list <- base::list
[17:42:57.703]             seq.int <- base::seq.int
[17:42:57.703]             signalCondition <- base::signalCondition
[17:42:57.703]             sys.calls <- base::sys.calls
[17:42:57.703]             `[[` <- base::`[[`
[17:42:57.703]             `+` <- base::`+`
[17:42:57.703]             `<<-` <- base::`<<-`
[17:42:57.703]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:57.703]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:57.703]                   3L)]
[17:42:57.703]             }
[17:42:57.703]             function(cond) {
[17:42:57.703]                 is_error <- inherits(cond, "error")
[17:42:57.703]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:57.703]                   NULL)
[17:42:57.703]                 if (is_error) {
[17:42:57.703]                   sessionInformation <- function() {
[17:42:57.703]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:57.703]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:57.703]                       search = base::search(), system = base::Sys.info())
[17:42:57.703]                   }
[17:42:57.703]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.703]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:57.703]                     cond$call), session = sessionInformation(), 
[17:42:57.703]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:57.703]                   signalCondition(cond)
[17:42:57.703]                 }
[17:42:57.703]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:57.703]                 "immediateCondition"))) {
[17:42:57.703]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:57.703]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.703]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:57.703]                   if (TRUE && !signal) {
[17:42:57.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.703]                     {
[17:42:57.703]                       inherits <- base::inherits
[17:42:57.703]                       invokeRestart <- base::invokeRestart
[17:42:57.703]                       is.null <- base::is.null
[17:42:57.703]                       muffled <- FALSE
[17:42:57.703]                       if (inherits(cond, "message")) {
[17:42:57.703]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.703]                         if (muffled) 
[17:42:57.703]                           invokeRestart("muffleMessage")
[17:42:57.703]                       }
[17:42:57.703]                       else if (inherits(cond, "warning")) {
[17:42:57.703]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.703]                         if (muffled) 
[17:42:57.703]                           invokeRestart("muffleWarning")
[17:42:57.703]                       }
[17:42:57.703]                       else if (inherits(cond, "condition")) {
[17:42:57.703]                         if (!is.null(pattern)) {
[17:42:57.703]                           computeRestarts <- base::computeRestarts
[17:42:57.703]                           grepl <- base::grepl
[17:42:57.703]                           restarts <- computeRestarts(cond)
[17:42:57.703]                           for (restart in restarts) {
[17:42:57.703]                             name <- restart$name
[17:42:57.703]                             if (is.null(name)) 
[17:42:57.703]                               next
[17:42:57.703]                             if (!grepl(pattern, name)) 
[17:42:57.703]                               next
[17:42:57.703]                             invokeRestart(restart)
[17:42:57.703]                             muffled <- TRUE
[17:42:57.703]                             break
[17:42:57.703]                           }
[17:42:57.703]                         }
[17:42:57.703]                       }
[17:42:57.703]                       invisible(muffled)
[17:42:57.703]                     }
[17:42:57.703]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.703]                   }
[17:42:57.703]                 }
[17:42:57.703]                 else {
[17:42:57.703]                   if (TRUE) {
[17:42:57.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.703]                     {
[17:42:57.703]                       inherits <- base::inherits
[17:42:57.703]                       invokeRestart <- base::invokeRestart
[17:42:57.703]                       is.null <- base::is.null
[17:42:57.703]                       muffled <- FALSE
[17:42:57.703]                       if (inherits(cond, "message")) {
[17:42:57.703]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.703]                         if (muffled) 
[17:42:57.703]                           invokeRestart("muffleMessage")
[17:42:57.703]                       }
[17:42:57.703]                       else if (inherits(cond, "warning")) {
[17:42:57.703]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.703]                         if (muffled) 
[17:42:57.703]                           invokeRestart("muffleWarning")
[17:42:57.703]                       }
[17:42:57.703]                       else if (inherits(cond, "condition")) {
[17:42:57.703]                         if (!is.null(pattern)) {
[17:42:57.703]                           computeRestarts <- base::computeRestarts
[17:42:57.703]                           grepl <- base::grepl
[17:42:57.703]                           restarts <- computeRestarts(cond)
[17:42:57.703]                           for (restart in restarts) {
[17:42:57.703]                             name <- restart$name
[17:42:57.703]                             if (is.null(name)) 
[17:42:57.703]                               next
[17:42:57.703]                             if (!grepl(pattern, name)) 
[17:42:57.703]                               next
[17:42:57.703]                             invokeRestart(restart)
[17:42:57.703]                             muffled <- TRUE
[17:42:57.703]                             break
[17:42:57.703]                           }
[17:42:57.703]                         }
[17:42:57.703]                       }
[17:42:57.703]                       invisible(muffled)
[17:42:57.703]                     }
[17:42:57.703]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.703]                   }
[17:42:57.703]                 }
[17:42:57.703]             }
[17:42:57.703]         }))
[17:42:57.703]     }, error = function(ex) {
[17:42:57.703]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:57.703]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.703]                 ...future.rng), started = ...future.startTime, 
[17:42:57.703]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:57.703]             version = "1.8"), class = "FutureResult")
[17:42:57.703]     }, finally = {
[17:42:57.703]         if (!identical(...future.workdir, getwd())) 
[17:42:57.703]             setwd(...future.workdir)
[17:42:57.703]         {
[17:42:57.703]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:57.703]                 ...future.oldOptions$nwarnings <- NULL
[17:42:57.703]             }
[17:42:57.703]             base::options(...future.oldOptions)
[17:42:57.703]             if (.Platform$OS.type == "windows") {
[17:42:57.703]                 old_names <- names(...future.oldEnvVars)
[17:42:57.703]                 envs <- base::Sys.getenv()
[17:42:57.703]                 names <- names(envs)
[17:42:57.703]                 common <- intersect(names, old_names)
[17:42:57.703]                 added <- setdiff(names, old_names)
[17:42:57.703]                 removed <- setdiff(old_names, names)
[17:42:57.703]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:57.703]                   envs[common]]
[17:42:57.703]                 NAMES <- toupper(changed)
[17:42:57.703]                 args <- list()
[17:42:57.703]                 for (kk in seq_along(NAMES)) {
[17:42:57.703]                   name <- changed[[kk]]
[17:42:57.703]                   NAME <- NAMES[[kk]]
[17:42:57.703]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.703]                     next
[17:42:57.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.703]                 }
[17:42:57.703]                 NAMES <- toupper(added)
[17:42:57.703]                 for (kk in seq_along(NAMES)) {
[17:42:57.703]                   name <- added[[kk]]
[17:42:57.703]                   NAME <- NAMES[[kk]]
[17:42:57.703]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.703]                     next
[17:42:57.703]                   args[[name]] <- ""
[17:42:57.703]                 }
[17:42:57.703]                 NAMES <- toupper(removed)
[17:42:57.703]                 for (kk in seq_along(NAMES)) {
[17:42:57.703]                   name <- removed[[kk]]
[17:42:57.703]                   NAME <- NAMES[[kk]]
[17:42:57.703]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.703]                     next
[17:42:57.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.703]                 }
[17:42:57.703]                 if (length(args) > 0) 
[17:42:57.703]                   base::do.call(base::Sys.setenv, args = args)
[17:42:57.703]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:57.703]             }
[17:42:57.703]             else {
[17:42:57.703]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:57.703]             }
[17:42:57.703]             {
[17:42:57.703]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:57.703]                   0L) {
[17:42:57.703]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:57.703]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:57.703]                   base::options(opts)
[17:42:57.703]                 }
[17:42:57.703]                 {
[17:42:57.703]                   {
[17:42:57.703]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:57.703]                     NULL
[17:42:57.703]                   }
[17:42:57.703]                   options(future.plan = NULL)
[17:42:57.703]                   if (is.na(NA_character_)) 
[17:42:57.703]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.703]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:57.703]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:57.703]                     envir = parent.frame()) 
[17:42:57.703]                   {
[17:42:57.703]                     default_workers <- missing(workers)
[17:42:57.703]                     if (is.function(workers)) 
[17:42:57.703]                       workers <- workers()
[17:42:57.703]                     workers <- structure(as.integer(workers), 
[17:42:57.703]                       class = class(workers))
[17:42:57.703]                     stop_if_not(is.finite(workers), workers >= 
[17:42:57.703]                       1L)
[17:42:57.703]                     if ((workers == 1L && !inherits(workers, 
[17:42:57.703]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:57.703]                       if (default_workers) 
[17:42:57.703]                         supportsMulticore(warn = TRUE)
[17:42:57.703]                       return(sequential(..., envir = envir))
[17:42:57.703]                     }
[17:42:57.703]                     oopts <- options(mc.cores = workers)
[17:42:57.703]                     on.exit(options(oopts))
[17:42:57.703]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:57.703]                       envir = envir)
[17:42:57.703]                     if (!future$lazy) 
[17:42:57.703]                       future <- run(future)
[17:42:57.703]                     invisible(future)
[17:42:57.703]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:57.703]                 }
[17:42:57.703]             }
[17:42:57.703]         }
[17:42:57.703]     })
[17:42:57.703]     if (TRUE) {
[17:42:57.703]         base::sink(type = "output", split = FALSE)
[17:42:57.703]         if (TRUE) {
[17:42:57.703]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:57.703]         }
[17:42:57.703]         else {
[17:42:57.703]             ...future.result["stdout"] <- base::list(NULL)
[17:42:57.703]         }
[17:42:57.703]         base::close(...future.stdout)
[17:42:57.703]         ...future.stdout <- NULL
[17:42:57.703]     }
[17:42:57.703]     ...future.result$conditions <- ...future.conditions
[17:42:57.703]     ...future.result$finished <- base::Sys.time()
[17:42:57.703]     ...future.result
[17:42:57.703] }
[17:42:57.707] requestCore(): workers = 2
[17:42:57.709] MulticoreFuture started
 - Creating multicore future #3 ...
[17:42:57.710] plan(): Setting new future strategy stack:
[17:42:57.711] List of future strategies:
[17:42:57.711] 1. sequential:
[17:42:57.711]    - args: function (..., envir = parent.frame())
[17:42:57.711]    - tweaked: FALSE
[17:42:57.711]    - call: NULL
[17:42:57.712] plan(): nbrOfWorkers() = 1
[17:42:57.714] plan(): Setting new future strategy stack:
[17:42:57.714] List of future strategies:
[17:42:57.714] 1. multicore:
[17:42:57.714]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:57.714]    - tweaked: FALSE
[17:42:57.714]    - call: plan(multicore)
[17:42:57.716] getGlobalsAndPackages() ...
[17:42:57.716] Not searching for globals
[17:42:57.716] - globals: [0] <none>
[17:42:57.716] getGlobalsAndPackages() ... DONE
[17:42:57.723] Packages needed by the future expression (n = 0): <none>
[17:42:57.724] Packages needed by future strategies (n = 0): <none>
[17:42:57.727] plan(): nbrOfWorkers() = 2
[17:42:57.725] {
[17:42:57.725]     {
[17:42:57.725]         {
[17:42:57.725]             ...future.startTime <- base::Sys.time()
[17:42:57.725]             {
[17:42:57.725]                 {
[17:42:57.725]                   {
[17:42:57.725]                     {
[17:42:57.725]                       base::local({
[17:42:57.725]                         has_future <- base::requireNamespace("future", 
[17:42:57.725]                           quietly = TRUE)
[17:42:57.725]                         if (has_future) {
[17:42:57.725]                           ns <- base::getNamespace("future")
[17:42:57.725]                           version <- ns[[".package"]][["version"]]
[17:42:57.725]                           if (is.null(version)) 
[17:42:57.725]                             version <- utils::packageVersion("future")
[17:42:57.725]                         }
[17:42:57.725]                         else {
[17:42:57.725]                           version <- NULL
[17:42:57.725]                         }
[17:42:57.725]                         if (!has_future || version < "1.8.0") {
[17:42:57.725]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:57.725]                             "", base::R.version$version.string), 
[17:42:57.725]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:57.725]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:57.725]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:57.725]                               "release", "version")], collapse = " "), 
[17:42:57.725]                             hostname = base::Sys.info()[["nodename"]])
[17:42:57.725]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:57.725]                             info)
[17:42:57.725]                           info <- base::paste(info, collapse = "; ")
[17:42:57.725]                           if (!has_future) {
[17:42:57.725]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:57.725]                               info)
[17:42:57.725]                           }
[17:42:57.725]                           else {
[17:42:57.725]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:57.725]                               info, version)
[17:42:57.725]                           }
[17:42:57.725]                           base::stop(msg)
[17:42:57.725]                         }
[17:42:57.725]                       })
[17:42:57.725]                     }
[17:42:57.725]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:57.725]                     base::options(mc.cores = 1L)
[17:42:57.725]                   }
[17:42:57.725]                   options(future.plan = NULL)
[17:42:57.725]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.725]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:57.725]                 }
[17:42:57.725]                 ...future.workdir <- getwd()
[17:42:57.725]             }
[17:42:57.725]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:57.725]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:57.725]         }
[17:42:57.725]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:57.725]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:57.725]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:57.725]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:57.725]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:57.725]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:57.725]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:57.725]             base::names(...future.oldOptions))
[17:42:57.725]     }
[17:42:57.725]     if (FALSE) {
[17:42:57.725]     }
[17:42:57.725]     else {
[17:42:57.725]         if (TRUE) {
[17:42:57.725]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:57.725]                 open = "w")
[17:42:57.725]         }
[17:42:57.725]         else {
[17:42:57.725]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:57.725]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:57.725]         }
[17:42:57.725]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:57.725]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:57.725]             base::sink(type = "output", split = FALSE)
[17:42:57.725]             base::close(...future.stdout)
[17:42:57.725]         }, add = TRUE)
[17:42:57.725]     }
[17:42:57.725]     ...future.frame <- base::sys.nframe()
[17:42:57.725]     ...future.conditions <- base::list()
[17:42:57.725]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:57.725]     if (FALSE) {
[17:42:57.725]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:57.725]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:57.725]     }
[17:42:57.725]     ...future.result <- base::tryCatch({
[17:42:57.725]         base::withCallingHandlers({
[17:42:57.725]             ...future.value <- base::withVisible(base::local({
[17:42:57.725]                 withCallingHandlers({
[17:42:57.725]                   {
[17:42:57.725]                     ii
[17:42:57.725]                   }
[17:42:57.725]                 }, immediateCondition = function(cond) {
[17:42:57.725]                   save_rds <- function (object, pathname, ...) 
[17:42:57.725]                   {
[17:42:57.725]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:57.725]                     if (file_test("-f", pathname_tmp)) {
[17:42:57.725]                       fi_tmp <- file.info(pathname_tmp)
[17:42:57.725]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:57.725]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:57.725]                         fi_tmp[["mtime"]])
[17:42:57.725]                     }
[17:42:57.725]                     tryCatch({
[17:42:57.725]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:57.725]                     }, error = function(ex) {
[17:42:57.725]                       msg <- conditionMessage(ex)
[17:42:57.725]                       fi_tmp <- file.info(pathname_tmp)
[17:42:57.725]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:57.725]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:57.725]                         fi_tmp[["mtime"]], msg)
[17:42:57.725]                       ex$message <- msg
[17:42:57.725]                       stop(ex)
[17:42:57.725]                     })
[17:42:57.725]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:57.725]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:57.725]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:57.725]                       fi_tmp <- file.info(pathname_tmp)
[17:42:57.725]                       fi <- file.info(pathname)
[17:42:57.725]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:57.725]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:57.725]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:57.725]                         fi[["size"]], fi[["mtime"]])
[17:42:57.725]                       stop(msg)
[17:42:57.725]                     }
[17:42:57.725]                     invisible(pathname)
[17:42:57.725]                   }
[17:42:57.725]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:57.725]                     rootPath = tempdir()) 
[17:42:57.725]                   {
[17:42:57.725]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:57.725]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:57.725]                       tmpdir = path, fileext = ".rds")
[17:42:57.725]                     save_rds(obj, file)
[17:42:57.725]                   }
[17:42:57.725]                   saveImmediateCondition(cond, path = "/tmp/Rtmpie37tE/.future/immediateConditions")
[17:42:57.725]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.725]                   {
[17:42:57.725]                     inherits <- base::inherits
[17:42:57.725]                     invokeRestart <- base::invokeRestart
[17:42:57.725]                     is.null <- base::is.null
[17:42:57.725]                     muffled <- FALSE
[17:42:57.725]                     if (inherits(cond, "message")) {
[17:42:57.725]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:57.725]                       if (muffled) 
[17:42:57.725]                         invokeRestart("muffleMessage")
[17:42:57.725]                     }
[17:42:57.725]                     else if (inherits(cond, "warning")) {
[17:42:57.725]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:57.725]                       if (muffled) 
[17:42:57.725]                         invokeRestart("muffleWarning")
[17:42:57.725]                     }
[17:42:57.725]                     else if (inherits(cond, "condition")) {
[17:42:57.725]                       if (!is.null(pattern)) {
[17:42:57.725]                         computeRestarts <- base::computeRestarts
[17:42:57.725]                         grepl <- base::grepl
[17:42:57.725]                         restarts <- computeRestarts(cond)
[17:42:57.725]                         for (restart in restarts) {
[17:42:57.725]                           name <- restart$name
[17:42:57.725]                           if (is.null(name)) 
[17:42:57.725]                             next
[17:42:57.725]                           if (!grepl(pattern, name)) 
[17:42:57.725]                             next
[17:42:57.725]                           invokeRestart(restart)
[17:42:57.725]                           muffled <- TRUE
[17:42:57.725]                           break
[17:42:57.725]                         }
[17:42:57.725]                       }
[17:42:57.725]                     }
[17:42:57.725]                     invisible(muffled)
[17:42:57.725]                   }
[17:42:57.725]                   muffleCondition(cond)
[17:42:57.725]                 })
[17:42:57.725]             }))
[17:42:57.725]             future::FutureResult(value = ...future.value$value, 
[17:42:57.725]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.725]                   ...future.rng), globalenv = if (FALSE) 
[17:42:57.725]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:57.725]                     ...future.globalenv.names))
[17:42:57.725]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:57.725]         }, condition = base::local({
[17:42:57.725]             c <- base::c
[17:42:57.725]             inherits <- base::inherits
[17:42:57.725]             invokeRestart <- base::invokeRestart
[17:42:57.725]             length <- base::length
[17:42:57.725]             list <- base::list
[17:42:57.725]             seq.int <- base::seq.int
[17:42:57.725]             signalCondition <- base::signalCondition
[17:42:57.725]             sys.calls <- base::sys.calls
[17:42:57.725]             `[[` <- base::`[[`
[17:42:57.725]             `+` <- base::`+`
[17:42:57.725]             `<<-` <- base::`<<-`
[17:42:57.725]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:57.725]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:57.725]                   3L)]
[17:42:57.725]             }
[17:42:57.725]             function(cond) {
[17:42:57.725]                 is_error <- inherits(cond, "error")
[17:42:57.725]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:57.725]                   NULL)
[17:42:57.725]                 if (is_error) {
[17:42:57.725]                   sessionInformation <- function() {
[17:42:57.725]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:57.725]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:57.725]                       search = base::search(), system = base::Sys.info())
[17:42:57.725]                   }
[17:42:57.725]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.725]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:57.725]                     cond$call), session = sessionInformation(), 
[17:42:57.725]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:57.725]                   signalCondition(cond)
[17:42:57.725]                 }
[17:42:57.725]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:57.725]                 "immediateCondition"))) {
[17:42:57.725]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:57.725]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.725]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:57.725]                   if (TRUE && !signal) {
[17:42:57.725]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.725]                     {
[17:42:57.725]                       inherits <- base::inherits
[17:42:57.725]                       invokeRestart <- base::invokeRestart
[17:42:57.725]                       is.null <- base::is.null
[17:42:57.725]                       muffled <- FALSE
[17:42:57.725]                       if (inherits(cond, "message")) {
[17:42:57.725]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.725]                         if (muffled) 
[17:42:57.725]                           invokeRestart("muffleMessage")
[17:42:57.725]                       }
[17:42:57.725]                       else if (inherits(cond, "warning")) {
[17:42:57.725]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.725]                         if (muffled) 
[17:42:57.725]                           invokeRestart("muffleWarning")
[17:42:57.725]                       }
[17:42:57.725]                       else if (inherits(cond, "condition")) {
[17:42:57.725]                         if (!is.null(pattern)) {
[17:42:57.725]                           computeRestarts <- base::computeRestarts
[17:42:57.725]                           grepl <- base::grepl
[17:42:57.725]                           restarts <- computeRestarts(cond)
[17:42:57.725]                           for (restart in restarts) {
[17:42:57.725]                             name <- restart$name
[17:42:57.725]                             if (is.null(name)) 
[17:42:57.725]                               next
[17:42:57.725]                             if (!grepl(pattern, name)) 
[17:42:57.725]                               next
[17:42:57.725]                             invokeRestart(restart)
[17:42:57.725]                             muffled <- TRUE
[17:42:57.725]                             break
[17:42:57.725]                           }
[17:42:57.725]                         }
[17:42:57.725]                       }
[17:42:57.725]                       invisible(muffled)
[17:42:57.725]                     }
[17:42:57.725]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.725]                   }
[17:42:57.725]                 }
[17:42:57.725]                 else {
[17:42:57.725]                   if (TRUE) {
[17:42:57.725]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.725]                     {
[17:42:57.725]                       inherits <- base::inherits
[17:42:57.725]                       invokeRestart <- base::invokeRestart
[17:42:57.725]                       is.null <- base::is.null
[17:42:57.725]                       muffled <- FALSE
[17:42:57.725]                       if (inherits(cond, "message")) {
[17:42:57.725]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.725]                         if (muffled) 
[17:42:57.725]                           invokeRestart("muffleMessage")
[17:42:57.725]                       }
[17:42:57.725]                       else if (inherits(cond, "warning")) {
[17:42:57.725]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.725]                         if (muffled) 
[17:42:57.725]                           invokeRestart("muffleWarning")
[17:42:57.725]                       }
[17:42:57.725]                       else if (inherits(cond, "condition")) {
[17:42:57.725]                         if (!is.null(pattern)) {
[17:42:57.725]                           computeRestarts <- base::computeRestarts
[17:42:57.725]                           grepl <- base::grepl
[17:42:57.725]                           restarts <- computeRestarts(cond)
[17:42:57.725]                           for (restart in restarts) {
[17:42:57.725]                             name <- restart$name
[17:42:57.725]                             if (is.null(name)) 
[17:42:57.725]                               next
[17:42:57.725]                             if (!grepl(pattern, name)) 
[17:42:57.725]                               next
[17:42:57.725]                             invokeRestart(restart)
[17:42:57.725]                             muffled <- TRUE
[17:42:57.725]                             break
[17:42:57.725]                           }
[17:42:57.725]                         }
[17:42:57.725]                       }
[17:42:57.725]                       invisible(muffled)
[17:42:57.725]                     }
[17:42:57.725]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.725]                   }
[17:42:57.725]                 }
[17:42:57.725]             }
[17:42:57.725]         }))
[17:42:57.725]     }, error = function(ex) {
[17:42:57.725]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:57.725]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.725]                 ...future.rng), started = ...future.startTime, 
[17:42:57.725]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:57.725]             version = "1.8"), class = "FutureResult")
[17:42:57.725]     }, finally = {
[17:42:57.725]         if (!identical(...future.workdir, getwd())) 
[17:42:57.725]             setwd(...future.workdir)
[17:42:57.725]         {
[17:42:57.725]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:57.725]                 ...future.oldOptions$nwarnings <- NULL
[17:42:57.725]             }
[17:42:57.725]             base::options(...future.oldOptions)
[17:42:57.725]             if (.Platform$OS.type == "windows") {
[17:42:57.725]                 old_names <- names(...future.oldEnvVars)
[17:42:57.725]                 envs <- base::Sys.getenv()
[17:42:57.725]                 names <- names(envs)
[17:42:57.725]                 common <- intersect(names, old_names)
[17:42:57.725]                 added <- setdiff(names, old_names)
[17:42:57.725]                 removed <- setdiff(old_names, names)
[17:42:57.725]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:57.725]                   envs[common]]
[17:42:57.725]                 NAMES <- toupper(changed)
[17:42:57.725]                 args <- list()
[17:42:57.725]                 for (kk in seq_along(NAMES)) {
[17:42:57.725]                   name <- changed[[kk]]
[17:42:57.725]                   NAME <- NAMES[[kk]]
[17:42:57.725]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.725]                     next
[17:42:57.725]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.725]                 }
[17:42:57.725]                 NAMES <- toupper(added)
[17:42:57.725]                 for (kk in seq_along(NAMES)) {
[17:42:57.725]                   name <- added[[kk]]
[17:42:57.725]                   NAME <- NAMES[[kk]]
[17:42:57.725]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.725]                     next
[17:42:57.725]                   args[[name]] <- ""
[17:42:57.725]                 }
[17:42:57.725]                 NAMES <- toupper(removed)
[17:42:57.725]                 for (kk in seq_along(NAMES)) {
[17:42:57.725]                   name <- removed[[kk]]
[17:42:57.725]                   NAME <- NAMES[[kk]]
[17:42:57.725]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.725]                     next
[17:42:57.725]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.725]                 }
[17:42:57.725]                 if (length(args) > 0) 
[17:42:57.725]                   base::do.call(base::Sys.setenv, args = args)
[17:42:57.725]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:57.725]             }
[17:42:57.725]             else {
[17:42:57.725]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:57.725]             }
[17:42:57.725]             {
[17:42:57.725]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:57.725]                   0L) {
[17:42:57.725]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:57.725]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:57.725]                   base::options(opts)
[17:42:57.725]                 }
[17:42:57.725]                 {
[17:42:57.725]                   {
[17:42:57.725]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:57.725]                     NULL
[17:42:57.725]                   }
[17:42:57.725]                   options(future.plan = NULL)
[17:42:57.725]                   if (is.na(NA_character_)) 
[17:42:57.725]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.725]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:57.725]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:57.725]                     envir = parent.frame()) 
[17:42:57.725]                   {
[17:42:57.725]                     default_workers <- missing(workers)
[17:42:57.725]                     if (is.function(workers)) 
[17:42:57.725]                       workers <- workers()
[17:42:57.725]                     workers <- structure(as.integer(workers), 
[17:42:57.725]                       class = class(workers))
[17:42:57.725]                     stop_if_not(is.finite(workers), workers >= 
[17:42:57.725]                       1L)
[17:42:57.725]                     if ((workers == 1L && !inherits(workers, 
[17:42:57.725]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:57.725]                       if (default_workers) 
[17:42:57.725]                         supportsMulticore(warn = TRUE)
[17:42:57.725]                       return(sequential(..., envir = envir))
[17:42:57.725]                     }
[17:42:57.725]                     oopts <- options(mc.cores = workers)
[17:42:57.725]                     on.exit(options(oopts))
[17:42:57.725]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:57.725]                       envir = envir)
[17:42:57.725]                     if (!future$lazy) 
[17:42:57.725]                       future <- run(future)
[17:42:57.725]                     invisible(future)
[17:42:57.725]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:57.725]                 }
[17:42:57.725]             }
[17:42:57.725]         }
[17:42:57.725]     })
[17:42:57.725]     if (TRUE) {
[17:42:57.725]         base::sink(type = "output", split = FALSE)
[17:42:57.725]         if (TRUE) {
[17:42:57.725]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:57.725]         }
[17:42:57.725]         else {
[17:42:57.725]             ...future.result["stdout"] <- base::list(NULL)
[17:42:57.725]         }
[17:42:57.725]         base::close(...future.stdout)
[17:42:57.725]         ...future.stdout <- NULL
[17:42:57.725]     }
[17:42:57.725]     ...future.result$conditions <- ...future.conditions
[17:42:57.725]     ...future.result$finished <- base::Sys.time()
[17:42:57.725]     ...future.result
[17:42:57.725] }
[17:42:57.729] requestCore(): workers = 2
[17:42:57.729] Poll #1 (0): usedCores() = 2, workers = 2
[17:42:57.744] MulticoreFuture started
 - Creating multicore future #4 ...
[17:42:57.746] plan(): Setting new future strategy stack:
[17:42:57.746] List of future strategies:
[17:42:57.746] 1. sequential:
[17:42:57.746]    - args: function (..., envir = parent.frame())
[17:42:57.746]    - tweaked: FALSE
[17:42:57.746]    - call: NULL
[17:42:57.748] plan(): nbrOfWorkers() = 1
[17:42:57.750] plan(): Setting new future strategy stack:
[17:42:57.750] List of future strategies:
[17:42:57.750] 1. multicore:
[17:42:57.750]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:57.750]    - tweaked: FALSE
[17:42:57.750]    - call: plan(multicore)
[17:42:57.752] getGlobalsAndPackages() ...
[17:42:57.752] Not searching for globals
[17:42:57.753] - globals: [0] <none>
[17:42:57.753] getGlobalsAndPackages() ... DONE
[17:42:57.754] Packages needed by the future expression (n = 0): <none>
[17:42:57.754] Packages needed by future strategies (n = 0): <none>
[17:42:57.756] plan(): nbrOfWorkers() = 2
[17:42:57.755] {
[17:42:57.755]     {
[17:42:57.755]         {
[17:42:57.755]             ...future.startTime <- base::Sys.time()
[17:42:57.755]             {
[17:42:57.755]                 {
[17:42:57.755]                   {
[17:42:57.755]                     {
[17:42:57.755]                       base::local({
[17:42:57.755]                         has_future <- base::requireNamespace("future", 
[17:42:57.755]                           quietly = TRUE)
[17:42:57.755]                         if (has_future) {
[17:42:57.755]                           ns <- base::getNamespace("future")
[17:42:57.755]                           version <- ns[[".package"]][["version"]]
[17:42:57.755]                           if (is.null(version)) 
[17:42:57.755]                             version <- utils::packageVersion("future")
[17:42:57.755]                         }
[17:42:57.755]                         else {
[17:42:57.755]                           version <- NULL
[17:42:57.755]                         }
[17:42:57.755]                         if (!has_future || version < "1.8.0") {
[17:42:57.755]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:57.755]                             "", base::R.version$version.string), 
[17:42:57.755]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:57.755]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:57.755]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:57.755]                               "release", "version")], collapse = " "), 
[17:42:57.755]                             hostname = base::Sys.info()[["nodename"]])
[17:42:57.755]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:57.755]                             info)
[17:42:57.755]                           info <- base::paste(info, collapse = "; ")
[17:42:57.755]                           if (!has_future) {
[17:42:57.755]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:57.755]                               info)
[17:42:57.755]                           }
[17:42:57.755]                           else {
[17:42:57.755]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:57.755]                               info, version)
[17:42:57.755]                           }
[17:42:57.755]                           base::stop(msg)
[17:42:57.755]                         }
[17:42:57.755]                       })
[17:42:57.755]                     }
[17:42:57.755]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:57.755]                     base::options(mc.cores = 1L)
[17:42:57.755]                   }
[17:42:57.755]                   options(future.plan = NULL)
[17:42:57.755]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.755]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:57.755]                 }
[17:42:57.755]                 ...future.workdir <- getwd()
[17:42:57.755]             }
[17:42:57.755]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:57.755]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:57.755]         }
[17:42:57.755]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:57.755]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:57.755]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:57.755]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:57.755]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:57.755]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:57.755]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:57.755]             base::names(...future.oldOptions))
[17:42:57.755]     }
[17:42:57.755]     if (FALSE) {
[17:42:57.755]     }
[17:42:57.755]     else {
[17:42:57.755]         if (TRUE) {
[17:42:57.755]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:57.755]                 open = "w")
[17:42:57.755]         }
[17:42:57.755]         else {
[17:42:57.755]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:57.755]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:57.755]         }
[17:42:57.755]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:57.755]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:57.755]             base::sink(type = "output", split = FALSE)
[17:42:57.755]             base::close(...future.stdout)
[17:42:57.755]         }, add = TRUE)
[17:42:57.755]     }
[17:42:57.755]     ...future.frame <- base::sys.nframe()
[17:42:57.755]     ...future.conditions <- base::list()
[17:42:57.755]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:57.755]     if (FALSE) {
[17:42:57.755]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:57.755]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:57.755]     }
[17:42:57.755]     ...future.result <- base::tryCatch({
[17:42:57.755]         base::withCallingHandlers({
[17:42:57.755]             ...future.value <- base::withVisible(base::local({
[17:42:57.755]                 withCallingHandlers({
[17:42:57.755]                   {
[17:42:57.755]                     ii
[17:42:57.755]                   }
[17:42:57.755]                 }, immediateCondition = function(cond) {
[17:42:57.755]                   save_rds <- function (object, pathname, ...) 
[17:42:57.755]                   {
[17:42:57.755]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:57.755]                     if (file_test("-f", pathname_tmp)) {
[17:42:57.755]                       fi_tmp <- file.info(pathname_tmp)
[17:42:57.755]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:57.755]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:57.755]                         fi_tmp[["mtime"]])
[17:42:57.755]                     }
[17:42:57.755]                     tryCatch({
[17:42:57.755]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:57.755]                     }, error = function(ex) {
[17:42:57.755]                       msg <- conditionMessage(ex)
[17:42:57.755]                       fi_tmp <- file.info(pathname_tmp)
[17:42:57.755]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:57.755]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:57.755]                         fi_tmp[["mtime"]], msg)
[17:42:57.755]                       ex$message <- msg
[17:42:57.755]                       stop(ex)
[17:42:57.755]                     })
[17:42:57.755]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:57.755]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:57.755]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:57.755]                       fi_tmp <- file.info(pathname_tmp)
[17:42:57.755]                       fi <- file.info(pathname)
[17:42:57.755]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:57.755]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:57.755]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:57.755]                         fi[["size"]], fi[["mtime"]])
[17:42:57.755]                       stop(msg)
[17:42:57.755]                     }
[17:42:57.755]                     invisible(pathname)
[17:42:57.755]                   }
[17:42:57.755]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:57.755]                     rootPath = tempdir()) 
[17:42:57.755]                   {
[17:42:57.755]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:57.755]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:57.755]                       tmpdir = path, fileext = ".rds")
[17:42:57.755]                     save_rds(obj, file)
[17:42:57.755]                   }
[17:42:57.755]                   saveImmediateCondition(cond, path = "/tmp/Rtmpie37tE/.future/immediateConditions")
[17:42:57.755]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.755]                   {
[17:42:57.755]                     inherits <- base::inherits
[17:42:57.755]                     invokeRestart <- base::invokeRestart
[17:42:57.755]                     is.null <- base::is.null
[17:42:57.755]                     muffled <- FALSE
[17:42:57.755]                     if (inherits(cond, "message")) {
[17:42:57.755]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:57.755]                       if (muffled) 
[17:42:57.755]                         invokeRestart("muffleMessage")
[17:42:57.755]                     }
[17:42:57.755]                     else if (inherits(cond, "warning")) {
[17:42:57.755]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:57.755]                       if (muffled) 
[17:42:57.755]                         invokeRestart("muffleWarning")
[17:42:57.755]                     }
[17:42:57.755]                     else if (inherits(cond, "condition")) {
[17:42:57.755]                       if (!is.null(pattern)) {
[17:42:57.755]                         computeRestarts <- base::computeRestarts
[17:42:57.755]                         grepl <- base::grepl
[17:42:57.755]                         restarts <- computeRestarts(cond)
[17:42:57.755]                         for (restart in restarts) {
[17:42:57.755]                           name <- restart$name
[17:42:57.755]                           if (is.null(name)) 
[17:42:57.755]                             next
[17:42:57.755]                           if (!grepl(pattern, name)) 
[17:42:57.755]                             next
[17:42:57.755]                           invokeRestart(restart)
[17:42:57.755]                           muffled <- TRUE
[17:42:57.755]                           break
[17:42:57.755]                         }
[17:42:57.755]                       }
[17:42:57.755]                     }
[17:42:57.755]                     invisible(muffled)
[17:42:57.755]                   }
[17:42:57.755]                   muffleCondition(cond)
[17:42:57.755]                 })
[17:42:57.755]             }))
[17:42:57.755]             future::FutureResult(value = ...future.value$value, 
[17:42:57.755]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.755]                   ...future.rng), globalenv = if (FALSE) 
[17:42:57.755]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:57.755]                     ...future.globalenv.names))
[17:42:57.755]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:57.755]         }, condition = base::local({
[17:42:57.755]             c <- base::c
[17:42:57.755]             inherits <- base::inherits
[17:42:57.755]             invokeRestart <- base::invokeRestart
[17:42:57.755]             length <- base::length
[17:42:57.755]             list <- base::list
[17:42:57.755]             seq.int <- base::seq.int
[17:42:57.755]             signalCondition <- base::signalCondition
[17:42:57.755]             sys.calls <- base::sys.calls
[17:42:57.755]             `[[` <- base::`[[`
[17:42:57.755]             `+` <- base::`+`
[17:42:57.755]             `<<-` <- base::`<<-`
[17:42:57.755]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:57.755]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:57.755]                   3L)]
[17:42:57.755]             }
[17:42:57.755]             function(cond) {
[17:42:57.755]                 is_error <- inherits(cond, "error")
[17:42:57.755]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:57.755]                   NULL)
[17:42:57.755]                 if (is_error) {
[17:42:57.755]                   sessionInformation <- function() {
[17:42:57.755]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:57.755]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:57.755]                       search = base::search(), system = base::Sys.info())
[17:42:57.755]                   }
[17:42:57.755]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.755]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:57.755]                     cond$call), session = sessionInformation(), 
[17:42:57.755]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:57.755]                   signalCondition(cond)
[17:42:57.755]                 }
[17:42:57.755]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:57.755]                 "immediateCondition"))) {
[17:42:57.755]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:57.755]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.755]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:57.755]                   if (TRUE && !signal) {
[17:42:57.755]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.755]                     {
[17:42:57.755]                       inherits <- base::inherits
[17:42:57.755]                       invokeRestart <- base::invokeRestart
[17:42:57.755]                       is.null <- base::is.null
[17:42:57.755]                       muffled <- FALSE
[17:42:57.755]                       if (inherits(cond, "message")) {
[17:42:57.755]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.755]                         if (muffled) 
[17:42:57.755]                           invokeRestart("muffleMessage")
[17:42:57.755]                       }
[17:42:57.755]                       else if (inherits(cond, "warning")) {
[17:42:57.755]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.755]                         if (muffled) 
[17:42:57.755]                           invokeRestart("muffleWarning")
[17:42:57.755]                       }
[17:42:57.755]                       else if (inherits(cond, "condition")) {
[17:42:57.755]                         if (!is.null(pattern)) {
[17:42:57.755]                           computeRestarts <- base::computeRestarts
[17:42:57.755]                           grepl <- base::grepl
[17:42:57.755]                           restarts <- computeRestarts(cond)
[17:42:57.755]                           for (restart in restarts) {
[17:42:57.755]                             name <- restart$name
[17:42:57.755]                             if (is.null(name)) 
[17:42:57.755]                               next
[17:42:57.755]                             if (!grepl(pattern, name)) 
[17:42:57.755]                               next
[17:42:57.755]                             invokeRestart(restart)
[17:42:57.755]                             muffled <- TRUE
[17:42:57.755]                             break
[17:42:57.755]                           }
[17:42:57.755]                         }
[17:42:57.755]                       }
[17:42:57.755]                       invisible(muffled)
[17:42:57.755]                     }
[17:42:57.755]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.755]                   }
[17:42:57.755]                 }
[17:42:57.755]                 else {
[17:42:57.755]                   if (TRUE) {
[17:42:57.755]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.755]                     {
[17:42:57.755]                       inherits <- base::inherits
[17:42:57.755]                       invokeRestart <- base::invokeRestart
[17:42:57.755]                       is.null <- base::is.null
[17:42:57.755]                       muffled <- FALSE
[17:42:57.755]                       if (inherits(cond, "message")) {
[17:42:57.755]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.755]                         if (muffled) 
[17:42:57.755]                           invokeRestart("muffleMessage")
[17:42:57.755]                       }
[17:42:57.755]                       else if (inherits(cond, "warning")) {
[17:42:57.755]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.755]                         if (muffled) 
[17:42:57.755]                           invokeRestart("muffleWarning")
[17:42:57.755]                       }
[17:42:57.755]                       else if (inherits(cond, "condition")) {
[17:42:57.755]                         if (!is.null(pattern)) {
[17:42:57.755]                           computeRestarts <- base::computeRestarts
[17:42:57.755]                           grepl <- base::grepl
[17:42:57.755]                           restarts <- computeRestarts(cond)
[17:42:57.755]                           for (restart in restarts) {
[17:42:57.755]                             name <- restart$name
[17:42:57.755]                             if (is.null(name)) 
[17:42:57.755]                               next
[17:42:57.755]                             if (!grepl(pattern, name)) 
[17:42:57.755]                               next
[17:42:57.755]                             invokeRestart(restart)
[17:42:57.755]                             muffled <- TRUE
[17:42:57.755]                             break
[17:42:57.755]                           }
[17:42:57.755]                         }
[17:42:57.755]                       }
[17:42:57.755]                       invisible(muffled)
[17:42:57.755]                     }
[17:42:57.755]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.755]                   }
[17:42:57.755]                 }
[17:42:57.755]             }
[17:42:57.755]         }))
[17:42:57.755]     }, error = function(ex) {
[17:42:57.755]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:57.755]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.755]                 ...future.rng), started = ...future.startTime, 
[17:42:57.755]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:57.755]             version = "1.8"), class = "FutureResult")
[17:42:57.755]     }, finally = {
[17:42:57.755]         if (!identical(...future.workdir, getwd())) 
[17:42:57.755]             setwd(...future.workdir)
[17:42:57.755]         {
[17:42:57.755]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:57.755]                 ...future.oldOptions$nwarnings <- NULL
[17:42:57.755]             }
[17:42:57.755]             base::options(...future.oldOptions)
[17:42:57.755]             if (.Platform$OS.type == "windows") {
[17:42:57.755]                 old_names <- names(...future.oldEnvVars)
[17:42:57.755]                 envs <- base::Sys.getenv()
[17:42:57.755]                 names <- names(envs)
[17:42:57.755]                 common <- intersect(names, old_names)
[17:42:57.755]                 added <- setdiff(names, old_names)
[17:42:57.755]                 removed <- setdiff(old_names, names)
[17:42:57.755]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:57.755]                   envs[common]]
[17:42:57.755]                 NAMES <- toupper(changed)
[17:42:57.755]                 args <- list()
[17:42:57.755]                 for (kk in seq_along(NAMES)) {
[17:42:57.755]                   name <- changed[[kk]]
[17:42:57.755]                   NAME <- NAMES[[kk]]
[17:42:57.755]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.755]                     next
[17:42:57.755]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.755]                 }
[17:42:57.755]                 NAMES <- toupper(added)
[17:42:57.755]                 for (kk in seq_along(NAMES)) {
[17:42:57.755]                   name <- added[[kk]]
[17:42:57.755]                   NAME <- NAMES[[kk]]
[17:42:57.755]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.755]                     next
[17:42:57.755]                   args[[name]] <- ""
[17:42:57.755]                 }
[17:42:57.755]                 NAMES <- toupper(removed)
[17:42:57.755]                 for (kk in seq_along(NAMES)) {
[17:42:57.755]                   name <- removed[[kk]]
[17:42:57.755]                   NAME <- NAMES[[kk]]
[17:42:57.755]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.755]                     next
[17:42:57.755]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.755]                 }
[17:42:57.755]                 if (length(args) > 0) 
[17:42:57.755]                   base::do.call(base::Sys.setenv, args = args)
[17:42:57.755]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:57.755]             }
[17:42:57.755]             else {
[17:42:57.755]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:57.755]             }
[17:42:57.755]             {
[17:42:57.755]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:57.755]                   0L) {
[17:42:57.755]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:57.755]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:57.755]                   base::options(opts)
[17:42:57.755]                 }
[17:42:57.755]                 {
[17:42:57.755]                   {
[17:42:57.755]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:57.755]                     NULL
[17:42:57.755]                   }
[17:42:57.755]                   options(future.plan = NULL)
[17:42:57.755]                   if (is.na(NA_character_)) 
[17:42:57.755]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.755]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:57.755]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:57.755]                     envir = parent.frame()) 
[17:42:57.755]                   {
[17:42:57.755]                     default_workers <- missing(workers)
[17:42:57.755]                     if (is.function(workers)) 
[17:42:57.755]                       workers <- workers()
[17:42:57.755]                     workers <- structure(as.integer(workers), 
[17:42:57.755]                       class = class(workers))
[17:42:57.755]                     stop_if_not(is.finite(workers), workers >= 
[17:42:57.755]                       1L)
[17:42:57.755]                     if ((workers == 1L && !inherits(workers, 
[17:42:57.755]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:57.755]                       if (default_workers) 
[17:42:57.755]                         supportsMulticore(warn = TRUE)
[17:42:57.755]                       return(sequential(..., envir = envir))
[17:42:57.755]                     }
[17:42:57.755]                     oopts <- options(mc.cores = workers)
[17:42:57.755]                     on.exit(options(oopts))
[17:42:57.755]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:57.755]                       envir = envir)
[17:42:57.755]                     if (!future$lazy) 
[17:42:57.755]                       future <- run(future)
[17:42:57.755]                     invisible(future)
[17:42:57.755]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:57.755]                 }
[17:42:57.755]             }
[17:42:57.755]         }
[17:42:57.755]     })
[17:42:57.755]     if (TRUE) {
[17:42:57.755]         base::sink(type = "output", split = FALSE)
[17:42:57.755]         if (TRUE) {
[17:42:57.755]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:57.755]         }
[17:42:57.755]         else {
[17:42:57.755]             ...future.result["stdout"] <- base::list(NULL)
[17:42:57.755]         }
[17:42:57.755]         base::close(...future.stdout)
[17:42:57.755]         ...future.stdout <- NULL
[17:42:57.755]     }
[17:42:57.755]     ...future.result$conditions <- ...future.conditions
[17:42:57.755]     ...future.result$finished <- base::Sys.time()
[17:42:57.755]     ...future.result
[17:42:57.755] }
[17:42:57.759] requestCore(): workers = 2
[17:42:57.760] Poll #1 (0): usedCores() = 2, workers = 2
[17:42:57.787] MulticoreFuture started
 - Resolving 4 multicore futures
[17:42:57.788] plan(): Setting new future strategy stack:
[17:42:57.789] List of future strategies:
[17:42:57.789] 1. sequential:
[17:42:57.789]    - args: function (..., envir = parent.frame())
[17:42:57.789]    - tweaked: FALSE
[17:42:57.789]    - call: NULL
[17:42:57.790] plan(): nbrOfWorkers() = 1
[17:42:57.792] plan(): Setting new future strategy stack:
[17:42:57.792] List of future strategies:
[17:42:57.792] 1. multicore:
[17:42:57.792]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:57.792]    - tweaked: FALSE
[17:42:57.792]    - call: plan(multicore)
[17:42:57.798] plan(): nbrOfWorkers() = 2
*** multicore(..., globals = FALSE) and errors
[17:42:57.802] getGlobalsAndPackages() ...
[17:42:57.803] Not searching for globals
[17:42:57.803] - globals: [0] <none>
[17:42:57.803] getGlobalsAndPackages() ... DONE
[17:42:57.804] Packages needed by the future expression (n = 0): <none>
[17:42:57.804] Packages needed by future strategies (n = 0): <none>
[17:42:57.804] {
[17:42:57.804]     {
[17:42:57.804]         {
[17:42:57.804]             ...future.startTime <- base::Sys.time()
[17:42:57.804]             {
[17:42:57.804]                 {
[17:42:57.804]                   {
[17:42:57.804]                     {
[17:42:57.804]                       base::local({
[17:42:57.804]                         has_future <- base::requireNamespace("future", 
[17:42:57.804]                           quietly = TRUE)
[17:42:57.804]                         if (has_future) {
[17:42:57.804]                           ns <- base::getNamespace("future")
[17:42:57.804]                           version <- ns[[".package"]][["version"]]
[17:42:57.804]                           if (is.null(version)) 
[17:42:57.804]                             version <- utils::packageVersion("future")
[17:42:57.804]                         }
[17:42:57.804]                         else {
[17:42:57.804]                           version <- NULL
[17:42:57.804]                         }
[17:42:57.804]                         if (!has_future || version < "1.8.0") {
[17:42:57.804]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:57.804]                             "", base::R.version$version.string), 
[17:42:57.804]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:57.804]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:57.804]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:57.804]                               "release", "version")], collapse = " "), 
[17:42:57.804]                             hostname = base::Sys.info()[["nodename"]])
[17:42:57.804]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:57.804]                             info)
[17:42:57.804]                           info <- base::paste(info, collapse = "; ")
[17:42:57.804]                           if (!has_future) {
[17:42:57.804]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:57.804]                               info)
[17:42:57.804]                           }
[17:42:57.804]                           else {
[17:42:57.804]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:57.804]                               info, version)
[17:42:57.804]                           }
[17:42:57.804]                           base::stop(msg)
[17:42:57.804]                         }
[17:42:57.804]                       })
[17:42:57.804]                     }
[17:42:57.804]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:57.804]                     base::options(mc.cores = 1L)
[17:42:57.804]                   }
[17:42:57.804]                   options(future.plan = NULL)
[17:42:57.804]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.804]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:57.804]                 }
[17:42:57.804]                 ...future.workdir <- getwd()
[17:42:57.804]             }
[17:42:57.804]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:57.804]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:57.804]         }
[17:42:57.804]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:57.804]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:57.804]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:57.804]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:57.804]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:57.804]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:57.804]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:57.804]             base::names(...future.oldOptions))
[17:42:57.804]     }
[17:42:57.804]     if (FALSE) {
[17:42:57.804]     }
[17:42:57.804]     else {
[17:42:57.804]         if (TRUE) {
[17:42:57.804]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:57.804]                 open = "w")
[17:42:57.804]         }
[17:42:57.804]         else {
[17:42:57.804]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:57.804]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:57.804]         }
[17:42:57.804]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:57.804]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:57.804]             base::sink(type = "output", split = FALSE)
[17:42:57.804]             base::close(...future.stdout)
[17:42:57.804]         }, add = TRUE)
[17:42:57.804]     }
[17:42:57.804]     ...future.frame <- base::sys.nframe()
[17:42:57.804]     ...future.conditions <- base::list()
[17:42:57.804]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:57.804]     if (FALSE) {
[17:42:57.804]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:57.804]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:57.804]     }
[17:42:57.804]     ...future.result <- base::tryCatch({
[17:42:57.804]         base::withCallingHandlers({
[17:42:57.804]             ...future.value <- base::withVisible(base::local({
[17:42:57.804]                 withCallingHandlers({
[17:42:57.804]                   {
[17:42:57.804]                     stop("Whoops!")
[17:42:57.804]                     1
[17:42:57.804]                   }
[17:42:57.804]                 }, immediateCondition = function(cond) {
[17:42:57.804]                   save_rds <- function (object, pathname, ...) 
[17:42:57.804]                   {
[17:42:57.804]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:57.804]                     if (file_test("-f", pathname_tmp)) {
[17:42:57.804]                       fi_tmp <- file.info(pathname_tmp)
[17:42:57.804]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:57.804]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:57.804]                         fi_tmp[["mtime"]])
[17:42:57.804]                     }
[17:42:57.804]                     tryCatch({
[17:42:57.804]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:57.804]                     }, error = function(ex) {
[17:42:57.804]                       msg <- conditionMessage(ex)
[17:42:57.804]                       fi_tmp <- file.info(pathname_tmp)
[17:42:57.804]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:57.804]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:57.804]                         fi_tmp[["mtime"]], msg)
[17:42:57.804]                       ex$message <- msg
[17:42:57.804]                       stop(ex)
[17:42:57.804]                     })
[17:42:57.804]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:57.804]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:57.804]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:57.804]                       fi_tmp <- file.info(pathname_tmp)
[17:42:57.804]                       fi <- file.info(pathname)
[17:42:57.804]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:57.804]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:57.804]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:57.804]                         fi[["size"]], fi[["mtime"]])
[17:42:57.804]                       stop(msg)
[17:42:57.804]                     }
[17:42:57.804]                     invisible(pathname)
[17:42:57.804]                   }
[17:42:57.804]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:57.804]                     rootPath = tempdir()) 
[17:42:57.804]                   {
[17:42:57.804]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:57.804]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:57.804]                       tmpdir = path, fileext = ".rds")
[17:42:57.804]                     save_rds(obj, file)
[17:42:57.804]                   }
[17:42:57.804]                   saveImmediateCondition(cond, path = "/tmp/Rtmpie37tE/.future/immediateConditions")
[17:42:57.804]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.804]                   {
[17:42:57.804]                     inherits <- base::inherits
[17:42:57.804]                     invokeRestart <- base::invokeRestart
[17:42:57.804]                     is.null <- base::is.null
[17:42:57.804]                     muffled <- FALSE
[17:42:57.804]                     if (inherits(cond, "message")) {
[17:42:57.804]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:57.804]                       if (muffled) 
[17:42:57.804]                         invokeRestart("muffleMessage")
[17:42:57.804]                     }
[17:42:57.804]                     else if (inherits(cond, "warning")) {
[17:42:57.804]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:57.804]                       if (muffled) 
[17:42:57.804]                         invokeRestart("muffleWarning")
[17:42:57.804]                     }
[17:42:57.804]                     else if (inherits(cond, "condition")) {
[17:42:57.804]                       if (!is.null(pattern)) {
[17:42:57.804]                         computeRestarts <- base::computeRestarts
[17:42:57.804]                         grepl <- base::grepl
[17:42:57.804]                         restarts <- computeRestarts(cond)
[17:42:57.804]                         for (restart in restarts) {
[17:42:57.804]                           name <- restart$name
[17:42:57.804]                           if (is.null(name)) 
[17:42:57.804]                             next
[17:42:57.804]                           if (!grepl(pattern, name)) 
[17:42:57.804]                             next
[17:42:57.804]                           invokeRestart(restart)
[17:42:57.804]                           muffled <- TRUE
[17:42:57.804]                           break
[17:42:57.804]                         }
[17:42:57.804]                       }
[17:42:57.804]                     }
[17:42:57.804]                     invisible(muffled)
[17:42:57.804]                   }
[17:42:57.804]                   muffleCondition(cond)
[17:42:57.804]                 })
[17:42:57.804]             }))
[17:42:57.804]             future::FutureResult(value = ...future.value$value, 
[17:42:57.804]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.804]                   ...future.rng), globalenv = if (FALSE) 
[17:42:57.804]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:57.804]                     ...future.globalenv.names))
[17:42:57.804]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:57.804]         }, condition = base::local({
[17:42:57.804]             c <- base::c
[17:42:57.804]             inherits <- base::inherits
[17:42:57.804]             invokeRestart <- base::invokeRestart
[17:42:57.804]             length <- base::length
[17:42:57.804]             list <- base::list
[17:42:57.804]             seq.int <- base::seq.int
[17:42:57.804]             signalCondition <- base::signalCondition
[17:42:57.804]             sys.calls <- base::sys.calls
[17:42:57.804]             `[[` <- base::`[[`
[17:42:57.804]             `+` <- base::`+`
[17:42:57.804]             `<<-` <- base::`<<-`
[17:42:57.804]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:57.804]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:57.804]                   3L)]
[17:42:57.804]             }
[17:42:57.804]             function(cond) {
[17:42:57.804]                 is_error <- inherits(cond, "error")
[17:42:57.804]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:57.804]                   NULL)
[17:42:57.804]                 if (is_error) {
[17:42:57.804]                   sessionInformation <- function() {
[17:42:57.804]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:57.804]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:57.804]                       search = base::search(), system = base::Sys.info())
[17:42:57.804]                   }
[17:42:57.804]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.804]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:57.804]                     cond$call), session = sessionInformation(), 
[17:42:57.804]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:57.804]                   signalCondition(cond)
[17:42:57.804]                 }
[17:42:57.804]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:57.804]                 "immediateCondition"))) {
[17:42:57.804]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:57.804]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.804]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:57.804]                   if (TRUE && !signal) {
[17:42:57.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.804]                     {
[17:42:57.804]                       inherits <- base::inherits
[17:42:57.804]                       invokeRestart <- base::invokeRestart
[17:42:57.804]                       is.null <- base::is.null
[17:42:57.804]                       muffled <- FALSE
[17:42:57.804]                       if (inherits(cond, "message")) {
[17:42:57.804]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.804]                         if (muffled) 
[17:42:57.804]                           invokeRestart("muffleMessage")
[17:42:57.804]                       }
[17:42:57.804]                       else if (inherits(cond, "warning")) {
[17:42:57.804]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.804]                         if (muffled) 
[17:42:57.804]                           invokeRestart("muffleWarning")
[17:42:57.804]                       }
[17:42:57.804]                       else if (inherits(cond, "condition")) {
[17:42:57.804]                         if (!is.null(pattern)) {
[17:42:57.804]                           computeRestarts <- base::computeRestarts
[17:42:57.804]                           grepl <- base::grepl
[17:42:57.804]                           restarts <- computeRestarts(cond)
[17:42:57.804]                           for (restart in restarts) {
[17:42:57.804]                             name <- restart$name
[17:42:57.804]                             if (is.null(name)) 
[17:42:57.804]                               next
[17:42:57.804]                             if (!grepl(pattern, name)) 
[17:42:57.804]                               next
[17:42:57.804]                             invokeRestart(restart)
[17:42:57.804]                             muffled <- TRUE
[17:42:57.804]                             break
[17:42:57.804]                           }
[17:42:57.804]                         }
[17:42:57.804]                       }
[17:42:57.804]                       invisible(muffled)
[17:42:57.804]                     }
[17:42:57.804]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.804]                   }
[17:42:57.804]                 }
[17:42:57.804]                 else {
[17:42:57.804]                   if (TRUE) {
[17:42:57.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.804]                     {
[17:42:57.804]                       inherits <- base::inherits
[17:42:57.804]                       invokeRestart <- base::invokeRestart
[17:42:57.804]                       is.null <- base::is.null
[17:42:57.804]                       muffled <- FALSE
[17:42:57.804]                       if (inherits(cond, "message")) {
[17:42:57.804]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.804]                         if (muffled) 
[17:42:57.804]                           invokeRestart("muffleMessage")
[17:42:57.804]                       }
[17:42:57.804]                       else if (inherits(cond, "warning")) {
[17:42:57.804]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.804]                         if (muffled) 
[17:42:57.804]                           invokeRestart("muffleWarning")
[17:42:57.804]                       }
[17:42:57.804]                       else if (inherits(cond, "condition")) {
[17:42:57.804]                         if (!is.null(pattern)) {
[17:42:57.804]                           computeRestarts <- base::computeRestarts
[17:42:57.804]                           grepl <- base::grepl
[17:42:57.804]                           restarts <- computeRestarts(cond)
[17:42:57.804]                           for (restart in restarts) {
[17:42:57.804]                             name <- restart$name
[17:42:57.804]                             if (is.null(name)) 
[17:42:57.804]                               next
[17:42:57.804]                             if (!grepl(pattern, name)) 
[17:42:57.804]                               next
[17:42:57.804]                             invokeRestart(restart)
[17:42:57.804]                             muffled <- TRUE
[17:42:57.804]                             break
[17:42:57.804]                           }
[17:42:57.804]                         }
[17:42:57.804]                       }
[17:42:57.804]                       invisible(muffled)
[17:42:57.804]                     }
[17:42:57.804]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.804]                   }
[17:42:57.804]                 }
[17:42:57.804]             }
[17:42:57.804]         }))
[17:42:57.804]     }, error = function(ex) {
[17:42:57.804]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:57.804]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.804]                 ...future.rng), started = ...future.startTime, 
[17:42:57.804]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:57.804]             version = "1.8"), class = "FutureResult")
[17:42:57.804]     }, finally = {
[17:42:57.804]         if (!identical(...future.workdir, getwd())) 
[17:42:57.804]             setwd(...future.workdir)
[17:42:57.804]         {
[17:42:57.804]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:57.804]                 ...future.oldOptions$nwarnings <- NULL
[17:42:57.804]             }
[17:42:57.804]             base::options(...future.oldOptions)
[17:42:57.804]             if (.Platform$OS.type == "windows") {
[17:42:57.804]                 old_names <- names(...future.oldEnvVars)
[17:42:57.804]                 envs <- base::Sys.getenv()
[17:42:57.804]                 names <- names(envs)
[17:42:57.804]                 common <- intersect(names, old_names)
[17:42:57.804]                 added <- setdiff(names, old_names)
[17:42:57.804]                 removed <- setdiff(old_names, names)
[17:42:57.804]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:57.804]                   envs[common]]
[17:42:57.804]                 NAMES <- toupper(changed)
[17:42:57.804]                 args <- list()
[17:42:57.804]                 for (kk in seq_along(NAMES)) {
[17:42:57.804]                   name <- changed[[kk]]
[17:42:57.804]                   NAME <- NAMES[[kk]]
[17:42:57.804]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.804]                     next
[17:42:57.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.804]                 }
[17:42:57.804]                 NAMES <- toupper(added)
[17:42:57.804]                 for (kk in seq_along(NAMES)) {
[17:42:57.804]                   name <- added[[kk]]
[17:42:57.804]                   NAME <- NAMES[[kk]]
[17:42:57.804]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.804]                     next
[17:42:57.804]                   args[[name]] <- ""
[17:42:57.804]                 }
[17:42:57.804]                 NAMES <- toupper(removed)
[17:42:57.804]                 for (kk in seq_along(NAMES)) {
[17:42:57.804]                   name <- removed[[kk]]
[17:42:57.804]                   NAME <- NAMES[[kk]]
[17:42:57.804]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.804]                     next
[17:42:57.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.804]                 }
[17:42:57.804]                 if (length(args) > 0) 
[17:42:57.804]                   base::do.call(base::Sys.setenv, args = args)
[17:42:57.804]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:57.804]             }
[17:42:57.804]             else {
[17:42:57.804]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:57.804]             }
[17:42:57.804]             {
[17:42:57.804]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:57.804]                   0L) {
[17:42:57.804]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:57.804]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:57.804]                   base::options(opts)
[17:42:57.804]                 }
[17:42:57.804]                 {
[17:42:57.804]                   {
[17:42:57.804]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:57.804]                     NULL
[17:42:57.804]                   }
[17:42:57.804]                   options(future.plan = NULL)
[17:42:57.804]                   if (is.na(NA_character_)) 
[17:42:57.804]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.804]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:57.804]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:57.804]                     envir = parent.frame()) 
[17:42:57.804]                   {
[17:42:57.804]                     default_workers <- missing(workers)
[17:42:57.804]                     if (is.function(workers)) 
[17:42:57.804]                       workers <- workers()
[17:42:57.804]                     workers <- structure(as.integer(workers), 
[17:42:57.804]                       class = class(workers))
[17:42:57.804]                     stop_if_not(is.finite(workers), workers >= 
[17:42:57.804]                       1L)
[17:42:57.804]                     if ((workers == 1L && !inherits(workers, 
[17:42:57.804]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:57.804]                       if (default_workers) 
[17:42:57.804]                         supportsMulticore(warn = TRUE)
[17:42:57.804]                       return(sequential(..., envir = envir))
[17:42:57.804]                     }
[17:42:57.804]                     oopts <- options(mc.cores = workers)
[17:42:57.804]                     on.exit(options(oopts))
[17:42:57.804]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:57.804]                       envir = envir)
[17:42:57.804]                     if (!future$lazy) 
[17:42:57.804]                       future <- run(future)
[17:42:57.804]                     invisible(future)
[17:42:57.804]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:57.804]                 }
[17:42:57.804]             }
[17:42:57.804]         }
[17:42:57.804]     })
[17:42:57.804]     if (TRUE) {
[17:42:57.804]         base::sink(type = "output", split = FALSE)
[17:42:57.804]         if (TRUE) {
[17:42:57.804]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:57.804]         }
[17:42:57.804]         else {
[17:42:57.804]             ...future.result["stdout"] <- base::list(NULL)
[17:42:57.804]         }
[17:42:57.804]         base::close(...future.stdout)
[17:42:57.804]         ...future.stdout <- NULL
[17:42:57.804]     }
[17:42:57.804]     ...future.result$conditions <- ...future.conditions
[17:42:57.804]     ...future.result$finished <- base::Sys.time()
[17:42:57.804]     ...future.result
[17:42:57.804] }
[17:42:57.807] requestCore(): workers = 2
[17:42:57.809] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:42:57.811] plan(): Setting new future strategy stack:
[17:42:57.811] List of future strategies:
[17:42:57.811] 1. sequential:
[17:42:57.811]    - args: function (..., envir = parent.frame())
[17:42:57.811]    - tweaked: FALSE
[17:42:57.811]    - call: NULL
[17:42:57.812] plan(): nbrOfWorkers() = 1
[17:42:57.814] plan(): Setting new future strategy stack:
[17:42:57.814] List of future strategies:
[17:42:57.814] 1. multicore:
[17:42:57.814]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:57.814]    - tweaked: FALSE
[17:42:57.814]    - call: plan(multicore)
[17:42:57.819] plan(): nbrOfWorkers() = 2
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 56280105-ab48-3cfb-51ca-f6f685381758
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:57.828] signalConditions() ...
[17:42:57.828]  - include = ‘immediateCondition’
[17:42:57.828]  - exclude = 
[17:42:57.828]  - resignal = FALSE
[17:42:57.828]  - Number of conditions: 1
[17:42:57.828] signalConditions() ... done
[17:42:57.829] signalConditions() ...
[17:42:57.829]  - include = ‘immediateCondition’
[17:42:57.829]  - exclude = 
[17:42:57.829]  - resignal = FALSE
[17:42:57.829]  - Number of conditions: 1
[17:42:57.829] signalConditions() ... done
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/Rtmpie37tE/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[17:42:57.830] signalConditions() ...
[17:42:57.834]  - include = ‘immediateCondition’
[17:42:57.834]  - exclude = 
[17:42:57.835]  - resignal = FALSE
[17:42:57.835]  - Number of conditions: 1
[17:42:57.835] signalConditions() ... done
[17:42:57.835] Future state: ‘finished’
[17:42:57.835] signalConditions() ...
[17:42:57.835]  - include = ‘condition’
[17:42:57.835]  - exclude = ‘immediateCondition’
[17:42:57.836]  - resignal = TRUE
[17:42:57.836]  - Number of conditions: 1
[17:42:57.836]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:42:57.836] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/Rtmpie37tE/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[17:42:57.837] signalConditions() ...
[17:42:57.837]  - include = ‘immediateCondition’
[17:42:57.837]  - exclude = 
[17:42:57.838]  - resignal = FALSE
[17:42:57.838]  - Number of conditions: 1
[17:42:57.838] signalConditions() ... done
[17:42:57.838] Future state: ‘finished’
[17:42:57.838] signalConditions() ...
[17:42:57.838]  - include = ‘condition’
[17:42:57.838]  - exclude = ‘immediateCondition’
[17:42:57.838]  - resignal = TRUE
[17:42:57.839]  - Number of conditions: 1
[17:42:57.839]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:42:57.839] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/Rtmpie37tE/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[17:42:57.844] getGlobalsAndPackages() ...
[17:42:57.844] 
[17:42:57.844] - globals: [0] <none>
[17:42:57.845] getGlobalsAndPackages() ... DONE
[17:42:57.845] Packages needed by the future expression (n = 0): <none>
[17:42:57.845] Packages needed by future strategies (n = 0): <none>
[17:42:57.846] {
[17:42:57.846]     {
[17:42:57.846]         {
[17:42:57.846]             ...future.startTime <- base::Sys.time()
[17:42:57.846]             {
[17:42:57.846]                 {
[17:42:57.846]                   {
[17:42:57.846]                     {
[17:42:57.846]                       base::local({
[17:42:57.846]                         has_future <- base::requireNamespace("future", 
[17:42:57.846]                           quietly = TRUE)
[17:42:57.846]                         if (has_future) {
[17:42:57.846]                           ns <- base::getNamespace("future")
[17:42:57.846]                           version <- ns[[".package"]][["version"]]
[17:42:57.846]                           if (is.null(version)) 
[17:42:57.846]                             version <- utils::packageVersion("future")
[17:42:57.846]                         }
[17:42:57.846]                         else {
[17:42:57.846]                           version <- NULL
[17:42:57.846]                         }
[17:42:57.846]                         if (!has_future || version < "1.8.0") {
[17:42:57.846]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:57.846]                             "", base::R.version$version.string), 
[17:42:57.846]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:57.846]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:57.846]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:57.846]                               "release", "version")], collapse = " "), 
[17:42:57.846]                             hostname = base::Sys.info()[["nodename"]])
[17:42:57.846]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:57.846]                             info)
[17:42:57.846]                           info <- base::paste(info, collapse = "; ")
[17:42:57.846]                           if (!has_future) {
[17:42:57.846]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:57.846]                               info)
[17:42:57.846]                           }
[17:42:57.846]                           else {
[17:42:57.846]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:57.846]                               info, version)
[17:42:57.846]                           }
[17:42:57.846]                           base::stop(msg)
[17:42:57.846]                         }
[17:42:57.846]                       })
[17:42:57.846]                     }
[17:42:57.846]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:57.846]                     base::options(mc.cores = 1L)
[17:42:57.846]                   }
[17:42:57.846]                   options(future.plan = NULL)
[17:42:57.846]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.846]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:57.846]                 }
[17:42:57.846]                 ...future.workdir <- getwd()
[17:42:57.846]             }
[17:42:57.846]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:57.846]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:57.846]         }
[17:42:57.846]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:57.846]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:57.846]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:57.846]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:57.846]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:57.846]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:57.846]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:57.846]             base::names(...future.oldOptions))
[17:42:57.846]     }
[17:42:57.846]     if (FALSE) {
[17:42:57.846]     }
[17:42:57.846]     else {
[17:42:57.846]         if (TRUE) {
[17:42:57.846]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:57.846]                 open = "w")
[17:42:57.846]         }
[17:42:57.846]         else {
[17:42:57.846]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:57.846]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:57.846]         }
[17:42:57.846]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:57.846]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:57.846]             base::sink(type = "output", split = FALSE)
[17:42:57.846]             base::close(...future.stdout)
[17:42:57.846]         }, add = TRUE)
[17:42:57.846]     }
[17:42:57.846]     ...future.frame <- base::sys.nframe()
[17:42:57.846]     ...future.conditions <- base::list()
[17:42:57.846]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:57.846]     if (FALSE) {
[17:42:57.846]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:57.846]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:57.846]     }
[17:42:57.846]     ...future.result <- base::tryCatch({
[17:42:57.846]         base::withCallingHandlers({
[17:42:57.846]             ...future.value <- base::withVisible(base::local({
[17:42:57.846]                 withCallingHandlers({
[17:42:57.846]                   {
[17:42:57.846]                     stop(structure(list(message = "boom"), class = c("MyError", 
[17:42:57.846]                       "error", "condition")))
[17:42:57.846]                   }
[17:42:57.846]                 }, immediateCondition = function(cond) {
[17:42:57.846]                   save_rds <- function (object, pathname, ...) 
[17:42:57.846]                   {
[17:42:57.846]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:57.846]                     if (file_test("-f", pathname_tmp)) {
[17:42:57.846]                       fi_tmp <- file.info(pathname_tmp)
[17:42:57.846]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:57.846]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:57.846]                         fi_tmp[["mtime"]])
[17:42:57.846]                     }
[17:42:57.846]                     tryCatch({
[17:42:57.846]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:57.846]                     }, error = function(ex) {
[17:42:57.846]                       msg <- conditionMessage(ex)
[17:42:57.846]                       fi_tmp <- file.info(pathname_tmp)
[17:42:57.846]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:57.846]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:57.846]                         fi_tmp[["mtime"]], msg)
[17:42:57.846]                       ex$message <- msg
[17:42:57.846]                       stop(ex)
[17:42:57.846]                     })
[17:42:57.846]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:57.846]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:57.846]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:57.846]                       fi_tmp <- file.info(pathname_tmp)
[17:42:57.846]                       fi <- file.info(pathname)
[17:42:57.846]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:57.846]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:57.846]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:57.846]                         fi[["size"]], fi[["mtime"]])
[17:42:57.846]                       stop(msg)
[17:42:57.846]                     }
[17:42:57.846]                     invisible(pathname)
[17:42:57.846]                   }
[17:42:57.846]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:57.846]                     rootPath = tempdir()) 
[17:42:57.846]                   {
[17:42:57.846]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:57.846]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:57.846]                       tmpdir = path, fileext = ".rds")
[17:42:57.846]                     save_rds(obj, file)
[17:42:57.846]                   }
[17:42:57.846]                   saveImmediateCondition(cond, path = "/tmp/Rtmpie37tE/.future/immediateConditions")
[17:42:57.846]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.846]                   {
[17:42:57.846]                     inherits <- base::inherits
[17:42:57.846]                     invokeRestart <- base::invokeRestart
[17:42:57.846]                     is.null <- base::is.null
[17:42:57.846]                     muffled <- FALSE
[17:42:57.846]                     if (inherits(cond, "message")) {
[17:42:57.846]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:57.846]                       if (muffled) 
[17:42:57.846]                         invokeRestart("muffleMessage")
[17:42:57.846]                     }
[17:42:57.846]                     else if (inherits(cond, "warning")) {
[17:42:57.846]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:57.846]                       if (muffled) 
[17:42:57.846]                         invokeRestart("muffleWarning")
[17:42:57.846]                     }
[17:42:57.846]                     else if (inherits(cond, "condition")) {
[17:42:57.846]                       if (!is.null(pattern)) {
[17:42:57.846]                         computeRestarts <- base::computeRestarts
[17:42:57.846]                         grepl <- base::grepl
[17:42:57.846]                         restarts <- computeRestarts(cond)
[17:42:57.846]                         for (restart in restarts) {
[17:42:57.846]                           name <- restart$name
[17:42:57.846]                           if (is.null(name)) 
[17:42:57.846]                             next
[17:42:57.846]                           if (!grepl(pattern, name)) 
[17:42:57.846]                             next
[17:42:57.846]                           invokeRestart(restart)
[17:42:57.846]                           muffled <- TRUE
[17:42:57.846]                           break
[17:42:57.846]                         }
[17:42:57.846]                       }
[17:42:57.846]                     }
[17:42:57.846]                     invisible(muffled)
[17:42:57.846]                   }
[17:42:57.846]                   muffleCondition(cond)
[17:42:57.846]                 })
[17:42:57.846]             }))
[17:42:57.846]             future::FutureResult(value = ...future.value$value, 
[17:42:57.846]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.846]                   ...future.rng), globalenv = if (FALSE) 
[17:42:57.846]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:57.846]                     ...future.globalenv.names))
[17:42:57.846]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:57.846]         }, condition = base::local({
[17:42:57.846]             c <- base::c
[17:42:57.846]             inherits <- base::inherits
[17:42:57.846]             invokeRestart <- base::invokeRestart
[17:42:57.846]             length <- base::length
[17:42:57.846]             list <- base::list
[17:42:57.846]             seq.int <- base::seq.int
[17:42:57.846]             signalCondition <- base::signalCondition
[17:42:57.846]             sys.calls <- base::sys.calls
[17:42:57.846]             `[[` <- base::`[[`
[17:42:57.846]             `+` <- base::`+`
[17:42:57.846]             `<<-` <- base::`<<-`
[17:42:57.846]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:57.846]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:57.846]                   3L)]
[17:42:57.846]             }
[17:42:57.846]             function(cond) {
[17:42:57.846]                 is_error <- inherits(cond, "error")
[17:42:57.846]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:57.846]                   NULL)
[17:42:57.846]                 if (is_error) {
[17:42:57.846]                   sessionInformation <- function() {
[17:42:57.846]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:57.846]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:57.846]                       search = base::search(), system = base::Sys.info())
[17:42:57.846]                   }
[17:42:57.846]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.846]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:57.846]                     cond$call), session = sessionInformation(), 
[17:42:57.846]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:57.846]                   signalCondition(cond)
[17:42:57.846]                 }
[17:42:57.846]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:57.846]                 "immediateCondition"))) {
[17:42:57.846]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:57.846]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.846]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:57.846]                   if (TRUE && !signal) {
[17:42:57.846]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.846]                     {
[17:42:57.846]                       inherits <- base::inherits
[17:42:57.846]                       invokeRestart <- base::invokeRestart
[17:42:57.846]                       is.null <- base::is.null
[17:42:57.846]                       muffled <- FALSE
[17:42:57.846]                       if (inherits(cond, "message")) {
[17:42:57.846]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.846]                         if (muffled) 
[17:42:57.846]                           invokeRestart("muffleMessage")
[17:42:57.846]                       }
[17:42:57.846]                       else if (inherits(cond, "warning")) {
[17:42:57.846]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.846]                         if (muffled) 
[17:42:57.846]                           invokeRestart("muffleWarning")
[17:42:57.846]                       }
[17:42:57.846]                       else if (inherits(cond, "condition")) {
[17:42:57.846]                         if (!is.null(pattern)) {
[17:42:57.846]                           computeRestarts <- base::computeRestarts
[17:42:57.846]                           grepl <- base::grepl
[17:42:57.846]                           restarts <- computeRestarts(cond)
[17:42:57.846]                           for (restart in restarts) {
[17:42:57.846]                             name <- restart$name
[17:42:57.846]                             if (is.null(name)) 
[17:42:57.846]                               next
[17:42:57.846]                             if (!grepl(pattern, name)) 
[17:42:57.846]                               next
[17:42:57.846]                             invokeRestart(restart)
[17:42:57.846]                             muffled <- TRUE
[17:42:57.846]                             break
[17:42:57.846]                           }
[17:42:57.846]                         }
[17:42:57.846]                       }
[17:42:57.846]                       invisible(muffled)
[17:42:57.846]                     }
[17:42:57.846]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.846]                   }
[17:42:57.846]                 }
[17:42:57.846]                 else {
[17:42:57.846]                   if (TRUE) {
[17:42:57.846]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.846]                     {
[17:42:57.846]                       inherits <- base::inherits
[17:42:57.846]                       invokeRestart <- base::invokeRestart
[17:42:57.846]                       is.null <- base::is.null
[17:42:57.846]                       muffled <- FALSE
[17:42:57.846]                       if (inherits(cond, "message")) {
[17:42:57.846]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.846]                         if (muffled) 
[17:42:57.846]                           invokeRestart("muffleMessage")
[17:42:57.846]                       }
[17:42:57.846]                       else if (inherits(cond, "warning")) {
[17:42:57.846]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.846]                         if (muffled) 
[17:42:57.846]                           invokeRestart("muffleWarning")
[17:42:57.846]                       }
[17:42:57.846]                       else if (inherits(cond, "condition")) {
[17:42:57.846]                         if (!is.null(pattern)) {
[17:42:57.846]                           computeRestarts <- base::computeRestarts
[17:42:57.846]                           grepl <- base::grepl
[17:42:57.846]                           restarts <- computeRestarts(cond)
[17:42:57.846]                           for (restart in restarts) {
[17:42:57.846]                             name <- restart$name
[17:42:57.846]                             if (is.null(name)) 
[17:42:57.846]                               next
[17:42:57.846]                             if (!grepl(pattern, name)) 
[17:42:57.846]                               next
[17:42:57.846]                             invokeRestart(restart)
[17:42:57.846]                             muffled <- TRUE
[17:42:57.846]                             break
[17:42:57.846]                           }
[17:42:57.846]                         }
[17:42:57.846]                       }
[17:42:57.846]                       invisible(muffled)
[17:42:57.846]                     }
[17:42:57.846]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.846]                   }
[17:42:57.846]                 }
[17:42:57.846]             }
[17:42:57.846]         }))
[17:42:57.846]     }, error = function(ex) {
[17:42:57.846]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:57.846]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.846]                 ...future.rng), started = ...future.startTime, 
[17:42:57.846]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:57.846]             version = "1.8"), class = "FutureResult")
[17:42:57.846]     }, finally = {
[17:42:57.846]         if (!identical(...future.workdir, getwd())) 
[17:42:57.846]             setwd(...future.workdir)
[17:42:57.846]         {
[17:42:57.846]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:57.846]                 ...future.oldOptions$nwarnings <- NULL
[17:42:57.846]             }
[17:42:57.846]             base::options(...future.oldOptions)
[17:42:57.846]             if (.Platform$OS.type == "windows") {
[17:42:57.846]                 old_names <- names(...future.oldEnvVars)
[17:42:57.846]                 envs <- base::Sys.getenv()
[17:42:57.846]                 names <- names(envs)
[17:42:57.846]                 common <- intersect(names, old_names)
[17:42:57.846]                 added <- setdiff(names, old_names)
[17:42:57.846]                 removed <- setdiff(old_names, names)
[17:42:57.846]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:57.846]                   envs[common]]
[17:42:57.846]                 NAMES <- toupper(changed)
[17:42:57.846]                 args <- list()
[17:42:57.846]                 for (kk in seq_along(NAMES)) {
[17:42:57.846]                   name <- changed[[kk]]
[17:42:57.846]                   NAME <- NAMES[[kk]]
[17:42:57.846]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.846]                     next
[17:42:57.846]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.846]                 }
[17:42:57.846]                 NAMES <- toupper(added)
[17:42:57.846]                 for (kk in seq_along(NAMES)) {
[17:42:57.846]                   name <- added[[kk]]
[17:42:57.846]                   NAME <- NAMES[[kk]]
[17:42:57.846]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.846]                     next
[17:42:57.846]                   args[[name]] <- ""
[17:42:57.846]                 }
[17:42:57.846]                 NAMES <- toupper(removed)
[17:42:57.846]                 for (kk in seq_along(NAMES)) {
[17:42:57.846]                   name <- removed[[kk]]
[17:42:57.846]                   NAME <- NAMES[[kk]]
[17:42:57.846]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.846]                     next
[17:42:57.846]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.846]                 }
[17:42:57.846]                 if (length(args) > 0) 
[17:42:57.846]                   base::do.call(base::Sys.setenv, args = args)
[17:42:57.846]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:57.846]             }
[17:42:57.846]             else {
[17:42:57.846]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:57.846]             }
[17:42:57.846]             {
[17:42:57.846]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:57.846]                   0L) {
[17:42:57.846]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:57.846]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:57.846]                   base::options(opts)
[17:42:57.846]                 }
[17:42:57.846]                 {
[17:42:57.846]                   {
[17:42:57.846]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:57.846]                     NULL
[17:42:57.846]                   }
[17:42:57.846]                   options(future.plan = NULL)
[17:42:57.846]                   if (is.na(NA_character_)) 
[17:42:57.846]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.846]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:57.846]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:57.846]                     envir = parent.frame()) 
[17:42:57.846]                   {
[17:42:57.846]                     default_workers <- missing(workers)
[17:42:57.846]                     if (is.function(workers)) 
[17:42:57.846]                       workers <- workers()
[17:42:57.846]                     workers <- structure(as.integer(workers), 
[17:42:57.846]                       class = class(workers))
[17:42:57.846]                     stop_if_not(is.finite(workers), workers >= 
[17:42:57.846]                       1L)
[17:42:57.846]                     if ((workers == 1L && !inherits(workers, 
[17:42:57.846]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:57.846]                       if (default_workers) 
[17:42:57.846]                         supportsMulticore(warn = TRUE)
[17:42:57.846]                       return(sequential(..., envir = envir))
[17:42:57.846]                     }
[17:42:57.846]                     oopts <- options(mc.cores = workers)
[17:42:57.846]                     on.exit(options(oopts))
[17:42:57.846]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:57.846]                       envir = envir)
[17:42:57.846]                     if (!future$lazy) 
[17:42:57.846]                       future <- run(future)
[17:42:57.846]                     invisible(future)
[17:42:57.846]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:57.846]                 }
[17:42:57.846]             }
[17:42:57.846]         }
[17:42:57.846]     })
[17:42:57.846]     if (TRUE) {
[17:42:57.846]         base::sink(type = "output", split = FALSE)
[17:42:57.846]         if (TRUE) {
[17:42:57.846]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:57.846]         }
[17:42:57.846]         else {
[17:42:57.846]             ...future.result["stdout"] <- base::list(NULL)
[17:42:57.846]         }
[17:42:57.846]         base::close(...future.stdout)
[17:42:57.846]         ...future.stdout <- NULL
[17:42:57.846]     }
[17:42:57.846]     ...future.result$conditions <- ...future.conditions
[17:42:57.846]     ...future.result$finished <- base::Sys.time()
[17:42:57.846]     ...future.result
[17:42:57.846] }
[17:42:57.848] requestCore(): workers = 2
[17:42:57.851] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:42:57.852] plan(): Setting new future strategy stack:
[17:42:57.852] List of future strategies:
[17:42:57.852] 1. sequential:
[17:42:57.852]    - args: function (..., envir = parent.frame())
[17:42:57.852]    - tweaked: FALSE
[17:42:57.852]    - call: NULL
[17:42:57.853] plan(): nbrOfWorkers() = 1
[17:42:57.855] plan(): Setting new future strategy stack:
[17:42:57.855] List of future strategies:
[17:42:57.855] 1. multicore:
[17:42:57.855]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:57.855]    - tweaked: FALSE
[17:42:57.855]    - call: plan(multicore)
[17:42:57.860] plan(): nbrOfWorkers() = 2
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 56280105-ab48-3cfb-51ca-f6f685381758
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:57.865] signalConditions() ...
[17:42:57.865]  - include = ‘immediateCondition’
[17:42:57.865]  - exclude = 
[17:42:57.865]  - resignal = FALSE
[17:42:57.865]  - Number of conditions: 1
[17:42:57.866] signalConditions() ... done
[17:42:57.866] signalConditions() ...
[17:42:57.866]  - include = ‘immediateCondition’
[17:42:57.866]  - exclude = 
[17:42:57.866]  - resignal = FALSE
[17:42:57.866]  - Number of conditions: 1
[17:42:57.866] signalConditions() ... done
<MyError: boom>
[17:42:57.867] signalConditions() ...
[17:42:57.867]  - include = ‘immediateCondition’
[17:42:57.867]  - exclude = 
[17:42:57.867]  - resignal = FALSE
[17:42:57.867]  - Number of conditions: 1
[17:42:57.867] signalConditions() ... done
[17:42:57.867] Future state: ‘finished’
[17:42:57.868] signalConditions() ...
[17:42:57.868]  - include = ‘condition’
[17:42:57.868]  - exclude = ‘immediateCondition’
[17:42:57.868]  - resignal = TRUE
[17:42:57.868]  - Number of conditions: 1
[17:42:57.868]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[17:42:57.868] signalConditions() ... done
*** multicore(..., globals = TRUE) without globals
[17:42:57.873] getGlobalsAndPackages() ...
[17:42:57.873] Searching for globals...
[17:42:57.874] - globals found: [1] ‘{’
[17:42:57.874] Searching for globals ... DONE
[17:42:57.874] Resolving globals: FALSE
[17:42:57.875] 
[17:42:57.875] 
[17:42:57.875] getGlobalsAndPackages() ... DONE
[17:42:57.875] Packages needed by the future expression (n = 0): <none>
[17:42:57.876] Packages needed by future strategies (n = 0): <none>
[17:42:57.876] {
[17:42:57.876]     {
[17:42:57.876]         {
[17:42:57.876]             ...future.startTime <- base::Sys.time()
[17:42:57.876]             {
[17:42:57.876]                 {
[17:42:57.876]                   {
[17:42:57.876]                     {
[17:42:57.876]                       base::local({
[17:42:57.876]                         has_future <- base::requireNamespace("future", 
[17:42:57.876]                           quietly = TRUE)
[17:42:57.876]                         if (has_future) {
[17:42:57.876]                           ns <- base::getNamespace("future")
[17:42:57.876]                           version <- ns[[".package"]][["version"]]
[17:42:57.876]                           if (is.null(version)) 
[17:42:57.876]                             version <- utils::packageVersion("future")
[17:42:57.876]                         }
[17:42:57.876]                         else {
[17:42:57.876]                           version <- NULL
[17:42:57.876]                         }
[17:42:57.876]                         if (!has_future || version < "1.8.0") {
[17:42:57.876]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:57.876]                             "", base::R.version$version.string), 
[17:42:57.876]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:57.876]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:57.876]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:57.876]                               "release", "version")], collapse = " "), 
[17:42:57.876]                             hostname = base::Sys.info()[["nodename"]])
[17:42:57.876]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:57.876]                             info)
[17:42:57.876]                           info <- base::paste(info, collapse = "; ")
[17:42:57.876]                           if (!has_future) {
[17:42:57.876]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:57.876]                               info)
[17:42:57.876]                           }
[17:42:57.876]                           else {
[17:42:57.876]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:57.876]                               info, version)
[17:42:57.876]                           }
[17:42:57.876]                           base::stop(msg)
[17:42:57.876]                         }
[17:42:57.876]                       })
[17:42:57.876]                     }
[17:42:57.876]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:57.876]                     base::options(mc.cores = 1L)
[17:42:57.876]                   }
[17:42:57.876]                   options(future.plan = NULL)
[17:42:57.876]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.876]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:57.876]                 }
[17:42:57.876]                 ...future.workdir <- getwd()
[17:42:57.876]             }
[17:42:57.876]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:57.876]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:57.876]         }
[17:42:57.876]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:57.876]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:57.876]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:57.876]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:57.876]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:57.876]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:57.876]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:57.876]             base::names(...future.oldOptions))
[17:42:57.876]     }
[17:42:57.876]     if (FALSE) {
[17:42:57.876]     }
[17:42:57.876]     else {
[17:42:57.876]         if (TRUE) {
[17:42:57.876]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:57.876]                 open = "w")
[17:42:57.876]         }
[17:42:57.876]         else {
[17:42:57.876]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:57.876]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:57.876]         }
[17:42:57.876]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:57.876]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:57.876]             base::sink(type = "output", split = FALSE)
[17:42:57.876]             base::close(...future.stdout)
[17:42:57.876]         }, add = TRUE)
[17:42:57.876]     }
[17:42:57.876]     ...future.frame <- base::sys.nframe()
[17:42:57.876]     ...future.conditions <- base::list()
[17:42:57.876]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:57.876]     if (FALSE) {
[17:42:57.876]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:57.876]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:57.876]     }
[17:42:57.876]     ...future.result <- base::tryCatch({
[17:42:57.876]         base::withCallingHandlers({
[17:42:57.876]             ...future.value <- base::withVisible(base::local({
[17:42:57.876]                 withCallingHandlers({
[17:42:57.876]                   {
[17:42:57.876]                     42L
[17:42:57.876]                   }
[17:42:57.876]                 }, immediateCondition = function(cond) {
[17:42:57.876]                   save_rds <- function (object, pathname, ...) 
[17:42:57.876]                   {
[17:42:57.876]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:57.876]                     if (file_test("-f", pathname_tmp)) {
[17:42:57.876]                       fi_tmp <- file.info(pathname_tmp)
[17:42:57.876]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:57.876]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:57.876]                         fi_tmp[["mtime"]])
[17:42:57.876]                     }
[17:42:57.876]                     tryCatch({
[17:42:57.876]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:57.876]                     }, error = function(ex) {
[17:42:57.876]                       msg <- conditionMessage(ex)
[17:42:57.876]                       fi_tmp <- file.info(pathname_tmp)
[17:42:57.876]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:57.876]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:57.876]                         fi_tmp[["mtime"]], msg)
[17:42:57.876]                       ex$message <- msg
[17:42:57.876]                       stop(ex)
[17:42:57.876]                     })
[17:42:57.876]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:57.876]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:57.876]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:57.876]                       fi_tmp <- file.info(pathname_tmp)
[17:42:57.876]                       fi <- file.info(pathname)
[17:42:57.876]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:57.876]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:57.876]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:57.876]                         fi[["size"]], fi[["mtime"]])
[17:42:57.876]                       stop(msg)
[17:42:57.876]                     }
[17:42:57.876]                     invisible(pathname)
[17:42:57.876]                   }
[17:42:57.876]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:57.876]                     rootPath = tempdir()) 
[17:42:57.876]                   {
[17:42:57.876]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:57.876]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:57.876]                       tmpdir = path, fileext = ".rds")
[17:42:57.876]                     save_rds(obj, file)
[17:42:57.876]                   }
[17:42:57.876]                   saveImmediateCondition(cond, path = "/tmp/Rtmpie37tE/.future/immediateConditions")
[17:42:57.876]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.876]                   {
[17:42:57.876]                     inherits <- base::inherits
[17:42:57.876]                     invokeRestart <- base::invokeRestart
[17:42:57.876]                     is.null <- base::is.null
[17:42:57.876]                     muffled <- FALSE
[17:42:57.876]                     if (inherits(cond, "message")) {
[17:42:57.876]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:57.876]                       if (muffled) 
[17:42:57.876]                         invokeRestart("muffleMessage")
[17:42:57.876]                     }
[17:42:57.876]                     else if (inherits(cond, "warning")) {
[17:42:57.876]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:57.876]                       if (muffled) 
[17:42:57.876]                         invokeRestart("muffleWarning")
[17:42:57.876]                     }
[17:42:57.876]                     else if (inherits(cond, "condition")) {
[17:42:57.876]                       if (!is.null(pattern)) {
[17:42:57.876]                         computeRestarts <- base::computeRestarts
[17:42:57.876]                         grepl <- base::grepl
[17:42:57.876]                         restarts <- computeRestarts(cond)
[17:42:57.876]                         for (restart in restarts) {
[17:42:57.876]                           name <- restart$name
[17:42:57.876]                           if (is.null(name)) 
[17:42:57.876]                             next
[17:42:57.876]                           if (!grepl(pattern, name)) 
[17:42:57.876]                             next
[17:42:57.876]                           invokeRestart(restart)
[17:42:57.876]                           muffled <- TRUE
[17:42:57.876]                           break
[17:42:57.876]                         }
[17:42:57.876]                       }
[17:42:57.876]                     }
[17:42:57.876]                     invisible(muffled)
[17:42:57.876]                   }
[17:42:57.876]                   muffleCondition(cond)
[17:42:57.876]                 })
[17:42:57.876]             }))
[17:42:57.876]             future::FutureResult(value = ...future.value$value, 
[17:42:57.876]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.876]                   ...future.rng), globalenv = if (FALSE) 
[17:42:57.876]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:57.876]                     ...future.globalenv.names))
[17:42:57.876]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:57.876]         }, condition = base::local({
[17:42:57.876]             c <- base::c
[17:42:57.876]             inherits <- base::inherits
[17:42:57.876]             invokeRestart <- base::invokeRestart
[17:42:57.876]             length <- base::length
[17:42:57.876]             list <- base::list
[17:42:57.876]             seq.int <- base::seq.int
[17:42:57.876]             signalCondition <- base::signalCondition
[17:42:57.876]             sys.calls <- base::sys.calls
[17:42:57.876]             `[[` <- base::`[[`
[17:42:57.876]             `+` <- base::`+`
[17:42:57.876]             `<<-` <- base::`<<-`
[17:42:57.876]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:57.876]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:57.876]                   3L)]
[17:42:57.876]             }
[17:42:57.876]             function(cond) {
[17:42:57.876]                 is_error <- inherits(cond, "error")
[17:42:57.876]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:57.876]                   NULL)
[17:42:57.876]                 if (is_error) {
[17:42:57.876]                   sessionInformation <- function() {
[17:42:57.876]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:57.876]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:57.876]                       search = base::search(), system = base::Sys.info())
[17:42:57.876]                   }
[17:42:57.876]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.876]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:57.876]                     cond$call), session = sessionInformation(), 
[17:42:57.876]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:57.876]                   signalCondition(cond)
[17:42:57.876]                 }
[17:42:57.876]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:57.876]                 "immediateCondition"))) {
[17:42:57.876]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:57.876]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.876]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:57.876]                   if (TRUE && !signal) {
[17:42:57.876]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.876]                     {
[17:42:57.876]                       inherits <- base::inherits
[17:42:57.876]                       invokeRestart <- base::invokeRestart
[17:42:57.876]                       is.null <- base::is.null
[17:42:57.876]                       muffled <- FALSE
[17:42:57.876]                       if (inherits(cond, "message")) {
[17:42:57.876]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.876]                         if (muffled) 
[17:42:57.876]                           invokeRestart("muffleMessage")
[17:42:57.876]                       }
[17:42:57.876]                       else if (inherits(cond, "warning")) {
[17:42:57.876]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.876]                         if (muffled) 
[17:42:57.876]                           invokeRestart("muffleWarning")
[17:42:57.876]                       }
[17:42:57.876]                       else if (inherits(cond, "condition")) {
[17:42:57.876]                         if (!is.null(pattern)) {
[17:42:57.876]                           computeRestarts <- base::computeRestarts
[17:42:57.876]                           grepl <- base::grepl
[17:42:57.876]                           restarts <- computeRestarts(cond)
[17:42:57.876]                           for (restart in restarts) {
[17:42:57.876]                             name <- restart$name
[17:42:57.876]                             if (is.null(name)) 
[17:42:57.876]                               next
[17:42:57.876]                             if (!grepl(pattern, name)) 
[17:42:57.876]                               next
[17:42:57.876]                             invokeRestart(restart)
[17:42:57.876]                             muffled <- TRUE
[17:42:57.876]                             break
[17:42:57.876]                           }
[17:42:57.876]                         }
[17:42:57.876]                       }
[17:42:57.876]                       invisible(muffled)
[17:42:57.876]                     }
[17:42:57.876]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.876]                   }
[17:42:57.876]                 }
[17:42:57.876]                 else {
[17:42:57.876]                   if (TRUE) {
[17:42:57.876]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.876]                     {
[17:42:57.876]                       inherits <- base::inherits
[17:42:57.876]                       invokeRestart <- base::invokeRestart
[17:42:57.876]                       is.null <- base::is.null
[17:42:57.876]                       muffled <- FALSE
[17:42:57.876]                       if (inherits(cond, "message")) {
[17:42:57.876]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.876]                         if (muffled) 
[17:42:57.876]                           invokeRestart("muffleMessage")
[17:42:57.876]                       }
[17:42:57.876]                       else if (inherits(cond, "warning")) {
[17:42:57.876]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.876]                         if (muffled) 
[17:42:57.876]                           invokeRestart("muffleWarning")
[17:42:57.876]                       }
[17:42:57.876]                       else if (inherits(cond, "condition")) {
[17:42:57.876]                         if (!is.null(pattern)) {
[17:42:57.876]                           computeRestarts <- base::computeRestarts
[17:42:57.876]                           grepl <- base::grepl
[17:42:57.876]                           restarts <- computeRestarts(cond)
[17:42:57.876]                           for (restart in restarts) {
[17:42:57.876]                             name <- restart$name
[17:42:57.876]                             if (is.null(name)) 
[17:42:57.876]                               next
[17:42:57.876]                             if (!grepl(pattern, name)) 
[17:42:57.876]                               next
[17:42:57.876]                             invokeRestart(restart)
[17:42:57.876]                             muffled <- TRUE
[17:42:57.876]                             break
[17:42:57.876]                           }
[17:42:57.876]                         }
[17:42:57.876]                       }
[17:42:57.876]                       invisible(muffled)
[17:42:57.876]                     }
[17:42:57.876]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.876]                   }
[17:42:57.876]                 }
[17:42:57.876]             }
[17:42:57.876]         }))
[17:42:57.876]     }, error = function(ex) {
[17:42:57.876]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:57.876]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.876]                 ...future.rng), started = ...future.startTime, 
[17:42:57.876]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:57.876]             version = "1.8"), class = "FutureResult")
[17:42:57.876]     }, finally = {
[17:42:57.876]         if (!identical(...future.workdir, getwd())) 
[17:42:57.876]             setwd(...future.workdir)
[17:42:57.876]         {
[17:42:57.876]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:57.876]                 ...future.oldOptions$nwarnings <- NULL
[17:42:57.876]             }
[17:42:57.876]             base::options(...future.oldOptions)
[17:42:57.876]             if (.Platform$OS.type == "windows") {
[17:42:57.876]                 old_names <- names(...future.oldEnvVars)
[17:42:57.876]                 envs <- base::Sys.getenv()
[17:42:57.876]                 names <- names(envs)
[17:42:57.876]                 common <- intersect(names, old_names)
[17:42:57.876]                 added <- setdiff(names, old_names)
[17:42:57.876]                 removed <- setdiff(old_names, names)
[17:42:57.876]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:57.876]                   envs[common]]
[17:42:57.876]                 NAMES <- toupper(changed)
[17:42:57.876]                 args <- list()
[17:42:57.876]                 for (kk in seq_along(NAMES)) {
[17:42:57.876]                   name <- changed[[kk]]
[17:42:57.876]                   NAME <- NAMES[[kk]]
[17:42:57.876]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.876]                     next
[17:42:57.876]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.876]                 }
[17:42:57.876]                 NAMES <- toupper(added)
[17:42:57.876]                 for (kk in seq_along(NAMES)) {
[17:42:57.876]                   name <- added[[kk]]
[17:42:57.876]                   NAME <- NAMES[[kk]]
[17:42:57.876]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.876]                     next
[17:42:57.876]                   args[[name]] <- ""
[17:42:57.876]                 }
[17:42:57.876]                 NAMES <- toupper(removed)
[17:42:57.876]                 for (kk in seq_along(NAMES)) {
[17:42:57.876]                   name <- removed[[kk]]
[17:42:57.876]                   NAME <- NAMES[[kk]]
[17:42:57.876]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.876]                     next
[17:42:57.876]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.876]                 }
[17:42:57.876]                 if (length(args) > 0) 
[17:42:57.876]                   base::do.call(base::Sys.setenv, args = args)
[17:42:57.876]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:57.876]             }
[17:42:57.876]             else {
[17:42:57.876]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:57.876]             }
[17:42:57.876]             {
[17:42:57.876]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:57.876]                   0L) {
[17:42:57.876]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:57.876]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:57.876]                   base::options(opts)
[17:42:57.876]                 }
[17:42:57.876]                 {
[17:42:57.876]                   {
[17:42:57.876]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:57.876]                     NULL
[17:42:57.876]                   }
[17:42:57.876]                   options(future.plan = NULL)
[17:42:57.876]                   if (is.na(NA_character_)) 
[17:42:57.876]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.876]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:57.876]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:57.876]                     envir = parent.frame()) 
[17:42:57.876]                   {
[17:42:57.876]                     default_workers <- missing(workers)
[17:42:57.876]                     if (is.function(workers)) 
[17:42:57.876]                       workers <- workers()
[17:42:57.876]                     workers <- structure(as.integer(workers), 
[17:42:57.876]                       class = class(workers))
[17:42:57.876]                     stop_if_not(is.finite(workers), workers >= 
[17:42:57.876]                       1L)
[17:42:57.876]                     if ((workers == 1L && !inherits(workers, 
[17:42:57.876]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:57.876]                       if (default_workers) 
[17:42:57.876]                         supportsMulticore(warn = TRUE)
[17:42:57.876]                       return(sequential(..., envir = envir))
[17:42:57.876]                     }
[17:42:57.876]                     oopts <- options(mc.cores = workers)
[17:42:57.876]                     on.exit(options(oopts))
[17:42:57.876]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:57.876]                       envir = envir)
[17:42:57.876]                     if (!future$lazy) 
[17:42:57.876]                       future <- run(future)
[17:42:57.876]                     invisible(future)
[17:42:57.876]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:57.876]                 }
[17:42:57.876]             }
[17:42:57.876]         }
[17:42:57.876]     })
[17:42:57.876]     if (TRUE) {
[17:42:57.876]         base::sink(type = "output", split = FALSE)
[17:42:57.876]         if (TRUE) {
[17:42:57.876]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:57.876]         }
[17:42:57.876]         else {
[17:42:57.876]             ...future.result["stdout"] <- base::list(NULL)
[17:42:57.876]         }
[17:42:57.876]         base::close(...future.stdout)
[17:42:57.876]         ...future.stdout <- NULL
[17:42:57.876]     }
[17:42:57.876]     ...future.result$conditions <- ...future.conditions
[17:42:57.876]     ...future.result$finished <- base::Sys.time()
[17:42:57.876]     ...future.result
[17:42:57.876] }
[17:42:57.879] requestCore(): workers = 2
[17:42:57.881] MulticoreFuture started
[17:42:57.882] plan(): Setting new future strategy stack:
[17:42:57.882] List of future strategies:
[17:42:57.882] 1. sequential:
[17:42:57.882]    - args: function (..., envir = parent.frame())
[17:42:57.882]    - tweaked: FALSE
[17:42:57.882]    - call: NULL
[17:42:57.883] plan(): nbrOfWorkers() = 1
[17:42:57.885] plan(): Setting new future strategy stack:
[17:42:57.885] List of future strategies:
[17:42:57.885] 1. multicore:
[17:42:57.885]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:57.885]    - tweaked: FALSE
[17:42:57.885]    - call: plan(multicore)
[17:42:57.890] plan(): nbrOfWorkers() = 2
[1] TRUE
[1] 42
*** multicore(..., globals = TRUE) with globals
[17:42:57.896] getGlobalsAndPackages() ...
[17:42:57.896] Searching for globals...
[17:42:57.898] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘a’
[17:42:57.899] Searching for globals ... DONE
[17:42:57.899] Resolving globals: FALSE
[17:42:57.899] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:57.900] The total size of the 1 globals exported for future expression (‘{; b <- 3; c <- 2; a * b * c; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[17:42:57.900] - globals: [1] ‘a’
[17:42:57.900] 
[17:42:57.900] getGlobalsAndPackages() ... DONE
[17:42:57.901] Packages needed by the future expression (n = 0): <none>
[17:42:57.901] Packages needed by future strategies (n = 0): <none>
[17:42:57.901] {
[17:42:57.901]     {
[17:42:57.901]         {
[17:42:57.901]             ...future.startTime <- base::Sys.time()
[17:42:57.901]             {
[17:42:57.901]                 {
[17:42:57.901]                   {
[17:42:57.901]                     {
[17:42:57.901]                       base::local({
[17:42:57.901]                         has_future <- base::requireNamespace("future", 
[17:42:57.901]                           quietly = TRUE)
[17:42:57.901]                         if (has_future) {
[17:42:57.901]                           ns <- base::getNamespace("future")
[17:42:57.901]                           version <- ns[[".package"]][["version"]]
[17:42:57.901]                           if (is.null(version)) 
[17:42:57.901]                             version <- utils::packageVersion("future")
[17:42:57.901]                         }
[17:42:57.901]                         else {
[17:42:57.901]                           version <- NULL
[17:42:57.901]                         }
[17:42:57.901]                         if (!has_future || version < "1.8.0") {
[17:42:57.901]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:57.901]                             "", base::R.version$version.string), 
[17:42:57.901]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:57.901]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:57.901]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:57.901]                               "release", "version")], collapse = " "), 
[17:42:57.901]                             hostname = base::Sys.info()[["nodename"]])
[17:42:57.901]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:57.901]                             info)
[17:42:57.901]                           info <- base::paste(info, collapse = "; ")
[17:42:57.901]                           if (!has_future) {
[17:42:57.901]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:57.901]                               info)
[17:42:57.901]                           }
[17:42:57.901]                           else {
[17:42:57.901]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:57.901]                               info, version)
[17:42:57.901]                           }
[17:42:57.901]                           base::stop(msg)
[17:42:57.901]                         }
[17:42:57.901]                       })
[17:42:57.901]                     }
[17:42:57.901]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:57.901]                     base::options(mc.cores = 1L)
[17:42:57.901]                   }
[17:42:57.901]                   options(future.plan = NULL)
[17:42:57.901]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.901]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:57.901]                 }
[17:42:57.901]                 ...future.workdir <- getwd()
[17:42:57.901]             }
[17:42:57.901]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:57.901]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:57.901]         }
[17:42:57.901]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:57.901]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:57.901]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:57.901]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:57.901]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:57.901]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:57.901]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:57.901]             base::names(...future.oldOptions))
[17:42:57.901]     }
[17:42:57.901]     if (FALSE) {
[17:42:57.901]     }
[17:42:57.901]     else {
[17:42:57.901]         if (TRUE) {
[17:42:57.901]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:57.901]                 open = "w")
[17:42:57.901]         }
[17:42:57.901]         else {
[17:42:57.901]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:57.901]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:57.901]         }
[17:42:57.901]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:57.901]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:57.901]             base::sink(type = "output", split = FALSE)
[17:42:57.901]             base::close(...future.stdout)
[17:42:57.901]         }, add = TRUE)
[17:42:57.901]     }
[17:42:57.901]     ...future.frame <- base::sys.nframe()
[17:42:57.901]     ...future.conditions <- base::list()
[17:42:57.901]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:57.901]     if (FALSE) {
[17:42:57.901]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:57.901]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:57.901]     }
[17:42:57.901]     ...future.result <- base::tryCatch({
[17:42:57.901]         base::withCallingHandlers({
[17:42:57.901]             ...future.value <- base::withVisible(base::local({
[17:42:57.901]                 withCallingHandlers({
[17:42:57.901]                   {
[17:42:57.901]                     b <- 3
[17:42:57.901]                     c <- 2
[17:42:57.901]                     a * b * c
[17:42:57.901]                   }
[17:42:57.901]                 }, immediateCondition = function(cond) {
[17:42:57.901]                   save_rds <- function (object, pathname, ...) 
[17:42:57.901]                   {
[17:42:57.901]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:57.901]                     if (file_test("-f", pathname_tmp)) {
[17:42:57.901]                       fi_tmp <- file.info(pathname_tmp)
[17:42:57.901]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:57.901]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:57.901]                         fi_tmp[["mtime"]])
[17:42:57.901]                     }
[17:42:57.901]                     tryCatch({
[17:42:57.901]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:57.901]                     }, error = function(ex) {
[17:42:57.901]                       msg <- conditionMessage(ex)
[17:42:57.901]                       fi_tmp <- file.info(pathname_tmp)
[17:42:57.901]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:57.901]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:57.901]                         fi_tmp[["mtime"]], msg)
[17:42:57.901]                       ex$message <- msg
[17:42:57.901]                       stop(ex)
[17:42:57.901]                     })
[17:42:57.901]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:57.901]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:57.901]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:57.901]                       fi_tmp <- file.info(pathname_tmp)
[17:42:57.901]                       fi <- file.info(pathname)
[17:42:57.901]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:57.901]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:57.901]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:57.901]                         fi[["size"]], fi[["mtime"]])
[17:42:57.901]                       stop(msg)
[17:42:57.901]                     }
[17:42:57.901]                     invisible(pathname)
[17:42:57.901]                   }
[17:42:57.901]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:57.901]                     rootPath = tempdir()) 
[17:42:57.901]                   {
[17:42:57.901]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:57.901]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:57.901]                       tmpdir = path, fileext = ".rds")
[17:42:57.901]                     save_rds(obj, file)
[17:42:57.901]                   }
[17:42:57.901]                   saveImmediateCondition(cond, path = "/tmp/Rtmpie37tE/.future/immediateConditions")
[17:42:57.901]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.901]                   {
[17:42:57.901]                     inherits <- base::inherits
[17:42:57.901]                     invokeRestart <- base::invokeRestart
[17:42:57.901]                     is.null <- base::is.null
[17:42:57.901]                     muffled <- FALSE
[17:42:57.901]                     if (inherits(cond, "message")) {
[17:42:57.901]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:57.901]                       if (muffled) 
[17:42:57.901]                         invokeRestart("muffleMessage")
[17:42:57.901]                     }
[17:42:57.901]                     else if (inherits(cond, "warning")) {
[17:42:57.901]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:57.901]                       if (muffled) 
[17:42:57.901]                         invokeRestart("muffleWarning")
[17:42:57.901]                     }
[17:42:57.901]                     else if (inherits(cond, "condition")) {
[17:42:57.901]                       if (!is.null(pattern)) {
[17:42:57.901]                         computeRestarts <- base::computeRestarts
[17:42:57.901]                         grepl <- base::grepl
[17:42:57.901]                         restarts <- computeRestarts(cond)
[17:42:57.901]                         for (restart in restarts) {
[17:42:57.901]                           name <- restart$name
[17:42:57.901]                           if (is.null(name)) 
[17:42:57.901]                             next
[17:42:57.901]                           if (!grepl(pattern, name)) 
[17:42:57.901]                             next
[17:42:57.901]                           invokeRestart(restart)
[17:42:57.901]                           muffled <- TRUE
[17:42:57.901]                           break
[17:42:57.901]                         }
[17:42:57.901]                       }
[17:42:57.901]                     }
[17:42:57.901]                     invisible(muffled)
[17:42:57.901]                   }
[17:42:57.901]                   muffleCondition(cond)
[17:42:57.901]                 })
[17:42:57.901]             }))
[17:42:57.901]             future::FutureResult(value = ...future.value$value, 
[17:42:57.901]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.901]                   ...future.rng), globalenv = if (FALSE) 
[17:42:57.901]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:57.901]                     ...future.globalenv.names))
[17:42:57.901]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:57.901]         }, condition = base::local({
[17:42:57.901]             c <- base::c
[17:42:57.901]             inherits <- base::inherits
[17:42:57.901]             invokeRestart <- base::invokeRestart
[17:42:57.901]             length <- base::length
[17:42:57.901]             list <- base::list
[17:42:57.901]             seq.int <- base::seq.int
[17:42:57.901]             signalCondition <- base::signalCondition
[17:42:57.901]             sys.calls <- base::sys.calls
[17:42:57.901]             `[[` <- base::`[[`
[17:42:57.901]             `+` <- base::`+`
[17:42:57.901]             `<<-` <- base::`<<-`
[17:42:57.901]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:57.901]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:57.901]                   3L)]
[17:42:57.901]             }
[17:42:57.901]             function(cond) {
[17:42:57.901]                 is_error <- inherits(cond, "error")
[17:42:57.901]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:57.901]                   NULL)
[17:42:57.901]                 if (is_error) {
[17:42:57.901]                   sessionInformation <- function() {
[17:42:57.901]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:57.901]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:57.901]                       search = base::search(), system = base::Sys.info())
[17:42:57.901]                   }
[17:42:57.901]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.901]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:57.901]                     cond$call), session = sessionInformation(), 
[17:42:57.901]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:57.901]                   signalCondition(cond)
[17:42:57.901]                 }
[17:42:57.901]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:57.901]                 "immediateCondition"))) {
[17:42:57.901]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:57.901]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.901]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:57.901]                   if (TRUE && !signal) {
[17:42:57.901]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.901]                     {
[17:42:57.901]                       inherits <- base::inherits
[17:42:57.901]                       invokeRestart <- base::invokeRestart
[17:42:57.901]                       is.null <- base::is.null
[17:42:57.901]                       muffled <- FALSE
[17:42:57.901]                       if (inherits(cond, "message")) {
[17:42:57.901]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.901]                         if (muffled) 
[17:42:57.901]                           invokeRestart("muffleMessage")
[17:42:57.901]                       }
[17:42:57.901]                       else if (inherits(cond, "warning")) {
[17:42:57.901]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.901]                         if (muffled) 
[17:42:57.901]                           invokeRestart("muffleWarning")
[17:42:57.901]                       }
[17:42:57.901]                       else if (inherits(cond, "condition")) {
[17:42:57.901]                         if (!is.null(pattern)) {
[17:42:57.901]                           computeRestarts <- base::computeRestarts
[17:42:57.901]                           grepl <- base::grepl
[17:42:57.901]                           restarts <- computeRestarts(cond)
[17:42:57.901]                           for (restart in restarts) {
[17:42:57.901]                             name <- restart$name
[17:42:57.901]                             if (is.null(name)) 
[17:42:57.901]                               next
[17:42:57.901]                             if (!grepl(pattern, name)) 
[17:42:57.901]                               next
[17:42:57.901]                             invokeRestart(restart)
[17:42:57.901]                             muffled <- TRUE
[17:42:57.901]                             break
[17:42:57.901]                           }
[17:42:57.901]                         }
[17:42:57.901]                       }
[17:42:57.901]                       invisible(muffled)
[17:42:57.901]                     }
[17:42:57.901]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.901]                   }
[17:42:57.901]                 }
[17:42:57.901]                 else {
[17:42:57.901]                   if (TRUE) {
[17:42:57.901]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.901]                     {
[17:42:57.901]                       inherits <- base::inherits
[17:42:57.901]                       invokeRestart <- base::invokeRestart
[17:42:57.901]                       is.null <- base::is.null
[17:42:57.901]                       muffled <- FALSE
[17:42:57.901]                       if (inherits(cond, "message")) {
[17:42:57.901]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.901]                         if (muffled) 
[17:42:57.901]                           invokeRestart("muffleMessage")
[17:42:57.901]                       }
[17:42:57.901]                       else if (inherits(cond, "warning")) {
[17:42:57.901]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.901]                         if (muffled) 
[17:42:57.901]                           invokeRestart("muffleWarning")
[17:42:57.901]                       }
[17:42:57.901]                       else if (inherits(cond, "condition")) {
[17:42:57.901]                         if (!is.null(pattern)) {
[17:42:57.901]                           computeRestarts <- base::computeRestarts
[17:42:57.901]                           grepl <- base::grepl
[17:42:57.901]                           restarts <- computeRestarts(cond)
[17:42:57.901]                           for (restart in restarts) {
[17:42:57.901]                             name <- restart$name
[17:42:57.901]                             if (is.null(name)) 
[17:42:57.901]                               next
[17:42:57.901]                             if (!grepl(pattern, name)) 
[17:42:57.901]                               next
[17:42:57.901]                             invokeRestart(restart)
[17:42:57.901]                             muffled <- TRUE
[17:42:57.901]                             break
[17:42:57.901]                           }
[17:42:57.901]                         }
[17:42:57.901]                       }
[17:42:57.901]                       invisible(muffled)
[17:42:57.901]                     }
[17:42:57.901]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.901]                   }
[17:42:57.901]                 }
[17:42:57.901]             }
[17:42:57.901]         }))
[17:42:57.901]     }, error = function(ex) {
[17:42:57.901]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:57.901]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.901]                 ...future.rng), started = ...future.startTime, 
[17:42:57.901]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:57.901]             version = "1.8"), class = "FutureResult")
[17:42:57.901]     }, finally = {
[17:42:57.901]         if (!identical(...future.workdir, getwd())) 
[17:42:57.901]             setwd(...future.workdir)
[17:42:57.901]         {
[17:42:57.901]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:57.901]                 ...future.oldOptions$nwarnings <- NULL
[17:42:57.901]             }
[17:42:57.901]             base::options(...future.oldOptions)
[17:42:57.901]             if (.Platform$OS.type == "windows") {
[17:42:57.901]                 old_names <- names(...future.oldEnvVars)
[17:42:57.901]                 envs <- base::Sys.getenv()
[17:42:57.901]                 names <- names(envs)
[17:42:57.901]                 common <- intersect(names, old_names)
[17:42:57.901]                 added <- setdiff(names, old_names)
[17:42:57.901]                 removed <- setdiff(old_names, names)
[17:42:57.901]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:57.901]                   envs[common]]
[17:42:57.901]                 NAMES <- toupper(changed)
[17:42:57.901]                 args <- list()
[17:42:57.901]                 for (kk in seq_along(NAMES)) {
[17:42:57.901]                   name <- changed[[kk]]
[17:42:57.901]                   NAME <- NAMES[[kk]]
[17:42:57.901]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.901]                     next
[17:42:57.901]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.901]                 }
[17:42:57.901]                 NAMES <- toupper(added)
[17:42:57.901]                 for (kk in seq_along(NAMES)) {
[17:42:57.901]                   name <- added[[kk]]
[17:42:57.901]                   NAME <- NAMES[[kk]]
[17:42:57.901]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.901]                     next
[17:42:57.901]                   args[[name]] <- ""
[17:42:57.901]                 }
[17:42:57.901]                 NAMES <- toupper(removed)
[17:42:57.901]                 for (kk in seq_along(NAMES)) {
[17:42:57.901]                   name <- removed[[kk]]
[17:42:57.901]                   NAME <- NAMES[[kk]]
[17:42:57.901]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.901]                     next
[17:42:57.901]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.901]                 }
[17:42:57.901]                 if (length(args) > 0) 
[17:42:57.901]                   base::do.call(base::Sys.setenv, args = args)
[17:42:57.901]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:57.901]             }
[17:42:57.901]             else {
[17:42:57.901]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:57.901]             }
[17:42:57.901]             {
[17:42:57.901]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:57.901]                   0L) {
[17:42:57.901]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:57.901]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:57.901]                   base::options(opts)
[17:42:57.901]                 }
[17:42:57.901]                 {
[17:42:57.901]                   {
[17:42:57.901]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:57.901]                     NULL
[17:42:57.901]                   }
[17:42:57.901]                   options(future.plan = NULL)
[17:42:57.901]                   if (is.na(NA_character_)) 
[17:42:57.901]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.901]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:57.901]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:57.901]                     envir = parent.frame()) 
[17:42:57.901]                   {
[17:42:57.901]                     default_workers <- missing(workers)
[17:42:57.901]                     if (is.function(workers)) 
[17:42:57.901]                       workers <- workers()
[17:42:57.901]                     workers <- structure(as.integer(workers), 
[17:42:57.901]                       class = class(workers))
[17:42:57.901]                     stop_if_not(is.finite(workers), workers >= 
[17:42:57.901]                       1L)
[17:42:57.901]                     if ((workers == 1L && !inherits(workers, 
[17:42:57.901]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:57.901]                       if (default_workers) 
[17:42:57.901]                         supportsMulticore(warn = TRUE)
[17:42:57.901]                       return(sequential(..., envir = envir))
[17:42:57.901]                     }
[17:42:57.901]                     oopts <- options(mc.cores = workers)
[17:42:57.901]                     on.exit(options(oopts))
[17:42:57.901]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:57.901]                       envir = envir)
[17:42:57.901]                     if (!future$lazy) 
[17:42:57.901]                       future <- run(future)
[17:42:57.901]                     invisible(future)
[17:42:57.901]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:57.901]                 }
[17:42:57.901]             }
[17:42:57.901]         }
[17:42:57.901]     })
[17:42:57.901]     if (TRUE) {
[17:42:57.901]         base::sink(type = "output", split = FALSE)
[17:42:57.901]         if (TRUE) {
[17:42:57.901]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:57.901]         }
[17:42:57.901]         else {
[17:42:57.901]             ...future.result["stdout"] <- base::list(NULL)
[17:42:57.901]         }
[17:42:57.901]         base::close(...future.stdout)
[17:42:57.901]         ...future.stdout <- NULL
[17:42:57.901]     }
[17:42:57.901]     ...future.result$conditions <- ...future.conditions
[17:42:57.901]     ...future.result$finished <- base::Sys.time()
[17:42:57.901]     ...future.result
[17:42:57.901] }
[17:42:57.904] assign_globals() ...
[17:42:57.904] List of 1
[17:42:57.904]  $ a: num 0
[17:42:57.904]  - attr(*, "where")=List of 1
[17:42:57.904]   ..$ a:<environment: R_EmptyEnv> 
[17:42:57.904]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:57.904]  - attr(*, "resolved")= logi FALSE
[17:42:57.904]  - attr(*, "total_size")= num 56
[17:42:57.910] - copied ‘a’ to environment
[17:42:57.910] assign_globals() ... done
[17:42:57.910] requestCore(): workers = 2
[17:42:57.912] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:42:57.913] plan(): Setting new future strategy stack:
Globals: 1 objects totaling 56 bytes (numeric ‘a’ of 56 bytes)
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:42:57.914] List of future strategies:
[17:42:57.914] 1. sequential:
[17:42:57.914]    - args: function (..., envir = parent.frame())
[17:42:57.914]    - tweaked: FALSE
[17:42:57.914]    - call: NULL
[17:42:57.915] plan(): nbrOfWorkers() = 1
[17:42:57.917] plan(): Setting new future strategy stack:
[17:42:57.917] List of future strategies:
[17:42:57.917] 1. multicore:
[17:42:57.917]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:57.917]    - tweaked: FALSE
[17:42:57.917]    - call: plan(multicore)
[17:42:57.922] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 56280105-ab48-3cfb-51ca-f6f685381758
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[1] 0
*** multicore(..., globals = TRUE) with globals and blocking
 - Creating multicore future #1 ...
[17:42:57.928] getGlobalsAndPackages() ...
[17:42:57.929] Searching for globals...
[17:42:57.930] - globals found: [2] ‘{’, ‘ii’
[17:42:57.930] Searching for globals ... DONE
[17:42:57.930] Resolving globals: FALSE
[17:42:57.931] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:57.931] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:42:57.931] - globals: [1] ‘ii’
[17:42:57.931] 
[17:42:57.931] getGlobalsAndPackages() ... DONE
[17:42:57.932] Packages needed by the future expression (n = 0): <none>
[17:42:57.932] Packages needed by future strategies (n = 0): <none>
[17:42:57.933] {
[17:42:57.933]     {
[17:42:57.933]         {
[17:42:57.933]             ...future.startTime <- base::Sys.time()
[17:42:57.933]             {
[17:42:57.933]                 {
[17:42:57.933]                   {
[17:42:57.933]                     {
[17:42:57.933]                       base::local({
[17:42:57.933]                         has_future <- base::requireNamespace("future", 
[17:42:57.933]                           quietly = TRUE)
[17:42:57.933]                         if (has_future) {
[17:42:57.933]                           ns <- base::getNamespace("future")
[17:42:57.933]                           version <- ns[[".package"]][["version"]]
[17:42:57.933]                           if (is.null(version)) 
[17:42:57.933]                             version <- utils::packageVersion("future")
[17:42:57.933]                         }
[17:42:57.933]                         else {
[17:42:57.933]                           version <- NULL
[17:42:57.933]                         }
[17:42:57.933]                         if (!has_future || version < "1.8.0") {
[17:42:57.933]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:57.933]                             "", base::R.version$version.string), 
[17:42:57.933]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:57.933]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:57.933]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:57.933]                               "release", "version")], collapse = " "), 
[17:42:57.933]                             hostname = base::Sys.info()[["nodename"]])
[17:42:57.933]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:57.933]                             info)
[17:42:57.933]                           info <- base::paste(info, collapse = "; ")
[17:42:57.933]                           if (!has_future) {
[17:42:57.933]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:57.933]                               info)
[17:42:57.933]                           }
[17:42:57.933]                           else {
[17:42:57.933]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:57.933]                               info, version)
[17:42:57.933]                           }
[17:42:57.933]                           base::stop(msg)
[17:42:57.933]                         }
[17:42:57.933]                       })
[17:42:57.933]                     }
[17:42:57.933]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:57.933]                     base::options(mc.cores = 1L)
[17:42:57.933]                   }
[17:42:57.933]                   options(future.plan = NULL)
[17:42:57.933]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.933]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:57.933]                 }
[17:42:57.933]                 ...future.workdir <- getwd()
[17:42:57.933]             }
[17:42:57.933]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:57.933]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:57.933]         }
[17:42:57.933]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:57.933]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:57.933]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:57.933]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:57.933]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:57.933]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:57.933]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:57.933]             base::names(...future.oldOptions))
[17:42:57.933]     }
[17:42:57.933]     if (FALSE) {
[17:42:57.933]     }
[17:42:57.933]     else {
[17:42:57.933]         if (TRUE) {
[17:42:57.933]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:57.933]                 open = "w")
[17:42:57.933]         }
[17:42:57.933]         else {
[17:42:57.933]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:57.933]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:57.933]         }
[17:42:57.933]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:57.933]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:57.933]             base::sink(type = "output", split = FALSE)
[17:42:57.933]             base::close(...future.stdout)
[17:42:57.933]         }, add = TRUE)
[17:42:57.933]     }
[17:42:57.933]     ...future.frame <- base::sys.nframe()
[17:42:57.933]     ...future.conditions <- base::list()
[17:42:57.933]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:57.933]     if (FALSE) {
[17:42:57.933]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:57.933]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:57.933]     }
[17:42:57.933]     ...future.result <- base::tryCatch({
[17:42:57.933]         base::withCallingHandlers({
[17:42:57.933]             ...future.value <- base::withVisible(base::local({
[17:42:57.933]                 withCallingHandlers({
[17:42:57.933]                   {
[17:42:57.933]                     ii
[17:42:57.933]                   }
[17:42:57.933]                 }, immediateCondition = function(cond) {
[17:42:57.933]                   save_rds <- function (object, pathname, ...) 
[17:42:57.933]                   {
[17:42:57.933]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:57.933]                     if (file_test("-f", pathname_tmp)) {
[17:42:57.933]                       fi_tmp <- file.info(pathname_tmp)
[17:42:57.933]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:57.933]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:57.933]                         fi_tmp[["mtime"]])
[17:42:57.933]                     }
[17:42:57.933]                     tryCatch({
[17:42:57.933]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:57.933]                     }, error = function(ex) {
[17:42:57.933]                       msg <- conditionMessage(ex)
[17:42:57.933]                       fi_tmp <- file.info(pathname_tmp)
[17:42:57.933]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:57.933]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:57.933]                         fi_tmp[["mtime"]], msg)
[17:42:57.933]                       ex$message <- msg
[17:42:57.933]                       stop(ex)
[17:42:57.933]                     })
[17:42:57.933]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:57.933]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:57.933]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:57.933]                       fi_tmp <- file.info(pathname_tmp)
[17:42:57.933]                       fi <- file.info(pathname)
[17:42:57.933]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:57.933]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:57.933]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:57.933]                         fi[["size"]], fi[["mtime"]])
[17:42:57.933]                       stop(msg)
[17:42:57.933]                     }
[17:42:57.933]                     invisible(pathname)
[17:42:57.933]                   }
[17:42:57.933]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:57.933]                     rootPath = tempdir()) 
[17:42:57.933]                   {
[17:42:57.933]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:57.933]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:57.933]                       tmpdir = path, fileext = ".rds")
[17:42:57.933]                     save_rds(obj, file)
[17:42:57.933]                   }
[17:42:57.933]                   saveImmediateCondition(cond, path = "/tmp/Rtmpie37tE/.future/immediateConditions")
[17:42:57.933]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.933]                   {
[17:42:57.933]                     inherits <- base::inherits
[17:42:57.933]                     invokeRestart <- base::invokeRestart
[17:42:57.933]                     is.null <- base::is.null
[17:42:57.933]                     muffled <- FALSE
[17:42:57.933]                     if (inherits(cond, "message")) {
[17:42:57.933]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:57.933]                       if (muffled) 
[17:42:57.933]                         invokeRestart("muffleMessage")
[17:42:57.933]                     }
[17:42:57.933]                     else if (inherits(cond, "warning")) {
[17:42:57.933]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:57.933]                       if (muffled) 
[17:42:57.933]                         invokeRestart("muffleWarning")
[17:42:57.933]                     }
[17:42:57.933]                     else if (inherits(cond, "condition")) {
[17:42:57.933]                       if (!is.null(pattern)) {
[17:42:57.933]                         computeRestarts <- base::computeRestarts
[17:42:57.933]                         grepl <- base::grepl
[17:42:57.933]                         restarts <- computeRestarts(cond)
[17:42:57.933]                         for (restart in restarts) {
[17:42:57.933]                           name <- restart$name
[17:42:57.933]                           if (is.null(name)) 
[17:42:57.933]                             next
[17:42:57.933]                           if (!grepl(pattern, name)) 
[17:42:57.933]                             next
[17:42:57.933]                           invokeRestart(restart)
[17:42:57.933]                           muffled <- TRUE
[17:42:57.933]                           break
[17:42:57.933]                         }
[17:42:57.933]                       }
[17:42:57.933]                     }
[17:42:57.933]                     invisible(muffled)
[17:42:57.933]                   }
[17:42:57.933]                   muffleCondition(cond)
[17:42:57.933]                 })
[17:42:57.933]             }))
[17:42:57.933]             future::FutureResult(value = ...future.value$value, 
[17:42:57.933]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.933]                   ...future.rng), globalenv = if (FALSE) 
[17:42:57.933]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:57.933]                     ...future.globalenv.names))
[17:42:57.933]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:57.933]         }, condition = base::local({
[17:42:57.933]             c <- base::c
[17:42:57.933]             inherits <- base::inherits
[17:42:57.933]             invokeRestart <- base::invokeRestart
[17:42:57.933]             length <- base::length
[17:42:57.933]             list <- base::list
[17:42:57.933]             seq.int <- base::seq.int
[17:42:57.933]             signalCondition <- base::signalCondition
[17:42:57.933]             sys.calls <- base::sys.calls
[17:42:57.933]             `[[` <- base::`[[`
[17:42:57.933]             `+` <- base::`+`
[17:42:57.933]             `<<-` <- base::`<<-`
[17:42:57.933]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:57.933]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:57.933]                   3L)]
[17:42:57.933]             }
[17:42:57.933]             function(cond) {
[17:42:57.933]                 is_error <- inherits(cond, "error")
[17:42:57.933]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:57.933]                   NULL)
[17:42:57.933]                 if (is_error) {
[17:42:57.933]                   sessionInformation <- function() {
[17:42:57.933]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:57.933]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:57.933]                       search = base::search(), system = base::Sys.info())
[17:42:57.933]                   }
[17:42:57.933]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.933]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:57.933]                     cond$call), session = sessionInformation(), 
[17:42:57.933]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:57.933]                   signalCondition(cond)
[17:42:57.933]                 }
[17:42:57.933]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:57.933]                 "immediateCondition"))) {
[17:42:57.933]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:57.933]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.933]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:57.933]                   if (TRUE && !signal) {
[17:42:57.933]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.933]                     {
[17:42:57.933]                       inherits <- base::inherits
[17:42:57.933]                       invokeRestart <- base::invokeRestart
[17:42:57.933]                       is.null <- base::is.null
[17:42:57.933]                       muffled <- FALSE
[17:42:57.933]                       if (inherits(cond, "message")) {
[17:42:57.933]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.933]                         if (muffled) 
[17:42:57.933]                           invokeRestart("muffleMessage")
[17:42:57.933]                       }
[17:42:57.933]                       else if (inherits(cond, "warning")) {
[17:42:57.933]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.933]                         if (muffled) 
[17:42:57.933]                           invokeRestart("muffleWarning")
[17:42:57.933]                       }
[17:42:57.933]                       else if (inherits(cond, "condition")) {
[17:42:57.933]                         if (!is.null(pattern)) {
[17:42:57.933]                           computeRestarts <- base::computeRestarts
[17:42:57.933]                           grepl <- base::grepl
[17:42:57.933]                           restarts <- computeRestarts(cond)
[17:42:57.933]                           for (restart in restarts) {
[17:42:57.933]                             name <- restart$name
[17:42:57.933]                             if (is.null(name)) 
[17:42:57.933]                               next
[17:42:57.933]                             if (!grepl(pattern, name)) 
[17:42:57.933]                               next
[17:42:57.933]                             invokeRestart(restart)
[17:42:57.933]                             muffled <- TRUE
[17:42:57.933]                             break
[17:42:57.933]                           }
[17:42:57.933]                         }
[17:42:57.933]                       }
[17:42:57.933]                       invisible(muffled)
[17:42:57.933]                     }
[17:42:57.933]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.933]                   }
[17:42:57.933]                 }
[17:42:57.933]                 else {
[17:42:57.933]                   if (TRUE) {
[17:42:57.933]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.933]                     {
[17:42:57.933]                       inherits <- base::inherits
[17:42:57.933]                       invokeRestart <- base::invokeRestart
[17:42:57.933]                       is.null <- base::is.null
[17:42:57.933]                       muffled <- FALSE
[17:42:57.933]                       if (inherits(cond, "message")) {
[17:42:57.933]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.933]                         if (muffled) 
[17:42:57.933]                           invokeRestart("muffleMessage")
[17:42:57.933]                       }
[17:42:57.933]                       else if (inherits(cond, "warning")) {
[17:42:57.933]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.933]                         if (muffled) 
[17:42:57.933]                           invokeRestart("muffleWarning")
[17:42:57.933]                       }
[17:42:57.933]                       else if (inherits(cond, "condition")) {
[17:42:57.933]                         if (!is.null(pattern)) {
[17:42:57.933]                           computeRestarts <- base::computeRestarts
[17:42:57.933]                           grepl <- base::grepl
[17:42:57.933]                           restarts <- computeRestarts(cond)
[17:42:57.933]                           for (restart in restarts) {
[17:42:57.933]                             name <- restart$name
[17:42:57.933]                             if (is.null(name)) 
[17:42:57.933]                               next
[17:42:57.933]                             if (!grepl(pattern, name)) 
[17:42:57.933]                               next
[17:42:57.933]                             invokeRestart(restart)
[17:42:57.933]                             muffled <- TRUE
[17:42:57.933]                             break
[17:42:57.933]                           }
[17:42:57.933]                         }
[17:42:57.933]                       }
[17:42:57.933]                       invisible(muffled)
[17:42:57.933]                     }
[17:42:57.933]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.933]                   }
[17:42:57.933]                 }
[17:42:57.933]             }
[17:42:57.933]         }))
[17:42:57.933]     }, error = function(ex) {
[17:42:57.933]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:57.933]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.933]                 ...future.rng), started = ...future.startTime, 
[17:42:57.933]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:57.933]             version = "1.8"), class = "FutureResult")
[17:42:57.933]     }, finally = {
[17:42:57.933]         if (!identical(...future.workdir, getwd())) 
[17:42:57.933]             setwd(...future.workdir)
[17:42:57.933]         {
[17:42:57.933]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:57.933]                 ...future.oldOptions$nwarnings <- NULL
[17:42:57.933]             }
[17:42:57.933]             base::options(...future.oldOptions)
[17:42:57.933]             if (.Platform$OS.type == "windows") {
[17:42:57.933]                 old_names <- names(...future.oldEnvVars)
[17:42:57.933]                 envs <- base::Sys.getenv()
[17:42:57.933]                 names <- names(envs)
[17:42:57.933]                 common <- intersect(names, old_names)
[17:42:57.933]                 added <- setdiff(names, old_names)
[17:42:57.933]                 removed <- setdiff(old_names, names)
[17:42:57.933]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:57.933]                   envs[common]]
[17:42:57.933]                 NAMES <- toupper(changed)
[17:42:57.933]                 args <- list()
[17:42:57.933]                 for (kk in seq_along(NAMES)) {
[17:42:57.933]                   name <- changed[[kk]]
[17:42:57.933]                   NAME <- NAMES[[kk]]
[17:42:57.933]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.933]                     next
[17:42:57.933]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.933]                 }
[17:42:57.933]                 NAMES <- toupper(added)
[17:42:57.933]                 for (kk in seq_along(NAMES)) {
[17:42:57.933]                   name <- added[[kk]]
[17:42:57.933]                   NAME <- NAMES[[kk]]
[17:42:57.933]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.933]                     next
[17:42:57.933]                   args[[name]] <- ""
[17:42:57.933]                 }
[17:42:57.933]                 NAMES <- toupper(removed)
[17:42:57.933]                 for (kk in seq_along(NAMES)) {
[17:42:57.933]                   name <- removed[[kk]]
[17:42:57.933]                   NAME <- NAMES[[kk]]
[17:42:57.933]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.933]                     next
[17:42:57.933]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.933]                 }
[17:42:57.933]                 if (length(args) > 0) 
[17:42:57.933]                   base::do.call(base::Sys.setenv, args = args)
[17:42:57.933]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:57.933]             }
[17:42:57.933]             else {
[17:42:57.933]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:57.933]             }
[17:42:57.933]             {
[17:42:57.933]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:57.933]                   0L) {
[17:42:57.933]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:57.933]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:57.933]                   base::options(opts)
[17:42:57.933]                 }
[17:42:57.933]                 {
[17:42:57.933]                   {
[17:42:57.933]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:57.933]                     NULL
[17:42:57.933]                   }
[17:42:57.933]                   options(future.plan = NULL)
[17:42:57.933]                   if (is.na(NA_character_)) 
[17:42:57.933]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.933]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:57.933]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:57.933]                     envir = parent.frame()) 
[17:42:57.933]                   {
[17:42:57.933]                     default_workers <- missing(workers)
[17:42:57.933]                     if (is.function(workers)) 
[17:42:57.933]                       workers <- workers()
[17:42:57.933]                     workers <- structure(as.integer(workers), 
[17:42:57.933]                       class = class(workers))
[17:42:57.933]                     stop_if_not(is.finite(workers), workers >= 
[17:42:57.933]                       1L)
[17:42:57.933]                     if ((workers == 1L && !inherits(workers, 
[17:42:57.933]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:57.933]                       if (default_workers) 
[17:42:57.933]                         supportsMulticore(warn = TRUE)
[17:42:57.933]                       return(sequential(..., envir = envir))
[17:42:57.933]                     }
[17:42:57.933]                     oopts <- options(mc.cores = workers)
[17:42:57.933]                     on.exit(options(oopts))
[17:42:57.933]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:57.933]                       envir = envir)
[17:42:57.933]                     if (!future$lazy) 
[17:42:57.933]                       future <- run(future)
[17:42:57.933]                     invisible(future)
[17:42:57.933]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:57.933]                 }
[17:42:57.933]             }
[17:42:57.933]         }
[17:42:57.933]     })
[17:42:57.933]     if (TRUE) {
[17:42:57.933]         base::sink(type = "output", split = FALSE)
[17:42:57.933]         if (TRUE) {
[17:42:57.933]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:57.933]         }
[17:42:57.933]         else {
[17:42:57.933]             ...future.result["stdout"] <- base::list(NULL)
[17:42:57.933]         }
[17:42:57.933]         base::close(...future.stdout)
[17:42:57.933]         ...future.stdout <- NULL
[17:42:57.933]     }
[17:42:57.933]     ...future.result$conditions <- ...future.conditions
[17:42:57.933]     ...future.result$finished <- base::Sys.time()
[17:42:57.933]     ...future.result
[17:42:57.933] }
[17:42:57.936] assign_globals() ...
[17:42:57.936] List of 1
[17:42:57.936]  $ ii: int 1
[17:42:57.936]  - attr(*, "where")=List of 1
[17:42:57.936]   ..$ ii:<environment: R_EmptyEnv> 
[17:42:57.936]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:57.936]  - attr(*, "resolved")= logi FALSE
[17:42:57.936]  - attr(*, "total_size")= num 56
[17:42:57.939] - copied ‘ii’ to environment
[17:42:57.939] assign_globals() ... done
[17:42:57.939] requestCore(): workers = 2
[17:42:57.941] MulticoreFuture started
 - Creating multicore future #2 ...
[17:42:57.942] plan(): Setting new future strategy stack:
[17:42:57.943] List of future strategies:
[17:42:57.943] 1. sequential:
[17:42:57.943]    - args: function (..., envir = parent.frame())
[17:42:57.943]    - tweaked: FALSE
[17:42:57.943]    - call: NULL
[17:42:57.943] plan(): nbrOfWorkers() = 1
[17:42:57.945] plan(): Setting new future strategy stack:
[17:42:57.945] List of future strategies:
[17:42:57.945] 1. multicore:
[17:42:57.945]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:57.945]    - tweaked: FALSE
[17:42:57.945]    - call: plan(multicore)
[17:42:57.947] getGlobalsAndPackages() ...
[17:42:57.947] Searching for globals...
[17:42:57.949] - globals found: [2] ‘{’, ‘ii’
[17:42:57.949] Searching for globals ... DONE
[17:42:57.949] Resolving globals: FALSE
[17:42:57.950] plan(): nbrOfWorkers() = 2
[17:42:57.950] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:57.951] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:42:57.951] - globals: [1] ‘ii’
[17:42:57.951] 
[17:42:57.951] getGlobalsAndPackages() ... DONE
[17:42:57.952] Packages needed by the future expression (n = 0): <none>
[17:42:57.952] Packages needed by future strategies (n = 0): <none>
[17:42:57.953] {
[17:42:57.953]     {
[17:42:57.953]         {
[17:42:57.953]             ...future.startTime <- base::Sys.time()
[17:42:57.953]             {
[17:42:57.953]                 {
[17:42:57.953]                   {
[17:42:57.953]                     {
[17:42:57.953]                       base::local({
[17:42:57.953]                         has_future <- base::requireNamespace("future", 
[17:42:57.953]                           quietly = TRUE)
[17:42:57.953]                         if (has_future) {
[17:42:57.953]                           ns <- base::getNamespace("future")
[17:42:57.953]                           version <- ns[[".package"]][["version"]]
[17:42:57.953]                           if (is.null(version)) 
[17:42:57.953]                             version <- utils::packageVersion("future")
[17:42:57.953]                         }
[17:42:57.953]                         else {
[17:42:57.953]                           version <- NULL
[17:42:57.953]                         }
[17:42:57.953]                         if (!has_future || version < "1.8.0") {
[17:42:57.953]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:57.953]                             "", base::R.version$version.string), 
[17:42:57.953]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:57.953]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:57.953]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:57.953]                               "release", "version")], collapse = " "), 
[17:42:57.953]                             hostname = base::Sys.info()[["nodename"]])
[17:42:57.953]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:57.953]                             info)
[17:42:57.953]                           info <- base::paste(info, collapse = "; ")
[17:42:57.953]                           if (!has_future) {
[17:42:57.953]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:57.953]                               info)
[17:42:57.953]                           }
[17:42:57.953]                           else {
[17:42:57.953]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:57.953]                               info, version)
[17:42:57.953]                           }
[17:42:57.953]                           base::stop(msg)
[17:42:57.953]                         }
[17:42:57.953]                       })
[17:42:57.953]                     }
[17:42:57.953]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:57.953]                     base::options(mc.cores = 1L)
[17:42:57.953]                   }
[17:42:57.953]                   options(future.plan = NULL)
[17:42:57.953]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.953]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:57.953]                 }
[17:42:57.953]                 ...future.workdir <- getwd()
[17:42:57.953]             }
[17:42:57.953]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:57.953]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:57.953]         }
[17:42:57.953]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:57.953]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:57.953]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:57.953]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:57.953]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:57.953]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:57.953]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:57.953]             base::names(...future.oldOptions))
[17:42:57.953]     }
[17:42:57.953]     if (FALSE) {
[17:42:57.953]     }
[17:42:57.953]     else {
[17:42:57.953]         if (TRUE) {
[17:42:57.953]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:57.953]                 open = "w")
[17:42:57.953]         }
[17:42:57.953]         else {
[17:42:57.953]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:57.953]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:57.953]         }
[17:42:57.953]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:57.953]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:57.953]             base::sink(type = "output", split = FALSE)
[17:42:57.953]             base::close(...future.stdout)
[17:42:57.953]         }, add = TRUE)
[17:42:57.953]     }
[17:42:57.953]     ...future.frame <- base::sys.nframe()
[17:42:57.953]     ...future.conditions <- base::list()
[17:42:57.953]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:57.953]     if (FALSE) {
[17:42:57.953]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:57.953]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:57.953]     }
[17:42:57.953]     ...future.result <- base::tryCatch({
[17:42:57.953]         base::withCallingHandlers({
[17:42:57.953]             ...future.value <- base::withVisible(base::local({
[17:42:57.953]                 withCallingHandlers({
[17:42:57.953]                   {
[17:42:57.953]                     ii
[17:42:57.953]                   }
[17:42:57.953]                 }, immediateCondition = function(cond) {
[17:42:57.953]                   save_rds <- function (object, pathname, ...) 
[17:42:57.953]                   {
[17:42:57.953]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:57.953]                     if (file_test("-f", pathname_tmp)) {
[17:42:57.953]                       fi_tmp <- file.info(pathname_tmp)
[17:42:57.953]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:57.953]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:57.953]                         fi_tmp[["mtime"]])
[17:42:57.953]                     }
[17:42:57.953]                     tryCatch({
[17:42:57.953]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:57.953]                     }, error = function(ex) {
[17:42:57.953]                       msg <- conditionMessage(ex)
[17:42:57.953]                       fi_tmp <- file.info(pathname_tmp)
[17:42:57.953]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:57.953]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:57.953]                         fi_tmp[["mtime"]], msg)
[17:42:57.953]                       ex$message <- msg
[17:42:57.953]                       stop(ex)
[17:42:57.953]                     })
[17:42:57.953]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:57.953]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:57.953]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:57.953]                       fi_tmp <- file.info(pathname_tmp)
[17:42:57.953]                       fi <- file.info(pathname)
[17:42:57.953]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:57.953]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:57.953]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:57.953]                         fi[["size"]], fi[["mtime"]])
[17:42:57.953]                       stop(msg)
[17:42:57.953]                     }
[17:42:57.953]                     invisible(pathname)
[17:42:57.953]                   }
[17:42:57.953]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:57.953]                     rootPath = tempdir()) 
[17:42:57.953]                   {
[17:42:57.953]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:57.953]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:57.953]                       tmpdir = path, fileext = ".rds")
[17:42:57.953]                     save_rds(obj, file)
[17:42:57.953]                   }
[17:42:57.953]                   saveImmediateCondition(cond, path = "/tmp/Rtmpie37tE/.future/immediateConditions")
[17:42:57.953]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.953]                   {
[17:42:57.953]                     inherits <- base::inherits
[17:42:57.953]                     invokeRestart <- base::invokeRestart
[17:42:57.953]                     is.null <- base::is.null
[17:42:57.953]                     muffled <- FALSE
[17:42:57.953]                     if (inherits(cond, "message")) {
[17:42:57.953]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:57.953]                       if (muffled) 
[17:42:57.953]                         invokeRestart("muffleMessage")
[17:42:57.953]                     }
[17:42:57.953]                     else if (inherits(cond, "warning")) {
[17:42:57.953]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:57.953]                       if (muffled) 
[17:42:57.953]                         invokeRestart("muffleWarning")
[17:42:57.953]                     }
[17:42:57.953]                     else if (inherits(cond, "condition")) {
[17:42:57.953]                       if (!is.null(pattern)) {
[17:42:57.953]                         computeRestarts <- base::computeRestarts
[17:42:57.953]                         grepl <- base::grepl
[17:42:57.953]                         restarts <- computeRestarts(cond)
[17:42:57.953]                         for (restart in restarts) {
[17:42:57.953]                           name <- restart$name
[17:42:57.953]                           if (is.null(name)) 
[17:42:57.953]                             next
[17:42:57.953]                           if (!grepl(pattern, name)) 
[17:42:57.953]                             next
[17:42:57.953]                           invokeRestart(restart)
[17:42:57.953]                           muffled <- TRUE
[17:42:57.953]                           break
[17:42:57.953]                         }
[17:42:57.953]                       }
[17:42:57.953]                     }
[17:42:57.953]                     invisible(muffled)
[17:42:57.953]                   }
[17:42:57.953]                   muffleCondition(cond)
[17:42:57.953]                 })
[17:42:57.953]             }))
[17:42:57.953]             future::FutureResult(value = ...future.value$value, 
[17:42:57.953]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.953]                   ...future.rng), globalenv = if (FALSE) 
[17:42:57.953]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:57.953]                     ...future.globalenv.names))
[17:42:57.953]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:57.953]         }, condition = base::local({
[17:42:57.953]             c <- base::c
[17:42:57.953]             inherits <- base::inherits
[17:42:57.953]             invokeRestart <- base::invokeRestart
[17:42:57.953]             length <- base::length
[17:42:57.953]             list <- base::list
[17:42:57.953]             seq.int <- base::seq.int
[17:42:57.953]             signalCondition <- base::signalCondition
[17:42:57.953]             sys.calls <- base::sys.calls
[17:42:57.953]             `[[` <- base::`[[`
[17:42:57.953]             `+` <- base::`+`
[17:42:57.953]             `<<-` <- base::`<<-`
[17:42:57.953]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:57.953]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:57.953]                   3L)]
[17:42:57.953]             }
[17:42:57.953]             function(cond) {
[17:42:57.953]                 is_error <- inherits(cond, "error")
[17:42:57.953]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:57.953]                   NULL)
[17:42:57.953]                 if (is_error) {
[17:42:57.953]                   sessionInformation <- function() {
[17:42:57.953]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:57.953]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:57.953]                       search = base::search(), system = base::Sys.info())
[17:42:57.953]                   }
[17:42:57.953]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.953]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:57.953]                     cond$call), session = sessionInformation(), 
[17:42:57.953]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:57.953]                   signalCondition(cond)
[17:42:57.953]                 }
[17:42:57.953]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:57.953]                 "immediateCondition"))) {
[17:42:57.953]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:57.953]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.953]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:57.953]                   if (TRUE && !signal) {
[17:42:57.953]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.953]                     {
[17:42:57.953]                       inherits <- base::inherits
[17:42:57.953]                       invokeRestart <- base::invokeRestart
[17:42:57.953]                       is.null <- base::is.null
[17:42:57.953]                       muffled <- FALSE
[17:42:57.953]                       if (inherits(cond, "message")) {
[17:42:57.953]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.953]                         if (muffled) 
[17:42:57.953]                           invokeRestart("muffleMessage")
[17:42:57.953]                       }
[17:42:57.953]                       else if (inherits(cond, "warning")) {
[17:42:57.953]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.953]                         if (muffled) 
[17:42:57.953]                           invokeRestart("muffleWarning")
[17:42:57.953]                       }
[17:42:57.953]                       else if (inherits(cond, "condition")) {
[17:42:57.953]                         if (!is.null(pattern)) {
[17:42:57.953]                           computeRestarts <- base::computeRestarts
[17:42:57.953]                           grepl <- base::grepl
[17:42:57.953]                           restarts <- computeRestarts(cond)
[17:42:57.953]                           for (restart in restarts) {
[17:42:57.953]                             name <- restart$name
[17:42:57.953]                             if (is.null(name)) 
[17:42:57.953]                               next
[17:42:57.953]                             if (!grepl(pattern, name)) 
[17:42:57.953]                               next
[17:42:57.953]                             invokeRestart(restart)
[17:42:57.953]                             muffled <- TRUE
[17:42:57.953]                             break
[17:42:57.953]                           }
[17:42:57.953]                         }
[17:42:57.953]                       }
[17:42:57.953]                       invisible(muffled)
[17:42:57.953]                     }
[17:42:57.953]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.953]                   }
[17:42:57.953]                 }
[17:42:57.953]                 else {
[17:42:57.953]                   if (TRUE) {
[17:42:57.953]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.953]                     {
[17:42:57.953]                       inherits <- base::inherits
[17:42:57.953]                       invokeRestart <- base::invokeRestart
[17:42:57.953]                       is.null <- base::is.null
[17:42:57.953]                       muffled <- FALSE
[17:42:57.953]                       if (inherits(cond, "message")) {
[17:42:57.953]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.953]                         if (muffled) 
[17:42:57.953]                           invokeRestart("muffleMessage")
[17:42:57.953]                       }
[17:42:57.953]                       else if (inherits(cond, "warning")) {
[17:42:57.953]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.953]                         if (muffled) 
[17:42:57.953]                           invokeRestart("muffleWarning")
[17:42:57.953]                       }
[17:42:57.953]                       else if (inherits(cond, "condition")) {
[17:42:57.953]                         if (!is.null(pattern)) {
[17:42:57.953]                           computeRestarts <- base::computeRestarts
[17:42:57.953]                           grepl <- base::grepl
[17:42:57.953]                           restarts <- computeRestarts(cond)
[17:42:57.953]                           for (restart in restarts) {
[17:42:57.953]                             name <- restart$name
[17:42:57.953]                             if (is.null(name)) 
[17:42:57.953]                               next
[17:42:57.953]                             if (!grepl(pattern, name)) 
[17:42:57.953]                               next
[17:42:57.953]                             invokeRestart(restart)
[17:42:57.953]                             muffled <- TRUE
[17:42:57.953]                             break
[17:42:57.953]                           }
[17:42:57.953]                         }
[17:42:57.953]                       }
[17:42:57.953]                       invisible(muffled)
[17:42:57.953]                     }
[17:42:57.953]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.953]                   }
[17:42:57.953]                 }
[17:42:57.953]             }
[17:42:57.953]         }))
[17:42:57.953]     }, error = function(ex) {
[17:42:57.953]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:57.953]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.953]                 ...future.rng), started = ...future.startTime, 
[17:42:57.953]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:57.953]             version = "1.8"), class = "FutureResult")
[17:42:57.953]     }, finally = {
[17:42:57.953]         if (!identical(...future.workdir, getwd())) 
[17:42:57.953]             setwd(...future.workdir)
[17:42:57.953]         {
[17:42:57.953]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:57.953]                 ...future.oldOptions$nwarnings <- NULL
[17:42:57.953]             }
[17:42:57.953]             base::options(...future.oldOptions)
[17:42:57.953]             if (.Platform$OS.type == "windows") {
[17:42:57.953]                 old_names <- names(...future.oldEnvVars)
[17:42:57.953]                 envs <- base::Sys.getenv()
[17:42:57.953]                 names <- names(envs)
[17:42:57.953]                 common <- intersect(names, old_names)
[17:42:57.953]                 added <- setdiff(names, old_names)
[17:42:57.953]                 removed <- setdiff(old_names, names)
[17:42:57.953]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:57.953]                   envs[common]]
[17:42:57.953]                 NAMES <- toupper(changed)
[17:42:57.953]                 args <- list()
[17:42:57.953]                 for (kk in seq_along(NAMES)) {
[17:42:57.953]                   name <- changed[[kk]]
[17:42:57.953]                   NAME <- NAMES[[kk]]
[17:42:57.953]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.953]                     next
[17:42:57.953]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.953]                 }
[17:42:57.953]                 NAMES <- toupper(added)
[17:42:57.953]                 for (kk in seq_along(NAMES)) {
[17:42:57.953]                   name <- added[[kk]]
[17:42:57.953]                   NAME <- NAMES[[kk]]
[17:42:57.953]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.953]                     next
[17:42:57.953]                   args[[name]] <- ""
[17:42:57.953]                 }
[17:42:57.953]                 NAMES <- toupper(removed)
[17:42:57.953]                 for (kk in seq_along(NAMES)) {
[17:42:57.953]                   name <- removed[[kk]]
[17:42:57.953]                   NAME <- NAMES[[kk]]
[17:42:57.953]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.953]                     next
[17:42:57.953]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.953]                 }
[17:42:57.953]                 if (length(args) > 0) 
[17:42:57.953]                   base::do.call(base::Sys.setenv, args = args)
[17:42:57.953]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:57.953]             }
[17:42:57.953]             else {
[17:42:57.953]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:57.953]             }
[17:42:57.953]             {
[17:42:57.953]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:57.953]                   0L) {
[17:42:57.953]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:57.953]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:57.953]                   base::options(opts)
[17:42:57.953]                 }
[17:42:57.953]                 {
[17:42:57.953]                   {
[17:42:57.953]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:57.953]                     NULL
[17:42:57.953]                   }
[17:42:57.953]                   options(future.plan = NULL)
[17:42:57.953]                   if (is.na(NA_character_)) 
[17:42:57.953]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.953]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:57.953]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:57.953]                     envir = parent.frame()) 
[17:42:57.953]                   {
[17:42:57.953]                     default_workers <- missing(workers)
[17:42:57.953]                     if (is.function(workers)) 
[17:42:57.953]                       workers <- workers()
[17:42:57.953]                     workers <- structure(as.integer(workers), 
[17:42:57.953]                       class = class(workers))
[17:42:57.953]                     stop_if_not(is.finite(workers), workers >= 
[17:42:57.953]                       1L)
[17:42:57.953]                     if ((workers == 1L && !inherits(workers, 
[17:42:57.953]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:57.953]                       if (default_workers) 
[17:42:57.953]                         supportsMulticore(warn = TRUE)
[17:42:57.953]                       return(sequential(..., envir = envir))
[17:42:57.953]                     }
[17:42:57.953]                     oopts <- options(mc.cores = workers)
[17:42:57.953]                     on.exit(options(oopts))
[17:42:57.953]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:57.953]                       envir = envir)
[17:42:57.953]                     if (!future$lazy) 
[17:42:57.953]                       future <- run(future)
[17:42:57.953]                     invisible(future)
[17:42:57.953]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:57.953]                 }
[17:42:57.953]             }
[17:42:57.953]         }
[17:42:57.953]     })
[17:42:57.953]     if (TRUE) {
[17:42:57.953]         base::sink(type = "output", split = FALSE)
[17:42:57.953]         if (TRUE) {
[17:42:57.953]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:57.953]         }
[17:42:57.953]         else {
[17:42:57.953]             ...future.result["stdout"] <- base::list(NULL)
[17:42:57.953]         }
[17:42:57.953]         base::close(...future.stdout)
[17:42:57.953]         ...future.stdout <- NULL
[17:42:57.953]     }
[17:42:57.953]     ...future.result$conditions <- ...future.conditions
[17:42:57.953]     ...future.result$finished <- base::Sys.time()
[17:42:57.953]     ...future.result
[17:42:57.953] }
[17:42:57.956] assign_globals() ...
[17:42:57.956] List of 1
[17:42:57.956]  $ ii: int 2
[17:42:57.956]  - attr(*, "where")=List of 1
[17:42:57.956]   ..$ ii:<environment: R_EmptyEnv> 
[17:42:57.956]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:57.956]  - attr(*, "resolved")= logi FALSE
[17:42:57.956]  - attr(*, "total_size")= num 56
[17:42:57.960] - copied ‘ii’ to environment
[17:42:57.960] assign_globals() ... done
[17:42:57.961] requestCore(): workers = 2
[17:42:57.963] MulticoreFuture started
 - Creating multicore future #3 ...
[17:42:57.964] plan(): Setting new future strategy stack:
[17:42:57.964] List of future strategies:
[17:42:57.964] 1. sequential:
[17:42:57.964]    - args: function (..., envir = parent.frame())
[17:42:57.964]    - tweaked: FALSE
[17:42:57.964]    - call: NULL
[17:42:57.965] plan(): nbrOfWorkers() = 1
[17:42:57.967] plan(): Setting new future strategy stack:
[17:42:57.968] List of future strategies:
[17:42:57.968] 1. multicore:
[17:42:57.968]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:57.968]    - tweaked: FALSE
[17:42:57.968]    - call: plan(multicore)
[17:42:57.969] getGlobalsAndPackages() ...
[17:42:57.969] Searching for globals...
[17:42:57.970] - globals found: [2] ‘{’, ‘ii’
[17:42:57.971] Searching for globals ... DONE
[17:42:57.971] Resolving globals: FALSE
[17:42:57.972] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:57.973] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:42:57.973] - globals: [1] ‘ii’
[17:42:57.973] 
[17:42:57.973] getGlobalsAndPackages() ... DONE
[17:42:57.973] plan(): nbrOfWorkers() = 2
[17:42:57.978] Packages needed by the future expression (n = 0): <none>
[17:42:57.978] Packages needed by future strategies (n = 0): <none>
[17:42:57.979] {
[17:42:57.979]     {
[17:42:57.979]         {
[17:42:57.979]             ...future.startTime <- base::Sys.time()
[17:42:57.979]             {
[17:42:57.979]                 {
[17:42:57.979]                   {
[17:42:57.979]                     {
[17:42:57.979]                       base::local({
[17:42:57.979]                         has_future <- base::requireNamespace("future", 
[17:42:57.979]                           quietly = TRUE)
[17:42:57.979]                         if (has_future) {
[17:42:57.979]                           ns <- base::getNamespace("future")
[17:42:57.979]                           version <- ns[[".package"]][["version"]]
[17:42:57.979]                           if (is.null(version)) 
[17:42:57.979]                             version <- utils::packageVersion("future")
[17:42:57.979]                         }
[17:42:57.979]                         else {
[17:42:57.979]                           version <- NULL
[17:42:57.979]                         }
[17:42:57.979]                         if (!has_future || version < "1.8.0") {
[17:42:57.979]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:57.979]                             "", base::R.version$version.string), 
[17:42:57.979]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:57.979]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:57.979]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:57.979]                               "release", "version")], collapse = " "), 
[17:42:57.979]                             hostname = base::Sys.info()[["nodename"]])
[17:42:57.979]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:57.979]                             info)
[17:42:57.979]                           info <- base::paste(info, collapse = "; ")
[17:42:57.979]                           if (!has_future) {
[17:42:57.979]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:57.979]                               info)
[17:42:57.979]                           }
[17:42:57.979]                           else {
[17:42:57.979]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:57.979]                               info, version)
[17:42:57.979]                           }
[17:42:57.979]                           base::stop(msg)
[17:42:57.979]                         }
[17:42:57.979]                       })
[17:42:57.979]                     }
[17:42:57.979]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:57.979]                     base::options(mc.cores = 1L)
[17:42:57.979]                   }
[17:42:57.979]                   options(future.plan = NULL)
[17:42:57.979]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.979]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:57.979]                 }
[17:42:57.979]                 ...future.workdir <- getwd()
[17:42:57.979]             }
[17:42:57.979]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:57.979]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:57.979]         }
[17:42:57.979]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:57.979]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:57.979]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:57.979]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:57.979]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:57.979]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:57.979]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:57.979]             base::names(...future.oldOptions))
[17:42:57.979]     }
[17:42:57.979]     if (FALSE) {
[17:42:57.979]     }
[17:42:57.979]     else {
[17:42:57.979]         if (TRUE) {
[17:42:57.979]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:57.979]                 open = "w")
[17:42:57.979]         }
[17:42:57.979]         else {
[17:42:57.979]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:57.979]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:57.979]         }
[17:42:57.979]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:57.979]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:57.979]             base::sink(type = "output", split = FALSE)
[17:42:57.979]             base::close(...future.stdout)
[17:42:57.979]         }, add = TRUE)
[17:42:57.979]     }
[17:42:57.979]     ...future.frame <- base::sys.nframe()
[17:42:57.979]     ...future.conditions <- base::list()
[17:42:57.979]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:57.979]     if (FALSE) {
[17:42:57.979]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:57.979]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:57.979]     }
[17:42:57.979]     ...future.result <- base::tryCatch({
[17:42:57.979]         base::withCallingHandlers({
[17:42:57.979]             ...future.value <- base::withVisible(base::local({
[17:42:57.979]                 withCallingHandlers({
[17:42:57.979]                   {
[17:42:57.979]                     ii
[17:42:57.979]                   }
[17:42:57.979]                 }, immediateCondition = function(cond) {
[17:42:57.979]                   save_rds <- function (object, pathname, ...) 
[17:42:57.979]                   {
[17:42:57.979]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:57.979]                     if (file_test("-f", pathname_tmp)) {
[17:42:57.979]                       fi_tmp <- file.info(pathname_tmp)
[17:42:57.979]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:57.979]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:57.979]                         fi_tmp[["mtime"]])
[17:42:57.979]                     }
[17:42:57.979]                     tryCatch({
[17:42:57.979]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:57.979]                     }, error = function(ex) {
[17:42:57.979]                       msg <- conditionMessage(ex)
[17:42:57.979]                       fi_tmp <- file.info(pathname_tmp)
[17:42:57.979]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:57.979]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:57.979]                         fi_tmp[["mtime"]], msg)
[17:42:57.979]                       ex$message <- msg
[17:42:57.979]                       stop(ex)
[17:42:57.979]                     })
[17:42:57.979]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:57.979]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:57.979]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:57.979]                       fi_tmp <- file.info(pathname_tmp)
[17:42:57.979]                       fi <- file.info(pathname)
[17:42:57.979]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:57.979]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:57.979]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:57.979]                         fi[["size"]], fi[["mtime"]])
[17:42:57.979]                       stop(msg)
[17:42:57.979]                     }
[17:42:57.979]                     invisible(pathname)
[17:42:57.979]                   }
[17:42:57.979]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:57.979]                     rootPath = tempdir()) 
[17:42:57.979]                   {
[17:42:57.979]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:57.979]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:57.979]                       tmpdir = path, fileext = ".rds")
[17:42:57.979]                     save_rds(obj, file)
[17:42:57.979]                   }
[17:42:57.979]                   saveImmediateCondition(cond, path = "/tmp/Rtmpie37tE/.future/immediateConditions")
[17:42:57.979]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.979]                   {
[17:42:57.979]                     inherits <- base::inherits
[17:42:57.979]                     invokeRestart <- base::invokeRestart
[17:42:57.979]                     is.null <- base::is.null
[17:42:57.979]                     muffled <- FALSE
[17:42:57.979]                     if (inherits(cond, "message")) {
[17:42:57.979]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:57.979]                       if (muffled) 
[17:42:57.979]                         invokeRestart("muffleMessage")
[17:42:57.979]                     }
[17:42:57.979]                     else if (inherits(cond, "warning")) {
[17:42:57.979]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:57.979]                       if (muffled) 
[17:42:57.979]                         invokeRestart("muffleWarning")
[17:42:57.979]                     }
[17:42:57.979]                     else if (inherits(cond, "condition")) {
[17:42:57.979]                       if (!is.null(pattern)) {
[17:42:57.979]                         computeRestarts <- base::computeRestarts
[17:42:57.979]                         grepl <- base::grepl
[17:42:57.979]                         restarts <- computeRestarts(cond)
[17:42:57.979]                         for (restart in restarts) {
[17:42:57.979]                           name <- restart$name
[17:42:57.979]                           if (is.null(name)) 
[17:42:57.979]                             next
[17:42:57.979]                           if (!grepl(pattern, name)) 
[17:42:57.979]                             next
[17:42:57.979]                           invokeRestart(restart)
[17:42:57.979]                           muffled <- TRUE
[17:42:57.979]                           break
[17:42:57.979]                         }
[17:42:57.979]                       }
[17:42:57.979]                     }
[17:42:57.979]                     invisible(muffled)
[17:42:57.979]                   }
[17:42:57.979]                   muffleCondition(cond)
[17:42:57.979]                 })
[17:42:57.979]             }))
[17:42:57.979]             future::FutureResult(value = ...future.value$value, 
[17:42:57.979]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.979]                   ...future.rng), globalenv = if (FALSE) 
[17:42:57.979]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:57.979]                     ...future.globalenv.names))
[17:42:57.979]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:57.979]         }, condition = base::local({
[17:42:57.979]             c <- base::c
[17:42:57.979]             inherits <- base::inherits
[17:42:57.979]             invokeRestart <- base::invokeRestart
[17:42:57.979]             length <- base::length
[17:42:57.979]             list <- base::list
[17:42:57.979]             seq.int <- base::seq.int
[17:42:57.979]             signalCondition <- base::signalCondition
[17:42:57.979]             sys.calls <- base::sys.calls
[17:42:57.979]             `[[` <- base::`[[`
[17:42:57.979]             `+` <- base::`+`
[17:42:57.979]             `<<-` <- base::`<<-`
[17:42:57.979]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:57.979]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:57.979]                   3L)]
[17:42:57.979]             }
[17:42:57.979]             function(cond) {
[17:42:57.979]                 is_error <- inherits(cond, "error")
[17:42:57.979]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:57.979]                   NULL)
[17:42:57.979]                 if (is_error) {
[17:42:57.979]                   sessionInformation <- function() {
[17:42:57.979]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:57.979]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:57.979]                       search = base::search(), system = base::Sys.info())
[17:42:57.979]                   }
[17:42:57.979]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.979]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:57.979]                     cond$call), session = sessionInformation(), 
[17:42:57.979]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:57.979]                   signalCondition(cond)
[17:42:57.979]                 }
[17:42:57.979]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:57.979]                 "immediateCondition"))) {
[17:42:57.979]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:57.979]                   ...future.conditions[[length(...future.conditions) + 
[17:42:57.979]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:57.979]                   if (TRUE && !signal) {
[17:42:57.979]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.979]                     {
[17:42:57.979]                       inherits <- base::inherits
[17:42:57.979]                       invokeRestart <- base::invokeRestart
[17:42:57.979]                       is.null <- base::is.null
[17:42:57.979]                       muffled <- FALSE
[17:42:57.979]                       if (inherits(cond, "message")) {
[17:42:57.979]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.979]                         if (muffled) 
[17:42:57.979]                           invokeRestart("muffleMessage")
[17:42:57.979]                       }
[17:42:57.979]                       else if (inherits(cond, "warning")) {
[17:42:57.979]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.979]                         if (muffled) 
[17:42:57.979]                           invokeRestart("muffleWarning")
[17:42:57.979]                       }
[17:42:57.979]                       else if (inherits(cond, "condition")) {
[17:42:57.979]                         if (!is.null(pattern)) {
[17:42:57.979]                           computeRestarts <- base::computeRestarts
[17:42:57.979]                           grepl <- base::grepl
[17:42:57.979]                           restarts <- computeRestarts(cond)
[17:42:57.979]                           for (restart in restarts) {
[17:42:57.979]                             name <- restart$name
[17:42:57.979]                             if (is.null(name)) 
[17:42:57.979]                               next
[17:42:57.979]                             if (!grepl(pattern, name)) 
[17:42:57.979]                               next
[17:42:57.979]                             invokeRestart(restart)
[17:42:57.979]                             muffled <- TRUE
[17:42:57.979]                             break
[17:42:57.979]                           }
[17:42:57.979]                         }
[17:42:57.979]                       }
[17:42:57.979]                       invisible(muffled)
[17:42:57.979]                     }
[17:42:57.979]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.979]                   }
[17:42:57.979]                 }
[17:42:57.979]                 else {
[17:42:57.979]                   if (TRUE) {
[17:42:57.979]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:57.979]                     {
[17:42:57.979]                       inherits <- base::inherits
[17:42:57.979]                       invokeRestart <- base::invokeRestart
[17:42:57.979]                       is.null <- base::is.null
[17:42:57.979]                       muffled <- FALSE
[17:42:57.979]                       if (inherits(cond, "message")) {
[17:42:57.979]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:57.979]                         if (muffled) 
[17:42:57.979]                           invokeRestart("muffleMessage")
[17:42:57.979]                       }
[17:42:57.979]                       else if (inherits(cond, "warning")) {
[17:42:57.979]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:57.979]                         if (muffled) 
[17:42:57.979]                           invokeRestart("muffleWarning")
[17:42:57.979]                       }
[17:42:57.979]                       else if (inherits(cond, "condition")) {
[17:42:57.979]                         if (!is.null(pattern)) {
[17:42:57.979]                           computeRestarts <- base::computeRestarts
[17:42:57.979]                           grepl <- base::grepl
[17:42:57.979]                           restarts <- computeRestarts(cond)
[17:42:57.979]                           for (restart in restarts) {
[17:42:57.979]                             name <- restart$name
[17:42:57.979]                             if (is.null(name)) 
[17:42:57.979]                               next
[17:42:57.979]                             if (!grepl(pattern, name)) 
[17:42:57.979]                               next
[17:42:57.979]                             invokeRestart(restart)
[17:42:57.979]                             muffled <- TRUE
[17:42:57.979]                             break
[17:42:57.979]                           }
[17:42:57.979]                         }
[17:42:57.979]                       }
[17:42:57.979]                       invisible(muffled)
[17:42:57.979]                     }
[17:42:57.979]                     muffleCondition(cond, pattern = "^muffle")
[17:42:57.979]                   }
[17:42:57.979]                 }
[17:42:57.979]             }
[17:42:57.979]         }))
[17:42:57.979]     }, error = function(ex) {
[17:42:57.979]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:57.979]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:57.979]                 ...future.rng), started = ...future.startTime, 
[17:42:57.979]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:57.979]             version = "1.8"), class = "FutureResult")
[17:42:57.979]     }, finally = {
[17:42:57.979]         if (!identical(...future.workdir, getwd())) 
[17:42:57.979]             setwd(...future.workdir)
[17:42:57.979]         {
[17:42:57.979]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:57.979]                 ...future.oldOptions$nwarnings <- NULL
[17:42:57.979]             }
[17:42:57.979]             base::options(...future.oldOptions)
[17:42:57.979]             if (.Platform$OS.type == "windows") {
[17:42:57.979]                 old_names <- names(...future.oldEnvVars)
[17:42:57.979]                 envs <- base::Sys.getenv()
[17:42:57.979]                 names <- names(envs)
[17:42:57.979]                 common <- intersect(names, old_names)
[17:42:57.979]                 added <- setdiff(names, old_names)
[17:42:57.979]                 removed <- setdiff(old_names, names)
[17:42:57.979]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:57.979]                   envs[common]]
[17:42:57.979]                 NAMES <- toupper(changed)
[17:42:57.979]                 args <- list()
[17:42:57.979]                 for (kk in seq_along(NAMES)) {
[17:42:57.979]                   name <- changed[[kk]]
[17:42:57.979]                   NAME <- NAMES[[kk]]
[17:42:57.979]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.979]                     next
[17:42:57.979]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.979]                 }
[17:42:57.979]                 NAMES <- toupper(added)
[17:42:57.979]                 for (kk in seq_along(NAMES)) {
[17:42:57.979]                   name <- added[[kk]]
[17:42:57.979]                   NAME <- NAMES[[kk]]
[17:42:57.979]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.979]                     next
[17:42:57.979]                   args[[name]] <- ""
[17:42:57.979]                 }
[17:42:57.979]                 NAMES <- toupper(removed)
[17:42:57.979]                 for (kk in seq_along(NAMES)) {
[17:42:57.979]                   name <- removed[[kk]]
[17:42:57.979]                   NAME <- NAMES[[kk]]
[17:42:57.979]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:57.979]                     next
[17:42:57.979]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:57.979]                 }
[17:42:57.979]                 if (length(args) > 0) 
[17:42:57.979]                   base::do.call(base::Sys.setenv, args = args)
[17:42:57.979]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:57.979]             }
[17:42:57.979]             else {
[17:42:57.979]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:57.979]             }
[17:42:57.979]             {
[17:42:57.979]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:57.979]                   0L) {
[17:42:57.979]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:57.979]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:57.979]                   base::options(opts)
[17:42:57.979]                 }
[17:42:57.979]                 {
[17:42:57.979]                   {
[17:42:57.979]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:57.979]                     NULL
[17:42:57.979]                   }
[17:42:57.979]                   options(future.plan = NULL)
[17:42:57.979]                   if (is.na(NA_character_)) 
[17:42:57.979]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:57.979]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:57.979]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:57.979]                     envir = parent.frame()) 
[17:42:57.979]                   {
[17:42:57.979]                     default_workers <- missing(workers)
[17:42:57.979]                     if (is.function(workers)) 
[17:42:57.979]                       workers <- workers()
[17:42:57.979]                     workers <- structure(as.integer(workers), 
[17:42:57.979]                       class = class(workers))
[17:42:57.979]                     stop_if_not(is.finite(workers), workers >= 
[17:42:57.979]                       1L)
[17:42:57.979]                     if ((workers == 1L && !inherits(workers, 
[17:42:57.979]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:57.979]                       if (default_workers) 
[17:42:57.979]                         supportsMulticore(warn = TRUE)
[17:42:57.979]                       return(sequential(..., envir = envir))
[17:42:57.979]                     }
[17:42:57.979]                     oopts <- options(mc.cores = workers)
[17:42:57.979]                     on.exit(options(oopts))
[17:42:57.979]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:57.979]                       envir = envir)
[17:42:57.979]                     if (!future$lazy) 
[17:42:57.979]                       future <- run(future)
[17:42:57.979]                     invisible(future)
[17:42:57.979]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:57.979]                 }
[17:42:57.979]             }
[17:42:57.979]         }
[17:42:57.979]     })
[17:42:57.979]     if (TRUE) {
[17:42:57.979]         base::sink(type = "output", split = FALSE)
[17:42:57.979]         if (TRUE) {
[17:42:57.979]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:57.979]         }
[17:42:57.979]         else {
[17:42:57.979]             ...future.result["stdout"] <- base::list(NULL)
[17:42:57.979]         }
[17:42:57.979]         base::close(...future.stdout)
[17:42:57.979]         ...future.stdout <- NULL
[17:42:57.979]     }
[17:42:57.979]     ...future.result$conditions <- ...future.conditions
[17:42:57.979]     ...future.result$finished <- base::Sys.time()
[17:42:57.979]     ...future.result
[17:42:57.979] }
[17:42:57.982] assign_globals() ...
[17:42:57.982] List of 1
[17:42:57.982]  $ ii: int 3
[17:42:57.982]  - attr(*, "where")=List of 1
[17:42:57.982]   ..$ ii:<environment: R_EmptyEnv> 
[17:42:57.982]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:57.982]  - attr(*, "resolved")= logi FALSE
[17:42:57.982]  - attr(*, "total_size")= num 56
[17:42:57.986] - copied ‘ii’ to environment
[17:42:57.987] assign_globals() ... done
[17:42:57.987] requestCore(): workers = 2
[17:42:57.987] Poll #1 (0): usedCores() = 2, workers = 2
[17:42:58.001] MulticoreFuture started
 - Creating multicore future #4 ...
[17:42:58.002] plan(): Setting new future strategy stack:
[17:42:58.003] List of future strategies:
[17:42:58.003] 1. sequential:
[17:42:58.003]    - args: function (..., envir = parent.frame())
[17:42:58.003]    - tweaked: FALSE
[17:42:58.003]    - call: NULL
[17:42:58.004] plan(): nbrOfWorkers() = 1
[17:42:58.006] plan(): Setting new future strategy stack:
[17:42:58.006] List of future strategies:
[17:42:58.006] 1. multicore:
[17:42:58.006]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:58.006]    - tweaked: FALSE
[17:42:58.006]    - call: plan(multicore)
[17:42:58.009] getGlobalsAndPackages() ...
[17:42:58.009] Searching for globals...
[17:42:58.010] - globals found: [2] ‘{’, ‘ii’
[17:42:58.010] Searching for globals ... DONE
[17:42:58.011] Resolving globals: FALSE
[17:42:58.012] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:58.012] plan(): nbrOfWorkers() = 2
[17:42:58.012] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:42:58.013] - globals: [1] ‘ii’
[17:42:58.013] 
[17:42:58.013] getGlobalsAndPackages() ... DONE
[17:42:58.014] Packages needed by the future expression (n = 0): <none>
[17:42:58.014] Packages needed by future strategies (n = 0): <none>
[17:42:58.015] {
[17:42:58.015]     {
[17:42:58.015]         {
[17:42:58.015]             ...future.startTime <- base::Sys.time()
[17:42:58.015]             {
[17:42:58.015]                 {
[17:42:58.015]                   {
[17:42:58.015]                     {
[17:42:58.015]                       base::local({
[17:42:58.015]                         has_future <- base::requireNamespace("future", 
[17:42:58.015]                           quietly = TRUE)
[17:42:58.015]                         if (has_future) {
[17:42:58.015]                           ns <- base::getNamespace("future")
[17:42:58.015]                           version <- ns[[".package"]][["version"]]
[17:42:58.015]                           if (is.null(version)) 
[17:42:58.015]                             version <- utils::packageVersion("future")
[17:42:58.015]                         }
[17:42:58.015]                         else {
[17:42:58.015]                           version <- NULL
[17:42:58.015]                         }
[17:42:58.015]                         if (!has_future || version < "1.8.0") {
[17:42:58.015]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:58.015]                             "", base::R.version$version.string), 
[17:42:58.015]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:58.015]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:58.015]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:58.015]                               "release", "version")], collapse = " "), 
[17:42:58.015]                             hostname = base::Sys.info()[["nodename"]])
[17:42:58.015]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:58.015]                             info)
[17:42:58.015]                           info <- base::paste(info, collapse = "; ")
[17:42:58.015]                           if (!has_future) {
[17:42:58.015]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:58.015]                               info)
[17:42:58.015]                           }
[17:42:58.015]                           else {
[17:42:58.015]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:58.015]                               info, version)
[17:42:58.015]                           }
[17:42:58.015]                           base::stop(msg)
[17:42:58.015]                         }
[17:42:58.015]                       })
[17:42:58.015]                     }
[17:42:58.015]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:58.015]                     base::options(mc.cores = 1L)
[17:42:58.015]                   }
[17:42:58.015]                   options(future.plan = NULL)
[17:42:58.015]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:58.015]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:58.015]                 }
[17:42:58.015]                 ...future.workdir <- getwd()
[17:42:58.015]             }
[17:42:58.015]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:58.015]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:58.015]         }
[17:42:58.015]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:58.015]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:58.015]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:58.015]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:58.015]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:58.015]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:58.015]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:58.015]             base::names(...future.oldOptions))
[17:42:58.015]     }
[17:42:58.015]     if (FALSE) {
[17:42:58.015]     }
[17:42:58.015]     else {
[17:42:58.015]         if (TRUE) {
[17:42:58.015]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:58.015]                 open = "w")
[17:42:58.015]         }
[17:42:58.015]         else {
[17:42:58.015]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:58.015]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:58.015]         }
[17:42:58.015]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:58.015]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:58.015]             base::sink(type = "output", split = FALSE)
[17:42:58.015]             base::close(...future.stdout)
[17:42:58.015]         }, add = TRUE)
[17:42:58.015]     }
[17:42:58.015]     ...future.frame <- base::sys.nframe()
[17:42:58.015]     ...future.conditions <- base::list()
[17:42:58.015]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:58.015]     if (FALSE) {
[17:42:58.015]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:58.015]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:58.015]     }
[17:42:58.015]     ...future.result <- base::tryCatch({
[17:42:58.015]         base::withCallingHandlers({
[17:42:58.015]             ...future.value <- base::withVisible(base::local({
[17:42:58.015]                 withCallingHandlers({
[17:42:58.015]                   {
[17:42:58.015]                     ii
[17:42:58.015]                   }
[17:42:58.015]                 }, immediateCondition = function(cond) {
[17:42:58.015]                   save_rds <- function (object, pathname, ...) 
[17:42:58.015]                   {
[17:42:58.015]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:58.015]                     if (file_test("-f", pathname_tmp)) {
[17:42:58.015]                       fi_tmp <- file.info(pathname_tmp)
[17:42:58.015]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:58.015]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:58.015]                         fi_tmp[["mtime"]])
[17:42:58.015]                     }
[17:42:58.015]                     tryCatch({
[17:42:58.015]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:58.015]                     }, error = function(ex) {
[17:42:58.015]                       msg <- conditionMessage(ex)
[17:42:58.015]                       fi_tmp <- file.info(pathname_tmp)
[17:42:58.015]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:58.015]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:58.015]                         fi_tmp[["mtime"]], msg)
[17:42:58.015]                       ex$message <- msg
[17:42:58.015]                       stop(ex)
[17:42:58.015]                     })
[17:42:58.015]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:58.015]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:58.015]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:58.015]                       fi_tmp <- file.info(pathname_tmp)
[17:42:58.015]                       fi <- file.info(pathname)
[17:42:58.015]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:58.015]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:58.015]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:58.015]                         fi[["size"]], fi[["mtime"]])
[17:42:58.015]                       stop(msg)
[17:42:58.015]                     }
[17:42:58.015]                     invisible(pathname)
[17:42:58.015]                   }
[17:42:58.015]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:58.015]                     rootPath = tempdir()) 
[17:42:58.015]                   {
[17:42:58.015]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:58.015]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:58.015]                       tmpdir = path, fileext = ".rds")
[17:42:58.015]                     save_rds(obj, file)
[17:42:58.015]                   }
[17:42:58.015]                   saveImmediateCondition(cond, path = "/tmp/Rtmpie37tE/.future/immediateConditions")
[17:42:58.015]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:58.015]                   {
[17:42:58.015]                     inherits <- base::inherits
[17:42:58.015]                     invokeRestart <- base::invokeRestart
[17:42:58.015]                     is.null <- base::is.null
[17:42:58.015]                     muffled <- FALSE
[17:42:58.015]                     if (inherits(cond, "message")) {
[17:42:58.015]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:58.015]                       if (muffled) 
[17:42:58.015]                         invokeRestart("muffleMessage")
[17:42:58.015]                     }
[17:42:58.015]                     else if (inherits(cond, "warning")) {
[17:42:58.015]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:58.015]                       if (muffled) 
[17:42:58.015]                         invokeRestart("muffleWarning")
[17:42:58.015]                     }
[17:42:58.015]                     else if (inherits(cond, "condition")) {
[17:42:58.015]                       if (!is.null(pattern)) {
[17:42:58.015]                         computeRestarts <- base::computeRestarts
[17:42:58.015]                         grepl <- base::grepl
[17:42:58.015]                         restarts <- computeRestarts(cond)
[17:42:58.015]                         for (restart in restarts) {
[17:42:58.015]                           name <- restart$name
[17:42:58.015]                           if (is.null(name)) 
[17:42:58.015]                             next
[17:42:58.015]                           if (!grepl(pattern, name)) 
[17:42:58.015]                             next
[17:42:58.015]                           invokeRestart(restart)
[17:42:58.015]                           muffled <- TRUE
[17:42:58.015]                           break
[17:42:58.015]                         }
[17:42:58.015]                       }
[17:42:58.015]                     }
[17:42:58.015]                     invisible(muffled)
[17:42:58.015]                   }
[17:42:58.015]                   muffleCondition(cond)
[17:42:58.015]                 })
[17:42:58.015]             }))
[17:42:58.015]             future::FutureResult(value = ...future.value$value, 
[17:42:58.015]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:58.015]                   ...future.rng), globalenv = if (FALSE) 
[17:42:58.015]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:58.015]                     ...future.globalenv.names))
[17:42:58.015]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:58.015]         }, condition = base::local({
[17:42:58.015]             c <- base::c
[17:42:58.015]             inherits <- base::inherits
[17:42:58.015]             invokeRestart <- base::invokeRestart
[17:42:58.015]             length <- base::length
[17:42:58.015]             list <- base::list
[17:42:58.015]             seq.int <- base::seq.int
[17:42:58.015]             signalCondition <- base::signalCondition
[17:42:58.015]             sys.calls <- base::sys.calls
[17:42:58.015]             `[[` <- base::`[[`
[17:42:58.015]             `+` <- base::`+`
[17:42:58.015]             `<<-` <- base::`<<-`
[17:42:58.015]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:58.015]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:58.015]                   3L)]
[17:42:58.015]             }
[17:42:58.015]             function(cond) {
[17:42:58.015]                 is_error <- inherits(cond, "error")
[17:42:58.015]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:58.015]                   NULL)
[17:42:58.015]                 if (is_error) {
[17:42:58.015]                   sessionInformation <- function() {
[17:42:58.015]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:58.015]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:58.015]                       search = base::search(), system = base::Sys.info())
[17:42:58.015]                   }
[17:42:58.015]                   ...future.conditions[[length(...future.conditions) + 
[17:42:58.015]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:58.015]                     cond$call), session = sessionInformation(), 
[17:42:58.015]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:58.015]                   signalCondition(cond)
[17:42:58.015]                 }
[17:42:58.015]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:58.015]                 "immediateCondition"))) {
[17:42:58.015]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:58.015]                   ...future.conditions[[length(...future.conditions) + 
[17:42:58.015]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:58.015]                   if (TRUE && !signal) {
[17:42:58.015]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:58.015]                     {
[17:42:58.015]                       inherits <- base::inherits
[17:42:58.015]                       invokeRestart <- base::invokeRestart
[17:42:58.015]                       is.null <- base::is.null
[17:42:58.015]                       muffled <- FALSE
[17:42:58.015]                       if (inherits(cond, "message")) {
[17:42:58.015]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:58.015]                         if (muffled) 
[17:42:58.015]                           invokeRestart("muffleMessage")
[17:42:58.015]                       }
[17:42:58.015]                       else if (inherits(cond, "warning")) {
[17:42:58.015]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:58.015]                         if (muffled) 
[17:42:58.015]                           invokeRestart("muffleWarning")
[17:42:58.015]                       }
[17:42:58.015]                       else if (inherits(cond, "condition")) {
[17:42:58.015]                         if (!is.null(pattern)) {
[17:42:58.015]                           computeRestarts <- base::computeRestarts
[17:42:58.015]                           grepl <- base::grepl
[17:42:58.015]                           restarts <- computeRestarts(cond)
[17:42:58.015]                           for (restart in restarts) {
[17:42:58.015]                             name <- restart$name
[17:42:58.015]                             if (is.null(name)) 
[17:42:58.015]                               next
[17:42:58.015]                             if (!grepl(pattern, name)) 
[17:42:58.015]                               next
[17:42:58.015]                             invokeRestart(restart)
[17:42:58.015]                             muffled <- TRUE
[17:42:58.015]                             break
[17:42:58.015]                           }
[17:42:58.015]                         }
[17:42:58.015]                       }
[17:42:58.015]                       invisible(muffled)
[17:42:58.015]                     }
[17:42:58.015]                     muffleCondition(cond, pattern = "^muffle")
[17:42:58.015]                   }
[17:42:58.015]                 }
[17:42:58.015]                 else {
[17:42:58.015]                   if (TRUE) {
[17:42:58.015]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:58.015]                     {
[17:42:58.015]                       inherits <- base::inherits
[17:42:58.015]                       invokeRestart <- base::invokeRestart
[17:42:58.015]                       is.null <- base::is.null
[17:42:58.015]                       muffled <- FALSE
[17:42:58.015]                       if (inherits(cond, "message")) {
[17:42:58.015]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:58.015]                         if (muffled) 
[17:42:58.015]                           invokeRestart("muffleMessage")
[17:42:58.015]                       }
[17:42:58.015]                       else if (inherits(cond, "warning")) {
[17:42:58.015]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:58.015]                         if (muffled) 
[17:42:58.015]                           invokeRestart("muffleWarning")
[17:42:58.015]                       }
[17:42:58.015]                       else if (inherits(cond, "condition")) {
[17:42:58.015]                         if (!is.null(pattern)) {
[17:42:58.015]                           computeRestarts <- base::computeRestarts
[17:42:58.015]                           grepl <- base::grepl
[17:42:58.015]                           restarts <- computeRestarts(cond)
[17:42:58.015]                           for (restart in restarts) {
[17:42:58.015]                             name <- restart$name
[17:42:58.015]                             if (is.null(name)) 
[17:42:58.015]                               next
[17:42:58.015]                             if (!grepl(pattern, name)) 
[17:42:58.015]                               next
[17:42:58.015]                             invokeRestart(restart)
[17:42:58.015]                             muffled <- TRUE
[17:42:58.015]                             break
[17:42:58.015]                           }
[17:42:58.015]                         }
[17:42:58.015]                       }
[17:42:58.015]                       invisible(muffled)
[17:42:58.015]                     }
[17:42:58.015]                     muffleCondition(cond, pattern = "^muffle")
[17:42:58.015]                   }
[17:42:58.015]                 }
[17:42:58.015]             }
[17:42:58.015]         }))
[17:42:58.015]     }, error = function(ex) {
[17:42:58.015]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:58.015]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:58.015]                 ...future.rng), started = ...future.startTime, 
[17:42:58.015]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:58.015]             version = "1.8"), class = "FutureResult")
[17:42:58.015]     }, finally = {
[17:42:58.015]         if (!identical(...future.workdir, getwd())) 
[17:42:58.015]             setwd(...future.workdir)
[17:42:58.015]         {
[17:42:58.015]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:58.015]                 ...future.oldOptions$nwarnings <- NULL
[17:42:58.015]             }
[17:42:58.015]             base::options(...future.oldOptions)
[17:42:58.015]             if (.Platform$OS.type == "windows") {
[17:42:58.015]                 old_names <- names(...future.oldEnvVars)
[17:42:58.015]                 envs <- base::Sys.getenv()
[17:42:58.015]                 names <- names(envs)
[17:42:58.015]                 common <- intersect(names, old_names)
[17:42:58.015]                 added <- setdiff(names, old_names)
[17:42:58.015]                 removed <- setdiff(old_names, names)
[17:42:58.015]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:58.015]                   envs[common]]
[17:42:58.015]                 NAMES <- toupper(changed)
[17:42:58.015]                 args <- list()
[17:42:58.015]                 for (kk in seq_along(NAMES)) {
[17:42:58.015]                   name <- changed[[kk]]
[17:42:58.015]                   NAME <- NAMES[[kk]]
[17:42:58.015]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:58.015]                     next
[17:42:58.015]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:58.015]                 }
[17:42:58.015]                 NAMES <- toupper(added)
[17:42:58.015]                 for (kk in seq_along(NAMES)) {
[17:42:58.015]                   name <- added[[kk]]
[17:42:58.015]                   NAME <- NAMES[[kk]]
[17:42:58.015]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:58.015]                     next
[17:42:58.015]                   args[[name]] <- ""
[17:42:58.015]                 }
[17:42:58.015]                 NAMES <- toupper(removed)
[17:42:58.015]                 for (kk in seq_along(NAMES)) {
[17:42:58.015]                   name <- removed[[kk]]
[17:42:58.015]                   NAME <- NAMES[[kk]]
[17:42:58.015]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:58.015]                     next
[17:42:58.015]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:58.015]                 }
[17:42:58.015]                 if (length(args) > 0) 
[17:42:58.015]                   base::do.call(base::Sys.setenv, args = args)
[17:42:58.015]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:58.015]             }
[17:42:58.015]             else {
[17:42:58.015]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:58.015]             }
[17:42:58.015]             {
[17:42:58.015]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:58.015]                   0L) {
[17:42:58.015]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:58.015]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:58.015]                   base::options(opts)
[17:42:58.015]                 }
[17:42:58.015]                 {
[17:42:58.015]                   {
[17:42:58.015]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:58.015]                     NULL
[17:42:58.015]                   }
[17:42:58.015]                   options(future.plan = NULL)
[17:42:58.015]                   if (is.na(NA_character_)) 
[17:42:58.015]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:58.015]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:58.015]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:58.015]                     envir = parent.frame()) 
[17:42:58.015]                   {
[17:42:58.015]                     default_workers <- missing(workers)
[17:42:58.015]                     if (is.function(workers)) 
[17:42:58.015]                       workers <- workers()
[17:42:58.015]                     workers <- structure(as.integer(workers), 
[17:42:58.015]                       class = class(workers))
[17:42:58.015]                     stop_if_not(is.finite(workers), workers >= 
[17:42:58.015]                       1L)
[17:42:58.015]                     if ((workers == 1L && !inherits(workers, 
[17:42:58.015]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:58.015]                       if (default_workers) 
[17:42:58.015]                         supportsMulticore(warn = TRUE)
[17:42:58.015]                       return(sequential(..., envir = envir))
[17:42:58.015]                     }
[17:42:58.015]                     oopts <- options(mc.cores = workers)
[17:42:58.015]                     on.exit(options(oopts))
[17:42:58.015]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:58.015]                       envir = envir)
[17:42:58.015]                     if (!future$lazy) 
[17:42:58.015]                       future <- run(future)
[17:42:58.015]                     invisible(future)
[17:42:58.015]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:58.015]                 }
[17:42:58.015]             }
[17:42:58.015]         }
[17:42:58.015]     })
[17:42:58.015]     if (TRUE) {
[17:42:58.015]         base::sink(type = "output", split = FALSE)
[17:42:58.015]         if (TRUE) {
[17:42:58.015]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:58.015]         }
[17:42:58.015]         else {
[17:42:58.015]             ...future.result["stdout"] <- base::list(NULL)
[17:42:58.015]         }
[17:42:58.015]         base::close(...future.stdout)
[17:42:58.015]         ...future.stdout <- NULL
[17:42:58.015]     }
[17:42:58.015]     ...future.result$conditions <- ...future.conditions
[17:42:58.015]     ...future.result$finished <- base::Sys.time()
[17:42:58.015]     ...future.result
[17:42:58.015] }
[17:42:58.018] assign_globals() ...
[17:42:58.018] List of 1
[17:42:58.018]  $ ii: int 4
[17:42:58.018]  - attr(*, "where")=List of 1
[17:42:58.018]   ..$ ii:<environment: R_EmptyEnv> 
[17:42:58.018]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:58.018]  - attr(*, "resolved")= logi FALSE
[17:42:58.018]  - attr(*, "total_size")= num 56
[17:42:58.022] - copied ‘ii’ to environment
[17:42:58.022] assign_globals() ... done
[17:42:58.022] requestCore(): workers = 2
[17:42:58.023] Poll #1 (0): usedCores() = 2, workers = 2
[17:42:58.037] MulticoreFuture started
 - Resolving 4 multicore futures
[17:42:58.038] plan(): Setting new future strategy stack:
[17:42:58.039] List of future strategies:
[17:42:58.039] 1. sequential:
[17:42:58.039]    - args: function (..., envir = parent.frame())
[17:42:58.039]    - tweaked: FALSE
[17:42:58.039]    - call: NULL
[17:42:58.040] plan(): nbrOfWorkers() = 1
[17:42:58.041] plan(): Setting new future strategy stack:
[17:42:58.042] List of future strategies:
[17:42:58.042] 1. multicore:
[17:42:58.042]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:58.042]    - tweaked: FALSE
[17:42:58.042]    - call: plan(multicore)
[17:42:58.047] plan(): nbrOfWorkers() = 2
*** multicore(..., globals = TRUE) and errors
[17:42:58.052] getGlobalsAndPackages() ...
[17:42:58.052] Searching for globals...
[17:42:58.053] - globals found: [2] ‘{’, ‘stop’
[17:42:58.053] Searching for globals ... DONE
[17:42:58.053] Resolving globals: FALSE
[17:42:58.054] 
[17:42:58.054] 
[17:42:58.054] getGlobalsAndPackages() ... DONE
[17:42:58.055] Packages needed by the future expression (n = 0): <none>
[17:42:58.055] Packages needed by future strategies (n = 0): <none>
[17:42:58.055] {
[17:42:58.055]     {
[17:42:58.055]         {
[17:42:58.055]             ...future.startTime <- base::Sys.time()
[17:42:58.055]             {
[17:42:58.055]                 {
[17:42:58.055]                   {
[17:42:58.055]                     {
[17:42:58.055]                       base::local({
[17:42:58.055]                         has_future <- base::requireNamespace("future", 
[17:42:58.055]                           quietly = TRUE)
[17:42:58.055]                         if (has_future) {
[17:42:58.055]                           ns <- base::getNamespace("future")
[17:42:58.055]                           version <- ns[[".package"]][["version"]]
[17:42:58.055]                           if (is.null(version)) 
[17:42:58.055]                             version <- utils::packageVersion("future")
[17:42:58.055]                         }
[17:42:58.055]                         else {
[17:42:58.055]                           version <- NULL
[17:42:58.055]                         }
[17:42:58.055]                         if (!has_future || version < "1.8.0") {
[17:42:58.055]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:58.055]                             "", base::R.version$version.string), 
[17:42:58.055]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:58.055]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:58.055]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:58.055]                               "release", "version")], collapse = " "), 
[17:42:58.055]                             hostname = base::Sys.info()[["nodename"]])
[17:42:58.055]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:58.055]                             info)
[17:42:58.055]                           info <- base::paste(info, collapse = "; ")
[17:42:58.055]                           if (!has_future) {
[17:42:58.055]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:58.055]                               info)
[17:42:58.055]                           }
[17:42:58.055]                           else {
[17:42:58.055]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:58.055]                               info, version)
[17:42:58.055]                           }
[17:42:58.055]                           base::stop(msg)
[17:42:58.055]                         }
[17:42:58.055]                       })
[17:42:58.055]                     }
[17:42:58.055]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:58.055]                     base::options(mc.cores = 1L)
[17:42:58.055]                   }
[17:42:58.055]                   options(future.plan = NULL)
[17:42:58.055]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:58.055]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:58.055]                 }
[17:42:58.055]                 ...future.workdir <- getwd()
[17:42:58.055]             }
[17:42:58.055]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:58.055]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:58.055]         }
[17:42:58.055]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:58.055]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:58.055]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:58.055]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:58.055]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:58.055]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:58.055]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:58.055]             base::names(...future.oldOptions))
[17:42:58.055]     }
[17:42:58.055]     if (FALSE) {
[17:42:58.055]     }
[17:42:58.055]     else {
[17:42:58.055]         if (TRUE) {
[17:42:58.055]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:58.055]                 open = "w")
[17:42:58.055]         }
[17:42:58.055]         else {
[17:42:58.055]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:58.055]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:58.055]         }
[17:42:58.055]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:58.055]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:58.055]             base::sink(type = "output", split = FALSE)
[17:42:58.055]             base::close(...future.stdout)
[17:42:58.055]         }, add = TRUE)
[17:42:58.055]     }
[17:42:58.055]     ...future.frame <- base::sys.nframe()
[17:42:58.055]     ...future.conditions <- base::list()
[17:42:58.055]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:58.055]     if (FALSE) {
[17:42:58.055]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:58.055]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:58.055]     }
[17:42:58.055]     ...future.result <- base::tryCatch({
[17:42:58.055]         base::withCallingHandlers({
[17:42:58.055]             ...future.value <- base::withVisible(base::local({
[17:42:58.055]                 withCallingHandlers({
[17:42:58.055]                   {
[17:42:58.055]                     stop("Whoops!")
[17:42:58.055]                     1
[17:42:58.055]                   }
[17:42:58.055]                 }, immediateCondition = function(cond) {
[17:42:58.055]                   save_rds <- function (object, pathname, ...) 
[17:42:58.055]                   {
[17:42:58.055]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:58.055]                     if (file_test("-f", pathname_tmp)) {
[17:42:58.055]                       fi_tmp <- file.info(pathname_tmp)
[17:42:58.055]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:58.055]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:58.055]                         fi_tmp[["mtime"]])
[17:42:58.055]                     }
[17:42:58.055]                     tryCatch({
[17:42:58.055]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:58.055]                     }, error = function(ex) {
[17:42:58.055]                       msg <- conditionMessage(ex)
[17:42:58.055]                       fi_tmp <- file.info(pathname_tmp)
[17:42:58.055]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:58.055]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:58.055]                         fi_tmp[["mtime"]], msg)
[17:42:58.055]                       ex$message <- msg
[17:42:58.055]                       stop(ex)
[17:42:58.055]                     })
[17:42:58.055]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:58.055]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:58.055]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:58.055]                       fi_tmp <- file.info(pathname_tmp)
[17:42:58.055]                       fi <- file.info(pathname)
[17:42:58.055]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:58.055]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:58.055]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:58.055]                         fi[["size"]], fi[["mtime"]])
[17:42:58.055]                       stop(msg)
[17:42:58.055]                     }
[17:42:58.055]                     invisible(pathname)
[17:42:58.055]                   }
[17:42:58.055]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:58.055]                     rootPath = tempdir()) 
[17:42:58.055]                   {
[17:42:58.055]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:58.055]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:58.055]                       tmpdir = path, fileext = ".rds")
[17:42:58.055]                     save_rds(obj, file)
[17:42:58.055]                   }
[17:42:58.055]                   saveImmediateCondition(cond, path = "/tmp/Rtmpie37tE/.future/immediateConditions")
[17:42:58.055]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:58.055]                   {
[17:42:58.055]                     inherits <- base::inherits
[17:42:58.055]                     invokeRestart <- base::invokeRestart
[17:42:58.055]                     is.null <- base::is.null
[17:42:58.055]                     muffled <- FALSE
[17:42:58.055]                     if (inherits(cond, "message")) {
[17:42:58.055]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:58.055]                       if (muffled) 
[17:42:58.055]                         invokeRestart("muffleMessage")
[17:42:58.055]                     }
[17:42:58.055]                     else if (inherits(cond, "warning")) {
[17:42:58.055]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:58.055]                       if (muffled) 
[17:42:58.055]                         invokeRestart("muffleWarning")
[17:42:58.055]                     }
[17:42:58.055]                     else if (inherits(cond, "condition")) {
[17:42:58.055]                       if (!is.null(pattern)) {
[17:42:58.055]                         computeRestarts <- base::computeRestarts
[17:42:58.055]                         grepl <- base::grepl
[17:42:58.055]                         restarts <- computeRestarts(cond)
[17:42:58.055]                         for (restart in restarts) {
[17:42:58.055]                           name <- restart$name
[17:42:58.055]                           if (is.null(name)) 
[17:42:58.055]                             next
[17:42:58.055]                           if (!grepl(pattern, name)) 
[17:42:58.055]                             next
[17:42:58.055]                           invokeRestart(restart)
[17:42:58.055]                           muffled <- TRUE
[17:42:58.055]                           break
[17:42:58.055]                         }
[17:42:58.055]                       }
[17:42:58.055]                     }
[17:42:58.055]                     invisible(muffled)
[17:42:58.055]                   }
[17:42:58.055]                   muffleCondition(cond)
[17:42:58.055]                 })
[17:42:58.055]             }))
[17:42:58.055]             future::FutureResult(value = ...future.value$value, 
[17:42:58.055]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:58.055]                   ...future.rng), globalenv = if (FALSE) 
[17:42:58.055]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:58.055]                     ...future.globalenv.names))
[17:42:58.055]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:58.055]         }, condition = base::local({
[17:42:58.055]             c <- base::c
[17:42:58.055]             inherits <- base::inherits
[17:42:58.055]             invokeRestart <- base::invokeRestart
[17:42:58.055]             length <- base::length
[17:42:58.055]             list <- base::list
[17:42:58.055]             seq.int <- base::seq.int
[17:42:58.055]             signalCondition <- base::signalCondition
[17:42:58.055]             sys.calls <- base::sys.calls
[17:42:58.055]             `[[` <- base::`[[`
[17:42:58.055]             `+` <- base::`+`
[17:42:58.055]             `<<-` <- base::`<<-`
[17:42:58.055]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:58.055]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:58.055]                   3L)]
[17:42:58.055]             }
[17:42:58.055]             function(cond) {
[17:42:58.055]                 is_error <- inherits(cond, "error")
[17:42:58.055]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:58.055]                   NULL)
[17:42:58.055]                 if (is_error) {
[17:42:58.055]                   sessionInformation <- function() {
[17:42:58.055]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:58.055]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:58.055]                       search = base::search(), system = base::Sys.info())
[17:42:58.055]                   }
[17:42:58.055]                   ...future.conditions[[length(...future.conditions) + 
[17:42:58.055]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:58.055]                     cond$call), session = sessionInformation(), 
[17:42:58.055]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:58.055]                   signalCondition(cond)
[17:42:58.055]                 }
[17:42:58.055]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:58.055]                 "immediateCondition"))) {
[17:42:58.055]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:58.055]                   ...future.conditions[[length(...future.conditions) + 
[17:42:58.055]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:58.055]                   if (TRUE && !signal) {
[17:42:58.055]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:58.055]                     {
[17:42:58.055]                       inherits <- base::inherits
[17:42:58.055]                       invokeRestart <- base::invokeRestart
[17:42:58.055]                       is.null <- base::is.null
[17:42:58.055]                       muffled <- FALSE
[17:42:58.055]                       if (inherits(cond, "message")) {
[17:42:58.055]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:58.055]                         if (muffled) 
[17:42:58.055]                           invokeRestart("muffleMessage")
[17:42:58.055]                       }
[17:42:58.055]                       else if (inherits(cond, "warning")) {
[17:42:58.055]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:58.055]                         if (muffled) 
[17:42:58.055]                           invokeRestart("muffleWarning")
[17:42:58.055]                       }
[17:42:58.055]                       else if (inherits(cond, "condition")) {
[17:42:58.055]                         if (!is.null(pattern)) {
[17:42:58.055]                           computeRestarts <- base::computeRestarts
[17:42:58.055]                           grepl <- base::grepl
[17:42:58.055]                           restarts <- computeRestarts(cond)
[17:42:58.055]                           for (restart in restarts) {
[17:42:58.055]                             name <- restart$name
[17:42:58.055]                             if (is.null(name)) 
[17:42:58.055]                               next
[17:42:58.055]                             if (!grepl(pattern, name)) 
[17:42:58.055]                               next
[17:42:58.055]                             invokeRestart(restart)
[17:42:58.055]                             muffled <- TRUE
[17:42:58.055]                             break
[17:42:58.055]                           }
[17:42:58.055]                         }
[17:42:58.055]                       }
[17:42:58.055]                       invisible(muffled)
[17:42:58.055]                     }
[17:42:58.055]                     muffleCondition(cond, pattern = "^muffle")
[17:42:58.055]                   }
[17:42:58.055]                 }
[17:42:58.055]                 else {
[17:42:58.055]                   if (TRUE) {
[17:42:58.055]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:58.055]                     {
[17:42:58.055]                       inherits <- base::inherits
[17:42:58.055]                       invokeRestart <- base::invokeRestart
[17:42:58.055]                       is.null <- base::is.null
[17:42:58.055]                       muffled <- FALSE
[17:42:58.055]                       if (inherits(cond, "message")) {
[17:42:58.055]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:58.055]                         if (muffled) 
[17:42:58.055]                           invokeRestart("muffleMessage")
[17:42:58.055]                       }
[17:42:58.055]                       else if (inherits(cond, "warning")) {
[17:42:58.055]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:58.055]                         if (muffled) 
[17:42:58.055]                           invokeRestart("muffleWarning")
[17:42:58.055]                       }
[17:42:58.055]                       else if (inherits(cond, "condition")) {
[17:42:58.055]                         if (!is.null(pattern)) {
[17:42:58.055]                           computeRestarts <- base::computeRestarts
[17:42:58.055]                           grepl <- base::grepl
[17:42:58.055]                           restarts <- computeRestarts(cond)
[17:42:58.055]                           for (restart in restarts) {
[17:42:58.055]                             name <- restart$name
[17:42:58.055]                             if (is.null(name)) 
[17:42:58.055]                               next
[17:42:58.055]                             if (!grepl(pattern, name)) 
[17:42:58.055]                               next
[17:42:58.055]                             invokeRestart(restart)
[17:42:58.055]                             muffled <- TRUE
[17:42:58.055]                             break
[17:42:58.055]                           }
[17:42:58.055]                         }
[17:42:58.055]                       }
[17:42:58.055]                       invisible(muffled)
[17:42:58.055]                     }
[17:42:58.055]                     muffleCondition(cond, pattern = "^muffle")
[17:42:58.055]                   }
[17:42:58.055]                 }
[17:42:58.055]             }
[17:42:58.055]         }))
[17:42:58.055]     }, error = function(ex) {
[17:42:58.055]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:58.055]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:58.055]                 ...future.rng), started = ...future.startTime, 
[17:42:58.055]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:58.055]             version = "1.8"), class = "FutureResult")
[17:42:58.055]     }, finally = {
[17:42:58.055]         if (!identical(...future.workdir, getwd())) 
[17:42:58.055]             setwd(...future.workdir)
[17:42:58.055]         {
[17:42:58.055]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:58.055]                 ...future.oldOptions$nwarnings <- NULL
[17:42:58.055]             }
[17:42:58.055]             base::options(...future.oldOptions)
[17:42:58.055]             if (.Platform$OS.type == "windows") {
[17:42:58.055]                 old_names <- names(...future.oldEnvVars)
[17:42:58.055]                 envs <- base::Sys.getenv()
[17:42:58.055]                 names <- names(envs)
[17:42:58.055]                 common <- intersect(names, old_names)
[17:42:58.055]                 added <- setdiff(names, old_names)
[17:42:58.055]                 removed <- setdiff(old_names, names)
[17:42:58.055]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:58.055]                   envs[common]]
[17:42:58.055]                 NAMES <- toupper(changed)
[17:42:58.055]                 args <- list()
[17:42:58.055]                 for (kk in seq_along(NAMES)) {
[17:42:58.055]                   name <- changed[[kk]]
[17:42:58.055]                   NAME <- NAMES[[kk]]
[17:42:58.055]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:58.055]                     next
[17:42:58.055]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:58.055]                 }
[17:42:58.055]                 NAMES <- toupper(added)
[17:42:58.055]                 for (kk in seq_along(NAMES)) {
[17:42:58.055]                   name <- added[[kk]]
[17:42:58.055]                   NAME <- NAMES[[kk]]
[17:42:58.055]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:58.055]                     next
[17:42:58.055]                   args[[name]] <- ""
[17:42:58.055]                 }
[17:42:58.055]                 NAMES <- toupper(removed)
[17:42:58.055]                 for (kk in seq_along(NAMES)) {
[17:42:58.055]                   name <- removed[[kk]]
[17:42:58.055]                   NAME <- NAMES[[kk]]
[17:42:58.055]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:58.055]                     next
[17:42:58.055]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:58.055]                 }
[17:42:58.055]                 if (length(args) > 0) 
[17:42:58.055]                   base::do.call(base::Sys.setenv, args = args)
[17:42:58.055]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:58.055]             }
[17:42:58.055]             else {
[17:42:58.055]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:58.055]             }
[17:42:58.055]             {
[17:42:58.055]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:58.055]                   0L) {
[17:42:58.055]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:58.055]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:58.055]                   base::options(opts)
[17:42:58.055]                 }
[17:42:58.055]                 {
[17:42:58.055]                   {
[17:42:58.055]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:58.055]                     NULL
[17:42:58.055]                   }
[17:42:58.055]                   options(future.plan = NULL)
[17:42:58.055]                   if (is.na(NA_character_)) 
[17:42:58.055]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:58.055]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:58.055]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:58.055]                     envir = parent.frame()) 
[17:42:58.055]                   {
[17:42:58.055]                     default_workers <- missing(workers)
[17:42:58.055]                     if (is.function(workers)) 
[17:42:58.055]                       workers <- workers()
[17:42:58.055]                     workers <- structure(as.integer(workers), 
[17:42:58.055]                       class = class(workers))
[17:42:58.055]                     stop_if_not(is.finite(workers), workers >= 
[17:42:58.055]                       1L)
[17:42:58.055]                     if ((workers == 1L && !inherits(workers, 
[17:42:58.055]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:58.055]                       if (default_workers) 
[17:42:58.055]                         supportsMulticore(warn = TRUE)
[17:42:58.055]                       return(sequential(..., envir = envir))
[17:42:58.055]                     }
[17:42:58.055]                     oopts <- options(mc.cores = workers)
[17:42:58.055]                     on.exit(options(oopts))
[17:42:58.055]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:58.055]                       envir = envir)
[17:42:58.055]                     if (!future$lazy) 
[17:42:58.055]                       future <- run(future)
[17:42:58.055]                     invisible(future)
[17:42:58.055]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:58.055]                 }
[17:42:58.055]             }
[17:42:58.055]         }
[17:42:58.055]     })
[17:42:58.055]     if (TRUE) {
[17:42:58.055]         base::sink(type = "output", split = FALSE)
[17:42:58.055]         if (TRUE) {
[17:42:58.055]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:58.055]         }
[17:42:58.055]         else {
[17:42:58.055]             ...future.result["stdout"] <- base::list(NULL)
[17:42:58.055]         }
[17:42:58.055]         base::close(...future.stdout)
[17:42:58.055]         ...future.stdout <- NULL
[17:42:58.055]     }
[17:42:58.055]     ...future.result$conditions <- ...future.conditions
[17:42:58.055]     ...future.result$finished <- base::Sys.time()
[17:42:58.055]     ...future.result
[17:42:58.055] }
[17:42:58.058] requestCore(): workers = 2
[17:42:58.060] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:42:58.061] plan(): Setting new future strategy stack:
[17:42:58.061] List of future strategies:
[17:42:58.061] 1. sequential:
[17:42:58.061]    - args: function (..., envir = parent.frame())
[17:42:58.061]    - tweaked: FALSE
[17:42:58.061]    - call: NULL
[17:42:58.062] plan(): nbrOfWorkers() = 1
[17:42:58.064] plan(): Setting new future strategy stack:
[17:42:58.064] List of future strategies:
[17:42:58.064] 1. multicore:
[17:42:58.064]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:58.064]    - tweaked: FALSE
[17:42:58.064]    - call: plan(multicore)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 56280105-ab48-3cfb-51ca-f6f685381758
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:58.074] plan(): nbrOfWorkers() = 2
[17:42:58.079] signalConditions() ...
[17:42:58.079]  - include = ‘immediateCondition’
[17:42:58.079]  - exclude = 
[17:42:58.079]  - resignal = FALSE
[17:42:58.079]  - Number of conditions: 1
[17:42:58.083] signalConditions() ... done
[17:42:58.083] signalConditions() ...
[17:42:58.083]  - include = ‘immediateCondition’
[17:42:58.083]  - exclude = 
[17:42:58.083]  - resignal = FALSE
[17:42:58.083]  - Number of conditions: 1
[17:42:58.083] signalConditions() ... done
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/Rtmpie37tE/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[17:42:58.084] signalConditions() ...
[17:42:58.084]  - include = ‘immediateCondition’
[17:42:58.084]  - exclude = 
[17:42:58.085]  - resignal = FALSE
[17:42:58.085]  - Number of conditions: 1
[17:42:58.085] signalConditions() ... done
[17:42:58.085] Future state: ‘finished’
[17:42:58.085] signalConditions() ...
[17:42:58.085]  - include = ‘condition’
[17:42:58.086]  - exclude = ‘immediateCondition’
[17:42:58.086]  - resignal = TRUE
[17:42:58.086]  - Number of conditions: 1
[17:42:58.086]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:42:58.086] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/Rtmpie37tE/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[17:42:58.087] signalConditions() ...
[17:42:58.087]  - include = ‘immediateCondition’
[17:42:58.087]  - exclude = 
[17:42:58.088]  - resignal = FALSE
[17:42:58.088]  - Number of conditions: 1
[17:42:58.088] signalConditions() ... done
[17:42:58.088] Future state: ‘finished’
[17:42:58.088] signalConditions() ...
[17:42:58.088]  - include = ‘condition’
[17:42:58.088]  - exclude = ‘immediateCondition’
[17:42:58.088]  - resignal = TRUE
[17:42:58.089]  - Number of conditions: 1
[17:42:58.089]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:42:58.089] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/Rtmpie37tE/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[17:42:58.094] getGlobalsAndPackages() ...
[17:42:58.094] 
[17:42:58.094] - globals: [0] <none>
[17:42:58.094] getGlobalsAndPackages() ... DONE
[17:42:58.095] Packages needed by the future expression (n = 0): <none>
[17:42:58.095] Packages needed by future strategies (n = 0): <none>
[17:42:58.096] {
[17:42:58.096]     {
[17:42:58.096]         {
[17:42:58.096]             ...future.startTime <- base::Sys.time()
[17:42:58.096]             {
[17:42:58.096]                 {
[17:42:58.096]                   {
[17:42:58.096]                     {
[17:42:58.096]                       base::local({
[17:42:58.096]                         has_future <- base::requireNamespace("future", 
[17:42:58.096]                           quietly = TRUE)
[17:42:58.096]                         if (has_future) {
[17:42:58.096]                           ns <- base::getNamespace("future")
[17:42:58.096]                           version <- ns[[".package"]][["version"]]
[17:42:58.096]                           if (is.null(version)) 
[17:42:58.096]                             version <- utils::packageVersion("future")
[17:42:58.096]                         }
[17:42:58.096]                         else {
[17:42:58.096]                           version <- NULL
[17:42:58.096]                         }
[17:42:58.096]                         if (!has_future || version < "1.8.0") {
[17:42:58.096]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:58.096]                             "", base::R.version$version.string), 
[17:42:58.096]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:58.096]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:58.096]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:58.096]                               "release", "version")], collapse = " "), 
[17:42:58.096]                             hostname = base::Sys.info()[["nodename"]])
[17:42:58.096]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:58.096]                             info)
[17:42:58.096]                           info <- base::paste(info, collapse = "; ")
[17:42:58.096]                           if (!has_future) {
[17:42:58.096]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:58.096]                               info)
[17:42:58.096]                           }
[17:42:58.096]                           else {
[17:42:58.096]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:58.096]                               info, version)
[17:42:58.096]                           }
[17:42:58.096]                           base::stop(msg)
[17:42:58.096]                         }
[17:42:58.096]                       })
[17:42:58.096]                     }
[17:42:58.096]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:58.096]                     base::options(mc.cores = 1L)
[17:42:58.096]                   }
[17:42:58.096]                   options(future.plan = NULL)
[17:42:58.096]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:58.096]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:58.096]                 }
[17:42:58.096]                 ...future.workdir <- getwd()
[17:42:58.096]             }
[17:42:58.096]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:58.096]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:58.096]         }
[17:42:58.096]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:58.096]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:58.096]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:58.096]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:58.096]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:58.096]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:58.096]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:58.096]             base::names(...future.oldOptions))
[17:42:58.096]     }
[17:42:58.096]     if (FALSE) {
[17:42:58.096]     }
[17:42:58.096]     else {
[17:42:58.096]         if (TRUE) {
[17:42:58.096]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:58.096]                 open = "w")
[17:42:58.096]         }
[17:42:58.096]         else {
[17:42:58.096]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:58.096]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:58.096]         }
[17:42:58.096]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:58.096]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:58.096]             base::sink(type = "output", split = FALSE)
[17:42:58.096]             base::close(...future.stdout)
[17:42:58.096]         }, add = TRUE)
[17:42:58.096]     }
[17:42:58.096]     ...future.frame <- base::sys.nframe()
[17:42:58.096]     ...future.conditions <- base::list()
[17:42:58.096]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:58.096]     if (FALSE) {
[17:42:58.096]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:58.096]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:58.096]     }
[17:42:58.096]     ...future.result <- base::tryCatch({
[17:42:58.096]         base::withCallingHandlers({
[17:42:58.096]             ...future.value <- base::withVisible(base::local({
[17:42:58.096]                 withCallingHandlers({
[17:42:58.096]                   {
[17:42:58.096]                     stop(structure(list(message = "boom"), class = c("MyError", 
[17:42:58.096]                       "error", "condition")))
[17:42:58.096]                   }
[17:42:58.096]                 }, immediateCondition = function(cond) {
[17:42:58.096]                   save_rds <- function (object, pathname, ...) 
[17:42:58.096]                   {
[17:42:58.096]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:58.096]                     if (file_test("-f", pathname_tmp)) {
[17:42:58.096]                       fi_tmp <- file.info(pathname_tmp)
[17:42:58.096]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:58.096]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:58.096]                         fi_tmp[["mtime"]])
[17:42:58.096]                     }
[17:42:58.096]                     tryCatch({
[17:42:58.096]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:58.096]                     }, error = function(ex) {
[17:42:58.096]                       msg <- conditionMessage(ex)
[17:42:58.096]                       fi_tmp <- file.info(pathname_tmp)
[17:42:58.096]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:58.096]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:58.096]                         fi_tmp[["mtime"]], msg)
[17:42:58.096]                       ex$message <- msg
[17:42:58.096]                       stop(ex)
[17:42:58.096]                     })
[17:42:58.096]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:58.096]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:58.096]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:58.096]                       fi_tmp <- file.info(pathname_tmp)
[17:42:58.096]                       fi <- file.info(pathname)
[17:42:58.096]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:58.096]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:58.096]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:58.096]                         fi[["size"]], fi[["mtime"]])
[17:42:58.096]                       stop(msg)
[17:42:58.096]                     }
[17:42:58.096]                     invisible(pathname)
[17:42:58.096]                   }
[17:42:58.096]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:58.096]                     rootPath = tempdir()) 
[17:42:58.096]                   {
[17:42:58.096]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:58.096]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:58.096]                       tmpdir = path, fileext = ".rds")
[17:42:58.096]                     save_rds(obj, file)
[17:42:58.096]                   }
[17:42:58.096]                   saveImmediateCondition(cond, path = "/tmp/Rtmpie37tE/.future/immediateConditions")
[17:42:58.096]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:58.096]                   {
[17:42:58.096]                     inherits <- base::inherits
[17:42:58.096]                     invokeRestart <- base::invokeRestart
[17:42:58.096]                     is.null <- base::is.null
[17:42:58.096]                     muffled <- FALSE
[17:42:58.096]                     if (inherits(cond, "message")) {
[17:42:58.096]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:58.096]                       if (muffled) 
[17:42:58.096]                         invokeRestart("muffleMessage")
[17:42:58.096]                     }
[17:42:58.096]                     else if (inherits(cond, "warning")) {
[17:42:58.096]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:58.096]                       if (muffled) 
[17:42:58.096]                         invokeRestart("muffleWarning")
[17:42:58.096]                     }
[17:42:58.096]                     else if (inherits(cond, "condition")) {
[17:42:58.096]                       if (!is.null(pattern)) {
[17:42:58.096]                         computeRestarts <- base::computeRestarts
[17:42:58.096]                         grepl <- base::grepl
[17:42:58.096]                         restarts <- computeRestarts(cond)
[17:42:58.096]                         for (restart in restarts) {
[17:42:58.096]                           name <- restart$name
[17:42:58.096]                           if (is.null(name)) 
[17:42:58.096]                             next
[17:42:58.096]                           if (!grepl(pattern, name)) 
[17:42:58.096]                             next
[17:42:58.096]                           invokeRestart(restart)
[17:42:58.096]                           muffled <- TRUE
[17:42:58.096]                           break
[17:42:58.096]                         }
[17:42:58.096]                       }
[17:42:58.096]                     }
[17:42:58.096]                     invisible(muffled)
[17:42:58.096]                   }
[17:42:58.096]                   muffleCondition(cond)
[17:42:58.096]                 })
[17:42:58.096]             }))
[17:42:58.096]             future::FutureResult(value = ...future.value$value, 
[17:42:58.096]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:58.096]                   ...future.rng), globalenv = if (FALSE) 
[17:42:58.096]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:58.096]                     ...future.globalenv.names))
[17:42:58.096]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:58.096]         }, condition = base::local({
[17:42:58.096]             c <- base::c
[17:42:58.096]             inherits <- base::inherits
[17:42:58.096]             invokeRestart <- base::invokeRestart
[17:42:58.096]             length <- base::length
[17:42:58.096]             list <- base::list
[17:42:58.096]             seq.int <- base::seq.int
[17:42:58.096]             signalCondition <- base::signalCondition
[17:42:58.096]             sys.calls <- base::sys.calls
[17:42:58.096]             `[[` <- base::`[[`
[17:42:58.096]             `+` <- base::`+`
[17:42:58.096]             `<<-` <- base::`<<-`
[17:42:58.096]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:58.096]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:58.096]                   3L)]
[17:42:58.096]             }
[17:42:58.096]             function(cond) {
[17:42:58.096]                 is_error <- inherits(cond, "error")
[17:42:58.096]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:58.096]                   NULL)
[17:42:58.096]                 if (is_error) {
[17:42:58.096]                   sessionInformation <- function() {
[17:42:58.096]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:58.096]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:58.096]                       search = base::search(), system = base::Sys.info())
[17:42:58.096]                   }
[17:42:58.096]                   ...future.conditions[[length(...future.conditions) + 
[17:42:58.096]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:58.096]                     cond$call), session = sessionInformation(), 
[17:42:58.096]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:58.096]                   signalCondition(cond)
[17:42:58.096]                 }
[17:42:58.096]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:58.096]                 "immediateCondition"))) {
[17:42:58.096]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:58.096]                   ...future.conditions[[length(...future.conditions) + 
[17:42:58.096]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:58.096]                   if (TRUE && !signal) {
[17:42:58.096]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:58.096]                     {
[17:42:58.096]                       inherits <- base::inherits
[17:42:58.096]                       invokeRestart <- base::invokeRestart
[17:42:58.096]                       is.null <- base::is.null
[17:42:58.096]                       muffled <- FALSE
[17:42:58.096]                       if (inherits(cond, "message")) {
[17:42:58.096]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:58.096]                         if (muffled) 
[17:42:58.096]                           invokeRestart("muffleMessage")
[17:42:58.096]                       }
[17:42:58.096]                       else if (inherits(cond, "warning")) {
[17:42:58.096]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:58.096]                         if (muffled) 
[17:42:58.096]                           invokeRestart("muffleWarning")
[17:42:58.096]                       }
[17:42:58.096]                       else if (inherits(cond, "condition")) {
[17:42:58.096]                         if (!is.null(pattern)) {
[17:42:58.096]                           computeRestarts <- base::computeRestarts
[17:42:58.096]                           grepl <- base::grepl
[17:42:58.096]                           restarts <- computeRestarts(cond)
[17:42:58.096]                           for (restart in restarts) {
[17:42:58.096]                             name <- restart$name
[17:42:58.096]                             if (is.null(name)) 
[17:42:58.096]                               next
[17:42:58.096]                             if (!grepl(pattern, name)) 
[17:42:58.096]                               next
[17:42:58.096]                             invokeRestart(restart)
[17:42:58.096]                             muffled <- TRUE
[17:42:58.096]                             break
[17:42:58.096]                           }
[17:42:58.096]                         }
[17:42:58.096]                       }
[17:42:58.096]                       invisible(muffled)
[17:42:58.096]                     }
[17:42:58.096]                     muffleCondition(cond, pattern = "^muffle")
[17:42:58.096]                   }
[17:42:58.096]                 }
[17:42:58.096]                 else {
[17:42:58.096]                   if (TRUE) {
[17:42:58.096]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:58.096]                     {
[17:42:58.096]                       inherits <- base::inherits
[17:42:58.096]                       invokeRestart <- base::invokeRestart
[17:42:58.096]                       is.null <- base::is.null
[17:42:58.096]                       muffled <- FALSE
[17:42:58.096]                       if (inherits(cond, "message")) {
[17:42:58.096]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:58.096]                         if (muffled) 
[17:42:58.096]                           invokeRestart("muffleMessage")
[17:42:58.096]                       }
[17:42:58.096]                       else if (inherits(cond, "warning")) {
[17:42:58.096]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:58.096]                         if (muffled) 
[17:42:58.096]                           invokeRestart("muffleWarning")
[17:42:58.096]                       }
[17:42:58.096]                       else if (inherits(cond, "condition")) {
[17:42:58.096]                         if (!is.null(pattern)) {
[17:42:58.096]                           computeRestarts <- base::computeRestarts
[17:42:58.096]                           grepl <- base::grepl
[17:42:58.096]                           restarts <- computeRestarts(cond)
[17:42:58.096]                           for (restart in restarts) {
[17:42:58.096]                             name <- restart$name
[17:42:58.096]                             if (is.null(name)) 
[17:42:58.096]                               next
[17:42:58.096]                             if (!grepl(pattern, name)) 
[17:42:58.096]                               next
[17:42:58.096]                             invokeRestart(restart)
[17:42:58.096]                             muffled <- TRUE
[17:42:58.096]                             break
[17:42:58.096]                           }
[17:42:58.096]                         }
[17:42:58.096]                       }
[17:42:58.096]                       invisible(muffled)
[17:42:58.096]                     }
[17:42:58.096]                     muffleCondition(cond, pattern = "^muffle")
[17:42:58.096]                   }
[17:42:58.096]                 }
[17:42:58.096]             }
[17:42:58.096]         }))
[17:42:58.096]     }, error = function(ex) {
[17:42:58.096]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:58.096]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:58.096]                 ...future.rng), started = ...future.startTime, 
[17:42:58.096]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:58.096]             version = "1.8"), class = "FutureResult")
[17:42:58.096]     }, finally = {
[17:42:58.096]         if (!identical(...future.workdir, getwd())) 
[17:42:58.096]             setwd(...future.workdir)
[17:42:58.096]         {
[17:42:58.096]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:58.096]                 ...future.oldOptions$nwarnings <- NULL
[17:42:58.096]             }
[17:42:58.096]             base::options(...future.oldOptions)
[17:42:58.096]             if (.Platform$OS.type == "windows") {
[17:42:58.096]                 old_names <- names(...future.oldEnvVars)
[17:42:58.096]                 envs <- base::Sys.getenv()
[17:42:58.096]                 names <- names(envs)
[17:42:58.096]                 common <- intersect(names, old_names)
[17:42:58.096]                 added <- setdiff(names, old_names)
[17:42:58.096]                 removed <- setdiff(old_names, names)
[17:42:58.096]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:58.096]                   envs[common]]
[17:42:58.096]                 NAMES <- toupper(changed)
[17:42:58.096]                 args <- list()
[17:42:58.096]                 for (kk in seq_along(NAMES)) {
[17:42:58.096]                   name <- changed[[kk]]
[17:42:58.096]                   NAME <- NAMES[[kk]]
[17:42:58.096]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:58.096]                     next
[17:42:58.096]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:58.096]                 }
[17:42:58.096]                 NAMES <- toupper(added)
[17:42:58.096]                 for (kk in seq_along(NAMES)) {
[17:42:58.096]                   name <- added[[kk]]
[17:42:58.096]                   NAME <- NAMES[[kk]]
[17:42:58.096]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:58.096]                     next
[17:42:58.096]                   args[[name]] <- ""
[17:42:58.096]                 }
[17:42:58.096]                 NAMES <- toupper(removed)
[17:42:58.096]                 for (kk in seq_along(NAMES)) {
[17:42:58.096]                   name <- removed[[kk]]
[17:42:58.096]                   NAME <- NAMES[[kk]]
[17:42:58.096]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:58.096]                     next
[17:42:58.096]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:58.096]                 }
[17:42:58.096]                 if (length(args) > 0) 
[17:42:58.096]                   base::do.call(base::Sys.setenv, args = args)
[17:42:58.096]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:58.096]             }
[17:42:58.096]             else {
[17:42:58.096]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:58.096]             }
[17:42:58.096]             {
[17:42:58.096]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:58.096]                   0L) {
[17:42:58.096]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:58.096]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:58.096]                   base::options(opts)
[17:42:58.096]                 }
[17:42:58.096]                 {
[17:42:58.096]                   {
[17:42:58.096]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:58.096]                     NULL
[17:42:58.096]                   }
[17:42:58.096]                   options(future.plan = NULL)
[17:42:58.096]                   if (is.na(NA_character_)) 
[17:42:58.096]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:58.096]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:58.096]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:58.096]                     envir = parent.frame()) 
[17:42:58.096]                   {
[17:42:58.096]                     default_workers <- missing(workers)
[17:42:58.096]                     if (is.function(workers)) 
[17:42:58.096]                       workers <- workers()
[17:42:58.096]                     workers <- structure(as.integer(workers), 
[17:42:58.096]                       class = class(workers))
[17:42:58.096]                     stop_if_not(is.finite(workers), workers >= 
[17:42:58.096]                       1L)
[17:42:58.096]                     if ((workers == 1L && !inherits(workers, 
[17:42:58.096]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:58.096]                       if (default_workers) 
[17:42:58.096]                         supportsMulticore(warn = TRUE)
[17:42:58.096]                       return(sequential(..., envir = envir))
[17:42:58.096]                     }
[17:42:58.096]                     oopts <- options(mc.cores = workers)
[17:42:58.096]                     on.exit(options(oopts))
[17:42:58.096]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:58.096]                       envir = envir)
[17:42:58.096]                     if (!future$lazy) 
[17:42:58.096]                       future <- run(future)
[17:42:58.096]                     invisible(future)
[17:42:58.096]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:58.096]                 }
[17:42:58.096]             }
[17:42:58.096]         }
[17:42:58.096]     })
[17:42:58.096]     if (TRUE) {
[17:42:58.096]         base::sink(type = "output", split = FALSE)
[17:42:58.096]         if (TRUE) {
[17:42:58.096]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:58.096]         }
[17:42:58.096]         else {
[17:42:58.096]             ...future.result["stdout"] <- base::list(NULL)
[17:42:58.096]         }
[17:42:58.096]         base::close(...future.stdout)
[17:42:58.096]         ...future.stdout <- NULL
[17:42:58.096]     }
[17:42:58.096]     ...future.result$conditions <- ...future.conditions
[17:42:58.096]     ...future.result$finished <- base::Sys.time()
[17:42:58.096]     ...future.result
[17:42:58.096] }
[17:42:58.098] requestCore(): workers = 2
[17:42:58.100] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:42:58.101] plan(): Setting new future strategy stack:
[17:42:58.101] List of future strategies:
[17:42:58.101] 1. sequential:
[17:42:58.101]    - args: function (..., envir = parent.frame())
[17:42:58.101]    - tweaked: FALSE
[17:42:58.101]    - call: NULL
[17:42:58.102] plan(): nbrOfWorkers() = 1
[17:42:58.104] plan(): Setting new future strategy stack:
[17:42:58.104] List of future strategies:
[17:42:58.104] 1. multicore:
[17:42:58.104]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:58.104]    - tweaked: FALSE
[17:42:58.104]    - call: plan(multicore)
[17:42:58.109] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 56280105-ab48-3cfb-51ca-f6f685381758
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:58.114] signalConditions() ...
[17:42:58.114]  - include = ‘immediateCondition’
[17:42:58.114]  - exclude = 
[17:42:58.114]  - resignal = FALSE
[17:42:58.114]  - Number of conditions: 1
[17:42:58.115] signalConditions() ... done
[17:42:58.115] signalConditions() ...
[17:42:58.115]  - include = ‘immediateCondition’
[17:42:58.115]  - exclude = 
[17:42:58.115]  - resignal = FALSE
[17:42:58.115]  - Number of conditions: 1
[17:42:58.115] signalConditions() ... done
<MyError: boom>
[17:42:58.116] signalConditions() ...
[17:42:58.116]  - include = ‘immediateCondition’
[17:42:58.116]  - exclude = 
[17:42:58.116]  - resignal = FALSE
[17:42:58.116]  - Number of conditions: 1
[17:42:58.116] signalConditions() ... done
[17:42:58.116] Future state: ‘finished’
[17:42:58.117] signalConditions() ...
[17:42:58.117]  - include = ‘condition’
[17:42:58.117]  - exclude = ‘immediateCondition’
[17:42:58.117]  - resignal = TRUE
[17:42:58.117]  - Number of conditions: 1
[17:42:58.117]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[17:42:58.117] signalConditions() ... done
*** multicore(..., workers = 1L) ...
[17:42:58.118] getGlobalsAndPackages() ...
[17:42:58.118] Searching for globals...
[17:42:58.119] - globals found: [4] ‘{’, ‘*’, ‘a’, ‘b’
[17:42:58.119] Searching for globals ... DONE
[17:42:58.119] Resolving globals: FALSE
[17:42:58.120] The total size of the 2 globals is 112 bytes (112 bytes)
[17:42:58.120] The total size of the 2 globals exported for future expression (‘{; a * b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘b’ (56 bytes of class ‘numeric’)
[17:42:58.120] - globals: [2] ‘a’, ‘b’
[17:42:58.121] 
[17:42:58.121] getGlobalsAndPackages() ... DONE
[17:42:58.121] Packages needed by the future expression (n = 0): <none>
[17:42:58.121] Packages needed by future strategies (n = 0): <none>
[17:42:58.122] {
[17:42:58.122]     {
[17:42:58.122]         {
[17:42:58.122]             ...future.startTime <- base::Sys.time()
[17:42:58.122]             {
[17:42:58.122]                 {
[17:42:58.122]                   {
[17:42:58.122]                     base::local({
[17:42:58.122]                       has_future <- base::requireNamespace("future", 
[17:42:58.122]                         quietly = TRUE)
[17:42:58.122]                       if (has_future) {
[17:42:58.122]                         ns <- base::getNamespace("future")
[17:42:58.122]                         version <- ns[[".package"]][["version"]]
[17:42:58.122]                         if (is.null(version)) 
[17:42:58.122]                           version <- utils::packageVersion("future")
[17:42:58.122]                       }
[17:42:58.122]                       else {
[17:42:58.122]                         version <- NULL
[17:42:58.122]                       }
[17:42:58.122]                       if (!has_future || version < "1.8.0") {
[17:42:58.122]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:58.122]                           "", base::R.version$version.string), 
[17:42:58.122]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:58.122]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:58.122]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:58.122]                             "release", "version")], collapse = " "), 
[17:42:58.122]                           hostname = base::Sys.info()[["nodename"]])
[17:42:58.122]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:58.122]                           info)
[17:42:58.122]                         info <- base::paste(info, collapse = "; ")
[17:42:58.122]                         if (!has_future) {
[17:42:58.122]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:58.122]                             info)
[17:42:58.122]                         }
[17:42:58.122]                         else {
[17:42:58.122]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:58.122]                             info, version)
[17:42:58.122]                         }
[17:42:58.122]                         base::stop(msg)
[17:42:58.122]                       }
[17:42:58.122]                     })
[17:42:58.122]                   }
[17:42:58.122]                   options(future.plan = NULL)
[17:42:58.122]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:58.122]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:58.122]                 }
[17:42:58.122]                 ...future.workdir <- getwd()
[17:42:58.122]             }
[17:42:58.122]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:58.122]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:58.122]         }
[17:42:58.122]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:58.122]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:58.122]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:58.122]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:58.122]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:58.122]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:58.122]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:58.122]             base::names(...future.oldOptions))
[17:42:58.122]     }
[17:42:58.122]     if (FALSE) {
[17:42:58.122]     }
[17:42:58.122]     else {
[17:42:58.122]         if (TRUE) {
[17:42:58.122]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:58.122]                 open = "w")
[17:42:58.122]         }
[17:42:58.122]         else {
[17:42:58.122]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:58.122]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:58.122]         }
[17:42:58.122]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:58.122]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:58.122]             base::sink(type = "output", split = FALSE)
[17:42:58.122]             base::close(...future.stdout)
[17:42:58.122]         }, add = TRUE)
[17:42:58.122]     }
[17:42:58.122]     ...future.frame <- base::sys.nframe()
[17:42:58.122]     ...future.conditions <- base::list()
[17:42:58.122]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:58.122]     if (FALSE) {
[17:42:58.122]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:58.122]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:58.122]     }
[17:42:58.122]     ...future.result <- base::tryCatch({
[17:42:58.122]         base::withCallingHandlers({
[17:42:58.122]             ...future.value <- base::withVisible(base::local({
[17:42:58.122]                 a * b
[17:42:58.122]             }))
[17:42:58.122]             future::FutureResult(value = ...future.value$value, 
[17:42:58.122]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:58.122]                   ...future.rng), globalenv = if (FALSE) 
[17:42:58.122]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:58.122]                     ...future.globalenv.names))
[17:42:58.122]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:58.122]         }, condition = base::local({
[17:42:58.122]             c <- base::c
[17:42:58.122]             inherits <- base::inherits
[17:42:58.122]             invokeRestart <- base::invokeRestart
[17:42:58.122]             length <- base::length
[17:42:58.122]             list <- base::list
[17:42:58.122]             seq.int <- base::seq.int
[17:42:58.122]             signalCondition <- base::signalCondition
[17:42:58.122]             sys.calls <- base::sys.calls
[17:42:58.122]             `[[` <- base::`[[`
[17:42:58.122]             `+` <- base::`+`
[17:42:58.122]             `<<-` <- base::`<<-`
[17:42:58.122]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:58.122]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:58.122]                   3L)]
[17:42:58.122]             }
[17:42:58.122]             function(cond) {
[17:42:58.122]                 is_error <- inherits(cond, "error")
[17:42:58.122]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:58.122]                   NULL)
[17:42:58.122]                 if (is_error) {
[17:42:58.122]                   sessionInformation <- function() {
[17:42:58.122]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:58.122]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:58.122]                       search = base::search(), system = base::Sys.info())
[17:42:58.122]                   }
[17:42:58.122]                   ...future.conditions[[length(...future.conditions) + 
[17:42:58.122]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:58.122]                     cond$call), session = sessionInformation(), 
[17:42:58.122]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:58.122]                   signalCondition(cond)
[17:42:58.122]                 }
[17:42:58.122]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:58.122]                 "immediateCondition"))) {
[17:42:58.122]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:58.122]                   ...future.conditions[[length(...future.conditions) + 
[17:42:58.122]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:58.122]                   if (TRUE && !signal) {
[17:42:58.122]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:58.122]                     {
[17:42:58.122]                       inherits <- base::inherits
[17:42:58.122]                       invokeRestart <- base::invokeRestart
[17:42:58.122]                       is.null <- base::is.null
[17:42:58.122]                       muffled <- FALSE
[17:42:58.122]                       if (inherits(cond, "message")) {
[17:42:58.122]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:58.122]                         if (muffled) 
[17:42:58.122]                           invokeRestart("muffleMessage")
[17:42:58.122]                       }
[17:42:58.122]                       else if (inherits(cond, "warning")) {
[17:42:58.122]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:58.122]                         if (muffled) 
[17:42:58.122]                           invokeRestart("muffleWarning")
[17:42:58.122]                       }
[17:42:58.122]                       else if (inherits(cond, "condition")) {
[17:42:58.122]                         if (!is.null(pattern)) {
[17:42:58.122]                           computeRestarts <- base::computeRestarts
[17:42:58.122]                           grepl <- base::grepl
[17:42:58.122]                           restarts <- computeRestarts(cond)
[17:42:58.122]                           for (restart in restarts) {
[17:42:58.122]                             name <- restart$name
[17:42:58.122]                             if (is.null(name)) 
[17:42:58.122]                               next
[17:42:58.122]                             if (!grepl(pattern, name)) 
[17:42:58.122]                               next
[17:42:58.122]                             invokeRestart(restart)
[17:42:58.122]                             muffled <- TRUE
[17:42:58.122]                             break
[17:42:58.122]                           }
[17:42:58.122]                         }
[17:42:58.122]                       }
[17:42:58.122]                       invisible(muffled)
[17:42:58.122]                     }
[17:42:58.122]                     muffleCondition(cond, pattern = "^muffle")
[17:42:58.122]                   }
[17:42:58.122]                 }
[17:42:58.122]                 else {
[17:42:58.122]                   if (TRUE) {
[17:42:58.122]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:58.122]                     {
[17:42:58.122]                       inherits <- base::inherits
[17:42:58.122]                       invokeRestart <- base::invokeRestart
[17:42:58.122]                       is.null <- base::is.null
[17:42:58.122]                       muffled <- FALSE
[17:42:58.122]                       if (inherits(cond, "message")) {
[17:42:58.122]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:58.122]                         if (muffled) 
[17:42:58.122]                           invokeRestart("muffleMessage")
[17:42:58.122]                       }
[17:42:58.122]                       else if (inherits(cond, "warning")) {
[17:42:58.122]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:58.122]                         if (muffled) 
[17:42:58.122]                           invokeRestart("muffleWarning")
[17:42:58.122]                       }
[17:42:58.122]                       else if (inherits(cond, "condition")) {
[17:42:58.122]                         if (!is.null(pattern)) {
[17:42:58.122]                           computeRestarts <- base::computeRestarts
[17:42:58.122]                           grepl <- base::grepl
[17:42:58.122]                           restarts <- computeRestarts(cond)
[17:42:58.122]                           for (restart in restarts) {
[17:42:58.122]                             name <- restart$name
[17:42:58.122]                             if (is.null(name)) 
[17:42:58.122]                               next
[17:42:58.122]                             if (!grepl(pattern, name)) 
[17:42:58.122]                               next
[17:42:58.122]                             invokeRestart(restart)
[17:42:58.122]                             muffled <- TRUE
[17:42:58.122]                             break
[17:42:58.122]                           }
[17:42:58.122]                         }
[17:42:58.122]                       }
[17:42:58.122]                       invisible(muffled)
[17:42:58.122]                     }
[17:42:58.122]                     muffleCondition(cond, pattern = "^muffle")
[17:42:58.122]                   }
[17:42:58.122]                 }
[17:42:58.122]             }
[17:42:58.122]         }))
[17:42:58.122]     }, error = function(ex) {
[17:42:58.122]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:58.122]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:58.122]                 ...future.rng), started = ...future.startTime, 
[17:42:58.122]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:58.122]             version = "1.8"), class = "FutureResult")
[17:42:58.122]     }, finally = {
[17:42:58.122]         if (!identical(...future.workdir, getwd())) 
[17:42:58.122]             setwd(...future.workdir)
[17:42:58.122]         {
[17:42:58.122]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:58.122]                 ...future.oldOptions$nwarnings <- NULL
[17:42:58.122]             }
[17:42:58.122]             base::options(...future.oldOptions)
[17:42:58.122]             if (.Platform$OS.type == "windows") {
[17:42:58.122]                 old_names <- names(...future.oldEnvVars)
[17:42:58.122]                 envs <- base::Sys.getenv()
[17:42:58.122]                 names <- names(envs)
[17:42:58.122]                 common <- intersect(names, old_names)
[17:42:58.122]                 added <- setdiff(names, old_names)
[17:42:58.122]                 removed <- setdiff(old_names, names)
[17:42:58.122]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:58.122]                   envs[common]]
[17:42:58.122]                 NAMES <- toupper(changed)
[17:42:58.122]                 args <- list()
[17:42:58.122]                 for (kk in seq_along(NAMES)) {
[17:42:58.122]                   name <- changed[[kk]]
[17:42:58.122]                   NAME <- NAMES[[kk]]
[17:42:58.122]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:58.122]                     next
[17:42:58.122]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:58.122]                 }
[17:42:58.122]                 NAMES <- toupper(added)
[17:42:58.122]                 for (kk in seq_along(NAMES)) {
[17:42:58.122]                   name <- added[[kk]]
[17:42:58.122]                   NAME <- NAMES[[kk]]
[17:42:58.122]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:58.122]                     next
[17:42:58.122]                   args[[name]] <- ""
[17:42:58.122]                 }
[17:42:58.122]                 NAMES <- toupper(removed)
[17:42:58.122]                 for (kk in seq_along(NAMES)) {
[17:42:58.122]                   name <- removed[[kk]]
[17:42:58.122]                   NAME <- NAMES[[kk]]
[17:42:58.122]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:58.122]                     next
[17:42:58.122]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:58.122]                 }
[17:42:58.122]                 if (length(args) > 0) 
[17:42:58.122]                   base::do.call(base::Sys.setenv, args = args)
[17:42:58.122]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:58.122]             }
[17:42:58.122]             else {
[17:42:58.122]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:58.122]             }
[17:42:58.122]             {
[17:42:58.122]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:58.122]                   0L) {
[17:42:58.122]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:58.122]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:58.122]                   base::options(opts)
[17:42:58.122]                 }
[17:42:58.122]                 {
[17:42:58.122]                   {
[17:42:58.122]                     NULL
[17:42:58.122]                     RNGkind("Mersenne-Twister")
[17:42:58.122]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:58.122]                       inherits = FALSE)
[17:42:58.122]                   }
[17:42:58.122]                   options(future.plan = NULL)
[17:42:58.122]                   if (is.na(NA_character_)) 
[17:42:58.122]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:58.122]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:58.122]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:58.122]                     envir = parent.frame()) 
[17:42:58.122]                   {
[17:42:58.122]                     default_workers <- missing(workers)
[17:42:58.122]                     if (is.function(workers)) 
[17:42:58.122]                       workers <- workers()
[17:42:58.122]                     workers <- structure(as.integer(workers), 
[17:42:58.122]                       class = class(workers))
[17:42:58.122]                     stop_if_not(is.finite(workers), workers >= 
[17:42:58.122]                       1L)
[17:42:58.122]                     if ((workers == 1L && !inherits(workers, 
[17:42:58.122]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:58.122]                       if (default_workers) 
[17:42:58.122]                         supportsMulticore(warn = TRUE)
[17:42:58.122]                       return(sequential(..., envir = envir))
[17:42:58.122]                     }
[17:42:58.122]                     oopts <- options(mc.cores = workers)
[17:42:58.122]                     on.exit(options(oopts))
[17:42:58.122]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:58.122]                       envir = envir)
[17:42:58.122]                     if (!future$lazy) 
[17:42:58.122]                       future <- run(future)
[17:42:58.122]                     invisible(future)
[17:42:58.122]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:58.122]                 }
[17:42:58.122]             }
[17:42:58.122]         }
[17:42:58.122]     })
[17:42:58.122]     if (TRUE) {
[17:42:58.122]         base::sink(type = "output", split = FALSE)
[17:42:58.122]         if (TRUE) {
[17:42:58.122]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:58.122]         }
[17:42:58.122]         else {
[17:42:58.122]             ...future.result["stdout"] <- base::list(NULL)
[17:42:58.122]         }
[17:42:58.122]         base::close(...future.stdout)
[17:42:58.122]         ...future.stdout <- NULL
[17:42:58.122]     }
[17:42:58.122]     ...future.result$conditions <- ...future.conditions
[17:42:58.122]     ...future.result$finished <- base::Sys.time()
[17:42:58.122]     ...future.result
[17:42:58.122] }
[17:42:58.124] assign_globals() ...
[17:42:58.124] List of 2
[17:42:58.124]  $ a: num 2
[17:42:58.124]  $ b: num 3
[17:42:58.124]  - attr(*, "where")=List of 2
[17:42:58.124]   ..$ a:<environment: R_EmptyEnv> 
[17:42:58.124]   ..$ b:<environment: R_EmptyEnv> 
[17:42:58.124]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:58.124]  - attr(*, "resolved")= logi FALSE
[17:42:58.124]  - attr(*, "total_size")= num 112
[17:42:58.127] - copied ‘a’ to environment
[17:42:58.128] - copied ‘b’ to environment
[17:42:58.128] assign_globals() ... done
[17:42:58.128] plan(): Setting new future strategy stack:
[17:42:58.128] List of future strategies:
[17:42:58.128] 1. sequential:
[17:42:58.128]    - args: function (..., envir = parent.frame())
[17:42:58.128]    - tweaked: FALSE
[17:42:58.128]    - call: NULL
[17:42:58.128] plan(): nbrOfWorkers() = 1
[17:42:58.132] plan(): Setting new future strategy stack:
[17:42:58.132] List of future strategies:
[17:42:58.132] 1. multicore:
[17:42:58.132]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:58.132]    - tweaked: FALSE
[17:42:58.132]    - call: plan(multicore)
[17:42:58.136] plan(): nbrOfWorkers() = 2
[17:42:58.136] SequentialFuture started (and completed)
[1] 6
*** multicore(..., workers = 1L) ... DONE
Testing with 2 cores ... DONE
> 
> message("*** multicore() ... DONE")
*** multicore() ... DONE
> 
> source("incl/end.R")
[17:42:58.137] plan(): Setting new future strategy stack:
[17:42:58.137] List of future strategies:
[17:42:58.137] 1. FutureStrategy:
[17:42:58.137]    - args: function (..., envir = parent.frame())
[17:42:58.137]    - tweaked: FALSE
[17:42:58.137]    - call: future::plan(oplan)
[17:42:58.138] plan(): nbrOfWorkers() = 1
> 
