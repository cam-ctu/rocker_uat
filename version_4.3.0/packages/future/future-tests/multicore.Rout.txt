
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[13:21:03.099] plan(): Setting new future strategy stack:
[13:21:03.100] List of future strategies:
[13:21:03.100] 1. sequential:
[13:21:03.100]    - args: function (..., envir = parent.frame())
[13:21:03.100]    - tweaked: FALSE
[13:21:03.100]    - call: future::plan("sequential")
[13:21:03.112] plan(): nbrOfWorkers() = 1
> library("listenv")
> plan(multicore)
[13:21:03.124] plan(): Setting new future strategy stack:
[13:21:03.124] List of future strategies:
[13:21:03.124] 1. multicore:
[13:21:03.124]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:03.124]    - tweaked: FALSE
[13:21:03.124]    - call: plan(multicore)
[13:21:03.138] plan(): nbrOfWorkers() = 2
> 
> message("*** multicore() ...")
*** multicore() ...
> 
> for (cores in 1:min(2L, availableCores("multicore"))) {
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   if (!supportsMulticore()) {
+     message(sprintf("Multicore futures are not supporting on '%s'. Falling back to use synchronous sequential futures", .Platform$OS.type))
+   }
+ 
+   nworkers <- nbrOfWorkers()
+   message("Number of workers: ", nworkers)
+   stopifnot(nworkers == cores)
+   
+   for (globals in c(FALSE, TRUE)) {
+ 
+     message(sprintf("*** multicore(..., globals = %s) without globals", globals))
+   
+     f <- multicore({
+       42L
+     }, globals = globals)
+     stopifnot(inherits(f, "MulticoreFuture") || ((cores ==1 || !supportsMulticore()) && inherits(f, "SequentialFuture")))
+   
+     print(resolved(f))
+     y <- value(f)
+     print(y)
+     stopifnot(y == 42L)
+   
+   
+     message(sprintf("*** multicore(..., globals = %s) with globals", globals))
+     ## A global variable
+     a <- 0
+     f <- multicore({
+       b <- 3
+       c <- 2
+       a * b * c
+     }, globals = globals)
+     print(f)
+   
+   
+     ## A multicore future is evaluated in a separated
+     ## forked process.  Changing the value of a global
+     ## variable should not affect the result of the
+     ## future.
+     a <- 7  ## Make sure globals are frozen
+     v <- value(f)
+     print(v)
+     stopifnot(v == 0)
+   
+   
+     message(sprintf("*** multicore(..., globals = %s) with globals and blocking", globals))
+     x <- listenv()
+     for (ii in 1:4) {
+       message(sprintf(" - Creating multicore future #%d ...", ii))
+       x[[ii]] <- multicore({ ii }, globals = globals)
+     }
+     message(sprintf(" - Resolving %d multicore futures", length(x)))
+     v <- sapply(x, FUN = value)
+     stopifnot(all(v == 1:4))
+   
+   
+     message(sprintf("*** multicore(..., globals = %s) and errors", globals))
+     f <- multicore({
+       stop("Whoops!")
+       1
+     }, globals = globals)
+     print(f)
+     v <- value(f, signal = FALSE)
+     print(v)
+     stopifnot(inherits(v, "simpleError"))
+   
+     res <- try(value(f), silent = TRUE)
+     print(res)
+     stopifnot(inherits(res, "try-error"))
+   
+     ## Error is repeated
+     res <- try(value(f), silent = TRUE)
+     print(res)
+     stopifnot(inherits(res, "try-error"))
+ 
+     ## Custom error class
+     f <- multicore({
+       stop(structure(list(message = "boom"),
+                      class = c("MyError", "error", "condition")))
+     })
+     print(f)
+     v <- value(f, signal = FALSE)
+     print(v)
+     stopifnot(inherits(v, "error"), inherits(v, "MyError"))
+   
+     ## Make sure error is signaled
+     res <- tryCatch(value(f), error = identity)
+     stopifnot(inherits(res, "error"))
+   
+     ## Issue #200: Custom condition class attributes are lost 
+     stopifnot(inherits(res, "MyError"))    
+   } # for (globals ...)
+ 
+ 
+   message("*** multicore(..., workers = 1L) ...")
+ 
+   a <- 2
+   b <- 3
+   yTruth <- a * b
+ 
+   f <- multicore({ a * b }, globals = TRUE, workers = 1L)
+   rm(list = c("a", "b"))
+ 
+   v <- value(f)
+   print(v)
+   stopifnot(v == yTruth)
+ 
+   message("*** multicore(..., workers = 1L) ... DONE")
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
Number of workers: 1
*** multicore(..., globals = FALSE) without globals
[13:21:03.197] getGlobalsAndPackages() ...
[13:21:03.197] Not searching for globals
[13:21:03.197] - globals: [0] <none>
[13:21:03.197] getGlobalsAndPackages() ... DONE
[13:21:03.198] Packages needed by the future expression (n = 0): <none>
[13:21:03.198] Packages needed by future strategies (n = 0): <none>
[13:21:03.199] {
[13:21:03.199]     {
[13:21:03.199]         {
[13:21:03.199]             ...future.startTime <- base::Sys.time()
[13:21:03.199]             {
[13:21:03.199]                 {
[13:21:03.199]                   {
[13:21:03.199]                     base::local({
[13:21:03.199]                       has_future <- base::requireNamespace("future", 
[13:21:03.199]                         quietly = TRUE)
[13:21:03.199]                       if (has_future) {
[13:21:03.199]                         ns <- base::getNamespace("future")
[13:21:03.199]                         version <- ns[[".package"]][["version"]]
[13:21:03.199]                         if (is.null(version)) 
[13:21:03.199]                           version <- utils::packageVersion("future")
[13:21:03.199]                       }
[13:21:03.199]                       else {
[13:21:03.199]                         version <- NULL
[13:21:03.199]                       }
[13:21:03.199]                       if (!has_future || version < "1.8.0") {
[13:21:03.199]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:03.199]                           "", base::R.version$version.string), 
[13:21:03.199]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:03.199]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:03.199]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:03.199]                             "release", "version")], collapse = " "), 
[13:21:03.199]                           hostname = base::Sys.info()[["nodename"]])
[13:21:03.199]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:03.199]                           info)
[13:21:03.199]                         info <- base::paste(info, collapse = "; ")
[13:21:03.199]                         if (!has_future) {
[13:21:03.199]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:03.199]                             info)
[13:21:03.199]                         }
[13:21:03.199]                         else {
[13:21:03.199]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:03.199]                             info, version)
[13:21:03.199]                         }
[13:21:03.199]                         base::stop(msg)
[13:21:03.199]                       }
[13:21:03.199]                     })
[13:21:03.199]                   }
[13:21:03.199]                   options(future.plan = NULL)
[13:21:03.199]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.199]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:03.199]                 }
[13:21:03.199]                 ...future.workdir <- getwd()
[13:21:03.199]             }
[13:21:03.199]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:03.199]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:03.199]         }
[13:21:03.199]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:03.199]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:03.199]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:03.199]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:03.199]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:03.199]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:03.199]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:03.199]             base::names(...future.oldOptions))
[13:21:03.199]     }
[13:21:03.199]     if (FALSE) {
[13:21:03.199]     }
[13:21:03.199]     else {
[13:21:03.199]         if (TRUE) {
[13:21:03.199]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:03.199]                 open = "w")
[13:21:03.199]         }
[13:21:03.199]         else {
[13:21:03.199]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:03.199]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:03.199]         }
[13:21:03.199]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:03.199]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:03.199]             base::sink(type = "output", split = FALSE)
[13:21:03.199]             base::close(...future.stdout)
[13:21:03.199]         }, add = TRUE)
[13:21:03.199]     }
[13:21:03.199]     ...future.frame <- base::sys.nframe()
[13:21:03.199]     ...future.conditions <- base::list()
[13:21:03.199]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:03.199]     if (FALSE) {
[13:21:03.199]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:03.199]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:03.199]     }
[13:21:03.199]     ...future.result <- base::tryCatch({
[13:21:03.199]         base::withCallingHandlers({
[13:21:03.199]             ...future.value <- base::withVisible(base::local({
[13:21:03.199]                 42L
[13:21:03.199]             }))
[13:21:03.199]             future::FutureResult(value = ...future.value$value, 
[13:21:03.199]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.199]                   ...future.rng), globalenv = if (FALSE) 
[13:21:03.199]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:03.199]                     ...future.globalenv.names))
[13:21:03.199]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:03.199]         }, condition = base::local({
[13:21:03.199]             c <- base::c
[13:21:03.199]             inherits <- base::inherits
[13:21:03.199]             invokeRestart <- base::invokeRestart
[13:21:03.199]             length <- base::length
[13:21:03.199]             list <- base::list
[13:21:03.199]             seq.int <- base::seq.int
[13:21:03.199]             signalCondition <- base::signalCondition
[13:21:03.199]             sys.calls <- base::sys.calls
[13:21:03.199]             `[[` <- base::`[[`
[13:21:03.199]             `+` <- base::`+`
[13:21:03.199]             `<<-` <- base::`<<-`
[13:21:03.199]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:03.199]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:03.199]                   3L)]
[13:21:03.199]             }
[13:21:03.199]             function(cond) {
[13:21:03.199]                 is_error <- inherits(cond, "error")
[13:21:03.199]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:03.199]                   NULL)
[13:21:03.199]                 if (is_error) {
[13:21:03.199]                   sessionInformation <- function() {
[13:21:03.199]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:03.199]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:03.199]                       search = base::search(), system = base::Sys.info())
[13:21:03.199]                   }
[13:21:03.199]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.199]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:03.199]                     cond$call), session = sessionInformation(), 
[13:21:03.199]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:03.199]                   signalCondition(cond)
[13:21:03.199]                 }
[13:21:03.199]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:03.199]                 "immediateCondition"))) {
[13:21:03.199]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:03.199]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.199]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:03.199]                   if (TRUE && !signal) {
[13:21:03.199]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.199]                     {
[13:21:03.199]                       inherits <- base::inherits
[13:21:03.199]                       invokeRestart <- base::invokeRestart
[13:21:03.199]                       is.null <- base::is.null
[13:21:03.199]                       muffled <- FALSE
[13:21:03.199]                       if (inherits(cond, "message")) {
[13:21:03.199]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.199]                         if (muffled) 
[13:21:03.199]                           invokeRestart("muffleMessage")
[13:21:03.199]                       }
[13:21:03.199]                       else if (inherits(cond, "warning")) {
[13:21:03.199]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.199]                         if (muffled) 
[13:21:03.199]                           invokeRestart("muffleWarning")
[13:21:03.199]                       }
[13:21:03.199]                       else if (inherits(cond, "condition")) {
[13:21:03.199]                         if (!is.null(pattern)) {
[13:21:03.199]                           computeRestarts <- base::computeRestarts
[13:21:03.199]                           grepl <- base::grepl
[13:21:03.199]                           restarts <- computeRestarts(cond)
[13:21:03.199]                           for (restart in restarts) {
[13:21:03.199]                             name <- restart$name
[13:21:03.199]                             if (is.null(name)) 
[13:21:03.199]                               next
[13:21:03.199]                             if (!grepl(pattern, name)) 
[13:21:03.199]                               next
[13:21:03.199]                             invokeRestart(restart)
[13:21:03.199]                             muffled <- TRUE
[13:21:03.199]                             break
[13:21:03.199]                           }
[13:21:03.199]                         }
[13:21:03.199]                       }
[13:21:03.199]                       invisible(muffled)
[13:21:03.199]                     }
[13:21:03.199]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.199]                   }
[13:21:03.199]                 }
[13:21:03.199]                 else {
[13:21:03.199]                   if (TRUE) {
[13:21:03.199]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.199]                     {
[13:21:03.199]                       inherits <- base::inherits
[13:21:03.199]                       invokeRestart <- base::invokeRestart
[13:21:03.199]                       is.null <- base::is.null
[13:21:03.199]                       muffled <- FALSE
[13:21:03.199]                       if (inherits(cond, "message")) {
[13:21:03.199]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.199]                         if (muffled) 
[13:21:03.199]                           invokeRestart("muffleMessage")
[13:21:03.199]                       }
[13:21:03.199]                       else if (inherits(cond, "warning")) {
[13:21:03.199]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.199]                         if (muffled) 
[13:21:03.199]                           invokeRestart("muffleWarning")
[13:21:03.199]                       }
[13:21:03.199]                       else if (inherits(cond, "condition")) {
[13:21:03.199]                         if (!is.null(pattern)) {
[13:21:03.199]                           computeRestarts <- base::computeRestarts
[13:21:03.199]                           grepl <- base::grepl
[13:21:03.199]                           restarts <- computeRestarts(cond)
[13:21:03.199]                           for (restart in restarts) {
[13:21:03.199]                             name <- restart$name
[13:21:03.199]                             if (is.null(name)) 
[13:21:03.199]                               next
[13:21:03.199]                             if (!grepl(pattern, name)) 
[13:21:03.199]                               next
[13:21:03.199]                             invokeRestart(restart)
[13:21:03.199]                             muffled <- TRUE
[13:21:03.199]                             break
[13:21:03.199]                           }
[13:21:03.199]                         }
[13:21:03.199]                       }
[13:21:03.199]                       invisible(muffled)
[13:21:03.199]                     }
[13:21:03.199]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.199]                   }
[13:21:03.199]                 }
[13:21:03.199]             }
[13:21:03.199]         }))
[13:21:03.199]     }, error = function(ex) {
[13:21:03.199]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:03.199]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.199]                 ...future.rng), started = ...future.startTime, 
[13:21:03.199]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:03.199]             version = "1.8"), class = "FutureResult")
[13:21:03.199]     }, finally = {
[13:21:03.199]         if (!identical(...future.workdir, getwd())) 
[13:21:03.199]             setwd(...future.workdir)
[13:21:03.199]         {
[13:21:03.199]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:03.199]                 ...future.oldOptions$nwarnings <- NULL
[13:21:03.199]             }
[13:21:03.199]             base::options(...future.oldOptions)
[13:21:03.199]             if (.Platform$OS.type == "windows") {
[13:21:03.199]                 old_names <- names(...future.oldEnvVars)
[13:21:03.199]                 envs <- base::Sys.getenv()
[13:21:03.199]                 names <- names(envs)
[13:21:03.199]                 common <- intersect(names, old_names)
[13:21:03.199]                 added <- setdiff(names, old_names)
[13:21:03.199]                 removed <- setdiff(old_names, names)
[13:21:03.199]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:03.199]                   envs[common]]
[13:21:03.199]                 NAMES <- toupper(changed)
[13:21:03.199]                 args <- list()
[13:21:03.199]                 for (kk in seq_along(NAMES)) {
[13:21:03.199]                   name <- changed[[kk]]
[13:21:03.199]                   NAME <- NAMES[[kk]]
[13:21:03.199]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.199]                     next
[13:21:03.199]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.199]                 }
[13:21:03.199]                 NAMES <- toupper(added)
[13:21:03.199]                 for (kk in seq_along(NAMES)) {
[13:21:03.199]                   name <- added[[kk]]
[13:21:03.199]                   NAME <- NAMES[[kk]]
[13:21:03.199]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.199]                     next
[13:21:03.199]                   args[[name]] <- ""
[13:21:03.199]                 }
[13:21:03.199]                 NAMES <- toupper(removed)
[13:21:03.199]                 for (kk in seq_along(NAMES)) {
[13:21:03.199]                   name <- removed[[kk]]
[13:21:03.199]                   NAME <- NAMES[[kk]]
[13:21:03.199]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.199]                     next
[13:21:03.199]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.199]                 }
[13:21:03.199]                 if (length(args) > 0) 
[13:21:03.199]                   base::do.call(base::Sys.setenv, args = args)
[13:21:03.199]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:03.199]             }
[13:21:03.199]             else {
[13:21:03.199]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:03.199]             }
[13:21:03.199]             {
[13:21:03.199]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:03.199]                   0L) {
[13:21:03.199]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:03.199]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:03.199]                   base::options(opts)
[13:21:03.199]                 }
[13:21:03.199]                 {
[13:21:03.199]                   {
[13:21:03.199]                     NULL
[13:21:03.199]                     RNGkind("Mersenne-Twister")
[13:21:03.199]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:03.199]                       inherits = FALSE)
[13:21:03.199]                   }
[13:21:03.199]                   options(future.plan = NULL)
[13:21:03.199]                   if (is.na(NA_character_)) 
[13:21:03.199]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.199]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:03.199]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:03.199]                     envir = parent.frame()) 
[13:21:03.199]                   {
[13:21:03.199]                     default_workers <- missing(workers)
[13:21:03.199]                     if (is.function(workers)) 
[13:21:03.199]                       workers <- workers()
[13:21:03.199]                     workers <- structure(as.integer(workers), 
[13:21:03.199]                       class = class(workers))
[13:21:03.199]                     stop_if_not(is.finite(workers), workers >= 
[13:21:03.199]                       1L)
[13:21:03.199]                     if ((workers == 1L && !inherits(workers, 
[13:21:03.199]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:03.199]                       if (default_workers) 
[13:21:03.199]                         supportsMulticore(warn = TRUE)
[13:21:03.199]                       return(sequential(..., envir = envir))
[13:21:03.199]                     }
[13:21:03.199]                     oopts <- options(mc.cores = workers)
[13:21:03.199]                     on.exit(options(oopts))
[13:21:03.199]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:03.199]                       envir = envir)
[13:21:03.199]                     if (!future$lazy) 
[13:21:03.199]                       future <- run(future)
[13:21:03.199]                     invisible(future)
[13:21:03.199]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:03.199]                 }
[13:21:03.199]             }
[13:21:03.199]         }
[13:21:03.199]     })
[13:21:03.199]     if (TRUE) {
[13:21:03.199]         base::sink(type = "output", split = FALSE)
[13:21:03.199]         if (TRUE) {
[13:21:03.199]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:03.199]         }
[13:21:03.199]         else {
[13:21:03.199]             ...future.result["stdout"] <- base::list(NULL)
[13:21:03.199]         }
[13:21:03.199]         base::close(...future.stdout)
[13:21:03.199]         ...future.stdout <- NULL
[13:21:03.199]     }
[13:21:03.199]     ...future.result$conditions <- ...future.conditions
[13:21:03.199]     ...future.result$finished <- base::Sys.time()
[13:21:03.199]     ...future.result
[13:21:03.199] }
[13:21:03.201] plan(): Setting new future strategy stack:
[13:21:03.201] List of future strategies:
[13:21:03.201] 1. sequential:
[13:21:03.201]    - args: function (..., envir = parent.frame())
[13:21:03.201]    - tweaked: FALSE
[13:21:03.201]    - call: NULL
[13:21:03.202] plan(): nbrOfWorkers() = 1
[13:21:03.203] plan(): Setting new future strategy stack:
[13:21:03.203] List of future strategies:
[13:21:03.203] 1. multicore:
[13:21:03.203]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:03.203]    - tweaked: FALSE
[13:21:03.203]    - call: plan(multicore)
[13:21:03.206] plan(): nbrOfWorkers() = 1
[13:21:03.207] SequentialFuture started (and completed)
[13:21:03.207] resolved() for ‘SequentialFuture’ ...
[13:21:03.207] - state: ‘finished’
[13:21:03.207] - run: TRUE
[13:21:03.208] - result: ‘FutureResult’
[13:21:03.208] resolved() for ‘SequentialFuture’ ... done
[1] TRUE
[1] 42
*** multicore(..., globals = FALSE) with globals
[13:21:03.211] getGlobalsAndPackages() ...
[13:21:03.211] Not searching for globals
[13:21:03.212] - globals: [0] <none>
[13:21:03.212] getGlobalsAndPackages() ... DONE
[13:21:03.212] Packages needed by the future expression (n = 0): <none>
[13:21:03.212] Packages needed by future strategies (n = 0): <none>
[13:21:03.212] {
[13:21:03.212]     {
[13:21:03.212]         {
[13:21:03.212]             ...future.startTime <- base::Sys.time()
[13:21:03.212]             {
[13:21:03.212]                 {
[13:21:03.212]                   {
[13:21:03.212]                     base::local({
[13:21:03.212]                       has_future <- base::requireNamespace("future", 
[13:21:03.212]                         quietly = TRUE)
[13:21:03.212]                       if (has_future) {
[13:21:03.212]                         ns <- base::getNamespace("future")
[13:21:03.212]                         version <- ns[[".package"]][["version"]]
[13:21:03.212]                         if (is.null(version)) 
[13:21:03.212]                           version <- utils::packageVersion("future")
[13:21:03.212]                       }
[13:21:03.212]                       else {
[13:21:03.212]                         version <- NULL
[13:21:03.212]                       }
[13:21:03.212]                       if (!has_future || version < "1.8.0") {
[13:21:03.212]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:03.212]                           "", base::R.version$version.string), 
[13:21:03.212]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:03.212]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:03.212]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:03.212]                             "release", "version")], collapse = " "), 
[13:21:03.212]                           hostname = base::Sys.info()[["nodename"]])
[13:21:03.212]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:03.212]                           info)
[13:21:03.212]                         info <- base::paste(info, collapse = "; ")
[13:21:03.212]                         if (!has_future) {
[13:21:03.212]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:03.212]                             info)
[13:21:03.212]                         }
[13:21:03.212]                         else {
[13:21:03.212]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:03.212]                             info, version)
[13:21:03.212]                         }
[13:21:03.212]                         base::stop(msg)
[13:21:03.212]                       }
[13:21:03.212]                     })
[13:21:03.212]                   }
[13:21:03.212]                   options(future.plan = NULL)
[13:21:03.212]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.212]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:03.212]                 }
[13:21:03.212]                 ...future.workdir <- getwd()
[13:21:03.212]             }
[13:21:03.212]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:03.212]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:03.212]         }
[13:21:03.212]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:03.212]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:03.212]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:03.212]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:03.212]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:03.212]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:03.212]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:03.212]             base::names(...future.oldOptions))
[13:21:03.212]     }
[13:21:03.212]     if (FALSE) {
[13:21:03.212]     }
[13:21:03.212]     else {
[13:21:03.212]         if (TRUE) {
[13:21:03.212]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:03.212]                 open = "w")
[13:21:03.212]         }
[13:21:03.212]         else {
[13:21:03.212]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:03.212]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:03.212]         }
[13:21:03.212]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:03.212]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:03.212]             base::sink(type = "output", split = FALSE)
[13:21:03.212]             base::close(...future.stdout)
[13:21:03.212]         }, add = TRUE)
[13:21:03.212]     }
[13:21:03.212]     ...future.frame <- base::sys.nframe()
[13:21:03.212]     ...future.conditions <- base::list()
[13:21:03.212]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:03.212]     if (FALSE) {
[13:21:03.212]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:03.212]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:03.212]     }
[13:21:03.212]     ...future.result <- base::tryCatch({
[13:21:03.212]         base::withCallingHandlers({
[13:21:03.212]             ...future.value <- base::withVisible(base::local({
[13:21:03.212]                 b <- 3
[13:21:03.212]                 c <- 2
[13:21:03.212]                 a * b * c
[13:21:03.212]             }))
[13:21:03.212]             future::FutureResult(value = ...future.value$value, 
[13:21:03.212]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.212]                   ...future.rng), globalenv = if (FALSE) 
[13:21:03.212]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:03.212]                     ...future.globalenv.names))
[13:21:03.212]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:03.212]         }, condition = base::local({
[13:21:03.212]             c <- base::c
[13:21:03.212]             inherits <- base::inherits
[13:21:03.212]             invokeRestart <- base::invokeRestart
[13:21:03.212]             length <- base::length
[13:21:03.212]             list <- base::list
[13:21:03.212]             seq.int <- base::seq.int
[13:21:03.212]             signalCondition <- base::signalCondition
[13:21:03.212]             sys.calls <- base::sys.calls
[13:21:03.212]             `[[` <- base::`[[`
[13:21:03.212]             `+` <- base::`+`
[13:21:03.212]             `<<-` <- base::`<<-`
[13:21:03.212]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:03.212]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:03.212]                   3L)]
[13:21:03.212]             }
[13:21:03.212]             function(cond) {
[13:21:03.212]                 is_error <- inherits(cond, "error")
[13:21:03.212]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:03.212]                   NULL)
[13:21:03.212]                 if (is_error) {
[13:21:03.212]                   sessionInformation <- function() {
[13:21:03.212]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:03.212]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:03.212]                       search = base::search(), system = base::Sys.info())
[13:21:03.212]                   }
[13:21:03.212]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.212]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:03.212]                     cond$call), session = sessionInformation(), 
[13:21:03.212]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:03.212]                   signalCondition(cond)
[13:21:03.212]                 }
[13:21:03.212]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:03.212]                 "immediateCondition"))) {
[13:21:03.212]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:03.212]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.212]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:03.212]                   if (TRUE && !signal) {
[13:21:03.212]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.212]                     {
[13:21:03.212]                       inherits <- base::inherits
[13:21:03.212]                       invokeRestart <- base::invokeRestart
[13:21:03.212]                       is.null <- base::is.null
[13:21:03.212]                       muffled <- FALSE
[13:21:03.212]                       if (inherits(cond, "message")) {
[13:21:03.212]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.212]                         if (muffled) 
[13:21:03.212]                           invokeRestart("muffleMessage")
[13:21:03.212]                       }
[13:21:03.212]                       else if (inherits(cond, "warning")) {
[13:21:03.212]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.212]                         if (muffled) 
[13:21:03.212]                           invokeRestart("muffleWarning")
[13:21:03.212]                       }
[13:21:03.212]                       else if (inherits(cond, "condition")) {
[13:21:03.212]                         if (!is.null(pattern)) {
[13:21:03.212]                           computeRestarts <- base::computeRestarts
[13:21:03.212]                           grepl <- base::grepl
[13:21:03.212]                           restarts <- computeRestarts(cond)
[13:21:03.212]                           for (restart in restarts) {
[13:21:03.212]                             name <- restart$name
[13:21:03.212]                             if (is.null(name)) 
[13:21:03.212]                               next
[13:21:03.212]                             if (!grepl(pattern, name)) 
[13:21:03.212]                               next
[13:21:03.212]                             invokeRestart(restart)
[13:21:03.212]                             muffled <- TRUE
[13:21:03.212]                             break
[13:21:03.212]                           }
[13:21:03.212]                         }
[13:21:03.212]                       }
[13:21:03.212]                       invisible(muffled)
[13:21:03.212]                     }
[13:21:03.212]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.212]                   }
[13:21:03.212]                 }
[13:21:03.212]                 else {
[13:21:03.212]                   if (TRUE) {
[13:21:03.212]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.212]                     {
[13:21:03.212]                       inherits <- base::inherits
[13:21:03.212]                       invokeRestart <- base::invokeRestart
[13:21:03.212]                       is.null <- base::is.null
[13:21:03.212]                       muffled <- FALSE
[13:21:03.212]                       if (inherits(cond, "message")) {
[13:21:03.212]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.212]                         if (muffled) 
[13:21:03.212]                           invokeRestart("muffleMessage")
[13:21:03.212]                       }
[13:21:03.212]                       else if (inherits(cond, "warning")) {
[13:21:03.212]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.212]                         if (muffled) 
[13:21:03.212]                           invokeRestart("muffleWarning")
[13:21:03.212]                       }
[13:21:03.212]                       else if (inherits(cond, "condition")) {
[13:21:03.212]                         if (!is.null(pattern)) {
[13:21:03.212]                           computeRestarts <- base::computeRestarts
[13:21:03.212]                           grepl <- base::grepl
[13:21:03.212]                           restarts <- computeRestarts(cond)
[13:21:03.212]                           for (restart in restarts) {
[13:21:03.212]                             name <- restart$name
[13:21:03.212]                             if (is.null(name)) 
[13:21:03.212]                               next
[13:21:03.212]                             if (!grepl(pattern, name)) 
[13:21:03.212]                               next
[13:21:03.212]                             invokeRestart(restart)
[13:21:03.212]                             muffled <- TRUE
[13:21:03.212]                             break
[13:21:03.212]                           }
[13:21:03.212]                         }
[13:21:03.212]                       }
[13:21:03.212]                       invisible(muffled)
[13:21:03.212]                     }
[13:21:03.212]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.212]                   }
[13:21:03.212]                 }
[13:21:03.212]             }
[13:21:03.212]         }))
[13:21:03.212]     }, error = function(ex) {
[13:21:03.212]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:03.212]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.212]                 ...future.rng), started = ...future.startTime, 
[13:21:03.212]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:03.212]             version = "1.8"), class = "FutureResult")
[13:21:03.212]     }, finally = {
[13:21:03.212]         if (!identical(...future.workdir, getwd())) 
[13:21:03.212]             setwd(...future.workdir)
[13:21:03.212]         {
[13:21:03.212]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:03.212]                 ...future.oldOptions$nwarnings <- NULL
[13:21:03.212]             }
[13:21:03.212]             base::options(...future.oldOptions)
[13:21:03.212]             if (.Platform$OS.type == "windows") {
[13:21:03.212]                 old_names <- names(...future.oldEnvVars)
[13:21:03.212]                 envs <- base::Sys.getenv()
[13:21:03.212]                 names <- names(envs)
[13:21:03.212]                 common <- intersect(names, old_names)
[13:21:03.212]                 added <- setdiff(names, old_names)
[13:21:03.212]                 removed <- setdiff(old_names, names)
[13:21:03.212]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:03.212]                   envs[common]]
[13:21:03.212]                 NAMES <- toupper(changed)
[13:21:03.212]                 args <- list()
[13:21:03.212]                 for (kk in seq_along(NAMES)) {
[13:21:03.212]                   name <- changed[[kk]]
[13:21:03.212]                   NAME <- NAMES[[kk]]
[13:21:03.212]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.212]                     next
[13:21:03.212]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.212]                 }
[13:21:03.212]                 NAMES <- toupper(added)
[13:21:03.212]                 for (kk in seq_along(NAMES)) {
[13:21:03.212]                   name <- added[[kk]]
[13:21:03.212]                   NAME <- NAMES[[kk]]
[13:21:03.212]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.212]                     next
[13:21:03.212]                   args[[name]] <- ""
[13:21:03.212]                 }
[13:21:03.212]                 NAMES <- toupper(removed)
[13:21:03.212]                 for (kk in seq_along(NAMES)) {
[13:21:03.212]                   name <- removed[[kk]]
[13:21:03.212]                   NAME <- NAMES[[kk]]
[13:21:03.212]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.212]                     next
[13:21:03.212]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.212]                 }
[13:21:03.212]                 if (length(args) > 0) 
[13:21:03.212]                   base::do.call(base::Sys.setenv, args = args)
[13:21:03.212]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:03.212]             }
[13:21:03.212]             else {
[13:21:03.212]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:03.212]             }
[13:21:03.212]             {
[13:21:03.212]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:03.212]                   0L) {
[13:21:03.212]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:03.212]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:03.212]                   base::options(opts)
[13:21:03.212]                 }
[13:21:03.212]                 {
[13:21:03.212]                   {
[13:21:03.212]                     NULL
[13:21:03.212]                     RNGkind("Mersenne-Twister")
[13:21:03.212]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:03.212]                       inherits = FALSE)
[13:21:03.212]                   }
[13:21:03.212]                   options(future.plan = NULL)
[13:21:03.212]                   if (is.na(NA_character_)) 
[13:21:03.212]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.212]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:03.212]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:03.212]                     envir = parent.frame()) 
[13:21:03.212]                   {
[13:21:03.212]                     default_workers <- missing(workers)
[13:21:03.212]                     if (is.function(workers)) 
[13:21:03.212]                       workers <- workers()
[13:21:03.212]                     workers <- structure(as.integer(workers), 
[13:21:03.212]                       class = class(workers))
[13:21:03.212]                     stop_if_not(is.finite(workers), workers >= 
[13:21:03.212]                       1L)
[13:21:03.212]                     if ((workers == 1L && !inherits(workers, 
[13:21:03.212]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:03.212]                       if (default_workers) 
[13:21:03.212]                         supportsMulticore(warn = TRUE)
[13:21:03.212]                       return(sequential(..., envir = envir))
[13:21:03.212]                     }
[13:21:03.212]                     oopts <- options(mc.cores = workers)
[13:21:03.212]                     on.exit(options(oopts))
[13:21:03.212]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:03.212]                       envir = envir)
[13:21:03.212]                     if (!future$lazy) 
[13:21:03.212]                       future <- run(future)
[13:21:03.212]                     invisible(future)
[13:21:03.212]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:03.212]                 }
[13:21:03.212]             }
[13:21:03.212]         }
[13:21:03.212]     })
[13:21:03.212]     if (TRUE) {
[13:21:03.212]         base::sink(type = "output", split = FALSE)
[13:21:03.212]         if (TRUE) {
[13:21:03.212]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:03.212]         }
[13:21:03.212]         else {
[13:21:03.212]             ...future.result["stdout"] <- base::list(NULL)
[13:21:03.212]         }
[13:21:03.212]         base::close(...future.stdout)
[13:21:03.212]         ...future.stdout <- NULL
[13:21:03.212]     }
[13:21:03.212]     ...future.result$conditions <- ...future.conditions
[13:21:03.212]     ...future.result$finished <- base::Sys.time()
[13:21:03.212]     ...future.result
[13:21:03.212] }
[13:21:03.214] plan(): Setting new future strategy stack:
[13:21:03.214] List of future strategies:
[13:21:03.214] 1. sequential:
[13:21:03.214]    - args: function (..., envir = parent.frame())
[13:21:03.214]    - tweaked: FALSE
[13:21:03.214]    - call: NULL
[13:21:03.216] plan(): nbrOfWorkers() = 1
[13:21:03.217] plan(): Setting new future strategy stack:
[13:21:03.217] List of future strategies:
[13:21:03.217] 1. multicore:
[13:21:03.217]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:03.217]    - tweaked: FALSE
[13:21:03.217]    - call: plan(multicore)
[13:21:03.220] plan(): nbrOfWorkers() = 1
[13:21:03.221] SequentialFuture started (and completed)
SequentialFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 56 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: 32f7abe8-d290-272e-8911-a8ce072c31c3
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[1] 0
*** multicore(..., globals = FALSE) with globals and blocking
 - Creating multicore future #1 ...
[13:21:03.225] getGlobalsAndPackages() ...
[13:21:03.225] Not searching for globals
[13:21:03.225] - globals: [0] <none>
[13:21:03.225] getGlobalsAndPackages() ... DONE
[13:21:03.226] Packages needed by the future expression (n = 0): <none>
[13:21:03.226] Packages needed by future strategies (n = 0): <none>
[13:21:03.226] {
[13:21:03.226]     {
[13:21:03.226]         {
[13:21:03.226]             ...future.startTime <- base::Sys.time()
[13:21:03.226]             {
[13:21:03.226]                 {
[13:21:03.226]                   {
[13:21:03.226]                     base::local({
[13:21:03.226]                       has_future <- base::requireNamespace("future", 
[13:21:03.226]                         quietly = TRUE)
[13:21:03.226]                       if (has_future) {
[13:21:03.226]                         ns <- base::getNamespace("future")
[13:21:03.226]                         version <- ns[[".package"]][["version"]]
[13:21:03.226]                         if (is.null(version)) 
[13:21:03.226]                           version <- utils::packageVersion("future")
[13:21:03.226]                       }
[13:21:03.226]                       else {
[13:21:03.226]                         version <- NULL
[13:21:03.226]                       }
[13:21:03.226]                       if (!has_future || version < "1.8.0") {
[13:21:03.226]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:03.226]                           "", base::R.version$version.string), 
[13:21:03.226]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:03.226]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:03.226]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:03.226]                             "release", "version")], collapse = " "), 
[13:21:03.226]                           hostname = base::Sys.info()[["nodename"]])
[13:21:03.226]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:03.226]                           info)
[13:21:03.226]                         info <- base::paste(info, collapse = "; ")
[13:21:03.226]                         if (!has_future) {
[13:21:03.226]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:03.226]                             info)
[13:21:03.226]                         }
[13:21:03.226]                         else {
[13:21:03.226]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:03.226]                             info, version)
[13:21:03.226]                         }
[13:21:03.226]                         base::stop(msg)
[13:21:03.226]                       }
[13:21:03.226]                     })
[13:21:03.226]                   }
[13:21:03.226]                   options(future.plan = NULL)
[13:21:03.226]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.226]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:03.226]                 }
[13:21:03.226]                 ...future.workdir <- getwd()
[13:21:03.226]             }
[13:21:03.226]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:03.226]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:03.226]         }
[13:21:03.226]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:03.226]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:03.226]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:03.226]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:03.226]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:03.226]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:03.226]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:03.226]             base::names(...future.oldOptions))
[13:21:03.226]     }
[13:21:03.226]     if (FALSE) {
[13:21:03.226]     }
[13:21:03.226]     else {
[13:21:03.226]         if (TRUE) {
[13:21:03.226]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:03.226]                 open = "w")
[13:21:03.226]         }
[13:21:03.226]         else {
[13:21:03.226]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:03.226]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:03.226]         }
[13:21:03.226]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:03.226]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:03.226]             base::sink(type = "output", split = FALSE)
[13:21:03.226]             base::close(...future.stdout)
[13:21:03.226]         }, add = TRUE)
[13:21:03.226]     }
[13:21:03.226]     ...future.frame <- base::sys.nframe()
[13:21:03.226]     ...future.conditions <- base::list()
[13:21:03.226]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:03.226]     if (FALSE) {
[13:21:03.226]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:03.226]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:03.226]     }
[13:21:03.226]     ...future.result <- base::tryCatch({
[13:21:03.226]         base::withCallingHandlers({
[13:21:03.226]             ...future.value <- base::withVisible(base::local({
[13:21:03.226]                 ii
[13:21:03.226]             }))
[13:21:03.226]             future::FutureResult(value = ...future.value$value, 
[13:21:03.226]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.226]                   ...future.rng), globalenv = if (FALSE) 
[13:21:03.226]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:03.226]                     ...future.globalenv.names))
[13:21:03.226]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:03.226]         }, condition = base::local({
[13:21:03.226]             c <- base::c
[13:21:03.226]             inherits <- base::inherits
[13:21:03.226]             invokeRestart <- base::invokeRestart
[13:21:03.226]             length <- base::length
[13:21:03.226]             list <- base::list
[13:21:03.226]             seq.int <- base::seq.int
[13:21:03.226]             signalCondition <- base::signalCondition
[13:21:03.226]             sys.calls <- base::sys.calls
[13:21:03.226]             `[[` <- base::`[[`
[13:21:03.226]             `+` <- base::`+`
[13:21:03.226]             `<<-` <- base::`<<-`
[13:21:03.226]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:03.226]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:03.226]                   3L)]
[13:21:03.226]             }
[13:21:03.226]             function(cond) {
[13:21:03.226]                 is_error <- inherits(cond, "error")
[13:21:03.226]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:03.226]                   NULL)
[13:21:03.226]                 if (is_error) {
[13:21:03.226]                   sessionInformation <- function() {
[13:21:03.226]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:03.226]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:03.226]                       search = base::search(), system = base::Sys.info())
[13:21:03.226]                   }
[13:21:03.226]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.226]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:03.226]                     cond$call), session = sessionInformation(), 
[13:21:03.226]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:03.226]                   signalCondition(cond)
[13:21:03.226]                 }
[13:21:03.226]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:03.226]                 "immediateCondition"))) {
[13:21:03.226]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:03.226]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.226]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:03.226]                   if (TRUE && !signal) {
[13:21:03.226]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.226]                     {
[13:21:03.226]                       inherits <- base::inherits
[13:21:03.226]                       invokeRestart <- base::invokeRestart
[13:21:03.226]                       is.null <- base::is.null
[13:21:03.226]                       muffled <- FALSE
[13:21:03.226]                       if (inherits(cond, "message")) {
[13:21:03.226]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.226]                         if (muffled) 
[13:21:03.226]                           invokeRestart("muffleMessage")
[13:21:03.226]                       }
[13:21:03.226]                       else if (inherits(cond, "warning")) {
[13:21:03.226]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.226]                         if (muffled) 
[13:21:03.226]                           invokeRestart("muffleWarning")
[13:21:03.226]                       }
[13:21:03.226]                       else if (inherits(cond, "condition")) {
[13:21:03.226]                         if (!is.null(pattern)) {
[13:21:03.226]                           computeRestarts <- base::computeRestarts
[13:21:03.226]                           grepl <- base::grepl
[13:21:03.226]                           restarts <- computeRestarts(cond)
[13:21:03.226]                           for (restart in restarts) {
[13:21:03.226]                             name <- restart$name
[13:21:03.226]                             if (is.null(name)) 
[13:21:03.226]                               next
[13:21:03.226]                             if (!grepl(pattern, name)) 
[13:21:03.226]                               next
[13:21:03.226]                             invokeRestart(restart)
[13:21:03.226]                             muffled <- TRUE
[13:21:03.226]                             break
[13:21:03.226]                           }
[13:21:03.226]                         }
[13:21:03.226]                       }
[13:21:03.226]                       invisible(muffled)
[13:21:03.226]                     }
[13:21:03.226]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.226]                   }
[13:21:03.226]                 }
[13:21:03.226]                 else {
[13:21:03.226]                   if (TRUE) {
[13:21:03.226]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.226]                     {
[13:21:03.226]                       inherits <- base::inherits
[13:21:03.226]                       invokeRestart <- base::invokeRestart
[13:21:03.226]                       is.null <- base::is.null
[13:21:03.226]                       muffled <- FALSE
[13:21:03.226]                       if (inherits(cond, "message")) {
[13:21:03.226]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.226]                         if (muffled) 
[13:21:03.226]                           invokeRestart("muffleMessage")
[13:21:03.226]                       }
[13:21:03.226]                       else if (inherits(cond, "warning")) {
[13:21:03.226]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.226]                         if (muffled) 
[13:21:03.226]                           invokeRestart("muffleWarning")
[13:21:03.226]                       }
[13:21:03.226]                       else if (inherits(cond, "condition")) {
[13:21:03.226]                         if (!is.null(pattern)) {
[13:21:03.226]                           computeRestarts <- base::computeRestarts
[13:21:03.226]                           grepl <- base::grepl
[13:21:03.226]                           restarts <- computeRestarts(cond)
[13:21:03.226]                           for (restart in restarts) {
[13:21:03.226]                             name <- restart$name
[13:21:03.226]                             if (is.null(name)) 
[13:21:03.226]                               next
[13:21:03.226]                             if (!grepl(pattern, name)) 
[13:21:03.226]                               next
[13:21:03.226]                             invokeRestart(restart)
[13:21:03.226]                             muffled <- TRUE
[13:21:03.226]                             break
[13:21:03.226]                           }
[13:21:03.226]                         }
[13:21:03.226]                       }
[13:21:03.226]                       invisible(muffled)
[13:21:03.226]                     }
[13:21:03.226]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.226]                   }
[13:21:03.226]                 }
[13:21:03.226]             }
[13:21:03.226]         }))
[13:21:03.226]     }, error = function(ex) {
[13:21:03.226]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:03.226]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.226]                 ...future.rng), started = ...future.startTime, 
[13:21:03.226]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:03.226]             version = "1.8"), class = "FutureResult")
[13:21:03.226]     }, finally = {
[13:21:03.226]         if (!identical(...future.workdir, getwd())) 
[13:21:03.226]             setwd(...future.workdir)
[13:21:03.226]         {
[13:21:03.226]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:03.226]                 ...future.oldOptions$nwarnings <- NULL
[13:21:03.226]             }
[13:21:03.226]             base::options(...future.oldOptions)
[13:21:03.226]             if (.Platform$OS.type == "windows") {
[13:21:03.226]                 old_names <- names(...future.oldEnvVars)
[13:21:03.226]                 envs <- base::Sys.getenv()
[13:21:03.226]                 names <- names(envs)
[13:21:03.226]                 common <- intersect(names, old_names)
[13:21:03.226]                 added <- setdiff(names, old_names)
[13:21:03.226]                 removed <- setdiff(old_names, names)
[13:21:03.226]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:03.226]                   envs[common]]
[13:21:03.226]                 NAMES <- toupper(changed)
[13:21:03.226]                 args <- list()
[13:21:03.226]                 for (kk in seq_along(NAMES)) {
[13:21:03.226]                   name <- changed[[kk]]
[13:21:03.226]                   NAME <- NAMES[[kk]]
[13:21:03.226]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.226]                     next
[13:21:03.226]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.226]                 }
[13:21:03.226]                 NAMES <- toupper(added)
[13:21:03.226]                 for (kk in seq_along(NAMES)) {
[13:21:03.226]                   name <- added[[kk]]
[13:21:03.226]                   NAME <- NAMES[[kk]]
[13:21:03.226]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.226]                     next
[13:21:03.226]                   args[[name]] <- ""
[13:21:03.226]                 }
[13:21:03.226]                 NAMES <- toupper(removed)
[13:21:03.226]                 for (kk in seq_along(NAMES)) {
[13:21:03.226]                   name <- removed[[kk]]
[13:21:03.226]                   NAME <- NAMES[[kk]]
[13:21:03.226]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.226]                     next
[13:21:03.226]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.226]                 }
[13:21:03.226]                 if (length(args) > 0) 
[13:21:03.226]                   base::do.call(base::Sys.setenv, args = args)
[13:21:03.226]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:03.226]             }
[13:21:03.226]             else {
[13:21:03.226]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:03.226]             }
[13:21:03.226]             {
[13:21:03.226]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:03.226]                   0L) {
[13:21:03.226]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:03.226]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:03.226]                   base::options(opts)
[13:21:03.226]                 }
[13:21:03.226]                 {
[13:21:03.226]                   {
[13:21:03.226]                     NULL
[13:21:03.226]                     RNGkind("Mersenne-Twister")
[13:21:03.226]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:03.226]                       inherits = FALSE)
[13:21:03.226]                   }
[13:21:03.226]                   options(future.plan = NULL)
[13:21:03.226]                   if (is.na(NA_character_)) 
[13:21:03.226]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.226]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:03.226]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:03.226]                     envir = parent.frame()) 
[13:21:03.226]                   {
[13:21:03.226]                     default_workers <- missing(workers)
[13:21:03.226]                     if (is.function(workers)) 
[13:21:03.226]                       workers <- workers()
[13:21:03.226]                     workers <- structure(as.integer(workers), 
[13:21:03.226]                       class = class(workers))
[13:21:03.226]                     stop_if_not(is.finite(workers), workers >= 
[13:21:03.226]                       1L)
[13:21:03.226]                     if ((workers == 1L && !inherits(workers, 
[13:21:03.226]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:03.226]                       if (default_workers) 
[13:21:03.226]                         supportsMulticore(warn = TRUE)
[13:21:03.226]                       return(sequential(..., envir = envir))
[13:21:03.226]                     }
[13:21:03.226]                     oopts <- options(mc.cores = workers)
[13:21:03.226]                     on.exit(options(oopts))
[13:21:03.226]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:03.226]                       envir = envir)
[13:21:03.226]                     if (!future$lazy) 
[13:21:03.226]                       future <- run(future)
[13:21:03.226]                     invisible(future)
[13:21:03.226]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:03.226]                 }
[13:21:03.226]             }
[13:21:03.226]         }
[13:21:03.226]     })
[13:21:03.226]     if (TRUE) {
[13:21:03.226]         base::sink(type = "output", split = FALSE)
[13:21:03.226]         if (TRUE) {
[13:21:03.226]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:03.226]         }
[13:21:03.226]         else {
[13:21:03.226]             ...future.result["stdout"] <- base::list(NULL)
[13:21:03.226]         }
[13:21:03.226]         base::close(...future.stdout)
[13:21:03.226]         ...future.stdout <- NULL
[13:21:03.226]     }
[13:21:03.226]     ...future.result$conditions <- ...future.conditions
[13:21:03.226]     ...future.result$finished <- base::Sys.time()
[13:21:03.226]     ...future.result
[13:21:03.226] }
[13:21:03.228] plan(): Setting new future strategy stack:
[13:21:03.228] List of future strategies:
[13:21:03.228] 1. sequential:
[13:21:03.228]    - args: function (..., envir = parent.frame())
[13:21:03.228]    - tweaked: FALSE
[13:21:03.228]    - call: NULL
[13:21:03.229] plan(): nbrOfWorkers() = 1
[13:21:03.229] plan(): Setting new future strategy stack:
[13:21:03.229] List of future strategies:
[13:21:03.229] 1. multicore:
[13:21:03.229]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:03.229]    - tweaked: FALSE
[13:21:03.229]    - call: plan(multicore)
[13:21:03.233] plan(): nbrOfWorkers() = 1
[13:21:03.233] SequentialFuture started (and completed)
 - Creating multicore future #2 ...
[13:21:03.236] getGlobalsAndPackages() ...
[13:21:03.236] Not searching for globals
[13:21:03.236] - globals: [0] <none>
[13:21:03.237] getGlobalsAndPackages() ... DONE
[13:21:03.237] Packages needed by the future expression (n = 0): <none>
[13:21:03.237] Packages needed by future strategies (n = 0): <none>
[13:21:03.237] {
[13:21:03.237]     {
[13:21:03.237]         {
[13:21:03.237]             ...future.startTime <- base::Sys.time()
[13:21:03.237]             {
[13:21:03.237]                 {
[13:21:03.237]                   {
[13:21:03.237]                     base::local({
[13:21:03.237]                       has_future <- base::requireNamespace("future", 
[13:21:03.237]                         quietly = TRUE)
[13:21:03.237]                       if (has_future) {
[13:21:03.237]                         ns <- base::getNamespace("future")
[13:21:03.237]                         version <- ns[[".package"]][["version"]]
[13:21:03.237]                         if (is.null(version)) 
[13:21:03.237]                           version <- utils::packageVersion("future")
[13:21:03.237]                       }
[13:21:03.237]                       else {
[13:21:03.237]                         version <- NULL
[13:21:03.237]                       }
[13:21:03.237]                       if (!has_future || version < "1.8.0") {
[13:21:03.237]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:03.237]                           "", base::R.version$version.string), 
[13:21:03.237]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:03.237]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:03.237]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:03.237]                             "release", "version")], collapse = " "), 
[13:21:03.237]                           hostname = base::Sys.info()[["nodename"]])
[13:21:03.237]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:03.237]                           info)
[13:21:03.237]                         info <- base::paste(info, collapse = "; ")
[13:21:03.237]                         if (!has_future) {
[13:21:03.237]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:03.237]                             info)
[13:21:03.237]                         }
[13:21:03.237]                         else {
[13:21:03.237]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:03.237]                             info, version)
[13:21:03.237]                         }
[13:21:03.237]                         base::stop(msg)
[13:21:03.237]                       }
[13:21:03.237]                     })
[13:21:03.237]                   }
[13:21:03.237]                   options(future.plan = NULL)
[13:21:03.237]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.237]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:03.237]                 }
[13:21:03.237]                 ...future.workdir <- getwd()
[13:21:03.237]             }
[13:21:03.237]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:03.237]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:03.237]         }
[13:21:03.237]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:03.237]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:03.237]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:03.237]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:03.237]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:03.237]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:03.237]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:03.237]             base::names(...future.oldOptions))
[13:21:03.237]     }
[13:21:03.237]     if (FALSE) {
[13:21:03.237]     }
[13:21:03.237]     else {
[13:21:03.237]         if (TRUE) {
[13:21:03.237]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:03.237]                 open = "w")
[13:21:03.237]         }
[13:21:03.237]         else {
[13:21:03.237]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:03.237]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:03.237]         }
[13:21:03.237]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:03.237]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:03.237]             base::sink(type = "output", split = FALSE)
[13:21:03.237]             base::close(...future.stdout)
[13:21:03.237]         }, add = TRUE)
[13:21:03.237]     }
[13:21:03.237]     ...future.frame <- base::sys.nframe()
[13:21:03.237]     ...future.conditions <- base::list()
[13:21:03.237]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:03.237]     if (FALSE) {
[13:21:03.237]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:03.237]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:03.237]     }
[13:21:03.237]     ...future.result <- base::tryCatch({
[13:21:03.237]         base::withCallingHandlers({
[13:21:03.237]             ...future.value <- base::withVisible(base::local({
[13:21:03.237]                 ii
[13:21:03.237]             }))
[13:21:03.237]             future::FutureResult(value = ...future.value$value, 
[13:21:03.237]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.237]                   ...future.rng), globalenv = if (FALSE) 
[13:21:03.237]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:03.237]                     ...future.globalenv.names))
[13:21:03.237]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:03.237]         }, condition = base::local({
[13:21:03.237]             c <- base::c
[13:21:03.237]             inherits <- base::inherits
[13:21:03.237]             invokeRestart <- base::invokeRestart
[13:21:03.237]             length <- base::length
[13:21:03.237]             list <- base::list
[13:21:03.237]             seq.int <- base::seq.int
[13:21:03.237]             signalCondition <- base::signalCondition
[13:21:03.237]             sys.calls <- base::sys.calls
[13:21:03.237]             `[[` <- base::`[[`
[13:21:03.237]             `+` <- base::`+`
[13:21:03.237]             `<<-` <- base::`<<-`
[13:21:03.237]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:03.237]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:03.237]                   3L)]
[13:21:03.237]             }
[13:21:03.237]             function(cond) {
[13:21:03.237]                 is_error <- inherits(cond, "error")
[13:21:03.237]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:03.237]                   NULL)
[13:21:03.237]                 if (is_error) {
[13:21:03.237]                   sessionInformation <- function() {
[13:21:03.237]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:03.237]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:03.237]                       search = base::search(), system = base::Sys.info())
[13:21:03.237]                   }
[13:21:03.237]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.237]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:03.237]                     cond$call), session = sessionInformation(), 
[13:21:03.237]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:03.237]                   signalCondition(cond)
[13:21:03.237]                 }
[13:21:03.237]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:03.237]                 "immediateCondition"))) {
[13:21:03.237]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:03.237]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.237]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:03.237]                   if (TRUE && !signal) {
[13:21:03.237]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.237]                     {
[13:21:03.237]                       inherits <- base::inherits
[13:21:03.237]                       invokeRestart <- base::invokeRestart
[13:21:03.237]                       is.null <- base::is.null
[13:21:03.237]                       muffled <- FALSE
[13:21:03.237]                       if (inherits(cond, "message")) {
[13:21:03.237]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.237]                         if (muffled) 
[13:21:03.237]                           invokeRestart("muffleMessage")
[13:21:03.237]                       }
[13:21:03.237]                       else if (inherits(cond, "warning")) {
[13:21:03.237]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.237]                         if (muffled) 
[13:21:03.237]                           invokeRestart("muffleWarning")
[13:21:03.237]                       }
[13:21:03.237]                       else if (inherits(cond, "condition")) {
[13:21:03.237]                         if (!is.null(pattern)) {
[13:21:03.237]                           computeRestarts <- base::computeRestarts
[13:21:03.237]                           grepl <- base::grepl
[13:21:03.237]                           restarts <- computeRestarts(cond)
[13:21:03.237]                           for (restart in restarts) {
[13:21:03.237]                             name <- restart$name
[13:21:03.237]                             if (is.null(name)) 
[13:21:03.237]                               next
[13:21:03.237]                             if (!grepl(pattern, name)) 
[13:21:03.237]                               next
[13:21:03.237]                             invokeRestart(restart)
[13:21:03.237]                             muffled <- TRUE
[13:21:03.237]                             break
[13:21:03.237]                           }
[13:21:03.237]                         }
[13:21:03.237]                       }
[13:21:03.237]                       invisible(muffled)
[13:21:03.237]                     }
[13:21:03.237]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.237]                   }
[13:21:03.237]                 }
[13:21:03.237]                 else {
[13:21:03.237]                   if (TRUE) {
[13:21:03.237]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.237]                     {
[13:21:03.237]                       inherits <- base::inherits
[13:21:03.237]                       invokeRestart <- base::invokeRestart
[13:21:03.237]                       is.null <- base::is.null
[13:21:03.237]                       muffled <- FALSE
[13:21:03.237]                       if (inherits(cond, "message")) {
[13:21:03.237]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.237]                         if (muffled) 
[13:21:03.237]                           invokeRestart("muffleMessage")
[13:21:03.237]                       }
[13:21:03.237]                       else if (inherits(cond, "warning")) {
[13:21:03.237]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.237]                         if (muffled) 
[13:21:03.237]                           invokeRestart("muffleWarning")
[13:21:03.237]                       }
[13:21:03.237]                       else if (inherits(cond, "condition")) {
[13:21:03.237]                         if (!is.null(pattern)) {
[13:21:03.237]                           computeRestarts <- base::computeRestarts
[13:21:03.237]                           grepl <- base::grepl
[13:21:03.237]                           restarts <- computeRestarts(cond)
[13:21:03.237]                           for (restart in restarts) {
[13:21:03.237]                             name <- restart$name
[13:21:03.237]                             if (is.null(name)) 
[13:21:03.237]                               next
[13:21:03.237]                             if (!grepl(pattern, name)) 
[13:21:03.237]                               next
[13:21:03.237]                             invokeRestart(restart)
[13:21:03.237]                             muffled <- TRUE
[13:21:03.237]                             break
[13:21:03.237]                           }
[13:21:03.237]                         }
[13:21:03.237]                       }
[13:21:03.237]                       invisible(muffled)
[13:21:03.237]                     }
[13:21:03.237]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.237]                   }
[13:21:03.237]                 }
[13:21:03.237]             }
[13:21:03.237]         }))
[13:21:03.237]     }, error = function(ex) {
[13:21:03.237]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:03.237]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.237]                 ...future.rng), started = ...future.startTime, 
[13:21:03.237]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:03.237]             version = "1.8"), class = "FutureResult")
[13:21:03.237]     }, finally = {
[13:21:03.237]         if (!identical(...future.workdir, getwd())) 
[13:21:03.237]             setwd(...future.workdir)
[13:21:03.237]         {
[13:21:03.237]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:03.237]                 ...future.oldOptions$nwarnings <- NULL
[13:21:03.237]             }
[13:21:03.237]             base::options(...future.oldOptions)
[13:21:03.237]             if (.Platform$OS.type == "windows") {
[13:21:03.237]                 old_names <- names(...future.oldEnvVars)
[13:21:03.237]                 envs <- base::Sys.getenv()
[13:21:03.237]                 names <- names(envs)
[13:21:03.237]                 common <- intersect(names, old_names)
[13:21:03.237]                 added <- setdiff(names, old_names)
[13:21:03.237]                 removed <- setdiff(old_names, names)
[13:21:03.237]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:03.237]                   envs[common]]
[13:21:03.237]                 NAMES <- toupper(changed)
[13:21:03.237]                 args <- list()
[13:21:03.237]                 for (kk in seq_along(NAMES)) {
[13:21:03.237]                   name <- changed[[kk]]
[13:21:03.237]                   NAME <- NAMES[[kk]]
[13:21:03.237]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.237]                     next
[13:21:03.237]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.237]                 }
[13:21:03.237]                 NAMES <- toupper(added)
[13:21:03.237]                 for (kk in seq_along(NAMES)) {
[13:21:03.237]                   name <- added[[kk]]
[13:21:03.237]                   NAME <- NAMES[[kk]]
[13:21:03.237]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.237]                     next
[13:21:03.237]                   args[[name]] <- ""
[13:21:03.237]                 }
[13:21:03.237]                 NAMES <- toupper(removed)
[13:21:03.237]                 for (kk in seq_along(NAMES)) {
[13:21:03.237]                   name <- removed[[kk]]
[13:21:03.237]                   NAME <- NAMES[[kk]]
[13:21:03.237]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.237]                     next
[13:21:03.237]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.237]                 }
[13:21:03.237]                 if (length(args) > 0) 
[13:21:03.237]                   base::do.call(base::Sys.setenv, args = args)
[13:21:03.237]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:03.237]             }
[13:21:03.237]             else {
[13:21:03.237]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:03.237]             }
[13:21:03.237]             {
[13:21:03.237]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:03.237]                   0L) {
[13:21:03.237]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:03.237]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:03.237]                   base::options(opts)
[13:21:03.237]                 }
[13:21:03.237]                 {
[13:21:03.237]                   {
[13:21:03.237]                     NULL
[13:21:03.237]                     RNGkind("Mersenne-Twister")
[13:21:03.237]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:03.237]                       inherits = FALSE)
[13:21:03.237]                   }
[13:21:03.237]                   options(future.plan = NULL)
[13:21:03.237]                   if (is.na(NA_character_)) 
[13:21:03.237]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.237]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:03.237]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:03.237]                     envir = parent.frame()) 
[13:21:03.237]                   {
[13:21:03.237]                     default_workers <- missing(workers)
[13:21:03.237]                     if (is.function(workers)) 
[13:21:03.237]                       workers <- workers()
[13:21:03.237]                     workers <- structure(as.integer(workers), 
[13:21:03.237]                       class = class(workers))
[13:21:03.237]                     stop_if_not(is.finite(workers), workers >= 
[13:21:03.237]                       1L)
[13:21:03.237]                     if ((workers == 1L && !inherits(workers, 
[13:21:03.237]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:03.237]                       if (default_workers) 
[13:21:03.237]                         supportsMulticore(warn = TRUE)
[13:21:03.237]                       return(sequential(..., envir = envir))
[13:21:03.237]                     }
[13:21:03.237]                     oopts <- options(mc.cores = workers)
[13:21:03.237]                     on.exit(options(oopts))
[13:21:03.237]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:03.237]                       envir = envir)
[13:21:03.237]                     if (!future$lazy) 
[13:21:03.237]                       future <- run(future)
[13:21:03.237]                     invisible(future)
[13:21:03.237]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:03.237]                 }
[13:21:03.237]             }
[13:21:03.237]         }
[13:21:03.237]     })
[13:21:03.237]     if (TRUE) {
[13:21:03.237]         base::sink(type = "output", split = FALSE)
[13:21:03.237]         if (TRUE) {
[13:21:03.237]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:03.237]         }
[13:21:03.237]         else {
[13:21:03.237]             ...future.result["stdout"] <- base::list(NULL)
[13:21:03.237]         }
[13:21:03.237]         base::close(...future.stdout)
[13:21:03.237]         ...future.stdout <- NULL
[13:21:03.237]     }
[13:21:03.237]     ...future.result$conditions <- ...future.conditions
[13:21:03.237]     ...future.result$finished <- base::Sys.time()
[13:21:03.237]     ...future.result
[13:21:03.237] }
[13:21:03.239] plan(): Setting new future strategy stack:
[13:21:03.239] List of future strategies:
[13:21:03.239] 1. sequential:
[13:21:03.239]    - args: function (..., envir = parent.frame())
[13:21:03.239]    - tweaked: FALSE
[13:21:03.239]    - call: NULL
[13:21:03.240] plan(): nbrOfWorkers() = 1
[13:21:03.240] plan(): Setting new future strategy stack:
[13:21:03.240] List of future strategies:
[13:21:03.240] 1. multicore:
[13:21:03.240]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:03.240]    - tweaked: FALSE
[13:21:03.240]    - call: plan(multicore)
[13:21:03.244] plan(): nbrOfWorkers() = 1
[13:21:03.244] SequentialFuture started (and completed)
 - Creating multicore future #3 ...
[13:21:03.247] getGlobalsAndPackages() ...
[13:21:03.247] Not searching for globals
[13:21:03.248] - globals: [0] <none>
[13:21:03.248] getGlobalsAndPackages() ... DONE
[13:21:03.248] Packages needed by the future expression (n = 0): <none>
[13:21:03.248] Packages needed by future strategies (n = 0): <none>
[13:21:03.249] {
[13:21:03.249]     {
[13:21:03.249]         {
[13:21:03.249]             ...future.startTime <- base::Sys.time()
[13:21:03.249]             {
[13:21:03.249]                 {
[13:21:03.249]                   {
[13:21:03.249]                     base::local({
[13:21:03.249]                       has_future <- base::requireNamespace("future", 
[13:21:03.249]                         quietly = TRUE)
[13:21:03.249]                       if (has_future) {
[13:21:03.249]                         ns <- base::getNamespace("future")
[13:21:03.249]                         version <- ns[[".package"]][["version"]]
[13:21:03.249]                         if (is.null(version)) 
[13:21:03.249]                           version <- utils::packageVersion("future")
[13:21:03.249]                       }
[13:21:03.249]                       else {
[13:21:03.249]                         version <- NULL
[13:21:03.249]                       }
[13:21:03.249]                       if (!has_future || version < "1.8.0") {
[13:21:03.249]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:03.249]                           "", base::R.version$version.string), 
[13:21:03.249]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:03.249]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:03.249]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:03.249]                             "release", "version")], collapse = " "), 
[13:21:03.249]                           hostname = base::Sys.info()[["nodename"]])
[13:21:03.249]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:03.249]                           info)
[13:21:03.249]                         info <- base::paste(info, collapse = "; ")
[13:21:03.249]                         if (!has_future) {
[13:21:03.249]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:03.249]                             info)
[13:21:03.249]                         }
[13:21:03.249]                         else {
[13:21:03.249]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:03.249]                             info, version)
[13:21:03.249]                         }
[13:21:03.249]                         base::stop(msg)
[13:21:03.249]                       }
[13:21:03.249]                     })
[13:21:03.249]                   }
[13:21:03.249]                   options(future.plan = NULL)
[13:21:03.249]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.249]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:03.249]                 }
[13:21:03.249]                 ...future.workdir <- getwd()
[13:21:03.249]             }
[13:21:03.249]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:03.249]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:03.249]         }
[13:21:03.249]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:03.249]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:03.249]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:03.249]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:03.249]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:03.249]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:03.249]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:03.249]             base::names(...future.oldOptions))
[13:21:03.249]     }
[13:21:03.249]     if (FALSE) {
[13:21:03.249]     }
[13:21:03.249]     else {
[13:21:03.249]         if (TRUE) {
[13:21:03.249]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:03.249]                 open = "w")
[13:21:03.249]         }
[13:21:03.249]         else {
[13:21:03.249]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:03.249]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:03.249]         }
[13:21:03.249]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:03.249]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:03.249]             base::sink(type = "output", split = FALSE)
[13:21:03.249]             base::close(...future.stdout)
[13:21:03.249]         }, add = TRUE)
[13:21:03.249]     }
[13:21:03.249]     ...future.frame <- base::sys.nframe()
[13:21:03.249]     ...future.conditions <- base::list()
[13:21:03.249]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:03.249]     if (FALSE) {
[13:21:03.249]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:03.249]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:03.249]     }
[13:21:03.249]     ...future.result <- base::tryCatch({
[13:21:03.249]         base::withCallingHandlers({
[13:21:03.249]             ...future.value <- base::withVisible(base::local({
[13:21:03.249]                 ii
[13:21:03.249]             }))
[13:21:03.249]             future::FutureResult(value = ...future.value$value, 
[13:21:03.249]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.249]                   ...future.rng), globalenv = if (FALSE) 
[13:21:03.249]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:03.249]                     ...future.globalenv.names))
[13:21:03.249]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:03.249]         }, condition = base::local({
[13:21:03.249]             c <- base::c
[13:21:03.249]             inherits <- base::inherits
[13:21:03.249]             invokeRestart <- base::invokeRestart
[13:21:03.249]             length <- base::length
[13:21:03.249]             list <- base::list
[13:21:03.249]             seq.int <- base::seq.int
[13:21:03.249]             signalCondition <- base::signalCondition
[13:21:03.249]             sys.calls <- base::sys.calls
[13:21:03.249]             `[[` <- base::`[[`
[13:21:03.249]             `+` <- base::`+`
[13:21:03.249]             `<<-` <- base::`<<-`
[13:21:03.249]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:03.249]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:03.249]                   3L)]
[13:21:03.249]             }
[13:21:03.249]             function(cond) {
[13:21:03.249]                 is_error <- inherits(cond, "error")
[13:21:03.249]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:03.249]                   NULL)
[13:21:03.249]                 if (is_error) {
[13:21:03.249]                   sessionInformation <- function() {
[13:21:03.249]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:03.249]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:03.249]                       search = base::search(), system = base::Sys.info())
[13:21:03.249]                   }
[13:21:03.249]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.249]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:03.249]                     cond$call), session = sessionInformation(), 
[13:21:03.249]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:03.249]                   signalCondition(cond)
[13:21:03.249]                 }
[13:21:03.249]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:03.249]                 "immediateCondition"))) {
[13:21:03.249]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:03.249]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.249]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:03.249]                   if (TRUE && !signal) {
[13:21:03.249]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.249]                     {
[13:21:03.249]                       inherits <- base::inherits
[13:21:03.249]                       invokeRestart <- base::invokeRestart
[13:21:03.249]                       is.null <- base::is.null
[13:21:03.249]                       muffled <- FALSE
[13:21:03.249]                       if (inherits(cond, "message")) {
[13:21:03.249]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.249]                         if (muffled) 
[13:21:03.249]                           invokeRestart("muffleMessage")
[13:21:03.249]                       }
[13:21:03.249]                       else if (inherits(cond, "warning")) {
[13:21:03.249]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.249]                         if (muffled) 
[13:21:03.249]                           invokeRestart("muffleWarning")
[13:21:03.249]                       }
[13:21:03.249]                       else if (inherits(cond, "condition")) {
[13:21:03.249]                         if (!is.null(pattern)) {
[13:21:03.249]                           computeRestarts <- base::computeRestarts
[13:21:03.249]                           grepl <- base::grepl
[13:21:03.249]                           restarts <- computeRestarts(cond)
[13:21:03.249]                           for (restart in restarts) {
[13:21:03.249]                             name <- restart$name
[13:21:03.249]                             if (is.null(name)) 
[13:21:03.249]                               next
[13:21:03.249]                             if (!grepl(pattern, name)) 
[13:21:03.249]                               next
[13:21:03.249]                             invokeRestart(restart)
[13:21:03.249]                             muffled <- TRUE
[13:21:03.249]                             break
[13:21:03.249]                           }
[13:21:03.249]                         }
[13:21:03.249]                       }
[13:21:03.249]                       invisible(muffled)
[13:21:03.249]                     }
[13:21:03.249]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.249]                   }
[13:21:03.249]                 }
[13:21:03.249]                 else {
[13:21:03.249]                   if (TRUE) {
[13:21:03.249]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.249]                     {
[13:21:03.249]                       inherits <- base::inherits
[13:21:03.249]                       invokeRestart <- base::invokeRestart
[13:21:03.249]                       is.null <- base::is.null
[13:21:03.249]                       muffled <- FALSE
[13:21:03.249]                       if (inherits(cond, "message")) {
[13:21:03.249]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.249]                         if (muffled) 
[13:21:03.249]                           invokeRestart("muffleMessage")
[13:21:03.249]                       }
[13:21:03.249]                       else if (inherits(cond, "warning")) {
[13:21:03.249]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.249]                         if (muffled) 
[13:21:03.249]                           invokeRestart("muffleWarning")
[13:21:03.249]                       }
[13:21:03.249]                       else if (inherits(cond, "condition")) {
[13:21:03.249]                         if (!is.null(pattern)) {
[13:21:03.249]                           computeRestarts <- base::computeRestarts
[13:21:03.249]                           grepl <- base::grepl
[13:21:03.249]                           restarts <- computeRestarts(cond)
[13:21:03.249]                           for (restart in restarts) {
[13:21:03.249]                             name <- restart$name
[13:21:03.249]                             if (is.null(name)) 
[13:21:03.249]                               next
[13:21:03.249]                             if (!grepl(pattern, name)) 
[13:21:03.249]                               next
[13:21:03.249]                             invokeRestart(restart)
[13:21:03.249]                             muffled <- TRUE
[13:21:03.249]                             break
[13:21:03.249]                           }
[13:21:03.249]                         }
[13:21:03.249]                       }
[13:21:03.249]                       invisible(muffled)
[13:21:03.249]                     }
[13:21:03.249]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.249]                   }
[13:21:03.249]                 }
[13:21:03.249]             }
[13:21:03.249]         }))
[13:21:03.249]     }, error = function(ex) {
[13:21:03.249]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:03.249]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.249]                 ...future.rng), started = ...future.startTime, 
[13:21:03.249]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:03.249]             version = "1.8"), class = "FutureResult")
[13:21:03.249]     }, finally = {
[13:21:03.249]         if (!identical(...future.workdir, getwd())) 
[13:21:03.249]             setwd(...future.workdir)
[13:21:03.249]         {
[13:21:03.249]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:03.249]                 ...future.oldOptions$nwarnings <- NULL
[13:21:03.249]             }
[13:21:03.249]             base::options(...future.oldOptions)
[13:21:03.249]             if (.Platform$OS.type == "windows") {
[13:21:03.249]                 old_names <- names(...future.oldEnvVars)
[13:21:03.249]                 envs <- base::Sys.getenv()
[13:21:03.249]                 names <- names(envs)
[13:21:03.249]                 common <- intersect(names, old_names)
[13:21:03.249]                 added <- setdiff(names, old_names)
[13:21:03.249]                 removed <- setdiff(old_names, names)
[13:21:03.249]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:03.249]                   envs[common]]
[13:21:03.249]                 NAMES <- toupper(changed)
[13:21:03.249]                 args <- list()
[13:21:03.249]                 for (kk in seq_along(NAMES)) {
[13:21:03.249]                   name <- changed[[kk]]
[13:21:03.249]                   NAME <- NAMES[[kk]]
[13:21:03.249]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.249]                     next
[13:21:03.249]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.249]                 }
[13:21:03.249]                 NAMES <- toupper(added)
[13:21:03.249]                 for (kk in seq_along(NAMES)) {
[13:21:03.249]                   name <- added[[kk]]
[13:21:03.249]                   NAME <- NAMES[[kk]]
[13:21:03.249]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.249]                     next
[13:21:03.249]                   args[[name]] <- ""
[13:21:03.249]                 }
[13:21:03.249]                 NAMES <- toupper(removed)
[13:21:03.249]                 for (kk in seq_along(NAMES)) {
[13:21:03.249]                   name <- removed[[kk]]
[13:21:03.249]                   NAME <- NAMES[[kk]]
[13:21:03.249]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.249]                     next
[13:21:03.249]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.249]                 }
[13:21:03.249]                 if (length(args) > 0) 
[13:21:03.249]                   base::do.call(base::Sys.setenv, args = args)
[13:21:03.249]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:03.249]             }
[13:21:03.249]             else {
[13:21:03.249]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:03.249]             }
[13:21:03.249]             {
[13:21:03.249]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:03.249]                   0L) {
[13:21:03.249]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:03.249]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:03.249]                   base::options(opts)
[13:21:03.249]                 }
[13:21:03.249]                 {
[13:21:03.249]                   {
[13:21:03.249]                     NULL
[13:21:03.249]                     RNGkind("Mersenne-Twister")
[13:21:03.249]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:03.249]                       inherits = FALSE)
[13:21:03.249]                   }
[13:21:03.249]                   options(future.plan = NULL)
[13:21:03.249]                   if (is.na(NA_character_)) 
[13:21:03.249]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.249]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:03.249]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:03.249]                     envir = parent.frame()) 
[13:21:03.249]                   {
[13:21:03.249]                     default_workers <- missing(workers)
[13:21:03.249]                     if (is.function(workers)) 
[13:21:03.249]                       workers <- workers()
[13:21:03.249]                     workers <- structure(as.integer(workers), 
[13:21:03.249]                       class = class(workers))
[13:21:03.249]                     stop_if_not(is.finite(workers), workers >= 
[13:21:03.249]                       1L)
[13:21:03.249]                     if ((workers == 1L && !inherits(workers, 
[13:21:03.249]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:03.249]                       if (default_workers) 
[13:21:03.249]                         supportsMulticore(warn = TRUE)
[13:21:03.249]                       return(sequential(..., envir = envir))
[13:21:03.249]                     }
[13:21:03.249]                     oopts <- options(mc.cores = workers)
[13:21:03.249]                     on.exit(options(oopts))
[13:21:03.249]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:03.249]                       envir = envir)
[13:21:03.249]                     if (!future$lazy) 
[13:21:03.249]                       future <- run(future)
[13:21:03.249]                     invisible(future)
[13:21:03.249]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:03.249]                 }
[13:21:03.249]             }
[13:21:03.249]         }
[13:21:03.249]     })
[13:21:03.249]     if (TRUE) {
[13:21:03.249]         base::sink(type = "output", split = FALSE)
[13:21:03.249]         if (TRUE) {
[13:21:03.249]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:03.249]         }
[13:21:03.249]         else {
[13:21:03.249]             ...future.result["stdout"] <- base::list(NULL)
[13:21:03.249]         }
[13:21:03.249]         base::close(...future.stdout)
[13:21:03.249]         ...future.stdout <- NULL
[13:21:03.249]     }
[13:21:03.249]     ...future.result$conditions <- ...future.conditions
[13:21:03.249]     ...future.result$finished <- base::Sys.time()
[13:21:03.249]     ...future.result
[13:21:03.249] }
[13:21:03.250] plan(): Setting new future strategy stack:
[13:21:03.250] List of future strategies:
[13:21:03.250] 1. sequential:
[13:21:03.250]    - args: function (..., envir = parent.frame())
[13:21:03.250]    - tweaked: FALSE
[13:21:03.250]    - call: NULL
[13:21:03.251] plan(): nbrOfWorkers() = 1
[13:21:03.251] plan(): Setting new future strategy stack:
[13:21:03.252] List of future strategies:
[13:21:03.252] 1. multicore:
[13:21:03.252]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:03.252]    - tweaked: FALSE
[13:21:03.252]    - call: plan(multicore)
[13:21:03.255] plan(): nbrOfWorkers() = 1
[13:21:03.255] SequentialFuture started (and completed)
 - Creating multicore future #4 ...
[13:21:03.258] getGlobalsAndPackages() ...
[13:21:03.258] Not searching for globals
[13:21:03.259] - globals: [0] <none>
[13:21:03.259] getGlobalsAndPackages() ... DONE
[13:21:03.259] Packages needed by the future expression (n = 0): <none>
[13:21:03.259] Packages needed by future strategies (n = 0): <none>
[13:21:03.259] {
[13:21:03.259]     {
[13:21:03.259]         {
[13:21:03.259]             ...future.startTime <- base::Sys.time()
[13:21:03.259]             {
[13:21:03.259]                 {
[13:21:03.259]                   {
[13:21:03.259]                     base::local({
[13:21:03.259]                       has_future <- base::requireNamespace("future", 
[13:21:03.259]                         quietly = TRUE)
[13:21:03.259]                       if (has_future) {
[13:21:03.259]                         ns <- base::getNamespace("future")
[13:21:03.259]                         version <- ns[[".package"]][["version"]]
[13:21:03.259]                         if (is.null(version)) 
[13:21:03.259]                           version <- utils::packageVersion("future")
[13:21:03.259]                       }
[13:21:03.259]                       else {
[13:21:03.259]                         version <- NULL
[13:21:03.259]                       }
[13:21:03.259]                       if (!has_future || version < "1.8.0") {
[13:21:03.259]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:03.259]                           "", base::R.version$version.string), 
[13:21:03.259]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:03.259]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:03.259]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:03.259]                             "release", "version")], collapse = " "), 
[13:21:03.259]                           hostname = base::Sys.info()[["nodename"]])
[13:21:03.259]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:03.259]                           info)
[13:21:03.259]                         info <- base::paste(info, collapse = "; ")
[13:21:03.259]                         if (!has_future) {
[13:21:03.259]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:03.259]                             info)
[13:21:03.259]                         }
[13:21:03.259]                         else {
[13:21:03.259]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:03.259]                             info, version)
[13:21:03.259]                         }
[13:21:03.259]                         base::stop(msg)
[13:21:03.259]                       }
[13:21:03.259]                     })
[13:21:03.259]                   }
[13:21:03.259]                   options(future.plan = NULL)
[13:21:03.259]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.259]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:03.259]                 }
[13:21:03.259]                 ...future.workdir <- getwd()
[13:21:03.259]             }
[13:21:03.259]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:03.259]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:03.259]         }
[13:21:03.259]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:03.259]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:03.259]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:03.259]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:03.259]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:03.259]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:03.259]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:03.259]             base::names(...future.oldOptions))
[13:21:03.259]     }
[13:21:03.259]     if (FALSE) {
[13:21:03.259]     }
[13:21:03.259]     else {
[13:21:03.259]         if (TRUE) {
[13:21:03.259]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:03.259]                 open = "w")
[13:21:03.259]         }
[13:21:03.259]         else {
[13:21:03.259]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:03.259]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:03.259]         }
[13:21:03.259]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:03.259]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:03.259]             base::sink(type = "output", split = FALSE)
[13:21:03.259]             base::close(...future.stdout)
[13:21:03.259]         }, add = TRUE)
[13:21:03.259]     }
[13:21:03.259]     ...future.frame <- base::sys.nframe()
[13:21:03.259]     ...future.conditions <- base::list()
[13:21:03.259]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:03.259]     if (FALSE) {
[13:21:03.259]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:03.259]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:03.259]     }
[13:21:03.259]     ...future.result <- base::tryCatch({
[13:21:03.259]         base::withCallingHandlers({
[13:21:03.259]             ...future.value <- base::withVisible(base::local({
[13:21:03.259]                 ii
[13:21:03.259]             }))
[13:21:03.259]             future::FutureResult(value = ...future.value$value, 
[13:21:03.259]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.259]                   ...future.rng), globalenv = if (FALSE) 
[13:21:03.259]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:03.259]                     ...future.globalenv.names))
[13:21:03.259]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:03.259]         }, condition = base::local({
[13:21:03.259]             c <- base::c
[13:21:03.259]             inherits <- base::inherits
[13:21:03.259]             invokeRestart <- base::invokeRestart
[13:21:03.259]             length <- base::length
[13:21:03.259]             list <- base::list
[13:21:03.259]             seq.int <- base::seq.int
[13:21:03.259]             signalCondition <- base::signalCondition
[13:21:03.259]             sys.calls <- base::sys.calls
[13:21:03.259]             `[[` <- base::`[[`
[13:21:03.259]             `+` <- base::`+`
[13:21:03.259]             `<<-` <- base::`<<-`
[13:21:03.259]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:03.259]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:03.259]                   3L)]
[13:21:03.259]             }
[13:21:03.259]             function(cond) {
[13:21:03.259]                 is_error <- inherits(cond, "error")
[13:21:03.259]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:03.259]                   NULL)
[13:21:03.259]                 if (is_error) {
[13:21:03.259]                   sessionInformation <- function() {
[13:21:03.259]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:03.259]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:03.259]                       search = base::search(), system = base::Sys.info())
[13:21:03.259]                   }
[13:21:03.259]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.259]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:03.259]                     cond$call), session = sessionInformation(), 
[13:21:03.259]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:03.259]                   signalCondition(cond)
[13:21:03.259]                 }
[13:21:03.259]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:03.259]                 "immediateCondition"))) {
[13:21:03.259]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:03.259]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.259]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:03.259]                   if (TRUE && !signal) {
[13:21:03.259]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.259]                     {
[13:21:03.259]                       inherits <- base::inherits
[13:21:03.259]                       invokeRestart <- base::invokeRestart
[13:21:03.259]                       is.null <- base::is.null
[13:21:03.259]                       muffled <- FALSE
[13:21:03.259]                       if (inherits(cond, "message")) {
[13:21:03.259]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.259]                         if (muffled) 
[13:21:03.259]                           invokeRestart("muffleMessage")
[13:21:03.259]                       }
[13:21:03.259]                       else if (inherits(cond, "warning")) {
[13:21:03.259]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.259]                         if (muffled) 
[13:21:03.259]                           invokeRestart("muffleWarning")
[13:21:03.259]                       }
[13:21:03.259]                       else if (inherits(cond, "condition")) {
[13:21:03.259]                         if (!is.null(pattern)) {
[13:21:03.259]                           computeRestarts <- base::computeRestarts
[13:21:03.259]                           grepl <- base::grepl
[13:21:03.259]                           restarts <- computeRestarts(cond)
[13:21:03.259]                           for (restart in restarts) {
[13:21:03.259]                             name <- restart$name
[13:21:03.259]                             if (is.null(name)) 
[13:21:03.259]                               next
[13:21:03.259]                             if (!grepl(pattern, name)) 
[13:21:03.259]                               next
[13:21:03.259]                             invokeRestart(restart)
[13:21:03.259]                             muffled <- TRUE
[13:21:03.259]                             break
[13:21:03.259]                           }
[13:21:03.259]                         }
[13:21:03.259]                       }
[13:21:03.259]                       invisible(muffled)
[13:21:03.259]                     }
[13:21:03.259]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.259]                   }
[13:21:03.259]                 }
[13:21:03.259]                 else {
[13:21:03.259]                   if (TRUE) {
[13:21:03.259]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.259]                     {
[13:21:03.259]                       inherits <- base::inherits
[13:21:03.259]                       invokeRestart <- base::invokeRestart
[13:21:03.259]                       is.null <- base::is.null
[13:21:03.259]                       muffled <- FALSE
[13:21:03.259]                       if (inherits(cond, "message")) {
[13:21:03.259]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.259]                         if (muffled) 
[13:21:03.259]                           invokeRestart("muffleMessage")
[13:21:03.259]                       }
[13:21:03.259]                       else if (inherits(cond, "warning")) {
[13:21:03.259]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.259]                         if (muffled) 
[13:21:03.259]                           invokeRestart("muffleWarning")
[13:21:03.259]                       }
[13:21:03.259]                       else if (inherits(cond, "condition")) {
[13:21:03.259]                         if (!is.null(pattern)) {
[13:21:03.259]                           computeRestarts <- base::computeRestarts
[13:21:03.259]                           grepl <- base::grepl
[13:21:03.259]                           restarts <- computeRestarts(cond)
[13:21:03.259]                           for (restart in restarts) {
[13:21:03.259]                             name <- restart$name
[13:21:03.259]                             if (is.null(name)) 
[13:21:03.259]                               next
[13:21:03.259]                             if (!grepl(pattern, name)) 
[13:21:03.259]                               next
[13:21:03.259]                             invokeRestart(restart)
[13:21:03.259]                             muffled <- TRUE
[13:21:03.259]                             break
[13:21:03.259]                           }
[13:21:03.259]                         }
[13:21:03.259]                       }
[13:21:03.259]                       invisible(muffled)
[13:21:03.259]                     }
[13:21:03.259]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.259]                   }
[13:21:03.259]                 }
[13:21:03.259]             }
[13:21:03.259]         }))
[13:21:03.259]     }, error = function(ex) {
[13:21:03.259]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:03.259]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.259]                 ...future.rng), started = ...future.startTime, 
[13:21:03.259]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:03.259]             version = "1.8"), class = "FutureResult")
[13:21:03.259]     }, finally = {
[13:21:03.259]         if (!identical(...future.workdir, getwd())) 
[13:21:03.259]             setwd(...future.workdir)
[13:21:03.259]         {
[13:21:03.259]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:03.259]                 ...future.oldOptions$nwarnings <- NULL
[13:21:03.259]             }
[13:21:03.259]             base::options(...future.oldOptions)
[13:21:03.259]             if (.Platform$OS.type == "windows") {
[13:21:03.259]                 old_names <- names(...future.oldEnvVars)
[13:21:03.259]                 envs <- base::Sys.getenv()
[13:21:03.259]                 names <- names(envs)
[13:21:03.259]                 common <- intersect(names, old_names)
[13:21:03.259]                 added <- setdiff(names, old_names)
[13:21:03.259]                 removed <- setdiff(old_names, names)
[13:21:03.259]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:03.259]                   envs[common]]
[13:21:03.259]                 NAMES <- toupper(changed)
[13:21:03.259]                 args <- list()
[13:21:03.259]                 for (kk in seq_along(NAMES)) {
[13:21:03.259]                   name <- changed[[kk]]
[13:21:03.259]                   NAME <- NAMES[[kk]]
[13:21:03.259]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.259]                     next
[13:21:03.259]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.259]                 }
[13:21:03.259]                 NAMES <- toupper(added)
[13:21:03.259]                 for (kk in seq_along(NAMES)) {
[13:21:03.259]                   name <- added[[kk]]
[13:21:03.259]                   NAME <- NAMES[[kk]]
[13:21:03.259]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.259]                     next
[13:21:03.259]                   args[[name]] <- ""
[13:21:03.259]                 }
[13:21:03.259]                 NAMES <- toupper(removed)
[13:21:03.259]                 for (kk in seq_along(NAMES)) {
[13:21:03.259]                   name <- removed[[kk]]
[13:21:03.259]                   NAME <- NAMES[[kk]]
[13:21:03.259]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.259]                     next
[13:21:03.259]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.259]                 }
[13:21:03.259]                 if (length(args) > 0) 
[13:21:03.259]                   base::do.call(base::Sys.setenv, args = args)
[13:21:03.259]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:03.259]             }
[13:21:03.259]             else {
[13:21:03.259]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:03.259]             }
[13:21:03.259]             {
[13:21:03.259]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:03.259]                   0L) {
[13:21:03.259]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:03.259]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:03.259]                   base::options(opts)
[13:21:03.259]                 }
[13:21:03.259]                 {
[13:21:03.259]                   {
[13:21:03.259]                     NULL
[13:21:03.259]                     RNGkind("Mersenne-Twister")
[13:21:03.259]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:03.259]                       inherits = FALSE)
[13:21:03.259]                   }
[13:21:03.259]                   options(future.plan = NULL)
[13:21:03.259]                   if (is.na(NA_character_)) 
[13:21:03.259]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.259]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:03.259]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:03.259]                     envir = parent.frame()) 
[13:21:03.259]                   {
[13:21:03.259]                     default_workers <- missing(workers)
[13:21:03.259]                     if (is.function(workers)) 
[13:21:03.259]                       workers <- workers()
[13:21:03.259]                     workers <- structure(as.integer(workers), 
[13:21:03.259]                       class = class(workers))
[13:21:03.259]                     stop_if_not(is.finite(workers), workers >= 
[13:21:03.259]                       1L)
[13:21:03.259]                     if ((workers == 1L && !inherits(workers, 
[13:21:03.259]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:03.259]                       if (default_workers) 
[13:21:03.259]                         supportsMulticore(warn = TRUE)
[13:21:03.259]                       return(sequential(..., envir = envir))
[13:21:03.259]                     }
[13:21:03.259]                     oopts <- options(mc.cores = workers)
[13:21:03.259]                     on.exit(options(oopts))
[13:21:03.259]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:03.259]                       envir = envir)
[13:21:03.259]                     if (!future$lazy) 
[13:21:03.259]                       future <- run(future)
[13:21:03.259]                     invisible(future)
[13:21:03.259]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:03.259]                 }
[13:21:03.259]             }
[13:21:03.259]         }
[13:21:03.259]     })
[13:21:03.259]     if (TRUE) {
[13:21:03.259]         base::sink(type = "output", split = FALSE)
[13:21:03.259]         if (TRUE) {
[13:21:03.259]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:03.259]         }
[13:21:03.259]         else {
[13:21:03.259]             ...future.result["stdout"] <- base::list(NULL)
[13:21:03.259]         }
[13:21:03.259]         base::close(...future.stdout)
[13:21:03.259]         ...future.stdout <- NULL
[13:21:03.259]     }
[13:21:03.259]     ...future.result$conditions <- ...future.conditions
[13:21:03.259]     ...future.result$finished <- base::Sys.time()
[13:21:03.259]     ...future.result
[13:21:03.259] }
[13:21:03.261] plan(): Setting new future strategy stack:
[13:21:03.261] List of future strategies:
[13:21:03.261] 1. sequential:
[13:21:03.261]    - args: function (..., envir = parent.frame())
[13:21:03.261]    - tweaked: FALSE
[13:21:03.261]    - call: NULL
[13:21:03.262] plan(): nbrOfWorkers() = 1
[13:21:03.262] plan(): Setting new future strategy stack:
[13:21:03.262] List of future strategies:
[13:21:03.262] 1. multicore:
[13:21:03.262]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:03.262]    - tweaked: FALSE
[13:21:03.262]    - call: plan(multicore)
[13:21:03.266] plan(): nbrOfWorkers() = 1
[13:21:03.266] SequentialFuture started (and completed)
 - Resolving 4 multicore futures
*** multicore(..., globals = FALSE) and errors
[13:21:03.270] getGlobalsAndPackages() ...
[13:21:03.270] Not searching for globals
[13:21:03.270] - globals: [0] <none>
[13:21:03.270] getGlobalsAndPackages() ... DONE
[13:21:03.270] Packages needed by the future expression (n = 0): <none>
[13:21:03.270] Packages needed by future strategies (n = 0): <none>
[13:21:03.271] {
[13:21:03.271]     {
[13:21:03.271]         {
[13:21:03.271]             ...future.startTime <- base::Sys.time()
[13:21:03.271]             {
[13:21:03.271]                 {
[13:21:03.271]                   {
[13:21:03.271]                     base::local({
[13:21:03.271]                       has_future <- base::requireNamespace("future", 
[13:21:03.271]                         quietly = TRUE)
[13:21:03.271]                       if (has_future) {
[13:21:03.271]                         ns <- base::getNamespace("future")
[13:21:03.271]                         version <- ns[[".package"]][["version"]]
[13:21:03.271]                         if (is.null(version)) 
[13:21:03.271]                           version <- utils::packageVersion("future")
[13:21:03.271]                       }
[13:21:03.271]                       else {
[13:21:03.271]                         version <- NULL
[13:21:03.271]                       }
[13:21:03.271]                       if (!has_future || version < "1.8.0") {
[13:21:03.271]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:03.271]                           "", base::R.version$version.string), 
[13:21:03.271]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:03.271]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:03.271]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:03.271]                             "release", "version")], collapse = " "), 
[13:21:03.271]                           hostname = base::Sys.info()[["nodename"]])
[13:21:03.271]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:03.271]                           info)
[13:21:03.271]                         info <- base::paste(info, collapse = "; ")
[13:21:03.271]                         if (!has_future) {
[13:21:03.271]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:03.271]                             info)
[13:21:03.271]                         }
[13:21:03.271]                         else {
[13:21:03.271]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:03.271]                             info, version)
[13:21:03.271]                         }
[13:21:03.271]                         base::stop(msg)
[13:21:03.271]                       }
[13:21:03.271]                     })
[13:21:03.271]                   }
[13:21:03.271]                   options(future.plan = NULL)
[13:21:03.271]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.271]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:03.271]                 }
[13:21:03.271]                 ...future.workdir <- getwd()
[13:21:03.271]             }
[13:21:03.271]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:03.271]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:03.271]         }
[13:21:03.271]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:03.271]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:03.271]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:03.271]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:03.271]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:03.271]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:03.271]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:03.271]             base::names(...future.oldOptions))
[13:21:03.271]     }
[13:21:03.271]     if (FALSE) {
[13:21:03.271]     }
[13:21:03.271]     else {
[13:21:03.271]         if (TRUE) {
[13:21:03.271]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:03.271]                 open = "w")
[13:21:03.271]         }
[13:21:03.271]         else {
[13:21:03.271]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:03.271]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:03.271]         }
[13:21:03.271]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:03.271]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:03.271]             base::sink(type = "output", split = FALSE)
[13:21:03.271]             base::close(...future.stdout)
[13:21:03.271]         }, add = TRUE)
[13:21:03.271]     }
[13:21:03.271]     ...future.frame <- base::sys.nframe()
[13:21:03.271]     ...future.conditions <- base::list()
[13:21:03.271]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:03.271]     if (FALSE) {
[13:21:03.271]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:03.271]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:03.271]     }
[13:21:03.271]     ...future.result <- base::tryCatch({
[13:21:03.271]         base::withCallingHandlers({
[13:21:03.271]             ...future.value <- base::withVisible(base::local({
[13:21:03.271]                 stop("Whoops!")
[13:21:03.271]                 1
[13:21:03.271]             }))
[13:21:03.271]             future::FutureResult(value = ...future.value$value, 
[13:21:03.271]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.271]                   ...future.rng), globalenv = if (FALSE) 
[13:21:03.271]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:03.271]                     ...future.globalenv.names))
[13:21:03.271]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:03.271]         }, condition = base::local({
[13:21:03.271]             c <- base::c
[13:21:03.271]             inherits <- base::inherits
[13:21:03.271]             invokeRestart <- base::invokeRestart
[13:21:03.271]             length <- base::length
[13:21:03.271]             list <- base::list
[13:21:03.271]             seq.int <- base::seq.int
[13:21:03.271]             signalCondition <- base::signalCondition
[13:21:03.271]             sys.calls <- base::sys.calls
[13:21:03.271]             `[[` <- base::`[[`
[13:21:03.271]             `+` <- base::`+`
[13:21:03.271]             `<<-` <- base::`<<-`
[13:21:03.271]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:03.271]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:03.271]                   3L)]
[13:21:03.271]             }
[13:21:03.271]             function(cond) {
[13:21:03.271]                 is_error <- inherits(cond, "error")
[13:21:03.271]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:03.271]                   NULL)
[13:21:03.271]                 if (is_error) {
[13:21:03.271]                   sessionInformation <- function() {
[13:21:03.271]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:03.271]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:03.271]                       search = base::search(), system = base::Sys.info())
[13:21:03.271]                   }
[13:21:03.271]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.271]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:03.271]                     cond$call), session = sessionInformation(), 
[13:21:03.271]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:03.271]                   signalCondition(cond)
[13:21:03.271]                 }
[13:21:03.271]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:03.271]                 "immediateCondition"))) {
[13:21:03.271]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:03.271]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.271]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:03.271]                   if (TRUE && !signal) {
[13:21:03.271]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.271]                     {
[13:21:03.271]                       inherits <- base::inherits
[13:21:03.271]                       invokeRestart <- base::invokeRestart
[13:21:03.271]                       is.null <- base::is.null
[13:21:03.271]                       muffled <- FALSE
[13:21:03.271]                       if (inherits(cond, "message")) {
[13:21:03.271]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.271]                         if (muffled) 
[13:21:03.271]                           invokeRestart("muffleMessage")
[13:21:03.271]                       }
[13:21:03.271]                       else if (inherits(cond, "warning")) {
[13:21:03.271]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.271]                         if (muffled) 
[13:21:03.271]                           invokeRestart("muffleWarning")
[13:21:03.271]                       }
[13:21:03.271]                       else if (inherits(cond, "condition")) {
[13:21:03.271]                         if (!is.null(pattern)) {
[13:21:03.271]                           computeRestarts <- base::computeRestarts
[13:21:03.271]                           grepl <- base::grepl
[13:21:03.271]                           restarts <- computeRestarts(cond)
[13:21:03.271]                           for (restart in restarts) {
[13:21:03.271]                             name <- restart$name
[13:21:03.271]                             if (is.null(name)) 
[13:21:03.271]                               next
[13:21:03.271]                             if (!grepl(pattern, name)) 
[13:21:03.271]                               next
[13:21:03.271]                             invokeRestart(restart)
[13:21:03.271]                             muffled <- TRUE
[13:21:03.271]                             break
[13:21:03.271]                           }
[13:21:03.271]                         }
[13:21:03.271]                       }
[13:21:03.271]                       invisible(muffled)
[13:21:03.271]                     }
[13:21:03.271]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.271]                   }
[13:21:03.271]                 }
[13:21:03.271]                 else {
[13:21:03.271]                   if (TRUE) {
[13:21:03.271]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.271]                     {
[13:21:03.271]                       inherits <- base::inherits
[13:21:03.271]                       invokeRestart <- base::invokeRestart
[13:21:03.271]                       is.null <- base::is.null
[13:21:03.271]                       muffled <- FALSE
[13:21:03.271]                       if (inherits(cond, "message")) {
[13:21:03.271]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.271]                         if (muffled) 
[13:21:03.271]                           invokeRestart("muffleMessage")
[13:21:03.271]                       }
[13:21:03.271]                       else if (inherits(cond, "warning")) {
[13:21:03.271]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.271]                         if (muffled) 
[13:21:03.271]                           invokeRestart("muffleWarning")
[13:21:03.271]                       }
[13:21:03.271]                       else if (inherits(cond, "condition")) {
[13:21:03.271]                         if (!is.null(pattern)) {
[13:21:03.271]                           computeRestarts <- base::computeRestarts
[13:21:03.271]                           grepl <- base::grepl
[13:21:03.271]                           restarts <- computeRestarts(cond)
[13:21:03.271]                           for (restart in restarts) {
[13:21:03.271]                             name <- restart$name
[13:21:03.271]                             if (is.null(name)) 
[13:21:03.271]                               next
[13:21:03.271]                             if (!grepl(pattern, name)) 
[13:21:03.271]                               next
[13:21:03.271]                             invokeRestart(restart)
[13:21:03.271]                             muffled <- TRUE
[13:21:03.271]                             break
[13:21:03.271]                           }
[13:21:03.271]                         }
[13:21:03.271]                       }
[13:21:03.271]                       invisible(muffled)
[13:21:03.271]                     }
[13:21:03.271]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.271]                   }
[13:21:03.271]                 }
[13:21:03.271]             }
[13:21:03.271]         }))
[13:21:03.271]     }, error = function(ex) {
[13:21:03.271]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:03.271]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.271]                 ...future.rng), started = ...future.startTime, 
[13:21:03.271]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:03.271]             version = "1.8"), class = "FutureResult")
[13:21:03.271]     }, finally = {
[13:21:03.271]         if (!identical(...future.workdir, getwd())) 
[13:21:03.271]             setwd(...future.workdir)
[13:21:03.271]         {
[13:21:03.271]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:03.271]                 ...future.oldOptions$nwarnings <- NULL
[13:21:03.271]             }
[13:21:03.271]             base::options(...future.oldOptions)
[13:21:03.271]             if (.Platform$OS.type == "windows") {
[13:21:03.271]                 old_names <- names(...future.oldEnvVars)
[13:21:03.271]                 envs <- base::Sys.getenv()
[13:21:03.271]                 names <- names(envs)
[13:21:03.271]                 common <- intersect(names, old_names)
[13:21:03.271]                 added <- setdiff(names, old_names)
[13:21:03.271]                 removed <- setdiff(old_names, names)
[13:21:03.271]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:03.271]                   envs[common]]
[13:21:03.271]                 NAMES <- toupper(changed)
[13:21:03.271]                 args <- list()
[13:21:03.271]                 for (kk in seq_along(NAMES)) {
[13:21:03.271]                   name <- changed[[kk]]
[13:21:03.271]                   NAME <- NAMES[[kk]]
[13:21:03.271]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.271]                     next
[13:21:03.271]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.271]                 }
[13:21:03.271]                 NAMES <- toupper(added)
[13:21:03.271]                 for (kk in seq_along(NAMES)) {
[13:21:03.271]                   name <- added[[kk]]
[13:21:03.271]                   NAME <- NAMES[[kk]]
[13:21:03.271]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.271]                     next
[13:21:03.271]                   args[[name]] <- ""
[13:21:03.271]                 }
[13:21:03.271]                 NAMES <- toupper(removed)
[13:21:03.271]                 for (kk in seq_along(NAMES)) {
[13:21:03.271]                   name <- removed[[kk]]
[13:21:03.271]                   NAME <- NAMES[[kk]]
[13:21:03.271]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.271]                     next
[13:21:03.271]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.271]                 }
[13:21:03.271]                 if (length(args) > 0) 
[13:21:03.271]                   base::do.call(base::Sys.setenv, args = args)
[13:21:03.271]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:03.271]             }
[13:21:03.271]             else {
[13:21:03.271]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:03.271]             }
[13:21:03.271]             {
[13:21:03.271]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:03.271]                   0L) {
[13:21:03.271]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:03.271]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:03.271]                   base::options(opts)
[13:21:03.271]                 }
[13:21:03.271]                 {
[13:21:03.271]                   {
[13:21:03.271]                     NULL
[13:21:03.271]                     RNGkind("Mersenne-Twister")
[13:21:03.271]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:03.271]                       inherits = FALSE)
[13:21:03.271]                   }
[13:21:03.271]                   options(future.plan = NULL)
[13:21:03.271]                   if (is.na(NA_character_)) 
[13:21:03.271]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.271]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:03.271]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:03.271]                     envir = parent.frame()) 
[13:21:03.271]                   {
[13:21:03.271]                     default_workers <- missing(workers)
[13:21:03.271]                     if (is.function(workers)) 
[13:21:03.271]                       workers <- workers()
[13:21:03.271]                     workers <- structure(as.integer(workers), 
[13:21:03.271]                       class = class(workers))
[13:21:03.271]                     stop_if_not(is.finite(workers), workers >= 
[13:21:03.271]                       1L)
[13:21:03.271]                     if ((workers == 1L && !inherits(workers, 
[13:21:03.271]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:03.271]                       if (default_workers) 
[13:21:03.271]                         supportsMulticore(warn = TRUE)
[13:21:03.271]                       return(sequential(..., envir = envir))
[13:21:03.271]                     }
[13:21:03.271]                     oopts <- options(mc.cores = workers)
[13:21:03.271]                     on.exit(options(oopts))
[13:21:03.271]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:03.271]                       envir = envir)
[13:21:03.271]                     if (!future$lazy) 
[13:21:03.271]                       future <- run(future)
[13:21:03.271]                     invisible(future)
[13:21:03.271]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:03.271]                 }
[13:21:03.271]             }
[13:21:03.271]         }
[13:21:03.271]     })
[13:21:03.271]     if (TRUE) {
[13:21:03.271]         base::sink(type = "output", split = FALSE)
[13:21:03.271]         if (TRUE) {
[13:21:03.271]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:03.271]         }
[13:21:03.271]         else {
[13:21:03.271]             ...future.result["stdout"] <- base::list(NULL)
[13:21:03.271]         }
[13:21:03.271]         base::close(...future.stdout)
[13:21:03.271]         ...future.stdout <- NULL
[13:21:03.271]     }
[13:21:03.271]     ...future.result$conditions <- ...future.conditions
[13:21:03.271]     ...future.result$finished <- base::Sys.time()
[13:21:03.271]     ...future.result
[13:21:03.271] }
[13:21:03.273] plan(): Setting new future strategy stack:
[13:21:03.273] List of future strategies:
[13:21:03.273] 1. sequential:
[13:21:03.273]    - args: function (..., envir = parent.frame())
[13:21:03.273]    - tweaked: FALSE
[13:21:03.273]    - call: NULL
[13:21:03.273] plan(): nbrOfWorkers() = 1
[13:21:03.274] plan(): Setting new future strategy stack:
[13:21:03.274] List of future strategies:
[13:21:03.274] 1. multicore:
[13:21:03.274]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:03.274]    - tweaked: FALSE
[13:21:03.274]    - call: plan(multicore)
[13:21:03.278] plan(): nbrOfWorkers() = 1
[13:21:03.278] SequentialFuture started (and completed)
[13:21:03.278] signalConditions() ...
[13:21:03.279]  - include = ‘immediateCondition’
[13:21:03.280]  - exclude = 
[13:21:03.280]  - resignal = FALSE
[13:21:03.280]  - Number of conditions: 1
[13:21:03.280] signalConditions() ... done
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 0 bytes of class ‘NULL’
Conditions captured: [n=1] ‘simpleError’
Early signaling: FALSE
Owner process: 32f7abe8-d290-272e-8911-a8ce072c31c3
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:03.280] signalConditions() ...
[13:21:03.280]  - include = ‘immediateCondition’
[13:21:03.281]  - exclude = 
[13:21:03.281]  - resignal = FALSE
[13:21:03.281]  - Number of conditions: 1
[13:21:03.281] signalConditions() ... done
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[13:21:03.281] signalConditions() ...
[13:21:03.281]  - include = ‘immediateCondition’
[13:21:03.281]  - exclude = 
[13:21:03.282]  - resignal = FALSE
[13:21:03.282]  - Number of conditions: 1
[13:21:03.282] signalConditions() ... done
[13:21:03.282] Future state: ‘finished’
[13:21:03.282] signalConditions() ...
[13:21:03.282]  - include = ‘condition’
[13:21:03.282]  - exclude = ‘immediateCondition’
[13:21:03.282]  - resignal = TRUE
[13:21:03.282]  - Number of conditions: 1
[13:21:03.282]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:21:03.283] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[13:21:03.283] signalConditions() ...
[13:21:03.283]  - include = ‘immediateCondition’
[13:21:03.283]  - exclude = 
[13:21:03.283]  - resignal = FALSE
[13:21:03.283]  - Number of conditions: 1
[13:21:03.283] signalConditions() ... done
[13:21:03.283] Future state: ‘finished’
[13:21:03.284] signalConditions() ...
[13:21:03.284]  - include = ‘condition’
[13:21:03.284]  - exclude = ‘immediateCondition’
[13:21:03.284]  - resignal = TRUE
[13:21:03.284]  - Number of conditions: 1
[13:21:03.284]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:21:03.284] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[13:21:03.288] getGlobalsAndPackages() ...
[13:21:03.288] Searching for globals...
[13:21:03.294] - globals found: [5] ‘{’, ‘stop’, ‘structure’, ‘list’, ‘c’
[13:21:03.294] Searching for globals ... DONE
[13:21:03.295] Resolving globals: FALSE
[13:21:03.295] 
[13:21:03.295] 
[13:21:03.295] getGlobalsAndPackages() ... DONE
[13:21:03.296] Packages needed by the future expression (n = 0): <none>
[13:21:03.296] Packages needed by future strategies (n = 0): <none>
[13:21:03.296] {
[13:21:03.296]     {
[13:21:03.296]         {
[13:21:03.296]             ...future.startTime <- base::Sys.time()
[13:21:03.296]             {
[13:21:03.296]                 {
[13:21:03.296]                   {
[13:21:03.296]                     base::local({
[13:21:03.296]                       has_future <- base::requireNamespace("future", 
[13:21:03.296]                         quietly = TRUE)
[13:21:03.296]                       if (has_future) {
[13:21:03.296]                         ns <- base::getNamespace("future")
[13:21:03.296]                         version <- ns[[".package"]][["version"]]
[13:21:03.296]                         if (is.null(version)) 
[13:21:03.296]                           version <- utils::packageVersion("future")
[13:21:03.296]                       }
[13:21:03.296]                       else {
[13:21:03.296]                         version <- NULL
[13:21:03.296]                       }
[13:21:03.296]                       if (!has_future || version < "1.8.0") {
[13:21:03.296]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:03.296]                           "", base::R.version$version.string), 
[13:21:03.296]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:03.296]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:03.296]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:03.296]                             "release", "version")], collapse = " "), 
[13:21:03.296]                           hostname = base::Sys.info()[["nodename"]])
[13:21:03.296]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:03.296]                           info)
[13:21:03.296]                         info <- base::paste(info, collapse = "; ")
[13:21:03.296]                         if (!has_future) {
[13:21:03.296]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:03.296]                             info)
[13:21:03.296]                         }
[13:21:03.296]                         else {
[13:21:03.296]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:03.296]                             info, version)
[13:21:03.296]                         }
[13:21:03.296]                         base::stop(msg)
[13:21:03.296]                       }
[13:21:03.296]                     })
[13:21:03.296]                   }
[13:21:03.296]                   options(future.plan = NULL)
[13:21:03.296]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.296]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:03.296]                 }
[13:21:03.296]                 ...future.workdir <- getwd()
[13:21:03.296]             }
[13:21:03.296]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:03.296]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:03.296]         }
[13:21:03.296]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:03.296]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:03.296]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:03.296]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:03.296]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:03.296]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:03.296]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:03.296]             base::names(...future.oldOptions))
[13:21:03.296]     }
[13:21:03.296]     if (FALSE) {
[13:21:03.296]     }
[13:21:03.296]     else {
[13:21:03.296]         if (TRUE) {
[13:21:03.296]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:03.296]                 open = "w")
[13:21:03.296]         }
[13:21:03.296]         else {
[13:21:03.296]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:03.296]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:03.296]         }
[13:21:03.296]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:03.296]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:03.296]             base::sink(type = "output", split = FALSE)
[13:21:03.296]             base::close(...future.stdout)
[13:21:03.296]         }, add = TRUE)
[13:21:03.296]     }
[13:21:03.296]     ...future.frame <- base::sys.nframe()
[13:21:03.296]     ...future.conditions <- base::list()
[13:21:03.296]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:03.296]     if (FALSE) {
[13:21:03.296]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:03.296]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:03.296]     }
[13:21:03.296]     ...future.result <- base::tryCatch({
[13:21:03.296]         base::withCallingHandlers({
[13:21:03.296]             ...future.value <- base::withVisible(base::local({
[13:21:03.296]                 stop(structure(list(message = "boom"), class = c("MyError", 
[13:21:03.296]                   "error", "condition")))
[13:21:03.296]             }))
[13:21:03.296]             future::FutureResult(value = ...future.value$value, 
[13:21:03.296]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.296]                   ...future.rng), globalenv = if (FALSE) 
[13:21:03.296]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:03.296]                     ...future.globalenv.names))
[13:21:03.296]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:03.296]         }, condition = base::local({
[13:21:03.296]             c <- base::c
[13:21:03.296]             inherits <- base::inherits
[13:21:03.296]             invokeRestart <- base::invokeRestart
[13:21:03.296]             length <- base::length
[13:21:03.296]             list <- base::list
[13:21:03.296]             seq.int <- base::seq.int
[13:21:03.296]             signalCondition <- base::signalCondition
[13:21:03.296]             sys.calls <- base::sys.calls
[13:21:03.296]             `[[` <- base::`[[`
[13:21:03.296]             `+` <- base::`+`
[13:21:03.296]             `<<-` <- base::`<<-`
[13:21:03.296]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:03.296]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:03.296]                   3L)]
[13:21:03.296]             }
[13:21:03.296]             function(cond) {
[13:21:03.296]                 is_error <- inherits(cond, "error")
[13:21:03.296]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:03.296]                   NULL)
[13:21:03.296]                 if (is_error) {
[13:21:03.296]                   sessionInformation <- function() {
[13:21:03.296]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:03.296]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:03.296]                       search = base::search(), system = base::Sys.info())
[13:21:03.296]                   }
[13:21:03.296]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.296]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:03.296]                     cond$call), session = sessionInformation(), 
[13:21:03.296]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:03.296]                   signalCondition(cond)
[13:21:03.296]                 }
[13:21:03.296]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:03.296]                 "immediateCondition"))) {
[13:21:03.296]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:03.296]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.296]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:03.296]                   if (TRUE && !signal) {
[13:21:03.296]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.296]                     {
[13:21:03.296]                       inherits <- base::inherits
[13:21:03.296]                       invokeRestart <- base::invokeRestart
[13:21:03.296]                       is.null <- base::is.null
[13:21:03.296]                       muffled <- FALSE
[13:21:03.296]                       if (inherits(cond, "message")) {
[13:21:03.296]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.296]                         if (muffled) 
[13:21:03.296]                           invokeRestart("muffleMessage")
[13:21:03.296]                       }
[13:21:03.296]                       else if (inherits(cond, "warning")) {
[13:21:03.296]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.296]                         if (muffled) 
[13:21:03.296]                           invokeRestart("muffleWarning")
[13:21:03.296]                       }
[13:21:03.296]                       else if (inherits(cond, "condition")) {
[13:21:03.296]                         if (!is.null(pattern)) {
[13:21:03.296]                           computeRestarts <- base::computeRestarts
[13:21:03.296]                           grepl <- base::grepl
[13:21:03.296]                           restarts <- computeRestarts(cond)
[13:21:03.296]                           for (restart in restarts) {
[13:21:03.296]                             name <- restart$name
[13:21:03.296]                             if (is.null(name)) 
[13:21:03.296]                               next
[13:21:03.296]                             if (!grepl(pattern, name)) 
[13:21:03.296]                               next
[13:21:03.296]                             invokeRestart(restart)
[13:21:03.296]                             muffled <- TRUE
[13:21:03.296]                             break
[13:21:03.296]                           }
[13:21:03.296]                         }
[13:21:03.296]                       }
[13:21:03.296]                       invisible(muffled)
[13:21:03.296]                     }
[13:21:03.296]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.296]                   }
[13:21:03.296]                 }
[13:21:03.296]                 else {
[13:21:03.296]                   if (TRUE) {
[13:21:03.296]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.296]                     {
[13:21:03.296]                       inherits <- base::inherits
[13:21:03.296]                       invokeRestart <- base::invokeRestart
[13:21:03.296]                       is.null <- base::is.null
[13:21:03.296]                       muffled <- FALSE
[13:21:03.296]                       if (inherits(cond, "message")) {
[13:21:03.296]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.296]                         if (muffled) 
[13:21:03.296]                           invokeRestart("muffleMessage")
[13:21:03.296]                       }
[13:21:03.296]                       else if (inherits(cond, "warning")) {
[13:21:03.296]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.296]                         if (muffled) 
[13:21:03.296]                           invokeRestart("muffleWarning")
[13:21:03.296]                       }
[13:21:03.296]                       else if (inherits(cond, "condition")) {
[13:21:03.296]                         if (!is.null(pattern)) {
[13:21:03.296]                           computeRestarts <- base::computeRestarts
[13:21:03.296]                           grepl <- base::grepl
[13:21:03.296]                           restarts <- computeRestarts(cond)
[13:21:03.296]                           for (restart in restarts) {
[13:21:03.296]                             name <- restart$name
[13:21:03.296]                             if (is.null(name)) 
[13:21:03.296]                               next
[13:21:03.296]                             if (!grepl(pattern, name)) 
[13:21:03.296]                               next
[13:21:03.296]                             invokeRestart(restart)
[13:21:03.296]                             muffled <- TRUE
[13:21:03.296]                             break
[13:21:03.296]                           }
[13:21:03.296]                         }
[13:21:03.296]                       }
[13:21:03.296]                       invisible(muffled)
[13:21:03.296]                     }
[13:21:03.296]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.296]                   }
[13:21:03.296]                 }
[13:21:03.296]             }
[13:21:03.296]         }))
[13:21:03.296]     }, error = function(ex) {
[13:21:03.296]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:03.296]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.296]                 ...future.rng), started = ...future.startTime, 
[13:21:03.296]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:03.296]             version = "1.8"), class = "FutureResult")
[13:21:03.296]     }, finally = {
[13:21:03.296]         if (!identical(...future.workdir, getwd())) 
[13:21:03.296]             setwd(...future.workdir)
[13:21:03.296]         {
[13:21:03.296]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:03.296]                 ...future.oldOptions$nwarnings <- NULL
[13:21:03.296]             }
[13:21:03.296]             base::options(...future.oldOptions)
[13:21:03.296]             if (.Platform$OS.type == "windows") {
[13:21:03.296]                 old_names <- names(...future.oldEnvVars)
[13:21:03.296]                 envs <- base::Sys.getenv()
[13:21:03.296]                 names <- names(envs)
[13:21:03.296]                 common <- intersect(names, old_names)
[13:21:03.296]                 added <- setdiff(names, old_names)
[13:21:03.296]                 removed <- setdiff(old_names, names)
[13:21:03.296]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:03.296]                   envs[common]]
[13:21:03.296]                 NAMES <- toupper(changed)
[13:21:03.296]                 args <- list()
[13:21:03.296]                 for (kk in seq_along(NAMES)) {
[13:21:03.296]                   name <- changed[[kk]]
[13:21:03.296]                   NAME <- NAMES[[kk]]
[13:21:03.296]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.296]                     next
[13:21:03.296]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.296]                 }
[13:21:03.296]                 NAMES <- toupper(added)
[13:21:03.296]                 for (kk in seq_along(NAMES)) {
[13:21:03.296]                   name <- added[[kk]]
[13:21:03.296]                   NAME <- NAMES[[kk]]
[13:21:03.296]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.296]                     next
[13:21:03.296]                   args[[name]] <- ""
[13:21:03.296]                 }
[13:21:03.296]                 NAMES <- toupper(removed)
[13:21:03.296]                 for (kk in seq_along(NAMES)) {
[13:21:03.296]                   name <- removed[[kk]]
[13:21:03.296]                   NAME <- NAMES[[kk]]
[13:21:03.296]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.296]                     next
[13:21:03.296]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.296]                 }
[13:21:03.296]                 if (length(args) > 0) 
[13:21:03.296]                   base::do.call(base::Sys.setenv, args = args)
[13:21:03.296]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:03.296]             }
[13:21:03.296]             else {
[13:21:03.296]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:03.296]             }
[13:21:03.296]             {
[13:21:03.296]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:03.296]                   0L) {
[13:21:03.296]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:03.296]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:03.296]                   base::options(opts)
[13:21:03.296]                 }
[13:21:03.296]                 {
[13:21:03.296]                   {
[13:21:03.296]                     NULL
[13:21:03.296]                     RNGkind("Mersenne-Twister")
[13:21:03.296]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:03.296]                       inherits = FALSE)
[13:21:03.296]                   }
[13:21:03.296]                   options(future.plan = NULL)
[13:21:03.296]                   if (is.na(NA_character_)) 
[13:21:03.296]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.296]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:03.296]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:03.296]                     envir = parent.frame()) 
[13:21:03.296]                   {
[13:21:03.296]                     default_workers <- missing(workers)
[13:21:03.296]                     if (is.function(workers)) 
[13:21:03.296]                       workers <- workers()
[13:21:03.296]                     workers <- structure(as.integer(workers), 
[13:21:03.296]                       class = class(workers))
[13:21:03.296]                     stop_if_not(is.finite(workers), workers >= 
[13:21:03.296]                       1L)
[13:21:03.296]                     if ((workers == 1L && !inherits(workers, 
[13:21:03.296]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:03.296]                       if (default_workers) 
[13:21:03.296]                         supportsMulticore(warn = TRUE)
[13:21:03.296]                       return(sequential(..., envir = envir))
[13:21:03.296]                     }
[13:21:03.296]                     oopts <- options(mc.cores = workers)
[13:21:03.296]                     on.exit(options(oopts))
[13:21:03.296]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:03.296]                       envir = envir)
[13:21:03.296]                     if (!future$lazy) 
[13:21:03.296]                       future <- run(future)
[13:21:03.296]                     invisible(future)
[13:21:03.296]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:03.296]                 }
[13:21:03.296]             }
[13:21:03.296]         }
[13:21:03.296]     })
[13:21:03.296]     if (TRUE) {
[13:21:03.296]         base::sink(type = "output", split = FALSE)
[13:21:03.296]         if (TRUE) {
[13:21:03.296]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:03.296]         }
[13:21:03.296]         else {
[13:21:03.296]             ...future.result["stdout"] <- base::list(NULL)
[13:21:03.296]         }
[13:21:03.296]         base::close(...future.stdout)
[13:21:03.296]         ...future.stdout <- NULL
[13:21:03.296]     }
[13:21:03.296]     ...future.result$conditions <- ...future.conditions
[13:21:03.296]     ...future.result$finished <- base::Sys.time()
[13:21:03.296]     ...future.result
[13:21:03.296] }
[13:21:03.298] plan(): Setting new future strategy stack:
[13:21:03.298] List of future strategies:
[13:21:03.298] 1. sequential:
[13:21:03.298]    - args: function (..., envir = parent.frame())
[13:21:03.298]    - tweaked: FALSE
[13:21:03.298]    - call: NULL
[13:21:03.298] plan(): nbrOfWorkers() = 1
[13:21:03.299] plan(): Setting new future strategy stack:
[13:21:03.299] List of future strategies:
[13:21:03.299] 1. multicore:
[13:21:03.299]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:03.299]    - tweaked: FALSE
[13:21:03.299]    - call: plan(multicore)
[13:21:03.303] plan(): nbrOfWorkers() = 1
[13:21:03.303] SequentialFuture started (and completed)
[13:21:03.303] signalConditions() ...
[13:21:03.303]  - include = ‘immediateCondition’
[13:21:03.303]  - exclude = 
[13:21:03.303]  - resignal = FALSE
[13:21:03.303]  - Number of conditions: 1
[13:21:03.303] signalConditions() ... done
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 0 bytes of class ‘NULL’
Conditions captured: [n=1] ‘MyError’
Early signaling: FALSE
Owner process: 32f7abe8-d290-272e-8911-a8ce072c31c3
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:03.304] signalConditions() ...
[13:21:03.304]  - include = ‘immediateCondition’
[13:21:03.304]  - exclude = 
[13:21:03.304]  - resignal = FALSE
[13:21:03.304]  - Number of conditions: 1
[13:21:03.304] signalConditions() ... done
<MyError: boom>
[13:21:03.305] signalConditions() ...
[13:21:03.305]  - include = ‘immediateCondition’
[13:21:03.305]  - exclude = 
[13:21:03.305]  - resignal = FALSE
[13:21:03.305]  - Number of conditions: 1
[13:21:03.305] signalConditions() ... done
[13:21:03.305] Future state: ‘finished’
[13:21:03.305] signalConditions() ...
[13:21:03.305]  - include = ‘condition’
[13:21:03.306]  - exclude = ‘immediateCondition’
[13:21:03.306]  - resignal = TRUE
[13:21:03.306]  - Number of conditions: 1
[13:21:03.306]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[13:21:03.306] signalConditions() ... done
*** multicore(..., globals = TRUE) without globals
[13:21:03.309] getGlobalsAndPackages() ...
[13:21:03.309] Searching for globals...
[13:21:03.310] - globals found: [1] ‘{’
[13:21:03.310] Searching for globals ... DONE
[13:21:03.310] Resolving globals: FALSE
[13:21:03.310] 
[13:21:03.310] 
[13:21:03.310] getGlobalsAndPackages() ... DONE
[13:21:03.311] Packages needed by the future expression (n = 0): <none>
[13:21:03.311] Packages needed by future strategies (n = 0): <none>
[13:21:03.311] {
[13:21:03.311]     {
[13:21:03.311]         {
[13:21:03.311]             ...future.startTime <- base::Sys.time()
[13:21:03.311]             {
[13:21:03.311]                 {
[13:21:03.311]                   {
[13:21:03.311]                     base::local({
[13:21:03.311]                       has_future <- base::requireNamespace("future", 
[13:21:03.311]                         quietly = TRUE)
[13:21:03.311]                       if (has_future) {
[13:21:03.311]                         ns <- base::getNamespace("future")
[13:21:03.311]                         version <- ns[[".package"]][["version"]]
[13:21:03.311]                         if (is.null(version)) 
[13:21:03.311]                           version <- utils::packageVersion("future")
[13:21:03.311]                       }
[13:21:03.311]                       else {
[13:21:03.311]                         version <- NULL
[13:21:03.311]                       }
[13:21:03.311]                       if (!has_future || version < "1.8.0") {
[13:21:03.311]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:03.311]                           "", base::R.version$version.string), 
[13:21:03.311]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:03.311]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:03.311]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:03.311]                             "release", "version")], collapse = " "), 
[13:21:03.311]                           hostname = base::Sys.info()[["nodename"]])
[13:21:03.311]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:03.311]                           info)
[13:21:03.311]                         info <- base::paste(info, collapse = "; ")
[13:21:03.311]                         if (!has_future) {
[13:21:03.311]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:03.311]                             info)
[13:21:03.311]                         }
[13:21:03.311]                         else {
[13:21:03.311]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:03.311]                             info, version)
[13:21:03.311]                         }
[13:21:03.311]                         base::stop(msg)
[13:21:03.311]                       }
[13:21:03.311]                     })
[13:21:03.311]                   }
[13:21:03.311]                   options(future.plan = NULL)
[13:21:03.311]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.311]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:03.311]                 }
[13:21:03.311]                 ...future.workdir <- getwd()
[13:21:03.311]             }
[13:21:03.311]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:03.311]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:03.311]         }
[13:21:03.311]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:03.311]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:03.311]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:03.311]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:03.311]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:03.311]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:03.311]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:03.311]             base::names(...future.oldOptions))
[13:21:03.311]     }
[13:21:03.311]     if (FALSE) {
[13:21:03.311]     }
[13:21:03.311]     else {
[13:21:03.311]         if (TRUE) {
[13:21:03.311]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:03.311]                 open = "w")
[13:21:03.311]         }
[13:21:03.311]         else {
[13:21:03.311]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:03.311]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:03.311]         }
[13:21:03.311]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:03.311]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:03.311]             base::sink(type = "output", split = FALSE)
[13:21:03.311]             base::close(...future.stdout)
[13:21:03.311]         }, add = TRUE)
[13:21:03.311]     }
[13:21:03.311]     ...future.frame <- base::sys.nframe()
[13:21:03.311]     ...future.conditions <- base::list()
[13:21:03.311]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:03.311]     if (FALSE) {
[13:21:03.311]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:03.311]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:03.311]     }
[13:21:03.311]     ...future.result <- base::tryCatch({
[13:21:03.311]         base::withCallingHandlers({
[13:21:03.311]             ...future.value <- base::withVisible(base::local({
[13:21:03.311]                 42L
[13:21:03.311]             }))
[13:21:03.311]             future::FutureResult(value = ...future.value$value, 
[13:21:03.311]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.311]                   ...future.rng), globalenv = if (FALSE) 
[13:21:03.311]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:03.311]                     ...future.globalenv.names))
[13:21:03.311]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:03.311]         }, condition = base::local({
[13:21:03.311]             c <- base::c
[13:21:03.311]             inherits <- base::inherits
[13:21:03.311]             invokeRestart <- base::invokeRestart
[13:21:03.311]             length <- base::length
[13:21:03.311]             list <- base::list
[13:21:03.311]             seq.int <- base::seq.int
[13:21:03.311]             signalCondition <- base::signalCondition
[13:21:03.311]             sys.calls <- base::sys.calls
[13:21:03.311]             `[[` <- base::`[[`
[13:21:03.311]             `+` <- base::`+`
[13:21:03.311]             `<<-` <- base::`<<-`
[13:21:03.311]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:03.311]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:03.311]                   3L)]
[13:21:03.311]             }
[13:21:03.311]             function(cond) {
[13:21:03.311]                 is_error <- inherits(cond, "error")
[13:21:03.311]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:03.311]                   NULL)
[13:21:03.311]                 if (is_error) {
[13:21:03.311]                   sessionInformation <- function() {
[13:21:03.311]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:03.311]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:03.311]                       search = base::search(), system = base::Sys.info())
[13:21:03.311]                   }
[13:21:03.311]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.311]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:03.311]                     cond$call), session = sessionInformation(), 
[13:21:03.311]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:03.311]                   signalCondition(cond)
[13:21:03.311]                 }
[13:21:03.311]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:03.311]                 "immediateCondition"))) {
[13:21:03.311]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:03.311]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.311]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:03.311]                   if (TRUE && !signal) {
[13:21:03.311]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.311]                     {
[13:21:03.311]                       inherits <- base::inherits
[13:21:03.311]                       invokeRestart <- base::invokeRestart
[13:21:03.311]                       is.null <- base::is.null
[13:21:03.311]                       muffled <- FALSE
[13:21:03.311]                       if (inherits(cond, "message")) {
[13:21:03.311]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.311]                         if (muffled) 
[13:21:03.311]                           invokeRestart("muffleMessage")
[13:21:03.311]                       }
[13:21:03.311]                       else if (inherits(cond, "warning")) {
[13:21:03.311]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.311]                         if (muffled) 
[13:21:03.311]                           invokeRestart("muffleWarning")
[13:21:03.311]                       }
[13:21:03.311]                       else if (inherits(cond, "condition")) {
[13:21:03.311]                         if (!is.null(pattern)) {
[13:21:03.311]                           computeRestarts <- base::computeRestarts
[13:21:03.311]                           grepl <- base::grepl
[13:21:03.311]                           restarts <- computeRestarts(cond)
[13:21:03.311]                           for (restart in restarts) {
[13:21:03.311]                             name <- restart$name
[13:21:03.311]                             if (is.null(name)) 
[13:21:03.311]                               next
[13:21:03.311]                             if (!grepl(pattern, name)) 
[13:21:03.311]                               next
[13:21:03.311]                             invokeRestart(restart)
[13:21:03.311]                             muffled <- TRUE
[13:21:03.311]                             break
[13:21:03.311]                           }
[13:21:03.311]                         }
[13:21:03.311]                       }
[13:21:03.311]                       invisible(muffled)
[13:21:03.311]                     }
[13:21:03.311]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.311]                   }
[13:21:03.311]                 }
[13:21:03.311]                 else {
[13:21:03.311]                   if (TRUE) {
[13:21:03.311]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.311]                     {
[13:21:03.311]                       inherits <- base::inherits
[13:21:03.311]                       invokeRestart <- base::invokeRestart
[13:21:03.311]                       is.null <- base::is.null
[13:21:03.311]                       muffled <- FALSE
[13:21:03.311]                       if (inherits(cond, "message")) {
[13:21:03.311]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.311]                         if (muffled) 
[13:21:03.311]                           invokeRestart("muffleMessage")
[13:21:03.311]                       }
[13:21:03.311]                       else if (inherits(cond, "warning")) {
[13:21:03.311]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.311]                         if (muffled) 
[13:21:03.311]                           invokeRestart("muffleWarning")
[13:21:03.311]                       }
[13:21:03.311]                       else if (inherits(cond, "condition")) {
[13:21:03.311]                         if (!is.null(pattern)) {
[13:21:03.311]                           computeRestarts <- base::computeRestarts
[13:21:03.311]                           grepl <- base::grepl
[13:21:03.311]                           restarts <- computeRestarts(cond)
[13:21:03.311]                           for (restart in restarts) {
[13:21:03.311]                             name <- restart$name
[13:21:03.311]                             if (is.null(name)) 
[13:21:03.311]                               next
[13:21:03.311]                             if (!grepl(pattern, name)) 
[13:21:03.311]                               next
[13:21:03.311]                             invokeRestart(restart)
[13:21:03.311]                             muffled <- TRUE
[13:21:03.311]                             break
[13:21:03.311]                           }
[13:21:03.311]                         }
[13:21:03.311]                       }
[13:21:03.311]                       invisible(muffled)
[13:21:03.311]                     }
[13:21:03.311]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.311]                   }
[13:21:03.311]                 }
[13:21:03.311]             }
[13:21:03.311]         }))
[13:21:03.311]     }, error = function(ex) {
[13:21:03.311]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:03.311]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.311]                 ...future.rng), started = ...future.startTime, 
[13:21:03.311]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:03.311]             version = "1.8"), class = "FutureResult")
[13:21:03.311]     }, finally = {
[13:21:03.311]         if (!identical(...future.workdir, getwd())) 
[13:21:03.311]             setwd(...future.workdir)
[13:21:03.311]         {
[13:21:03.311]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:03.311]                 ...future.oldOptions$nwarnings <- NULL
[13:21:03.311]             }
[13:21:03.311]             base::options(...future.oldOptions)
[13:21:03.311]             if (.Platform$OS.type == "windows") {
[13:21:03.311]                 old_names <- names(...future.oldEnvVars)
[13:21:03.311]                 envs <- base::Sys.getenv()
[13:21:03.311]                 names <- names(envs)
[13:21:03.311]                 common <- intersect(names, old_names)
[13:21:03.311]                 added <- setdiff(names, old_names)
[13:21:03.311]                 removed <- setdiff(old_names, names)
[13:21:03.311]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:03.311]                   envs[common]]
[13:21:03.311]                 NAMES <- toupper(changed)
[13:21:03.311]                 args <- list()
[13:21:03.311]                 for (kk in seq_along(NAMES)) {
[13:21:03.311]                   name <- changed[[kk]]
[13:21:03.311]                   NAME <- NAMES[[kk]]
[13:21:03.311]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.311]                     next
[13:21:03.311]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.311]                 }
[13:21:03.311]                 NAMES <- toupper(added)
[13:21:03.311]                 for (kk in seq_along(NAMES)) {
[13:21:03.311]                   name <- added[[kk]]
[13:21:03.311]                   NAME <- NAMES[[kk]]
[13:21:03.311]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.311]                     next
[13:21:03.311]                   args[[name]] <- ""
[13:21:03.311]                 }
[13:21:03.311]                 NAMES <- toupper(removed)
[13:21:03.311]                 for (kk in seq_along(NAMES)) {
[13:21:03.311]                   name <- removed[[kk]]
[13:21:03.311]                   NAME <- NAMES[[kk]]
[13:21:03.311]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.311]                     next
[13:21:03.311]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.311]                 }
[13:21:03.311]                 if (length(args) > 0) 
[13:21:03.311]                   base::do.call(base::Sys.setenv, args = args)
[13:21:03.311]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:03.311]             }
[13:21:03.311]             else {
[13:21:03.311]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:03.311]             }
[13:21:03.311]             {
[13:21:03.311]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:03.311]                   0L) {
[13:21:03.311]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:03.311]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:03.311]                   base::options(opts)
[13:21:03.311]                 }
[13:21:03.311]                 {
[13:21:03.311]                   {
[13:21:03.311]                     NULL
[13:21:03.311]                     RNGkind("Mersenne-Twister")
[13:21:03.311]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:03.311]                       inherits = FALSE)
[13:21:03.311]                   }
[13:21:03.311]                   options(future.plan = NULL)
[13:21:03.311]                   if (is.na(NA_character_)) 
[13:21:03.311]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.311]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:03.311]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:03.311]                     envir = parent.frame()) 
[13:21:03.311]                   {
[13:21:03.311]                     default_workers <- missing(workers)
[13:21:03.311]                     if (is.function(workers)) 
[13:21:03.311]                       workers <- workers()
[13:21:03.311]                     workers <- structure(as.integer(workers), 
[13:21:03.311]                       class = class(workers))
[13:21:03.311]                     stop_if_not(is.finite(workers), workers >= 
[13:21:03.311]                       1L)
[13:21:03.311]                     if ((workers == 1L && !inherits(workers, 
[13:21:03.311]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:03.311]                       if (default_workers) 
[13:21:03.311]                         supportsMulticore(warn = TRUE)
[13:21:03.311]                       return(sequential(..., envir = envir))
[13:21:03.311]                     }
[13:21:03.311]                     oopts <- options(mc.cores = workers)
[13:21:03.311]                     on.exit(options(oopts))
[13:21:03.311]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:03.311]                       envir = envir)
[13:21:03.311]                     if (!future$lazy) 
[13:21:03.311]                       future <- run(future)
[13:21:03.311]                     invisible(future)
[13:21:03.311]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:03.311]                 }
[13:21:03.311]             }
[13:21:03.311]         }
[13:21:03.311]     })
[13:21:03.311]     if (TRUE) {
[13:21:03.311]         base::sink(type = "output", split = FALSE)
[13:21:03.311]         if (TRUE) {
[13:21:03.311]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:03.311]         }
[13:21:03.311]         else {
[13:21:03.311]             ...future.result["stdout"] <- base::list(NULL)
[13:21:03.311]         }
[13:21:03.311]         base::close(...future.stdout)
[13:21:03.311]         ...future.stdout <- NULL
[13:21:03.311]     }
[13:21:03.311]     ...future.result$conditions <- ...future.conditions
[13:21:03.311]     ...future.result$finished <- base::Sys.time()
[13:21:03.311]     ...future.result
[13:21:03.311] }
[13:21:03.313] plan(): Setting new future strategy stack:
[13:21:03.313] List of future strategies:
[13:21:03.313] 1. sequential:
[13:21:03.313]    - args: function (..., envir = parent.frame())
[13:21:03.313]    - tweaked: FALSE
[13:21:03.313]    - call: NULL
[13:21:03.313] plan(): nbrOfWorkers() = 1
[13:21:03.314] plan(): Setting new future strategy stack:
[13:21:03.314] List of future strategies:
[13:21:03.314] 1. multicore:
[13:21:03.314]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:03.314]    - tweaked: FALSE
[13:21:03.314]    - call: plan(multicore)
[13:21:03.318] plan(): nbrOfWorkers() = 1
[13:21:03.318] SequentialFuture started (and completed)
[13:21:03.318] resolved() for ‘SequentialFuture’ ...
[13:21:03.318] - state: ‘finished’
[13:21:03.318] - run: TRUE
[13:21:03.318] - result: ‘FutureResult’
[13:21:03.318] resolved() for ‘SequentialFuture’ ... done
[1] TRUE
[1] 42
*** multicore(..., globals = TRUE) with globals
[13:21:03.322] getGlobalsAndPackages() ...
[13:21:03.322] Searching for globals...
[13:21:03.325] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘a’
[13:21:03.326] Searching for globals ... DONE
[13:21:03.326] Resolving globals: FALSE
[13:21:03.326] The total size of the 1 globals is 56 bytes (56 bytes)
[13:21:03.327] The total size of the 1 globals exported for future expression (‘{; b <- 3; c <- 2; a * b * c; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:21:03.327] - globals: [1] ‘a’
[13:21:03.327] 
[13:21:03.327] getGlobalsAndPackages() ... DONE
[13:21:03.327] Packages needed by the future expression (n = 0): <none>
[13:21:03.327] Packages needed by future strategies (n = 0): <none>
[13:21:03.328] {
[13:21:03.328]     {
[13:21:03.328]         {
[13:21:03.328]             ...future.startTime <- base::Sys.time()
[13:21:03.328]             {
[13:21:03.328]                 {
[13:21:03.328]                   {
[13:21:03.328]                     base::local({
[13:21:03.328]                       has_future <- base::requireNamespace("future", 
[13:21:03.328]                         quietly = TRUE)
[13:21:03.328]                       if (has_future) {
[13:21:03.328]                         ns <- base::getNamespace("future")
[13:21:03.328]                         version <- ns[[".package"]][["version"]]
[13:21:03.328]                         if (is.null(version)) 
[13:21:03.328]                           version <- utils::packageVersion("future")
[13:21:03.328]                       }
[13:21:03.328]                       else {
[13:21:03.328]                         version <- NULL
[13:21:03.328]                       }
[13:21:03.328]                       if (!has_future || version < "1.8.0") {
[13:21:03.328]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:03.328]                           "", base::R.version$version.string), 
[13:21:03.328]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:03.328]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:03.328]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:03.328]                             "release", "version")], collapse = " "), 
[13:21:03.328]                           hostname = base::Sys.info()[["nodename"]])
[13:21:03.328]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:03.328]                           info)
[13:21:03.328]                         info <- base::paste(info, collapse = "; ")
[13:21:03.328]                         if (!has_future) {
[13:21:03.328]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:03.328]                             info)
[13:21:03.328]                         }
[13:21:03.328]                         else {
[13:21:03.328]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:03.328]                             info, version)
[13:21:03.328]                         }
[13:21:03.328]                         base::stop(msg)
[13:21:03.328]                       }
[13:21:03.328]                     })
[13:21:03.328]                   }
[13:21:03.328]                   options(future.plan = NULL)
[13:21:03.328]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.328]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:03.328]                 }
[13:21:03.328]                 ...future.workdir <- getwd()
[13:21:03.328]             }
[13:21:03.328]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:03.328]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:03.328]         }
[13:21:03.328]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:03.328]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:03.328]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:03.328]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:03.328]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:03.328]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:03.328]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:03.328]             base::names(...future.oldOptions))
[13:21:03.328]     }
[13:21:03.328]     if (FALSE) {
[13:21:03.328]     }
[13:21:03.328]     else {
[13:21:03.328]         if (TRUE) {
[13:21:03.328]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:03.328]                 open = "w")
[13:21:03.328]         }
[13:21:03.328]         else {
[13:21:03.328]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:03.328]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:03.328]         }
[13:21:03.328]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:03.328]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:03.328]             base::sink(type = "output", split = FALSE)
[13:21:03.328]             base::close(...future.stdout)
[13:21:03.328]         }, add = TRUE)
[13:21:03.328]     }
[13:21:03.328]     ...future.frame <- base::sys.nframe()
[13:21:03.328]     ...future.conditions <- base::list()
[13:21:03.328]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:03.328]     if (FALSE) {
[13:21:03.328]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:03.328]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:03.328]     }
[13:21:03.328]     ...future.result <- base::tryCatch({
[13:21:03.328]         base::withCallingHandlers({
[13:21:03.328]             ...future.value <- base::withVisible(base::local({
[13:21:03.328]                 b <- 3
[13:21:03.328]                 c <- 2
[13:21:03.328]                 a * b * c
[13:21:03.328]             }))
[13:21:03.328]             future::FutureResult(value = ...future.value$value, 
[13:21:03.328]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.328]                   ...future.rng), globalenv = if (FALSE) 
[13:21:03.328]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:03.328]                     ...future.globalenv.names))
[13:21:03.328]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:03.328]         }, condition = base::local({
[13:21:03.328]             c <- base::c
[13:21:03.328]             inherits <- base::inherits
[13:21:03.328]             invokeRestart <- base::invokeRestart
[13:21:03.328]             length <- base::length
[13:21:03.328]             list <- base::list
[13:21:03.328]             seq.int <- base::seq.int
[13:21:03.328]             signalCondition <- base::signalCondition
[13:21:03.328]             sys.calls <- base::sys.calls
[13:21:03.328]             `[[` <- base::`[[`
[13:21:03.328]             `+` <- base::`+`
[13:21:03.328]             `<<-` <- base::`<<-`
[13:21:03.328]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:03.328]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:03.328]                   3L)]
[13:21:03.328]             }
[13:21:03.328]             function(cond) {
[13:21:03.328]                 is_error <- inherits(cond, "error")
[13:21:03.328]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:03.328]                   NULL)
[13:21:03.328]                 if (is_error) {
[13:21:03.328]                   sessionInformation <- function() {
[13:21:03.328]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:03.328]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:03.328]                       search = base::search(), system = base::Sys.info())
[13:21:03.328]                   }
[13:21:03.328]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.328]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:03.328]                     cond$call), session = sessionInformation(), 
[13:21:03.328]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:03.328]                   signalCondition(cond)
[13:21:03.328]                 }
[13:21:03.328]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:03.328]                 "immediateCondition"))) {
[13:21:03.328]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:03.328]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.328]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:03.328]                   if (TRUE && !signal) {
[13:21:03.328]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.328]                     {
[13:21:03.328]                       inherits <- base::inherits
[13:21:03.328]                       invokeRestart <- base::invokeRestart
[13:21:03.328]                       is.null <- base::is.null
[13:21:03.328]                       muffled <- FALSE
[13:21:03.328]                       if (inherits(cond, "message")) {
[13:21:03.328]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.328]                         if (muffled) 
[13:21:03.328]                           invokeRestart("muffleMessage")
[13:21:03.328]                       }
[13:21:03.328]                       else if (inherits(cond, "warning")) {
[13:21:03.328]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.328]                         if (muffled) 
[13:21:03.328]                           invokeRestart("muffleWarning")
[13:21:03.328]                       }
[13:21:03.328]                       else if (inherits(cond, "condition")) {
[13:21:03.328]                         if (!is.null(pattern)) {
[13:21:03.328]                           computeRestarts <- base::computeRestarts
[13:21:03.328]                           grepl <- base::grepl
[13:21:03.328]                           restarts <- computeRestarts(cond)
[13:21:03.328]                           for (restart in restarts) {
[13:21:03.328]                             name <- restart$name
[13:21:03.328]                             if (is.null(name)) 
[13:21:03.328]                               next
[13:21:03.328]                             if (!grepl(pattern, name)) 
[13:21:03.328]                               next
[13:21:03.328]                             invokeRestart(restart)
[13:21:03.328]                             muffled <- TRUE
[13:21:03.328]                             break
[13:21:03.328]                           }
[13:21:03.328]                         }
[13:21:03.328]                       }
[13:21:03.328]                       invisible(muffled)
[13:21:03.328]                     }
[13:21:03.328]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.328]                   }
[13:21:03.328]                 }
[13:21:03.328]                 else {
[13:21:03.328]                   if (TRUE) {
[13:21:03.328]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.328]                     {
[13:21:03.328]                       inherits <- base::inherits
[13:21:03.328]                       invokeRestart <- base::invokeRestart
[13:21:03.328]                       is.null <- base::is.null
[13:21:03.328]                       muffled <- FALSE
[13:21:03.328]                       if (inherits(cond, "message")) {
[13:21:03.328]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.328]                         if (muffled) 
[13:21:03.328]                           invokeRestart("muffleMessage")
[13:21:03.328]                       }
[13:21:03.328]                       else if (inherits(cond, "warning")) {
[13:21:03.328]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.328]                         if (muffled) 
[13:21:03.328]                           invokeRestart("muffleWarning")
[13:21:03.328]                       }
[13:21:03.328]                       else if (inherits(cond, "condition")) {
[13:21:03.328]                         if (!is.null(pattern)) {
[13:21:03.328]                           computeRestarts <- base::computeRestarts
[13:21:03.328]                           grepl <- base::grepl
[13:21:03.328]                           restarts <- computeRestarts(cond)
[13:21:03.328]                           for (restart in restarts) {
[13:21:03.328]                             name <- restart$name
[13:21:03.328]                             if (is.null(name)) 
[13:21:03.328]                               next
[13:21:03.328]                             if (!grepl(pattern, name)) 
[13:21:03.328]                               next
[13:21:03.328]                             invokeRestart(restart)
[13:21:03.328]                             muffled <- TRUE
[13:21:03.328]                             break
[13:21:03.328]                           }
[13:21:03.328]                         }
[13:21:03.328]                       }
[13:21:03.328]                       invisible(muffled)
[13:21:03.328]                     }
[13:21:03.328]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.328]                   }
[13:21:03.328]                 }
[13:21:03.328]             }
[13:21:03.328]         }))
[13:21:03.328]     }, error = function(ex) {
[13:21:03.328]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:03.328]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.328]                 ...future.rng), started = ...future.startTime, 
[13:21:03.328]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:03.328]             version = "1.8"), class = "FutureResult")
[13:21:03.328]     }, finally = {
[13:21:03.328]         if (!identical(...future.workdir, getwd())) 
[13:21:03.328]             setwd(...future.workdir)
[13:21:03.328]         {
[13:21:03.328]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:03.328]                 ...future.oldOptions$nwarnings <- NULL
[13:21:03.328]             }
[13:21:03.328]             base::options(...future.oldOptions)
[13:21:03.328]             if (.Platform$OS.type == "windows") {
[13:21:03.328]                 old_names <- names(...future.oldEnvVars)
[13:21:03.328]                 envs <- base::Sys.getenv()
[13:21:03.328]                 names <- names(envs)
[13:21:03.328]                 common <- intersect(names, old_names)
[13:21:03.328]                 added <- setdiff(names, old_names)
[13:21:03.328]                 removed <- setdiff(old_names, names)
[13:21:03.328]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:03.328]                   envs[common]]
[13:21:03.328]                 NAMES <- toupper(changed)
[13:21:03.328]                 args <- list()
[13:21:03.328]                 for (kk in seq_along(NAMES)) {
[13:21:03.328]                   name <- changed[[kk]]
[13:21:03.328]                   NAME <- NAMES[[kk]]
[13:21:03.328]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.328]                     next
[13:21:03.328]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.328]                 }
[13:21:03.328]                 NAMES <- toupper(added)
[13:21:03.328]                 for (kk in seq_along(NAMES)) {
[13:21:03.328]                   name <- added[[kk]]
[13:21:03.328]                   NAME <- NAMES[[kk]]
[13:21:03.328]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.328]                     next
[13:21:03.328]                   args[[name]] <- ""
[13:21:03.328]                 }
[13:21:03.328]                 NAMES <- toupper(removed)
[13:21:03.328]                 for (kk in seq_along(NAMES)) {
[13:21:03.328]                   name <- removed[[kk]]
[13:21:03.328]                   NAME <- NAMES[[kk]]
[13:21:03.328]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.328]                     next
[13:21:03.328]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.328]                 }
[13:21:03.328]                 if (length(args) > 0) 
[13:21:03.328]                   base::do.call(base::Sys.setenv, args = args)
[13:21:03.328]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:03.328]             }
[13:21:03.328]             else {
[13:21:03.328]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:03.328]             }
[13:21:03.328]             {
[13:21:03.328]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:03.328]                   0L) {
[13:21:03.328]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:03.328]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:03.328]                   base::options(opts)
[13:21:03.328]                 }
[13:21:03.328]                 {
[13:21:03.328]                   {
[13:21:03.328]                     NULL
[13:21:03.328]                     RNGkind("Mersenne-Twister")
[13:21:03.328]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:03.328]                       inherits = FALSE)
[13:21:03.328]                   }
[13:21:03.328]                   options(future.plan = NULL)
[13:21:03.328]                   if (is.na(NA_character_)) 
[13:21:03.328]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.328]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:03.328]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:03.328]                     envir = parent.frame()) 
[13:21:03.328]                   {
[13:21:03.328]                     default_workers <- missing(workers)
[13:21:03.328]                     if (is.function(workers)) 
[13:21:03.328]                       workers <- workers()
[13:21:03.328]                     workers <- structure(as.integer(workers), 
[13:21:03.328]                       class = class(workers))
[13:21:03.328]                     stop_if_not(is.finite(workers), workers >= 
[13:21:03.328]                       1L)
[13:21:03.328]                     if ((workers == 1L && !inherits(workers, 
[13:21:03.328]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:03.328]                       if (default_workers) 
[13:21:03.328]                         supportsMulticore(warn = TRUE)
[13:21:03.328]                       return(sequential(..., envir = envir))
[13:21:03.328]                     }
[13:21:03.328]                     oopts <- options(mc.cores = workers)
[13:21:03.328]                     on.exit(options(oopts))
[13:21:03.328]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:03.328]                       envir = envir)
[13:21:03.328]                     if (!future$lazy) 
[13:21:03.328]                       future <- run(future)
[13:21:03.328]                     invisible(future)
[13:21:03.328]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:03.328]                 }
[13:21:03.328]             }
[13:21:03.328]         }
[13:21:03.328]     })
[13:21:03.328]     if (TRUE) {
[13:21:03.328]         base::sink(type = "output", split = FALSE)
[13:21:03.328]         if (TRUE) {
[13:21:03.328]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:03.328]         }
[13:21:03.328]         else {
[13:21:03.328]             ...future.result["stdout"] <- base::list(NULL)
[13:21:03.328]         }
[13:21:03.328]         base::close(...future.stdout)
[13:21:03.328]         ...future.stdout <- NULL
[13:21:03.328]     }
[13:21:03.328]     ...future.result$conditions <- ...future.conditions
[13:21:03.328]     ...future.result$finished <- base::Sys.time()
[13:21:03.328]     ...future.result
[13:21:03.328] }
[13:21:03.330] assign_globals() ...
[13:21:03.330] List of 1
[13:21:03.330]  $ a: num 0
[13:21:03.330]  - attr(*, "where")=List of 1
[13:21:03.330]   ..$ a:<environment: R_EmptyEnv> 
[13:21:03.330]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:03.330]  - attr(*, "resolved")= logi FALSE
[13:21:03.330]  - attr(*, "total_size")= num 56
[13:21:03.334] - copied ‘a’ to environment
[13:21:03.334] assign_globals() ... done
[13:21:03.334] plan(): Setting new future strategy stack:
[13:21:03.335] List of future strategies:
[13:21:03.335] 1. sequential:
[13:21:03.335]    - args: function (..., envir = parent.frame())
[13:21:03.335]    - tweaked: FALSE
[13:21:03.335]    - call: NULL
[13:21:03.335] plan(): nbrOfWorkers() = 1
[13:21:03.336] plan(): Setting new future strategy stack:
[13:21:03.336] List of future strategies:
[13:21:03.336] 1. multicore:
[13:21:03.336]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:03.336]    - tweaked: FALSE
[13:21:03.336]    - call: plan(multicore)
[13:21:03.339] plan(): nbrOfWorkers() = 1
[13:21:03.339] SequentialFuture started (and completed)
SequentialFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: 1 objects totaling 56 bytes (numeric ‘a’ of 56 bytes)
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 56 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: 32f7abe8-d290-272e-8911-a8ce072c31c3
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[1] 0
*** multicore(..., globals = TRUE) with globals and blocking
 - Creating multicore future #1 ...
[13:21:03.343] getGlobalsAndPackages() ...
[13:21:03.343] Searching for globals...
[13:21:03.344] - globals found: [2] ‘{’, ‘ii’
[13:21:03.344] Searching for globals ... DONE
[13:21:03.344] Resolving globals: FALSE
[13:21:03.345] The total size of the 1 globals is 56 bytes (56 bytes)
[13:21:03.345] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:21:03.345] - globals: [1] ‘ii’
[13:21:03.345] 
[13:21:03.345] getGlobalsAndPackages() ... DONE
[13:21:03.346] Packages needed by the future expression (n = 0): <none>
[13:21:03.346] Packages needed by future strategies (n = 0): <none>
[13:21:03.346] {
[13:21:03.346]     {
[13:21:03.346]         {
[13:21:03.346]             ...future.startTime <- base::Sys.time()
[13:21:03.346]             {
[13:21:03.346]                 {
[13:21:03.346]                   {
[13:21:03.346]                     base::local({
[13:21:03.346]                       has_future <- base::requireNamespace("future", 
[13:21:03.346]                         quietly = TRUE)
[13:21:03.346]                       if (has_future) {
[13:21:03.346]                         ns <- base::getNamespace("future")
[13:21:03.346]                         version <- ns[[".package"]][["version"]]
[13:21:03.346]                         if (is.null(version)) 
[13:21:03.346]                           version <- utils::packageVersion("future")
[13:21:03.346]                       }
[13:21:03.346]                       else {
[13:21:03.346]                         version <- NULL
[13:21:03.346]                       }
[13:21:03.346]                       if (!has_future || version < "1.8.0") {
[13:21:03.346]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:03.346]                           "", base::R.version$version.string), 
[13:21:03.346]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:03.346]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:03.346]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:03.346]                             "release", "version")], collapse = " "), 
[13:21:03.346]                           hostname = base::Sys.info()[["nodename"]])
[13:21:03.346]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:03.346]                           info)
[13:21:03.346]                         info <- base::paste(info, collapse = "; ")
[13:21:03.346]                         if (!has_future) {
[13:21:03.346]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:03.346]                             info)
[13:21:03.346]                         }
[13:21:03.346]                         else {
[13:21:03.346]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:03.346]                             info, version)
[13:21:03.346]                         }
[13:21:03.346]                         base::stop(msg)
[13:21:03.346]                       }
[13:21:03.346]                     })
[13:21:03.346]                   }
[13:21:03.346]                   options(future.plan = NULL)
[13:21:03.346]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.346]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:03.346]                 }
[13:21:03.346]                 ...future.workdir <- getwd()
[13:21:03.346]             }
[13:21:03.346]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:03.346]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:03.346]         }
[13:21:03.346]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:03.346]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:03.346]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:03.346]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:03.346]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:03.346]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:03.346]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:03.346]             base::names(...future.oldOptions))
[13:21:03.346]     }
[13:21:03.346]     if (FALSE) {
[13:21:03.346]     }
[13:21:03.346]     else {
[13:21:03.346]         if (TRUE) {
[13:21:03.346]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:03.346]                 open = "w")
[13:21:03.346]         }
[13:21:03.346]         else {
[13:21:03.346]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:03.346]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:03.346]         }
[13:21:03.346]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:03.346]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:03.346]             base::sink(type = "output", split = FALSE)
[13:21:03.346]             base::close(...future.stdout)
[13:21:03.346]         }, add = TRUE)
[13:21:03.346]     }
[13:21:03.346]     ...future.frame <- base::sys.nframe()
[13:21:03.346]     ...future.conditions <- base::list()
[13:21:03.346]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:03.346]     if (FALSE) {
[13:21:03.346]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:03.346]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:03.346]     }
[13:21:03.346]     ...future.result <- base::tryCatch({
[13:21:03.346]         base::withCallingHandlers({
[13:21:03.346]             ...future.value <- base::withVisible(base::local({
[13:21:03.346]                 ii
[13:21:03.346]             }))
[13:21:03.346]             future::FutureResult(value = ...future.value$value, 
[13:21:03.346]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.346]                   ...future.rng), globalenv = if (FALSE) 
[13:21:03.346]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:03.346]                     ...future.globalenv.names))
[13:21:03.346]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:03.346]         }, condition = base::local({
[13:21:03.346]             c <- base::c
[13:21:03.346]             inherits <- base::inherits
[13:21:03.346]             invokeRestart <- base::invokeRestart
[13:21:03.346]             length <- base::length
[13:21:03.346]             list <- base::list
[13:21:03.346]             seq.int <- base::seq.int
[13:21:03.346]             signalCondition <- base::signalCondition
[13:21:03.346]             sys.calls <- base::sys.calls
[13:21:03.346]             `[[` <- base::`[[`
[13:21:03.346]             `+` <- base::`+`
[13:21:03.346]             `<<-` <- base::`<<-`
[13:21:03.346]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:03.346]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:03.346]                   3L)]
[13:21:03.346]             }
[13:21:03.346]             function(cond) {
[13:21:03.346]                 is_error <- inherits(cond, "error")
[13:21:03.346]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:03.346]                   NULL)
[13:21:03.346]                 if (is_error) {
[13:21:03.346]                   sessionInformation <- function() {
[13:21:03.346]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:03.346]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:03.346]                       search = base::search(), system = base::Sys.info())
[13:21:03.346]                   }
[13:21:03.346]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.346]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:03.346]                     cond$call), session = sessionInformation(), 
[13:21:03.346]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:03.346]                   signalCondition(cond)
[13:21:03.346]                 }
[13:21:03.346]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:03.346]                 "immediateCondition"))) {
[13:21:03.346]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:03.346]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.346]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:03.346]                   if (TRUE && !signal) {
[13:21:03.346]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.346]                     {
[13:21:03.346]                       inherits <- base::inherits
[13:21:03.346]                       invokeRestart <- base::invokeRestart
[13:21:03.346]                       is.null <- base::is.null
[13:21:03.346]                       muffled <- FALSE
[13:21:03.346]                       if (inherits(cond, "message")) {
[13:21:03.346]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.346]                         if (muffled) 
[13:21:03.346]                           invokeRestart("muffleMessage")
[13:21:03.346]                       }
[13:21:03.346]                       else if (inherits(cond, "warning")) {
[13:21:03.346]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.346]                         if (muffled) 
[13:21:03.346]                           invokeRestart("muffleWarning")
[13:21:03.346]                       }
[13:21:03.346]                       else if (inherits(cond, "condition")) {
[13:21:03.346]                         if (!is.null(pattern)) {
[13:21:03.346]                           computeRestarts <- base::computeRestarts
[13:21:03.346]                           grepl <- base::grepl
[13:21:03.346]                           restarts <- computeRestarts(cond)
[13:21:03.346]                           for (restart in restarts) {
[13:21:03.346]                             name <- restart$name
[13:21:03.346]                             if (is.null(name)) 
[13:21:03.346]                               next
[13:21:03.346]                             if (!grepl(pattern, name)) 
[13:21:03.346]                               next
[13:21:03.346]                             invokeRestart(restart)
[13:21:03.346]                             muffled <- TRUE
[13:21:03.346]                             break
[13:21:03.346]                           }
[13:21:03.346]                         }
[13:21:03.346]                       }
[13:21:03.346]                       invisible(muffled)
[13:21:03.346]                     }
[13:21:03.346]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.346]                   }
[13:21:03.346]                 }
[13:21:03.346]                 else {
[13:21:03.346]                   if (TRUE) {
[13:21:03.346]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.346]                     {
[13:21:03.346]                       inherits <- base::inherits
[13:21:03.346]                       invokeRestart <- base::invokeRestart
[13:21:03.346]                       is.null <- base::is.null
[13:21:03.346]                       muffled <- FALSE
[13:21:03.346]                       if (inherits(cond, "message")) {
[13:21:03.346]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.346]                         if (muffled) 
[13:21:03.346]                           invokeRestart("muffleMessage")
[13:21:03.346]                       }
[13:21:03.346]                       else if (inherits(cond, "warning")) {
[13:21:03.346]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.346]                         if (muffled) 
[13:21:03.346]                           invokeRestart("muffleWarning")
[13:21:03.346]                       }
[13:21:03.346]                       else if (inherits(cond, "condition")) {
[13:21:03.346]                         if (!is.null(pattern)) {
[13:21:03.346]                           computeRestarts <- base::computeRestarts
[13:21:03.346]                           grepl <- base::grepl
[13:21:03.346]                           restarts <- computeRestarts(cond)
[13:21:03.346]                           for (restart in restarts) {
[13:21:03.346]                             name <- restart$name
[13:21:03.346]                             if (is.null(name)) 
[13:21:03.346]                               next
[13:21:03.346]                             if (!grepl(pattern, name)) 
[13:21:03.346]                               next
[13:21:03.346]                             invokeRestart(restart)
[13:21:03.346]                             muffled <- TRUE
[13:21:03.346]                             break
[13:21:03.346]                           }
[13:21:03.346]                         }
[13:21:03.346]                       }
[13:21:03.346]                       invisible(muffled)
[13:21:03.346]                     }
[13:21:03.346]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.346]                   }
[13:21:03.346]                 }
[13:21:03.346]             }
[13:21:03.346]         }))
[13:21:03.346]     }, error = function(ex) {
[13:21:03.346]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:03.346]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.346]                 ...future.rng), started = ...future.startTime, 
[13:21:03.346]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:03.346]             version = "1.8"), class = "FutureResult")
[13:21:03.346]     }, finally = {
[13:21:03.346]         if (!identical(...future.workdir, getwd())) 
[13:21:03.346]             setwd(...future.workdir)
[13:21:03.346]         {
[13:21:03.346]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:03.346]                 ...future.oldOptions$nwarnings <- NULL
[13:21:03.346]             }
[13:21:03.346]             base::options(...future.oldOptions)
[13:21:03.346]             if (.Platform$OS.type == "windows") {
[13:21:03.346]                 old_names <- names(...future.oldEnvVars)
[13:21:03.346]                 envs <- base::Sys.getenv()
[13:21:03.346]                 names <- names(envs)
[13:21:03.346]                 common <- intersect(names, old_names)
[13:21:03.346]                 added <- setdiff(names, old_names)
[13:21:03.346]                 removed <- setdiff(old_names, names)
[13:21:03.346]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:03.346]                   envs[common]]
[13:21:03.346]                 NAMES <- toupper(changed)
[13:21:03.346]                 args <- list()
[13:21:03.346]                 for (kk in seq_along(NAMES)) {
[13:21:03.346]                   name <- changed[[kk]]
[13:21:03.346]                   NAME <- NAMES[[kk]]
[13:21:03.346]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.346]                     next
[13:21:03.346]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.346]                 }
[13:21:03.346]                 NAMES <- toupper(added)
[13:21:03.346]                 for (kk in seq_along(NAMES)) {
[13:21:03.346]                   name <- added[[kk]]
[13:21:03.346]                   NAME <- NAMES[[kk]]
[13:21:03.346]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.346]                     next
[13:21:03.346]                   args[[name]] <- ""
[13:21:03.346]                 }
[13:21:03.346]                 NAMES <- toupper(removed)
[13:21:03.346]                 for (kk in seq_along(NAMES)) {
[13:21:03.346]                   name <- removed[[kk]]
[13:21:03.346]                   NAME <- NAMES[[kk]]
[13:21:03.346]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.346]                     next
[13:21:03.346]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.346]                 }
[13:21:03.346]                 if (length(args) > 0) 
[13:21:03.346]                   base::do.call(base::Sys.setenv, args = args)
[13:21:03.346]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:03.346]             }
[13:21:03.346]             else {
[13:21:03.346]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:03.346]             }
[13:21:03.346]             {
[13:21:03.346]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:03.346]                   0L) {
[13:21:03.346]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:03.346]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:03.346]                   base::options(opts)
[13:21:03.346]                 }
[13:21:03.346]                 {
[13:21:03.346]                   {
[13:21:03.346]                     NULL
[13:21:03.346]                     RNGkind("Mersenne-Twister")
[13:21:03.346]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:03.346]                       inherits = FALSE)
[13:21:03.346]                   }
[13:21:03.346]                   options(future.plan = NULL)
[13:21:03.346]                   if (is.na(NA_character_)) 
[13:21:03.346]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.346]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:03.346]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:03.346]                     envir = parent.frame()) 
[13:21:03.346]                   {
[13:21:03.346]                     default_workers <- missing(workers)
[13:21:03.346]                     if (is.function(workers)) 
[13:21:03.346]                       workers <- workers()
[13:21:03.346]                     workers <- structure(as.integer(workers), 
[13:21:03.346]                       class = class(workers))
[13:21:03.346]                     stop_if_not(is.finite(workers), workers >= 
[13:21:03.346]                       1L)
[13:21:03.346]                     if ((workers == 1L && !inherits(workers, 
[13:21:03.346]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:03.346]                       if (default_workers) 
[13:21:03.346]                         supportsMulticore(warn = TRUE)
[13:21:03.346]                       return(sequential(..., envir = envir))
[13:21:03.346]                     }
[13:21:03.346]                     oopts <- options(mc.cores = workers)
[13:21:03.346]                     on.exit(options(oopts))
[13:21:03.346]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:03.346]                       envir = envir)
[13:21:03.346]                     if (!future$lazy) 
[13:21:03.346]                       future <- run(future)
[13:21:03.346]                     invisible(future)
[13:21:03.346]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:03.346]                 }
[13:21:03.346]             }
[13:21:03.346]         }
[13:21:03.346]     })
[13:21:03.346]     if (TRUE) {
[13:21:03.346]         base::sink(type = "output", split = FALSE)
[13:21:03.346]         if (TRUE) {
[13:21:03.346]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:03.346]         }
[13:21:03.346]         else {
[13:21:03.346]             ...future.result["stdout"] <- base::list(NULL)
[13:21:03.346]         }
[13:21:03.346]         base::close(...future.stdout)
[13:21:03.346]         ...future.stdout <- NULL
[13:21:03.346]     }
[13:21:03.346]     ...future.result$conditions <- ...future.conditions
[13:21:03.346]     ...future.result$finished <- base::Sys.time()
[13:21:03.346]     ...future.result
[13:21:03.346] }
[13:21:03.348] assign_globals() ...
[13:21:03.348] List of 1
[13:21:03.348]  $ ii: int 1
[13:21:03.348]  - attr(*, "where")=List of 1
[13:21:03.348]   ..$ ii:<environment: R_EmptyEnv> 
[13:21:03.348]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:03.348]  - attr(*, "resolved")= logi FALSE
[13:21:03.348]  - attr(*, "total_size")= num 56
[13:21:03.350] - copied ‘ii’ to environment
[13:21:03.350] assign_globals() ... done
[13:21:03.350] plan(): Setting new future strategy stack:
[13:21:03.350] List of future strategies:
[13:21:03.350] 1. sequential:
[13:21:03.350]    - args: function (..., envir = parent.frame())
[13:21:03.350]    - tweaked: FALSE
[13:21:03.350]    - call: NULL
[13:21:03.351] plan(): nbrOfWorkers() = 1
[13:21:03.351] plan(): Setting new future strategy stack:
[13:21:03.352] List of future strategies:
[13:21:03.352] 1. multicore:
[13:21:03.352]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:03.352]    - tweaked: FALSE
[13:21:03.352]    - call: plan(multicore)
[13:21:03.355] plan(): nbrOfWorkers() = 1
[13:21:03.355] SequentialFuture started (and completed)
 - Creating multicore future #2 ...
[13:21:03.358] getGlobalsAndPackages() ...
[13:21:03.359] Searching for globals...
[13:21:03.359] - globals found: [2] ‘{’, ‘ii’
[13:21:03.359] Searching for globals ... DONE
[13:21:03.359] Resolving globals: FALSE
[13:21:03.360] The total size of the 1 globals is 56 bytes (56 bytes)
[13:21:03.360] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:21:03.360] - globals: [1] ‘ii’
[13:21:03.360] 
[13:21:03.360] getGlobalsAndPackages() ... DONE
[13:21:03.361] Packages needed by the future expression (n = 0): <none>
[13:21:03.361] Packages needed by future strategies (n = 0): <none>
[13:21:03.361] {
[13:21:03.361]     {
[13:21:03.361]         {
[13:21:03.361]             ...future.startTime <- base::Sys.time()
[13:21:03.361]             {
[13:21:03.361]                 {
[13:21:03.361]                   {
[13:21:03.361]                     base::local({
[13:21:03.361]                       has_future <- base::requireNamespace("future", 
[13:21:03.361]                         quietly = TRUE)
[13:21:03.361]                       if (has_future) {
[13:21:03.361]                         ns <- base::getNamespace("future")
[13:21:03.361]                         version <- ns[[".package"]][["version"]]
[13:21:03.361]                         if (is.null(version)) 
[13:21:03.361]                           version <- utils::packageVersion("future")
[13:21:03.361]                       }
[13:21:03.361]                       else {
[13:21:03.361]                         version <- NULL
[13:21:03.361]                       }
[13:21:03.361]                       if (!has_future || version < "1.8.0") {
[13:21:03.361]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:03.361]                           "", base::R.version$version.string), 
[13:21:03.361]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:03.361]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:03.361]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:03.361]                             "release", "version")], collapse = " "), 
[13:21:03.361]                           hostname = base::Sys.info()[["nodename"]])
[13:21:03.361]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:03.361]                           info)
[13:21:03.361]                         info <- base::paste(info, collapse = "; ")
[13:21:03.361]                         if (!has_future) {
[13:21:03.361]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:03.361]                             info)
[13:21:03.361]                         }
[13:21:03.361]                         else {
[13:21:03.361]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:03.361]                             info, version)
[13:21:03.361]                         }
[13:21:03.361]                         base::stop(msg)
[13:21:03.361]                       }
[13:21:03.361]                     })
[13:21:03.361]                   }
[13:21:03.361]                   options(future.plan = NULL)
[13:21:03.361]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.361]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:03.361]                 }
[13:21:03.361]                 ...future.workdir <- getwd()
[13:21:03.361]             }
[13:21:03.361]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:03.361]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:03.361]         }
[13:21:03.361]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:03.361]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:03.361]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:03.361]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:03.361]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:03.361]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:03.361]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:03.361]             base::names(...future.oldOptions))
[13:21:03.361]     }
[13:21:03.361]     if (FALSE) {
[13:21:03.361]     }
[13:21:03.361]     else {
[13:21:03.361]         if (TRUE) {
[13:21:03.361]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:03.361]                 open = "w")
[13:21:03.361]         }
[13:21:03.361]         else {
[13:21:03.361]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:03.361]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:03.361]         }
[13:21:03.361]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:03.361]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:03.361]             base::sink(type = "output", split = FALSE)
[13:21:03.361]             base::close(...future.stdout)
[13:21:03.361]         }, add = TRUE)
[13:21:03.361]     }
[13:21:03.361]     ...future.frame <- base::sys.nframe()
[13:21:03.361]     ...future.conditions <- base::list()
[13:21:03.361]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:03.361]     if (FALSE) {
[13:21:03.361]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:03.361]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:03.361]     }
[13:21:03.361]     ...future.result <- base::tryCatch({
[13:21:03.361]         base::withCallingHandlers({
[13:21:03.361]             ...future.value <- base::withVisible(base::local({
[13:21:03.361]                 ii
[13:21:03.361]             }))
[13:21:03.361]             future::FutureResult(value = ...future.value$value, 
[13:21:03.361]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.361]                   ...future.rng), globalenv = if (FALSE) 
[13:21:03.361]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:03.361]                     ...future.globalenv.names))
[13:21:03.361]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:03.361]         }, condition = base::local({
[13:21:03.361]             c <- base::c
[13:21:03.361]             inherits <- base::inherits
[13:21:03.361]             invokeRestart <- base::invokeRestart
[13:21:03.361]             length <- base::length
[13:21:03.361]             list <- base::list
[13:21:03.361]             seq.int <- base::seq.int
[13:21:03.361]             signalCondition <- base::signalCondition
[13:21:03.361]             sys.calls <- base::sys.calls
[13:21:03.361]             `[[` <- base::`[[`
[13:21:03.361]             `+` <- base::`+`
[13:21:03.361]             `<<-` <- base::`<<-`
[13:21:03.361]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:03.361]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:03.361]                   3L)]
[13:21:03.361]             }
[13:21:03.361]             function(cond) {
[13:21:03.361]                 is_error <- inherits(cond, "error")
[13:21:03.361]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:03.361]                   NULL)
[13:21:03.361]                 if (is_error) {
[13:21:03.361]                   sessionInformation <- function() {
[13:21:03.361]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:03.361]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:03.361]                       search = base::search(), system = base::Sys.info())
[13:21:03.361]                   }
[13:21:03.361]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.361]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:03.361]                     cond$call), session = sessionInformation(), 
[13:21:03.361]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:03.361]                   signalCondition(cond)
[13:21:03.361]                 }
[13:21:03.361]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:03.361]                 "immediateCondition"))) {
[13:21:03.361]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:03.361]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.361]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:03.361]                   if (TRUE && !signal) {
[13:21:03.361]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.361]                     {
[13:21:03.361]                       inherits <- base::inherits
[13:21:03.361]                       invokeRestart <- base::invokeRestart
[13:21:03.361]                       is.null <- base::is.null
[13:21:03.361]                       muffled <- FALSE
[13:21:03.361]                       if (inherits(cond, "message")) {
[13:21:03.361]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.361]                         if (muffled) 
[13:21:03.361]                           invokeRestart("muffleMessage")
[13:21:03.361]                       }
[13:21:03.361]                       else if (inherits(cond, "warning")) {
[13:21:03.361]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.361]                         if (muffled) 
[13:21:03.361]                           invokeRestart("muffleWarning")
[13:21:03.361]                       }
[13:21:03.361]                       else if (inherits(cond, "condition")) {
[13:21:03.361]                         if (!is.null(pattern)) {
[13:21:03.361]                           computeRestarts <- base::computeRestarts
[13:21:03.361]                           grepl <- base::grepl
[13:21:03.361]                           restarts <- computeRestarts(cond)
[13:21:03.361]                           for (restart in restarts) {
[13:21:03.361]                             name <- restart$name
[13:21:03.361]                             if (is.null(name)) 
[13:21:03.361]                               next
[13:21:03.361]                             if (!grepl(pattern, name)) 
[13:21:03.361]                               next
[13:21:03.361]                             invokeRestart(restart)
[13:21:03.361]                             muffled <- TRUE
[13:21:03.361]                             break
[13:21:03.361]                           }
[13:21:03.361]                         }
[13:21:03.361]                       }
[13:21:03.361]                       invisible(muffled)
[13:21:03.361]                     }
[13:21:03.361]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.361]                   }
[13:21:03.361]                 }
[13:21:03.361]                 else {
[13:21:03.361]                   if (TRUE) {
[13:21:03.361]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.361]                     {
[13:21:03.361]                       inherits <- base::inherits
[13:21:03.361]                       invokeRestart <- base::invokeRestart
[13:21:03.361]                       is.null <- base::is.null
[13:21:03.361]                       muffled <- FALSE
[13:21:03.361]                       if (inherits(cond, "message")) {
[13:21:03.361]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.361]                         if (muffled) 
[13:21:03.361]                           invokeRestart("muffleMessage")
[13:21:03.361]                       }
[13:21:03.361]                       else if (inherits(cond, "warning")) {
[13:21:03.361]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.361]                         if (muffled) 
[13:21:03.361]                           invokeRestart("muffleWarning")
[13:21:03.361]                       }
[13:21:03.361]                       else if (inherits(cond, "condition")) {
[13:21:03.361]                         if (!is.null(pattern)) {
[13:21:03.361]                           computeRestarts <- base::computeRestarts
[13:21:03.361]                           grepl <- base::grepl
[13:21:03.361]                           restarts <- computeRestarts(cond)
[13:21:03.361]                           for (restart in restarts) {
[13:21:03.361]                             name <- restart$name
[13:21:03.361]                             if (is.null(name)) 
[13:21:03.361]                               next
[13:21:03.361]                             if (!grepl(pattern, name)) 
[13:21:03.361]                               next
[13:21:03.361]                             invokeRestart(restart)
[13:21:03.361]                             muffled <- TRUE
[13:21:03.361]                             break
[13:21:03.361]                           }
[13:21:03.361]                         }
[13:21:03.361]                       }
[13:21:03.361]                       invisible(muffled)
[13:21:03.361]                     }
[13:21:03.361]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.361]                   }
[13:21:03.361]                 }
[13:21:03.361]             }
[13:21:03.361]         }))
[13:21:03.361]     }, error = function(ex) {
[13:21:03.361]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:03.361]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.361]                 ...future.rng), started = ...future.startTime, 
[13:21:03.361]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:03.361]             version = "1.8"), class = "FutureResult")
[13:21:03.361]     }, finally = {
[13:21:03.361]         if (!identical(...future.workdir, getwd())) 
[13:21:03.361]             setwd(...future.workdir)
[13:21:03.361]         {
[13:21:03.361]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:03.361]                 ...future.oldOptions$nwarnings <- NULL
[13:21:03.361]             }
[13:21:03.361]             base::options(...future.oldOptions)
[13:21:03.361]             if (.Platform$OS.type == "windows") {
[13:21:03.361]                 old_names <- names(...future.oldEnvVars)
[13:21:03.361]                 envs <- base::Sys.getenv()
[13:21:03.361]                 names <- names(envs)
[13:21:03.361]                 common <- intersect(names, old_names)
[13:21:03.361]                 added <- setdiff(names, old_names)
[13:21:03.361]                 removed <- setdiff(old_names, names)
[13:21:03.361]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:03.361]                   envs[common]]
[13:21:03.361]                 NAMES <- toupper(changed)
[13:21:03.361]                 args <- list()
[13:21:03.361]                 for (kk in seq_along(NAMES)) {
[13:21:03.361]                   name <- changed[[kk]]
[13:21:03.361]                   NAME <- NAMES[[kk]]
[13:21:03.361]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.361]                     next
[13:21:03.361]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.361]                 }
[13:21:03.361]                 NAMES <- toupper(added)
[13:21:03.361]                 for (kk in seq_along(NAMES)) {
[13:21:03.361]                   name <- added[[kk]]
[13:21:03.361]                   NAME <- NAMES[[kk]]
[13:21:03.361]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.361]                     next
[13:21:03.361]                   args[[name]] <- ""
[13:21:03.361]                 }
[13:21:03.361]                 NAMES <- toupper(removed)
[13:21:03.361]                 for (kk in seq_along(NAMES)) {
[13:21:03.361]                   name <- removed[[kk]]
[13:21:03.361]                   NAME <- NAMES[[kk]]
[13:21:03.361]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.361]                     next
[13:21:03.361]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.361]                 }
[13:21:03.361]                 if (length(args) > 0) 
[13:21:03.361]                   base::do.call(base::Sys.setenv, args = args)
[13:21:03.361]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:03.361]             }
[13:21:03.361]             else {
[13:21:03.361]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:03.361]             }
[13:21:03.361]             {
[13:21:03.361]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:03.361]                   0L) {
[13:21:03.361]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:03.361]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:03.361]                   base::options(opts)
[13:21:03.361]                 }
[13:21:03.361]                 {
[13:21:03.361]                   {
[13:21:03.361]                     NULL
[13:21:03.361]                     RNGkind("Mersenne-Twister")
[13:21:03.361]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:03.361]                       inherits = FALSE)
[13:21:03.361]                   }
[13:21:03.361]                   options(future.plan = NULL)
[13:21:03.361]                   if (is.na(NA_character_)) 
[13:21:03.361]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.361]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:03.361]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:03.361]                     envir = parent.frame()) 
[13:21:03.361]                   {
[13:21:03.361]                     default_workers <- missing(workers)
[13:21:03.361]                     if (is.function(workers)) 
[13:21:03.361]                       workers <- workers()
[13:21:03.361]                     workers <- structure(as.integer(workers), 
[13:21:03.361]                       class = class(workers))
[13:21:03.361]                     stop_if_not(is.finite(workers), workers >= 
[13:21:03.361]                       1L)
[13:21:03.361]                     if ((workers == 1L && !inherits(workers, 
[13:21:03.361]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:03.361]                       if (default_workers) 
[13:21:03.361]                         supportsMulticore(warn = TRUE)
[13:21:03.361]                       return(sequential(..., envir = envir))
[13:21:03.361]                     }
[13:21:03.361]                     oopts <- options(mc.cores = workers)
[13:21:03.361]                     on.exit(options(oopts))
[13:21:03.361]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:03.361]                       envir = envir)
[13:21:03.361]                     if (!future$lazy) 
[13:21:03.361]                       future <- run(future)
[13:21:03.361]                     invisible(future)
[13:21:03.361]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:03.361]                 }
[13:21:03.361]             }
[13:21:03.361]         }
[13:21:03.361]     })
[13:21:03.361]     if (TRUE) {
[13:21:03.361]         base::sink(type = "output", split = FALSE)
[13:21:03.361]         if (TRUE) {
[13:21:03.361]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:03.361]         }
[13:21:03.361]         else {
[13:21:03.361]             ...future.result["stdout"] <- base::list(NULL)
[13:21:03.361]         }
[13:21:03.361]         base::close(...future.stdout)
[13:21:03.361]         ...future.stdout <- NULL
[13:21:03.361]     }
[13:21:03.361]     ...future.result$conditions <- ...future.conditions
[13:21:03.361]     ...future.result$finished <- base::Sys.time()
[13:21:03.361]     ...future.result
[13:21:03.361] }
[13:21:03.363] assign_globals() ...
[13:21:03.363] List of 1
[13:21:03.363]  $ ii: int 2
[13:21:03.363]  - attr(*, "where")=List of 1
[13:21:03.363]   ..$ ii:<environment: R_EmptyEnv> 
[13:21:03.363]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:03.363]  - attr(*, "resolved")= logi FALSE
[13:21:03.363]  - attr(*, "total_size")= num 56
[13:21:03.367] - copied ‘ii’ to environment
[13:21:03.367] assign_globals() ... done
[13:21:03.367] plan(): Setting new future strategy stack:
[13:21:03.367] List of future strategies:
[13:21:03.367] 1. sequential:
[13:21:03.367]    - args: function (..., envir = parent.frame())
[13:21:03.367]    - tweaked: FALSE
[13:21:03.367]    - call: NULL
[13:21:03.368] plan(): nbrOfWorkers() = 1
[13:21:03.368] plan(): Setting new future strategy stack:
[13:21:03.368] List of future strategies:
[13:21:03.368] 1. multicore:
[13:21:03.368]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:03.368]    - tweaked: FALSE
[13:21:03.368]    - call: plan(multicore)
[13:21:03.372] plan(): nbrOfWorkers() = 1
[13:21:03.372] SequentialFuture started (and completed)
 - Creating multicore future #3 ...
[13:21:03.375] getGlobalsAndPackages() ...
[13:21:03.375] Searching for globals...
[13:21:03.376] - globals found: [2] ‘{’, ‘ii’
[13:21:03.376] Searching for globals ... DONE
[13:21:03.376] Resolving globals: FALSE
[13:21:03.376] The total size of the 1 globals is 56 bytes (56 bytes)
[13:21:03.377] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:21:03.377] - globals: [1] ‘ii’
[13:21:03.377] 
[13:21:03.377] getGlobalsAndPackages() ... DONE
[13:21:03.377] Packages needed by the future expression (n = 0): <none>
[13:21:03.377] Packages needed by future strategies (n = 0): <none>
[13:21:03.378] {
[13:21:03.378]     {
[13:21:03.378]         {
[13:21:03.378]             ...future.startTime <- base::Sys.time()
[13:21:03.378]             {
[13:21:03.378]                 {
[13:21:03.378]                   {
[13:21:03.378]                     base::local({
[13:21:03.378]                       has_future <- base::requireNamespace("future", 
[13:21:03.378]                         quietly = TRUE)
[13:21:03.378]                       if (has_future) {
[13:21:03.378]                         ns <- base::getNamespace("future")
[13:21:03.378]                         version <- ns[[".package"]][["version"]]
[13:21:03.378]                         if (is.null(version)) 
[13:21:03.378]                           version <- utils::packageVersion("future")
[13:21:03.378]                       }
[13:21:03.378]                       else {
[13:21:03.378]                         version <- NULL
[13:21:03.378]                       }
[13:21:03.378]                       if (!has_future || version < "1.8.0") {
[13:21:03.378]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:03.378]                           "", base::R.version$version.string), 
[13:21:03.378]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:03.378]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:03.378]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:03.378]                             "release", "version")], collapse = " "), 
[13:21:03.378]                           hostname = base::Sys.info()[["nodename"]])
[13:21:03.378]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:03.378]                           info)
[13:21:03.378]                         info <- base::paste(info, collapse = "; ")
[13:21:03.378]                         if (!has_future) {
[13:21:03.378]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:03.378]                             info)
[13:21:03.378]                         }
[13:21:03.378]                         else {
[13:21:03.378]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:03.378]                             info, version)
[13:21:03.378]                         }
[13:21:03.378]                         base::stop(msg)
[13:21:03.378]                       }
[13:21:03.378]                     })
[13:21:03.378]                   }
[13:21:03.378]                   options(future.plan = NULL)
[13:21:03.378]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.378]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:03.378]                 }
[13:21:03.378]                 ...future.workdir <- getwd()
[13:21:03.378]             }
[13:21:03.378]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:03.378]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:03.378]         }
[13:21:03.378]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:03.378]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:03.378]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:03.378]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:03.378]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:03.378]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:03.378]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:03.378]             base::names(...future.oldOptions))
[13:21:03.378]     }
[13:21:03.378]     if (FALSE) {
[13:21:03.378]     }
[13:21:03.378]     else {
[13:21:03.378]         if (TRUE) {
[13:21:03.378]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:03.378]                 open = "w")
[13:21:03.378]         }
[13:21:03.378]         else {
[13:21:03.378]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:03.378]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:03.378]         }
[13:21:03.378]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:03.378]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:03.378]             base::sink(type = "output", split = FALSE)
[13:21:03.378]             base::close(...future.stdout)
[13:21:03.378]         }, add = TRUE)
[13:21:03.378]     }
[13:21:03.378]     ...future.frame <- base::sys.nframe()
[13:21:03.378]     ...future.conditions <- base::list()
[13:21:03.378]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:03.378]     if (FALSE) {
[13:21:03.378]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:03.378]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:03.378]     }
[13:21:03.378]     ...future.result <- base::tryCatch({
[13:21:03.378]         base::withCallingHandlers({
[13:21:03.378]             ...future.value <- base::withVisible(base::local({
[13:21:03.378]                 ii
[13:21:03.378]             }))
[13:21:03.378]             future::FutureResult(value = ...future.value$value, 
[13:21:03.378]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.378]                   ...future.rng), globalenv = if (FALSE) 
[13:21:03.378]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:03.378]                     ...future.globalenv.names))
[13:21:03.378]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:03.378]         }, condition = base::local({
[13:21:03.378]             c <- base::c
[13:21:03.378]             inherits <- base::inherits
[13:21:03.378]             invokeRestart <- base::invokeRestart
[13:21:03.378]             length <- base::length
[13:21:03.378]             list <- base::list
[13:21:03.378]             seq.int <- base::seq.int
[13:21:03.378]             signalCondition <- base::signalCondition
[13:21:03.378]             sys.calls <- base::sys.calls
[13:21:03.378]             `[[` <- base::`[[`
[13:21:03.378]             `+` <- base::`+`
[13:21:03.378]             `<<-` <- base::`<<-`
[13:21:03.378]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:03.378]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:03.378]                   3L)]
[13:21:03.378]             }
[13:21:03.378]             function(cond) {
[13:21:03.378]                 is_error <- inherits(cond, "error")
[13:21:03.378]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:03.378]                   NULL)
[13:21:03.378]                 if (is_error) {
[13:21:03.378]                   sessionInformation <- function() {
[13:21:03.378]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:03.378]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:03.378]                       search = base::search(), system = base::Sys.info())
[13:21:03.378]                   }
[13:21:03.378]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.378]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:03.378]                     cond$call), session = sessionInformation(), 
[13:21:03.378]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:03.378]                   signalCondition(cond)
[13:21:03.378]                 }
[13:21:03.378]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:03.378]                 "immediateCondition"))) {
[13:21:03.378]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:03.378]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.378]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:03.378]                   if (TRUE && !signal) {
[13:21:03.378]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.378]                     {
[13:21:03.378]                       inherits <- base::inherits
[13:21:03.378]                       invokeRestart <- base::invokeRestart
[13:21:03.378]                       is.null <- base::is.null
[13:21:03.378]                       muffled <- FALSE
[13:21:03.378]                       if (inherits(cond, "message")) {
[13:21:03.378]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.378]                         if (muffled) 
[13:21:03.378]                           invokeRestart("muffleMessage")
[13:21:03.378]                       }
[13:21:03.378]                       else if (inherits(cond, "warning")) {
[13:21:03.378]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.378]                         if (muffled) 
[13:21:03.378]                           invokeRestart("muffleWarning")
[13:21:03.378]                       }
[13:21:03.378]                       else if (inherits(cond, "condition")) {
[13:21:03.378]                         if (!is.null(pattern)) {
[13:21:03.378]                           computeRestarts <- base::computeRestarts
[13:21:03.378]                           grepl <- base::grepl
[13:21:03.378]                           restarts <- computeRestarts(cond)
[13:21:03.378]                           for (restart in restarts) {
[13:21:03.378]                             name <- restart$name
[13:21:03.378]                             if (is.null(name)) 
[13:21:03.378]                               next
[13:21:03.378]                             if (!grepl(pattern, name)) 
[13:21:03.378]                               next
[13:21:03.378]                             invokeRestart(restart)
[13:21:03.378]                             muffled <- TRUE
[13:21:03.378]                             break
[13:21:03.378]                           }
[13:21:03.378]                         }
[13:21:03.378]                       }
[13:21:03.378]                       invisible(muffled)
[13:21:03.378]                     }
[13:21:03.378]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.378]                   }
[13:21:03.378]                 }
[13:21:03.378]                 else {
[13:21:03.378]                   if (TRUE) {
[13:21:03.378]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.378]                     {
[13:21:03.378]                       inherits <- base::inherits
[13:21:03.378]                       invokeRestart <- base::invokeRestart
[13:21:03.378]                       is.null <- base::is.null
[13:21:03.378]                       muffled <- FALSE
[13:21:03.378]                       if (inherits(cond, "message")) {
[13:21:03.378]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.378]                         if (muffled) 
[13:21:03.378]                           invokeRestart("muffleMessage")
[13:21:03.378]                       }
[13:21:03.378]                       else if (inherits(cond, "warning")) {
[13:21:03.378]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.378]                         if (muffled) 
[13:21:03.378]                           invokeRestart("muffleWarning")
[13:21:03.378]                       }
[13:21:03.378]                       else if (inherits(cond, "condition")) {
[13:21:03.378]                         if (!is.null(pattern)) {
[13:21:03.378]                           computeRestarts <- base::computeRestarts
[13:21:03.378]                           grepl <- base::grepl
[13:21:03.378]                           restarts <- computeRestarts(cond)
[13:21:03.378]                           for (restart in restarts) {
[13:21:03.378]                             name <- restart$name
[13:21:03.378]                             if (is.null(name)) 
[13:21:03.378]                               next
[13:21:03.378]                             if (!grepl(pattern, name)) 
[13:21:03.378]                               next
[13:21:03.378]                             invokeRestart(restart)
[13:21:03.378]                             muffled <- TRUE
[13:21:03.378]                             break
[13:21:03.378]                           }
[13:21:03.378]                         }
[13:21:03.378]                       }
[13:21:03.378]                       invisible(muffled)
[13:21:03.378]                     }
[13:21:03.378]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.378]                   }
[13:21:03.378]                 }
[13:21:03.378]             }
[13:21:03.378]         }))
[13:21:03.378]     }, error = function(ex) {
[13:21:03.378]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:03.378]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.378]                 ...future.rng), started = ...future.startTime, 
[13:21:03.378]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:03.378]             version = "1.8"), class = "FutureResult")
[13:21:03.378]     }, finally = {
[13:21:03.378]         if (!identical(...future.workdir, getwd())) 
[13:21:03.378]             setwd(...future.workdir)
[13:21:03.378]         {
[13:21:03.378]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:03.378]                 ...future.oldOptions$nwarnings <- NULL
[13:21:03.378]             }
[13:21:03.378]             base::options(...future.oldOptions)
[13:21:03.378]             if (.Platform$OS.type == "windows") {
[13:21:03.378]                 old_names <- names(...future.oldEnvVars)
[13:21:03.378]                 envs <- base::Sys.getenv()
[13:21:03.378]                 names <- names(envs)
[13:21:03.378]                 common <- intersect(names, old_names)
[13:21:03.378]                 added <- setdiff(names, old_names)
[13:21:03.378]                 removed <- setdiff(old_names, names)
[13:21:03.378]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:03.378]                   envs[common]]
[13:21:03.378]                 NAMES <- toupper(changed)
[13:21:03.378]                 args <- list()
[13:21:03.378]                 for (kk in seq_along(NAMES)) {
[13:21:03.378]                   name <- changed[[kk]]
[13:21:03.378]                   NAME <- NAMES[[kk]]
[13:21:03.378]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.378]                     next
[13:21:03.378]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.378]                 }
[13:21:03.378]                 NAMES <- toupper(added)
[13:21:03.378]                 for (kk in seq_along(NAMES)) {
[13:21:03.378]                   name <- added[[kk]]
[13:21:03.378]                   NAME <- NAMES[[kk]]
[13:21:03.378]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.378]                     next
[13:21:03.378]                   args[[name]] <- ""
[13:21:03.378]                 }
[13:21:03.378]                 NAMES <- toupper(removed)
[13:21:03.378]                 for (kk in seq_along(NAMES)) {
[13:21:03.378]                   name <- removed[[kk]]
[13:21:03.378]                   NAME <- NAMES[[kk]]
[13:21:03.378]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.378]                     next
[13:21:03.378]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.378]                 }
[13:21:03.378]                 if (length(args) > 0) 
[13:21:03.378]                   base::do.call(base::Sys.setenv, args = args)
[13:21:03.378]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:03.378]             }
[13:21:03.378]             else {
[13:21:03.378]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:03.378]             }
[13:21:03.378]             {
[13:21:03.378]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:03.378]                   0L) {
[13:21:03.378]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:03.378]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:03.378]                   base::options(opts)
[13:21:03.378]                 }
[13:21:03.378]                 {
[13:21:03.378]                   {
[13:21:03.378]                     NULL
[13:21:03.378]                     RNGkind("Mersenne-Twister")
[13:21:03.378]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:03.378]                       inherits = FALSE)
[13:21:03.378]                   }
[13:21:03.378]                   options(future.plan = NULL)
[13:21:03.378]                   if (is.na(NA_character_)) 
[13:21:03.378]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.378]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:03.378]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:03.378]                     envir = parent.frame()) 
[13:21:03.378]                   {
[13:21:03.378]                     default_workers <- missing(workers)
[13:21:03.378]                     if (is.function(workers)) 
[13:21:03.378]                       workers <- workers()
[13:21:03.378]                     workers <- structure(as.integer(workers), 
[13:21:03.378]                       class = class(workers))
[13:21:03.378]                     stop_if_not(is.finite(workers), workers >= 
[13:21:03.378]                       1L)
[13:21:03.378]                     if ((workers == 1L && !inherits(workers, 
[13:21:03.378]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:03.378]                       if (default_workers) 
[13:21:03.378]                         supportsMulticore(warn = TRUE)
[13:21:03.378]                       return(sequential(..., envir = envir))
[13:21:03.378]                     }
[13:21:03.378]                     oopts <- options(mc.cores = workers)
[13:21:03.378]                     on.exit(options(oopts))
[13:21:03.378]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:03.378]                       envir = envir)
[13:21:03.378]                     if (!future$lazy) 
[13:21:03.378]                       future <- run(future)
[13:21:03.378]                     invisible(future)
[13:21:03.378]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:03.378]                 }
[13:21:03.378]             }
[13:21:03.378]         }
[13:21:03.378]     })
[13:21:03.378]     if (TRUE) {
[13:21:03.378]         base::sink(type = "output", split = FALSE)
[13:21:03.378]         if (TRUE) {
[13:21:03.378]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:03.378]         }
[13:21:03.378]         else {
[13:21:03.378]             ...future.result["stdout"] <- base::list(NULL)
[13:21:03.378]         }
[13:21:03.378]         base::close(...future.stdout)
[13:21:03.378]         ...future.stdout <- NULL
[13:21:03.378]     }
[13:21:03.378]     ...future.result$conditions <- ...future.conditions
[13:21:03.378]     ...future.result$finished <- base::Sys.time()
[13:21:03.378]     ...future.result
[13:21:03.378] }
[13:21:03.379] assign_globals() ...
[13:21:03.380] List of 1
[13:21:03.380]  $ ii: int 3
[13:21:03.380]  - attr(*, "where")=List of 1
[13:21:03.380]   ..$ ii:<environment: R_EmptyEnv> 
[13:21:03.380]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:03.380]  - attr(*, "resolved")= logi FALSE
[13:21:03.380]  - attr(*, "total_size")= num 56
[13:21:03.382] - copied ‘ii’ to environment
[13:21:03.382] assign_globals() ... done
[13:21:03.382] plan(): Setting new future strategy stack:
[13:21:03.382] List of future strategies:
[13:21:03.382] 1. sequential:
[13:21:03.382]    - args: function (..., envir = parent.frame())
[13:21:03.382]    - tweaked: FALSE
[13:21:03.382]    - call: NULL
[13:21:03.382] plan(): nbrOfWorkers() = 1
[13:21:03.383] plan(): Setting new future strategy stack:
[13:21:03.383] List of future strategies:
[13:21:03.383] 1. multicore:
[13:21:03.383]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:03.383]    - tweaked: FALSE
[13:21:03.383]    - call: plan(multicore)
[13:21:03.387] plan(): nbrOfWorkers() = 1
[13:21:03.387] SequentialFuture started (and completed)
 - Creating multicore future #4 ...
[13:21:03.390] getGlobalsAndPackages() ...
[13:21:03.390] Searching for globals...
[13:21:03.391] - globals found: [2] ‘{’, ‘ii’
[13:21:03.391] Searching for globals ... DONE
[13:21:03.391] Resolving globals: FALSE
[13:21:03.391] The total size of the 1 globals is 56 bytes (56 bytes)
[13:21:03.392] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:21:03.392] - globals: [1] ‘ii’
[13:21:03.392] 
[13:21:03.392] getGlobalsAndPackages() ... DONE
[13:21:03.392] Packages needed by the future expression (n = 0): <none>
[13:21:03.392] Packages needed by future strategies (n = 0): <none>
[13:21:03.393] {
[13:21:03.393]     {
[13:21:03.393]         {
[13:21:03.393]             ...future.startTime <- base::Sys.time()
[13:21:03.393]             {
[13:21:03.393]                 {
[13:21:03.393]                   {
[13:21:03.393]                     base::local({
[13:21:03.393]                       has_future <- base::requireNamespace("future", 
[13:21:03.393]                         quietly = TRUE)
[13:21:03.393]                       if (has_future) {
[13:21:03.393]                         ns <- base::getNamespace("future")
[13:21:03.393]                         version <- ns[[".package"]][["version"]]
[13:21:03.393]                         if (is.null(version)) 
[13:21:03.393]                           version <- utils::packageVersion("future")
[13:21:03.393]                       }
[13:21:03.393]                       else {
[13:21:03.393]                         version <- NULL
[13:21:03.393]                       }
[13:21:03.393]                       if (!has_future || version < "1.8.0") {
[13:21:03.393]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:03.393]                           "", base::R.version$version.string), 
[13:21:03.393]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:03.393]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:03.393]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:03.393]                             "release", "version")], collapse = " "), 
[13:21:03.393]                           hostname = base::Sys.info()[["nodename"]])
[13:21:03.393]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:03.393]                           info)
[13:21:03.393]                         info <- base::paste(info, collapse = "; ")
[13:21:03.393]                         if (!has_future) {
[13:21:03.393]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:03.393]                             info)
[13:21:03.393]                         }
[13:21:03.393]                         else {
[13:21:03.393]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:03.393]                             info, version)
[13:21:03.393]                         }
[13:21:03.393]                         base::stop(msg)
[13:21:03.393]                       }
[13:21:03.393]                     })
[13:21:03.393]                   }
[13:21:03.393]                   options(future.plan = NULL)
[13:21:03.393]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.393]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:03.393]                 }
[13:21:03.393]                 ...future.workdir <- getwd()
[13:21:03.393]             }
[13:21:03.393]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:03.393]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:03.393]         }
[13:21:03.393]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:03.393]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:03.393]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:03.393]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:03.393]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:03.393]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:03.393]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:03.393]             base::names(...future.oldOptions))
[13:21:03.393]     }
[13:21:03.393]     if (FALSE) {
[13:21:03.393]     }
[13:21:03.393]     else {
[13:21:03.393]         if (TRUE) {
[13:21:03.393]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:03.393]                 open = "w")
[13:21:03.393]         }
[13:21:03.393]         else {
[13:21:03.393]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:03.393]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:03.393]         }
[13:21:03.393]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:03.393]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:03.393]             base::sink(type = "output", split = FALSE)
[13:21:03.393]             base::close(...future.stdout)
[13:21:03.393]         }, add = TRUE)
[13:21:03.393]     }
[13:21:03.393]     ...future.frame <- base::sys.nframe()
[13:21:03.393]     ...future.conditions <- base::list()
[13:21:03.393]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:03.393]     if (FALSE) {
[13:21:03.393]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:03.393]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:03.393]     }
[13:21:03.393]     ...future.result <- base::tryCatch({
[13:21:03.393]         base::withCallingHandlers({
[13:21:03.393]             ...future.value <- base::withVisible(base::local({
[13:21:03.393]                 ii
[13:21:03.393]             }))
[13:21:03.393]             future::FutureResult(value = ...future.value$value, 
[13:21:03.393]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.393]                   ...future.rng), globalenv = if (FALSE) 
[13:21:03.393]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:03.393]                     ...future.globalenv.names))
[13:21:03.393]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:03.393]         }, condition = base::local({
[13:21:03.393]             c <- base::c
[13:21:03.393]             inherits <- base::inherits
[13:21:03.393]             invokeRestart <- base::invokeRestart
[13:21:03.393]             length <- base::length
[13:21:03.393]             list <- base::list
[13:21:03.393]             seq.int <- base::seq.int
[13:21:03.393]             signalCondition <- base::signalCondition
[13:21:03.393]             sys.calls <- base::sys.calls
[13:21:03.393]             `[[` <- base::`[[`
[13:21:03.393]             `+` <- base::`+`
[13:21:03.393]             `<<-` <- base::`<<-`
[13:21:03.393]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:03.393]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:03.393]                   3L)]
[13:21:03.393]             }
[13:21:03.393]             function(cond) {
[13:21:03.393]                 is_error <- inherits(cond, "error")
[13:21:03.393]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:03.393]                   NULL)
[13:21:03.393]                 if (is_error) {
[13:21:03.393]                   sessionInformation <- function() {
[13:21:03.393]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:03.393]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:03.393]                       search = base::search(), system = base::Sys.info())
[13:21:03.393]                   }
[13:21:03.393]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.393]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:03.393]                     cond$call), session = sessionInformation(), 
[13:21:03.393]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:03.393]                   signalCondition(cond)
[13:21:03.393]                 }
[13:21:03.393]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:03.393]                 "immediateCondition"))) {
[13:21:03.393]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:03.393]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.393]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:03.393]                   if (TRUE && !signal) {
[13:21:03.393]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.393]                     {
[13:21:03.393]                       inherits <- base::inherits
[13:21:03.393]                       invokeRestart <- base::invokeRestart
[13:21:03.393]                       is.null <- base::is.null
[13:21:03.393]                       muffled <- FALSE
[13:21:03.393]                       if (inherits(cond, "message")) {
[13:21:03.393]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.393]                         if (muffled) 
[13:21:03.393]                           invokeRestart("muffleMessage")
[13:21:03.393]                       }
[13:21:03.393]                       else if (inherits(cond, "warning")) {
[13:21:03.393]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.393]                         if (muffled) 
[13:21:03.393]                           invokeRestart("muffleWarning")
[13:21:03.393]                       }
[13:21:03.393]                       else if (inherits(cond, "condition")) {
[13:21:03.393]                         if (!is.null(pattern)) {
[13:21:03.393]                           computeRestarts <- base::computeRestarts
[13:21:03.393]                           grepl <- base::grepl
[13:21:03.393]                           restarts <- computeRestarts(cond)
[13:21:03.393]                           for (restart in restarts) {
[13:21:03.393]                             name <- restart$name
[13:21:03.393]                             if (is.null(name)) 
[13:21:03.393]                               next
[13:21:03.393]                             if (!grepl(pattern, name)) 
[13:21:03.393]                               next
[13:21:03.393]                             invokeRestart(restart)
[13:21:03.393]                             muffled <- TRUE
[13:21:03.393]                             break
[13:21:03.393]                           }
[13:21:03.393]                         }
[13:21:03.393]                       }
[13:21:03.393]                       invisible(muffled)
[13:21:03.393]                     }
[13:21:03.393]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.393]                   }
[13:21:03.393]                 }
[13:21:03.393]                 else {
[13:21:03.393]                   if (TRUE) {
[13:21:03.393]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.393]                     {
[13:21:03.393]                       inherits <- base::inherits
[13:21:03.393]                       invokeRestart <- base::invokeRestart
[13:21:03.393]                       is.null <- base::is.null
[13:21:03.393]                       muffled <- FALSE
[13:21:03.393]                       if (inherits(cond, "message")) {
[13:21:03.393]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.393]                         if (muffled) 
[13:21:03.393]                           invokeRestart("muffleMessage")
[13:21:03.393]                       }
[13:21:03.393]                       else if (inherits(cond, "warning")) {
[13:21:03.393]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.393]                         if (muffled) 
[13:21:03.393]                           invokeRestart("muffleWarning")
[13:21:03.393]                       }
[13:21:03.393]                       else if (inherits(cond, "condition")) {
[13:21:03.393]                         if (!is.null(pattern)) {
[13:21:03.393]                           computeRestarts <- base::computeRestarts
[13:21:03.393]                           grepl <- base::grepl
[13:21:03.393]                           restarts <- computeRestarts(cond)
[13:21:03.393]                           for (restart in restarts) {
[13:21:03.393]                             name <- restart$name
[13:21:03.393]                             if (is.null(name)) 
[13:21:03.393]                               next
[13:21:03.393]                             if (!grepl(pattern, name)) 
[13:21:03.393]                               next
[13:21:03.393]                             invokeRestart(restart)
[13:21:03.393]                             muffled <- TRUE
[13:21:03.393]                             break
[13:21:03.393]                           }
[13:21:03.393]                         }
[13:21:03.393]                       }
[13:21:03.393]                       invisible(muffled)
[13:21:03.393]                     }
[13:21:03.393]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.393]                   }
[13:21:03.393]                 }
[13:21:03.393]             }
[13:21:03.393]         }))
[13:21:03.393]     }, error = function(ex) {
[13:21:03.393]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:03.393]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.393]                 ...future.rng), started = ...future.startTime, 
[13:21:03.393]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:03.393]             version = "1.8"), class = "FutureResult")
[13:21:03.393]     }, finally = {
[13:21:03.393]         if (!identical(...future.workdir, getwd())) 
[13:21:03.393]             setwd(...future.workdir)
[13:21:03.393]         {
[13:21:03.393]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:03.393]                 ...future.oldOptions$nwarnings <- NULL
[13:21:03.393]             }
[13:21:03.393]             base::options(...future.oldOptions)
[13:21:03.393]             if (.Platform$OS.type == "windows") {
[13:21:03.393]                 old_names <- names(...future.oldEnvVars)
[13:21:03.393]                 envs <- base::Sys.getenv()
[13:21:03.393]                 names <- names(envs)
[13:21:03.393]                 common <- intersect(names, old_names)
[13:21:03.393]                 added <- setdiff(names, old_names)
[13:21:03.393]                 removed <- setdiff(old_names, names)
[13:21:03.393]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:03.393]                   envs[common]]
[13:21:03.393]                 NAMES <- toupper(changed)
[13:21:03.393]                 args <- list()
[13:21:03.393]                 for (kk in seq_along(NAMES)) {
[13:21:03.393]                   name <- changed[[kk]]
[13:21:03.393]                   NAME <- NAMES[[kk]]
[13:21:03.393]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.393]                     next
[13:21:03.393]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.393]                 }
[13:21:03.393]                 NAMES <- toupper(added)
[13:21:03.393]                 for (kk in seq_along(NAMES)) {
[13:21:03.393]                   name <- added[[kk]]
[13:21:03.393]                   NAME <- NAMES[[kk]]
[13:21:03.393]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.393]                     next
[13:21:03.393]                   args[[name]] <- ""
[13:21:03.393]                 }
[13:21:03.393]                 NAMES <- toupper(removed)
[13:21:03.393]                 for (kk in seq_along(NAMES)) {
[13:21:03.393]                   name <- removed[[kk]]
[13:21:03.393]                   NAME <- NAMES[[kk]]
[13:21:03.393]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.393]                     next
[13:21:03.393]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.393]                 }
[13:21:03.393]                 if (length(args) > 0) 
[13:21:03.393]                   base::do.call(base::Sys.setenv, args = args)
[13:21:03.393]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:03.393]             }
[13:21:03.393]             else {
[13:21:03.393]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:03.393]             }
[13:21:03.393]             {
[13:21:03.393]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:03.393]                   0L) {
[13:21:03.393]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:03.393]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:03.393]                   base::options(opts)
[13:21:03.393]                 }
[13:21:03.393]                 {
[13:21:03.393]                   {
[13:21:03.393]                     NULL
[13:21:03.393]                     RNGkind("Mersenne-Twister")
[13:21:03.393]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:03.393]                       inherits = FALSE)
[13:21:03.393]                   }
[13:21:03.393]                   options(future.plan = NULL)
[13:21:03.393]                   if (is.na(NA_character_)) 
[13:21:03.393]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.393]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:03.393]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:03.393]                     envir = parent.frame()) 
[13:21:03.393]                   {
[13:21:03.393]                     default_workers <- missing(workers)
[13:21:03.393]                     if (is.function(workers)) 
[13:21:03.393]                       workers <- workers()
[13:21:03.393]                     workers <- structure(as.integer(workers), 
[13:21:03.393]                       class = class(workers))
[13:21:03.393]                     stop_if_not(is.finite(workers), workers >= 
[13:21:03.393]                       1L)
[13:21:03.393]                     if ((workers == 1L && !inherits(workers, 
[13:21:03.393]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:03.393]                       if (default_workers) 
[13:21:03.393]                         supportsMulticore(warn = TRUE)
[13:21:03.393]                       return(sequential(..., envir = envir))
[13:21:03.393]                     }
[13:21:03.393]                     oopts <- options(mc.cores = workers)
[13:21:03.393]                     on.exit(options(oopts))
[13:21:03.393]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:03.393]                       envir = envir)
[13:21:03.393]                     if (!future$lazy) 
[13:21:03.393]                       future <- run(future)
[13:21:03.393]                     invisible(future)
[13:21:03.393]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:03.393]                 }
[13:21:03.393]             }
[13:21:03.393]         }
[13:21:03.393]     })
[13:21:03.393]     if (TRUE) {
[13:21:03.393]         base::sink(type = "output", split = FALSE)
[13:21:03.393]         if (TRUE) {
[13:21:03.393]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:03.393]         }
[13:21:03.393]         else {
[13:21:03.393]             ...future.result["stdout"] <- base::list(NULL)
[13:21:03.393]         }
[13:21:03.393]         base::close(...future.stdout)
[13:21:03.393]         ...future.stdout <- NULL
[13:21:03.393]     }
[13:21:03.393]     ...future.result$conditions <- ...future.conditions
[13:21:03.393]     ...future.result$finished <- base::Sys.time()
[13:21:03.393]     ...future.result
[13:21:03.393] }
[13:21:03.394] assign_globals() ...
[13:21:03.394] List of 1
[13:21:03.394]  $ ii: int 4
[13:21:03.394]  - attr(*, "where")=List of 1
[13:21:03.394]   ..$ ii:<environment: R_EmptyEnv> 
[13:21:03.394]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:03.394]  - attr(*, "resolved")= logi FALSE
[13:21:03.394]  - attr(*, "total_size")= num 56
[13:21:03.397] - copied ‘ii’ to environment
[13:21:03.397] assign_globals() ... done
[13:21:03.397] plan(): Setting new future strategy stack:
[13:21:03.397] List of future strategies:
[13:21:03.397] 1. sequential:
[13:21:03.397]    - args: function (..., envir = parent.frame())
[13:21:03.397]    - tweaked: FALSE
[13:21:03.397]    - call: NULL
[13:21:03.397] plan(): nbrOfWorkers() = 1
[13:21:03.398] plan(): Setting new future strategy stack:
[13:21:03.398] List of future strategies:
[13:21:03.398] 1. multicore:
[13:21:03.398]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:03.398]    - tweaked: FALSE
[13:21:03.398]    - call: plan(multicore)
[13:21:03.401] plan(): nbrOfWorkers() = 1
[13:21:03.402] SequentialFuture started (and completed)
 - Resolving 4 multicore futures
*** multicore(..., globals = TRUE) and errors
[13:21:03.405] getGlobalsAndPackages() ...
[13:21:03.406] Searching for globals...
[13:21:03.406] - globals found: [2] ‘{’, ‘stop’
[13:21:03.408] Searching for globals ... DONE
[13:21:03.408] Resolving globals: FALSE
[13:21:03.408] 
[13:21:03.408] 
[13:21:03.409] getGlobalsAndPackages() ... DONE
[13:21:03.409] Packages needed by the future expression (n = 0): <none>
[13:21:03.409] Packages needed by future strategies (n = 0): <none>
[13:21:03.409] {
[13:21:03.409]     {
[13:21:03.409]         {
[13:21:03.409]             ...future.startTime <- base::Sys.time()
[13:21:03.409]             {
[13:21:03.409]                 {
[13:21:03.409]                   {
[13:21:03.409]                     base::local({
[13:21:03.409]                       has_future <- base::requireNamespace("future", 
[13:21:03.409]                         quietly = TRUE)
[13:21:03.409]                       if (has_future) {
[13:21:03.409]                         ns <- base::getNamespace("future")
[13:21:03.409]                         version <- ns[[".package"]][["version"]]
[13:21:03.409]                         if (is.null(version)) 
[13:21:03.409]                           version <- utils::packageVersion("future")
[13:21:03.409]                       }
[13:21:03.409]                       else {
[13:21:03.409]                         version <- NULL
[13:21:03.409]                       }
[13:21:03.409]                       if (!has_future || version < "1.8.0") {
[13:21:03.409]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:03.409]                           "", base::R.version$version.string), 
[13:21:03.409]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:03.409]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:03.409]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:03.409]                             "release", "version")], collapse = " "), 
[13:21:03.409]                           hostname = base::Sys.info()[["nodename"]])
[13:21:03.409]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:03.409]                           info)
[13:21:03.409]                         info <- base::paste(info, collapse = "; ")
[13:21:03.409]                         if (!has_future) {
[13:21:03.409]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:03.409]                             info)
[13:21:03.409]                         }
[13:21:03.409]                         else {
[13:21:03.409]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:03.409]                             info, version)
[13:21:03.409]                         }
[13:21:03.409]                         base::stop(msg)
[13:21:03.409]                       }
[13:21:03.409]                     })
[13:21:03.409]                   }
[13:21:03.409]                   options(future.plan = NULL)
[13:21:03.409]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.409]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:03.409]                 }
[13:21:03.409]                 ...future.workdir <- getwd()
[13:21:03.409]             }
[13:21:03.409]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:03.409]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:03.409]         }
[13:21:03.409]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:03.409]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:03.409]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:03.409]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:03.409]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:03.409]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:03.409]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:03.409]             base::names(...future.oldOptions))
[13:21:03.409]     }
[13:21:03.409]     if (FALSE) {
[13:21:03.409]     }
[13:21:03.409]     else {
[13:21:03.409]         if (TRUE) {
[13:21:03.409]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:03.409]                 open = "w")
[13:21:03.409]         }
[13:21:03.409]         else {
[13:21:03.409]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:03.409]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:03.409]         }
[13:21:03.409]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:03.409]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:03.409]             base::sink(type = "output", split = FALSE)
[13:21:03.409]             base::close(...future.stdout)
[13:21:03.409]         }, add = TRUE)
[13:21:03.409]     }
[13:21:03.409]     ...future.frame <- base::sys.nframe()
[13:21:03.409]     ...future.conditions <- base::list()
[13:21:03.409]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:03.409]     if (FALSE) {
[13:21:03.409]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:03.409]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:03.409]     }
[13:21:03.409]     ...future.result <- base::tryCatch({
[13:21:03.409]         base::withCallingHandlers({
[13:21:03.409]             ...future.value <- base::withVisible(base::local({
[13:21:03.409]                 stop("Whoops!")
[13:21:03.409]                 1
[13:21:03.409]             }))
[13:21:03.409]             future::FutureResult(value = ...future.value$value, 
[13:21:03.409]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.409]                   ...future.rng), globalenv = if (FALSE) 
[13:21:03.409]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:03.409]                     ...future.globalenv.names))
[13:21:03.409]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:03.409]         }, condition = base::local({
[13:21:03.409]             c <- base::c
[13:21:03.409]             inherits <- base::inherits
[13:21:03.409]             invokeRestart <- base::invokeRestart
[13:21:03.409]             length <- base::length
[13:21:03.409]             list <- base::list
[13:21:03.409]             seq.int <- base::seq.int
[13:21:03.409]             signalCondition <- base::signalCondition
[13:21:03.409]             sys.calls <- base::sys.calls
[13:21:03.409]             `[[` <- base::`[[`
[13:21:03.409]             `+` <- base::`+`
[13:21:03.409]             `<<-` <- base::`<<-`
[13:21:03.409]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:03.409]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:03.409]                   3L)]
[13:21:03.409]             }
[13:21:03.409]             function(cond) {
[13:21:03.409]                 is_error <- inherits(cond, "error")
[13:21:03.409]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:03.409]                   NULL)
[13:21:03.409]                 if (is_error) {
[13:21:03.409]                   sessionInformation <- function() {
[13:21:03.409]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:03.409]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:03.409]                       search = base::search(), system = base::Sys.info())
[13:21:03.409]                   }
[13:21:03.409]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.409]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:03.409]                     cond$call), session = sessionInformation(), 
[13:21:03.409]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:03.409]                   signalCondition(cond)
[13:21:03.409]                 }
[13:21:03.409]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:03.409]                 "immediateCondition"))) {
[13:21:03.409]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:03.409]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.409]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:03.409]                   if (TRUE && !signal) {
[13:21:03.409]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.409]                     {
[13:21:03.409]                       inherits <- base::inherits
[13:21:03.409]                       invokeRestart <- base::invokeRestart
[13:21:03.409]                       is.null <- base::is.null
[13:21:03.409]                       muffled <- FALSE
[13:21:03.409]                       if (inherits(cond, "message")) {
[13:21:03.409]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.409]                         if (muffled) 
[13:21:03.409]                           invokeRestart("muffleMessage")
[13:21:03.409]                       }
[13:21:03.409]                       else if (inherits(cond, "warning")) {
[13:21:03.409]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.409]                         if (muffled) 
[13:21:03.409]                           invokeRestart("muffleWarning")
[13:21:03.409]                       }
[13:21:03.409]                       else if (inherits(cond, "condition")) {
[13:21:03.409]                         if (!is.null(pattern)) {
[13:21:03.409]                           computeRestarts <- base::computeRestarts
[13:21:03.409]                           grepl <- base::grepl
[13:21:03.409]                           restarts <- computeRestarts(cond)
[13:21:03.409]                           for (restart in restarts) {
[13:21:03.409]                             name <- restart$name
[13:21:03.409]                             if (is.null(name)) 
[13:21:03.409]                               next
[13:21:03.409]                             if (!grepl(pattern, name)) 
[13:21:03.409]                               next
[13:21:03.409]                             invokeRestart(restart)
[13:21:03.409]                             muffled <- TRUE
[13:21:03.409]                             break
[13:21:03.409]                           }
[13:21:03.409]                         }
[13:21:03.409]                       }
[13:21:03.409]                       invisible(muffled)
[13:21:03.409]                     }
[13:21:03.409]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.409]                   }
[13:21:03.409]                 }
[13:21:03.409]                 else {
[13:21:03.409]                   if (TRUE) {
[13:21:03.409]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.409]                     {
[13:21:03.409]                       inherits <- base::inherits
[13:21:03.409]                       invokeRestart <- base::invokeRestart
[13:21:03.409]                       is.null <- base::is.null
[13:21:03.409]                       muffled <- FALSE
[13:21:03.409]                       if (inherits(cond, "message")) {
[13:21:03.409]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.409]                         if (muffled) 
[13:21:03.409]                           invokeRestart("muffleMessage")
[13:21:03.409]                       }
[13:21:03.409]                       else if (inherits(cond, "warning")) {
[13:21:03.409]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.409]                         if (muffled) 
[13:21:03.409]                           invokeRestart("muffleWarning")
[13:21:03.409]                       }
[13:21:03.409]                       else if (inherits(cond, "condition")) {
[13:21:03.409]                         if (!is.null(pattern)) {
[13:21:03.409]                           computeRestarts <- base::computeRestarts
[13:21:03.409]                           grepl <- base::grepl
[13:21:03.409]                           restarts <- computeRestarts(cond)
[13:21:03.409]                           for (restart in restarts) {
[13:21:03.409]                             name <- restart$name
[13:21:03.409]                             if (is.null(name)) 
[13:21:03.409]                               next
[13:21:03.409]                             if (!grepl(pattern, name)) 
[13:21:03.409]                               next
[13:21:03.409]                             invokeRestart(restart)
[13:21:03.409]                             muffled <- TRUE
[13:21:03.409]                             break
[13:21:03.409]                           }
[13:21:03.409]                         }
[13:21:03.409]                       }
[13:21:03.409]                       invisible(muffled)
[13:21:03.409]                     }
[13:21:03.409]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.409]                   }
[13:21:03.409]                 }
[13:21:03.409]             }
[13:21:03.409]         }))
[13:21:03.409]     }, error = function(ex) {
[13:21:03.409]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:03.409]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.409]                 ...future.rng), started = ...future.startTime, 
[13:21:03.409]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:03.409]             version = "1.8"), class = "FutureResult")
[13:21:03.409]     }, finally = {
[13:21:03.409]         if (!identical(...future.workdir, getwd())) 
[13:21:03.409]             setwd(...future.workdir)
[13:21:03.409]         {
[13:21:03.409]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:03.409]                 ...future.oldOptions$nwarnings <- NULL
[13:21:03.409]             }
[13:21:03.409]             base::options(...future.oldOptions)
[13:21:03.409]             if (.Platform$OS.type == "windows") {
[13:21:03.409]                 old_names <- names(...future.oldEnvVars)
[13:21:03.409]                 envs <- base::Sys.getenv()
[13:21:03.409]                 names <- names(envs)
[13:21:03.409]                 common <- intersect(names, old_names)
[13:21:03.409]                 added <- setdiff(names, old_names)
[13:21:03.409]                 removed <- setdiff(old_names, names)
[13:21:03.409]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:03.409]                   envs[common]]
[13:21:03.409]                 NAMES <- toupper(changed)
[13:21:03.409]                 args <- list()
[13:21:03.409]                 for (kk in seq_along(NAMES)) {
[13:21:03.409]                   name <- changed[[kk]]
[13:21:03.409]                   NAME <- NAMES[[kk]]
[13:21:03.409]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.409]                     next
[13:21:03.409]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.409]                 }
[13:21:03.409]                 NAMES <- toupper(added)
[13:21:03.409]                 for (kk in seq_along(NAMES)) {
[13:21:03.409]                   name <- added[[kk]]
[13:21:03.409]                   NAME <- NAMES[[kk]]
[13:21:03.409]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.409]                     next
[13:21:03.409]                   args[[name]] <- ""
[13:21:03.409]                 }
[13:21:03.409]                 NAMES <- toupper(removed)
[13:21:03.409]                 for (kk in seq_along(NAMES)) {
[13:21:03.409]                   name <- removed[[kk]]
[13:21:03.409]                   NAME <- NAMES[[kk]]
[13:21:03.409]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.409]                     next
[13:21:03.409]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.409]                 }
[13:21:03.409]                 if (length(args) > 0) 
[13:21:03.409]                   base::do.call(base::Sys.setenv, args = args)
[13:21:03.409]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:03.409]             }
[13:21:03.409]             else {
[13:21:03.409]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:03.409]             }
[13:21:03.409]             {
[13:21:03.409]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:03.409]                   0L) {
[13:21:03.409]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:03.409]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:03.409]                   base::options(opts)
[13:21:03.409]                 }
[13:21:03.409]                 {
[13:21:03.409]                   {
[13:21:03.409]                     NULL
[13:21:03.409]                     RNGkind("Mersenne-Twister")
[13:21:03.409]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:03.409]                       inherits = FALSE)
[13:21:03.409]                   }
[13:21:03.409]                   options(future.plan = NULL)
[13:21:03.409]                   if (is.na(NA_character_)) 
[13:21:03.409]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.409]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:03.409]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:03.409]                     envir = parent.frame()) 
[13:21:03.409]                   {
[13:21:03.409]                     default_workers <- missing(workers)
[13:21:03.409]                     if (is.function(workers)) 
[13:21:03.409]                       workers <- workers()
[13:21:03.409]                     workers <- structure(as.integer(workers), 
[13:21:03.409]                       class = class(workers))
[13:21:03.409]                     stop_if_not(is.finite(workers), workers >= 
[13:21:03.409]                       1L)
[13:21:03.409]                     if ((workers == 1L && !inherits(workers, 
[13:21:03.409]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:03.409]                       if (default_workers) 
[13:21:03.409]                         supportsMulticore(warn = TRUE)
[13:21:03.409]                       return(sequential(..., envir = envir))
[13:21:03.409]                     }
[13:21:03.409]                     oopts <- options(mc.cores = workers)
[13:21:03.409]                     on.exit(options(oopts))
[13:21:03.409]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:03.409]                       envir = envir)
[13:21:03.409]                     if (!future$lazy) 
[13:21:03.409]                       future <- run(future)
[13:21:03.409]                     invisible(future)
[13:21:03.409]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:03.409]                 }
[13:21:03.409]             }
[13:21:03.409]         }
[13:21:03.409]     })
[13:21:03.409]     if (TRUE) {
[13:21:03.409]         base::sink(type = "output", split = FALSE)
[13:21:03.409]         if (TRUE) {
[13:21:03.409]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:03.409]         }
[13:21:03.409]         else {
[13:21:03.409]             ...future.result["stdout"] <- base::list(NULL)
[13:21:03.409]         }
[13:21:03.409]         base::close(...future.stdout)
[13:21:03.409]         ...future.stdout <- NULL
[13:21:03.409]     }
[13:21:03.409]     ...future.result$conditions <- ...future.conditions
[13:21:03.409]     ...future.result$finished <- base::Sys.time()
[13:21:03.409]     ...future.result
[13:21:03.409] }
[13:21:03.411] plan(): Setting new future strategy stack:
[13:21:03.411] List of future strategies:
[13:21:03.411] 1. sequential:
[13:21:03.411]    - args: function (..., envir = parent.frame())
[13:21:03.411]    - tweaked: FALSE
[13:21:03.411]    - call: NULL
[13:21:03.412] plan(): nbrOfWorkers() = 1
[13:21:03.412] plan(): Setting new future strategy stack:
[13:21:03.413] List of future strategies:
[13:21:03.413] 1. multicore:
[13:21:03.413]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:03.413]    - tweaked: FALSE
[13:21:03.413]    - call: plan(multicore)
[13:21:03.416] plan(): nbrOfWorkers() = 1
[13:21:03.416] SequentialFuture started (and completed)
[13:21:03.416] signalConditions() ...
[13:21:03.416]  - include = ‘immediateCondition’
[13:21:03.416]  - exclude = 
[13:21:03.416]  - resignal = FALSE
[13:21:03.417]  - Number of conditions: 1
[13:21:03.417] signalConditions() ... done
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 0 bytes of class ‘NULL’
Conditions captured: [n=1] ‘simpleError’
Early signaling: FALSE
Owner process: 32f7abe8-d290-272e-8911-a8ce072c31c3
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:03.417] signalConditions() ...
[13:21:03.417]  - include = ‘immediateCondition’
[13:21:03.417]  - exclude = 
[13:21:03.418]  - resignal = FALSE
[13:21:03.418]  - Number of conditions: 1
[13:21:03.418] signalConditions() ... done
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[13:21:03.418] signalConditions() ...
[13:21:03.418]  - include = ‘immediateCondition’
[13:21:03.418]  - exclude = 
[13:21:03.418]  - resignal = FALSE
[13:21:03.418]  - Number of conditions: 1
[13:21:03.418] signalConditions() ... done
[13:21:03.419] Future state: ‘finished’
[13:21:03.419] signalConditions() ...
[13:21:03.419]  - include = ‘condition’
[13:21:03.419]  - exclude = ‘immediateCondition’
[13:21:03.419]  - resignal = TRUE
[13:21:03.419]  - Number of conditions: 1
[13:21:03.419]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:21:03.419] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[13:21:03.420] signalConditions() ...
[13:21:03.420]  - include = ‘immediateCondition’
[13:21:03.420]  - exclude = 
[13:21:03.420]  - resignal = FALSE
[13:21:03.420]  - Number of conditions: 1
[13:21:03.420] signalConditions() ... done
[13:21:03.420] Future state: ‘finished’
[13:21:03.420] signalConditions() ...
[13:21:03.420]  - include = ‘condition’
[13:21:03.420]  - exclude = ‘immediateCondition’
[13:21:03.421]  - resignal = TRUE
[13:21:03.421]  - Number of conditions: 1
[13:21:03.421]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:21:03.421] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[13:21:03.424] getGlobalsAndPackages() ...
[13:21:03.424] Searching for globals...
[13:21:03.425] - globals found: [5] ‘{’, ‘stop’, ‘structure’, ‘list’, ‘c’
[13:21:03.426] Searching for globals ... DONE
[13:21:03.426] Resolving globals: FALSE
[13:21:03.426] 
[13:21:03.426] 
[13:21:03.426] getGlobalsAndPackages() ... DONE
[13:21:03.426] Packages needed by the future expression (n = 0): <none>
[13:21:03.427] Packages needed by future strategies (n = 0): <none>
[13:21:03.427] {
[13:21:03.427]     {
[13:21:03.427]         {
[13:21:03.427]             ...future.startTime <- base::Sys.time()
[13:21:03.427]             {
[13:21:03.427]                 {
[13:21:03.427]                   {
[13:21:03.427]                     base::local({
[13:21:03.427]                       has_future <- base::requireNamespace("future", 
[13:21:03.427]                         quietly = TRUE)
[13:21:03.427]                       if (has_future) {
[13:21:03.427]                         ns <- base::getNamespace("future")
[13:21:03.427]                         version <- ns[[".package"]][["version"]]
[13:21:03.427]                         if (is.null(version)) 
[13:21:03.427]                           version <- utils::packageVersion("future")
[13:21:03.427]                       }
[13:21:03.427]                       else {
[13:21:03.427]                         version <- NULL
[13:21:03.427]                       }
[13:21:03.427]                       if (!has_future || version < "1.8.0") {
[13:21:03.427]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:03.427]                           "", base::R.version$version.string), 
[13:21:03.427]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:03.427]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:03.427]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:03.427]                             "release", "version")], collapse = " "), 
[13:21:03.427]                           hostname = base::Sys.info()[["nodename"]])
[13:21:03.427]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:03.427]                           info)
[13:21:03.427]                         info <- base::paste(info, collapse = "; ")
[13:21:03.427]                         if (!has_future) {
[13:21:03.427]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:03.427]                             info)
[13:21:03.427]                         }
[13:21:03.427]                         else {
[13:21:03.427]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:03.427]                             info, version)
[13:21:03.427]                         }
[13:21:03.427]                         base::stop(msg)
[13:21:03.427]                       }
[13:21:03.427]                     })
[13:21:03.427]                   }
[13:21:03.427]                   options(future.plan = NULL)
[13:21:03.427]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.427]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:03.427]                 }
[13:21:03.427]                 ...future.workdir <- getwd()
[13:21:03.427]             }
[13:21:03.427]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:03.427]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:03.427]         }
[13:21:03.427]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:03.427]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:03.427]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:03.427]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:03.427]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:03.427]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:03.427]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:03.427]             base::names(...future.oldOptions))
[13:21:03.427]     }
[13:21:03.427]     if (FALSE) {
[13:21:03.427]     }
[13:21:03.427]     else {
[13:21:03.427]         if (TRUE) {
[13:21:03.427]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:03.427]                 open = "w")
[13:21:03.427]         }
[13:21:03.427]         else {
[13:21:03.427]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:03.427]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:03.427]         }
[13:21:03.427]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:03.427]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:03.427]             base::sink(type = "output", split = FALSE)
[13:21:03.427]             base::close(...future.stdout)
[13:21:03.427]         }, add = TRUE)
[13:21:03.427]     }
[13:21:03.427]     ...future.frame <- base::sys.nframe()
[13:21:03.427]     ...future.conditions <- base::list()
[13:21:03.427]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:03.427]     if (FALSE) {
[13:21:03.427]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:03.427]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:03.427]     }
[13:21:03.427]     ...future.result <- base::tryCatch({
[13:21:03.427]         base::withCallingHandlers({
[13:21:03.427]             ...future.value <- base::withVisible(base::local({
[13:21:03.427]                 stop(structure(list(message = "boom"), class = c("MyError", 
[13:21:03.427]                   "error", "condition")))
[13:21:03.427]             }))
[13:21:03.427]             future::FutureResult(value = ...future.value$value, 
[13:21:03.427]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.427]                   ...future.rng), globalenv = if (FALSE) 
[13:21:03.427]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:03.427]                     ...future.globalenv.names))
[13:21:03.427]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:03.427]         }, condition = base::local({
[13:21:03.427]             c <- base::c
[13:21:03.427]             inherits <- base::inherits
[13:21:03.427]             invokeRestart <- base::invokeRestart
[13:21:03.427]             length <- base::length
[13:21:03.427]             list <- base::list
[13:21:03.427]             seq.int <- base::seq.int
[13:21:03.427]             signalCondition <- base::signalCondition
[13:21:03.427]             sys.calls <- base::sys.calls
[13:21:03.427]             `[[` <- base::`[[`
[13:21:03.427]             `+` <- base::`+`
[13:21:03.427]             `<<-` <- base::`<<-`
[13:21:03.427]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:03.427]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:03.427]                   3L)]
[13:21:03.427]             }
[13:21:03.427]             function(cond) {
[13:21:03.427]                 is_error <- inherits(cond, "error")
[13:21:03.427]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:03.427]                   NULL)
[13:21:03.427]                 if (is_error) {
[13:21:03.427]                   sessionInformation <- function() {
[13:21:03.427]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:03.427]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:03.427]                       search = base::search(), system = base::Sys.info())
[13:21:03.427]                   }
[13:21:03.427]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.427]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:03.427]                     cond$call), session = sessionInformation(), 
[13:21:03.427]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:03.427]                   signalCondition(cond)
[13:21:03.427]                 }
[13:21:03.427]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:03.427]                 "immediateCondition"))) {
[13:21:03.427]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:03.427]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.427]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:03.427]                   if (TRUE && !signal) {
[13:21:03.427]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.427]                     {
[13:21:03.427]                       inherits <- base::inherits
[13:21:03.427]                       invokeRestart <- base::invokeRestart
[13:21:03.427]                       is.null <- base::is.null
[13:21:03.427]                       muffled <- FALSE
[13:21:03.427]                       if (inherits(cond, "message")) {
[13:21:03.427]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.427]                         if (muffled) 
[13:21:03.427]                           invokeRestart("muffleMessage")
[13:21:03.427]                       }
[13:21:03.427]                       else if (inherits(cond, "warning")) {
[13:21:03.427]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.427]                         if (muffled) 
[13:21:03.427]                           invokeRestart("muffleWarning")
[13:21:03.427]                       }
[13:21:03.427]                       else if (inherits(cond, "condition")) {
[13:21:03.427]                         if (!is.null(pattern)) {
[13:21:03.427]                           computeRestarts <- base::computeRestarts
[13:21:03.427]                           grepl <- base::grepl
[13:21:03.427]                           restarts <- computeRestarts(cond)
[13:21:03.427]                           for (restart in restarts) {
[13:21:03.427]                             name <- restart$name
[13:21:03.427]                             if (is.null(name)) 
[13:21:03.427]                               next
[13:21:03.427]                             if (!grepl(pattern, name)) 
[13:21:03.427]                               next
[13:21:03.427]                             invokeRestart(restart)
[13:21:03.427]                             muffled <- TRUE
[13:21:03.427]                             break
[13:21:03.427]                           }
[13:21:03.427]                         }
[13:21:03.427]                       }
[13:21:03.427]                       invisible(muffled)
[13:21:03.427]                     }
[13:21:03.427]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.427]                   }
[13:21:03.427]                 }
[13:21:03.427]                 else {
[13:21:03.427]                   if (TRUE) {
[13:21:03.427]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.427]                     {
[13:21:03.427]                       inherits <- base::inherits
[13:21:03.427]                       invokeRestart <- base::invokeRestart
[13:21:03.427]                       is.null <- base::is.null
[13:21:03.427]                       muffled <- FALSE
[13:21:03.427]                       if (inherits(cond, "message")) {
[13:21:03.427]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.427]                         if (muffled) 
[13:21:03.427]                           invokeRestart("muffleMessage")
[13:21:03.427]                       }
[13:21:03.427]                       else if (inherits(cond, "warning")) {
[13:21:03.427]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.427]                         if (muffled) 
[13:21:03.427]                           invokeRestart("muffleWarning")
[13:21:03.427]                       }
[13:21:03.427]                       else if (inherits(cond, "condition")) {
[13:21:03.427]                         if (!is.null(pattern)) {
[13:21:03.427]                           computeRestarts <- base::computeRestarts
[13:21:03.427]                           grepl <- base::grepl
[13:21:03.427]                           restarts <- computeRestarts(cond)
[13:21:03.427]                           for (restart in restarts) {
[13:21:03.427]                             name <- restart$name
[13:21:03.427]                             if (is.null(name)) 
[13:21:03.427]                               next
[13:21:03.427]                             if (!grepl(pattern, name)) 
[13:21:03.427]                               next
[13:21:03.427]                             invokeRestart(restart)
[13:21:03.427]                             muffled <- TRUE
[13:21:03.427]                             break
[13:21:03.427]                           }
[13:21:03.427]                         }
[13:21:03.427]                       }
[13:21:03.427]                       invisible(muffled)
[13:21:03.427]                     }
[13:21:03.427]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.427]                   }
[13:21:03.427]                 }
[13:21:03.427]             }
[13:21:03.427]         }))
[13:21:03.427]     }, error = function(ex) {
[13:21:03.427]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:03.427]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.427]                 ...future.rng), started = ...future.startTime, 
[13:21:03.427]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:03.427]             version = "1.8"), class = "FutureResult")
[13:21:03.427]     }, finally = {
[13:21:03.427]         if (!identical(...future.workdir, getwd())) 
[13:21:03.427]             setwd(...future.workdir)
[13:21:03.427]         {
[13:21:03.427]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:03.427]                 ...future.oldOptions$nwarnings <- NULL
[13:21:03.427]             }
[13:21:03.427]             base::options(...future.oldOptions)
[13:21:03.427]             if (.Platform$OS.type == "windows") {
[13:21:03.427]                 old_names <- names(...future.oldEnvVars)
[13:21:03.427]                 envs <- base::Sys.getenv()
[13:21:03.427]                 names <- names(envs)
[13:21:03.427]                 common <- intersect(names, old_names)
[13:21:03.427]                 added <- setdiff(names, old_names)
[13:21:03.427]                 removed <- setdiff(old_names, names)
[13:21:03.427]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:03.427]                   envs[common]]
[13:21:03.427]                 NAMES <- toupper(changed)
[13:21:03.427]                 args <- list()
[13:21:03.427]                 for (kk in seq_along(NAMES)) {
[13:21:03.427]                   name <- changed[[kk]]
[13:21:03.427]                   NAME <- NAMES[[kk]]
[13:21:03.427]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.427]                     next
[13:21:03.427]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.427]                 }
[13:21:03.427]                 NAMES <- toupper(added)
[13:21:03.427]                 for (kk in seq_along(NAMES)) {
[13:21:03.427]                   name <- added[[kk]]
[13:21:03.427]                   NAME <- NAMES[[kk]]
[13:21:03.427]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.427]                     next
[13:21:03.427]                   args[[name]] <- ""
[13:21:03.427]                 }
[13:21:03.427]                 NAMES <- toupper(removed)
[13:21:03.427]                 for (kk in seq_along(NAMES)) {
[13:21:03.427]                   name <- removed[[kk]]
[13:21:03.427]                   NAME <- NAMES[[kk]]
[13:21:03.427]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.427]                     next
[13:21:03.427]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.427]                 }
[13:21:03.427]                 if (length(args) > 0) 
[13:21:03.427]                   base::do.call(base::Sys.setenv, args = args)
[13:21:03.427]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:03.427]             }
[13:21:03.427]             else {
[13:21:03.427]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:03.427]             }
[13:21:03.427]             {
[13:21:03.427]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:03.427]                   0L) {
[13:21:03.427]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:03.427]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:03.427]                   base::options(opts)
[13:21:03.427]                 }
[13:21:03.427]                 {
[13:21:03.427]                   {
[13:21:03.427]                     NULL
[13:21:03.427]                     RNGkind("Mersenne-Twister")
[13:21:03.427]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:03.427]                       inherits = FALSE)
[13:21:03.427]                   }
[13:21:03.427]                   options(future.plan = NULL)
[13:21:03.427]                   if (is.na(NA_character_)) 
[13:21:03.427]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.427]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:03.427]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:03.427]                     envir = parent.frame()) 
[13:21:03.427]                   {
[13:21:03.427]                     default_workers <- missing(workers)
[13:21:03.427]                     if (is.function(workers)) 
[13:21:03.427]                       workers <- workers()
[13:21:03.427]                     workers <- structure(as.integer(workers), 
[13:21:03.427]                       class = class(workers))
[13:21:03.427]                     stop_if_not(is.finite(workers), workers >= 
[13:21:03.427]                       1L)
[13:21:03.427]                     if ((workers == 1L && !inherits(workers, 
[13:21:03.427]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:03.427]                       if (default_workers) 
[13:21:03.427]                         supportsMulticore(warn = TRUE)
[13:21:03.427]                       return(sequential(..., envir = envir))
[13:21:03.427]                     }
[13:21:03.427]                     oopts <- options(mc.cores = workers)
[13:21:03.427]                     on.exit(options(oopts))
[13:21:03.427]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:03.427]                       envir = envir)
[13:21:03.427]                     if (!future$lazy) 
[13:21:03.427]                       future <- run(future)
[13:21:03.427]                     invisible(future)
[13:21:03.427]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:03.427]                 }
[13:21:03.427]             }
[13:21:03.427]         }
[13:21:03.427]     })
[13:21:03.427]     if (TRUE) {
[13:21:03.427]         base::sink(type = "output", split = FALSE)
[13:21:03.427]         if (TRUE) {
[13:21:03.427]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:03.427]         }
[13:21:03.427]         else {
[13:21:03.427]             ...future.result["stdout"] <- base::list(NULL)
[13:21:03.427]         }
[13:21:03.427]         base::close(...future.stdout)
[13:21:03.427]         ...future.stdout <- NULL
[13:21:03.427]     }
[13:21:03.427]     ...future.result$conditions <- ...future.conditions
[13:21:03.427]     ...future.result$finished <- base::Sys.time()
[13:21:03.427]     ...future.result
[13:21:03.427] }
[13:21:03.429] plan(): Setting new future strategy stack:
[13:21:03.429] List of future strategies:
[13:21:03.429] 1. sequential:
[13:21:03.429]    - args: function (..., envir = parent.frame())
[13:21:03.429]    - tweaked: FALSE
[13:21:03.429]    - call: NULL
[13:21:03.429] plan(): nbrOfWorkers() = 1
[13:21:03.430] plan(): Setting new future strategy stack:
[13:21:03.430] List of future strategies:
[13:21:03.430] 1. multicore:
[13:21:03.430]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:03.430]    - tweaked: FALSE
[13:21:03.430]    - call: plan(multicore)
[13:21:03.434] plan(): nbrOfWorkers() = 1
[13:21:03.434] SequentialFuture started (and completed)
[13:21:03.434] signalConditions() ...
[13:21:03.434]  - include = ‘immediateCondition’
[13:21:03.434]  - exclude = 
[13:21:03.434]  - resignal = FALSE
[13:21:03.434]  - Number of conditions: 1
[13:21:03.434] signalConditions() ... done
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 0 bytes of class ‘NULL’
Conditions captured: [n=1] ‘MyError’
Early signaling: FALSE
Owner process: 32f7abe8-d290-272e-8911-a8ce072c31c3
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:03.435] signalConditions() ...
[13:21:03.435]  - include = ‘immediateCondition’
[13:21:03.435]  - exclude = 
[13:21:03.435]  - resignal = FALSE
[13:21:03.435]  - Number of conditions: 1
[13:21:03.435] signalConditions() ... done
<MyError: boom>
[13:21:03.435] signalConditions() ...
[13:21:03.436]  - include = ‘immediateCondition’
[13:21:03.436]  - exclude = 
[13:21:03.436]  - resignal = FALSE
[13:21:03.436]  - Number of conditions: 1
[13:21:03.436] signalConditions() ... done
[13:21:03.436] Future state: ‘finished’
[13:21:03.436] signalConditions() ...
[13:21:03.436]  - include = ‘condition’
[13:21:03.436]  - exclude = ‘immediateCondition’
[13:21:03.436]  - resignal = TRUE
[13:21:03.436]  - Number of conditions: 1
[13:21:03.437]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[13:21:03.437] signalConditions() ... done
*** multicore(..., workers = 1L) ...
[13:21:03.437] getGlobalsAndPackages() ...
[13:21:03.437] Searching for globals...
[13:21:03.438] - globals found: [4] ‘{’, ‘*’, ‘a’, ‘b’
[13:21:03.438] Searching for globals ... DONE
[13:21:03.438] Resolving globals: FALSE
[13:21:03.438] The total size of the 2 globals is 112 bytes (112 bytes)
[13:21:03.439] The total size of the 2 globals exported for future expression (‘{; a * b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘b’ (56 bytes of class ‘numeric’)
[13:21:03.439] - globals: [2] ‘a’, ‘b’
[13:21:03.439] 
[13:21:03.439] getGlobalsAndPackages() ... DONE
[13:21:03.439] Packages needed by the future expression (n = 0): <none>
[13:21:03.439] Packages needed by future strategies (n = 0): <none>
[13:21:03.440] {
[13:21:03.440]     {
[13:21:03.440]         {
[13:21:03.440]             ...future.startTime <- base::Sys.time()
[13:21:03.440]             {
[13:21:03.440]                 {
[13:21:03.440]                   {
[13:21:03.440]                     base::local({
[13:21:03.440]                       has_future <- base::requireNamespace("future", 
[13:21:03.440]                         quietly = TRUE)
[13:21:03.440]                       if (has_future) {
[13:21:03.440]                         ns <- base::getNamespace("future")
[13:21:03.440]                         version <- ns[[".package"]][["version"]]
[13:21:03.440]                         if (is.null(version)) 
[13:21:03.440]                           version <- utils::packageVersion("future")
[13:21:03.440]                       }
[13:21:03.440]                       else {
[13:21:03.440]                         version <- NULL
[13:21:03.440]                       }
[13:21:03.440]                       if (!has_future || version < "1.8.0") {
[13:21:03.440]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:03.440]                           "", base::R.version$version.string), 
[13:21:03.440]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:03.440]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:03.440]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:03.440]                             "release", "version")], collapse = " "), 
[13:21:03.440]                           hostname = base::Sys.info()[["nodename"]])
[13:21:03.440]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:03.440]                           info)
[13:21:03.440]                         info <- base::paste(info, collapse = "; ")
[13:21:03.440]                         if (!has_future) {
[13:21:03.440]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:03.440]                             info)
[13:21:03.440]                         }
[13:21:03.440]                         else {
[13:21:03.440]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:03.440]                             info, version)
[13:21:03.440]                         }
[13:21:03.440]                         base::stop(msg)
[13:21:03.440]                       }
[13:21:03.440]                     })
[13:21:03.440]                   }
[13:21:03.440]                   options(future.plan = NULL)
[13:21:03.440]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.440]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:03.440]                 }
[13:21:03.440]                 ...future.workdir <- getwd()
[13:21:03.440]             }
[13:21:03.440]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:03.440]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:03.440]         }
[13:21:03.440]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:03.440]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:03.440]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:03.440]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:03.440]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:03.440]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:03.440]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:03.440]             base::names(...future.oldOptions))
[13:21:03.440]     }
[13:21:03.440]     if (FALSE) {
[13:21:03.440]     }
[13:21:03.440]     else {
[13:21:03.440]         if (TRUE) {
[13:21:03.440]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:03.440]                 open = "w")
[13:21:03.440]         }
[13:21:03.440]         else {
[13:21:03.440]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:03.440]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:03.440]         }
[13:21:03.440]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:03.440]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:03.440]             base::sink(type = "output", split = FALSE)
[13:21:03.440]             base::close(...future.stdout)
[13:21:03.440]         }, add = TRUE)
[13:21:03.440]     }
[13:21:03.440]     ...future.frame <- base::sys.nframe()
[13:21:03.440]     ...future.conditions <- base::list()
[13:21:03.440]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:03.440]     if (FALSE) {
[13:21:03.440]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:03.440]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:03.440]     }
[13:21:03.440]     ...future.result <- base::tryCatch({
[13:21:03.440]         base::withCallingHandlers({
[13:21:03.440]             ...future.value <- base::withVisible(base::local({
[13:21:03.440]                 a * b
[13:21:03.440]             }))
[13:21:03.440]             future::FutureResult(value = ...future.value$value, 
[13:21:03.440]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.440]                   ...future.rng), globalenv = if (FALSE) 
[13:21:03.440]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:03.440]                     ...future.globalenv.names))
[13:21:03.440]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:03.440]         }, condition = base::local({
[13:21:03.440]             c <- base::c
[13:21:03.440]             inherits <- base::inherits
[13:21:03.440]             invokeRestart <- base::invokeRestart
[13:21:03.440]             length <- base::length
[13:21:03.440]             list <- base::list
[13:21:03.440]             seq.int <- base::seq.int
[13:21:03.440]             signalCondition <- base::signalCondition
[13:21:03.440]             sys.calls <- base::sys.calls
[13:21:03.440]             `[[` <- base::`[[`
[13:21:03.440]             `+` <- base::`+`
[13:21:03.440]             `<<-` <- base::`<<-`
[13:21:03.440]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:03.440]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:03.440]                   3L)]
[13:21:03.440]             }
[13:21:03.440]             function(cond) {
[13:21:03.440]                 is_error <- inherits(cond, "error")
[13:21:03.440]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:03.440]                   NULL)
[13:21:03.440]                 if (is_error) {
[13:21:03.440]                   sessionInformation <- function() {
[13:21:03.440]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:03.440]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:03.440]                       search = base::search(), system = base::Sys.info())
[13:21:03.440]                   }
[13:21:03.440]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.440]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:03.440]                     cond$call), session = sessionInformation(), 
[13:21:03.440]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:03.440]                   signalCondition(cond)
[13:21:03.440]                 }
[13:21:03.440]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:03.440]                 "immediateCondition"))) {
[13:21:03.440]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:03.440]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.440]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:03.440]                   if (TRUE && !signal) {
[13:21:03.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.440]                     {
[13:21:03.440]                       inherits <- base::inherits
[13:21:03.440]                       invokeRestart <- base::invokeRestart
[13:21:03.440]                       is.null <- base::is.null
[13:21:03.440]                       muffled <- FALSE
[13:21:03.440]                       if (inherits(cond, "message")) {
[13:21:03.440]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.440]                         if (muffled) 
[13:21:03.440]                           invokeRestart("muffleMessage")
[13:21:03.440]                       }
[13:21:03.440]                       else if (inherits(cond, "warning")) {
[13:21:03.440]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.440]                         if (muffled) 
[13:21:03.440]                           invokeRestart("muffleWarning")
[13:21:03.440]                       }
[13:21:03.440]                       else if (inherits(cond, "condition")) {
[13:21:03.440]                         if (!is.null(pattern)) {
[13:21:03.440]                           computeRestarts <- base::computeRestarts
[13:21:03.440]                           grepl <- base::grepl
[13:21:03.440]                           restarts <- computeRestarts(cond)
[13:21:03.440]                           for (restart in restarts) {
[13:21:03.440]                             name <- restart$name
[13:21:03.440]                             if (is.null(name)) 
[13:21:03.440]                               next
[13:21:03.440]                             if (!grepl(pattern, name)) 
[13:21:03.440]                               next
[13:21:03.440]                             invokeRestart(restart)
[13:21:03.440]                             muffled <- TRUE
[13:21:03.440]                             break
[13:21:03.440]                           }
[13:21:03.440]                         }
[13:21:03.440]                       }
[13:21:03.440]                       invisible(muffled)
[13:21:03.440]                     }
[13:21:03.440]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.440]                   }
[13:21:03.440]                 }
[13:21:03.440]                 else {
[13:21:03.440]                   if (TRUE) {
[13:21:03.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.440]                     {
[13:21:03.440]                       inherits <- base::inherits
[13:21:03.440]                       invokeRestart <- base::invokeRestart
[13:21:03.440]                       is.null <- base::is.null
[13:21:03.440]                       muffled <- FALSE
[13:21:03.440]                       if (inherits(cond, "message")) {
[13:21:03.440]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.440]                         if (muffled) 
[13:21:03.440]                           invokeRestart("muffleMessage")
[13:21:03.440]                       }
[13:21:03.440]                       else if (inherits(cond, "warning")) {
[13:21:03.440]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.440]                         if (muffled) 
[13:21:03.440]                           invokeRestart("muffleWarning")
[13:21:03.440]                       }
[13:21:03.440]                       else if (inherits(cond, "condition")) {
[13:21:03.440]                         if (!is.null(pattern)) {
[13:21:03.440]                           computeRestarts <- base::computeRestarts
[13:21:03.440]                           grepl <- base::grepl
[13:21:03.440]                           restarts <- computeRestarts(cond)
[13:21:03.440]                           for (restart in restarts) {
[13:21:03.440]                             name <- restart$name
[13:21:03.440]                             if (is.null(name)) 
[13:21:03.440]                               next
[13:21:03.440]                             if (!grepl(pattern, name)) 
[13:21:03.440]                               next
[13:21:03.440]                             invokeRestart(restart)
[13:21:03.440]                             muffled <- TRUE
[13:21:03.440]                             break
[13:21:03.440]                           }
[13:21:03.440]                         }
[13:21:03.440]                       }
[13:21:03.440]                       invisible(muffled)
[13:21:03.440]                     }
[13:21:03.440]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.440]                   }
[13:21:03.440]                 }
[13:21:03.440]             }
[13:21:03.440]         }))
[13:21:03.440]     }, error = function(ex) {
[13:21:03.440]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:03.440]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.440]                 ...future.rng), started = ...future.startTime, 
[13:21:03.440]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:03.440]             version = "1.8"), class = "FutureResult")
[13:21:03.440]     }, finally = {
[13:21:03.440]         if (!identical(...future.workdir, getwd())) 
[13:21:03.440]             setwd(...future.workdir)
[13:21:03.440]         {
[13:21:03.440]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:03.440]                 ...future.oldOptions$nwarnings <- NULL
[13:21:03.440]             }
[13:21:03.440]             base::options(...future.oldOptions)
[13:21:03.440]             if (.Platform$OS.type == "windows") {
[13:21:03.440]                 old_names <- names(...future.oldEnvVars)
[13:21:03.440]                 envs <- base::Sys.getenv()
[13:21:03.440]                 names <- names(envs)
[13:21:03.440]                 common <- intersect(names, old_names)
[13:21:03.440]                 added <- setdiff(names, old_names)
[13:21:03.440]                 removed <- setdiff(old_names, names)
[13:21:03.440]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:03.440]                   envs[common]]
[13:21:03.440]                 NAMES <- toupper(changed)
[13:21:03.440]                 args <- list()
[13:21:03.440]                 for (kk in seq_along(NAMES)) {
[13:21:03.440]                   name <- changed[[kk]]
[13:21:03.440]                   NAME <- NAMES[[kk]]
[13:21:03.440]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.440]                     next
[13:21:03.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.440]                 }
[13:21:03.440]                 NAMES <- toupper(added)
[13:21:03.440]                 for (kk in seq_along(NAMES)) {
[13:21:03.440]                   name <- added[[kk]]
[13:21:03.440]                   NAME <- NAMES[[kk]]
[13:21:03.440]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.440]                     next
[13:21:03.440]                   args[[name]] <- ""
[13:21:03.440]                 }
[13:21:03.440]                 NAMES <- toupper(removed)
[13:21:03.440]                 for (kk in seq_along(NAMES)) {
[13:21:03.440]                   name <- removed[[kk]]
[13:21:03.440]                   NAME <- NAMES[[kk]]
[13:21:03.440]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.440]                     next
[13:21:03.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.440]                 }
[13:21:03.440]                 if (length(args) > 0) 
[13:21:03.440]                   base::do.call(base::Sys.setenv, args = args)
[13:21:03.440]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:03.440]             }
[13:21:03.440]             else {
[13:21:03.440]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:03.440]             }
[13:21:03.440]             {
[13:21:03.440]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:03.440]                   0L) {
[13:21:03.440]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:03.440]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:03.440]                   base::options(opts)
[13:21:03.440]                 }
[13:21:03.440]                 {
[13:21:03.440]                   {
[13:21:03.440]                     NULL
[13:21:03.440]                     RNGkind("Mersenne-Twister")
[13:21:03.440]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:03.440]                       inherits = FALSE)
[13:21:03.440]                   }
[13:21:03.440]                   options(future.plan = NULL)
[13:21:03.440]                   if (is.na(NA_character_)) 
[13:21:03.440]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.440]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:03.440]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:03.440]                     envir = parent.frame()) 
[13:21:03.440]                   {
[13:21:03.440]                     default_workers <- missing(workers)
[13:21:03.440]                     if (is.function(workers)) 
[13:21:03.440]                       workers <- workers()
[13:21:03.440]                     workers <- structure(as.integer(workers), 
[13:21:03.440]                       class = class(workers))
[13:21:03.440]                     stop_if_not(is.finite(workers), workers >= 
[13:21:03.440]                       1L)
[13:21:03.440]                     if ((workers == 1L && !inherits(workers, 
[13:21:03.440]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:03.440]                       if (default_workers) 
[13:21:03.440]                         supportsMulticore(warn = TRUE)
[13:21:03.440]                       return(sequential(..., envir = envir))
[13:21:03.440]                     }
[13:21:03.440]                     oopts <- options(mc.cores = workers)
[13:21:03.440]                     on.exit(options(oopts))
[13:21:03.440]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:03.440]                       envir = envir)
[13:21:03.440]                     if (!future$lazy) 
[13:21:03.440]                       future <- run(future)
[13:21:03.440]                     invisible(future)
[13:21:03.440]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:03.440]                 }
[13:21:03.440]             }
[13:21:03.440]         }
[13:21:03.440]     })
[13:21:03.440]     if (TRUE) {
[13:21:03.440]         base::sink(type = "output", split = FALSE)
[13:21:03.440]         if (TRUE) {
[13:21:03.440]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:03.440]         }
[13:21:03.440]         else {
[13:21:03.440]             ...future.result["stdout"] <- base::list(NULL)
[13:21:03.440]         }
[13:21:03.440]         base::close(...future.stdout)
[13:21:03.440]         ...future.stdout <- NULL
[13:21:03.440]     }
[13:21:03.440]     ...future.result$conditions <- ...future.conditions
[13:21:03.440]     ...future.result$finished <- base::Sys.time()
[13:21:03.440]     ...future.result
[13:21:03.440] }
[13:21:03.442] assign_globals() ...
[13:21:03.442] List of 2
[13:21:03.442]  $ a: num 2
[13:21:03.442]  $ b: num 3
[13:21:03.442]  - attr(*, "where")=List of 2
[13:21:03.442]   ..$ a:<environment: R_EmptyEnv> 
[13:21:03.442]   ..$ b:<environment: R_EmptyEnv> 
[13:21:03.442]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:03.442]  - attr(*, "resolved")= logi FALSE
[13:21:03.442]  - attr(*, "total_size")= num 112
[13:21:03.446] - copied ‘a’ to environment
[13:21:03.446] - copied ‘b’ to environment
[13:21:03.446] assign_globals() ... done
[13:21:03.446] plan(): Setting new future strategy stack:
[13:21:03.447] List of future strategies:
[13:21:03.447] 1. sequential:
[13:21:03.447]    - args: function (..., envir = parent.frame())
[13:21:03.447]    - tweaked: FALSE
[13:21:03.447]    - call: NULL
[13:21:03.447] plan(): nbrOfWorkers() = 1
[13:21:03.448] plan(): Setting new future strategy stack:
[13:21:03.448] List of future strategies:
[13:21:03.448] 1. multicore:
[13:21:03.448]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:03.448]    - tweaked: FALSE
[13:21:03.448]    - call: plan(multicore)
[13:21:03.451] plan(): nbrOfWorkers() = 1
[13:21:03.451] SequentialFuture started (and completed)
[1] 6
*** multicore(..., workers = 1L) ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
Number of workers: 2
*** multicore(..., globals = FALSE) without globals
[13:21:03.459] getGlobalsAndPackages() ...
[13:21:03.459] Not searching for globals
[13:21:03.459] - globals: [0] <none>
[13:21:03.459] getGlobalsAndPackages() ... DONE
[13:21:03.460] Packages needed by the future expression (n = 0): <none>
[13:21:03.460] Packages needed by future strategies (n = 0): <none>
[13:21:03.461] {
[13:21:03.461]     {
[13:21:03.461]         {
[13:21:03.461]             ...future.startTime <- base::Sys.time()
[13:21:03.461]             {
[13:21:03.461]                 {
[13:21:03.461]                   {
[13:21:03.461]                     {
[13:21:03.461]                       base::local({
[13:21:03.461]                         has_future <- base::requireNamespace("future", 
[13:21:03.461]                           quietly = TRUE)
[13:21:03.461]                         if (has_future) {
[13:21:03.461]                           ns <- base::getNamespace("future")
[13:21:03.461]                           version <- ns[[".package"]][["version"]]
[13:21:03.461]                           if (is.null(version)) 
[13:21:03.461]                             version <- utils::packageVersion("future")
[13:21:03.461]                         }
[13:21:03.461]                         else {
[13:21:03.461]                           version <- NULL
[13:21:03.461]                         }
[13:21:03.461]                         if (!has_future || version < "1.8.0") {
[13:21:03.461]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:03.461]                             "", base::R.version$version.string), 
[13:21:03.461]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:03.461]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:03.461]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:03.461]                               "release", "version")], collapse = " "), 
[13:21:03.461]                             hostname = base::Sys.info()[["nodename"]])
[13:21:03.461]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:03.461]                             info)
[13:21:03.461]                           info <- base::paste(info, collapse = "; ")
[13:21:03.461]                           if (!has_future) {
[13:21:03.461]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:03.461]                               info)
[13:21:03.461]                           }
[13:21:03.461]                           else {
[13:21:03.461]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:03.461]                               info, version)
[13:21:03.461]                           }
[13:21:03.461]                           base::stop(msg)
[13:21:03.461]                         }
[13:21:03.461]                       })
[13:21:03.461]                     }
[13:21:03.461]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:03.461]                     base::options(mc.cores = 1L)
[13:21:03.461]                   }
[13:21:03.461]                   options(future.plan = NULL)
[13:21:03.461]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.461]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:03.461]                 }
[13:21:03.461]                 ...future.workdir <- getwd()
[13:21:03.461]             }
[13:21:03.461]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:03.461]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:03.461]         }
[13:21:03.461]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:03.461]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:03.461]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:03.461]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:03.461]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:03.461]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:03.461]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:03.461]             base::names(...future.oldOptions))
[13:21:03.461]     }
[13:21:03.461]     if (FALSE) {
[13:21:03.461]     }
[13:21:03.461]     else {
[13:21:03.461]         if (TRUE) {
[13:21:03.461]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:03.461]                 open = "w")
[13:21:03.461]         }
[13:21:03.461]         else {
[13:21:03.461]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:03.461]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:03.461]         }
[13:21:03.461]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:03.461]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:03.461]             base::sink(type = "output", split = FALSE)
[13:21:03.461]             base::close(...future.stdout)
[13:21:03.461]         }, add = TRUE)
[13:21:03.461]     }
[13:21:03.461]     ...future.frame <- base::sys.nframe()
[13:21:03.461]     ...future.conditions <- base::list()
[13:21:03.461]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:03.461]     if (FALSE) {
[13:21:03.461]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:03.461]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:03.461]     }
[13:21:03.461]     ...future.result <- base::tryCatch({
[13:21:03.461]         base::withCallingHandlers({
[13:21:03.461]             ...future.value <- base::withVisible(base::local({
[13:21:03.461]                 withCallingHandlers({
[13:21:03.461]                   {
[13:21:03.461]                     42L
[13:21:03.461]                   }
[13:21:03.461]                 }, immediateCondition = function(cond) {
[13:21:03.461]                   save_rds <- function (object, pathname, ...) 
[13:21:03.461]                   {
[13:21:03.461]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:03.461]                     if (file_test("-f", pathname_tmp)) {
[13:21:03.461]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.461]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:03.461]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.461]                         fi_tmp[["mtime"]])
[13:21:03.461]                     }
[13:21:03.461]                     tryCatch({
[13:21:03.461]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:03.461]                     }, error = function(ex) {
[13:21:03.461]                       msg <- conditionMessage(ex)
[13:21:03.461]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.461]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:03.461]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.461]                         fi_tmp[["mtime"]], msg)
[13:21:03.461]                       ex$message <- msg
[13:21:03.461]                       stop(ex)
[13:21:03.461]                     })
[13:21:03.461]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:03.461]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:03.461]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:03.461]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.461]                       fi <- file.info(pathname)
[13:21:03.461]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:03.461]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.461]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:03.461]                         fi[["size"]], fi[["mtime"]])
[13:21:03.461]                       stop(msg)
[13:21:03.461]                     }
[13:21:03.461]                     invisible(pathname)
[13:21:03.461]                   }
[13:21:03.461]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:03.461]                     rootPath = tempdir()) 
[13:21:03.461]                   {
[13:21:03.461]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:03.461]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:03.461]                       tmpdir = path, fileext = ".rds")
[13:21:03.461]                     save_rds(obj, file)
[13:21:03.461]                   }
[13:21:03.461]                   saveImmediateCondition(cond, path = "/tmp/Rtmpd6Ly3I/.future/immediateConditions")
[13:21:03.461]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.461]                   {
[13:21:03.461]                     inherits <- base::inherits
[13:21:03.461]                     invokeRestart <- base::invokeRestart
[13:21:03.461]                     is.null <- base::is.null
[13:21:03.461]                     muffled <- FALSE
[13:21:03.461]                     if (inherits(cond, "message")) {
[13:21:03.461]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:03.461]                       if (muffled) 
[13:21:03.461]                         invokeRestart("muffleMessage")
[13:21:03.461]                     }
[13:21:03.461]                     else if (inherits(cond, "warning")) {
[13:21:03.461]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:03.461]                       if (muffled) 
[13:21:03.461]                         invokeRestart("muffleWarning")
[13:21:03.461]                     }
[13:21:03.461]                     else if (inherits(cond, "condition")) {
[13:21:03.461]                       if (!is.null(pattern)) {
[13:21:03.461]                         computeRestarts <- base::computeRestarts
[13:21:03.461]                         grepl <- base::grepl
[13:21:03.461]                         restarts <- computeRestarts(cond)
[13:21:03.461]                         for (restart in restarts) {
[13:21:03.461]                           name <- restart$name
[13:21:03.461]                           if (is.null(name)) 
[13:21:03.461]                             next
[13:21:03.461]                           if (!grepl(pattern, name)) 
[13:21:03.461]                             next
[13:21:03.461]                           invokeRestart(restart)
[13:21:03.461]                           muffled <- TRUE
[13:21:03.461]                           break
[13:21:03.461]                         }
[13:21:03.461]                       }
[13:21:03.461]                     }
[13:21:03.461]                     invisible(muffled)
[13:21:03.461]                   }
[13:21:03.461]                   muffleCondition(cond)
[13:21:03.461]                 })
[13:21:03.461]             }))
[13:21:03.461]             future::FutureResult(value = ...future.value$value, 
[13:21:03.461]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.461]                   ...future.rng), globalenv = if (FALSE) 
[13:21:03.461]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:03.461]                     ...future.globalenv.names))
[13:21:03.461]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:03.461]         }, condition = base::local({
[13:21:03.461]             c <- base::c
[13:21:03.461]             inherits <- base::inherits
[13:21:03.461]             invokeRestart <- base::invokeRestart
[13:21:03.461]             length <- base::length
[13:21:03.461]             list <- base::list
[13:21:03.461]             seq.int <- base::seq.int
[13:21:03.461]             signalCondition <- base::signalCondition
[13:21:03.461]             sys.calls <- base::sys.calls
[13:21:03.461]             `[[` <- base::`[[`
[13:21:03.461]             `+` <- base::`+`
[13:21:03.461]             `<<-` <- base::`<<-`
[13:21:03.461]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:03.461]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:03.461]                   3L)]
[13:21:03.461]             }
[13:21:03.461]             function(cond) {
[13:21:03.461]                 is_error <- inherits(cond, "error")
[13:21:03.461]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:03.461]                   NULL)
[13:21:03.461]                 if (is_error) {
[13:21:03.461]                   sessionInformation <- function() {
[13:21:03.461]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:03.461]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:03.461]                       search = base::search(), system = base::Sys.info())
[13:21:03.461]                   }
[13:21:03.461]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.461]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:03.461]                     cond$call), session = sessionInformation(), 
[13:21:03.461]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:03.461]                   signalCondition(cond)
[13:21:03.461]                 }
[13:21:03.461]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:03.461]                 "immediateCondition"))) {
[13:21:03.461]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:03.461]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.461]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:03.461]                   if (TRUE && !signal) {
[13:21:03.461]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.461]                     {
[13:21:03.461]                       inherits <- base::inherits
[13:21:03.461]                       invokeRestart <- base::invokeRestart
[13:21:03.461]                       is.null <- base::is.null
[13:21:03.461]                       muffled <- FALSE
[13:21:03.461]                       if (inherits(cond, "message")) {
[13:21:03.461]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.461]                         if (muffled) 
[13:21:03.461]                           invokeRestart("muffleMessage")
[13:21:03.461]                       }
[13:21:03.461]                       else if (inherits(cond, "warning")) {
[13:21:03.461]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.461]                         if (muffled) 
[13:21:03.461]                           invokeRestart("muffleWarning")
[13:21:03.461]                       }
[13:21:03.461]                       else if (inherits(cond, "condition")) {
[13:21:03.461]                         if (!is.null(pattern)) {
[13:21:03.461]                           computeRestarts <- base::computeRestarts
[13:21:03.461]                           grepl <- base::grepl
[13:21:03.461]                           restarts <- computeRestarts(cond)
[13:21:03.461]                           for (restart in restarts) {
[13:21:03.461]                             name <- restart$name
[13:21:03.461]                             if (is.null(name)) 
[13:21:03.461]                               next
[13:21:03.461]                             if (!grepl(pattern, name)) 
[13:21:03.461]                               next
[13:21:03.461]                             invokeRestart(restart)
[13:21:03.461]                             muffled <- TRUE
[13:21:03.461]                             break
[13:21:03.461]                           }
[13:21:03.461]                         }
[13:21:03.461]                       }
[13:21:03.461]                       invisible(muffled)
[13:21:03.461]                     }
[13:21:03.461]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.461]                   }
[13:21:03.461]                 }
[13:21:03.461]                 else {
[13:21:03.461]                   if (TRUE) {
[13:21:03.461]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.461]                     {
[13:21:03.461]                       inherits <- base::inherits
[13:21:03.461]                       invokeRestart <- base::invokeRestart
[13:21:03.461]                       is.null <- base::is.null
[13:21:03.461]                       muffled <- FALSE
[13:21:03.461]                       if (inherits(cond, "message")) {
[13:21:03.461]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.461]                         if (muffled) 
[13:21:03.461]                           invokeRestart("muffleMessage")
[13:21:03.461]                       }
[13:21:03.461]                       else if (inherits(cond, "warning")) {
[13:21:03.461]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.461]                         if (muffled) 
[13:21:03.461]                           invokeRestart("muffleWarning")
[13:21:03.461]                       }
[13:21:03.461]                       else if (inherits(cond, "condition")) {
[13:21:03.461]                         if (!is.null(pattern)) {
[13:21:03.461]                           computeRestarts <- base::computeRestarts
[13:21:03.461]                           grepl <- base::grepl
[13:21:03.461]                           restarts <- computeRestarts(cond)
[13:21:03.461]                           for (restart in restarts) {
[13:21:03.461]                             name <- restart$name
[13:21:03.461]                             if (is.null(name)) 
[13:21:03.461]                               next
[13:21:03.461]                             if (!grepl(pattern, name)) 
[13:21:03.461]                               next
[13:21:03.461]                             invokeRestart(restart)
[13:21:03.461]                             muffled <- TRUE
[13:21:03.461]                             break
[13:21:03.461]                           }
[13:21:03.461]                         }
[13:21:03.461]                       }
[13:21:03.461]                       invisible(muffled)
[13:21:03.461]                     }
[13:21:03.461]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.461]                   }
[13:21:03.461]                 }
[13:21:03.461]             }
[13:21:03.461]         }))
[13:21:03.461]     }, error = function(ex) {
[13:21:03.461]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:03.461]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.461]                 ...future.rng), started = ...future.startTime, 
[13:21:03.461]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:03.461]             version = "1.8"), class = "FutureResult")
[13:21:03.461]     }, finally = {
[13:21:03.461]         if (!identical(...future.workdir, getwd())) 
[13:21:03.461]             setwd(...future.workdir)
[13:21:03.461]         {
[13:21:03.461]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:03.461]                 ...future.oldOptions$nwarnings <- NULL
[13:21:03.461]             }
[13:21:03.461]             base::options(...future.oldOptions)
[13:21:03.461]             if (.Platform$OS.type == "windows") {
[13:21:03.461]                 old_names <- names(...future.oldEnvVars)
[13:21:03.461]                 envs <- base::Sys.getenv()
[13:21:03.461]                 names <- names(envs)
[13:21:03.461]                 common <- intersect(names, old_names)
[13:21:03.461]                 added <- setdiff(names, old_names)
[13:21:03.461]                 removed <- setdiff(old_names, names)
[13:21:03.461]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:03.461]                   envs[common]]
[13:21:03.461]                 NAMES <- toupper(changed)
[13:21:03.461]                 args <- list()
[13:21:03.461]                 for (kk in seq_along(NAMES)) {
[13:21:03.461]                   name <- changed[[kk]]
[13:21:03.461]                   NAME <- NAMES[[kk]]
[13:21:03.461]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.461]                     next
[13:21:03.461]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.461]                 }
[13:21:03.461]                 NAMES <- toupper(added)
[13:21:03.461]                 for (kk in seq_along(NAMES)) {
[13:21:03.461]                   name <- added[[kk]]
[13:21:03.461]                   NAME <- NAMES[[kk]]
[13:21:03.461]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.461]                     next
[13:21:03.461]                   args[[name]] <- ""
[13:21:03.461]                 }
[13:21:03.461]                 NAMES <- toupper(removed)
[13:21:03.461]                 for (kk in seq_along(NAMES)) {
[13:21:03.461]                   name <- removed[[kk]]
[13:21:03.461]                   NAME <- NAMES[[kk]]
[13:21:03.461]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.461]                     next
[13:21:03.461]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.461]                 }
[13:21:03.461]                 if (length(args) > 0) 
[13:21:03.461]                   base::do.call(base::Sys.setenv, args = args)
[13:21:03.461]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:03.461]             }
[13:21:03.461]             else {
[13:21:03.461]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:03.461]             }
[13:21:03.461]             {
[13:21:03.461]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:03.461]                   0L) {
[13:21:03.461]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:03.461]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:03.461]                   base::options(opts)
[13:21:03.461]                 }
[13:21:03.461]                 {
[13:21:03.461]                   {
[13:21:03.461]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:03.461]                     NULL
[13:21:03.461]                   }
[13:21:03.461]                   options(future.plan = NULL)
[13:21:03.461]                   if (is.na(NA_character_)) 
[13:21:03.461]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.461]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:03.461]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:03.461]                     envir = parent.frame()) 
[13:21:03.461]                   {
[13:21:03.461]                     default_workers <- missing(workers)
[13:21:03.461]                     if (is.function(workers)) 
[13:21:03.461]                       workers <- workers()
[13:21:03.461]                     workers <- structure(as.integer(workers), 
[13:21:03.461]                       class = class(workers))
[13:21:03.461]                     stop_if_not(is.finite(workers), workers >= 
[13:21:03.461]                       1L)
[13:21:03.461]                     if ((workers == 1L && !inherits(workers, 
[13:21:03.461]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:03.461]                       if (default_workers) 
[13:21:03.461]                         supportsMulticore(warn = TRUE)
[13:21:03.461]                       return(sequential(..., envir = envir))
[13:21:03.461]                     }
[13:21:03.461]                     oopts <- options(mc.cores = workers)
[13:21:03.461]                     on.exit(options(oopts))
[13:21:03.461]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:03.461]                       envir = envir)
[13:21:03.461]                     if (!future$lazy) 
[13:21:03.461]                       future <- run(future)
[13:21:03.461]                     invisible(future)
[13:21:03.461]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:03.461]                 }
[13:21:03.461]             }
[13:21:03.461]         }
[13:21:03.461]     })
[13:21:03.461]     if (TRUE) {
[13:21:03.461]         base::sink(type = "output", split = FALSE)
[13:21:03.461]         if (TRUE) {
[13:21:03.461]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:03.461]         }
[13:21:03.461]         else {
[13:21:03.461]             ...future.result["stdout"] <- base::list(NULL)
[13:21:03.461]         }
[13:21:03.461]         base::close(...future.stdout)
[13:21:03.461]         ...future.stdout <- NULL
[13:21:03.461]     }
[13:21:03.461]     ...future.result$conditions <- ...future.conditions
[13:21:03.461]     ...future.result$finished <- base::Sys.time()
[13:21:03.461]     ...future.result
[13:21:03.461] }
[13:21:03.463] requestCore(): workers = 2
[13:21:03.466] MulticoreFuture started
[13:21:03.467] plan(): Setting new future strategy stack:
[13:21:03.467] List of future strategies:
[13:21:03.467] 1. sequential:
[13:21:03.467]    - args: function (..., envir = parent.frame())
[13:21:03.467]    - tweaked: FALSE
[13:21:03.467]    - call: NULL
[13:21:03.468] plan(): nbrOfWorkers() = 1
[13:21:03.470] plan(): Setting new future strategy stack:
[13:21:03.470] List of future strategies:
[13:21:03.470] 1. multicore:
[13:21:03.470]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:03.470]    - tweaked: FALSE
[13:21:03.470]    - call: plan(multicore)
[13:21:03.475] plan(): nbrOfWorkers() = 2
[1] TRUE
[1] 42
*** multicore(..., globals = FALSE) with globals
[13:21:03.485] getGlobalsAndPackages() ...
[13:21:03.485] Not searching for globals
[13:21:03.485] - globals: [0] <none>
[13:21:03.485] getGlobalsAndPackages() ... DONE
[13:21:03.486] Packages needed by the future expression (n = 0): <none>
[13:21:03.486] Packages needed by future strategies (n = 0): <none>
[13:21:03.486] {
[13:21:03.486]     {
[13:21:03.486]         {
[13:21:03.486]             ...future.startTime <- base::Sys.time()
[13:21:03.486]             {
[13:21:03.486]                 {
[13:21:03.486]                   {
[13:21:03.486]                     {
[13:21:03.486]                       base::local({
[13:21:03.486]                         has_future <- base::requireNamespace("future", 
[13:21:03.486]                           quietly = TRUE)
[13:21:03.486]                         if (has_future) {
[13:21:03.486]                           ns <- base::getNamespace("future")
[13:21:03.486]                           version <- ns[[".package"]][["version"]]
[13:21:03.486]                           if (is.null(version)) 
[13:21:03.486]                             version <- utils::packageVersion("future")
[13:21:03.486]                         }
[13:21:03.486]                         else {
[13:21:03.486]                           version <- NULL
[13:21:03.486]                         }
[13:21:03.486]                         if (!has_future || version < "1.8.0") {
[13:21:03.486]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:03.486]                             "", base::R.version$version.string), 
[13:21:03.486]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:03.486]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:03.486]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:03.486]                               "release", "version")], collapse = " "), 
[13:21:03.486]                             hostname = base::Sys.info()[["nodename"]])
[13:21:03.486]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:03.486]                             info)
[13:21:03.486]                           info <- base::paste(info, collapse = "; ")
[13:21:03.486]                           if (!has_future) {
[13:21:03.486]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:03.486]                               info)
[13:21:03.486]                           }
[13:21:03.486]                           else {
[13:21:03.486]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:03.486]                               info, version)
[13:21:03.486]                           }
[13:21:03.486]                           base::stop(msg)
[13:21:03.486]                         }
[13:21:03.486]                       })
[13:21:03.486]                     }
[13:21:03.486]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:03.486]                     base::options(mc.cores = 1L)
[13:21:03.486]                   }
[13:21:03.486]                   options(future.plan = NULL)
[13:21:03.486]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.486]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:03.486]                 }
[13:21:03.486]                 ...future.workdir <- getwd()
[13:21:03.486]             }
[13:21:03.486]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:03.486]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:03.486]         }
[13:21:03.486]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:03.486]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:03.486]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:03.486]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:03.486]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:03.486]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:03.486]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:03.486]             base::names(...future.oldOptions))
[13:21:03.486]     }
[13:21:03.486]     if (FALSE) {
[13:21:03.486]     }
[13:21:03.486]     else {
[13:21:03.486]         if (TRUE) {
[13:21:03.486]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:03.486]                 open = "w")
[13:21:03.486]         }
[13:21:03.486]         else {
[13:21:03.486]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:03.486]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:03.486]         }
[13:21:03.486]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:03.486]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:03.486]             base::sink(type = "output", split = FALSE)
[13:21:03.486]             base::close(...future.stdout)
[13:21:03.486]         }, add = TRUE)
[13:21:03.486]     }
[13:21:03.486]     ...future.frame <- base::sys.nframe()
[13:21:03.486]     ...future.conditions <- base::list()
[13:21:03.486]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:03.486]     if (FALSE) {
[13:21:03.486]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:03.486]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:03.486]     }
[13:21:03.486]     ...future.result <- base::tryCatch({
[13:21:03.486]         base::withCallingHandlers({
[13:21:03.486]             ...future.value <- base::withVisible(base::local({
[13:21:03.486]                 withCallingHandlers({
[13:21:03.486]                   {
[13:21:03.486]                     b <- 3
[13:21:03.486]                     c <- 2
[13:21:03.486]                     a * b * c
[13:21:03.486]                   }
[13:21:03.486]                 }, immediateCondition = function(cond) {
[13:21:03.486]                   save_rds <- function (object, pathname, ...) 
[13:21:03.486]                   {
[13:21:03.486]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:03.486]                     if (file_test("-f", pathname_tmp)) {
[13:21:03.486]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.486]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:03.486]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.486]                         fi_tmp[["mtime"]])
[13:21:03.486]                     }
[13:21:03.486]                     tryCatch({
[13:21:03.486]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:03.486]                     }, error = function(ex) {
[13:21:03.486]                       msg <- conditionMessage(ex)
[13:21:03.486]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.486]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:03.486]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.486]                         fi_tmp[["mtime"]], msg)
[13:21:03.486]                       ex$message <- msg
[13:21:03.486]                       stop(ex)
[13:21:03.486]                     })
[13:21:03.486]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:03.486]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:03.486]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:03.486]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.486]                       fi <- file.info(pathname)
[13:21:03.486]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:03.486]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.486]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:03.486]                         fi[["size"]], fi[["mtime"]])
[13:21:03.486]                       stop(msg)
[13:21:03.486]                     }
[13:21:03.486]                     invisible(pathname)
[13:21:03.486]                   }
[13:21:03.486]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:03.486]                     rootPath = tempdir()) 
[13:21:03.486]                   {
[13:21:03.486]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:03.486]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:03.486]                       tmpdir = path, fileext = ".rds")
[13:21:03.486]                     save_rds(obj, file)
[13:21:03.486]                   }
[13:21:03.486]                   saveImmediateCondition(cond, path = "/tmp/Rtmpd6Ly3I/.future/immediateConditions")
[13:21:03.486]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.486]                   {
[13:21:03.486]                     inherits <- base::inherits
[13:21:03.486]                     invokeRestart <- base::invokeRestart
[13:21:03.486]                     is.null <- base::is.null
[13:21:03.486]                     muffled <- FALSE
[13:21:03.486]                     if (inherits(cond, "message")) {
[13:21:03.486]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:03.486]                       if (muffled) 
[13:21:03.486]                         invokeRestart("muffleMessage")
[13:21:03.486]                     }
[13:21:03.486]                     else if (inherits(cond, "warning")) {
[13:21:03.486]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:03.486]                       if (muffled) 
[13:21:03.486]                         invokeRestart("muffleWarning")
[13:21:03.486]                     }
[13:21:03.486]                     else if (inherits(cond, "condition")) {
[13:21:03.486]                       if (!is.null(pattern)) {
[13:21:03.486]                         computeRestarts <- base::computeRestarts
[13:21:03.486]                         grepl <- base::grepl
[13:21:03.486]                         restarts <- computeRestarts(cond)
[13:21:03.486]                         for (restart in restarts) {
[13:21:03.486]                           name <- restart$name
[13:21:03.486]                           if (is.null(name)) 
[13:21:03.486]                             next
[13:21:03.486]                           if (!grepl(pattern, name)) 
[13:21:03.486]                             next
[13:21:03.486]                           invokeRestart(restart)
[13:21:03.486]                           muffled <- TRUE
[13:21:03.486]                           break
[13:21:03.486]                         }
[13:21:03.486]                       }
[13:21:03.486]                     }
[13:21:03.486]                     invisible(muffled)
[13:21:03.486]                   }
[13:21:03.486]                   muffleCondition(cond)
[13:21:03.486]                 })
[13:21:03.486]             }))
[13:21:03.486]             future::FutureResult(value = ...future.value$value, 
[13:21:03.486]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.486]                   ...future.rng), globalenv = if (FALSE) 
[13:21:03.486]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:03.486]                     ...future.globalenv.names))
[13:21:03.486]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:03.486]         }, condition = base::local({
[13:21:03.486]             c <- base::c
[13:21:03.486]             inherits <- base::inherits
[13:21:03.486]             invokeRestart <- base::invokeRestart
[13:21:03.486]             length <- base::length
[13:21:03.486]             list <- base::list
[13:21:03.486]             seq.int <- base::seq.int
[13:21:03.486]             signalCondition <- base::signalCondition
[13:21:03.486]             sys.calls <- base::sys.calls
[13:21:03.486]             `[[` <- base::`[[`
[13:21:03.486]             `+` <- base::`+`
[13:21:03.486]             `<<-` <- base::`<<-`
[13:21:03.486]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:03.486]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:03.486]                   3L)]
[13:21:03.486]             }
[13:21:03.486]             function(cond) {
[13:21:03.486]                 is_error <- inherits(cond, "error")
[13:21:03.486]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:03.486]                   NULL)
[13:21:03.486]                 if (is_error) {
[13:21:03.486]                   sessionInformation <- function() {
[13:21:03.486]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:03.486]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:03.486]                       search = base::search(), system = base::Sys.info())
[13:21:03.486]                   }
[13:21:03.486]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.486]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:03.486]                     cond$call), session = sessionInformation(), 
[13:21:03.486]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:03.486]                   signalCondition(cond)
[13:21:03.486]                 }
[13:21:03.486]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:03.486]                 "immediateCondition"))) {
[13:21:03.486]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:03.486]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.486]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:03.486]                   if (TRUE && !signal) {
[13:21:03.486]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.486]                     {
[13:21:03.486]                       inherits <- base::inherits
[13:21:03.486]                       invokeRestart <- base::invokeRestart
[13:21:03.486]                       is.null <- base::is.null
[13:21:03.486]                       muffled <- FALSE
[13:21:03.486]                       if (inherits(cond, "message")) {
[13:21:03.486]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.486]                         if (muffled) 
[13:21:03.486]                           invokeRestart("muffleMessage")
[13:21:03.486]                       }
[13:21:03.486]                       else if (inherits(cond, "warning")) {
[13:21:03.486]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.486]                         if (muffled) 
[13:21:03.486]                           invokeRestart("muffleWarning")
[13:21:03.486]                       }
[13:21:03.486]                       else if (inherits(cond, "condition")) {
[13:21:03.486]                         if (!is.null(pattern)) {
[13:21:03.486]                           computeRestarts <- base::computeRestarts
[13:21:03.486]                           grepl <- base::grepl
[13:21:03.486]                           restarts <- computeRestarts(cond)
[13:21:03.486]                           for (restart in restarts) {
[13:21:03.486]                             name <- restart$name
[13:21:03.486]                             if (is.null(name)) 
[13:21:03.486]                               next
[13:21:03.486]                             if (!grepl(pattern, name)) 
[13:21:03.486]                               next
[13:21:03.486]                             invokeRestart(restart)
[13:21:03.486]                             muffled <- TRUE
[13:21:03.486]                             break
[13:21:03.486]                           }
[13:21:03.486]                         }
[13:21:03.486]                       }
[13:21:03.486]                       invisible(muffled)
[13:21:03.486]                     }
[13:21:03.486]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.486]                   }
[13:21:03.486]                 }
[13:21:03.486]                 else {
[13:21:03.486]                   if (TRUE) {
[13:21:03.486]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.486]                     {
[13:21:03.486]                       inherits <- base::inherits
[13:21:03.486]                       invokeRestart <- base::invokeRestart
[13:21:03.486]                       is.null <- base::is.null
[13:21:03.486]                       muffled <- FALSE
[13:21:03.486]                       if (inherits(cond, "message")) {
[13:21:03.486]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.486]                         if (muffled) 
[13:21:03.486]                           invokeRestart("muffleMessage")
[13:21:03.486]                       }
[13:21:03.486]                       else if (inherits(cond, "warning")) {
[13:21:03.486]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.486]                         if (muffled) 
[13:21:03.486]                           invokeRestart("muffleWarning")
[13:21:03.486]                       }
[13:21:03.486]                       else if (inherits(cond, "condition")) {
[13:21:03.486]                         if (!is.null(pattern)) {
[13:21:03.486]                           computeRestarts <- base::computeRestarts
[13:21:03.486]                           grepl <- base::grepl
[13:21:03.486]                           restarts <- computeRestarts(cond)
[13:21:03.486]                           for (restart in restarts) {
[13:21:03.486]                             name <- restart$name
[13:21:03.486]                             if (is.null(name)) 
[13:21:03.486]                               next
[13:21:03.486]                             if (!grepl(pattern, name)) 
[13:21:03.486]                               next
[13:21:03.486]                             invokeRestart(restart)
[13:21:03.486]                             muffled <- TRUE
[13:21:03.486]                             break
[13:21:03.486]                           }
[13:21:03.486]                         }
[13:21:03.486]                       }
[13:21:03.486]                       invisible(muffled)
[13:21:03.486]                     }
[13:21:03.486]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.486]                   }
[13:21:03.486]                 }
[13:21:03.486]             }
[13:21:03.486]         }))
[13:21:03.486]     }, error = function(ex) {
[13:21:03.486]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:03.486]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.486]                 ...future.rng), started = ...future.startTime, 
[13:21:03.486]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:03.486]             version = "1.8"), class = "FutureResult")
[13:21:03.486]     }, finally = {
[13:21:03.486]         if (!identical(...future.workdir, getwd())) 
[13:21:03.486]             setwd(...future.workdir)
[13:21:03.486]         {
[13:21:03.486]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:03.486]                 ...future.oldOptions$nwarnings <- NULL
[13:21:03.486]             }
[13:21:03.486]             base::options(...future.oldOptions)
[13:21:03.486]             if (.Platform$OS.type == "windows") {
[13:21:03.486]                 old_names <- names(...future.oldEnvVars)
[13:21:03.486]                 envs <- base::Sys.getenv()
[13:21:03.486]                 names <- names(envs)
[13:21:03.486]                 common <- intersect(names, old_names)
[13:21:03.486]                 added <- setdiff(names, old_names)
[13:21:03.486]                 removed <- setdiff(old_names, names)
[13:21:03.486]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:03.486]                   envs[common]]
[13:21:03.486]                 NAMES <- toupper(changed)
[13:21:03.486]                 args <- list()
[13:21:03.486]                 for (kk in seq_along(NAMES)) {
[13:21:03.486]                   name <- changed[[kk]]
[13:21:03.486]                   NAME <- NAMES[[kk]]
[13:21:03.486]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.486]                     next
[13:21:03.486]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.486]                 }
[13:21:03.486]                 NAMES <- toupper(added)
[13:21:03.486]                 for (kk in seq_along(NAMES)) {
[13:21:03.486]                   name <- added[[kk]]
[13:21:03.486]                   NAME <- NAMES[[kk]]
[13:21:03.486]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.486]                     next
[13:21:03.486]                   args[[name]] <- ""
[13:21:03.486]                 }
[13:21:03.486]                 NAMES <- toupper(removed)
[13:21:03.486]                 for (kk in seq_along(NAMES)) {
[13:21:03.486]                   name <- removed[[kk]]
[13:21:03.486]                   NAME <- NAMES[[kk]]
[13:21:03.486]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.486]                     next
[13:21:03.486]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.486]                 }
[13:21:03.486]                 if (length(args) > 0) 
[13:21:03.486]                   base::do.call(base::Sys.setenv, args = args)
[13:21:03.486]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:03.486]             }
[13:21:03.486]             else {
[13:21:03.486]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:03.486]             }
[13:21:03.486]             {
[13:21:03.486]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:03.486]                   0L) {
[13:21:03.486]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:03.486]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:03.486]                   base::options(opts)
[13:21:03.486]                 }
[13:21:03.486]                 {
[13:21:03.486]                   {
[13:21:03.486]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:03.486]                     NULL
[13:21:03.486]                   }
[13:21:03.486]                   options(future.plan = NULL)
[13:21:03.486]                   if (is.na(NA_character_)) 
[13:21:03.486]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.486]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:03.486]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:03.486]                     envir = parent.frame()) 
[13:21:03.486]                   {
[13:21:03.486]                     default_workers <- missing(workers)
[13:21:03.486]                     if (is.function(workers)) 
[13:21:03.486]                       workers <- workers()
[13:21:03.486]                     workers <- structure(as.integer(workers), 
[13:21:03.486]                       class = class(workers))
[13:21:03.486]                     stop_if_not(is.finite(workers), workers >= 
[13:21:03.486]                       1L)
[13:21:03.486]                     if ((workers == 1L && !inherits(workers, 
[13:21:03.486]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:03.486]                       if (default_workers) 
[13:21:03.486]                         supportsMulticore(warn = TRUE)
[13:21:03.486]                       return(sequential(..., envir = envir))
[13:21:03.486]                     }
[13:21:03.486]                     oopts <- options(mc.cores = workers)
[13:21:03.486]                     on.exit(options(oopts))
[13:21:03.486]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:03.486]                       envir = envir)
[13:21:03.486]                     if (!future$lazy) 
[13:21:03.486]                       future <- run(future)
[13:21:03.486]                     invisible(future)
[13:21:03.486]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:03.486]                 }
[13:21:03.486]             }
[13:21:03.486]         }
[13:21:03.486]     })
[13:21:03.486]     if (TRUE) {
[13:21:03.486]         base::sink(type = "output", split = FALSE)
[13:21:03.486]         if (TRUE) {
[13:21:03.486]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:03.486]         }
[13:21:03.486]         else {
[13:21:03.486]             ...future.result["stdout"] <- base::list(NULL)
[13:21:03.486]         }
[13:21:03.486]         base::close(...future.stdout)
[13:21:03.486]         ...future.stdout <- NULL
[13:21:03.486]     }
[13:21:03.486]     ...future.result$conditions <- ...future.conditions
[13:21:03.486]     ...future.result$finished <- base::Sys.time()
[13:21:03.486]     ...future.result
[13:21:03.486] }
[13:21:03.489] requestCore(): workers = 2
[13:21:03.491] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:03.492] plan(): Setting new future strategy stack:
[13:21:03.492] List of future strategies:
[13:21:03.492] 1. sequential:
[13:21:03.492]    - args: function (..., envir = parent.frame())
[13:21:03.492]    - tweaked: FALSE
[13:21:03.492]    - call: NULL
[13:21:03.493] plan(): nbrOfWorkers() = 1
[13:21:03.495] plan(): Setting new future strategy stack:
[13:21:03.495] List of future strategies:
[13:21:03.495] 1. multicore:
[13:21:03.495]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:03.495]    - tweaked: FALSE
[13:21:03.495]    - call: plan(multicore)
[13:21:03.500] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 32f7abe8-d290-272e-8911-a8ce072c31c3
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[1] 0
*** multicore(..., globals = FALSE) with globals and blocking
 - Creating multicore future #1 ...
[13:21:03.505] getGlobalsAndPackages() ...
[13:21:03.505] Not searching for globals
[13:21:03.506] - globals: [0] <none>
[13:21:03.506] getGlobalsAndPackages() ... DONE
[13:21:03.506] Packages needed by the future expression (n = 0): <none>
[13:21:03.506] Packages needed by future strategies (n = 0): <none>
[13:21:03.507] {
[13:21:03.507]     {
[13:21:03.507]         {
[13:21:03.507]             ...future.startTime <- base::Sys.time()
[13:21:03.507]             {
[13:21:03.507]                 {
[13:21:03.507]                   {
[13:21:03.507]                     {
[13:21:03.507]                       base::local({
[13:21:03.507]                         has_future <- base::requireNamespace("future", 
[13:21:03.507]                           quietly = TRUE)
[13:21:03.507]                         if (has_future) {
[13:21:03.507]                           ns <- base::getNamespace("future")
[13:21:03.507]                           version <- ns[[".package"]][["version"]]
[13:21:03.507]                           if (is.null(version)) 
[13:21:03.507]                             version <- utils::packageVersion("future")
[13:21:03.507]                         }
[13:21:03.507]                         else {
[13:21:03.507]                           version <- NULL
[13:21:03.507]                         }
[13:21:03.507]                         if (!has_future || version < "1.8.0") {
[13:21:03.507]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:03.507]                             "", base::R.version$version.string), 
[13:21:03.507]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:03.507]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:03.507]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:03.507]                               "release", "version")], collapse = " "), 
[13:21:03.507]                             hostname = base::Sys.info()[["nodename"]])
[13:21:03.507]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:03.507]                             info)
[13:21:03.507]                           info <- base::paste(info, collapse = "; ")
[13:21:03.507]                           if (!has_future) {
[13:21:03.507]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:03.507]                               info)
[13:21:03.507]                           }
[13:21:03.507]                           else {
[13:21:03.507]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:03.507]                               info, version)
[13:21:03.507]                           }
[13:21:03.507]                           base::stop(msg)
[13:21:03.507]                         }
[13:21:03.507]                       })
[13:21:03.507]                     }
[13:21:03.507]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:03.507]                     base::options(mc.cores = 1L)
[13:21:03.507]                   }
[13:21:03.507]                   options(future.plan = NULL)
[13:21:03.507]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.507]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:03.507]                 }
[13:21:03.507]                 ...future.workdir <- getwd()
[13:21:03.507]             }
[13:21:03.507]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:03.507]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:03.507]         }
[13:21:03.507]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:03.507]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:03.507]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:03.507]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:03.507]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:03.507]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:03.507]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:03.507]             base::names(...future.oldOptions))
[13:21:03.507]     }
[13:21:03.507]     if (FALSE) {
[13:21:03.507]     }
[13:21:03.507]     else {
[13:21:03.507]         if (TRUE) {
[13:21:03.507]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:03.507]                 open = "w")
[13:21:03.507]         }
[13:21:03.507]         else {
[13:21:03.507]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:03.507]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:03.507]         }
[13:21:03.507]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:03.507]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:03.507]             base::sink(type = "output", split = FALSE)
[13:21:03.507]             base::close(...future.stdout)
[13:21:03.507]         }, add = TRUE)
[13:21:03.507]     }
[13:21:03.507]     ...future.frame <- base::sys.nframe()
[13:21:03.507]     ...future.conditions <- base::list()
[13:21:03.507]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:03.507]     if (FALSE) {
[13:21:03.507]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:03.507]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:03.507]     }
[13:21:03.507]     ...future.result <- base::tryCatch({
[13:21:03.507]         base::withCallingHandlers({
[13:21:03.507]             ...future.value <- base::withVisible(base::local({
[13:21:03.507]                 withCallingHandlers({
[13:21:03.507]                   {
[13:21:03.507]                     ii
[13:21:03.507]                   }
[13:21:03.507]                 }, immediateCondition = function(cond) {
[13:21:03.507]                   save_rds <- function (object, pathname, ...) 
[13:21:03.507]                   {
[13:21:03.507]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:03.507]                     if (file_test("-f", pathname_tmp)) {
[13:21:03.507]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.507]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:03.507]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.507]                         fi_tmp[["mtime"]])
[13:21:03.507]                     }
[13:21:03.507]                     tryCatch({
[13:21:03.507]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:03.507]                     }, error = function(ex) {
[13:21:03.507]                       msg <- conditionMessage(ex)
[13:21:03.507]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.507]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:03.507]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.507]                         fi_tmp[["mtime"]], msg)
[13:21:03.507]                       ex$message <- msg
[13:21:03.507]                       stop(ex)
[13:21:03.507]                     })
[13:21:03.507]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:03.507]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:03.507]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:03.507]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.507]                       fi <- file.info(pathname)
[13:21:03.507]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:03.507]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.507]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:03.507]                         fi[["size"]], fi[["mtime"]])
[13:21:03.507]                       stop(msg)
[13:21:03.507]                     }
[13:21:03.507]                     invisible(pathname)
[13:21:03.507]                   }
[13:21:03.507]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:03.507]                     rootPath = tempdir()) 
[13:21:03.507]                   {
[13:21:03.507]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:03.507]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:03.507]                       tmpdir = path, fileext = ".rds")
[13:21:03.507]                     save_rds(obj, file)
[13:21:03.507]                   }
[13:21:03.507]                   saveImmediateCondition(cond, path = "/tmp/Rtmpd6Ly3I/.future/immediateConditions")
[13:21:03.507]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.507]                   {
[13:21:03.507]                     inherits <- base::inherits
[13:21:03.507]                     invokeRestart <- base::invokeRestart
[13:21:03.507]                     is.null <- base::is.null
[13:21:03.507]                     muffled <- FALSE
[13:21:03.507]                     if (inherits(cond, "message")) {
[13:21:03.507]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:03.507]                       if (muffled) 
[13:21:03.507]                         invokeRestart("muffleMessage")
[13:21:03.507]                     }
[13:21:03.507]                     else if (inherits(cond, "warning")) {
[13:21:03.507]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:03.507]                       if (muffled) 
[13:21:03.507]                         invokeRestart("muffleWarning")
[13:21:03.507]                     }
[13:21:03.507]                     else if (inherits(cond, "condition")) {
[13:21:03.507]                       if (!is.null(pattern)) {
[13:21:03.507]                         computeRestarts <- base::computeRestarts
[13:21:03.507]                         grepl <- base::grepl
[13:21:03.507]                         restarts <- computeRestarts(cond)
[13:21:03.507]                         for (restart in restarts) {
[13:21:03.507]                           name <- restart$name
[13:21:03.507]                           if (is.null(name)) 
[13:21:03.507]                             next
[13:21:03.507]                           if (!grepl(pattern, name)) 
[13:21:03.507]                             next
[13:21:03.507]                           invokeRestart(restart)
[13:21:03.507]                           muffled <- TRUE
[13:21:03.507]                           break
[13:21:03.507]                         }
[13:21:03.507]                       }
[13:21:03.507]                     }
[13:21:03.507]                     invisible(muffled)
[13:21:03.507]                   }
[13:21:03.507]                   muffleCondition(cond)
[13:21:03.507]                 })
[13:21:03.507]             }))
[13:21:03.507]             future::FutureResult(value = ...future.value$value, 
[13:21:03.507]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.507]                   ...future.rng), globalenv = if (FALSE) 
[13:21:03.507]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:03.507]                     ...future.globalenv.names))
[13:21:03.507]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:03.507]         }, condition = base::local({
[13:21:03.507]             c <- base::c
[13:21:03.507]             inherits <- base::inherits
[13:21:03.507]             invokeRestart <- base::invokeRestart
[13:21:03.507]             length <- base::length
[13:21:03.507]             list <- base::list
[13:21:03.507]             seq.int <- base::seq.int
[13:21:03.507]             signalCondition <- base::signalCondition
[13:21:03.507]             sys.calls <- base::sys.calls
[13:21:03.507]             `[[` <- base::`[[`
[13:21:03.507]             `+` <- base::`+`
[13:21:03.507]             `<<-` <- base::`<<-`
[13:21:03.507]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:03.507]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:03.507]                   3L)]
[13:21:03.507]             }
[13:21:03.507]             function(cond) {
[13:21:03.507]                 is_error <- inherits(cond, "error")
[13:21:03.507]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:03.507]                   NULL)
[13:21:03.507]                 if (is_error) {
[13:21:03.507]                   sessionInformation <- function() {
[13:21:03.507]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:03.507]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:03.507]                       search = base::search(), system = base::Sys.info())
[13:21:03.507]                   }
[13:21:03.507]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.507]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:03.507]                     cond$call), session = sessionInformation(), 
[13:21:03.507]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:03.507]                   signalCondition(cond)
[13:21:03.507]                 }
[13:21:03.507]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:03.507]                 "immediateCondition"))) {
[13:21:03.507]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:03.507]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.507]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:03.507]                   if (TRUE && !signal) {
[13:21:03.507]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.507]                     {
[13:21:03.507]                       inherits <- base::inherits
[13:21:03.507]                       invokeRestart <- base::invokeRestart
[13:21:03.507]                       is.null <- base::is.null
[13:21:03.507]                       muffled <- FALSE
[13:21:03.507]                       if (inherits(cond, "message")) {
[13:21:03.507]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.507]                         if (muffled) 
[13:21:03.507]                           invokeRestart("muffleMessage")
[13:21:03.507]                       }
[13:21:03.507]                       else if (inherits(cond, "warning")) {
[13:21:03.507]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.507]                         if (muffled) 
[13:21:03.507]                           invokeRestart("muffleWarning")
[13:21:03.507]                       }
[13:21:03.507]                       else if (inherits(cond, "condition")) {
[13:21:03.507]                         if (!is.null(pattern)) {
[13:21:03.507]                           computeRestarts <- base::computeRestarts
[13:21:03.507]                           grepl <- base::grepl
[13:21:03.507]                           restarts <- computeRestarts(cond)
[13:21:03.507]                           for (restart in restarts) {
[13:21:03.507]                             name <- restart$name
[13:21:03.507]                             if (is.null(name)) 
[13:21:03.507]                               next
[13:21:03.507]                             if (!grepl(pattern, name)) 
[13:21:03.507]                               next
[13:21:03.507]                             invokeRestart(restart)
[13:21:03.507]                             muffled <- TRUE
[13:21:03.507]                             break
[13:21:03.507]                           }
[13:21:03.507]                         }
[13:21:03.507]                       }
[13:21:03.507]                       invisible(muffled)
[13:21:03.507]                     }
[13:21:03.507]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.507]                   }
[13:21:03.507]                 }
[13:21:03.507]                 else {
[13:21:03.507]                   if (TRUE) {
[13:21:03.507]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.507]                     {
[13:21:03.507]                       inherits <- base::inherits
[13:21:03.507]                       invokeRestart <- base::invokeRestart
[13:21:03.507]                       is.null <- base::is.null
[13:21:03.507]                       muffled <- FALSE
[13:21:03.507]                       if (inherits(cond, "message")) {
[13:21:03.507]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.507]                         if (muffled) 
[13:21:03.507]                           invokeRestart("muffleMessage")
[13:21:03.507]                       }
[13:21:03.507]                       else if (inherits(cond, "warning")) {
[13:21:03.507]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.507]                         if (muffled) 
[13:21:03.507]                           invokeRestart("muffleWarning")
[13:21:03.507]                       }
[13:21:03.507]                       else if (inherits(cond, "condition")) {
[13:21:03.507]                         if (!is.null(pattern)) {
[13:21:03.507]                           computeRestarts <- base::computeRestarts
[13:21:03.507]                           grepl <- base::grepl
[13:21:03.507]                           restarts <- computeRestarts(cond)
[13:21:03.507]                           for (restart in restarts) {
[13:21:03.507]                             name <- restart$name
[13:21:03.507]                             if (is.null(name)) 
[13:21:03.507]                               next
[13:21:03.507]                             if (!grepl(pattern, name)) 
[13:21:03.507]                               next
[13:21:03.507]                             invokeRestart(restart)
[13:21:03.507]                             muffled <- TRUE
[13:21:03.507]                             break
[13:21:03.507]                           }
[13:21:03.507]                         }
[13:21:03.507]                       }
[13:21:03.507]                       invisible(muffled)
[13:21:03.507]                     }
[13:21:03.507]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.507]                   }
[13:21:03.507]                 }
[13:21:03.507]             }
[13:21:03.507]         }))
[13:21:03.507]     }, error = function(ex) {
[13:21:03.507]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:03.507]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.507]                 ...future.rng), started = ...future.startTime, 
[13:21:03.507]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:03.507]             version = "1.8"), class = "FutureResult")
[13:21:03.507]     }, finally = {
[13:21:03.507]         if (!identical(...future.workdir, getwd())) 
[13:21:03.507]             setwd(...future.workdir)
[13:21:03.507]         {
[13:21:03.507]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:03.507]                 ...future.oldOptions$nwarnings <- NULL
[13:21:03.507]             }
[13:21:03.507]             base::options(...future.oldOptions)
[13:21:03.507]             if (.Platform$OS.type == "windows") {
[13:21:03.507]                 old_names <- names(...future.oldEnvVars)
[13:21:03.507]                 envs <- base::Sys.getenv()
[13:21:03.507]                 names <- names(envs)
[13:21:03.507]                 common <- intersect(names, old_names)
[13:21:03.507]                 added <- setdiff(names, old_names)
[13:21:03.507]                 removed <- setdiff(old_names, names)
[13:21:03.507]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:03.507]                   envs[common]]
[13:21:03.507]                 NAMES <- toupper(changed)
[13:21:03.507]                 args <- list()
[13:21:03.507]                 for (kk in seq_along(NAMES)) {
[13:21:03.507]                   name <- changed[[kk]]
[13:21:03.507]                   NAME <- NAMES[[kk]]
[13:21:03.507]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.507]                     next
[13:21:03.507]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.507]                 }
[13:21:03.507]                 NAMES <- toupper(added)
[13:21:03.507]                 for (kk in seq_along(NAMES)) {
[13:21:03.507]                   name <- added[[kk]]
[13:21:03.507]                   NAME <- NAMES[[kk]]
[13:21:03.507]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.507]                     next
[13:21:03.507]                   args[[name]] <- ""
[13:21:03.507]                 }
[13:21:03.507]                 NAMES <- toupper(removed)
[13:21:03.507]                 for (kk in seq_along(NAMES)) {
[13:21:03.507]                   name <- removed[[kk]]
[13:21:03.507]                   NAME <- NAMES[[kk]]
[13:21:03.507]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.507]                     next
[13:21:03.507]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.507]                 }
[13:21:03.507]                 if (length(args) > 0) 
[13:21:03.507]                   base::do.call(base::Sys.setenv, args = args)
[13:21:03.507]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:03.507]             }
[13:21:03.507]             else {
[13:21:03.507]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:03.507]             }
[13:21:03.507]             {
[13:21:03.507]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:03.507]                   0L) {
[13:21:03.507]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:03.507]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:03.507]                   base::options(opts)
[13:21:03.507]                 }
[13:21:03.507]                 {
[13:21:03.507]                   {
[13:21:03.507]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:03.507]                     NULL
[13:21:03.507]                   }
[13:21:03.507]                   options(future.plan = NULL)
[13:21:03.507]                   if (is.na(NA_character_)) 
[13:21:03.507]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.507]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:03.507]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:03.507]                     envir = parent.frame()) 
[13:21:03.507]                   {
[13:21:03.507]                     default_workers <- missing(workers)
[13:21:03.507]                     if (is.function(workers)) 
[13:21:03.507]                       workers <- workers()
[13:21:03.507]                     workers <- structure(as.integer(workers), 
[13:21:03.507]                       class = class(workers))
[13:21:03.507]                     stop_if_not(is.finite(workers), workers >= 
[13:21:03.507]                       1L)
[13:21:03.507]                     if ((workers == 1L && !inherits(workers, 
[13:21:03.507]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:03.507]                       if (default_workers) 
[13:21:03.507]                         supportsMulticore(warn = TRUE)
[13:21:03.507]                       return(sequential(..., envir = envir))
[13:21:03.507]                     }
[13:21:03.507]                     oopts <- options(mc.cores = workers)
[13:21:03.507]                     on.exit(options(oopts))
[13:21:03.507]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:03.507]                       envir = envir)
[13:21:03.507]                     if (!future$lazy) 
[13:21:03.507]                       future <- run(future)
[13:21:03.507]                     invisible(future)
[13:21:03.507]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:03.507]                 }
[13:21:03.507]             }
[13:21:03.507]         }
[13:21:03.507]     })
[13:21:03.507]     if (TRUE) {
[13:21:03.507]         base::sink(type = "output", split = FALSE)
[13:21:03.507]         if (TRUE) {
[13:21:03.507]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:03.507]         }
[13:21:03.507]         else {
[13:21:03.507]             ...future.result["stdout"] <- base::list(NULL)
[13:21:03.507]         }
[13:21:03.507]         base::close(...future.stdout)
[13:21:03.507]         ...future.stdout <- NULL
[13:21:03.507]     }
[13:21:03.507]     ...future.result$conditions <- ...future.conditions
[13:21:03.507]     ...future.result$finished <- base::Sys.time()
[13:21:03.507]     ...future.result
[13:21:03.507] }
[13:21:03.510] requestCore(): workers = 2
[13:21:03.511] MulticoreFuture started
 - Creating multicore future #2 ...
[13:21:03.512] plan(): Setting new future strategy stack:
[13:21:03.513] List of future strategies:
[13:21:03.513] 1. sequential:
[13:21:03.513]    - args: function (..., envir = parent.frame())
[13:21:03.513]    - tweaked: FALSE
[13:21:03.513]    - call: NULL
[13:21:03.514] plan(): nbrOfWorkers() = 1
[13:21:03.515] plan(): Setting new future strategy stack:
[13:21:03.516] List of future strategies:
[13:21:03.516] 1. multicore:
[13:21:03.516]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:03.516]    - tweaked: FALSE
[13:21:03.516]    - call: plan(multicore)
[13:21:03.517] getGlobalsAndPackages() ...
[13:21:03.517] Not searching for globals
[13:21:03.518] - globals: [0] <none>
[13:21:03.518] getGlobalsAndPackages() ... DONE
[13:21:03.519] Packages needed by the future expression (n = 0): <none>
[13:21:03.519] Packages needed by future strategies (n = 0): <none>
[13:21:03.521] plan(): nbrOfWorkers() = 2
[13:21:03.520] {
[13:21:03.520]     {
[13:21:03.520]         {
[13:21:03.520]             ...future.startTime <- base::Sys.time()
[13:21:03.520]             {
[13:21:03.520]                 {
[13:21:03.520]                   {
[13:21:03.520]                     {
[13:21:03.520]                       base::local({
[13:21:03.520]                         has_future <- base::requireNamespace("future", 
[13:21:03.520]                           quietly = TRUE)
[13:21:03.520]                         if (has_future) {
[13:21:03.520]                           ns <- base::getNamespace("future")
[13:21:03.520]                           version <- ns[[".package"]][["version"]]
[13:21:03.520]                           if (is.null(version)) 
[13:21:03.520]                             version <- utils::packageVersion("future")
[13:21:03.520]                         }
[13:21:03.520]                         else {
[13:21:03.520]                           version <- NULL
[13:21:03.520]                         }
[13:21:03.520]                         if (!has_future || version < "1.8.0") {
[13:21:03.520]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:03.520]                             "", base::R.version$version.string), 
[13:21:03.520]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:03.520]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:03.520]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:03.520]                               "release", "version")], collapse = " "), 
[13:21:03.520]                             hostname = base::Sys.info()[["nodename"]])
[13:21:03.520]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:03.520]                             info)
[13:21:03.520]                           info <- base::paste(info, collapse = "; ")
[13:21:03.520]                           if (!has_future) {
[13:21:03.520]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:03.520]                               info)
[13:21:03.520]                           }
[13:21:03.520]                           else {
[13:21:03.520]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:03.520]                               info, version)
[13:21:03.520]                           }
[13:21:03.520]                           base::stop(msg)
[13:21:03.520]                         }
[13:21:03.520]                       })
[13:21:03.520]                     }
[13:21:03.520]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:03.520]                     base::options(mc.cores = 1L)
[13:21:03.520]                   }
[13:21:03.520]                   options(future.plan = NULL)
[13:21:03.520]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.520]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:03.520]                 }
[13:21:03.520]                 ...future.workdir <- getwd()
[13:21:03.520]             }
[13:21:03.520]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:03.520]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:03.520]         }
[13:21:03.520]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:03.520]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:03.520]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:03.520]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:03.520]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:03.520]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:03.520]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:03.520]             base::names(...future.oldOptions))
[13:21:03.520]     }
[13:21:03.520]     if (FALSE) {
[13:21:03.520]     }
[13:21:03.520]     else {
[13:21:03.520]         if (TRUE) {
[13:21:03.520]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:03.520]                 open = "w")
[13:21:03.520]         }
[13:21:03.520]         else {
[13:21:03.520]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:03.520]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:03.520]         }
[13:21:03.520]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:03.520]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:03.520]             base::sink(type = "output", split = FALSE)
[13:21:03.520]             base::close(...future.stdout)
[13:21:03.520]         }, add = TRUE)
[13:21:03.520]     }
[13:21:03.520]     ...future.frame <- base::sys.nframe()
[13:21:03.520]     ...future.conditions <- base::list()
[13:21:03.520]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:03.520]     if (FALSE) {
[13:21:03.520]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:03.520]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:03.520]     }
[13:21:03.520]     ...future.result <- base::tryCatch({
[13:21:03.520]         base::withCallingHandlers({
[13:21:03.520]             ...future.value <- base::withVisible(base::local({
[13:21:03.520]                 withCallingHandlers({
[13:21:03.520]                   {
[13:21:03.520]                     ii
[13:21:03.520]                   }
[13:21:03.520]                 }, immediateCondition = function(cond) {
[13:21:03.520]                   save_rds <- function (object, pathname, ...) 
[13:21:03.520]                   {
[13:21:03.520]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:03.520]                     if (file_test("-f", pathname_tmp)) {
[13:21:03.520]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.520]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:03.520]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.520]                         fi_tmp[["mtime"]])
[13:21:03.520]                     }
[13:21:03.520]                     tryCatch({
[13:21:03.520]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:03.520]                     }, error = function(ex) {
[13:21:03.520]                       msg <- conditionMessage(ex)
[13:21:03.520]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.520]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:03.520]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.520]                         fi_tmp[["mtime"]], msg)
[13:21:03.520]                       ex$message <- msg
[13:21:03.520]                       stop(ex)
[13:21:03.520]                     })
[13:21:03.520]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:03.520]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:03.520]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:03.520]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.520]                       fi <- file.info(pathname)
[13:21:03.520]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:03.520]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.520]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:03.520]                         fi[["size"]], fi[["mtime"]])
[13:21:03.520]                       stop(msg)
[13:21:03.520]                     }
[13:21:03.520]                     invisible(pathname)
[13:21:03.520]                   }
[13:21:03.520]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:03.520]                     rootPath = tempdir()) 
[13:21:03.520]                   {
[13:21:03.520]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:03.520]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:03.520]                       tmpdir = path, fileext = ".rds")
[13:21:03.520]                     save_rds(obj, file)
[13:21:03.520]                   }
[13:21:03.520]                   saveImmediateCondition(cond, path = "/tmp/Rtmpd6Ly3I/.future/immediateConditions")
[13:21:03.520]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.520]                   {
[13:21:03.520]                     inherits <- base::inherits
[13:21:03.520]                     invokeRestart <- base::invokeRestart
[13:21:03.520]                     is.null <- base::is.null
[13:21:03.520]                     muffled <- FALSE
[13:21:03.520]                     if (inherits(cond, "message")) {
[13:21:03.520]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:03.520]                       if (muffled) 
[13:21:03.520]                         invokeRestart("muffleMessage")
[13:21:03.520]                     }
[13:21:03.520]                     else if (inherits(cond, "warning")) {
[13:21:03.520]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:03.520]                       if (muffled) 
[13:21:03.520]                         invokeRestart("muffleWarning")
[13:21:03.520]                     }
[13:21:03.520]                     else if (inherits(cond, "condition")) {
[13:21:03.520]                       if (!is.null(pattern)) {
[13:21:03.520]                         computeRestarts <- base::computeRestarts
[13:21:03.520]                         grepl <- base::grepl
[13:21:03.520]                         restarts <- computeRestarts(cond)
[13:21:03.520]                         for (restart in restarts) {
[13:21:03.520]                           name <- restart$name
[13:21:03.520]                           if (is.null(name)) 
[13:21:03.520]                             next
[13:21:03.520]                           if (!grepl(pattern, name)) 
[13:21:03.520]                             next
[13:21:03.520]                           invokeRestart(restart)
[13:21:03.520]                           muffled <- TRUE
[13:21:03.520]                           break
[13:21:03.520]                         }
[13:21:03.520]                       }
[13:21:03.520]                     }
[13:21:03.520]                     invisible(muffled)
[13:21:03.520]                   }
[13:21:03.520]                   muffleCondition(cond)
[13:21:03.520]                 })
[13:21:03.520]             }))
[13:21:03.520]             future::FutureResult(value = ...future.value$value, 
[13:21:03.520]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.520]                   ...future.rng), globalenv = if (FALSE) 
[13:21:03.520]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:03.520]                     ...future.globalenv.names))
[13:21:03.520]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:03.520]         }, condition = base::local({
[13:21:03.520]             c <- base::c
[13:21:03.520]             inherits <- base::inherits
[13:21:03.520]             invokeRestart <- base::invokeRestart
[13:21:03.520]             length <- base::length
[13:21:03.520]             list <- base::list
[13:21:03.520]             seq.int <- base::seq.int
[13:21:03.520]             signalCondition <- base::signalCondition
[13:21:03.520]             sys.calls <- base::sys.calls
[13:21:03.520]             `[[` <- base::`[[`
[13:21:03.520]             `+` <- base::`+`
[13:21:03.520]             `<<-` <- base::`<<-`
[13:21:03.520]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:03.520]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:03.520]                   3L)]
[13:21:03.520]             }
[13:21:03.520]             function(cond) {
[13:21:03.520]                 is_error <- inherits(cond, "error")
[13:21:03.520]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:03.520]                   NULL)
[13:21:03.520]                 if (is_error) {
[13:21:03.520]                   sessionInformation <- function() {
[13:21:03.520]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:03.520]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:03.520]                       search = base::search(), system = base::Sys.info())
[13:21:03.520]                   }
[13:21:03.520]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.520]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:03.520]                     cond$call), session = sessionInformation(), 
[13:21:03.520]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:03.520]                   signalCondition(cond)
[13:21:03.520]                 }
[13:21:03.520]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:03.520]                 "immediateCondition"))) {
[13:21:03.520]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:03.520]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.520]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:03.520]                   if (TRUE && !signal) {
[13:21:03.520]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.520]                     {
[13:21:03.520]                       inherits <- base::inherits
[13:21:03.520]                       invokeRestart <- base::invokeRestart
[13:21:03.520]                       is.null <- base::is.null
[13:21:03.520]                       muffled <- FALSE
[13:21:03.520]                       if (inherits(cond, "message")) {
[13:21:03.520]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.520]                         if (muffled) 
[13:21:03.520]                           invokeRestart("muffleMessage")
[13:21:03.520]                       }
[13:21:03.520]                       else if (inherits(cond, "warning")) {
[13:21:03.520]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.520]                         if (muffled) 
[13:21:03.520]                           invokeRestart("muffleWarning")
[13:21:03.520]                       }
[13:21:03.520]                       else if (inherits(cond, "condition")) {
[13:21:03.520]                         if (!is.null(pattern)) {
[13:21:03.520]                           computeRestarts <- base::computeRestarts
[13:21:03.520]                           grepl <- base::grepl
[13:21:03.520]                           restarts <- computeRestarts(cond)
[13:21:03.520]                           for (restart in restarts) {
[13:21:03.520]                             name <- restart$name
[13:21:03.520]                             if (is.null(name)) 
[13:21:03.520]                               next
[13:21:03.520]                             if (!grepl(pattern, name)) 
[13:21:03.520]                               next
[13:21:03.520]                             invokeRestart(restart)
[13:21:03.520]                             muffled <- TRUE
[13:21:03.520]                             break
[13:21:03.520]                           }
[13:21:03.520]                         }
[13:21:03.520]                       }
[13:21:03.520]                       invisible(muffled)
[13:21:03.520]                     }
[13:21:03.520]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.520]                   }
[13:21:03.520]                 }
[13:21:03.520]                 else {
[13:21:03.520]                   if (TRUE) {
[13:21:03.520]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.520]                     {
[13:21:03.520]                       inherits <- base::inherits
[13:21:03.520]                       invokeRestart <- base::invokeRestart
[13:21:03.520]                       is.null <- base::is.null
[13:21:03.520]                       muffled <- FALSE
[13:21:03.520]                       if (inherits(cond, "message")) {
[13:21:03.520]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.520]                         if (muffled) 
[13:21:03.520]                           invokeRestart("muffleMessage")
[13:21:03.520]                       }
[13:21:03.520]                       else if (inherits(cond, "warning")) {
[13:21:03.520]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.520]                         if (muffled) 
[13:21:03.520]                           invokeRestart("muffleWarning")
[13:21:03.520]                       }
[13:21:03.520]                       else if (inherits(cond, "condition")) {
[13:21:03.520]                         if (!is.null(pattern)) {
[13:21:03.520]                           computeRestarts <- base::computeRestarts
[13:21:03.520]                           grepl <- base::grepl
[13:21:03.520]                           restarts <- computeRestarts(cond)
[13:21:03.520]                           for (restart in restarts) {
[13:21:03.520]                             name <- restart$name
[13:21:03.520]                             if (is.null(name)) 
[13:21:03.520]                               next
[13:21:03.520]                             if (!grepl(pattern, name)) 
[13:21:03.520]                               next
[13:21:03.520]                             invokeRestart(restart)
[13:21:03.520]                             muffled <- TRUE
[13:21:03.520]                             break
[13:21:03.520]                           }
[13:21:03.520]                         }
[13:21:03.520]                       }
[13:21:03.520]                       invisible(muffled)
[13:21:03.520]                     }
[13:21:03.520]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.520]                   }
[13:21:03.520]                 }
[13:21:03.520]             }
[13:21:03.520]         }))
[13:21:03.520]     }, error = function(ex) {
[13:21:03.520]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:03.520]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.520]                 ...future.rng), started = ...future.startTime, 
[13:21:03.520]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:03.520]             version = "1.8"), class = "FutureResult")
[13:21:03.520]     }, finally = {
[13:21:03.520]         if (!identical(...future.workdir, getwd())) 
[13:21:03.520]             setwd(...future.workdir)
[13:21:03.520]         {
[13:21:03.520]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:03.520]                 ...future.oldOptions$nwarnings <- NULL
[13:21:03.520]             }
[13:21:03.520]             base::options(...future.oldOptions)
[13:21:03.520]             if (.Platform$OS.type == "windows") {
[13:21:03.520]                 old_names <- names(...future.oldEnvVars)
[13:21:03.520]                 envs <- base::Sys.getenv()
[13:21:03.520]                 names <- names(envs)
[13:21:03.520]                 common <- intersect(names, old_names)
[13:21:03.520]                 added <- setdiff(names, old_names)
[13:21:03.520]                 removed <- setdiff(old_names, names)
[13:21:03.520]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:03.520]                   envs[common]]
[13:21:03.520]                 NAMES <- toupper(changed)
[13:21:03.520]                 args <- list()
[13:21:03.520]                 for (kk in seq_along(NAMES)) {
[13:21:03.520]                   name <- changed[[kk]]
[13:21:03.520]                   NAME <- NAMES[[kk]]
[13:21:03.520]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.520]                     next
[13:21:03.520]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.520]                 }
[13:21:03.520]                 NAMES <- toupper(added)
[13:21:03.520]                 for (kk in seq_along(NAMES)) {
[13:21:03.520]                   name <- added[[kk]]
[13:21:03.520]                   NAME <- NAMES[[kk]]
[13:21:03.520]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.520]                     next
[13:21:03.520]                   args[[name]] <- ""
[13:21:03.520]                 }
[13:21:03.520]                 NAMES <- toupper(removed)
[13:21:03.520]                 for (kk in seq_along(NAMES)) {
[13:21:03.520]                   name <- removed[[kk]]
[13:21:03.520]                   NAME <- NAMES[[kk]]
[13:21:03.520]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.520]                     next
[13:21:03.520]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.520]                 }
[13:21:03.520]                 if (length(args) > 0) 
[13:21:03.520]                   base::do.call(base::Sys.setenv, args = args)
[13:21:03.520]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:03.520]             }
[13:21:03.520]             else {
[13:21:03.520]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:03.520]             }
[13:21:03.520]             {
[13:21:03.520]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:03.520]                   0L) {
[13:21:03.520]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:03.520]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:03.520]                   base::options(opts)
[13:21:03.520]                 }
[13:21:03.520]                 {
[13:21:03.520]                   {
[13:21:03.520]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:03.520]                     NULL
[13:21:03.520]                   }
[13:21:03.520]                   options(future.plan = NULL)
[13:21:03.520]                   if (is.na(NA_character_)) 
[13:21:03.520]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.520]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:03.520]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:03.520]                     envir = parent.frame()) 
[13:21:03.520]                   {
[13:21:03.520]                     default_workers <- missing(workers)
[13:21:03.520]                     if (is.function(workers)) 
[13:21:03.520]                       workers <- workers()
[13:21:03.520]                     workers <- structure(as.integer(workers), 
[13:21:03.520]                       class = class(workers))
[13:21:03.520]                     stop_if_not(is.finite(workers), workers >= 
[13:21:03.520]                       1L)
[13:21:03.520]                     if ((workers == 1L && !inherits(workers, 
[13:21:03.520]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:03.520]                       if (default_workers) 
[13:21:03.520]                         supportsMulticore(warn = TRUE)
[13:21:03.520]                       return(sequential(..., envir = envir))
[13:21:03.520]                     }
[13:21:03.520]                     oopts <- options(mc.cores = workers)
[13:21:03.520]                     on.exit(options(oopts))
[13:21:03.520]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:03.520]                       envir = envir)
[13:21:03.520]                     if (!future$lazy) 
[13:21:03.520]                       future <- run(future)
[13:21:03.520]                     invisible(future)
[13:21:03.520]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:03.520]                 }
[13:21:03.520]             }
[13:21:03.520]         }
[13:21:03.520]     })
[13:21:03.520]     if (TRUE) {
[13:21:03.520]         base::sink(type = "output", split = FALSE)
[13:21:03.520]         if (TRUE) {
[13:21:03.520]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:03.520]         }
[13:21:03.520]         else {
[13:21:03.520]             ...future.result["stdout"] <- base::list(NULL)
[13:21:03.520]         }
[13:21:03.520]         base::close(...future.stdout)
[13:21:03.520]         ...future.stdout <- NULL
[13:21:03.520]     }
[13:21:03.520]     ...future.result$conditions <- ...future.conditions
[13:21:03.520]     ...future.result$finished <- base::Sys.time()
[13:21:03.520]     ...future.result
[13:21:03.520] }
[13:21:03.523] requestCore(): workers = 2
[13:21:03.525] MulticoreFuture started
 - Creating multicore future #3 ...
[13:21:03.526] plan(): Setting new future strategy stack:
[13:21:03.527] List of future strategies:
[13:21:03.527] 1. sequential:
[13:21:03.527]    - args: function (..., envir = parent.frame())
[13:21:03.527]    - tweaked: FALSE
[13:21:03.527]    - call: NULL
[13:21:03.528] plan(): nbrOfWorkers() = 1
[13:21:03.529] plan(): Setting new future strategy stack:
[13:21:03.530] List of future strategies:
[13:21:03.530] 1. multicore:
[13:21:03.530]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:03.530]    - tweaked: FALSE
[13:21:03.530]    - call: plan(multicore)
[13:21:03.532] getGlobalsAndPackages() ...
[13:21:03.532] Not searching for globals
[13:21:03.532] - globals: [0] <none>
[13:21:03.532] getGlobalsAndPackages() ... DONE
[13:21:03.540] Packages needed by the future expression (n = 0): <none>
[13:21:03.540] Packages needed by future strategies (n = 0): <none>
[13:21:03.544] plan(): nbrOfWorkers() = 2
[13:21:03.541] {
[13:21:03.541]     {
[13:21:03.541]         {
[13:21:03.541]             ...future.startTime <- base::Sys.time()
[13:21:03.541]             {
[13:21:03.541]                 {
[13:21:03.541]                   {
[13:21:03.541]                     {
[13:21:03.541]                       base::local({
[13:21:03.541]                         has_future <- base::requireNamespace("future", 
[13:21:03.541]                           quietly = TRUE)
[13:21:03.541]                         if (has_future) {
[13:21:03.541]                           ns <- base::getNamespace("future")
[13:21:03.541]                           version <- ns[[".package"]][["version"]]
[13:21:03.541]                           if (is.null(version)) 
[13:21:03.541]                             version <- utils::packageVersion("future")
[13:21:03.541]                         }
[13:21:03.541]                         else {
[13:21:03.541]                           version <- NULL
[13:21:03.541]                         }
[13:21:03.541]                         if (!has_future || version < "1.8.0") {
[13:21:03.541]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:03.541]                             "", base::R.version$version.string), 
[13:21:03.541]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:03.541]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:03.541]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:03.541]                               "release", "version")], collapse = " "), 
[13:21:03.541]                             hostname = base::Sys.info()[["nodename"]])
[13:21:03.541]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:03.541]                             info)
[13:21:03.541]                           info <- base::paste(info, collapse = "; ")
[13:21:03.541]                           if (!has_future) {
[13:21:03.541]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:03.541]                               info)
[13:21:03.541]                           }
[13:21:03.541]                           else {
[13:21:03.541]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:03.541]                               info, version)
[13:21:03.541]                           }
[13:21:03.541]                           base::stop(msg)
[13:21:03.541]                         }
[13:21:03.541]                       })
[13:21:03.541]                     }
[13:21:03.541]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:03.541]                     base::options(mc.cores = 1L)
[13:21:03.541]                   }
[13:21:03.541]                   options(future.plan = NULL)
[13:21:03.541]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.541]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:03.541]                 }
[13:21:03.541]                 ...future.workdir <- getwd()
[13:21:03.541]             }
[13:21:03.541]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:03.541]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:03.541]         }
[13:21:03.541]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:03.541]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:03.541]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:03.541]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:03.541]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:03.541]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:03.541]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:03.541]             base::names(...future.oldOptions))
[13:21:03.541]     }
[13:21:03.541]     if (FALSE) {
[13:21:03.541]     }
[13:21:03.541]     else {
[13:21:03.541]         if (TRUE) {
[13:21:03.541]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:03.541]                 open = "w")
[13:21:03.541]         }
[13:21:03.541]         else {
[13:21:03.541]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:03.541]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:03.541]         }
[13:21:03.541]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:03.541]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:03.541]             base::sink(type = "output", split = FALSE)
[13:21:03.541]             base::close(...future.stdout)
[13:21:03.541]         }, add = TRUE)
[13:21:03.541]     }
[13:21:03.541]     ...future.frame <- base::sys.nframe()
[13:21:03.541]     ...future.conditions <- base::list()
[13:21:03.541]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:03.541]     if (FALSE) {
[13:21:03.541]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:03.541]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:03.541]     }
[13:21:03.541]     ...future.result <- base::tryCatch({
[13:21:03.541]         base::withCallingHandlers({
[13:21:03.541]             ...future.value <- base::withVisible(base::local({
[13:21:03.541]                 withCallingHandlers({
[13:21:03.541]                   {
[13:21:03.541]                     ii
[13:21:03.541]                   }
[13:21:03.541]                 }, immediateCondition = function(cond) {
[13:21:03.541]                   save_rds <- function (object, pathname, ...) 
[13:21:03.541]                   {
[13:21:03.541]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:03.541]                     if (file_test("-f", pathname_tmp)) {
[13:21:03.541]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.541]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:03.541]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.541]                         fi_tmp[["mtime"]])
[13:21:03.541]                     }
[13:21:03.541]                     tryCatch({
[13:21:03.541]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:03.541]                     }, error = function(ex) {
[13:21:03.541]                       msg <- conditionMessage(ex)
[13:21:03.541]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.541]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:03.541]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.541]                         fi_tmp[["mtime"]], msg)
[13:21:03.541]                       ex$message <- msg
[13:21:03.541]                       stop(ex)
[13:21:03.541]                     })
[13:21:03.541]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:03.541]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:03.541]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:03.541]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.541]                       fi <- file.info(pathname)
[13:21:03.541]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:03.541]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.541]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:03.541]                         fi[["size"]], fi[["mtime"]])
[13:21:03.541]                       stop(msg)
[13:21:03.541]                     }
[13:21:03.541]                     invisible(pathname)
[13:21:03.541]                   }
[13:21:03.541]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:03.541]                     rootPath = tempdir()) 
[13:21:03.541]                   {
[13:21:03.541]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:03.541]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:03.541]                       tmpdir = path, fileext = ".rds")
[13:21:03.541]                     save_rds(obj, file)
[13:21:03.541]                   }
[13:21:03.541]                   saveImmediateCondition(cond, path = "/tmp/Rtmpd6Ly3I/.future/immediateConditions")
[13:21:03.541]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.541]                   {
[13:21:03.541]                     inherits <- base::inherits
[13:21:03.541]                     invokeRestart <- base::invokeRestart
[13:21:03.541]                     is.null <- base::is.null
[13:21:03.541]                     muffled <- FALSE
[13:21:03.541]                     if (inherits(cond, "message")) {
[13:21:03.541]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:03.541]                       if (muffled) 
[13:21:03.541]                         invokeRestart("muffleMessage")
[13:21:03.541]                     }
[13:21:03.541]                     else if (inherits(cond, "warning")) {
[13:21:03.541]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:03.541]                       if (muffled) 
[13:21:03.541]                         invokeRestart("muffleWarning")
[13:21:03.541]                     }
[13:21:03.541]                     else if (inherits(cond, "condition")) {
[13:21:03.541]                       if (!is.null(pattern)) {
[13:21:03.541]                         computeRestarts <- base::computeRestarts
[13:21:03.541]                         grepl <- base::grepl
[13:21:03.541]                         restarts <- computeRestarts(cond)
[13:21:03.541]                         for (restart in restarts) {
[13:21:03.541]                           name <- restart$name
[13:21:03.541]                           if (is.null(name)) 
[13:21:03.541]                             next
[13:21:03.541]                           if (!grepl(pattern, name)) 
[13:21:03.541]                             next
[13:21:03.541]                           invokeRestart(restart)
[13:21:03.541]                           muffled <- TRUE
[13:21:03.541]                           break
[13:21:03.541]                         }
[13:21:03.541]                       }
[13:21:03.541]                     }
[13:21:03.541]                     invisible(muffled)
[13:21:03.541]                   }
[13:21:03.541]                   muffleCondition(cond)
[13:21:03.541]                 })
[13:21:03.541]             }))
[13:21:03.541]             future::FutureResult(value = ...future.value$value, 
[13:21:03.541]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.541]                   ...future.rng), globalenv = if (FALSE) 
[13:21:03.541]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:03.541]                     ...future.globalenv.names))
[13:21:03.541]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:03.541]         }, condition = base::local({
[13:21:03.541]             c <- base::c
[13:21:03.541]             inherits <- base::inherits
[13:21:03.541]             invokeRestart <- base::invokeRestart
[13:21:03.541]             length <- base::length
[13:21:03.541]             list <- base::list
[13:21:03.541]             seq.int <- base::seq.int
[13:21:03.541]             signalCondition <- base::signalCondition
[13:21:03.541]             sys.calls <- base::sys.calls
[13:21:03.541]             `[[` <- base::`[[`
[13:21:03.541]             `+` <- base::`+`
[13:21:03.541]             `<<-` <- base::`<<-`
[13:21:03.541]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:03.541]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:03.541]                   3L)]
[13:21:03.541]             }
[13:21:03.541]             function(cond) {
[13:21:03.541]                 is_error <- inherits(cond, "error")
[13:21:03.541]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:03.541]                   NULL)
[13:21:03.541]                 if (is_error) {
[13:21:03.541]                   sessionInformation <- function() {
[13:21:03.541]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:03.541]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:03.541]                       search = base::search(), system = base::Sys.info())
[13:21:03.541]                   }
[13:21:03.541]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.541]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:03.541]                     cond$call), session = sessionInformation(), 
[13:21:03.541]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:03.541]                   signalCondition(cond)
[13:21:03.541]                 }
[13:21:03.541]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:03.541]                 "immediateCondition"))) {
[13:21:03.541]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:03.541]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.541]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:03.541]                   if (TRUE && !signal) {
[13:21:03.541]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.541]                     {
[13:21:03.541]                       inherits <- base::inherits
[13:21:03.541]                       invokeRestart <- base::invokeRestart
[13:21:03.541]                       is.null <- base::is.null
[13:21:03.541]                       muffled <- FALSE
[13:21:03.541]                       if (inherits(cond, "message")) {
[13:21:03.541]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.541]                         if (muffled) 
[13:21:03.541]                           invokeRestart("muffleMessage")
[13:21:03.541]                       }
[13:21:03.541]                       else if (inherits(cond, "warning")) {
[13:21:03.541]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.541]                         if (muffled) 
[13:21:03.541]                           invokeRestart("muffleWarning")
[13:21:03.541]                       }
[13:21:03.541]                       else if (inherits(cond, "condition")) {
[13:21:03.541]                         if (!is.null(pattern)) {
[13:21:03.541]                           computeRestarts <- base::computeRestarts
[13:21:03.541]                           grepl <- base::grepl
[13:21:03.541]                           restarts <- computeRestarts(cond)
[13:21:03.541]                           for (restart in restarts) {
[13:21:03.541]                             name <- restart$name
[13:21:03.541]                             if (is.null(name)) 
[13:21:03.541]                               next
[13:21:03.541]                             if (!grepl(pattern, name)) 
[13:21:03.541]                               next
[13:21:03.541]                             invokeRestart(restart)
[13:21:03.541]                             muffled <- TRUE
[13:21:03.541]                             break
[13:21:03.541]                           }
[13:21:03.541]                         }
[13:21:03.541]                       }
[13:21:03.541]                       invisible(muffled)
[13:21:03.541]                     }
[13:21:03.541]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.541]                   }
[13:21:03.541]                 }
[13:21:03.541]                 else {
[13:21:03.541]                   if (TRUE) {
[13:21:03.541]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.541]                     {
[13:21:03.541]                       inherits <- base::inherits
[13:21:03.541]                       invokeRestart <- base::invokeRestart
[13:21:03.541]                       is.null <- base::is.null
[13:21:03.541]                       muffled <- FALSE
[13:21:03.541]                       if (inherits(cond, "message")) {
[13:21:03.541]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.541]                         if (muffled) 
[13:21:03.541]                           invokeRestart("muffleMessage")
[13:21:03.541]                       }
[13:21:03.541]                       else if (inherits(cond, "warning")) {
[13:21:03.541]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.541]                         if (muffled) 
[13:21:03.541]                           invokeRestart("muffleWarning")
[13:21:03.541]                       }
[13:21:03.541]                       else if (inherits(cond, "condition")) {
[13:21:03.541]                         if (!is.null(pattern)) {
[13:21:03.541]                           computeRestarts <- base::computeRestarts
[13:21:03.541]                           grepl <- base::grepl
[13:21:03.541]                           restarts <- computeRestarts(cond)
[13:21:03.541]                           for (restart in restarts) {
[13:21:03.541]                             name <- restart$name
[13:21:03.541]                             if (is.null(name)) 
[13:21:03.541]                               next
[13:21:03.541]                             if (!grepl(pattern, name)) 
[13:21:03.541]                               next
[13:21:03.541]                             invokeRestart(restart)
[13:21:03.541]                             muffled <- TRUE
[13:21:03.541]                             break
[13:21:03.541]                           }
[13:21:03.541]                         }
[13:21:03.541]                       }
[13:21:03.541]                       invisible(muffled)
[13:21:03.541]                     }
[13:21:03.541]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.541]                   }
[13:21:03.541]                 }
[13:21:03.541]             }
[13:21:03.541]         }))
[13:21:03.541]     }, error = function(ex) {
[13:21:03.541]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:03.541]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.541]                 ...future.rng), started = ...future.startTime, 
[13:21:03.541]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:03.541]             version = "1.8"), class = "FutureResult")
[13:21:03.541]     }, finally = {
[13:21:03.541]         if (!identical(...future.workdir, getwd())) 
[13:21:03.541]             setwd(...future.workdir)
[13:21:03.541]         {
[13:21:03.541]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:03.541]                 ...future.oldOptions$nwarnings <- NULL
[13:21:03.541]             }
[13:21:03.541]             base::options(...future.oldOptions)
[13:21:03.541]             if (.Platform$OS.type == "windows") {
[13:21:03.541]                 old_names <- names(...future.oldEnvVars)
[13:21:03.541]                 envs <- base::Sys.getenv()
[13:21:03.541]                 names <- names(envs)
[13:21:03.541]                 common <- intersect(names, old_names)
[13:21:03.541]                 added <- setdiff(names, old_names)
[13:21:03.541]                 removed <- setdiff(old_names, names)
[13:21:03.541]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:03.541]                   envs[common]]
[13:21:03.541]                 NAMES <- toupper(changed)
[13:21:03.541]                 args <- list()
[13:21:03.541]                 for (kk in seq_along(NAMES)) {
[13:21:03.541]                   name <- changed[[kk]]
[13:21:03.541]                   NAME <- NAMES[[kk]]
[13:21:03.541]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.541]                     next
[13:21:03.541]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.541]                 }
[13:21:03.541]                 NAMES <- toupper(added)
[13:21:03.541]                 for (kk in seq_along(NAMES)) {
[13:21:03.541]                   name <- added[[kk]]
[13:21:03.541]                   NAME <- NAMES[[kk]]
[13:21:03.541]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.541]                     next
[13:21:03.541]                   args[[name]] <- ""
[13:21:03.541]                 }
[13:21:03.541]                 NAMES <- toupper(removed)
[13:21:03.541]                 for (kk in seq_along(NAMES)) {
[13:21:03.541]                   name <- removed[[kk]]
[13:21:03.541]                   NAME <- NAMES[[kk]]
[13:21:03.541]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.541]                     next
[13:21:03.541]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.541]                 }
[13:21:03.541]                 if (length(args) > 0) 
[13:21:03.541]                   base::do.call(base::Sys.setenv, args = args)
[13:21:03.541]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:03.541]             }
[13:21:03.541]             else {
[13:21:03.541]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:03.541]             }
[13:21:03.541]             {
[13:21:03.541]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:03.541]                   0L) {
[13:21:03.541]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:03.541]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:03.541]                   base::options(opts)
[13:21:03.541]                 }
[13:21:03.541]                 {
[13:21:03.541]                   {
[13:21:03.541]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:03.541]                     NULL
[13:21:03.541]                   }
[13:21:03.541]                   options(future.plan = NULL)
[13:21:03.541]                   if (is.na(NA_character_)) 
[13:21:03.541]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.541]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:03.541]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:03.541]                     envir = parent.frame()) 
[13:21:03.541]                   {
[13:21:03.541]                     default_workers <- missing(workers)
[13:21:03.541]                     if (is.function(workers)) 
[13:21:03.541]                       workers <- workers()
[13:21:03.541]                     workers <- structure(as.integer(workers), 
[13:21:03.541]                       class = class(workers))
[13:21:03.541]                     stop_if_not(is.finite(workers), workers >= 
[13:21:03.541]                       1L)
[13:21:03.541]                     if ((workers == 1L && !inherits(workers, 
[13:21:03.541]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:03.541]                       if (default_workers) 
[13:21:03.541]                         supportsMulticore(warn = TRUE)
[13:21:03.541]                       return(sequential(..., envir = envir))
[13:21:03.541]                     }
[13:21:03.541]                     oopts <- options(mc.cores = workers)
[13:21:03.541]                     on.exit(options(oopts))
[13:21:03.541]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:03.541]                       envir = envir)
[13:21:03.541]                     if (!future$lazy) 
[13:21:03.541]                       future <- run(future)
[13:21:03.541]                     invisible(future)
[13:21:03.541]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:03.541]                 }
[13:21:03.541]             }
[13:21:03.541]         }
[13:21:03.541]     })
[13:21:03.541]     if (TRUE) {
[13:21:03.541]         base::sink(type = "output", split = FALSE)
[13:21:03.541]         if (TRUE) {
[13:21:03.541]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:03.541]         }
[13:21:03.541]         else {
[13:21:03.541]             ...future.result["stdout"] <- base::list(NULL)
[13:21:03.541]         }
[13:21:03.541]         base::close(...future.stdout)
[13:21:03.541]         ...future.stdout <- NULL
[13:21:03.541]     }
[13:21:03.541]     ...future.result$conditions <- ...future.conditions
[13:21:03.541]     ...future.result$finished <- base::Sys.time()
[13:21:03.541]     ...future.result
[13:21:03.541] }
[13:21:03.546] requestCore(): workers = 2
[13:21:03.546] Poll #1 (0): usedCores() = 2, workers = 2
[13:21:03.561] MulticoreFuture started
 - Creating multicore future #4 ...
[13:21:03.562] plan(): Setting new future strategy stack:
[13:21:03.562] List of future strategies:
[13:21:03.562] 1. sequential:
[13:21:03.562]    - args: function (..., envir = parent.frame())
[13:21:03.562]    - tweaked: FALSE
[13:21:03.562]    - call: NULL
[13:21:03.564] plan(): nbrOfWorkers() = 1
[13:21:03.566] plan(): Setting new future strategy stack:
[13:21:03.566] List of future strategies:
[13:21:03.566] 1. multicore:
[13:21:03.566]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:03.566]    - tweaked: FALSE
[13:21:03.566]    - call: plan(multicore)
[13:21:03.568] getGlobalsAndPackages() ...
[13:21:03.568] Not searching for globals
[13:21:03.569] - globals: [0] <none>
[13:21:03.569] getGlobalsAndPackages() ... DONE
[13:21:03.570] Packages needed by the future expression (n = 0): <none>
[13:21:03.570] Packages needed by future strategies (n = 0): <none>
[13:21:03.572] plan(): nbrOfWorkers() = 2
[13:21:03.571] {
[13:21:03.571]     {
[13:21:03.571]         {
[13:21:03.571]             ...future.startTime <- base::Sys.time()
[13:21:03.571]             {
[13:21:03.571]                 {
[13:21:03.571]                   {
[13:21:03.571]                     {
[13:21:03.571]                       base::local({
[13:21:03.571]                         has_future <- base::requireNamespace("future", 
[13:21:03.571]                           quietly = TRUE)
[13:21:03.571]                         if (has_future) {
[13:21:03.571]                           ns <- base::getNamespace("future")
[13:21:03.571]                           version <- ns[[".package"]][["version"]]
[13:21:03.571]                           if (is.null(version)) 
[13:21:03.571]                             version <- utils::packageVersion("future")
[13:21:03.571]                         }
[13:21:03.571]                         else {
[13:21:03.571]                           version <- NULL
[13:21:03.571]                         }
[13:21:03.571]                         if (!has_future || version < "1.8.0") {
[13:21:03.571]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:03.571]                             "", base::R.version$version.string), 
[13:21:03.571]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:03.571]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:03.571]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:03.571]                               "release", "version")], collapse = " "), 
[13:21:03.571]                             hostname = base::Sys.info()[["nodename"]])
[13:21:03.571]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:03.571]                             info)
[13:21:03.571]                           info <- base::paste(info, collapse = "; ")
[13:21:03.571]                           if (!has_future) {
[13:21:03.571]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:03.571]                               info)
[13:21:03.571]                           }
[13:21:03.571]                           else {
[13:21:03.571]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:03.571]                               info, version)
[13:21:03.571]                           }
[13:21:03.571]                           base::stop(msg)
[13:21:03.571]                         }
[13:21:03.571]                       })
[13:21:03.571]                     }
[13:21:03.571]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:03.571]                     base::options(mc.cores = 1L)
[13:21:03.571]                   }
[13:21:03.571]                   options(future.plan = NULL)
[13:21:03.571]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.571]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:03.571]                 }
[13:21:03.571]                 ...future.workdir <- getwd()
[13:21:03.571]             }
[13:21:03.571]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:03.571]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:03.571]         }
[13:21:03.571]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:03.571]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:03.571]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:03.571]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:03.571]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:03.571]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:03.571]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:03.571]             base::names(...future.oldOptions))
[13:21:03.571]     }
[13:21:03.571]     if (FALSE) {
[13:21:03.571]     }
[13:21:03.571]     else {
[13:21:03.571]         if (TRUE) {
[13:21:03.571]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:03.571]                 open = "w")
[13:21:03.571]         }
[13:21:03.571]         else {
[13:21:03.571]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:03.571]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:03.571]         }
[13:21:03.571]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:03.571]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:03.571]             base::sink(type = "output", split = FALSE)
[13:21:03.571]             base::close(...future.stdout)
[13:21:03.571]         }, add = TRUE)
[13:21:03.571]     }
[13:21:03.571]     ...future.frame <- base::sys.nframe()
[13:21:03.571]     ...future.conditions <- base::list()
[13:21:03.571]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:03.571]     if (FALSE) {
[13:21:03.571]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:03.571]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:03.571]     }
[13:21:03.571]     ...future.result <- base::tryCatch({
[13:21:03.571]         base::withCallingHandlers({
[13:21:03.571]             ...future.value <- base::withVisible(base::local({
[13:21:03.571]                 withCallingHandlers({
[13:21:03.571]                   {
[13:21:03.571]                     ii
[13:21:03.571]                   }
[13:21:03.571]                 }, immediateCondition = function(cond) {
[13:21:03.571]                   save_rds <- function (object, pathname, ...) 
[13:21:03.571]                   {
[13:21:03.571]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:03.571]                     if (file_test("-f", pathname_tmp)) {
[13:21:03.571]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.571]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:03.571]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.571]                         fi_tmp[["mtime"]])
[13:21:03.571]                     }
[13:21:03.571]                     tryCatch({
[13:21:03.571]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:03.571]                     }, error = function(ex) {
[13:21:03.571]                       msg <- conditionMessage(ex)
[13:21:03.571]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.571]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:03.571]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.571]                         fi_tmp[["mtime"]], msg)
[13:21:03.571]                       ex$message <- msg
[13:21:03.571]                       stop(ex)
[13:21:03.571]                     })
[13:21:03.571]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:03.571]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:03.571]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:03.571]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.571]                       fi <- file.info(pathname)
[13:21:03.571]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:03.571]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.571]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:03.571]                         fi[["size"]], fi[["mtime"]])
[13:21:03.571]                       stop(msg)
[13:21:03.571]                     }
[13:21:03.571]                     invisible(pathname)
[13:21:03.571]                   }
[13:21:03.571]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:03.571]                     rootPath = tempdir()) 
[13:21:03.571]                   {
[13:21:03.571]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:03.571]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:03.571]                       tmpdir = path, fileext = ".rds")
[13:21:03.571]                     save_rds(obj, file)
[13:21:03.571]                   }
[13:21:03.571]                   saveImmediateCondition(cond, path = "/tmp/Rtmpd6Ly3I/.future/immediateConditions")
[13:21:03.571]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.571]                   {
[13:21:03.571]                     inherits <- base::inherits
[13:21:03.571]                     invokeRestart <- base::invokeRestart
[13:21:03.571]                     is.null <- base::is.null
[13:21:03.571]                     muffled <- FALSE
[13:21:03.571]                     if (inherits(cond, "message")) {
[13:21:03.571]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:03.571]                       if (muffled) 
[13:21:03.571]                         invokeRestart("muffleMessage")
[13:21:03.571]                     }
[13:21:03.571]                     else if (inherits(cond, "warning")) {
[13:21:03.571]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:03.571]                       if (muffled) 
[13:21:03.571]                         invokeRestart("muffleWarning")
[13:21:03.571]                     }
[13:21:03.571]                     else if (inherits(cond, "condition")) {
[13:21:03.571]                       if (!is.null(pattern)) {
[13:21:03.571]                         computeRestarts <- base::computeRestarts
[13:21:03.571]                         grepl <- base::grepl
[13:21:03.571]                         restarts <- computeRestarts(cond)
[13:21:03.571]                         for (restart in restarts) {
[13:21:03.571]                           name <- restart$name
[13:21:03.571]                           if (is.null(name)) 
[13:21:03.571]                             next
[13:21:03.571]                           if (!grepl(pattern, name)) 
[13:21:03.571]                             next
[13:21:03.571]                           invokeRestart(restart)
[13:21:03.571]                           muffled <- TRUE
[13:21:03.571]                           break
[13:21:03.571]                         }
[13:21:03.571]                       }
[13:21:03.571]                     }
[13:21:03.571]                     invisible(muffled)
[13:21:03.571]                   }
[13:21:03.571]                   muffleCondition(cond)
[13:21:03.571]                 })
[13:21:03.571]             }))
[13:21:03.571]             future::FutureResult(value = ...future.value$value, 
[13:21:03.571]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.571]                   ...future.rng), globalenv = if (FALSE) 
[13:21:03.571]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:03.571]                     ...future.globalenv.names))
[13:21:03.571]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:03.571]         }, condition = base::local({
[13:21:03.571]             c <- base::c
[13:21:03.571]             inherits <- base::inherits
[13:21:03.571]             invokeRestart <- base::invokeRestart
[13:21:03.571]             length <- base::length
[13:21:03.571]             list <- base::list
[13:21:03.571]             seq.int <- base::seq.int
[13:21:03.571]             signalCondition <- base::signalCondition
[13:21:03.571]             sys.calls <- base::sys.calls
[13:21:03.571]             `[[` <- base::`[[`
[13:21:03.571]             `+` <- base::`+`
[13:21:03.571]             `<<-` <- base::`<<-`
[13:21:03.571]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:03.571]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:03.571]                   3L)]
[13:21:03.571]             }
[13:21:03.571]             function(cond) {
[13:21:03.571]                 is_error <- inherits(cond, "error")
[13:21:03.571]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:03.571]                   NULL)
[13:21:03.571]                 if (is_error) {
[13:21:03.571]                   sessionInformation <- function() {
[13:21:03.571]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:03.571]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:03.571]                       search = base::search(), system = base::Sys.info())
[13:21:03.571]                   }
[13:21:03.571]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.571]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:03.571]                     cond$call), session = sessionInformation(), 
[13:21:03.571]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:03.571]                   signalCondition(cond)
[13:21:03.571]                 }
[13:21:03.571]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:03.571]                 "immediateCondition"))) {
[13:21:03.571]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:03.571]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.571]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:03.571]                   if (TRUE && !signal) {
[13:21:03.571]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.571]                     {
[13:21:03.571]                       inherits <- base::inherits
[13:21:03.571]                       invokeRestart <- base::invokeRestart
[13:21:03.571]                       is.null <- base::is.null
[13:21:03.571]                       muffled <- FALSE
[13:21:03.571]                       if (inherits(cond, "message")) {
[13:21:03.571]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.571]                         if (muffled) 
[13:21:03.571]                           invokeRestart("muffleMessage")
[13:21:03.571]                       }
[13:21:03.571]                       else if (inherits(cond, "warning")) {
[13:21:03.571]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.571]                         if (muffled) 
[13:21:03.571]                           invokeRestart("muffleWarning")
[13:21:03.571]                       }
[13:21:03.571]                       else if (inherits(cond, "condition")) {
[13:21:03.571]                         if (!is.null(pattern)) {
[13:21:03.571]                           computeRestarts <- base::computeRestarts
[13:21:03.571]                           grepl <- base::grepl
[13:21:03.571]                           restarts <- computeRestarts(cond)
[13:21:03.571]                           for (restart in restarts) {
[13:21:03.571]                             name <- restart$name
[13:21:03.571]                             if (is.null(name)) 
[13:21:03.571]                               next
[13:21:03.571]                             if (!grepl(pattern, name)) 
[13:21:03.571]                               next
[13:21:03.571]                             invokeRestart(restart)
[13:21:03.571]                             muffled <- TRUE
[13:21:03.571]                             break
[13:21:03.571]                           }
[13:21:03.571]                         }
[13:21:03.571]                       }
[13:21:03.571]                       invisible(muffled)
[13:21:03.571]                     }
[13:21:03.571]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.571]                   }
[13:21:03.571]                 }
[13:21:03.571]                 else {
[13:21:03.571]                   if (TRUE) {
[13:21:03.571]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.571]                     {
[13:21:03.571]                       inherits <- base::inherits
[13:21:03.571]                       invokeRestart <- base::invokeRestart
[13:21:03.571]                       is.null <- base::is.null
[13:21:03.571]                       muffled <- FALSE
[13:21:03.571]                       if (inherits(cond, "message")) {
[13:21:03.571]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.571]                         if (muffled) 
[13:21:03.571]                           invokeRestart("muffleMessage")
[13:21:03.571]                       }
[13:21:03.571]                       else if (inherits(cond, "warning")) {
[13:21:03.571]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.571]                         if (muffled) 
[13:21:03.571]                           invokeRestart("muffleWarning")
[13:21:03.571]                       }
[13:21:03.571]                       else if (inherits(cond, "condition")) {
[13:21:03.571]                         if (!is.null(pattern)) {
[13:21:03.571]                           computeRestarts <- base::computeRestarts
[13:21:03.571]                           grepl <- base::grepl
[13:21:03.571]                           restarts <- computeRestarts(cond)
[13:21:03.571]                           for (restart in restarts) {
[13:21:03.571]                             name <- restart$name
[13:21:03.571]                             if (is.null(name)) 
[13:21:03.571]                               next
[13:21:03.571]                             if (!grepl(pattern, name)) 
[13:21:03.571]                               next
[13:21:03.571]                             invokeRestart(restart)
[13:21:03.571]                             muffled <- TRUE
[13:21:03.571]                             break
[13:21:03.571]                           }
[13:21:03.571]                         }
[13:21:03.571]                       }
[13:21:03.571]                       invisible(muffled)
[13:21:03.571]                     }
[13:21:03.571]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.571]                   }
[13:21:03.571]                 }
[13:21:03.571]             }
[13:21:03.571]         }))
[13:21:03.571]     }, error = function(ex) {
[13:21:03.571]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:03.571]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.571]                 ...future.rng), started = ...future.startTime, 
[13:21:03.571]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:03.571]             version = "1.8"), class = "FutureResult")
[13:21:03.571]     }, finally = {
[13:21:03.571]         if (!identical(...future.workdir, getwd())) 
[13:21:03.571]             setwd(...future.workdir)
[13:21:03.571]         {
[13:21:03.571]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:03.571]                 ...future.oldOptions$nwarnings <- NULL
[13:21:03.571]             }
[13:21:03.571]             base::options(...future.oldOptions)
[13:21:03.571]             if (.Platform$OS.type == "windows") {
[13:21:03.571]                 old_names <- names(...future.oldEnvVars)
[13:21:03.571]                 envs <- base::Sys.getenv()
[13:21:03.571]                 names <- names(envs)
[13:21:03.571]                 common <- intersect(names, old_names)
[13:21:03.571]                 added <- setdiff(names, old_names)
[13:21:03.571]                 removed <- setdiff(old_names, names)
[13:21:03.571]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:03.571]                   envs[common]]
[13:21:03.571]                 NAMES <- toupper(changed)
[13:21:03.571]                 args <- list()
[13:21:03.571]                 for (kk in seq_along(NAMES)) {
[13:21:03.571]                   name <- changed[[kk]]
[13:21:03.571]                   NAME <- NAMES[[kk]]
[13:21:03.571]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.571]                     next
[13:21:03.571]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.571]                 }
[13:21:03.571]                 NAMES <- toupper(added)
[13:21:03.571]                 for (kk in seq_along(NAMES)) {
[13:21:03.571]                   name <- added[[kk]]
[13:21:03.571]                   NAME <- NAMES[[kk]]
[13:21:03.571]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.571]                     next
[13:21:03.571]                   args[[name]] <- ""
[13:21:03.571]                 }
[13:21:03.571]                 NAMES <- toupper(removed)
[13:21:03.571]                 for (kk in seq_along(NAMES)) {
[13:21:03.571]                   name <- removed[[kk]]
[13:21:03.571]                   NAME <- NAMES[[kk]]
[13:21:03.571]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.571]                     next
[13:21:03.571]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.571]                 }
[13:21:03.571]                 if (length(args) > 0) 
[13:21:03.571]                   base::do.call(base::Sys.setenv, args = args)
[13:21:03.571]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:03.571]             }
[13:21:03.571]             else {
[13:21:03.571]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:03.571]             }
[13:21:03.571]             {
[13:21:03.571]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:03.571]                   0L) {
[13:21:03.571]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:03.571]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:03.571]                   base::options(opts)
[13:21:03.571]                 }
[13:21:03.571]                 {
[13:21:03.571]                   {
[13:21:03.571]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:03.571]                     NULL
[13:21:03.571]                   }
[13:21:03.571]                   options(future.plan = NULL)
[13:21:03.571]                   if (is.na(NA_character_)) 
[13:21:03.571]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.571]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:03.571]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:03.571]                     envir = parent.frame()) 
[13:21:03.571]                   {
[13:21:03.571]                     default_workers <- missing(workers)
[13:21:03.571]                     if (is.function(workers)) 
[13:21:03.571]                       workers <- workers()
[13:21:03.571]                     workers <- structure(as.integer(workers), 
[13:21:03.571]                       class = class(workers))
[13:21:03.571]                     stop_if_not(is.finite(workers), workers >= 
[13:21:03.571]                       1L)
[13:21:03.571]                     if ((workers == 1L && !inherits(workers, 
[13:21:03.571]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:03.571]                       if (default_workers) 
[13:21:03.571]                         supportsMulticore(warn = TRUE)
[13:21:03.571]                       return(sequential(..., envir = envir))
[13:21:03.571]                     }
[13:21:03.571]                     oopts <- options(mc.cores = workers)
[13:21:03.571]                     on.exit(options(oopts))
[13:21:03.571]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:03.571]                       envir = envir)
[13:21:03.571]                     if (!future$lazy) 
[13:21:03.571]                       future <- run(future)
[13:21:03.571]                     invisible(future)
[13:21:03.571]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:03.571]                 }
[13:21:03.571]             }
[13:21:03.571]         }
[13:21:03.571]     })
[13:21:03.571]     if (TRUE) {
[13:21:03.571]         base::sink(type = "output", split = FALSE)
[13:21:03.571]         if (TRUE) {
[13:21:03.571]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:03.571]         }
[13:21:03.571]         else {
[13:21:03.571]             ...future.result["stdout"] <- base::list(NULL)
[13:21:03.571]         }
[13:21:03.571]         base::close(...future.stdout)
[13:21:03.571]         ...future.stdout <- NULL
[13:21:03.571]     }
[13:21:03.571]     ...future.result$conditions <- ...future.conditions
[13:21:03.571]     ...future.result$finished <- base::Sys.time()
[13:21:03.571]     ...future.result
[13:21:03.571] }
[13:21:03.575] requestCore(): workers = 2
[13:21:03.576] Poll #1 (0): usedCores() = 2, workers = 2
[13:21:03.602] MulticoreFuture started
 - Resolving 4 multicore futures
[13:21:03.603] plan(): Setting new future strategy stack:
[13:21:03.604] List of future strategies:
[13:21:03.604] 1. sequential:
[13:21:03.604]    - args: function (..., envir = parent.frame())
[13:21:03.604]    - tweaked: FALSE
[13:21:03.604]    - call: NULL
[13:21:03.605] plan(): nbrOfWorkers() = 1
[13:21:03.606] plan(): Setting new future strategy stack:
[13:21:03.607] List of future strategies:
[13:21:03.607] 1. multicore:
[13:21:03.607]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:03.607]    - tweaked: FALSE
[13:21:03.607]    - call: plan(multicore)
[13:21:03.611] plan(): nbrOfWorkers() = 2
*** multicore(..., globals = FALSE) and errors
[13:21:03.616] getGlobalsAndPackages() ...
[13:21:03.616] Not searching for globals
[13:21:03.616] - globals: [0] <none>
[13:21:03.616] getGlobalsAndPackages() ... DONE
[13:21:03.617] Packages needed by the future expression (n = 0): <none>
[13:21:03.617] Packages needed by future strategies (n = 0): <none>
[13:21:03.618] {
[13:21:03.618]     {
[13:21:03.618]         {
[13:21:03.618]             ...future.startTime <- base::Sys.time()
[13:21:03.618]             {
[13:21:03.618]                 {
[13:21:03.618]                   {
[13:21:03.618]                     {
[13:21:03.618]                       base::local({
[13:21:03.618]                         has_future <- base::requireNamespace("future", 
[13:21:03.618]                           quietly = TRUE)
[13:21:03.618]                         if (has_future) {
[13:21:03.618]                           ns <- base::getNamespace("future")
[13:21:03.618]                           version <- ns[[".package"]][["version"]]
[13:21:03.618]                           if (is.null(version)) 
[13:21:03.618]                             version <- utils::packageVersion("future")
[13:21:03.618]                         }
[13:21:03.618]                         else {
[13:21:03.618]                           version <- NULL
[13:21:03.618]                         }
[13:21:03.618]                         if (!has_future || version < "1.8.0") {
[13:21:03.618]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:03.618]                             "", base::R.version$version.string), 
[13:21:03.618]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:03.618]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:03.618]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:03.618]                               "release", "version")], collapse = " "), 
[13:21:03.618]                             hostname = base::Sys.info()[["nodename"]])
[13:21:03.618]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:03.618]                             info)
[13:21:03.618]                           info <- base::paste(info, collapse = "; ")
[13:21:03.618]                           if (!has_future) {
[13:21:03.618]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:03.618]                               info)
[13:21:03.618]                           }
[13:21:03.618]                           else {
[13:21:03.618]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:03.618]                               info, version)
[13:21:03.618]                           }
[13:21:03.618]                           base::stop(msg)
[13:21:03.618]                         }
[13:21:03.618]                       })
[13:21:03.618]                     }
[13:21:03.618]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:03.618]                     base::options(mc.cores = 1L)
[13:21:03.618]                   }
[13:21:03.618]                   options(future.plan = NULL)
[13:21:03.618]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.618]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:03.618]                 }
[13:21:03.618]                 ...future.workdir <- getwd()
[13:21:03.618]             }
[13:21:03.618]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:03.618]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:03.618]         }
[13:21:03.618]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:03.618]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:03.618]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:03.618]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:03.618]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:03.618]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:03.618]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:03.618]             base::names(...future.oldOptions))
[13:21:03.618]     }
[13:21:03.618]     if (FALSE) {
[13:21:03.618]     }
[13:21:03.618]     else {
[13:21:03.618]         if (TRUE) {
[13:21:03.618]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:03.618]                 open = "w")
[13:21:03.618]         }
[13:21:03.618]         else {
[13:21:03.618]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:03.618]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:03.618]         }
[13:21:03.618]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:03.618]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:03.618]             base::sink(type = "output", split = FALSE)
[13:21:03.618]             base::close(...future.stdout)
[13:21:03.618]         }, add = TRUE)
[13:21:03.618]     }
[13:21:03.618]     ...future.frame <- base::sys.nframe()
[13:21:03.618]     ...future.conditions <- base::list()
[13:21:03.618]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:03.618]     if (FALSE) {
[13:21:03.618]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:03.618]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:03.618]     }
[13:21:03.618]     ...future.result <- base::tryCatch({
[13:21:03.618]         base::withCallingHandlers({
[13:21:03.618]             ...future.value <- base::withVisible(base::local({
[13:21:03.618]                 withCallingHandlers({
[13:21:03.618]                   {
[13:21:03.618]                     stop("Whoops!")
[13:21:03.618]                     1
[13:21:03.618]                   }
[13:21:03.618]                 }, immediateCondition = function(cond) {
[13:21:03.618]                   save_rds <- function (object, pathname, ...) 
[13:21:03.618]                   {
[13:21:03.618]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:03.618]                     if (file_test("-f", pathname_tmp)) {
[13:21:03.618]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.618]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:03.618]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.618]                         fi_tmp[["mtime"]])
[13:21:03.618]                     }
[13:21:03.618]                     tryCatch({
[13:21:03.618]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:03.618]                     }, error = function(ex) {
[13:21:03.618]                       msg <- conditionMessage(ex)
[13:21:03.618]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.618]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:03.618]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.618]                         fi_tmp[["mtime"]], msg)
[13:21:03.618]                       ex$message <- msg
[13:21:03.618]                       stop(ex)
[13:21:03.618]                     })
[13:21:03.618]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:03.618]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:03.618]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:03.618]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.618]                       fi <- file.info(pathname)
[13:21:03.618]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:03.618]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.618]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:03.618]                         fi[["size"]], fi[["mtime"]])
[13:21:03.618]                       stop(msg)
[13:21:03.618]                     }
[13:21:03.618]                     invisible(pathname)
[13:21:03.618]                   }
[13:21:03.618]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:03.618]                     rootPath = tempdir()) 
[13:21:03.618]                   {
[13:21:03.618]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:03.618]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:03.618]                       tmpdir = path, fileext = ".rds")
[13:21:03.618]                     save_rds(obj, file)
[13:21:03.618]                   }
[13:21:03.618]                   saveImmediateCondition(cond, path = "/tmp/Rtmpd6Ly3I/.future/immediateConditions")
[13:21:03.618]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.618]                   {
[13:21:03.618]                     inherits <- base::inherits
[13:21:03.618]                     invokeRestart <- base::invokeRestart
[13:21:03.618]                     is.null <- base::is.null
[13:21:03.618]                     muffled <- FALSE
[13:21:03.618]                     if (inherits(cond, "message")) {
[13:21:03.618]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:03.618]                       if (muffled) 
[13:21:03.618]                         invokeRestart("muffleMessage")
[13:21:03.618]                     }
[13:21:03.618]                     else if (inherits(cond, "warning")) {
[13:21:03.618]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:03.618]                       if (muffled) 
[13:21:03.618]                         invokeRestart("muffleWarning")
[13:21:03.618]                     }
[13:21:03.618]                     else if (inherits(cond, "condition")) {
[13:21:03.618]                       if (!is.null(pattern)) {
[13:21:03.618]                         computeRestarts <- base::computeRestarts
[13:21:03.618]                         grepl <- base::grepl
[13:21:03.618]                         restarts <- computeRestarts(cond)
[13:21:03.618]                         for (restart in restarts) {
[13:21:03.618]                           name <- restart$name
[13:21:03.618]                           if (is.null(name)) 
[13:21:03.618]                             next
[13:21:03.618]                           if (!grepl(pattern, name)) 
[13:21:03.618]                             next
[13:21:03.618]                           invokeRestart(restart)
[13:21:03.618]                           muffled <- TRUE
[13:21:03.618]                           break
[13:21:03.618]                         }
[13:21:03.618]                       }
[13:21:03.618]                     }
[13:21:03.618]                     invisible(muffled)
[13:21:03.618]                   }
[13:21:03.618]                   muffleCondition(cond)
[13:21:03.618]                 })
[13:21:03.618]             }))
[13:21:03.618]             future::FutureResult(value = ...future.value$value, 
[13:21:03.618]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.618]                   ...future.rng), globalenv = if (FALSE) 
[13:21:03.618]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:03.618]                     ...future.globalenv.names))
[13:21:03.618]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:03.618]         }, condition = base::local({
[13:21:03.618]             c <- base::c
[13:21:03.618]             inherits <- base::inherits
[13:21:03.618]             invokeRestart <- base::invokeRestart
[13:21:03.618]             length <- base::length
[13:21:03.618]             list <- base::list
[13:21:03.618]             seq.int <- base::seq.int
[13:21:03.618]             signalCondition <- base::signalCondition
[13:21:03.618]             sys.calls <- base::sys.calls
[13:21:03.618]             `[[` <- base::`[[`
[13:21:03.618]             `+` <- base::`+`
[13:21:03.618]             `<<-` <- base::`<<-`
[13:21:03.618]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:03.618]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:03.618]                   3L)]
[13:21:03.618]             }
[13:21:03.618]             function(cond) {
[13:21:03.618]                 is_error <- inherits(cond, "error")
[13:21:03.618]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:03.618]                   NULL)
[13:21:03.618]                 if (is_error) {
[13:21:03.618]                   sessionInformation <- function() {
[13:21:03.618]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:03.618]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:03.618]                       search = base::search(), system = base::Sys.info())
[13:21:03.618]                   }
[13:21:03.618]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.618]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:03.618]                     cond$call), session = sessionInformation(), 
[13:21:03.618]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:03.618]                   signalCondition(cond)
[13:21:03.618]                 }
[13:21:03.618]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:03.618]                 "immediateCondition"))) {
[13:21:03.618]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:03.618]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.618]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:03.618]                   if (TRUE && !signal) {
[13:21:03.618]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.618]                     {
[13:21:03.618]                       inherits <- base::inherits
[13:21:03.618]                       invokeRestart <- base::invokeRestart
[13:21:03.618]                       is.null <- base::is.null
[13:21:03.618]                       muffled <- FALSE
[13:21:03.618]                       if (inherits(cond, "message")) {
[13:21:03.618]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.618]                         if (muffled) 
[13:21:03.618]                           invokeRestart("muffleMessage")
[13:21:03.618]                       }
[13:21:03.618]                       else if (inherits(cond, "warning")) {
[13:21:03.618]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.618]                         if (muffled) 
[13:21:03.618]                           invokeRestart("muffleWarning")
[13:21:03.618]                       }
[13:21:03.618]                       else if (inherits(cond, "condition")) {
[13:21:03.618]                         if (!is.null(pattern)) {
[13:21:03.618]                           computeRestarts <- base::computeRestarts
[13:21:03.618]                           grepl <- base::grepl
[13:21:03.618]                           restarts <- computeRestarts(cond)
[13:21:03.618]                           for (restart in restarts) {
[13:21:03.618]                             name <- restart$name
[13:21:03.618]                             if (is.null(name)) 
[13:21:03.618]                               next
[13:21:03.618]                             if (!grepl(pattern, name)) 
[13:21:03.618]                               next
[13:21:03.618]                             invokeRestart(restart)
[13:21:03.618]                             muffled <- TRUE
[13:21:03.618]                             break
[13:21:03.618]                           }
[13:21:03.618]                         }
[13:21:03.618]                       }
[13:21:03.618]                       invisible(muffled)
[13:21:03.618]                     }
[13:21:03.618]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.618]                   }
[13:21:03.618]                 }
[13:21:03.618]                 else {
[13:21:03.618]                   if (TRUE) {
[13:21:03.618]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.618]                     {
[13:21:03.618]                       inherits <- base::inherits
[13:21:03.618]                       invokeRestart <- base::invokeRestart
[13:21:03.618]                       is.null <- base::is.null
[13:21:03.618]                       muffled <- FALSE
[13:21:03.618]                       if (inherits(cond, "message")) {
[13:21:03.618]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.618]                         if (muffled) 
[13:21:03.618]                           invokeRestart("muffleMessage")
[13:21:03.618]                       }
[13:21:03.618]                       else if (inherits(cond, "warning")) {
[13:21:03.618]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.618]                         if (muffled) 
[13:21:03.618]                           invokeRestart("muffleWarning")
[13:21:03.618]                       }
[13:21:03.618]                       else if (inherits(cond, "condition")) {
[13:21:03.618]                         if (!is.null(pattern)) {
[13:21:03.618]                           computeRestarts <- base::computeRestarts
[13:21:03.618]                           grepl <- base::grepl
[13:21:03.618]                           restarts <- computeRestarts(cond)
[13:21:03.618]                           for (restart in restarts) {
[13:21:03.618]                             name <- restart$name
[13:21:03.618]                             if (is.null(name)) 
[13:21:03.618]                               next
[13:21:03.618]                             if (!grepl(pattern, name)) 
[13:21:03.618]                               next
[13:21:03.618]                             invokeRestart(restart)
[13:21:03.618]                             muffled <- TRUE
[13:21:03.618]                             break
[13:21:03.618]                           }
[13:21:03.618]                         }
[13:21:03.618]                       }
[13:21:03.618]                       invisible(muffled)
[13:21:03.618]                     }
[13:21:03.618]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.618]                   }
[13:21:03.618]                 }
[13:21:03.618]             }
[13:21:03.618]         }))
[13:21:03.618]     }, error = function(ex) {
[13:21:03.618]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:03.618]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.618]                 ...future.rng), started = ...future.startTime, 
[13:21:03.618]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:03.618]             version = "1.8"), class = "FutureResult")
[13:21:03.618]     }, finally = {
[13:21:03.618]         if (!identical(...future.workdir, getwd())) 
[13:21:03.618]             setwd(...future.workdir)
[13:21:03.618]         {
[13:21:03.618]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:03.618]                 ...future.oldOptions$nwarnings <- NULL
[13:21:03.618]             }
[13:21:03.618]             base::options(...future.oldOptions)
[13:21:03.618]             if (.Platform$OS.type == "windows") {
[13:21:03.618]                 old_names <- names(...future.oldEnvVars)
[13:21:03.618]                 envs <- base::Sys.getenv()
[13:21:03.618]                 names <- names(envs)
[13:21:03.618]                 common <- intersect(names, old_names)
[13:21:03.618]                 added <- setdiff(names, old_names)
[13:21:03.618]                 removed <- setdiff(old_names, names)
[13:21:03.618]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:03.618]                   envs[common]]
[13:21:03.618]                 NAMES <- toupper(changed)
[13:21:03.618]                 args <- list()
[13:21:03.618]                 for (kk in seq_along(NAMES)) {
[13:21:03.618]                   name <- changed[[kk]]
[13:21:03.618]                   NAME <- NAMES[[kk]]
[13:21:03.618]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.618]                     next
[13:21:03.618]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.618]                 }
[13:21:03.618]                 NAMES <- toupper(added)
[13:21:03.618]                 for (kk in seq_along(NAMES)) {
[13:21:03.618]                   name <- added[[kk]]
[13:21:03.618]                   NAME <- NAMES[[kk]]
[13:21:03.618]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.618]                     next
[13:21:03.618]                   args[[name]] <- ""
[13:21:03.618]                 }
[13:21:03.618]                 NAMES <- toupper(removed)
[13:21:03.618]                 for (kk in seq_along(NAMES)) {
[13:21:03.618]                   name <- removed[[kk]]
[13:21:03.618]                   NAME <- NAMES[[kk]]
[13:21:03.618]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.618]                     next
[13:21:03.618]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.618]                 }
[13:21:03.618]                 if (length(args) > 0) 
[13:21:03.618]                   base::do.call(base::Sys.setenv, args = args)
[13:21:03.618]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:03.618]             }
[13:21:03.618]             else {
[13:21:03.618]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:03.618]             }
[13:21:03.618]             {
[13:21:03.618]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:03.618]                   0L) {
[13:21:03.618]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:03.618]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:03.618]                   base::options(opts)
[13:21:03.618]                 }
[13:21:03.618]                 {
[13:21:03.618]                   {
[13:21:03.618]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:03.618]                     NULL
[13:21:03.618]                   }
[13:21:03.618]                   options(future.plan = NULL)
[13:21:03.618]                   if (is.na(NA_character_)) 
[13:21:03.618]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.618]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:03.618]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:03.618]                     envir = parent.frame()) 
[13:21:03.618]                   {
[13:21:03.618]                     default_workers <- missing(workers)
[13:21:03.618]                     if (is.function(workers)) 
[13:21:03.618]                       workers <- workers()
[13:21:03.618]                     workers <- structure(as.integer(workers), 
[13:21:03.618]                       class = class(workers))
[13:21:03.618]                     stop_if_not(is.finite(workers), workers >= 
[13:21:03.618]                       1L)
[13:21:03.618]                     if ((workers == 1L && !inherits(workers, 
[13:21:03.618]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:03.618]                       if (default_workers) 
[13:21:03.618]                         supportsMulticore(warn = TRUE)
[13:21:03.618]                       return(sequential(..., envir = envir))
[13:21:03.618]                     }
[13:21:03.618]                     oopts <- options(mc.cores = workers)
[13:21:03.618]                     on.exit(options(oopts))
[13:21:03.618]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:03.618]                       envir = envir)
[13:21:03.618]                     if (!future$lazy) 
[13:21:03.618]                       future <- run(future)
[13:21:03.618]                     invisible(future)
[13:21:03.618]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:03.618]                 }
[13:21:03.618]             }
[13:21:03.618]         }
[13:21:03.618]     })
[13:21:03.618]     if (TRUE) {
[13:21:03.618]         base::sink(type = "output", split = FALSE)
[13:21:03.618]         if (TRUE) {
[13:21:03.618]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:03.618]         }
[13:21:03.618]         else {
[13:21:03.618]             ...future.result["stdout"] <- base::list(NULL)
[13:21:03.618]         }
[13:21:03.618]         base::close(...future.stdout)
[13:21:03.618]         ...future.stdout <- NULL
[13:21:03.618]     }
[13:21:03.618]     ...future.result$conditions <- ...future.conditions
[13:21:03.618]     ...future.result$finished <- base::Sys.time()
[13:21:03.618]     ...future.result
[13:21:03.618] }
[13:21:03.621] requestCore(): workers = 2
[13:21:03.622] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:03.623] plan(): Setting new future strategy stack:
[13:21:03.623] List of future strategies:
[13:21:03.623] 1. sequential:
[13:21:03.623]    - args: function (..., envir = parent.frame())
[13:21:03.623]    - tweaked: FALSE
[13:21:03.623]    - call: NULL
[13:21:03.624] plan(): nbrOfWorkers() = 1
[13:21:03.626] plan(): Setting new future strategy stack:
[13:21:03.626] List of future strategies:
[13:21:03.626] 1. multicore:
[13:21:03.626]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:03.626]    - tweaked: FALSE
[13:21:03.626]    - call: plan(multicore)
[13:21:03.631] plan(): nbrOfWorkers() = 2
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 32f7abe8-d290-272e-8911-a8ce072c31c3
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:03.640] signalConditions() ...
[13:21:03.640]  - include = ‘immediateCondition’
[13:21:03.640]  - exclude = 
[13:21:03.640]  - resignal = FALSE
[13:21:03.640]  - Number of conditions: 1
[13:21:03.641] signalConditions() ... done
[13:21:03.641] signalConditions() ...
[13:21:03.641]  - include = ‘immediateCondition’
[13:21:03.641]  - exclude = 
[13:21:03.641]  - resignal = FALSE
[13:21:03.641]  - Number of conditions: 1
[13:21:03.641] signalConditions() ... done
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/Rtmpd6Ly3I/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[13:21:03.642] signalConditions() ...
[13:21:03.645]  - include = ‘immediateCondition’
[13:21:03.645]  - exclude = 
[13:21:03.645]  - resignal = FALSE
[13:21:03.645]  - Number of conditions: 1
[13:21:03.646] signalConditions() ... done
[13:21:03.646] Future state: ‘finished’
[13:21:03.646] signalConditions() ...
[13:21:03.646]  - include = ‘condition’
[13:21:03.646]  - exclude = ‘immediateCondition’
[13:21:03.646]  - resignal = TRUE
[13:21:03.646]  - Number of conditions: 1
[13:21:03.646]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:21:03.647] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/Rtmpd6Ly3I/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[13:21:03.648] signalConditions() ...
[13:21:03.648]  - include = ‘immediateCondition’
[13:21:03.648]  - exclude = 
[13:21:03.648]  - resignal = FALSE
[13:21:03.648]  - Number of conditions: 1
[13:21:03.648] signalConditions() ... done
[13:21:03.648] Future state: ‘finished’
[13:21:03.649] signalConditions() ...
[13:21:03.649]  - include = ‘condition’
[13:21:03.649]  - exclude = ‘immediateCondition’
[13:21:03.649]  - resignal = TRUE
[13:21:03.649]  - Number of conditions: 1
[13:21:03.649]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:21:03.649] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/Rtmpd6Ly3I/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[13:21:03.654] getGlobalsAndPackages() ...
[13:21:03.654] 
[13:21:03.654] - globals: [0] <none>
[13:21:03.654] getGlobalsAndPackages() ... DONE
[13:21:03.655] Packages needed by the future expression (n = 0): <none>
[13:21:03.655] Packages needed by future strategies (n = 0): <none>
[13:21:03.656] {
[13:21:03.656]     {
[13:21:03.656]         {
[13:21:03.656]             ...future.startTime <- base::Sys.time()
[13:21:03.656]             {
[13:21:03.656]                 {
[13:21:03.656]                   {
[13:21:03.656]                     {
[13:21:03.656]                       base::local({
[13:21:03.656]                         has_future <- base::requireNamespace("future", 
[13:21:03.656]                           quietly = TRUE)
[13:21:03.656]                         if (has_future) {
[13:21:03.656]                           ns <- base::getNamespace("future")
[13:21:03.656]                           version <- ns[[".package"]][["version"]]
[13:21:03.656]                           if (is.null(version)) 
[13:21:03.656]                             version <- utils::packageVersion("future")
[13:21:03.656]                         }
[13:21:03.656]                         else {
[13:21:03.656]                           version <- NULL
[13:21:03.656]                         }
[13:21:03.656]                         if (!has_future || version < "1.8.0") {
[13:21:03.656]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:03.656]                             "", base::R.version$version.string), 
[13:21:03.656]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:03.656]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:03.656]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:03.656]                               "release", "version")], collapse = " "), 
[13:21:03.656]                             hostname = base::Sys.info()[["nodename"]])
[13:21:03.656]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:03.656]                             info)
[13:21:03.656]                           info <- base::paste(info, collapse = "; ")
[13:21:03.656]                           if (!has_future) {
[13:21:03.656]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:03.656]                               info)
[13:21:03.656]                           }
[13:21:03.656]                           else {
[13:21:03.656]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:03.656]                               info, version)
[13:21:03.656]                           }
[13:21:03.656]                           base::stop(msg)
[13:21:03.656]                         }
[13:21:03.656]                       })
[13:21:03.656]                     }
[13:21:03.656]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:03.656]                     base::options(mc.cores = 1L)
[13:21:03.656]                   }
[13:21:03.656]                   options(future.plan = NULL)
[13:21:03.656]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.656]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:03.656]                 }
[13:21:03.656]                 ...future.workdir <- getwd()
[13:21:03.656]             }
[13:21:03.656]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:03.656]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:03.656]         }
[13:21:03.656]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:03.656]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:03.656]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:03.656]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:03.656]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:03.656]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:03.656]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:03.656]             base::names(...future.oldOptions))
[13:21:03.656]     }
[13:21:03.656]     if (FALSE) {
[13:21:03.656]     }
[13:21:03.656]     else {
[13:21:03.656]         if (TRUE) {
[13:21:03.656]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:03.656]                 open = "w")
[13:21:03.656]         }
[13:21:03.656]         else {
[13:21:03.656]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:03.656]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:03.656]         }
[13:21:03.656]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:03.656]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:03.656]             base::sink(type = "output", split = FALSE)
[13:21:03.656]             base::close(...future.stdout)
[13:21:03.656]         }, add = TRUE)
[13:21:03.656]     }
[13:21:03.656]     ...future.frame <- base::sys.nframe()
[13:21:03.656]     ...future.conditions <- base::list()
[13:21:03.656]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:03.656]     if (FALSE) {
[13:21:03.656]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:03.656]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:03.656]     }
[13:21:03.656]     ...future.result <- base::tryCatch({
[13:21:03.656]         base::withCallingHandlers({
[13:21:03.656]             ...future.value <- base::withVisible(base::local({
[13:21:03.656]                 withCallingHandlers({
[13:21:03.656]                   {
[13:21:03.656]                     stop(structure(list(message = "boom"), class = c("MyError", 
[13:21:03.656]                       "error", "condition")))
[13:21:03.656]                   }
[13:21:03.656]                 }, immediateCondition = function(cond) {
[13:21:03.656]                   save_rds <- function (object, pathname, ...) 
[13:21:03.656]                   {
[13:21:03.656]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:03.656]                     if (file_test("-f", pathname_tmp)) {
[13:21:03.656]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.656]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:03.656]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.656]                         fi_tmp[["mtime"]])
[13:21:03.656]                     }
[13:21:03.656]                     tryCatch({
[13:21:03.656]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:03.656]                     }, error = function(ex) {
[13:21:03.656]                       msg <- conditionMessage(ex)
[13:21:03.656]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.656]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:03.656]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.656]                         fi_tmp[["mtime"]], msg)
[13:21:03.656]                       ex$message <- msg
[13:21:03.656]                       stop(ex)
[13:21:03.656]                     })
[13:21:03.656]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:03.656]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:03.656]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:03.656]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.656]                       fi <- file.info(pathname)
[13:21:03.656]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:03.656]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.656]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:03.656]                         fi[["size"]], fi[["mtime"]])
[13:21:03.656]                       stop(msg)
[13:21:03.656]                     }
[13:21:03.656]                     invisible(pathname)
[13:21:03.656]                   }
[13:21:03.656]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:03.656]                     rootPath = tempdir()) 
[13:21:03.656]                   {
[13:21:03.656]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:03.656]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:03.656]                       tmpdir = path, fileext = ".rds")
[13:21:03.656]                     save_rds(obj, file)
[13:21:03.656]                   }
[13:21:03.656]                   saveImmediateCondition(cond, path = "/tmp/Rtmpd6Ly3I/.future/immediateConditions")
[13:21:03.656]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.656]                   {
[13:21:03.656]                     inherits <- base::inherits
[13:21:03.656]                     invokeRestart <- base::invokeRestart
[13:21:03.656]                     is.null <- base::is.null
[13:21:03.656]                     muffled <- FALSE
[13:21:03.656]                     if (inherits(cond, "message")) {
[13:21:03.656]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:03.656]                       if (muffled) 
[13:21:03.656]                         invokeRestart("muffleMessage")
[13:21:03.656]                     }
[13:21:03.656]                     else if (inherits(cond, "warning")) {
[13:21:03.656]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:03.656]                       if (muffled) 
[13:21:03.656]                         invokeRestart("muffleWarning")
[13:21:03.656]                     }
[13:21:03.656]                     else if (inherits(cond, "condition")) {
[13:21:03.656]                       if (!is.null(pattern)) {
[13:21:03.656]                         computeRestarts <- base::computeRestarts
[13:21:03.656]                         grepl <- base::grepl
[13:21:03.656]                         restarts <- computeRestarts(cond)
[13:21:03.656]                         for (restart in restarts) {
[13:21:03.656]                           name <- restart$name
[13:21:03.656]                           if (is.null(name)) 
[13:21:03.656]                             next
[13:21:03.656]                           if (!grepl(pattern, name)) 
[13:21:03.656]                             next
[13:21:03.656]                           invokeRestart(restart)
[13:21:03.656]                           muffled <- TRUE
[13:21:03.656]                           break
[13:21:03.656]                         }
[13:21:03.656]                       }
[13:21:03.656]                     }
[13:21:03.656]                     invisible(muffled)
[13:21:03.656]                   }
[13:21:03.656]                   muffleCondition(cond)
[13:21:03.656]                 })
[13:21:03.656]             }))
[13:21:03.656]             future::FutureResult(value = ...future.value$value, 
[13:21:03.656]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.656]                   ...future.rng), globalenv = if (FALSE) 
[13:21:03.656]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:03.656]                     ...future.globalenv.names))
[13:21:03.656]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:03.656]         }, condition = base::local({
[13:21:03.656]             c <- base::c
[13:21:03.656]             inherits <- base::inherits
[13:21:03.656]             invokeRestart <- base::invokeRestart
[13:21:03.656]             length <- base::length
[13:21:03.656]             list <- base::list
[13:21:03.656]             seq.int <- base::seq.int
[13:21:03.656]             signalCondition <- base::signalCondition
[13:21:03.656]             sys.calls <- base::sys.calls
[13:21:03.656]             `[[` <- base::`[[`
[13:21:03.656]             `+` <- base::`+`
[13:21:03.656]             `<<-` <- base::`<<-`
[13:21:03.656]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:03.656]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:03.656]                   3L)]
[13:21:03.656]             }
[13:21:03.656]             function(cond) {
[13:21:03.656]                 is_error <- inherits(cond, "error")
[13:21:03.656]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:03.656]                   NULL)
[13:21:03.656]                 if (is_error) {
[13:21:03.656]                   sessionInformation <- function() {
[13:21:03.656]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:03.656]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:03.656]                       search = base::search(), system = base::Sys.info())
[13:21:03.656]                   }
[13:21:03.656]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.656]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:03.656]                     cond$call), session = sessionInformation(), 
[13:21:03.656]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:03.656]                   signalCondition(cond)
[13:21:03.656]                 }
[13:21:03.656]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:03.656]                 "immediateCondition"))) {
[13:21:03.656]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:03.656]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.656]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:03.656]                   if (TRUE && !signal) {
[13:21:03.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.656]                     {
[13:21:03.656]                       inherits <- base::inherits
[13:21:03.656]                       invokeRestart <- base::invokeRestart
[13:21:03.656]                       is.null <- base::is.null
[13:21:03.656]                       muffled <- FALSE
[13:21:03.656]                       if (inherits(cond, "message")) {
[13:21:03.656]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.656]                         if (muffled) 
[13:21:03.656]                           invokeRestart("muffleMessage")
[13:21:03.656]                       }
[13:21:03.656]                       else if (inherits(cond, "warning")) {
[13:21:03.656]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.656]                         if (muffled) 
[13:21:03.656]                           invokeRestart("muffleWarning")
[13:21:03.656]                       }
[13:21:03.656]                       else if (inherits(cond, "condition")) {
[13:21:03.656]                         if (!is.null(pattern)) {
[13:21:03.656]                           computeRestarts <- base::computeRestarts
[13:21:03.656]                           grepl <- base::grepl
[13:21:03.656]                           restarts <- computeRestarts(cond)
[13:21:03.656]                           for (restart in restarts) {
[13:21:03.656]                             name <- restart$name
[13:21:03.656]                             if (is.null(name)) 
[13:21:03.656]                               next
[13:21:03.656]                             if (!grepl(pattern, name)) 
[13:21:03.656]                               next
[13:21:03.656]                             invokeRestart(restart)
[13:21:03.656]                             muffled <- TRUE
[13:21:03.656]                             break
[13:21:03.656]                           }
[13:21:03.656]                         }
[13:21:03.656]                       }
[13:21:03.656]                       invisible(muffled)
[13:21:03.656]                     }
[13:21:03.656]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.656]                   }
[13:21:03.656]                 }
[13:21:03.656]                 else {
[13:21:03.656]                   if (TRUE) {
[13:21:03.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.656]                     {
[13:21:03.656]                       inherits <- base::inherits
[13:21:03.656]                       invokeRestart <- base::invokeRestart
[13:21:03.656]                       is.null <- base::is.null
[13:21:03.656]                       muffled <- FALSE
[13:21:03.656]                       if (inherits(cond, "message")) {
[13:21:03.656]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.656]                         if (muffled) 
[13:21:03.656]                           invokeRestart("muffleMessage")
[13:21:03.656]                       }
[13:21:03.656]                       else if (inherits(cond, "warning")) {
[13:21:03.656]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.656]                         if (muffled) 
[13:21:03.656]                           invokeRestart("muffleWarning")
[13:21:03.656]                       }
[13:21:03.656]                       else if (inherits(cond, "condition")) {
[13:21:03.656]                         if (!is.null(pattern)) {
[13:21:03.656]                           computeRestarts <- base::computeRestarts
[13:21:03.656]                           grepl <- base::grepl
[13:21:03.656]                           restarts <- computeRestarts(cond)
[13:21:03.656]                           for (restart in restarts) {
[13:21:03.656]                             name <- restart$name
[13:21:03.656]                             if (is.null(name)) 
[13:21:03.656]                               next
[13:21:03.656]                             if (!grepl(pattern, name)) 
[13:21:03.656]                               next
[13:21:03.656]                             invokeRestart(restart)
[13:21:03.656]                             muffled <- TRUE
[13:21:03.656]                             break
[13:21:03.656]                           }
[13:21:03.656]                         }
[13:21:03.656]                       }
[13:21:03.656]                       invisible(muffled)
[13:21:03.656]                     }
[13:21:03.656]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.656]                   }
[13:21:03.656]                 }
[13:21:03.656]             }
[13:21:03.656]         }))
[13:21:03.656]     }, error = function(ex) {
[13:21:03.656]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:03.656]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.656]                 ...future.rng), started = ...future.startTime, 
[13:21:03.656]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:03.656]             version = "1.8"), class = "FutureResult")
[13:21:03.656]     }, finally = {
[13:21:03.656]         if (!identical(...future.workdir, getwd())) 
[13:21:03.656]             setwd(...future.workdir)
[13:21:03.656]         {
[13:21:03.656]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:03.656]                 ...future.oldOptions$nwarnings <- NULL
[13:21:03.656]             }
[13:21:03.656]             base::options(...future.oldOptions)
[13:21:03.656]             if (.Platform$OS.type == "windows") {
[13:21:03.656]                 old_names <- names(...future.oldEnvVars)
[13:21:03.656]                 envs <- base::Sys.getenv()
[13:21:03.656]                 names <- names(envs)
[13:21:03.656]                 common <- intersect(names, old_names)
[13:21:03.656]                 added <- setdiff(names, old_names)
[13:21:03.656]                 removed <- setdiff(old_names, names)
[13:21:03.656]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:03.656]                   envs[common]]
[13:21:03.656]                 NAMES <- toupper(changed)
[13:21:03.656]                 args <- list()
[13:21:03.656]                 for (kk in seq_along(NAMES)) {
[13:21:03.656]                   name <- changed[[kk]]
[13:21:03.656]                   NAME <- NAMES[[kk]]
[13:21:03.656]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.656]                     next
[13:21:03.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.656]                 }
[13:21:03.656]                 NAMES <- toupper(added)
[13:21:03.656]                 for (kk in seq_along(NAMES)) {
[13:21:03.656]                   name <- added[[kk]]
[13:21:03.656]                   NAME <- NAMES[[kk]]
[13:21:03.656]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.656]                     next
[13:21:03.656]                   args[[name]] <- ""
[13:21:03.656]                 }
[13:21:03.656]                 NAMES <- toupper(removed)
[13:21:03.656]                 for (kk in seq_along(NAMES)) {
[13:21:03.656]                   name <- removed[[kk]]
[13:21:03.656]                   NAME <- NAMES[[kk]]
[13:21:03.656]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.656]                     next
[13:21:03.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.656]                 }
[13:21:03.656]                 if (length(args) > 0) 
[13:21:03.656]                   base::do.call(base::Sys.setenv, args = args)
[13:21:03.656]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:03.656]             }
[13:21:03.656]             else {
[13:21:03.656]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:03.656]             }
[13:21:03.656]             {
[13:21:03.656]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:03.656]                   0L) {
[13:21:03.656]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:03.656]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:03.656]                   base::options(opts)
[13:21:03.656]                 }
[13:21:03.656]                 {
[13:21:03.656]                   {
[13:21:03.656]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:03.656]                     NULL
[13:21:03.656]                   }
[13:21:03.656]                   options(future.plan = NULL)
[13:21:03.656]                   if (is.na(NA_character_)) 
[13:21:03.656]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.656]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:03.656]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:03.656]                     envir = parent.frame()) 
[13:21:03.656]                   {
[13:21:03.656]                     default_workers <- missing(workers)
[13:21:03.656]                     if (is.function(workers)) 
[13:21:03.656]                       workers <- workers()
[13:21:03.656]                     workers <- structure(as.integer(workers), 
[13:21:03.656]                       class = class(workers))
[13:21:03.656]                     stop_if_not(is.finite(workers), workers >= 
[13:21:03.656]                       1L)
[13:21:03.656]                     if ((workers == 1L && !inherits(workers, 
[13:21:03.656]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:03.656]                       if (default_workers) 
[13:21:03.656]                         supportsMulticore(warn = TRUE)
[13:21:03.656]                       return(sequential(..., envir = envir))
[13:21:03.656]                     }
[13:21:03.656]                     oopts <- options(mc.cores = workers)
[13:21:03.656]                     on.exit(options(oopts))
[13:21:03.656]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:03.656]                       envir = envir)
[13:21:03.656]                     if (!future$lazy) 
[13:21:03.656]                       future <- run(future)
[13:21:03.656]                     invisible(future)
[13:21:03.656]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:03.656]                 }
[13:21:03.656]             }
[13:21:03.656]         }
[13:21:03.656]     })
[13:21:03.656]     if (TRUE) {
[13:21:03.656]         base::sink(type = "output", split = FALSE)
[13:21:03.656]         if (TRUE) {
[13:21:03.656]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:03.656]         }
[13:21:03.656]         else {
[13:21:03.656]             ...future.result["stdout"] <- base::list(NULL)
[13:21:03.656]         }
[13:21:03.656]         base::close(...future.stdout)
[13:21:03.656]         ...future.stdout <- NULL
[13:21:03.656]     }
[13:21:03.656]     ...future.result$conditions <- ...future.conditions
[13:21:03.656]     ...future.result$finished <- base::Sys.time()
[13:21:03.656]     ...future.result
[13:21:03.656] }
[13:21:03.658] requestCore(): workers = 2
[13:21:03.660] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:03.661] plan(): Setting new future strategy stack:
[13:21:03.661] List of future strategies:
[13:21:03.661] 1. sequential:
[13:21:03.661]    - args: function (..., envir = parent.frame())
[13:21:03.661]    - tweaked: FALSE
[13:21:03.661]    - call: NULL
[13:21:03.662] plan(): nbrOfWorkers() = 1
[13:21:03.664] plan(): Setting new future strategy stack:
[13:21:03.664] List of future strategies:
[13:21:03.664] 1. multicore:
[13:21:03.664]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:03.664]    - tweaked: FALSE
[13:21:03.664]    - call: plan(multicore)
[13:21:03.669] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 32f7abe8-d290-272e-8911-a8ce072c31c3
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:03.674] signalConditions() ...
[13:21:03.674]  - include = ‘immediateCondition’
[13:21:03.674]  - exclude = 
[13:21:03.674]  - resignal = FALSE
[13:21:03.674]  - Number of conditions: 1
[13:21:03.674] signalConditions() ... done
[13:21:03.674] signalConditions() ...
[13:21:03.675]  - include = ‘immediateCondition’
[13:21:03.675]  - exclude = 
[13:21:03.675]  - resignal = FALSE
[13:21:03.675]  - Number of conditions: 1
[13:21:03.675] signalConditions() ... done
<MyError: boom>
[13:21:03.675] signalConditions() ...
[13:21:03.675]  - include = ‘immediateCondition’
[13:21:03.676]  - exclude = 
[13:21:03.676]  - resignal = FALSE
[13:21:03.676]  - Number of conditions: 1
[13:21:03.676] signalConditions() ... done
[13:21:03.676] Future state: ‘finished’
[13:21:03.676] signalConditions() ...
[13:21:03.676]  - include = ‘condition’
[13:21:03.676]  - exclude = ‘immediateCondition’
[13:21:03.676]  - resignal = TRUE
[13:21:03.677]  - Number of conditions: 1
[13:21:03.677]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[13:21:03.677] signalConditions() ... done
*** multicore(..., globals = TRUE) without globals
[13:21:03.681] getGlobalsAndPackages() ...
[13:21:03.681] Searching for globals...
[13:21:03.682] - globals found: [1] ‘{’
[13:21:03.682] Searching for globals ... DONE
[13:21:03.682] Resolving globals: FALSE
[13:21:03.682] 
[13:21:03.682] 
[13:21:03.683] getGlobalsAndPackages() ... DONE
[13:21:03.683] Packages needed by the future expression (n = 0): <none>
[13:21:03.683] Packages needed by future strategies (n = 0): <none>
[13:21:03.684] {
[13:21:03.684]     {
[13:21:03.684]         {
[13:21:03.684]             ...future.startTime <- base::Sys.time()
[13:21:03.684]             {
[13:21:03.684]                 {
[13:21:03.684]                   {
[13:21:03.684]                     {
[13:21:03.684]                       base::local({
[13:21:03.684]                         has_future <- base::requireNamespace("future", 
[13:21:03.684]                           quietly = TRUE)
[13:21:03.684]                         if (has_future) {
[13:21:03.684]                           ns <- base::getNamespace("future")
[13:21:03.684]                           version <- ns[[".package"]][["version"]]
[13:21:03.684]                           if (is.null(version)) 
[13:21:03.684]                             version <- utils::packageVersion("future")
[13:21:03.684]                         }
[13:21:03.684]                         else {
[13:21:03.684]                           version <- NULL
[13:21:03.684]                         }
[13:21:03.684]                         if (!has_future || version < "1.8.0") {
[13:21:03.684]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:03.684]                             "", base::R.version$version.string), 
[13:21:03.684]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:03.684]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:03.684]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:03.684]                               "release", "version")], collapse = " "), 
[13:21:03.684]                             hostname = base::Sys.info()[["nodename"]])
[13:21:03.684]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:03.684]                             info)
[13:21:03.684]                           info <- base::paste(info, collapse = "; ")
[13:21:03.684]                           if (!has_future) {
[13:21:03.684]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:03.684]                               info)
[13:21:03.684]                           }
[13:21:03.684]                           else {
[13:21:03.684]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:03.684]                               info, version)
[13:21:03.684]                           }
[13:21:03.684]                           base::stop(msg)
[13:21:03.684]                         }
[13:21:03.684]                       })
[13:21:03.684]                     }
[13:21:03.684]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:03.684]                     base::options(mc.cores = 1L)
[13:21:03.684]                   }
[13:21:03.684]                   options(future.plan = NULL)
[13:21:03.684]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.684]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:03.684]                 }
[13:21:03.684]                 ...future.workdir <- getwd()
[13:21:03.684]             }
[13:21:03.684]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:03.684]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:03.684]         }
[13:21:03.684]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:03.684]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:03.684]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:03.684]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:03.684]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:03.684]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:03.684]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:03.684]             base::names(...future.oldOptions))
[13:21:03.684]     }
[13:21:03.684]     if (FALSE) {
[13:21:03.684]     }
[13:21:03.684]     else {
[13:21:03.684]         if (TRUE) {
[13:21:03.684]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:03.684]                 open = "w")
[13:21:03.684]         }
[13:21:03.684]         else {
[13:21:03.684]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:03.684]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:03.684]         }
[13:21:03.684]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:03.684]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:03.684]             base::sink(type = "output", split = FALSE)
[13:21:03.684]             base::close(...future.stdout)
[13:21:03.684]         }, add = TRUE)
[13:21:03.684]     }
[13:21:03.684]     ...future.frame <- base::sys.nframe()
[13:21:03.684]     ...future.conditions <- base::list()
[13:21:03.684]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:03.684]     if (FALSE) {
[13:21:03.684]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:03.684]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:03.684]     }
[13:21:03.684]     ...future.result <- base::tryCatch({
[13:21:03.684]         base::withCallingHandlers({
[13:21:03.684]             ...future.value <- base::withVisible(base::local({
[13:21:03.684]                 withCallingHandlers({
[13:21:03.684]                   {
[13:21:03.684]                     42L
[13:21:03.684]                   }
[13:21:03.684]                 }, immediateCondition = function(cond) {
[13:21:03.684]                   save_rds <- function (object, pathname, ...) 
[13:21:03.684]                   {
[13:21:03.684]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:03.684]                     if (file_test("-f", pathname_tmp)) {
[13:21:03.684]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.684]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:03.684]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.684]                         fi_tmp[["mtime"]])
[13:21:03.684]                     }
[13:21:03.684]                     tryCatch({
[13:21:03.684]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:03.684]                     }, error = function(ex) {
[13:21:03.684]                       msg <- conditionMessage(ex)
[13:21:03.684]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.684]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:03.684]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.684]                         fi_tmp[["mtime"]], msg)
[13:21:03.684]                       ex$message <- msg
[13:21:03.684]                       stop(ex)
[13:21:03.684]                     })
[13:21:03.684]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:03.684]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:03.684]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:03.684]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.684]                       fi <- file.info(pathname)
[13:21:03.684]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:03.684]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.684]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:03.684]                         fi[["size"]], fi[["mtime"]])
[13:21:03.684]                       stop(msg)
[13:21:03.684]                     }
[13:21:03.684]                     invisible(pathname)
[13:21:03.684]                   }
[13:21:03.684]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:03.684]                     rootPath = tempdir()) 
[13:21:03.684]                   {
[13:21:03.684]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:03.684]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:03.684]                       tmpdir = path, fileext = ".rds")
[13:21:03.684]                     save_rds(obj, file)
[13:21:03.684]                   }
[13:21:03.684]                   saveImmediateCondition(cond, path = "/tmp/Rtmpd6Ly3I/.future/immediateConditions")
[13:21:03.684]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.684]                   {
[13:21:03.684]                     inherits <- base::inherits
[13:21:03.684]                     invokeRestart <- base::invokeRestart
[13:21:03.684]                     is.null <- base::is.null
[13:21:03.684]                     muffled <- FALSE
[13:21:03.684]                     if (inherits(cond, "message")) {
[13:21:03.684]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:03.684]                       if (muffled) 
[13:21:03.684]                         invokeRestart("muffleMessage")
[13:21:03.684]                     }
[13:21:03.684]                     else if (inherits(cond, "warning")) {
[13:21:03.684]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:03.684]                       if (muffled) 
[13:21:03.684]                         invokeRestart("muffleWarning")
[13:21:03.684]                     }
[13:21:03.684]                     else if (inherits(cond, "condition")) {
[13:21:03.684]                       if (!is.null(pattern)) {
[13:21:03.684]                         computeRestarts <- base::computeRestarts
[13:21:03.684]                         grepl <- base::grepl
[13:21:03.684]                         restarts <- computeRestarts(cond)
[13:21:03.684]                         for (restart in restarts) {
[13:21:03.684]                           name <- restart$name
[13:21:03.684]                           if (is.null(name)) 
[13:21:03.684]                             next
[13:21:03.684]                           if (!grepl(pattern, name)) 
[13:21:03.684]                             next
[13:21:03.684]                           invokeRestart(restart)
[13:21:03.684]                           muffled <- TRUE
[13:21:03.684]                           break
[13:21:03.684]                         }
[13:21:03.684]                       }
[13:21:03.684]                     }
[13:21:03.684]                     invisible(muffled)
[13:21:03.684]                   }
[13:21:03.684]                   muffleCondition(cond)
[13:21:03.684]                 })
[13:21:03.684]             }))
[13:21:03.684]             future::FutureResult(value = ...future.value$value, 
[13:21:03.684]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.684]                   ...future.rng), globalenv = if (FALSE) 
[13:21:03.684]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:03.684]                     ...future.globalenv.names))
[13:21:03.684]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:03.684]         }, condition = base::local({
[13:21:03.684]             c <- base::c
[13:21:03.684]             inherits <- base::inherits
[13:21:03.684]             invokeRestart <- base::invokeRestart
[13:21:03.684]             length <- base::length
[13:21:03.684]             list <- base::list
[13:21:03.684]             seq.int <- base::seq.int
[13:21:03.684]             signalCondition <- base::signalCondition
[13:21:03.684]             sys.calls <- base::sys.calls
[13:21:03.684]             `[[` <- base::`[[`
[13:21:03.684]             `+` <- base::`+`
[13:21:03.684]             `<<-` <- base::`<<-`
[13:21:03.684]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:03.684]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:03.684]                   3L)]
[13:21:03.684]             }
[13:21:03.684]             function(cond) {
[13:21:03.684]                 is_error <- inherits(cond, "error")
[13:21:03.684]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:03.684]                   NULL)
[13:21:03.684]                 if (is_error) {
[13:21:03.684]                   sessionInformation <- function() {
[13:21:03.684]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:03.684]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:03.684]                       search = base::search(), system = base::Sys.info())
[13:21:03.684]                   }
[13:21:03.684]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.684]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:03.684]                     cond$call), session = sessionInformation(), 
[13:21:03.684]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:03.684]                   signalCondition(cond)
[13:21:03.684]                 }
[13:21:03.684]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:03.684]                 "immediateCondition"))) {
[13:21:03.684]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:03.684]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.684]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:03.684]                   if (TRUE && !signal) {
[13:21:03.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.684]                     {
[13:21:03.684]                       inherits <- base::inherits
[13:21:03.684]                       invokeRestart <- base::invokeRestart
[13:21:03.684]                       is.null <- base::is.null
[13:21:03.684]                       muffled <- FALSE
[13:21:03.684]                       if (inherits(cond, "message")) {
[13:21:03.684]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.684]                         if (muffled) 
[13:21:03.684]                           invokeRestart("muffleMessage")
[13:21:03.684]                       }
[13:21:03.684]                       else if (inherits(cond, "warning")) {
[13:21:03.684]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.684]                         if (muffled) 
[13:21:03.684]                           invokeRestart("muffleWarning")
[13:21:03.684]                       }
[13:21:03.684]                       else if (inherits(cond, "condition")) {
[13:21:03.684]                         if (!is.null(pattern)) {
[13:21:03.684]                           computeRestarts <- base::computeRestarts
[13:21:03.684]                           grepl <- base::grepl
[13:21:03.684]                           restarts <- computeRestarts(cond)
[13:21:03.684]                           for (restart in restarts) {
[13:21:03.684]                             name <- restart$name
[13:21:03.684]                             if (is.null(name)) 
[13:21:03.684]                               next
[13:21:03.684]                             if (!grepl(pattern, name)) 
[13:21:03.684]                               next
[13:21:03.684]                             invokeRestart(restart)
[13:21:03.684]                             muffled <- TRUE
[13:21:03.684]                             break
[13:21:03.684]                           }
[13:21:03.684]                         }
[13:21:03.684]                       }
[13:21:03.684]                       invisible(muffled)
[13:21:03.684]                     }
[13:21:03.684]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.684]                   }
[13:21:03.684]                 }
[13:21:03.684]                 else {
[13:21:03.684]                   if (TRUE) {
[13:21:03.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.684]                     {
[13:21:03.684]                       inherits <- base::inherits
[13:21:03.684]                       invokeRestart <- base::invokeRestart
[13:21:03.684]                       is.null <- base::is.null
[13:21:03.684]                       muffled <- FALSE
[13:21:03.684]                       if (inherits(cond, "message")) {
[13:21:03.684]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.684]                         if (muffled) 
[13:21:03.684]                           invokeRestart("muffleMessage")
[13:21:03.684]                       }
[13:21:03.684]                       else if (inherits(cond, "warning")) {
[13:21:03.684]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.684]                         if (muffled) 
[13:21:03.684]                           invokeRestart("muffleWarning")
[13:21:03.684]                       }
[13:21:03.684]                       else if (inherits(cond, "condition")) {
[13:21:03.684]                         if (!is.null(pattern)) {
[13:21:03.684]                           computeRestarts <- base::computeRestarts
[13:21:03.684]                           grepl <- base::grepl
[13:21:03.684]                           restarts <- computeRestarts(cond)
[13:21:03.684]                           for (restart in restarts) {
[13:21:03.684]                             name <- restart$name
[13:21:03.684]                             if (is.null(name)) 
[13:21:03.684]                               next
[13:21:03.684]                             if (!grepl(pattern, name)) 
[13:21:03.684]                               next
[13:21:03.684]                             invokeRestart(restart)
[13:21:03.684]                             muffled <- TRUE
[13:21:03.684]                             break
[13:21:03.684]                           }
[13:21:03.684]                         }
[13:21:03.684]                       }
[13:21:03.684]                       invisible(muffled)
[13:21:03.684]                     }
[13:21:03.684]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.684]                   }
[13:21:03.684]                 }
[13:21:03.684]             }
[13:21:03.684]         }))
[13:21:03.684]     }, error = function(ex) {
[13:21:03.684]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:03.684]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.684]                 ...future.rng), started = ...future.startTime, 
[13:21:03.684]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:03.684]             version = "1.8"), class = "FutureResult")
[13:21:03.684]     }, finally = {
[13:21:03.684]         if (!identical(...future.workdir, getwd())) 
[13:21:03.684]             setwd(...future.workdir)
[13:21:03.684]         {
[13:21:03.684]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:03.684]                 ...future.oldOptions$nwarnings <- NULL
[13:21:03.684]             }
[13:21:03.684]             base::options(...future.oldOptions)
[13:21:03.684]             if (.Platform$OS.type == "windows") {
[13:21:03.684]                 old_names <- names(...future.oldEnvVars)
[13:21:03.684]                 envs <- base::Sys.getenv()
[13:21:03.684]                 names <- names(envs)
[13:21:03.684]                 common <- intersect(names, old_names)
[13:21:03.684]                 added <- setdiff(names, old_names)
[13:21:03.684]                 removed <- setdiff(old_names, names)
[13:21:03.684]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:03.684]                   envs[common]]
[13:21:03.684]                 NAMES <- toupper(changed)
[13:21:03.684]                 args <- list()
[13:21:03.684]                 for (kk in seq_along(NAMES)) {
[13:21:03.684]                   name <- changed[[kk]]
[13:21:03.684]                   NAME <- NAMES[[kk]]
[13:21:03.684]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.684]                     next
[13:21:03.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.684]                 }
[13:21:03.684]                 NAMES <- toupper(added)
[13:21:03.684]                 for (kk in seq_along(NAMES)) {
[13:21:03.684]                   name <- added[[kk]]
[13:21:03.684]                   NAME <- NAMES[[kk]]
[13:21:03.684]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.684]                     next
[13:21:03.684]                   args[[name]] <- ""
[13:21:03.684]                 }
[13:21:03.684]                 NAMES <- toupper(removed)
[13:21:03.684]                 for (kk in seq_along(NAMES)) {
[13:21:03.684]                   name <- removed[[kk]]
[13:21:03.684]                   NAME <- NAMES[[kk]]
[13:21:03.684]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.684]                     next
[13:21:03.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.684]                 }
[13:21:03.684]                 if (length(args) > 0) 
[13:21:03.684]                   base::do.call(base::Sys.setenv, args = args)
[13:21:03.684]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:03.684]             }
[13:21:03.684]             else {
[13:21:03.684]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:03.684]             }
[13:21:03.684]             {
[13:21:03.684]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:03.684]                   0L) {
[13:21:03.684]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:03.684]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:03.684]                   base::options(opts)
[13:21:03.684]                 }
[13:21:03.684]                 {
[13:21:03.684]                   {
[13:21:03.684]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:03.684]                     NULL
[13:21:03.684]                   }
[13:21:03.684]                   options(future.plan = NULL)
[13:21:03.684]                   if (is.na(NA_character_)) 
[13:21:03.684]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.684]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:03.684]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:03.684]                     envir = parent.frame()) 
[13:21:03.684]                   {
[13:21:03.684]                     default_workers <- missing(workers)
[13:21:03.684]                     if (is.function(workers)) 
[13:21:03.684]                       workers <- workers()
[13:21:03.684]                     workers <- structure(as.integer(workers), 
[13:21:03.684]                       class = class(workers))
[13:21:03.684]                     stop_if_not(is.finite(workers), workers >= 
[13:21:03.684]                       1L)
[13:21:03.684]                     if ((workers == 1L && !inherits(workers, 
[13:21:03.684]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:03.684]                       if (default_workers) 
[13:21:03.684]                         supportsMulticore(warn = TRUE)
[13:21:03.684]                       return(sequential(..., envir = envir))
[13:21:03.684]                     }
[13:21:03.684]                     oopts <- options(mc.cores = workers)
[13:21:03.684]                     on.exit(options(oopts))
[13:21:03.684]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:03.684]                       envir = envir)
[13:21:03.684]                     if (!future$lazy) 
[13:21:03.684]                       future <- run(future)
[13:21:03.684]                     invisible(future)
[13:21:03.684]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:03.684]                 }
[13:21:03.684]             }
[13:21:03.684]         }
[13:21:03.684]     })
[13:21:03.684]     if (TRUE) {
[13:21:03.684]         base::sink(type = "output", split = FALSE)
[13:21:03.684]         if (TRUE) {
[13:21:03.684]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:03.684]         }
[13:21:03.684]         else {
[13:21:03.684]             ...future.result["stdout"] <- base::list(NULL)
[13:21:03.684]         }
[13:21:03.684]         base::close(...future.stdout)
[13:21:03.684]         ...future.stdout <- NULL
[13:21:03.684]     }
[13:21:03.684]     ...future.result$conditions <- ...future.conditions
[13:21:03.684]     ...future.result$finished <- base::Sys.time()
[13:21:03.684]     ...future.result
[13:21:03.684] }
[13:21:03.686] requestCore(): workers = 2
[13:21:03.688] MulticoreFuture started
[13:21:03.689] plan(): Setting new future strategy stack:
[13:21:03.689] List of future strategies:
[13:21:03.689] 1. sequential:
[13:21:03.689]    - args: function (..., envir = parent.frame())
[13:21:03.689]    - tweaked: FALSE
[13:21:03.689]    - call: NULL
[13:21:03.690] plan(): nbrOfWorkers() = 1
[13:21:03.692] plan(): Setting new future strategy stack:
[13:21:03.692] List of future strategies:
[13:21:03.692] 1. multicore:
[13:21:03.692]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:03.692]    - tweaked: FALSE
[13:21:03.692]    - call: plan(multicore)
[13:21:03.697] plan(): nbrOfWorkers() = 2
[1] TRUE
[1] 42
*** multicore(..., globals = TRUE) with globals
[13:21:03.702] getGlobalsAndPackages() ...
[13:21:03.702] Searching for globals...
[13:21:03.705] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘a’
[13:21:03.705] Searching for globals ... DONE
[13:21:03.705] Resolving globals: FALSE
[13:21:03.706] The total size of the 1 globals is 56 bytes (56 bytes)
[13:21:03.706] The total size of the 1 globals exported for future expression (‘{; b <- 3; c <- 2; a * b * c; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:21:03.706] - globals: [1] ‘a’
[13:21:03.706] 
[13:21:03.706] getGlobalsAndPackages() ... DONE
[13:21:03.707] Packages needed by the future expression (n = 0): <none>
[13:21:03.707] Packages needed by future strategies (n = 0): <none>
[13:21:03.708] {
[13:21:03.708]     {
[13:21:03.708]         {
[13:21:03.708]             ...future.startTime <- base::Sys.time()
[13:21:03.708]             {
[13:21:03.708]                 {
[13:21:03.708]                   {
[13:21:03.708]                     {
[13:21:03.708]                       base::local({
[13:21:03.708]                         has_future <- base::requireNamespace("future", 
[13:21:03.708]                           quietly = TRUE)
[13:21:03.708]                         if (has_future) {
[13:21:03.708]                           ns <- base::getNamespace("future")
[13:21:03.708]                           version <- ns[[".package"]][["version"]]
[13:21:03.708]                           if (is.null(version)) 
[13:21:03.708]                             version <- utils::packageVersion("future")
[13:21:03.708]                         }
[13:21:03.708]                         else {
[13:21:03.708]                           version <- NULL
[13:21:03.708]                         }
[13:21:03.708]                         if (!has_future || version < "1.8.0") {
[13:21:03.708]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:03.708]                             "", base::R.version$version.string), 
[13:21:03.708]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:03.708]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:03.708]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:03.708]                               "release", "version")], collapse = " "), 
[13:21:03.708]                             hostname = base::Sys.info()[["nodename"]])
[13:21:03.708]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:03.708]                             info)
[13:21:03.708]                           info <- base::paste(info, collapse = "; ")
[13:21:03.708]                           if (!has_future) {
[13:21:03.708]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:03.708]                               info)
[13:21:03.708]                           }
[13:21:03.708]                           else {
[13:21:03.708]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:03.708]                               info, version)
[13:21:03.708]                           }
[13:21:03.708]                           base::stop(msg)
[13:21:03.708]                         }
[13:21:03.708]                       })
[13:21:03.708]                     }
[13:21:03.708]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:03.708]                     base::options(mc.cores = 1L)
[13:21:03.708]                   }
[13:21:03.708]                   options(future.plan = NULL)
[13:21:03.708]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.708]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:03.708]                 }
[13:21:03.708]                 ...future.workdir <- getwd()
[13:21:03.708]             }
[13:21:03.708]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:03.708]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:03.708]         }
[13:21:03.708]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:03.708]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:03.708]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:03.708]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:03.708]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:03.708]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:03.708]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:03.708]             base::names(...future.oldOptions))
[13:21:03.708]     }
[13:21:03.708]     if (FALSE) {
[13:21:03.708]     }
[13:21:03.708]     else {
[13:21:03.708]         if (TRUE) {
[13:21:03.708]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:03.708]                 open = "w")
[13:21:03.708]         }
[13:21:03.708]         else {
[13:21:03.708]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:03.708]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:03.708]         }
[13:21:03.708]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:03.708]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:03.708]             base::sink(type = "output", split = FALSE)
[13:21:03.708]             base::close(...future.stdout)
[13:21:03.708]         }, add = TRUE)
[13:21:03.708]     }
[13:21:03.708]     ...future.frame <- base::sys.nframe()
[13:21:03.708]     ...future.conditions <- base::list()
[13:21:03.708]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:03.708]     if (FALSE) {
[13:21:03.708]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:03.708]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:03.708]     }
[13:21:03.708]     ...future.result <- base::tryCatch({
[13:21:03.708]         base::withCallingHandlers({
[13:21:03.708]             ...future.value <- base::withVisible(base::local({
[13:21:03.708]                 withCallingHandlers({
[13:21:03.708]                   {
[13:21:03.708]                     b <- 3
[13:21:03.708]                     c <- 2
[13:21:03.708]                     a * b * c
[13:21:03.708]                   }
[13:21:03.708]                 }, immediateCondition = function(cond) {
[13:21:03.708]                   save_rds <- function (object, pathname, ...) 
[13:21:03.708]                   {
[13:21:03.708]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:03.708]                     if (file_test("-f", pathname_tmp)) {
[13:21:03.708]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.708]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:03.708]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.708]                         fi_tmp[["mtime"]])
[13:21:03.708]                     }
[13:21:03.708]                     tryCatch({
[13:21:03.708]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:03.708]                     }, error = function(ex) {
[13:21:03.708]                       msg <- conditionMessage(ex)
[13:21:03.708]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.708]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:03.708]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.708]                         fi_tmp[["mtime"]], msg)
[13:21:03.708]                       ex$message <- msg
[13:21:03.708]                       stop(ex)
[13:21:03.708]                     })
[13:21:03.708]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:03.708]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:03.708]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:03.708]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.708]                       fi <- file.info(pathname)
[13:21:03.708]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:03.708]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.708]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:03.708]                         fi[["size"]], fi[["mtime"]])
[13:21:03.708]                       stop(msg)
[13:21:03.708]                     }
[13:21:03.708]                     invisible(pathname)
[13:21:03.708]                   }
[13:21:03.708]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:03.708]                     rootPath = tempdir()) 
[13:21:03.708]                   {
[13:21:03.708]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:03.708]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:03.708]                       tmpdir = path, fileext = ".rds")
[13:21:03.708]                     save_rds(obj, file)
[13:21:03.708]                   }
[13:21:03.708]                   saveImmediateCondition(cond, path = "/tmp/Rtmpd6Ly3I/.future/immediateConditions")
[13:21:03.708]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.708]                   {
[13:21:03.708]                     inherits <- base::inherits
[13:21:03.708]                     invokeRestart <- base::invokeRestart
[13:21:03.708]                     is.null <- base::is.null
[13:21:03.708]                     muffled <- FALSE
[13:21:03.708]                     if (inherits(cond, "message")) {
[13:21:03.708]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:03.708]                       if (muffled) 
[13:21:03.708]                         invokeRestart("muffleMessage")
[13:21:03.708]                     }
[13:21:03.708]                     else if (inherits(cond, "warning")) {
[13:21:03.708]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:03.708]                       if (muffled) 
[13:21:03.708]                         invokeRestart("muffleWarning")
[13:21:03.708]                     }
[13:21:03.708]                     else if (inherits(cond, "condition")) {
[13:21:03.708]                       if (!is.null(pattern)) {
[13:21:03.708]                         computeRestarts <- base::computeRestarts
[13:21:03.708]                         grepl <- base::grepl
[13:21:03.708]                         restarts <- computeRestarts(cond)
[13:21:03.708]                         for (restart in restarts) {
[13:21:03.708]                           name <- restart$name
[13:21:03.708]                           if (is.null(name)) 
[13:21:03.708]                             next
[13:21:03.708]                           if (!grepl(pattern, name)) 
[13:21:03.708]                             next
[13:21:03.708]                           invokeRestart(restart)
[13:21:03.708]                           muffled <- TRUE
[13:21:03.708]                           break
[13:21:03.708]                         }
[13:21:03.708]                       }
[13:21:03.708]                     }
[13:21:03.708]                     invisible(muffled)
[13:21:03.708]                   }
[13:21:03.708]                   muffleCondition(cond)
[13:21:03.708]                 })
[13:21:03.708]             }))
[13:21:03.708]             future::FutureResult(value = ...future.value$value, 
[13:21:03.708]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.708]                   ...future.rng), globalenv = if (FALSE) 
[13:21:03.708]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:03.708]                     ...future.globalenv.names))
[13:21:03.708]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:03.708]         }, condition = base::local({
[13:21:03.708]             c <- base::c
[13:21:03.708]             inherits <- base::inherits
[13:21:03.708]             invokeRestart <- base::invokeRestart
[13:21:03.708]             length <- base::length
[13:21:03.708]             list <- base::list
[13:21:03.708]             seq.int <- base::seq.int
[13:21:03.708]             signalCondition <- base::signalCondition
[13:21:03.708]             sys.calls <- base::sys.calls
[13:21:03.708]             `[[` <- base::`[[`
[13:21:03.708]             `+` <- base::`+`
[13:21:03.708]             `<<-` <- base::`<<-`
[13:21:03.708]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:03.708]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:03.708]                   3L)]
[13:21:03.708]             }
[13:21:03.708]             function(cond) {
[13:21:03.708]                 is_error <- inherits(cond, "error")
[13:21:03.708]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:03.708]                   NULL)
[13:21:03.708]                 if (is_error) {
[13:21:03.708]                   sessionInformation <- function() {
[13:21:03.708]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:03.708]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:03.708]                       search = base::search(), system = base::Sys.info())
[13:21:03.708]                   }
[13:21:03.708]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.708]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:03.708]                     cond$call), session = sessionInformation(), 
[13:21:03.708]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:03.708]                   signalCondition(cond)
[13:21:03.708]                 }
[13:21:03.708]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:03.708]                 "immediateCondition"))) {
[13:21:03.708]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:03.708]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.708]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:03.708]                   if (TRUE && !signal) {
[13:21:03.708]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.708]                     {
[13:21:03.708]                       inherits <- base::inherits
[13:21:03.708]                       invokeRestart <- base::invokeRestart
[13:21:03.708]                       is.null <- base::is.null
[13:21:03.708]                       muffled <- FALSE
[13:21:03.708]                       if (inherits(cond, "message")) {
[13:21:03.708]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.708]                         if (muffled) 
[13:21:03.708]                           invokeRestart("muffleMessage")
[13:21:03.708]                       }
[13:21:03.708]                       else if (inherits(cond, "warning")) {
[13:21:03.708]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.708]                         if (muffled) 
[13:21:03.708]                           invokeRestart("muffleWarning")
[13:21:03.708]                       }
[13:21:03.708]                       else if (inherits(cond, "condition")) {
[13:21:03.708]                         if (!is.null(pattern)) {
[13:21:03.708]                           computeRestarts <- base::computeRestarts
[13:21:03.708]                           grepl <- base::grepl
[13:21:03.708]                           restarts <- computeRestarts(cond)
[13:21:03.708]                           for (restart in restarts) {
[13:21:03.708]                             name <- restart$name
[13:21:03.708]                             if (is.null(name)) 
[13:21:03.708]                               next
[13:21:03.708]                             if (!grepl(pattern, name)) 
[13:21:03.708]                               next
[13:21:03.708]                             invokeRestart(restart)
[13:21:03.708]                             muffled <- TRUE
[13:21:03.708]                             break
[13:21:03.708]                           }
[13:21:03.708]                         }
[13:21:03.708]                       }
[13:21:03.708]                       invisible(muffled)
[13:21:03.708]                     }
[13:21:03.708]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.708]                   }
[13:21:03.708]                 }
[13:21:03.708]                 else {
[13:21:03.708]                   if (TRUE) {
[13:21:03.708]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.708]                     {
[13:21:03.708]                       inherits <- base::inherits
[13:21:03.708]                       invokeRestart <- base::invokeRestart
[13:21:03.708]                       is.null <- base::is.null
[13:21:03.708]                       muffled <- FALSE
[13:21:03.708]                       if (inherits(cond, "message")) {
[13:21:03.708]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.708]                         if (muffled) 
[13:21:03.708]                           invokeRestart("muffleMessage")
[13:21:03.708]                       }
[13:21:03.708]                       else if (inherits(cond, "warning")) {
[13:21:03.708]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.708]                         if (muffled) 
[13:21:03.708]                           invokeRestart("muffleWarning")
[13:21:03.708]                       }
[13:21:03.708]                       else if (inherits(cond, "condition")) {
[13:21:03.708]                         if (!is.null(pattern)) {
[13:21:03.708]                           computeRestarts <- base::computeRestarts
[13:21:03.708]                           grepl <- base::grepl
[13:21:03.708]                           restarts <- computeRestarts(cond)
[13:21:03.708]                           for (restart in restarts) {
[13:21:03.708]                             name <- restart$name
[13:21:03.708]                             if (is.null(name)) 
[13:21:03.708]                               next
[13:21:03.708]                             if (!grepl(pattern, name)) 
[13:21:03.708]                               next
[13:21:03.708]                             invokeRestart(restart)
[13:21:03.708]                             muffled <- TRUE
[13:21:03.708]                             break
[13:21:03.708]                           }
[13:21:03.708]                         }
[13:21:03.708]                       }
[13:21:03.708]                       invisible(muffled)
[13:21:03.708]                     }
[13:21:03.708]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.708]                   }
[13:21:03.708]                 }
[13:21:03.708]             }
[13:21:03.708]         }))
[13:21:03.708]     }, error = function(ex) {
[13:21:03.708]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:03.708]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.708]                 ...future.rng), started = ...future.startTime, 
[13:21:03.708]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:03.708]             version = "1.8"), class = "FutureResult")
[13:21:03.708]     }, finally = {
[13:21:03.708]         if (!identical(...future.workdir, getwd())) 
[13:21:03.708]             setwd(...future.workdir)
[13:21:03.708]         {
[13:21:03.708]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:03.708]                 ...future.oldOptions$nwarnings <- NULL
[13:21:03.708]             }
[13:21:03.708]             base::options(...future.oldOptions)
[13:21:03.708]             if (.Platform$OS.type == "windows") {
[13:21:03.708]                 old_names <- names(...future.oldEnvVars)
[13:21:03.708]                 envs <- base::Sys.getenv()
[13:21:03.708]                 names <- names(envs)
[13:21:03.708]                 common <- intersect(names, old_names)
[13:21:03.708]                 added <- setdiff(names, old_names)
[13:21:03.708]                 removed <- setdiff(old_names, names)
[13:21:03.708]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:03.708]                   envs[common]]
[13:21:03.708]                 NAMES <- toupper(changed)
[13:21:03.708]                 args <- list()
[13:21:03.708]                 for (kk in seq_along(NAMES)) {
[13:21:03.708]                   name <- changed[[kk]]
[13:21:03.708]                   NAME <- NAMES[[kk]]
[13:21:03.708]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.708]                     next
[13:21:03.708]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.708]                 }
[13:21:03.708]                 NAMES <- toupper(added)
[13:21:03.708]                 for (kk in seq_along(NAMES)) {
[13:21:03.708]                   name <- added[[kk]]
[13:21:03.708]                   NAME <- NAMES[[kk]]
[13:21:03.708]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.708]                     next
[13:21:03.708]                   args[[name]] <- ""
[13:21:03.708]                 }
[13:21:03.708]                 NAMES <- toupper(removed)
[13:21:03.708]                 for (kk in seq_along(NAMES)) {
[13:21:03.708]                   name <- removed[[kk]]
[13:21:03.708]                   NAME <- NAMES[[kk]]
[13:21:03.708]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.708]                     next
[13:21:03.708]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.708]                 }
[13:21:03.708]                 if (length(args) > 0) 
[13:21:03.708]                   base::do.call(base::Sys.setenv, args = args)
[13:21:03.708]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:03.708]             }
[13:21:03.708]             else {
[13:21:03.708]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:03.708]             }
[13:21:03.708]             {
[13:21:03.708]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:03.708]                   0L) {
[13:21:03.708]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:03.708]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:03.708]                   base::options(opts)
[13:21:03.708]                 }
[13:21:03.708]                 {
[13:21:03.708]                   {
[13:21:03.708]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:03.708]                     NULL
[13:21:03.708]                   }
[13:21:03.708]                   options(future.plan = NULL)
[13:21:03.708]                   if (is.na(NA_character_)) 
[13:21:03.708]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.708]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:03.708]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:03.708]                     envir = parent.frame()) 
[13:21:03.708]                   {
[13:21:03.708]                     default_workers <- missing(workers)
[13:21:03.708]                     if (is.function(workers)) 
[13:21:03.708]                       workers <- workers()
[13:21:03.708]                     workers <- structure(as.integer(workers), 
[13:21:03.708]                       class = class(workers))
[13:21:03.708]                     stop_if_not(is.finite(workers), workers >= 
[13:21:03.708]                       1L)
[13:21:03.708]                     if ((workers == 1L && !inherits(workers, 
[13:21:03.708]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:03.708]                       if (default_workers) 
[13:21:03.708]                         supportsMulticore(warn = TRUE)
[13:21:03.708]                       return(sequential(..., envir = envir))
[13:21:03.708]                     }
[13:21:03.708]                     oopts <- options(mc.cores = workers)
[13:21:03.708]                     on.exit(options(oopts))
[13:21:03.708]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:03.708]                       envir = envir)
[13:21:03.708]                     if (!future$lazy) 
[13:21:03.708]                       future <- run(future)
[13:21:03.708]                     invisible(future)
[13:21:03.708]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:03.708]                 }
[13:21:03.708]             }
[13:21:03.708]         }
[13:21:03.708]     })
[13:21:03.708]     if (TRUE) {
[13:21:03.708]         base::sink(type = "output", split = FALSE)
[13:21:03.708]         if (TRUE) {
[13:21:03.708]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:03.708]         }
[13:21:03.708]         else {
[13:21:03.708]             ...future.result["stdout"] <- base::list(NULL)
[13:21:03.708]         }
[13:21:03.708]         base::close(...future.stdout)
[13:21:03.708]         ...future.stdout <- NULL
[13:21:03.708]     }
[13:21:03.708]     ...future.result$conditions <- ...future.conditions
[13:21:03.708]     ...future.result$finished <- base::Sys.time()
[13:21:03.708]     ...future.result
[13:21:03.708] }
[13:21:03.710] assign_globals() ...
[13:21:03.710] List of 1
[13:21:03.710]  $ a: num 0
[13:21:03.710]  - attr(*, "where")=List of 1
[13:21:03.710]   ..$ a:<environment: R_EmptyEnv> 
[13:21:03.710]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:03.710]  - attr(*, "resolved")= logi FALSE
[13:21:03.710]  - attr(*, "total_size")= num 56
[13:21:03.716] - copied ‘a’ to environment
[13:21:03.716] assign_globals() ... done
[13:21:03.716] requestCore(): workers = 2
[13:21:03.718] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:03.719] plan(): Setting new future strategy stack:
Globals: 1 objects totaling 56 bytes (numeric ‘a’ of 56 bytes)
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:03.720] List of future strategies:
[13:21:03.720] 1. sequential:
[13:21:03.720]    - args: function (..., envir = parent.frame())
[13:21:03.720]    - tweaked: FALSE
[13:21:03.720]    - call: NULL
[13:21:03.721] plan(): nbrOfWorkers() = 1
[13:21:03.723] plan(): Setting new future strategy stack:
[13:21:03.723] List of future strategies:
[13:21:03.723] 1. multicore:
[13:21:03.723]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:03.723]    - tweaked: FALSE
[13:21:03.723]    - call: plan(multicore)
[13:21:03.728] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 32f7abe8-d290-272e-8911-a8ce072c31c3
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[1] 0
*** multicore(..., globals = TRUE) with globals and blocking
 - Creating multicore future #1 ...
[13:21:03.734] getGlobalsAndPackages() ...
[13:21:03.734] Searching for globals...
[13:21:03.735] - globals found: [2] ‘{’, ‘ii’
[13:21:03.735] Searching for globals ... DONE
[13:21:03.735] Resolving globals: FALSE
[13:21:03.736] The total size of the 1 globals is 56 bytes (56 bytes)
[13:21:03.736] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:21:03.736] - globals: [1] ‘ii’
[13:21:03.737] 
[13:21:03.737] getGlobalsAndPackages() ... DONE
[13:21:03.737] Packages needed by the future expression (n = 0): <none>
[13:21:03.737] Packages needed by future strategies (n = 0): <none>
[13:21:03.738] {
[13:21:03.738]     {
[13:21:03.738]         {
[13:21:03.738]             ...future.startTime <- base::Sys.time()
[13:21:03.738]             {
[13:21:03.738]                 {
[13:21:03.738]                   {
[13:21:03.738]                     {
[13:21:03.738]                       base::local({
[13:21:03.738]                         has_future <- base::requireNamespace("future", 
[13:21:03.738]                           quietly = TRUE)
[13:21:03.738]                         if (has_future) {
[13:21:03.738]                           ns <- base::getNamespace("future")
[13:21:03.738]                           version <- ns[[".package"]][["version"]]
[13:21:03.738]                           if (is.null(version)) 
[13:21:03.738]                             version <- utils::packageVersion("future")
[13:21:03.738]                         }
[13:21:03.738]                         else {
[13:21:03.738]                           version <- NULL
[13:21:03.738]                         }
[13:21:03.738]                         if (!has_future || version < "1.8.0") {
[13:21:03.738]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:03.738]                             "", base::R.version$version.string), 
[13:21:03.738]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:03.738]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:03.738]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:03.738]                               "release", "version")], collapse = " "), 
[13:21:03.738]                             hostname = base::Sys.info()[["nodename"]])
[13:21:03.738]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:03.738]                             info)
[13:21:03.738]                           info <- base::paste(info, collapse = "; ")
[13:21:03.738]                           if (!has_future) {
[13:21:03.738]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:03.738]                               info)
[13:21:03.738]                           }
[13:21:03.738]                           else {
[13:21:03.738]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:03.738]                               info, version)
[13:21:03.738]                           }
[13:21:03.738]                           base::stop(msg)
[13:21:03.738]                         }
[13:21:03.738]                       })
[13:21:03.738]                     }
[13:21:03.738]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:03.738]                     base::options(mc.cores = 1L)
[13:21:03.738]                   }
[13:21:03.738]                   options(future.plan = NULL)
[13:21:03.738]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.738]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:03.738]                 }
[13:21:03.738]                 ...future.workdir <- getwd()
[13:21:03.738]             }
[13:21:03.738]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:03.738]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:03.738]         }
[13:21:03.738]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:03.738]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:03.738]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:03.738]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:03.738]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:03.738]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:03.738]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:03.738]             base::names(...future.oldOptions))
[13:21:03.738]     }
[13:21:03.738]     if (FALSE) {
[13:21:03.738]     }
[13:21:03.738]     else {
[13:21:03.738]         if (TRUE) {
[13:21:03.738]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:03.738]                 open = "w")
[13:21:03.738]         }
[13:21:03.738]         else {
[13:21:03.738]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:03.738]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:03.738]         }
[13:21:03.738]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:03.738]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:03.738]             base::sink(type = "output", split = FALSE)
[13:21:03.738]             base::close(...future.stdout)
[13:21:03.738]         }, add = TRUE)
[13:21:03.738]     }
[13:21:03.738]     ...future.frame <- base::sys.nframe()
[13:21:03.738]     ...future.conditions <- base::list()
[13:21:03.738]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:03.738]     if (FALSE) {
[13:21:03.738]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:03.738]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:03.738]     }
[13:21:03.738]     ...future.result <- base::tryCatch({
[13:21:03.738]         base::withCallingHandlers({
[13:21:03.738]             ...future.value <- base::withVisible(base::local({
[13:21:03.738]                 withCallingHandlers({
[13:21:03.738]                   {
[13:21:03.738]                     ii
[13:21:03.738]                   }
[13:21:03.738]                 }, immediateCondition = function(cond) {
[13:21:03.738]                   save_rds <- function (object, pathname, ...) 
[13:21:03.738]                   {
[13:21:03.738]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:03.738]                     if (file_test("-f", pathname_tmp)) {
[13:21:03.738]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.738]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:03.738]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.738]                         fi_tmp[["mtime"]])
[13:21:03.738]                     }
[13:21:03.738]                     tryCatch({
[13:21:03.738]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:03.738]                     }, error = function(ex) {
[13:21:03.738]                       msg <- conditionMessage(ex)
[13:21:03.738]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.738]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:03.738]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.738]                         fi_tmp[["mtime"]], msg)
[13:21:03.738]                       ex$message <- msg
[13:21:03.738]                       stop(ex)
[13:21:03.738]                     })
[13:21:03.738]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:03.738]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:03.738]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:03.738]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.738]                       fi <- file.info(pathname)
[13:21:03.738]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:03.738]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.738]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:03.738]                         fi[["size"]], fi[["mtime"]])
[13:21:03.738]                       stop(msg)
[13:21:03.738]                     }
[13:21:03.738]                     invisible(pathname)
[13:21:03.738]                   }
[13:21:03.738]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:03.738]                     rootPath = tempdir()) 
[13:21:03.738]                   {
[13:21:03.738]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:03.738]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:03.738]                       tmpdir = path, fileext = ".rds")
[13:21:03.738]                     save_rds(obj, file)
[13:21:03.738]                   }
[13:21:03.738]                   saveImmediateCondition(cond, path = "/tmp/Rtmpd6Ly3I/.future/immediateConditions")
[13:21:03.738]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.738]                   {
[13:21:03.738]                     inherits <- base::inherits
[13:21:03.738]                     invokeRestart <- base::invokeRestart
[13:21:03.738]                     is.null <- base::is.null
[13:21:03.738]                     muffled <- FALSE
[13:21:03.738]                     if (inherits(cond, "message")) {
[13:21:03.738]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:03.738]                       if (muffled) 
[13:21:03.738]                         invokeRestart("muffleMessage")
[13:21:03.738]                     }
[13:21:03.738]                     else if (inherits(cond, "warning")) {
[13:21:03.738]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:03.738]                       if (muffled) 
[13:21:03.738]                         invokeRestart("muffleWarning")
[13:21:03.738]                     }
[13:21:03.738]                     else if (inherits(cond, "condition")) {
[13:21:03.738]                       if (!is.null(pattern)) {
[13:21:03.738]                         computeRestarts <- base::computeRestarts
[13:21:03.738]                         grepl <- base::grepl
[13:21:03.738]                         restarts <- computeRestarts(cond)
[13:21:03.738]                         for (restart in restarts) {
[13:21:03.738]                           name <- restart$name
[13:21:03.738]                           if (is.null(name)) 
[13:21:03.738]                             next
[13:21:03.738]                           if (!grepl(pattern, name)) 
[13:21:03.738]                             next
[13:21:03.738]                           invokeRestart(restart)
[13:21:03.738]                           muffled <- TRUE
[13:21:03.738]                           break
[13:21:03.738]                         }
[13:21:03.738]                       }
[13:21:03.738]                     }
[13:21:03.738]                     invisible(muffled)
[13:21:03.738]                   }
[13:21:03.738]                   muffleCondition(cond)
[13:21:03.738]                 })
[13:21:03.738]             }))
[13:21:03.738]             future::FutureResult(value = ...future.value$value, 
[13:21:03.738]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.738]                   ...future.rng), globalenv = if (FALSE) 
[13:21:03.738]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:03.738]                     ...future.globalenv.names))
[13:21:03.738]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:03.738]         }, condition = base::local({
[13:21:03.738]             c <- base::c
[13:21:03.738]             inherits <- base::inherits
[13:21:03.738]             invokeRestart <- base::invokeRestart
[13:21:03.738]             length <- base::length
[13:21:03.738]             list <- base::list
[13:21:03.738]             seq.int <- base::seq.int
[13:21:03.738]             signalCondition <- base::signalCondition
[13:21:03.738]             sys.calls <- base::sys.calls
[13:21:03.738]             `[[` <- base::`[[`
[13:21:03.738]             `+` <- base::`+`
[13:21:03.738]             `<<-` <- base::`<<-`
[13:21:03.738]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:03.738]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:03.738]                   3L)]
[13:21:03.738]             }
[13:21:03.738]             function(cond) {
[13:21:03.738]                 is_error <- inherits(cond, "error")
[13:21:03.738]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:03.738]                   NULL)
[13:21:03.738]                 if (is_error) {
[13:21:03.738]                   sessionInformation <- function() {
[13:21:03.738]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:03.738]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:03.738]                       search = base::search(), system = base::Sys.info())
[13:21:03.738]                   }
[13:21:03.738]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.738]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:03.738]                     cond$call), session = sessionInformation(), 
[13:21:03.738]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:03.738]                   signalCondition(cond)
[13:21:03.738]                 }
[13:21:03.738]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:03.738]                 "immediateCondition"))) {
[13:21:03.738]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:03.738]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.738]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:03.738]                   if (TRUE && !signal) {
[13:21:03.738]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.738]                     {
[13:21:03.738]                       inherits <- base::inherits
[13:21:03.738]                       invokeRestart <- base::invokeRestart
[13:21:03.738]                       is.null <- base::is.null
[13:21:03.738]                       muffled <- FALSE
[13:21:03.738]                       if (inherits(cond, "message")) {
[13:21:03.738]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.738]                         if (muffled) 
[13:21:03.738]                           invokeRestart("muffleMessage")
[13:21:03.738]                       }
[13:21:03.738]                       else if (inherits(cond, "warning")) {
[13:21:03.738]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.738]                         if (muffled) 
[13:21:03.738]                           invokeRestart("muffleWarning")
[13:21:03.738]                       }
[13:21:03.738]                       else if (inherits(cond, "condition")) {
[13:21:03.738]                         if (!is.null(pattern)) {
[13:21:03.738]                           computeRestarts <- base::computeRestarts
[13:21:03.738]                           grepl <- base::grepl
[13:21:03.738]                           restarts <- computeRestarts(cond)
[13:21:03.738]                           for (restart in restarts) {
[13:21:03.738]                             name <- restart$name
[13:21:03.738]                             if (is.null(name)) 
[13:21:03.738]                               next
[13:21:03.738]                             if (!grepl(pattern, name)) 
[13:21:03.738]                               next
[13:21:03.738]                             invokeRestart(restart)
[13:21:03.738]                             muffled <- TRUE
[13:21:03.738]                             break
[13:21:03.738]                           }
[13:21:03.738]                         }
[13:21:03.738]                       }
[13:21:03.738]                       invisible(muffled)
[13:21:03.738]                     }
[13:21:03.738]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.738]                   }
[13:21:03.738]                 }
[13:21:03.738]                 else {
[13:21:03.738]                   if (TRUE) {
[13:21:03.738]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.738]                     {
[13:21:03.738]                       inherits <- base::inherits
[13:21:03.738]                       invokeRestart <- base::invokeRestart
[13:21:03.738]                       is.null <- base::is.null
[13:21:03.738]                       muffled <- FALSE
[13:21:03.738]                       if (inherits(cond, "message")) {
[13:21:03.738]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.738]                         if (muffled) 
[13:21:03.738]                           invokeRestart("muffleMessage")
[13:21:03.738]                       }
[13:21:03.738]                       else if (inherits(cond, "warning")) {
[13:21:03.738]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.738]                         if (muffled) 
[13:21:03.738]                           invokeRestart("muffleWarning")
[13:21:03.738]                       }
[13:21:03.738]                       else if (inherits(cond, "condition")) {
[13:21:03.738]                         if (!is.null(pattern)) {
[13:21:03.738]                           computeRestarts <- base::computeRestarts
[13:21:03.738]                           grepl <- base::grepl
[13:21:03.738]                           restarts <- computeRestarts(cond)
[13:21:03.738]                           for (restart in restarts) {
[13:21:03.738]                             name <- restart$name
[13:21:03.738]                             if (is.null(name)) 
[13:21:03.738]                               next
[13:21:03.738]                             if (!grepl(pattern, name)) 
[13:21:03.738]                               next
[13:21:03.738]                             invokeRestart(restart)
[13:21:03.738]                             muffled <- TRUE
[13:21:03.738]                             break
[13:21:03.738]                           }
[13:21:03.738]                         }
[13:21:03.738]                       }
[13:21:03.738]                       invisible(muffled)
[13:21:03.738]                     }
[13:21:03.738]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.738]                   }
[13:21:03.738]                 }
[13:21:03.738]             }
[13:21:03.738]         }))
[13:21:03.738]     }, error = function(ex) {
[13:21:03.738]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:03.738]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.738]                 ...future.rng), started = ...future.startTime, 
[13:21:03.738]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:03.738]             version = "1.8"), class = "FutureResult")
[13:21:03.738]     }, finally = {
[13:21:03.738]         if (!identical(...future.workdir, getwd())) 
[13:21:03.738]             setwd(...future.workdir)
[13:21:03.738]         {
[13:21:03.738]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:03.738]                 ...future.oldOptions$nwarnings <- NULL
[13:21:03.738]             }
[13:21:03.738]             base::options(...future.oldOptions)
[13:21:03.738]             if (.Platform$OS.type == "windows") {
[13:21:03.738]                 old_names <- names(...future.oldEnvVars)
[13:21:03.738]                 envs <- base::Sys.getenv()
[13:21:03.738]                 names <- names(envs)
[13:21:03.738]                 common <- intersect(names, old_names)
[13:21:03.738]                 added <- setdiff(names, old_names)
[13:21:03.738]                 removed <- setdiff(old_names, names)
[13:21:03.738]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:03.738]                   envs[common]]
[13:21:03.738]                 NAMES <- toupper(changed)
[13:21:03.738]                 args <- list()
[13:21:03.738]                 for (kk in seq_along(NAMES)) {
[13:21:03.738]                   name <- changed[[kk]]
[13:21:03.738]                   NAME <- NAMES[[kk]]
[13:21:03.738]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.738]                     next
[13:21:03.738]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.738]                 }
[13:21:03.738]                 NAMES <- toupper(added)
[13:21:03.738]                 for (kk in seq_along(NAMES)) {
[13:21:03.738]                   name <- added[[kk]]
[13:21:03.738]                   NAME <- NAMES[[kk]]
[13:21:03.738]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.738]                     next
[13:21:03.738]                   args[[name]] <- ""
[13:21:03.738]                 }
[13:21:03.738]                 NAMES <- toupper(removed)
[13:21:03.738]                 for (kk in seq_along(NAMES)) {
[13:21:03.738]                   name <- removed[[kk]]
[13:21:03.738]                   NAME <- NAMES[[kk]]
[13:21:03.738]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.738]                     next
[13:21:03.738]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.738]                 }
[13:21:03.738]                 if (length(args) > 0) 
[13:21:03.738]                   base::do.call(base::Sys.setenv, args = args)
[13:21:03.738]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:03.738]             }
[13:21:03.738]             else {
[13:21:03.738]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:03.738]             }
[13:21:03.738]             {
[13:21:03.738]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:03.738]                   0L) {
[13:21:03.738]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:03.738]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:03.738]                   base::options(opts)
[13:21:03.738]                 }
[13:21:03.738]                 {
[13:21:03.738]                   {
[13:21:03.738]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:03.738]                     NULL
[13:21:03.738]                   }
[13:21:03.738]                   options(future.plan = NULL)
[13:21:03.738]                   if (is.na(NA_character_)) 
[13:21:03.738]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.738]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:03.738]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:03.738]                     envir = parent.frame()) 
[13:21:03.738]                   {
[13:21:03.738]                     default_workers <- missing(workers)
[13:21:03.738]                     if (is.function(workers)) 
[13:21:03.738]                       workers <- workers()
[13:21:03.738]                     workers <- structure(as.integer(workers), 
[13:21:03.738]                       class = class(workers))
[13:21:03.738]                     stop_if_not(is.finite(workers), workers >= 
[13:21:03.738]                       1L)
[13:21:03.738]                     if ((workers == 1L && !inherits(workers, 
[13:21:03.738]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:03.738]                       if (default_workers) 
[13:21:03.738]                         supportsMulticore(warn = TRUE)
[13:21:03.738]                       return(sequential(..., envir = envir))
[13:21:03.738]                     }
[13:21:03.738]                     oopts <- options(mc.cores = workers)
[13:21:03.738]                     on.exit(options(oopts))
[13:21:03.738]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:03.738]                       envir = envir)
[13:21:03.738]                     if (!future$lazy) 
[13:21:03.738]                       future <- run(future)
[13:21:03.738]                     invisible(future)
[13:21:03.738]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:03.738]                 }
[13:21:03.738]             }
[13:21:03.738]         }
[13:21:03.738]     })
[13:21:03.738]     if (TRUE) {
[13:21:03.738]         base::sink(type = "output", split = FALSE)
[13:21:03.738]         if (TRUE) {
[13:21:03.738]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:03.738]         }
[13:21:03.738]         else {
[13:21:03.738]             ...future.result["stdout"] <- base::list(NULL)
[13:21:03.738]         }
[13:21:03.738]         base::close(...future.stdout)
[13:21:03.738]         ...future.stdout <- NULL
[13:21:03.738]     }
[13:21:03.738]     ...future.result$conditions <- ...future.conditions
[13:21:03.738]     ...future.result$finished <- base::Sys.time()
[13:21:03.738]     ...future.result
[13:21:03.738] }
[13:21:03.741] assign_globals() ...
[13:21:03.741] List of 1
[13:21:03.741]  $ ii: int 1
[13:21:03.741]  - attr(*, "where")=List of 1
[13:21:03.741]   ..$ ii:<environment: R_EmptyEnv> 
[13:21:03.741]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:03.741]  - attr(*, "resolved")= logi FALSE
[13:21:03.741]  - attr(*, "total_size")= num 56
[13:21:03.744] - copied ‘ii’ to environment
[13:21:03.744] assign_globals() ... done
[13:21:03.744] requestCore(): workers = 2
[13:21:03.746] MulticoreFuture started
 - Creating multicore future #2 ...
[13:21:03.747] plan(): Setting new future strategy stack:
[13:21:03.747] List of future strategies:
[13:21:03.747] 1. sequential:
[13:21:03.747]    - args: function (..., envir = parent.frame())
[13:21:03.747]    - tweaked: FALSE
[13:21:03.747]    - call: NULL
[13:21:03.748] plan(): nbrOfWorkers() = 1
[13:21:03.750] plan(): Setting new future strategy stack:
[13:21:03.750] List of future strategies:
[13:21:03.750] 1. multicore:
[13:21:03.750]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:03.750]    - tweaked: FALSE
[13:21:03.750]    - call: plan(multicore)
[13:21:03.752] getGlobalsAndPackages() ...
[13:21:03.752] Searching for globals...
[13:21:03.753] - globals found: [2] ‘{’, ‘ii’
[13:21:03.753] Searching for globals ... DONE
[13:21:03.754] Resolving globals: FALSE
[13:21:03.754] The total size of the 1 globals is 56 bytes (56 bytes)
[13:21:03.755] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:21:03.756] plan(): nbrOfWorkers() = 2
[13:21:03.756] - globals: [1] ‘ii’
[13:21:03.756] 
[13:21:03.756] getGlobalsAndPackages() ... DONE
[13:21:03.757] Packages needed by the future expression (n = 0): <none>
[13:21:03.757] Packages needed by future strategies (n = 0): <none>
[13:21:03.758] {
[13:21:03.758]     {
[13:21:03.758]         {
[13:21:03.758]             ...future.startTime <- base::Sys.time()
[13:21:03.758]             {
[13:21:03.758]                 {
[13:21:03.758]                   {
[13:21:03.758]                     {
[13:21:03.758]                       base::local({
[13:21:03.758]                         has_future <- base::requireNamespace("future", 
[13:21:03.758]                           quietly = TRUE)
[13:21:03.758]                         if (has_future) {
[13:21:03.758]                           ns <- base::getNamespace("future")
[13:21:03.758]                           version <- ns[[".package"]][["version"]]
[13:21:03.758]                           if (is.null(version)) 
[13:21:03.758]                             version <- utils::packageVersion("future")
[13:21:03.758]                         }
[13:21:03.758]                         else {
[13:21:03.758]                           version <- NULL
[13:21:03.758]                         }
[13:21:03.758]                         if (!has_future || version < "1.8.0") {
[13:21:03.758]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:03.758]                             "", base::R.version$version.string), 
[13:21:03.758]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:03.758]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:03.758]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:03.758]                               "release", "version")], collapse = " "), 
[13:21:03.758]                             hostname = base::Sys.info()[["nodename"]])
[13:21:03.758]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:03.758]                             info)
[13:21:03.758]                           info <- base::paste(info, collapse = "; ")
[13:21:03.758]                           if (!has_future) {
[13:21:03.758]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:03.758]                               info)
[13:21:03.758]                           }
[13:21:03.758]                           else {
[13:21:03.758]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:03.758]                               info, version)
[13:21:03.758]                           }
[13:21:03.758]                           base::stop(msg)
[13:21:03.758]                         }
[13:21:03.758]                       })
[13:21:03.758]                     }
[13:21:03.758]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:03.758]                     base::options(mc.cores = 1L)
[13:21:03.758]                   }
[13:21:03.758]                   options(future.plan = NULL)
[13:21:03.758]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.758]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:03.758]                 }
[13:21:03.758]                 ...future.workdir <- getwd()
[13:21:03.758]             }
[13:21:03.758]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:03.758]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:03.758]         }
[13:21:03.758]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:03.758]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:03.758]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:03.758]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:03.758]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:03.758]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:03.758]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:03.758]             base::names(...future.oldOptions))
[13:21:03.758]     }
[13:21:03.758]     if (FALSE) {
[13:21:03.758]     }
[13:21:03.758]     else {
[13:21:03.758]         if (TRUE) {
[13:21:03.758]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:03.758]                 open = "w")
[13:21:03.758]         }
[13:21:03.758]         else {
[13:21:03.758]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:03.758]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:03.758]         }
[13:21:03.758]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:03.758]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:03.758]             base::sink(type = "output", split = FALSE)
[13:21:03.758]             base::close(...future.stdout)
[13:21:03.758]         }, add = TRUE)
[13:21:03.758]     }
[13:21:03.758]     ...future.frame <- base::sys.nframe()
[13:21:03.758]     ...future.conditions <- base::list()
[13:21:03.758]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:03.758]     if (FALSE) {
[13:21:03.758]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:03.758]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:03.758]     }
[13:21:03.758]     ...future.result <- base::tryCatch({
[13:21:03.758]         base::withCallingHandlers({
[13:21:03.758]             ...future.value <- base::withVisible(base::local({
[13:21:03.758]                 withCallingHandlers({
[13:21:03.758]                   {
[13:21:03.758]                     ii
[13:21:03.758]                   }
[13:21:03.758]                 }, immediateCondition = function(cond) {
[13:21:03.758]                   save_rds <- function (object, pathname, ...) 
[13:21:03.758]                   {
[13:21:03.758]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:03.758]                     if (file_test("-f", pathname_tmp)) {
[13:21:03.758]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.758]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:03.758]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.758]                         fi_tmp[["mtime"]])
[13:21:03.758]                     }
[13:21:03.758]                     tryCatch({
[13:21:03.758]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:03.758]                     }, error = function(ex) {
[13:21:03.758]                       msg <- conditionMessage(ex)
[13:21:03.758]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.758]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:03.758]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.758]                         fi_tmp[["mtime"]], msg)
[13:21:03.758]                       ex$message <- msg
[13:21:03.758]                       stop(ex)
[13:21:03.758]                     })
[13:21:03.758]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:03.758]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:03.758]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:03.758]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.758]                       fi <- file.info(pathname)
[13:21:03.758]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:03.758]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.758]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:03.758]                         fi[["size"]], fi[["mtime"]])
[13:21:03.758]                       stop(msg)
[13:21:03.758]                     }
[13:21:03.758]                     invisible(pathname)
[13:21:03.758]                   }
[13:21:03.758]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:03.758]                     rootPath = tempdir()) 
[13:21:03.758]                   {
[13:21:03.758]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:03.758]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:03.758]                       tmpdir = path, fileext = ".rds")
[13:21:03.758]                     save_rds(obj, file)
[13:21:03.758]                   }
[13:21:03.758]                   saveImmediateCondition(cond, path = "/tmp/Rtmpd6Ly3I/.future/immediateConditions")
[13:21:03.758]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.758]                   {
[13:21:03.758]                     inherits <- base::inherits
[13:21:03.758]                     invokeRestart <- base::invokeRestart
[13:21:03.758]                     is.null <- base::is.null
[13:21:03.758]                     muffled <- FALSE
[13:21:03.758]                     if (inherits(cond, "message")) {
[13:21:03.758]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:03.758]                       if (muffled) 
[13:21:03.758]                         invokeRestart("muffleMessage")
[13:21:03.758]                     }
[13:21:03.758]                     else if (inherits(cond, "warning")) {
[13:21:03.758]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:03.758]                       if (muffled) 
[13:21:03.758]                         invokeRestart("muffleWarning")
[13:21:03.758]                     }
[13:21:03.758]                     else if (inherits(cond, "condition")) {
[13:21:03.758]                       if (!is.null(pattern)) {
[13:21:03.758]                         computeRestarts <- base::computeRestarts
[13:21:03.758]                         grepl <- base::grepl
[13:21:03.758]                         restarts <- computeRestarts(cond)
[13:21:03.758]                         for (restart in restarts) {
[13:21:03.758]                           name <- restart$name
[13:21:03.758]                           if (is.null(name)) 
[13:21:03.758]                             next
[13:21:03.758]                           if (!grepl(pattern, name)) 
[13:21:03.758]                             next
[13:21:03.758]                           invokeRestart(restart)
[13:21:03.758]                           muffled <- TRUE
[13:21:03.758]                           break
[13:21:03.758]                         }
[13:21:03.758]                       }
[13:21:03.758]                     }
[13:21:03.758]                     invisible(muffled)
[13:21:03.758]                   }
[13:21:03.758]                   muffleCondition(cond)
[13:21:03.758]                 })
[13:21:03.758]             }))
[13:21:03.758]             future::FutureResult(value = ...future.value$value, 
[13:21:03.758]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.758]                   ...future.rng), globalenv = if (FALSE) 
[13:21:03.758]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:03.758]                     ...future.globalenv.names))
[13:21:03.758]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:03.758]         }, condition = base::local({
[13:21:03.758]             c <- base::c
[13:21:03.758]             inherits <- base::inherits
[13:21:03.758]             invokeRestart <- base::invokeRestart
[13:21:03.758]             length <- base::length
[13:21:03.758]             list <- base::list
[13:21:03.758]             seq.int <- base::seq.int
[13:21:03.758]             signalCondition <- base::signalCondition
[13:21:03.758]             sys.calls <- base::sys.calls
[13:21:03.758]             `[[` <- base::`[[`
[13:21:03.758]             `+` <- base::`+`
[13:21:03.758]             `<<-` <- base::`<<-`
[13:21:03.758]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:03.758]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:03.758]                   3L)]
[13:21:03.758]             }
[13:21:03.758]             function(cond) {
[13:21:03.758]                 is_error <- inherits(cond, "error")
[13:21:03.758]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:03.758]                   NULL)
[13:21:03.758]                 if (is_error) {
[13:21:03.758]                   sessionInformation <- function() {
[13:21:03.758]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:03.758]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:03.758]                       search = base::search(), system = base::Sys.info())
[13:21:03.758]                   }
[13:21:03.758]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.758]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:03.758]                     cond$call), session = sessionInformation(), 
[13:21:03.758]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:03.758]                   signalCondition(cond)
[13:21:03.758]                 }
[13:21:03.758]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:03.758]                 "immediateCondition"))) {
[13:21:03.758]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:03.758]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.758]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:03.758]                   if (TRUE && !signal) {
[13:21:03.758]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.758]                     {
[13:21:03.758]                       inherits <- base::inherits
[13:21:03.758]                       invokeRestart <- base::invokeRestart
[13:21:03.758]                       is.null <- base::is.null
[13:21:03.758]                       muffled <- FALSE
[13:21:03.758]                       if (inherits(cond, "message")) {
[13:21:03.758]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.758]                         if (muffled) 
[13:21:03.758]                           invokeRestart("muffleMessage")
[13:21:03.758]                       }
[13:21:03.758]                       else if (inherits(cond, "warning")) {
[13:21:03.758]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.758]                         if (muffled) 
[13:21:03.758]                           invokeRestart("muffleWarning")
[13:21:03.758]                       }
[13:21:03.758]                       else if (inherits(cond, "condition")) {
[13:21:03.758]                         if (!is.null(pattern)) {
[13:21:03.758]                           computeRestarts <- base::computeRestarts
[13:21:03.758]                           grepl <- base::grepl
[13:21:03.758]                           restarts <- computeRestarts(cond)
[13:21:03.758]                           for (restart in restarts) {
[13:21:03.758]                             name <- restart$name
[13:21:03.758]                             if (is.null(name)) 
[13:21:03.758]                               next
[13:21:03.758]                             if (!grepl(pattern, name)) 
[13:21:03.758]                               next
[13:21:03.758]                             invokeRestart(restart)
[13:21:03.758]                             muffled <- TRUE
[13:21:03.758]                             break
[13:21:03.758]                           }
[13:21:03.758]                         }
[13:21:03.758]                       }
[13:21:03.758]                       invisible(muffled)
[13:21:03.758]                     }
[13:21:03.758]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.758]                   }
[13:21:03.758]                 }
[13:21:03.758]                 else {
[13:21:03.758]                   if (TRUE) {
[13:21:03.758]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.758]                     {
[13:21:03.758]                       inherits <- base::inherits
[13:21:03.758]                       invokeRestart <- base::invokeRestart
[13:21:03.758]                       is.null <- base::is.null
[13:21:03.758]                       muffled <- FALSE
[13:21:03.758]                       if (inherits(cond, "message")) {
[13:21:03.758]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.758]                         if (muffled) 
[13:21:03.758]                           invokeRestart("muffleMessage")
[13:21:03.758]                       }
[13:21:03.758]                       else if (inherits(cond, "warning")) {
[13:21:03.758]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.758]                         if (muffled) 
[13:21:03.758]                           invokeRestart("muffleWarning")
[13:21:03.758]                       }
[13:21:03.758]                       else if (inherits(cond, "condition")) {
[13:21:03.758]                         if (!is.null(pattern)) {
[13:21:03.758]                           computeRestarts <- base::computeRestarts
[13:21:03.758]                           grepl <- base::grepl
[13:21:03.758]                           restarts <- computeRestarts(cond)
[13:21:03.758]                           for (restart in restarts) {
[13:21:03.758]                             name <- restart$name
[13:21:03.758]                             if (is.null(name)) 
[13:21:03.758]                               next
[13:21:03.758]                             if (!grepl(pattern, name)) 
[13:21:03.758]                               next
[13:21:03.758]                             invokeRestart(restart)
[13:21:03.758]                             muffled <- TRUE
[13:21:03.758]                             break
[13:21:03.758]                           }
[13:21:03.758]                         }
[13:21:03.758]                       }
[13:21:03.758]                       invisible(muffled)
[13:21:03.758]                     }
[13:21:03.758]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.758]                   }
[13:21:03.758]                 }
[13:21:03.758]             }
[13:21:03.758]         }))
[13:21:03.758]     }, error = function(ex) {
[13:21:03.758]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:03.758]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.758]                 ...future.rng), started = ...future.startTime, 
[13:21:03.758]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:03.758]             version = "1.8"), class = "FutureResult")
[13:21:03.758]     }, finally = {
[13:21:03.758]         if (!identical(...future.workdir, getwd())) 
[13:21:03.758]             setwd(...future.workdir)
[13:21:03.758]         {
[13:21:03.758]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:03.758]                 ...future.oldOptions$nwarnings <- NULL
[13:21:03.758]             }
[13:21:03.758]             base::options(...future.oldOptions)
[13:21:03.758]             if (.Platform$OS.type == "windows") {
[13:21:03.758]                 old_names <- names(...future.oldEnvVars)
[13:21:03.758]                 envs <- base::Sys.getenv()
[13:21:03.758]                 names <- names(envs)
[13:21:03.758]                 common <- intersect(names, old_names)
[13:21:03.758]                 added <- setdiff(names, old_names)
[13:21:03.758]                 removed <- setdiff(old_names, names)
[13:21:03.758]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:03.758]                   envs[common]]
[13:21:03.758]                 NAMES <- toupper(changed)
[13:21:03.758]                 args <- list()
[13:21:03.758]                 for (kk in seq_along(NAMES)) {
[13:21:03.758]                   name <- changed[[kk]]
[13:21:03.758]                   NAME <- NAMES[[kk]]
[13:21:03.758]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.758]                     next
[13:21:03.758]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.758]                 }
[13:21:03.758]                 NAMES <- toupper(added)
[13:21:03.758]                 for (kk in seq_along(NAMES)) {
[13:21:03.758]                   name <- added[[kk]]
[13:21:03.758]                   NAME <- NAMES[[kk]]
[13:21:03.758]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.758]                     next
[13:21:03.758]                   args[[name]] <- ""
[13:21:03.758]                 }
[13:21:03.758]                 NAMES <- toupper(removed)
[13:21:03.758]                 for (kk in seq_along(NAMES)) {
[13:21:03.758]                   name <- removed[[kk]]
[13:21:03.758]                   NAME <- NAMES[[kk]]
[13:21:03.758]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.758]                     next
[13:21:03.758]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.758]                 }
[13:21:03.758]                 if (length(args) > 0) 
[13:21:03.758]                   base::do.call(base::Sys.setenv, args = args)
[13:21:03.758]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:03.758]             }
[13:21:03.758]             else {
[13:21:03.758]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:03.758]             }
[13:21:03.758]             {
[13:21:03.758]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:03.758]                   0L) {
[13:21:03.758]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:03.758]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:03.758]                   base::options(opts)
[13:21:03.758]                 }
[13:21:03.758]                 {
[13:21:03.758]                   {
[13:21:03.758]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:03.758]                     NULL
[13:21:03.758]                   }
[13:21:03.758]                   options(future.plan = NULL)
[13:21:03.758]                   if (is.na(NA_character_)) 
[13:21:03.758]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.758]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:03.758]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:03.758]                     envir = parent.frame()) 
[13:21:03.758]                   {
[13:21:03.758]                     default_workers <- missing(workers)
[13:21:03.758]                     if (is.function(workers)) 
[13:21:03.758]                       workers <- workers()
[13:21:03.758]                     workers <- structure(as.integer(workers), 
[13:21:03.758]                       class = class(workers))
[13:21:03.758]                     stop_if_not(is.finite(workers), workers >= 
[13:21:03.758]                       1L)
[13:21:03.758]                     if ((workers == 1L && !inherits(workers, 
[13:21:03.758]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:03.758]                       if (default_workers) 
[13:21:03.758]                         supportsMulticore(warn = TRUE)
[13:21:03.758]                       return(sequential(..., envir = envir))
[13:21:03.758]                     }
[13:21:03.758]                     oopts <- options(mc.cores = workers)
[13:21:03.758]                     on.exit(options(oopts))
[13:21:03.758]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:03.758]                       envir = envir)
[13:21:03.758]                     if (!future$lazy) 
[13:21:03.758]                       future <- run(future)
[13:21:03.758]                     invisible(future)
[13:21:03.758]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:03.758]                 }
[13:21:03.758]             }
[13:21:03.758]         }
[13:21:03.758]     })
[13:21:03.758]     if (TRUE) {
[13:21:03.758]         base::sink(type = "output", split = FALSE)
[13:21:03.758]         if (TRUE) {
[13:21:03.758]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:03.758]         }
[13:21:03.758]         else {
[13:21:03.758]             ...future.result["stdout"] <- base::list(NULL)
[13:21:03.758]         }
[13:21:03.758]         base::close(...future.stdout)
[13:21:03.758]         ...future.stdout <- NULL
[13:21:03.758]     }
[13:21:03.758]     ...future.result$conditions <- ...future.conditions
[13:21:03.758]     ...future.result$finished <- base::Sys.time()
[13:21:03.758]     ...future.result
[13:21:03.758] }
[13:21:03.761] assign_globals() ...
[13:21:03.761] List of 1
[13:21:03.761]  $ ii: int 2
[13:21:03.761]  - attr(*, "where")=List of 1
[13:21:03.761]   ..$ ii:<environment: R_EmptyEnv> 
[13:21:03.761]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:03.761]  - attr(*, "resolved")= logi FALSE
[13:21:03.761]  - attr(*, "total_size")= num 56
[13:21:03.764] - copied ‘ii’ to environment
[13:21:03.765] assign_globals() ... done
[13:21:03.765] requestCore(): workers = 2
[13:21:03.767] MulticoreFuture started
 - Creating multicore future #3 ...
[13:21:03.768] plan(): Setting new future strategy stack:
[13:21:03.768] List of future strategies:
[13:21:03.768] 1. sequential:
[13:21:03.768]    - args: function (..., envir = parent.frame())
[13:21:03.768]    - tweaked: FALSE
[13:21:03.768]    - call: NULL
[13:21:03.769] plan(): nbrOfWorkers() = 1
[13:21:03.771] plan(): Setting new future strategy stack:
[13:21:03.771] List of future strategies:
[13:21:03.771] 1. multicore:
[13:21:03.771]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:03.771]    - tweaked: FALSE
[13:21:03.771]    - call: plan(multicore)
[13:21:03.773] getGlobalsAndPackages() ...
[13:21:03.773] Searching for globals...
[13:21:03.775] - globals found: [2] ‘{’, ‘ii’
[13:21:03.775] Searching for globals ... DONE
[13:21:03.775] Resolving globals: FALSE
[13:21:03.776] The total size of the 1 globals is 56 bytes (56 bytes)
[13:21:03.777] plan(): nbrOfWorkers() = 2
[13:21:03.777] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:21:03.777] - globals: [1] ‘ii’
[13:21:03.778] 
[13:21:03.778] getGlobalsAndPackages() ... DONE
[13:21:03.782] Packages needed by the future expression (n = 0): <none>
[13:21:03.782] Packages needed by future strategies (n = 0): <none>
[13:21:03.783] {
[13:21:03.783]     {
[13:21:03.783]         {
[13:21:03.783]             ...future.startTime <- base::Sys.time()
[13:21:03.783]             {
[13:21:03.783]                 {
[13:21:03.783]                   {
[13:21:03.783]                     {
[13:21:03.783]                       base::local({
[13:21:03.783]                         has_future <- base::requireNamespace("future", 
[13:21:03.783]                           quietly = TRUE)
[13:21:03.783]                         if (has_future) {
[13:21:03.783]                           ns <- base::getNamespace("future")
[13:21:03.783]                           version <- ns[[".package"]][["version"]]
[13:21:03.783]                           if (is.null(version)) 
[13:21:03.783]                             version <- utils::packageVersion("future")
[13:21:03.783]                         }
[13:21:03.783]                         else {
[13:21:03.783]                           version <- NULL
[13:21:03.783]                         }
[13:21:03.783]                         if (!has_future || version < "1.8.0") {
[13:21:03.783]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:03.783]                             "", base::R.version$version.string), 
[13:21:03.783]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:03.783]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:03.783]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:03.783]                               "release", "version")], collapse = " "), 
[13:21:03.783]                             hostname = base::Sys.info()[["nodename"]])
[13:21:03.783]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:03.783]                             info)
[13:21:03.783]                           info <- base::paste(info, collapse = "; ")
[13:21:03.783]                           if (!has_future) {
[13:21:03.783]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:03.783]                               info)
[13:21:03.783]                           }
[13:21:03.783]                           else {
[13:21:03.783]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:03.783]                               info, version)
[13:21:03.783]                           }
[13:21:03.783]                           base::stop(msg)
[13:21:03.783]                         }
[13:21:03.783]                       })
[13:21:03.783]                     }
[13:21:03.783]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:03.783]                     base::options(mc.cores = 1L)
[13:21:03.783]                   }
[13:21:03.783]                   options(future.plan = NULL)
[13:21:03.783]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.783]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:03.783]                 }
[13:21:03.783]                 ...future.workdir <- getwd()
[13:21:03.783]             }
[13:21:03.783]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:03.783]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:03.783]         }
[13:21:03.783]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:03.783]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:03.783]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:03.783]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:03.783]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:03.783]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:03.783]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:03.783]             base::names(...future.oldOptions))
[13:21:03.783]     }
[13:21:03.783]     if (FALSE) {
[13:21:03.783]     }
[13:21:03.783]     else {
[13:21:03.783]         if (TRUE) {
[13:21:03.783]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:03.783]                 open = "w")
[13:21:03.783]         }
[13:21:03.783]         else {
[13:21:03.783]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:03.783]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:03.783]         }
[13:21:03.783]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:03.783]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:03.783]             base::sink(type = "output", split = FALSE)
[13:21:03.783]             base::close(...future.stdout)
[13:21:03.783]         }, add = TRUE)
[13:21:03.783]     }
[13:21:03.783]     ...future.frame <- base::sys.nframe()
[13:21:03.783]     ...future.conditions <- base::list()
[13:21:03.783]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:03.783]     if (FALSE) {
[13:21:03.783]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:03.783]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:03.783]     }
[13:21:03.783]     ...future.result <- base::tryCatch({
[13:21:03.783]         base::withCallingHandlers({
[13:21:03.783]             ...future.value <- base::withVisible(base::local({
[13:21:03.783]                 withCallingHandlers({
[13:21:03.783]                   {
[13:21:03.783]                     ii
[13:21:03.783]                   }
[13:21:03.783]                 }, immediateCondition = function(cond) {
[13:21:03.783]                   save_rds <- function (object, pathname, ...) 
[13:21:03.783]                   {
[13:21:03.783]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:03.783]                     if (file_test("-f", pathname_tmp)) {
[13:21:03.783]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.783]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:03.783]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.783]                         fi_tmp[["mtime"]])
[13:21:03.783]                     }
[13:21:03.783]                     tryCatch({
[13:21:03.783]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:03.783]                     }, error = function(ex) {
[13:21:03.783]                       msg <- conditionMessage(ex)
[13:21:03.783]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.783]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:03.783]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.783]                         fi_tmp[["mtime"]], msg)
[13:21:03.783]                       ex$message <- msg
[13:21:03.783]                       stop(ex)
[13:21:03.783]                     })
[13:21:03.783]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:03.783]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:03.783]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:03.783]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.783]                       fi <- file.info(pathname)
[13:21:03.783]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:03.783]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.783]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:03.783]                         fi[["size"]], fi[["mtime"]])
[13:21:03.783]                       stop(msg)
[13:21:03.783]                     }
[13:21:03.783]                     invisible(pathname)
[13:21:03.783]                   }
[13:21:03.783]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:03.783]                     rootPath = tempdir()) 
[13:21:03.783]                   {
[13:21:03.783]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:03.783]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:03.783]                       tmpdir = path, fileext = ".rds")
[13:21:03.783]                     save_rds(obj, file)
[13:21:03.783]                   }
[13:21:03.783]                   saveImmediateCondition(cond, path = "/tmp/Rtmpd6Ly3I/.future/immediateConditions")
[13:21:03.783]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.783]                   {
[13:21:03.783]                     inherits <- base::inherits
[13:21:03.783]                     invokeRestart <- base::invokeRestart
[13:21:03.783]                     is.null <- base::is.null
[13:21:03.783]                     muffled <- FALSE
[13:21:03.783]                     if (inherits(cond, "message")) {
[13:21:03.783]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:03.783]                       if (muffled) 
[13:21:03.783]                         invokeRestart("muffleMessage")
[13:21:03.783]                     }
[13:21:03.783]                     else if (inherits(cond, "warning")) {
[13:21:03.783]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:03.783]                       if (muffled) 
[13:21:03.783]                         invokeRestart("muffleWarning")
[13:21:03.783]                     }
[13:21:03.783]                     else if (inherits(cond, "condition")) {
[13:21:03.783]                       if (!is.null(pattern)) {
[13:21:03.783]                         computeRestarts <- base::computeRestarts
[13:21:03.783]                         grepl <- base::grepl
[13:21:03.783]                         restarts <- computeRestarts(cond)
[13:21:03.783]                         for (restart in restarts) {
[13:21:03.783]                           name <- restart$name
[13:21:03.783]                           if (is.null(name)) 
[13:21:03.783]                             next
[13:21:03.783]                           if (!grepl(pattern, name)) 
[13:21:03.783]                             next
[13:21:03.783]                           invokeRestart(restart)
[13:21:03.783]                           muffled <- TRUE
[13:21:03.783]                           break
[13:21:03.783]                         }
[13:21:03.783]                       }
[13:21:03.783]                     }
[13:21:03.783]                     invisible(muffled)
[13:21:03.783]                   }
[13:21:03.783]                   muffleCondition(cond)
[13:21:03.783]                 })
[13:21:03.783]             }))
[13:21:03.783]             future::FutureResult(value = ...future.value$value, 
[13:21:03.783]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.783]                   ...future.rng), globalenv = if (FALSE) 
[13:21:03.783]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:03.783]                     ...future.globalenv.names))
[13:21:03.783]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:03.783]         }, condition = base::local({
[13:21:03.783]             c <- base::c
[13:21:03.783]             inherits <- base::inherits
[13:21:03.783]             invokeRestart <- base::invokeRestart
[13:21:03.783]             length <- base::length
[13:21:03.783]             list <- base::list
[13:21:03.783]             seq.int <- base::seq.int
[13:21:03.783]             signalCondition <- base::signalCondition
[13:21:03.783]             sys.calls <- base::sys.calls
[13:21:03.783]             `[[` <- base::`[[`
[13:21:03.783]             `+` <- base::`+`
[13:21:03.783]             `<<-` <- base::`<<-`
[13:21:03.783]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:03.783]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:03.783]                   3L)]
[13:21:03.783]             }
[13:21:03.783]             function(cond) {
[13:21:03.783]                 is_error <- inherits(cond, "error")
[13:21:03.783]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:03.783]                   NULL)
[13:21:03.783]                 if (is_error) {
[13:21:03.783]                   sessionInformation <- function() {
[13:21:03.783]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:03.783]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:03.783]                       search = base::search(), system = base::Sys.info())
[13:21:03.783]                   }
[13:21:03.783]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.783]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:03.783]                     cond$call), session = sessionInformation(), 
[13:21:03.783]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:03.783]                   signalCondition(cond)
[13:21:03.783]                 }
[13:21:03.783]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:03.783]                 "immediateCondition"))) {
[13:21:03.783]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:03.783]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.783]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:03.783]                   if (TRUE && !signal) {
[13:21:03.783]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.783]                     {
[13:21:03.783]                       inherits <- base::inherits
[13:21:03.783]                       invokeRestart <- base::invokeRestart
[13:21:03.783]                       is.null <- base::is.null
[13:21:03.783]                       muffled <- FALSE
[13:21:03.783]                       if (inherits(cond, "message")) {
[13:21:03.783]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.783]                         if (muffled) 
[13:21:03.783]                           invokeRestart("muffleMessage")
[13:21:03.783]                       }
[13:21:03.783]                       else if (inherits(cond, "warning")) {
[13:21:03.783]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.783]                         if (muffled) 
[13:21:03.783]                           invokeRestart("muffleWarning")
[13:21:03.783]                       }
[13:21:03.783]                       else if (inherits(cond, "condition")) {
[13:21:03.783]                         if (!is.null(pattern)) {
[13:21:03.783]                           computeRestarts <- base::computeRestarts
[13:21:03.783]                           grepl <- base::grepl
[13:21:03.783]                           restarts <- computeRestarts(cond)
[13:21:03.783]                           for (restart in restarts) {
[13:21:03.783]                             name <- restart$name
[13:21:03.783]                             if (is.null(name)) 
[13:21:03.783]                               next
[13:21:03.783]                             if (!grepl(pattern, name)) 
[13:21:03.783]                               next
[13:21:03.783]                             invokeRestart(restart)
[13:21:03.783]                             muffled <- TRUE
[13:21:03.783]                             break
[13:21:03.783]                           }
[13:21:03.783]                         }
[13:21:03.783]                       }
[13:21:03.783]                       invisible(muffled)
[13:21:03.783]                     }
[13:21:03.783]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.783]                   }
[13:21:03.783]                 }
[13:21:03.783]                 else {
[13:21:03.783]                   if (TRUE) {
[13:21:03.783]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.783]                     {
[13:21:03.783]                       inherits <- base::inherits
[13:21:03.783]                       invokeRestart <- base::invokeRestart
[13:21:03.783]                       is.null <- base::is.null
[13:21:03.783]                       muffled <- FALSE
[13:21:03.783]                       if (inherits(cond, "message")) {
[13:21:03.783]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.783]                         if (muffled) 
[13:21:03.783]                           invokeRestart("muffleMessage")
[13:21:03.783]                       }
[13:21:03.783]                       else if (inherits(cond, "warning")) {
[13:21:03.783]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.783]                         if (muffled) 
[13:21:03.783]                           invokeRestart("muffleWarning")
[13:21:03.783]                       }
[13:21:03.783]                       else if (inherits(cond, "condition")) {
[13:21:03.783]                         if (!is.null(pattern)) {
[13:21:03.783]                           computeRestarts <- base::computeRestarts
[13:21:03.783]                           grepl <- base::grepl
[13:21:03.783]                           restarts <- computeRestarts(cond)
[13:21:03.783]                           for (restart in restarts) {
[13:21:03.783]                             name <- restart$name
[13:21:03.783]                             if (is.null(name)) 
[13:21:03.783]                               next
[13:21:03.783]                             if (!grepl(pattern, name)) 
[13:21:03.783]                               next
[13:21:03.783]                             invokeRestart(restart)
[13:21:03.783]                             muffled <- TRUE
[13:21:03.783]                             break
[13:21:03.783]                           }
[13:21:03.783]                         }
[13:21:03.783]                       }
[13:21:03.783]                       invisible(muffled)
[13:21:03.783]                     }
[13:21:03.783]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.783]                   }
[13:21:03.783]                 }
[13:21:03.783]             }
[13:21:03.783]         }))
[13:21:03.783]     }, error = function(ex) {
[13:21:03.783]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:03.783]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.783]                 ...future.rng), started = ...future.startTime, 
[13:21:03.783]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:03.783]             version = "1.8"), class = "FutureResult")
[13:21:03.783]     }, finally = {
[13:21:03.783]         if (!identical(...future.workdir, getwd())) 
[13:21:03.783]             setwd(...future.workdir)
[13:21:03.783]         {
[13:21:03.783]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:03.783]                 ...future.oldOptions$nwarnings <- NULL
[13:21:03.783]             }
[13:21:03.783]             base::options(...future.oldOptions)
[13:21:03.783]             if (.Platform$OS.type == "windows") {
[13:21:03.783]                 old_names <- names(...future.oldEnvVars)
[13:21:03.783]                 envs <- base::Sys.getenv()
[13:21:03.783]                 names <- names(envs)
[13:21:03.783]                 common <- intersect(names, old_names)
[13:21:03.783]                 added <- setdiff(names, old_names)
[13:21:03.783]                 removed <- setdiff(old_names, names)
[13:21:03.783]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:03.783]                   envs[common]]
[13:21:03.783]                 NAMES <- toupper(changed)
[13:21:03.783]                 args <- list()
[13:21:03.783]                 for (kk in seq_along(NAMES)) {
[13:21:03.783]                   name <- changed[[kk]]
[13:21:03.783]                   NAME <- NAMES[[kk]]
[13:21:03.783]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.783]                     next
[13:21:03.783]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.783]                 }
[13:21:03.783]                 NAMES <- toupper(added)
[13:21:03.783]                 for (kk in seq_along(NAMES)) {
[13:21:03.783]                   name <- added[[kk]]
[13:21:03.783]                   NAME <- NAMES[[kk]]
[13:21:03.783]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.783]                     next
[13:21:03.783]                   args[[name]] <- ""
[13:21:03.783]                 }
[13:21:03.783]                 NAMES <- toupper(removed)
[13:21:03.783]                 for (kk in seq_along(NAMES)) {
[13:21:03.783]                   name <- removed[[kk]]
[13:21:03.783]                   NAME <- NAMES[[kk]]
[13:21:03.783]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.783]                     next
[13:21:03.783]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.783]                 }
[13:21:03.783]                 if (length(args) > 0) 
[13:21:03.783]                   base::do.call(base::Sys.setenv, args = args)
[13:21:03.783]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:03.783]             }
[13:21:03.783]             else {
[13:21:03.783]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:03.783]             }
[13:21:03.783]             {
[13:21:03.783]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:03.783]                   0L) {
[13:21:03.783]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:03.783]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:03.783]                   base::options(opts)
[13:21:03.783]                 }
[13:21:03.783]                 {
[13:21:03.783]                   {
[13:21:03.783]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:03.783]                     NULL
[13:21:03.783]                   }
[13:21:03.783]                   options(future.plan = NULL)
[13:21:03.783]                   if (is.na(NA_character_)) 
[13:21:03.783]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.783]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:03.783]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:03.783]                     envir = parent.frame()) 
[13:21:03.783]                   {
[13:21:03.783]                     default_workers <- missing(workers)
[13:21:03.783]                     if (is.function(workers)) 
[13:21:03.783]                       workers <- workers()
[13:21:03.783]                     workers <- structure(as.integer(workers), 
[13:21:03.783]                       class = class(workers))
[13:21:03.783]                     stop_if_not(is.finite(workers), workers >= 
[13:21:03.783]                       1L)
[13:21:03.783]                     if ((workers == 1L && !inherits(workers, 
[13:21:03.783]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:03.783]                       if (default_workers) 
[13:21:03.783]                         supportsMulticore(warn = TRUE)
[13:21:03.783]                       return(sequential(..., envir = envir))
[13:21:03.783]                     }
[13:21:03.783]                     oopts <- options(mc.cores = workers)
[13:21:03.783]                     on.exit(options(oopts))
[13:21:03.783]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:03.783]                       envir = envir)
[13:21:03.783]                     if (!future$lazy) 
[13:21:03.783]                       future <- run(future)
[13:21:03.783]                     invisible(future)
[13:21:03.783]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:03.783]                 }
[13:21:03.783]             }
[13:21:03.783]         }
[13:21:03.783]     })
[13:21:03.783]     if (TRUE) {
[13:21:03.783]         base::sink(type = "output", split = FALSE)
[13:21:03.783]         if (TRUE) {
[13:21:03.783]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:03.783]         }
[13:21:03.783]         else {
[13:21:03.783]             ...future.result["stdout"] <- base::list(NULL)
[13:21:03.783]         }
[13:21:03.783]         base::close(...future.stdout)
[13:21:03.783]         ...future.stdout <- NULL
[13:21:03.783]     }
[13:21:03.783]     ...future.result$conditions <- ...future.conditions
[13:21:03.783]     ...future.result$finished <- base::Sys.time()
[13:21:03.783]     ...future.result
[13:21:03.783] }
[13:21:03.786] assign_globals() ...
[13:21:03.786] List of 1
[13:21:03.786]  $ ii: int 3
[13:21:03.786]  - attr(*, "where")=List of 1
[13:21:03.786]   ..$ ii:<environment: R_EmptyEnv> 
[13:21:03.786]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:03.786]  - attr(*, "resolved")= logi FALSE
[13:21:03.786]  - attr(*, "total_size")= num 56
[13:21:03.791] - copied ‘ii’ to environment
[13:21:03.791] assign_globals() ... done
[13:21:03.791] requestCore(): workers = 2
[13:21:03.791] Poll #1 (0): usedCores() = 2, workers = 2
[13:21:03.805] MulticoreFuture started
 - Creating multicore future #4 ...
[13:21:03.806] plan(): Setting new future strategy stack:
[13:21:03.807] List of future strategies:
[13:21:03.807] 1. sequential:
[13:21:03.807]    - args: function (..., envir = parent.frame())
[13:21:03.807]    - tweaked: FALSE
[13:21:03.807]    - call: NULL
[13:21:03.808] plan(): nbrOfWorkers() = 1
[13:21:03.810] plan(): Setting new future strategy stack:
[13:21:03.810] List of future strategies:
[13:21:03.810] 1. multicore:
[13:21:03.810]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:03.810]    - tweaked: FALSE
[13:21:03.810]    - call: plan(multicore)
[13:21:03.812] getGlobalsAndPackages() ...
[13:21:03.813] Searching for globals...
[13:21:03.814] - globals found: [2] ‘{’, ‘ii’
[13:21:03.814] Searching for globals ... DONE
[13:21:03.814] Resolving globals: FALSE
[13:21:03.815] The total size of the 1 globals is 56 bytes (56 bytes)
[13:21:03.816] plan(): nbrOfWorkers() = 2
[13:21:03.816] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:21:03.816] - globals: [1] ‘ii’
[13:21:03.817] 
[13:21:03.817] getGlobalsAndPackages() ... DONE
[13:21:03.818] Packages needed by the future expression (n = 0): <none>
[13:21:03.818] Packages needed by future strategies (n = 0): <none>
[13:21:03.818] {
[13:21:03.818]     {
[13:21:03.818]         {
[13:21:03.818]             ...future.startTime <- base::Sys.time()
[13:21:03.818]             {
[13:21:03.818]                 {
[13:21:03.818]                   {
[13:21:03.818]                     {
[13:21:03.818]                       base::local({
[13:21:03.818]                         has_future <- base::requireNamespace("future", 
[13:21:03.818]                           quietly = TRUE)
[13:21:03.818]                         if (has_future) {
[13:21:03.818]                           ns <- base::getNamespace("future")
[13:21:03.818]                           version <- ns[[".package"]][["version"]]
[13:21:03.818]                           if (is.null(version)) 
[13:21:03.818]                             version <- utils::packageVersion("future")
[13:21:03.818]                         }
[13:21:03.818]                         else {
[13:21:03.818]                           version <- NULL
[13:21:03.818]                         }
[13:21:03.818]                         if (!has_future || version < "1.8.0") {
[13:21:03.818]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:03.818]                             "", base::R.version$version.string), 
[13:21:03.818]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:03.818]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:03.818]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:03.818]                               "release", "version")], collapse = " "), 
[13:21:03.818]                             hostname = base::Sys.info()[["nodename"]])
[13:21:03.818]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:03.818]                             info)
[13:21:03.818]                           info <- base::paste(info, collapse = "; ")
[13:21:03.818]                           if (!has_future) {
[13:21:03.818]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:03.818]                               info)
[13:21:03.818]                           }
[13:21:03.818]                           else {
[13:21:03.818]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:03.818]                               info, version)
[13:21:03.818]                           }
[13:21:03.818]                           base::stop(msg)
[13:21:03.818]                         }
[13:21:03.818]                       })
[13:21:03.818]                     }
[13:21:03.818]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:03.818]                     base::options(mc.cores = 1L)
[13:21:03.818]                   }
[13:21:03.818]                   options(future.plan = NULL)
[13:21:03.818]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.818]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:03.818]                 }
[13:21:03.818]                 ...future.workdir <- getwd()
[13:21:03.818]             }
[13:21:03.818]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:03.818]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:03.818]         }
[13:21:03.818]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:03.818]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:03.818]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:03.818]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:03.818]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:03.818]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:03.818]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:03.818]             base::names(...future.oldOptions))
[13:21:03.818]     }
[13:21:03.818]     if (FALSE) {
[13:21:03.818]     }
[13:21:03.818]     else {
[13:21:03.818]         if (TRUE) {
[13:21:03.818]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:03.818]                 open = "w")
[13:21:03.818]         }
[13:21:03.818]         else {
[13:21:03.818]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:03.818]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:03.818]         }
[13:21:03.818]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:03.818]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:03.818]             base::sink(type = "output", split = FALSE)
[13:21:03.818]             base::close(...future.stdout)
[13:21:03.818]         }, add = TRUE)
[13:21:03.818]     }
[13:21:03.818]     ...future.frame <- base::sys.nframe()
[13:21:03.818]     ...future.conditions <- base::list()
[13:21:03.818]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:03.818]     if (FALSE) {
[13:21:03.818]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:03.818]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:03.818]     }
[13:21:03.818]     ...future.result <- base::tryCatch({
[13:21:03.818]         base::withCallingHandlers({
[13:21:03.818]             ...future.value <- base::withVisible(base::local({
[13:21:03.818]                 withCallingHandlers({
[13:21:03.818]                   {
[13:21:03.818]                     ii
[13:21:03.818]                   }
[13:21:03.818]                 }, immediateCondition = function(cond) {
[13:21:03.818]                   save_rds <- function (object, pathname, ...) 
[13:21:03.818]                   {
[13:21:03.818]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:03.818]                     if (file_test("-f", pathname_tmp)) {
[13:21:03.818]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.818]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:03.818]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.818]                         fi_tmp[["mtime"]])
[13:21:03.818]                     }
[13:21:03.818]                     tryCatch({
[13:21:03.818]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:03.818]                     }, error = function(ex) {
[13:21:03.818]                       msg <- conditionMessage(ex)
[13:21:03.818]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.818]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:03.818]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.818]                         fi_tmp[["mtime"]], msg)
[13:21:03.818]                       ex$message <- msg
[13:21:03.818]                       stop(ex)
[13:21:03.818]                     })
[13:21:03.818]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:03.818]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:03.818]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:03.818]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.818]                       fi <- file.info(pathname)
[13:21:03.818]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:03.818]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.818]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:03.818]                         fi[["size"]], fi[["mtime"]])
[13:21:03.818]                       stop(msg)
[13:21:03.818]                     }
[13:21:03.818]                     invisible(pathname)
[13:21:03.818]                   }
[13:21:03.818]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:03.818]                     rootPath = tempdir()) 
[13:21:03.818]                   {
[13:21:03.818]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:03.818]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:03.818]                       tmpdir = path, fileext = ".rds")
[13:21:03.818]                     save_rds(obj, file)
[13:21:03.818]                   }
[13:21:03.818]                   saveImmediateCondition(cond, path = "/tmp/Rtmpd6Ly3I/.future/immediateConditions")
[13:21:03.818]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.818]                   {
[13:21:03.818]                     inherits <- base::inherits
[13:21:03.818]                     invokeRestart <- base::invokeRestart
[13:21:03.818]                     is.null <- base::is.null
[13:21:03.818]                     muffled <- FALSE
[13:21:03.818]                     if (inherits(cond, "message")) {
[13:21:03.818]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:03.818]                       if (muffled) 
[13:21:03.818]                         invokeRestart("muffleMessage")
[13:21:03.818]                     }
[13:21:03.818]                     else if (inherits(cond, "warning")) {
[13:21:03.818]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:03.818]                       if (muffled) 
[13:21:03.818]                         invokeRestart("muffleWarning")
[13:21:03.818]                     }
[13:21:03.818]                     else if (inherits(cond, "condition")) {
[13:21:03.818]                       if (!is.null(pattern)) {
[13:21:03.818]                         computeRestarts <- base::computeRestarts
[13:21:03.818]                         grepl <- base::grepl
[13:21:03.818]                         restarts <- computeRestarts(cond)
[13:21:03.818]                         for (restart in restarts) {
[13:21:03.818]                           name <- restart$name
[13:21:03.818]                           if (is.null(name)) 
[13:21:03.818]                             next
[13:21:03.818]                           if (!grepl(pattern, name)) 
[13:21:03.818]                             next
[13:21:03.818]                           invokeRestart(restart)
[13:21:03.818]                           muffled <- TRUE
[13:21:03.818]                           break
[13:21:03.818]                         }
[13:21:03.818]                       }
[13:21:03.818]                     }
[13:21:03.818]                     invisible(muffled)
[13:21:03.818]                   }
[13:21:03.818]                   muffleCondition(cond)
[13:21:03.818]                 })
[13:21:03.818]             }))
[13:21:03.818]             future::FutureResult(value = ...future.value$value, 
[13:21:03.818]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.818]                   ...future.rng), globalenv = if (FALSE) 
[13:21:03.818]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:03.818]                     ...future.globalenv.names))
[13:21:03.818]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:03.818]         }, condition = base::local({
[13:21:03.818]             c <- base::c
[13:21:03.818]             inherits <- base::inherits
[13:21:03.818]             invokeRestart <- base::invokeRestart
[13:21:03.818]             length <- base::length
[13:21:03.818]             list <- base::list
[13:21:03.818]             seq.int <- base::seq.int
[13:21:03.818]             signalCondition <- base::signalCondition
[13:21:03.818]             sys.calls <- base::sys.calls
[13:21:03.818]             `[[` <- base::`[[`
[13:21:03.818]             `+` <- base::`+`
[13:21:03.818]             `<<-` <- base::`<<-`
[13:21:03.818]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:03.818]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:03.818]                   3L)]
[13:21:03.818]             }
[13:21:03.818]             function(cond) {
[13:21:03.818]                 is_error <- inherits(cond, "error")
[13:21:03.818]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:03.818]                   NULL)
[13:21:03.818]                 if (is_error) {
[13:21:03.818]                   sessionInformation <- function() {
[13:21:03.818]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:03.818]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:03.818]                       search = base::search(), system = base::Sys.info())
[13:21:03.818]                   }
[13:21:03.818]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.818]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:03.818]                     cond$call), session = sessionInformation(), 
[13:21:03.818]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:03.818]                   signalCondition(cond)
[13:21:03.818]                 }
[13:21:03.818]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:03.818]                 "immediateCondition"))) {
[13:21:03.818]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:03.818]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.818]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:03.818]                   if (TRUE && !signal) {
[13:21:03.818]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.818]                     {
[13:21:03.818]                       inherits <- base::inherits
[13:21:03.818]                       invokeRestart <- base::invokeRestart
[13:21:03.818]                       is.null <- base::is.null
[13:21:03.818]                       muffled <- FALSE
[13:21:03.818]                       if (inherits(cond, "message")) {
[13:21:03.818]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.818]                         if (muffled) 
[13:21:03.818]                           invokeRestart("muffleMessage")
[13:21:03.818]                       }
[13:21:03.818]                       else if (inherits(cond, "warning")) {
[13:21:03.818]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.818]                         if (muffled) 
[13:21:03.818]                           invokeRestart("muffleWarning")
[13:21:03.818]                       }
[13:21:03.818]                       else if (inherits(cond, "condition")) {
[13:21:03.818]                         if (!is.null(pattern)) {
[13:21:03.818]                           computeRestarts <- base::computeRestarts
[13:21:03.818]                           grepl <- base::grepl
[13:21:03.818]                           restarts <- computeRestarts(cond)
[13:21:03.818]                           for (restart in restarts) {
[13:21:03.818]                             name <- restart$name
[13:21:03.818]                             if (is.null(name)) 
[13:21:03.818]                               next
[13:21:03.818]                             if (!grepl(pattern, name)) 
[13:21:03.818]                               next
[13:21:03.818]                             invokeRestart(restart)
[13:21:03.818]                             muffled <- TRUE
[13:21:03.818]                             break
[13:21:03.818]                           }
[13:21:03.818]                         }
[13:21:03.818]                       }
[13:21:03.818]                       invisible(muffled)
[13:21:03.818]                     }
[13:21:03.818]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.818]                   }
[13:21:03.818]                 }
[13:21:03.818]                 else {
[13:21:03.818]                   if (TRUE) {
[13:21:03.818]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.818]                     {
[13:21:03.818]                       inherits <- base::inherits
[13:21:03.818]                       invokeRestart <- base::invokeRestart
[13:21:03.818]                       is.null <- base::is.null
[13:21:03.818]                       muffled <- FALSE
[13:21:03.818]                       if (inherits(cond, "message")) {
[13:21:03.818]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.818]                         if (muffled) 
[13:21:03.818]                           invokeRestart("muffleMessage")
[13:21:03.818]                       }
[13:21:03.818]                       else if (inherits(cond, "warning")) {
[13:21:03.818]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.818]                         if (muffled) 
[13:21:03.818]                           invokeRestart("muffleWarning")
[13:21:03.818]                       }
[13:21:03.818]                       else if (inherits(cond, "condition")) {
[13:21:03.818]                         if (!is.null(pattern)) {
[13:21:03.818]                           computeRestarts <- base::computeRestarts
[13:21:03.818]                           grepl <- base::grepl
[13:21:03.818]                           restarts <- computeRestarts(cond)
[13:21:03.818]                           for (restart in restarts) {
[13:21:03.818]                             name <- restart$name
[13:21:03.818]                             if (is.null(name)) 
[13:21:03.818]                               next
[13:21:03.818]                             if (!grepl(pattern, name)) 
[13:21:03.818]                               next
[13:21:03.818]                             invokeRestart(restart)
[13:21:03.818]                             muffled <- TRUE
[13:21:03.818]                             break
[13:21:03.818]                           }
[13:21:03.818]                         }
[13:21:03.818]                       }
[13:21:03.818]                       invisible(muffled)
[13:21:03.818]                     }
[13:21:03.818]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.818]                   }
[13:21:03.818]                 }
[13:21:03.818]             }
[13:21:03.818]         }))
[13:21:03.818]     }, error = function(ex) {
[13:21:03.818]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:03.818]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.818]                 ...future.rng), started = ...future.startTime, 
[13:21:03.818]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:03.818]             version = "1.8"), class = "FutureResult")
[13:21:03.818]     }, finally = {
[13:21:03.818]         if (!identical(...future.workdir, getwd())) 
[13:21:03.818]             setwd(...future.workdir)
[13:21:03.818]         {
[13:21:03.818]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:03.818]                 ...future.oldOptions$nwarnings <- NULL
[13:21:03.818]             }
[13:21:03.818]             base::options(...future.oldOptions)
[13:21:03.818]             if (.Platform$OS.type == "windows") {
[13:21:03.818]                 old_names <- names(...future.oldEnvVars)
[13:21:03.818]                 envs <- base::Sys.getenv()
[13:21:03.818]                 names <- names(envs)
[13:21:03.818]                 common <- intersect(names, old_names)
[13:21:03.818]                 added <- setdiff(names, old_names)
[13:21:03.818]                 removed <- setdiff(old_names, names)
[13:21:03.818]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:03.818]                   envs[common]]
[13:21:03.818]                 NAMES <- toupper(changed)
[13:21:03.818]                 args <- list()
[13:21:03.818]                 for (kk in seq_along(NAMES)) {
[13:21:03.818]                   name <- changed[[kk]]
[13:21:03.818]                   NAME <- NAMES[[kk]]
[13:21:03.818]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.818]                     next
[13:21:03.818]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.818]                 }
[13:21:03.818]                 NAMES <- toupper(added)
[13:21:03.818]                 for (kk in seq_along(NAMES)) {
[13:21:03.818]                   name <- added[[kk]]
[13:21:03.818]                   NAME <- NAMES[[kk]]
[13:21:03.818]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.818]                     next
[13:21:03.818]                   args[[name]] <- ""
[13:21:03.818]                 }
[13:21:03.818]                 NAMES <- toupper(removed)
[13:21:03.818]                 for (kk in seq_along(NAMES)) {
[13:21:03.818]                   name <- removed[[kk]]
[13:21:03.818]                   NAME <- NAMES[[kk]]
[13:21:03.818]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.818]                     next
[13:21:03.818]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.818]                 }
[13:21:03.818]                 if (length(args) > 0) 
[13:21:03.818]                   base::do.call(base::Sys.setenv, args = args)
[13:21:03.818]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:03.818]             }
[13:21:03.818]             else {
[13:21:03.818]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:03.818]             }
[13:21:03.818]             {
[13:21:03.818]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:03.818]                   0L) {
[13:21:03.818]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:03.818]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:03.818]                   base::options(opts)
[13:21:03.818]                 }
[13:21:03.818]                 {
[13:21:03.818]                   {
[13:21:03.818]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:03.818]                     NULL
[13:21:03.818]                   }
[13:21:03.818]                   options(future.plan = NULL)
[13:21:03.818]                   if (is.na(NA_character_)) 
[13:21:03.818]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.818]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:03.818]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:03.818]                     envir = parent.frame()) 
[13:21:03.818]                   {
[13:21:03.818]                     default_workers <- missing(workers)
[13:21:03.818]                     if (is.function(workers)) 
[13:21:03.818]                       workers <- workers()
[13:21:03.818]                     workers <- structure(as.integer(workers), 
[13:21:03.818]                       class = class(workers))
[13:21:03.818]                     stop_if_not(is.finite(workers), workers >= 
[13:21:03.818]                       1L)
[13:21:03.818]                     if ((workers == 1L && !inherits(workers, 
[13:21:03.818]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:03.818]                       if (default_workers) 
[13:21:03.818]                         supportsMulticore(warn = TRUE)
[13:21:03.818]                       return(sequential(..., envir = envir))
[13:21:03.818]                     }
[13:21:03.818]                     oopts <- options(mc.cores = workers)
[13:21:03.818]                     on.exit(options(oopts))
[13:21:03.818]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:03.818]                       envir = envir)
[13:21:03.818]                     if (!future$lazy) 
[13:21:03.818]                       future <- run(future)
[13:21:03.818]                     invisible(future)
[13:21:03.818]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:03.818]                 }
[13:21:03.818]             }
[13:21:03.818]         }
[13:21:03.818]     })
[13:21:03.818]     if (TRUE) {
[13:21:03.818]         base::sink(type = "output", split = FALSE)
[13:21:03.818]         if (TRUE) {
[13:21:03.818]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:03.818]         }
[13:21:03.818]         else {
[13:21:03.818]             ...future.result["stdout"] <- base::list(NULL)
[13:21:03.818]         }
[13:21:03.818]         base::close(...future.stdout)
[13:21:03.818]         ...future.stdout <- NULL
[13:21:03.818]     }
[13:21:03.818]     ...future.result$conditions <- ...future.conditions
[13:21:03.818]     ...future.result$finished <- base::Sys.time()
[13:21:03.818]     ...future.result
[13:21:03.818] }
[13:21:03.822] assign_globals() ...
[13:21:03.822] List of 1
[13:21:03.822]  $ ii: int 4
[13:21:03.822]  - attr(*, "where")=List of 1
[13:21:03.822]   ..$ ii:<environment: R_EmptyEnv> 
[13:21:03.822]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:03.822]  - attr(*, "resolved")= logi FALSE
[13:21:03.822]  - attr(*, "total_size")= num 56
[13:21:03.825] - copied ‘ii’ to environment
[13:21:03.826] assign_globals() ... done
[13:21:03.826] requestCore(): workers = 2
[13:21:03.826] Poll #1 (0): usedCores() = 2, workers = 2
[13:21:03.840] MulticoreFuture started
 - Resolving 4 multicore futures
[13:21:03.841] plan(): Setting new future strategy stack:
[13:21:03.841] List of future strategies:
[13:21:03.841] 1. sequential:
[13:21:03.841]    - args: function (..., envir = parent.frame())
[13:21:03.841]    - tweaked: FALSE
[13:21:03.841]    - call: NULL
[13:21:03.842] plan(): nbrOfWorkers() = 1
[13:21:03.844] plan(): Setting new future strategy stack:
[13:21:03.844] List of future strategies:
[13:21:03.844] 1. multicore:
[13:21:03.844]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:03.844]    - tweaked: FALSE
[13:21:03.844]    - call: plan(multicore)
[13:21:03.849] plan(): nbrOfWorkers() = 2
*** multicore(..., globals = TRUE) and errors
[13:21:03.854] getGlobalsAndPackages() ...
[13:21:03.854] Searching for globals...
[13:21:03.855] - globals found: [2] ‘{’, ‘stop’
[13:21:03.855] Searching for globals ... DONE
[13:21:03.856] Resolving globals: FALSE
[13:21:03.856] 
[13:21:03.856] 
[13:21:03.856] getGlobalsAndPackages() ... DONE
[13:21:03.857] Packages needed by the future expression (n = 0): <none>
[13:21:03.857] Packages needed by future strategies (n = 0): <none>
[13:21:03.857] {
[13:21:03.857]     {
[13:21:03.857]         {
[13:21:03.857]             ...future.startTime <- base::Sys.time()
[13:21:03.857]             {
[13:21:03.857]                 {
[13:21:03.857]                   {
[13:21:03.857]                     {
[13:21:03.857]                       base::local({
[13:21:03.857]                         has_future <- base::requireNamespace("future", 
[13:21:03.857]                           quietly = TRUE)
[13:21:03.857]                         if (has_future) {
[13:21:03.857]                           ns <- base::getNamespace("future")
[13:21:03.857]                           version <- ns[[".package"]][["version"]]
[13:21:03.857]                           if (is.null(version)) 
[13:21:03.857]                             version <- utils::packageVersion("future")
[13:21:03.857]                         }
[13:21:03.857]                         else {
[13:21:03.857]                           version <- NULL
[13:21:03.857]                         }
[13:21:03.857]                         if (!has_future || version < "1.8.0") {
[13:21:03.857]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:03.857]                             "", base::R.version$version.string), 
[13:21:03.857]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:03.857]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:03.857]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:03.857]                               "release", "version")], collapse = " "), 
[13:21:03.857]                             hostname = base::Sys.info()[["nodename"]])
[13:21:03.857]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:03.857]                             info)
[13:21:03.857]                           info <- base::paste(info, collapse = "; ")
[13:21:03.857]                           if (!has_future) {
[13:21:03.857]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:03.857]                               info)
[13:21:03.857]                           }
[13:21:03.857]                           else {
[13:21:03.857]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:03.857]                               info, version)
[13:21:03.857]                           }
[13:21:03.857]                           base::stop(msg)
[13:21:03.857]                         }
[13:21:03.857]                       })
[13:21:03.857]                     }
[13:21:03.857]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:03.857]                     base::options(mc.cores = 1L)
[13:21:03.857]                   }
[13:21:03.857]                   options(future.plan = NULL)
[13:21:03.857]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.857]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:03.857]                 }
[13:21:03.857]                 ...future.workdir <- getwd()
[13:21:03.857]             }
[13:21:03.857]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:03.857]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:03.857]         }
[13:21:03.857]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:03.857]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:03.857]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:03.857]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:03.857]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:03.857]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:03.857]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:03.857]             base::names(...future.oldOptions))
[13:21:03.857]     }
[13:21:03.857]     if (FALSE) {
[13:21:03.857]     }
[13:21:03.857]     else {
[13:21:03.857]         if (TRUE) {
[13:21:03.857]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:03.857]                 open = "w")
[13:21:03.857]         }
[13:21:03.857]         else {
[13:21:03.857]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:03.857]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:03.857]         }
[13:21:03.857]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:03.857]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:03.857]             base::sink(type = "output", split = FALSE)
[13:21:03.857]             base::close(...future.stdout)
[13:21:03.857]         }, add = TRUE)
[13:21:03.857]     }
[13:21:03.857]     ...future.frame <- base::sys.nframe()
[13:21:03.857]     ...future.conditions <- base::list()
[13:21:03.857]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:03.857]     if (FALSE) {
[13:21:03.857]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:03.857]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:03.857]     }
[13:21:03.857]     ...future.result <- base::tryCatch({
[13:21:03.857]         base::withCallingHandlers({
[13:21:03.857]             ...future.value <- base::withVisible(base::local({
[13:21:03.857]                 withCallingHandlers({
[13:21:03.857]                   {
[13:21:03.857]                     stop("Whoops!")
[13:21:03.857]                     1
[13:21:03.857]                   }
[13:21:03.857]                 }, immediateCondition = function(cond) {
[13:21:03.857]                   save_rds <- function (object, pathname, ...) 
[13:21:03.857]                   {
[13:21:03.857]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:03.857]                     if (file_test("-f", pathname_tmp)) {
[13:21:03.857]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.857]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:03.857]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.857]                         fi_tmp[["mtime"]])
[13:21:03.857]                     }
[13:21:03.857]                     tryCatch({
[13:21:03.857]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:03.857]                     }, error = function(ex) {
[13:21:03.857]                       msg <- conditionMessage(ex)
[13:21:03.857]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.857]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:03.857]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.857]                         fi_tmp[["mtime"]], msg)
[13:21:03.857]                       ex$message <- msg
[13:21:03.857]                       stop(ex)
[13:21:03.857]                     })
[13:21:03.857]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:03.857]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:03.857]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:03.857]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.857]                       fi <- file.info(pathname)
[13:21:03.857]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:03.857]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.857]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:03.857]                         fi[["size"]], fi[["mtime"]])
[13:21:03.857]                       stop(msg)
[13:21:03.857]                     }
[13:21:03.857]                     invisible(pathname)
[13:21:03.857]                   }
[13:21:03.857]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:03.857]                     rootPath = tempdir()) 
[13:21:03.857]                   {
[13:21:03.857]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:03.857]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:03.857]                       tmpdir = path, fileext = ".rds")
[13:21:03.857]                     save_rds(obj, file)
[13:21:03.857]                   }
[13:21:03.857]                   saveImmediateCondition(cond, path = "/tmp/Rtmpd6Ly3I/.future/immediateConditions")
[13:21:03.857]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.857]                   {
[13:21:03.857]                     inherits <- base::inherits
[13:21:03.857]                     invokeRestart <- base::invokeRestart
[13:21:03.857]                     is.null <- base::is.null
[13:21:03.857]                     muffled <- FALSE
[13:21:03.857]                     if (inherits(cond, "message")) {
[13:21:03.857]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:03.857]                       if (muffled) 
[13:21:03.857]                         invokeRestart("muffleMessage")
[13:21:03.857]                     }
[13:21:03.857]                     else if (inherits(cond, "warning")) {
[13:21:03.857]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:03.857]                       if (muffled) 
[13:21:03.857]                         invokeRestart("muffleWarning")
[13:21:03.857]                     }
[13:21:03.857]                     else if (inherits(cond, "condition")) {
[13:21:03.857]                       if (!is.null(pattern)) {
[13:21:03.857]                         computeRestarts <- base::computeRestarts
[13:21:03.857]                         grepl <- base::grepl
[13:21:03.857]                         restarts <- computeRestarts(cond)
[13:21:03.857]                         for (restart in restarts) {
[13:21:03.857]                           name <- restart$name
[13:21:03.857]                           if (is.null(name)) 
[13:21:03.857]                             next
[13:21:03.857]                           if (!grepl(pattern, name)) 
[13:21:03.857]                             next
[13:21:03.857]                           invokeRestart(restart)
[13:21:03.857]                           muffled <- TRUE
[13:21:03.857]                           break
[13:21:03.857]                         }
[13:21:03.857]                       }
[13:21:03.857]                     }
[13:21:03.857]                     invisible(muffled)
[13:21:03.857]                   }
[13:21:03.857]                   muffleCondition(cond)
[13:21:03.857]                 })
[13:21:03.857]             }))
[13:21:03.857]             future::FutureResult(value = ...future.value$value, 
[13:21:03.857]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.857]                   ...future.rng), globalenv = if (FALSE) 
[13:21:03.857]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:03.857]                     ...future.globalenv.names))
[13:21:03.857]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:03.857]         }, condition = base::local({
[13:21:03.857]             c <- base::c
[13:21:03.857]             inherits <- base::inherits
[13:21:03.857]             invokeRestart <- base::invokeRestart
[13:21:03.857]             length <- base::length
[13:21:03.857]             list <- base::list
[13:21:03.857]             seq.int <- base::seq.int
[13:21:03.857]             signalCondition <- base::signalCondition
[13:21:03.857]             sys.calls <- base::sys.calls
[13:21:03.857]             `[[` <- base::`[[`
[13:21:03.857]             `+` <- base::`+`
[13:21:03.857]             `<<-` <- base::`<<-`
[13:21:03.857]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:03.857]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:03.857]                   3L)]
[13:21:03.857]             }
[13:21:03.857]             function(cond) {
[13:21:03.857]                 is_error <- inherits(cond, "error")
[13:21:03.857]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:03.857]                   NULL)
[13:21:03.857]                 if (is_error) {
[13:21:03.857]                   sessionInformation <- function() {
[13:21:03.857]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:03.857]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:03.857]                       search = base::search(), system = base::Sys.info())
[13:21:03.857]                   }
[13:21:03.857]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.857]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:03.857]                     cond$call), session = sessionInformation(), 
[13:21:03.857]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:03.857]                   signalCondition(cond)
[13:21:03.857]                 }
[13:21:03.857]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:03.857]                 "immediateCondition"))) {
[13:21:03.857]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:03.857]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.857]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:03.857]                   if (TRUE && !signal) {
[13:21:03.857]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.857]                     {
[13:21:03.857]                       inherits <- base::inherits
[13:21:03.857]                       invokeRestart <- base::invokeRestart
[13:21:03.857]                       is.null <- base::is.null
[13:21:03.857]                       muffled <- FALSE
[13:21:03.857]                       if (inherits(cond, "message")) {
[13:21:03.857]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.857]                         if (muffled) 
[13:21:03.857]                           invokeRestart("muffleMessage")
[13:21:03.857]                       }
[13:21:03.857]                       else if (inherits(cond, "warning")) {
[13:21:03.857]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.857]                         if (muffled) 
[13:21:03.857]                           invokeRestart("muffleWarning")
[13:21:03.857]                       }
[13:21:03.857]                       else if (inherits(cond, "condition")) {
[13:21:03.857]                         if (!is.null(pattern)) {
[13:21:03.857]                           computeRestarts <- base::computeRestarts
[13:21:03.857]                           grepl <- base::grepl
[13:21:03.857]                           restarts <- computeRestarts(cond)
[13:21:03.857]                           for (restart in restarts) {
[13:21:03.857]                             name <- restart$name
[13:21:03.857]                             if (is.null(name)) 
[13:21:03.857]                               next
[13:21:03.857]                             if (!grepl(pattern, name)) 
[13:21:03.857]                               next
[13:21:03.857]                             invokeRestart(restart)
[13:21:03.857]                             muffled <- TRUE
[13:21:03.857]                             break
[13:21:03.857]                           }
[13:21:03.857]                         }
[13:21:03.857]                       }
[13:21:03.857]                       invisible(muffled)
[13:21:03.857]                     }
[13:21:03.857]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.857]                   }
[13:21:03.857]                 }
[13:21:03.857]                 else {
[13:21:03.857]                   if (TRUE) {
[13:21:03.857]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.857]                     {
[13:21:03.857]                       inherits <- base::inherits
[13:21:03.857]                       invokeRestart <- base::invokeRestart
[13:21:03.857]                       is.null <- base::is.null
[13:21:03.857]                       muffled <- FALSE
[13:21:03.857]                       if (inherits(cond, "message")) {
[13:21:03.857]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.857]                         if (muffled) 
[13:21:03.857]                           invokeRestart("muffleMessage")
[13:21:03.857]                       }
[13:21:03.857]                       else if (inherits(cond, "warning")) {
[13:21:03.857]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.857]                         if (muffled) 
[13:21:03.857]                           invokeRestart("muffleWarning")
[13:21:03.857]                       }
[13:21:03.857]                       else if (inherits(cond, "condition")) {
[13:21:03.857]                         if (!is.null(pattern)) {
[13:21:03.857]                           computeRestarts <- base::computeRestarts
[13:21:03.857]                           grepl <- base::grepl
[13:21:03.857]                           restarts <- computeRestarts(cond)
[13:21:03.857]                           for (restart in restarts) {
[13:21:03.857]                             name <- restart$name
[13:21:03.857]                             if (is.null(name)) 
[13:21:03.857]                               next
[13:21:03.857]                             if (!grepl(pattern, name)) 
[13:21:03.857]                               next
[13:21:03.857]                             invokeRestart(restart)
[13:21:03.857]                             muffled <- TRUE
[13:21:03.857]                             break
[13:21:03.857]                           }
[13:21:03.857]                         }
[13:21:03.857]                       }
[13:21:03.857]                       invisible(muffled)
[13:21:03.857]                     }
[13:21:03.857]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.857]                   }
[13:21:03.857]                 }
[13:21:03.857]             }
[13:21:03.857]         }))
[13:21:03.857]     }, error = function(ex) {
[13:21:03.857]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:03.857]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.857]                 ...future.rng), started = ...future.startTime, 
[13:21:03.857]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:03.857]             version = "1.8"), class = "FutureResult")
[13:21:03.857]     }, finally = {
[13:21:03.857]         if (!identical(...future.workdir, getwd())) 
[13:21:03.857]             setwd(...future.workdir)
[13:21:03.857]         {
[13:21:03.857]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:03.857]                 ...future.oldOptions$nwarnings <- NULL
[13:21:03.857]             }
[13:21:03.857]             base::options(...future.oldOptions)
[13:21:03.857]             if (.Platform$OS.type == "windows") {
[13:21:03.857]                 old_names <- names(...future.oldEnvVars)
[13:21:03.857]                 envs <- base::Sys.getenv()
[13:21:03.857]                 names <- names(envs)
[13:21:03.857]                 common <- intersect(names, old_names)
[13:21:03.857]                 added <- setdiff(names, old_names)
[13:21:03.857]                 removed <- setdiff(old_names, names)
[13:21:03.857]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:03.857]                   envs[common]]
[13:21:03.857]                 NAMES <- toupper(changed)
[13:21:03.857]                 args <- list()
[13:21:03.857]                 for (kk in seq_along(NAMES)) {
[13:21:03.857]                   name <- changed[[kk]]
[13:21:03.857]                   NAME <- NAMES[[kk]]
[13:21:03.857]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.857]                     next
[13:21:03.857]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.857]                 }
[13:21:03.857]                 NAMES <- toupper(added)
[13:21:03.857]                 for (kk in seq_along(NAMES)) {
[13:21:03.857]                   name <- added[[kk]]
[13:21:03.857]                   NAME <- NAMES[[kk]]
[13:21:03.857]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.857]                     next
[13:21:03.857]                   args[[name]] <- ""
[13:21:03.857]                 }
[13:21:03.857]                 NAMES <- toupper(removed)
[13:21:03.857]                 for (kk in seq_along(NAMES)) {
[13:21:03.857]                   name <- removed[[kk]]
[13:21:03.857]                   NAME <- NAMES[[kk]]
[13:21:03.857]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.857]                     next
[13:21:03.857]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.857]                 }
[13:21:03.857]                 if (length(args) > 0) 
[13:21:03.857]                   base::do.call(base::Sys.setenv, args = args)
[13:21:03.857]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:03.857]             }
[13:21:03.857]             else {
[13:21:03.857]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:03.857]             }
[13:21:03.857]             {
[13:21:03.857]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:03.857]                   0L) {
[13:21:03.857]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:03.857]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:03.857]                   base::options(opts)
[13:21:03.857]                 }
[13:21:03.857]                 {
[13:21:03.857]                   {
[13:21:03.857]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:03.857]                     NULL
[13:21:03.857]                   }
[13:21:03.857]                   options(future.plan = NULL)
[13:21:03.857]                   if (is.na(NA_character_)) 
[13:21:03.857]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.857]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:03.857]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:03.857]                     envir = parent.frame()) 
[13:21:03.857]                   {
[13:21:03.857]                     default_workers <- missing(workers)
[13:21:03.857]                     if (is.function(workers)) 
[13:21:03.857]                       workers <- workers()
[13:21:03.857]                     workers <- structure(as.integer(workers), 
[13:21:03.857]                       class = class(workers))
[13:21:03.857]                     stop_if_not(is.finite(workers), workers >= 
[13:21:03.857]                       1L)
[13:21:03.857]                     if ((workers == 1L && !inherits(workers, 
[13:21:03.857]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:03.857]                       if (default_workers) 
[13:21:03.857]                         supportsMulticore(warn = TRUE)
[13:21:03.857]                       return(sequential(..., envir = envir))
[13:21:03.857]                     }
[13:21:03.857]                     oopts <- options(mc.cores = workers)
[13:21:03.857]                     on.exit(options(oopts))
[13:21:03.857]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:03.857]                       envir = envir)
[13:21:03.857]                     if (!future$lazy) 
[13:21:03.857]                       future <- run(future)
[13:21:03.857]                     invisible(future)
[13:21:03.857]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:03.857]                 }
[13:21:03.857]             }
[13:21:03.857]         }
[13:21:03.857]     })
[13:21:03.857]     if (TRUE) {
[13:21:03.857]         base::sink(type = "output", split = FALSE)
[13:21:03.857]         if (TRUE) {
[13:21:03.857]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:03.857]         }
[13:21:03.857]         else {
[13:21:03.857]             ...future.result["stdout"] <- base::list(NULL)
[13:21:03.857]         }
[13:21:03.857]         base::close(...future.stdout)
[13:21:03.857]         ...future.stdout <- NULL
[13:21:03.857]     }
[13:21:03.857]     ...future.result$conditions <- ...future.conditions
[13:21:03.857]     ...future.result$finished <- base::Sys.time()
[13:21:03.857]     ...future.result
[13:21:03.857] }
[13:21:03.860] requestCore(): workers = 2
[13:21:03.862] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:03.863] plan(): Setting new future strategy stack:
[13:21:03.863] List of future strategies:
[13:21:03.863] 1. sequential:
[13:21:03.863]    - args: function (..., envir = parent.frame())
[13:21:03.863]    - tweaked: FALSE
[13:21:03.863]    - call: NULL
[13:21:03.864] plan(): nbrOfWorkers() = 1
[13:21:03.866] plan(): Setting new future strategy stack:
[13:21:03.866] List of future strategies:
[13:21:03.866] 1. multicore:
[13:21:03.866]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:03.866]    - tweaked: FALSE
[13:21:03.866]    - call: plan(multicore)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 32f7abe8-d290-272e-8911-a8ce072c31c3
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:03.876] plan(): nbrOfWorkers() = 2
[13:21:03.880] signalConditions() ...
[13:21:03.881]  - include = ‘immediateCondition’
[13:21:03.881]  - exclude = 
[13:21:03.881]  - resignal = FALSE
[13:21:03.881]  - Number of conditions: 1
[13:21:03.884] signalConditions() ... done
[13:21:03.884] signalConditions() ...
[13:21:03.884]  - include = ‘immediateCondition’
[13:21:03.884]  - exclude = 
[13:21:03.885]  - resignal = FALSE
[13:21:03.885]  - Number of conditions: 1
[13:21:03.885] signalConditions() ... done
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/Rtmpd6Ly3I/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[13:21:03.886] signalConditions() ...
[13:21:03.886]  - include = ‘immediateCondition’
[13:21:03.886]  - exclude = 
[13:21:03.886]  - resignal = FALSE
[13:21:03.886]  - Number of conditions: 1
[13:21:03.886] signalConditions() ... done
[13:21:03.887] Future state: ‘finished’
[13:21:03.887] signalConditions() ...
[13:21:03.887]  - include = ‘condition’
[13:21:03.887]  - exclude = ‘immediateCondition’
[13:21:03.887]  - resignal = TRUE
[13:21:03.887]  - Number of conditions: 1
[13:21:03.887]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:21:03.888] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/Rtmpd6Ly3I/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[13:21:03.889] signalConditions() ...
[13:21:03.889]  - include = ‘immediateCondition’
[13:21:03.889]  - exclude = 
[13:21:03.889]  - resignal = FALSE
[13:21:03.889]  - Number of conditions: 1
[13:21:03.889] signalConditions() ... done
[13:21:03.889] Future state: ‘finished’
[13:21:03.889] signalConditions() ...
[13:21:03.890]  - include = ‘condition’
[13:21:03.890]  - exclude = ‘immediateCondition’
[13:21:03.890]  - resignal = TRUE
[13:21:03.890]  - Number of conditions: 1
[13:21:03.890]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:21:03.890] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/Rtmpd6Ly3I/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[13:21:03.895] getGlobalsAndPackages() ...
[13:21:03.895] 
[13:21:03.895] - globals: [0] <none>
[13:21:03.895] getGlobalsAndPackages() ... DONE
[13:21:03.896] Packages needed by the future expression (n = 0): <none>
[13:21:03.896] Packages needed by future strategies (n = 0): <none>
[13:21:03.897] {
[13:21:03.897]     {
[13:21:03.897]         {
[13:21:03.897]             ...future.startTime <- base::Sys.time()
[13:21:03.897]             {
[13:21:03.897]                 {
[13:21:03.897]                   {
[13:21:03.897]                     {
[13:21:03.897]                       base::local({
[13:21:03.897]                         has_future <- base::requireNamespace("future", 
[13:21:03.897]                           quietly = TRUE)
[13:21:03.897]                         if (has_future) {
[13:21:03.897]                           ns <- base::getNamespace("future")
[13:21:03.897]                           version <- ns[[".package"]][["version"]]
[13:21:03.897]                           if (is.null(version)) 
[13:21:03.897]                             version <- utils::packageVersion("future")
[13:21:03.897]                         }
[13:21:03.897]                         else {
[13:21:03.897]                           version <- NULL
[13:21:03.897]                         }
[13:21:03.897]                         if (!has_future || version < "1.8.0") {
[13:21:03.897]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:03.897]                             "", base::R.version$version.string), 
[13:21:03.897]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:03.897]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:03.897]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:03.897]                               "release", "version")], collapse = " "), 
[13:21:03.897]                             hostname = base::Sys.info()[["nodename"]])
[13:21:03.897]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:03.897]                             info)
[13:21:03.897]                           info <- base::paste(info, collapse = "; ")
[13:21:03.897]                           if (!has_future) {
[13:21:03.897]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:03.897]                               info)
[13:21:03.897]                           }
[13:21:03.897]                           else {
[13:21:03.897]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:03.897]                               info, version)
[13:21:03.897]                           }
[13:21:03.897]                           base::stop(msg)
[13:21:03.897]                         }
[13:21:03.897]                       })
[13:21:03.897]                     }
[13:21:03.897]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:03.897]                     base::options(mc.cores = 1L)
[13:21:03.897]                   }
[13:21:03.897]                   options(future.plan = NULL)
[13:21:03.897]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.897]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:03.897]                 }
[13:21:03.897]                 ...future.workdir <- getwd()
[13:21:03.897]             }
[13:21:03.897]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:03.897]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:03.897]         }
[13:21:03.897]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:03.897]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:03.897]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:03.897]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:03.897]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:03.897]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:03.897]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:03.897]             base::names(...future.oldOptions))
[13:21:03.897]     }
[13:21:03.897]     if (FALSE) {
[13:21:03.897]     }
[13:21:03.897]     else {
[13:21:03.897]         if (TRUE) {
[13:21:03.897]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:03.897]                 open = "w")
[13:21:03.897]         }
[13:21:03.897]         else {
[13:21:03.897]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:03.897]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:03.897]         }
[13:21:03.897]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:03.897]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:03.897]             base::sink(type = "output", split = FALSE)
[13:21:03.897]             base::close(...future.stdout)
[13:21:03.897]         }, add = TRUE)
[13:21:03.897]     }
[13:21:03.897]     ...future.frame <- base::sys.nframe()
[13:21:03.897]     ...future.conditions <- base::list()
[13:21:03.897]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:03.897]     if (FALSE) {
[13:21:03.897]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:03.897]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:03.897]     }
[13:21:03.897]     ...future.result <- base::tryCatch({
[13:21:03.897]         base::withCallingHandlers({
[13:21:03.897]             ...future.value <- base::withVisible(base::local({
[13:21:03.897]                 withCallingHandlers({
[13:21:03.897]                   {
[13:21:03.897]                     stop(structure(list(message = "boom"), class = c("MyError", 
[13:21:03.897]                       "error", "condition")))
[13:21:03.897]                   }
[13:21:03.897]                 }, immediateCondition = function(cond) {
[13:21:03.897]                   save_rds <- function (object, pathname, ...) 
[13:21:03.897]                   {
[13:21:03.897]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:03.897]                     if (file_test("-f", pathname_tmp)) {
[13:21:03.897]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.897]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:03.897]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.897]                         fi_tmp[["mtime"]])
[13:21:03.897]                     }
[13:21:03.897]                     tryCatch({
[13:21:03.897]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:03.897]                     }, error = function(ex) {
[13:21:03.897]                       msg <- conditionMessage(ex)
[13:21:03.897]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.897]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:03.897]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.897]                         fi_tmp[["mtime"]], msg)
[13:21:03.897]                       ex$message <- msg
[13:21:03.897]                       stop(ex)
[13:21:03.897]                     })
[13:21:03.897]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:03.897]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:03.897]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:03.897]                       fi_tmp <- file.info(pathname_tmp)
[13:21:03.897]                       fi <- file.info(pathname)
[13:21:03.897]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:03.897]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:03.897]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:03.897]                         fi[["size"]], fi[["mtime"]])
[13:21:03.897]                       stop(msg)
[13:21:03.897]                     }
[13:21:03.897]                     invisible(pathname)
[13:21:03.897]                   }
[13:21:03.897]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:03.897]                     rootPath = tempdir()) 
[13:21:03.897]                   {
[13:21:03.897]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:03.897]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:03.897]                       tmpdir = path, fileext = ".rds")
[13:21:03.897]                     save_rds(obj, file)
[13:21:03.897]                   }
[13:21:03.897]                   saveImmediateCondition(cond, path = "/tmp/Rtmpd6Ly3I/.future/immediateConditions")
[13:21:03.897]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.897]                   {
[13:21:03.897]                     inherits <- base::inherits
[13:21:03.897]                     invokeRestart <- base::invokeRestart
[13:21:03.897]                     is.null <- base::is.null
[13:21:03.897]                     muffled <- FALSE
[13:21:03.897]                     if (inherits(cond, "message")) {
[13:21:03.897]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:03.897]                       if (muffled) 
[13:21:03.897]                         invokeRestart("muffleMessage")
[13:21:03.897]                     }
[13:21:03.897]                     else if (inherits(cond, "warning")) {
[13:21:03.897]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:03.897]                       if (muffled) 
[13:21:03.897]                         invokeRestart("muffleWarning")
[13:21:03.897]                     }
[13:21:03.897]                     else if (inherits(cond, "condition")) {
[13:21:03.897]                       if (!is.null(pattern)) {
[13:21:03.897]                         computeRestarts <- base::computeRestarts
[13:21:03.897]                         grepl <- base::grepl
[13:21:03.897]                         restarts <- computeRestarts(cond)
[13:21:03.897]                         for (restart in restarts) {
[13:21:03.897]                           name <- restart$name
[13:21:03.897]                           if (is.null(name)) 
[13:21:03.897]                             next
[13:21:03.897]                           if (!grepl(pattern, name)) 
[13:21:03.897]                             next
[13:21:03.897]                           invokeRestart(restart)
[13:21:03.897]                           muffled <- TRUE
[13:21:03.897]                           break
[13:21:03.897]                         }
[13:21:03.897]                       }
[13:21:03.897]                     }
[13:21:03.897]                     invisible(muffled)
[13:21:03.897]                   }
[13:21:03.897]                   muffleCondition(cond)
[13:21:03.897]                 })
[13:21:03.897]             }))
[13:21:03.897]             future::FutureResult(value = ...future.value$value, 
[13:21:03.897]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.897]                   ...future.rng), globalenv = if (FALSE) 
[13:21:03.897]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:03.897]                     ...future.globalenv.names))
[13:21:03.897]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:03.897]         }, condition = base::local({
[13:21:03.897]             c <- base::c
[13:21:03.897]             inherits <- base::inherits
[13:21:03.897]             invokeRestart <- base::invokeRestart
[13:21:03.897]             length <- base::length
[13:21:03.897]             list <- base::list
[13:21:03.897]             seq.int <- base::seq.int
[13:21:03.897]             signalCondition <- base::signalCondition
[13:21:03.897]             sys.calls <- base::sys.calls
[13:21:03.897]             `[[` <- base::`[[`
[13:21:03.897]             `+` <- base::`+`
[13:21:03.897]             `<<-` <- base::`<<-`
[13:21:03.897]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:03.897]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:03.897]                   3L)]
[13:21:03.897]             }
[13:21:03.897]             function(cond) {
[13:21:03.897]                 is_error <- inherits(cond, "error")
[13:21:03.897]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:03.897]                   NULL)
[13:21:03.897]                 if (is_error) {
[13:21:03.897]                   sessionInformation <- function() {
[13:21:03.897]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:03.897]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:03.897]                       search = base::search(), system = base::Sys.info())
[13:21:03.897]                   }
[13:21:03.897]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.897]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:03.897]                     cond$call), session = sessionInformation(), 
[13:21:03.897]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:03.897]                   signalCondition(cond)
[13:21:03.897]                 }
[13:21:03.897]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:03.897]                 "immediateCondition"))) {
[13:21:03.897]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:03.897]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.897]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:03.897]                   if (TRUE && !signal) {
[13:21:03.897]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.897]                     {
[13:21:03.897]                       inherits <- base::inherits
[13:21:03.897]                       invokeRestart <- base::invokeRestart
[13:21:03.897]                       is.null <- base::is.null
[13:21:03.897]                       muffled <- FALSE
[13:21:03.897]                       if (inherits(cond, "message")) {
[13:21:03.897]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.897]                         if (muffled) 
[13:21:03.897]                           invokeRestart("muffleMessage")
[13:21:03.897]                       }
[13:21:03.897]                       else if (inherits(cond, "warning")) {
[13:21:03.897]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.897]                         if (muffled) 
[13:21:03.897]                           invokeRestart("muffleWarning")
[13:21:03.897]                       }
[13:21:03.897]                       else if (inherits(cond, "condition")) {
[13:21:03.897]                         if (!is.null(pattern)) {
[13:21:03.897]                           computeRestarts <- base::computeRestarts
[13:21:03.897]                           grepl <- base::grepl
[13:21:03.897]                           restarts <- computeRestarts(cond)
[13:21:03.897]                           for (restart in restarts) {
[13:21:03.897]                             name <- restart$name
[13:21:03.897]                             if (is.null(name)) 
[13:21:03.897]                               next
[13:21:03.897]                             if (!grepl(pattern, name)) 
[13:21:03.897]                               next
[13:21:03.897]                             invokeRestart(restart)
[13:21:03.897]                             muffled <- TRUE
[13:21:03.897]                             break
[13:21:03.897]                           }
[13:21:03.897]                         }
[13:21:03.897]                       }
[13:21:03.897]                       invisible(muffled)
[13:21:03.897]                     }
[13:21:03.897]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.897]                   }
[13:21:03.897]                 }
[13:21:03.897]                 else {
[13:21:03.897]                   if (TRUE) {
[13:21:03.897]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.897]                     {
[13:21:03.897]                       inherits <- base::inherits
[13:21:03.897]                       invokeRestart <- base::invokeRestart
[13:21:03.897]                       is.null <- base::is.null
[13:21:03.897]                       muffled <- FALSE
[13:21:03.897]                       if (inherits(cond, "message")) {
[13:21:03.897]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.897]                         if (muffled) 
[13:21:03.897]                           invokeRestart("muffleMessage")
[13:21:03.897]                       }
[13:21:03.897]                       else if (inherits(cond, "warning")) {
[13:21:03.897]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.897]                         if (muffled) 
[13:21:03.897]                           invokeRestart("muffleWarning")
[13:21:03.897]                       }
[13:21:03.897]                       else if (inherits(cond, "condition")) {
[13:21:03.897]                         if (!is.null(pattern)) {
[13:21:03.897]                           computeRestarts <- base::computeRestarts
[13:21:03.897]                           grepl <- base::grepl
[13:21:03.897]                           restarts <- computeRestarts(cond)
[13:21:03.897]                           for (restart in restarts) {
[13:21:03.897]                             name <- restart$name
[13:21:03.897]                             if (is.null(name)) 
[13:21:03.897]                               next
[13:21:03.897]                             if (!grepl(pattern, name)) 
[13:21:03.897]                               next
[13:21:03.897]                             invokeRestart(restart)
[13:21:03.897]                             muffled <- TRUE
[13:21:03.897]                             break
[13:21:03.897]                           }
[13:21:03.897]                         }
[13:21:03.897]                       }
[13:21:03.897]                       invisible(muffled)
[13:21:03.897]                     }
[13:21:03.897]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.897]                   }
[13:21:03.897]                 }
[13:21:03.897]             }
[13:21:03.897]         }))
[13:21:03.897]     }, error = function(ex) {
[13:21:03.897]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:03.897]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.897]                 ...future.rng), started = ...future.startTime, 
[13:21:03.897]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:03.897]             version = "1.8"), class = "FutureResult")
[13:21:03.897]     }, finally = {
[13:21:03.897]         if (!identical(...future.workdir, getwd())) 
[13:21:03.897]             setwd(...future.workdir)
[13:21:03.897]         {
[13:21:03.897]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:03.897]                 ...future.oldOptions$nwarnings <- NULL
[13:21:03.897]             }
[13:21:03.897]             base::options(...future.oldOptions)
[13:21:03.897]             if (.Platform$OS.type == "windows") {
[13:21:03.897]                 old_names <- names(...future.oldEnvVars)
[13:21:03.897]                 envs <- base::Sys.getenv()
[13:21:03.897]                 names <- names(envs)
[13:21:03.897]                 common <- intersect(names, old_names)
[13:21:03.897]                 added <- setdiff(names, old_names)
[13:21:03.897]                 removed <- setdiff(old_names, names)
[13:21:03.897]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:03.897]                   envs[common]]
[13:21:03.897]                 NAMES <- toupper(changed)
[13:21:03.897]                 args <- list()
[13:21:03.897]                 for (kk in seq_along(NAMES)) {
[13:21:03.897]                   name <- changed[[kk]]
[13:21:03.897]                   NAME <- NAMES[[kk]]
[13:21:03.897]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.897]                     next
[13:21:03.897]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.897]                 }
[13:21:03.897]                 NAMES <- toupper(added)
[13:21:03.897]                 for (kk in seq_along(NAMES)) {
[13:21:03.897]                   name <- added[[kk]]
[13:21:03.897]                   NAME <- NAMES[[kk]]
[13:21:03.897]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.897]                     next
[13:21:03.897]                   args[[name]] <- ""
[13:21:03.897]                 }
[13:21:03.897]                 NAMES <- toupper(removed)
[13:21:03.897]                 for (kk in seq_along(NAMES)) {
[13:21:03.897]                   name <- removed[[kk]]
[13:21:03.897]                   NAME <- NAMES[[kk]]
[13:21:03.897]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.897]                     next
[13:21:03.897]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.897]                 }
[13:21:03.897]                 if (length(args) > 0) 
[13:21:03.897]                   base::do.call(base::Sys.setenv, args = args)
[13:21:03.897]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:03.897]             }
[13:21:03.897]             else {
[13:21:03.897]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:03.897]             }
[13:21:03.897]             {
[13:21:03.897]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:03.897]                   0L) {
[13:21:03.897]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:03.897]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:03.897]                   base::options(opts)
[13:21:03.897]                 }
[13:21:03.897]                 {
[13:21:03.897]                   {
[13:21:03.897]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:03.897]                     NULL
[13:21:03.897]                   }
[13:21:03.897]                   options(future.plan = NULL)
[13:21:03.897]                   if (is.na(NA_character_)) 
[13:21:03.897]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.897]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:03.897]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:03.897]                     envir = parent.frame()) 
[13:21:03.897]                   {
[13:21:03.897]                     default_workers <- missing(workers)
[13:21:03.897]                     if (is.function(workers)) 
[13:21:03.897]                       workers <- workers()
[13:21:03.897]                     workers <- structure(as.integer(workers), 
[13:21:03.897]                       class = class(workers))
[13:21:03.897]                     stop_if_not(is.finite(workers), workers >= 
[13:21:03.897]                       1L)
[13:21:03.897]                     if ((workers == 1L && !inherits(workers, 
[13:21:03.897]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:03.897]                       if (default_workers) 
[13:21:03.897]                         supportsMulticore(warn = TRUE)
[13:21:03.897]                       return(sequential(..., envir = envir))
[13:21:03.897]                     }
[13:21:03.897]                     oopts <- options(mc.cores = workers)
[13:21:03.897]                     on.exit(options(oopts))
[13:21:03.897]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:03.897]                       envir = envir)
[13:21:03.897]                     if (!future$lazy) 
[13:21:03.897]                       future <- run(future)
[13:21:03.897]                     invisible(future)
[13:21:03.897]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:03.897]                 }
[13:21:03.897]             }
[13:21:03.897]         }
[13:21:03.897]     })
[13:21:03.897]     if (TRUE) {
[13:21:03.897]         base::sink(type = "output", split = FALSE)
[13:21:03.897]         if (TRUE) {
[13:21:03.897]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:03.897]         }
[13:21:03.897]         else {
[13:21:03.897]             ...future.result["stdout"] <- base::list(NULL)
[13:21:03.897]         }
[13:21:03.897]         base::close(...future.stdout)
[13:21:03.897]         ...future.stdout <- NULL
[13:21:03.897]     }
[13:21:03.897]     ...future.result$conditions <- ...future.conditions
[13:21:03.897]     ...future.result$finished <- base::Sys.time()
[13:21:03.897]     ...future.result
[13:21:03.897] }
[13:21:03.899] requestCore(): workers = 2
[13:21:03.901] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:03.902] plan(): Setting new future strategy stack:
[13:21:03.902] List of future strategies:
[13:21:03.902] 1. sequential:
[13:21:03.902]    - args: function (..., envir = parent.frame())
[13:21:03.902]    - tweaked: FALSE
[13:21:03.902]    - call: NULL
[13:21:03.903] plan(): nbrOfWorkers() = 1
[13:21:03.905] plan(): Setting new future strategy stack:
[13:21:03.905] List of future strategies:
[13:21:03.905] 1. multicore:
[13:21:03.905]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:03.905]    - tweaked: FALSE
[13:21:03.905]    - call: plan(multicore)
[13:21:03.911] plan(): nbrOfWorkers() = 2
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 32f7abe8-d290-272e-8911-a8ce072c31c3
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:03.915] signalConditions() ...
[13:21:03.915]  - include = ‘immediateCondition’
[13:21:03.916]  - exclude = 
[13:21:03.916]  - resignal = FALSE
[13:21:03.916]  - Number of conditions: 1
[13:21:03.916] signalConditions() ... done
[13:21:03.916] signalConditions() ...
[13:21:03.917]  - include = ‘immediateCondition’
[13:21:03.917]  - exclude = 
[13:21:03.917]  - resignal = FALSE
[13:21:03.917]  - Number of conditions: 1
[13:21:03.917] signalConditions() ... done
<MyError: boom>
[13:21:03.918] signalConditions() ...
[13:21:03.918]  - include = ‘immediateCondition’
[13:21:03.918]  - exclude = 
[13:21:03.918]  - resignal = FALSE
[13:21:03.918]  - Number of conditions: 1
[13:21:03.918] signalConditions() ... done
[13:21:03.918] Future state: ‘finished’
[13:21:03.919] signalConditions() ...
[13:21:03.919]  - include = ‘condition’
[13:21:03.919]  - exclude = ‘immediateCondition’
[13:21:03.919]  - resignal = TRUE
[13:21:03.919]  - Number of conditions: 1
[13:21:03.919]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[13:21:03.919] signalConditions() ... done
*** multicore(..., workers = 1L) ...
[13:21:03.920] getGlobalsAndPackages() ...
[13:21:03.920] Searching for globals...
[13:21:03.921] - globals found: [4] ‘{’, ‘*’, ‘a’, ‘b’
[13:21:03.921] Searching for globals ... DONE
[13:21:03.921] Resolving globals: FALSE
[13:21:03.922] The total size of the 2 globals is 112 bytes (112 bytes)
[13:21:03.922] The total size of the 2 globals exported for future expression (‘{; a * b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘b’ (56 bytes of class ‘numeric’)
[13:21:03.923] - globals: [2] ‘a’, ‘b’
[13:21:03.923] 
[13:21:03.923] getGlobalsAndPackages() ... DONE
[13:21:03.923] Packages needed by the future expression (n = 0): <none>
[13:21:03.923] Packages needed by future strategies (n = 0): <none>
[13:21:03.924] {
[13:21:03.924]     {
[13:21:03.924]         {
[13:21:03.924]             ...future.startTime <- base::Sys.time()
[13:21:03.924]             {
[13:21:03.924]                 {
[13:21:03.924]                   {
[13:21:03.924]                     base::local({
[13:21:03.924]                       has_future <- base::requireNamespace("future", 
[13:21:03.924]                         quietly = TRUE)
[13:21:03.924]                       if (has_future) {
[13:21:03.924]                         ns <- base::getNamespace("future")
[13:21:03.924]                         version <- ns[[".package"]][["version"]]
[13:21:03.924]                         if (is.null(version)) 
[13:21:03.924]                           version <- utils::packageVersion("future")
[13:21:03.924]                       }
[13:21:03.924]                       else {
[13:21:03.924]                         version <- NULL
[13:21:03.924]                       }
[13:21:03.924]                       if (!has_future || version < "1.8.0") {
[13:21:03.924]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:03.924]                           "", base::R.version$version.string), 
[13:21:03.924]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:03.924]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:03.924]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:03.924]                             "release", "version")], collapse = " "), 
[13:21:03.924]                           hostname = base::Sys.info()[["nodename"]])
[13:21:03.924]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:03.924]                           info)
[13:21:03.924]                         info <- base::paste(info, collapse = "; ")
[13:21:03.924]                         if (!has_future) {
[13:21:03.924]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:03.924]                             info)
[13:21:03.924]                         }
[13:21:03.924]                         else {
[13:21:03.924]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:03.924]                             info, version)
[13:21:03.924]                         }
[13:21:03.924]                         base::stop(msg)
[13:21:03.924]                       }
[13:21:03.924]                     })
[13:21:03.924]                   }
[13:21:03.924]                   options(future.plan = NULL)
[13:21:03.924]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.924]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:03.924]                 }
[13:21:03.924]                 ...future.workdir <- getwd()
[13:21:03.924]             }
[13:21:03.924]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:03.924]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:03.924]         }
[13:21:03.924]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:03.924]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:03.924]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:03.924]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:03.924]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:03.924]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:03.924]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:03.924]             base::names(...future.oldOptions))
[13:21:03.924]     }
[13:21:03.924]     if (FALSE) {
[13:21:03.924]     }
[13:21:03.924]     else {
[13:21:03.924]         if (TRUE) {
[13:21:03.924]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:03.924]                 open = "w")
[13:21:03.924]         }
[13:21:03.924]         else {
[13:21:03.924]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:03.924]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:03.924]         }
[13:21:03.924]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:03.924]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:03.924]             base::sink(type = "output", split = FALSE)
[13:21:03.924]             base::close(...future.stdout)
[13:21:03.924]         }, add = TRUE)
[13:21:03.924]     }
[13:21:03.924]     ...future.frame <- base::sys.nframe()
[13:21:03.924]     ...future.conditions <- base::list()
[13:21:03.924]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:03.924]     if (FALSE) {
[13:21:03.924]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:03.924]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:03.924]     }
[13:21:03.924]     ...future.result <- base::tryCatch({
[13:21:03.924]         base::withCallingHandlers({
[13:21:03.924]             ...future.value <- base::withVisible(base::local({
[13:21:03.924]                 a * b
[13:21:03.924]             }))
[13:21:03.924]             future::FutureResult(value = ...future.value$value, 
[13:21:03.924]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.924]                   ...future.rng), globalenv = if (FALSE) 
[13:21:03.924]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:03.924]                     ...future.globalenv.names))
[13:21:03.924]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:03.924]         }, condition = base::local({
[13:21:03.924]             c <- base::c
[13:21:03.924]             inherits <- base::inherits
[13:21:03.924]             invokeRestart <- base::invokeRestart
[13:21:03.924]             length <- base::length
[13:21:03.924]             list <- base::list
[13:21:03.924]             seq.int <- base::seq.int
[13:21:03.924]             signalCondition <- base::signalCondition
[13:21:03.924]             sys.calls <- base::sys.calls
[13:21:03.924]             `[[` <- base::`[[`
[13:21:03.924]             `+` <- base::`+`
[13:21:03.924]             `<<-` <- base::`<<-`
[13:21:03.924]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:03.924]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:03.924]                   3L)]
[13:21:03.924]             }
[13:21:03.924]             function(cond) {
[13:21:03.924]                 is_error <- inherits(cond, "error")
[13:21:03.924]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:03.924]                   NULL)
[13:21:03.924]                 if (is_error) {
[13:21:03.924]                   sessionInformation <- function() {
[13:21:03.924]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:03.924]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:03.924]                       search = base::search(), system = base::Sys.info())
[13:21:03.924]                   }
[13:21:03.924]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.924]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:03.924]                     cond$call), session = sessionInformation(), 
[13:21:03.924]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:03.924]                   signalCondition(cond)
[13:21:03.924]                 }
[13:21:03.924]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:03.924]                 "immediateCondition"))) {
[13:21:03.924]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:03.924]                   ...future.conditions[[length(...future.conditions) + 
[13:21:03.924]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:03.924]                   if (TRUE && !signal) {
[13:21:03.924]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.924]                     {
[13:21:03.924]                       inherits <- base::inherits
[13:21:03.924]                       invokeRestart <- base::invokeRestart
[13:21:03.924]                       is.null <- base::is.null
[13:21:03.924]                       muffled <- FALSE
[13:21:03.924]                       if (inherits(cond, "message")) {
[13:21:03.924]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.924]                         if (muffled) 
[13:21:03.924]                           invokeRestart("muffleMessage")
[13:21:03.924]                       }
[13:21:03.924]                       else if (inherits(cond, "warning")) {
[13:21:03.924]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.924]                         if (muffled) 
[13:21:03.924]                           invokeRestart("muffleWarning")
[13:21:03.924]                       }
[13:21:03.924]                       else if (inherits(cond, "condition")) {
[13:21:03.924]                         if (!is.null(pattern)) {
[13:21:03.924]                           computeRestarts <- base::computeRestarts
[13:21:03.924]                           grepl <- base::grepl
[13:21:03.924]                           restarts <- computeRestarts(cond)
[13:21:03.924]                           for (restart in restarts) {
[13:21:03.924]                             name <- restart$name
[13:21:03.924]                             if (is.null(name)) 
[13:21:03.924]                               next
[13:21:03.924]                             if (!grepl(pattern, name)) 
[13:21:03.924]                               next
[13:21:03.924]                             invokeRestart(restart)
[13:21:03.924]                             muffled <- TRUE
[13:21:03.924]                             break
[13:21:03.924]                           }
[13:21:03.924]                         }
[13:21:03.924]                       }
[13:21:03.924]                       invisible(muffled)
[13:21:03.924]                     }
[13:21:03.924]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.924]                   }
[13:21:03.924]                 }
[13:21:03.924]                 else {
[13:21:03.924]                   if (TRUE) {
[13:21:03.924]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:03.924]                     {
[13:21:03.924]                       inherits <- base::inherits
[13:21:03.924]                       invokeRestart <- base::invokeRestart
[13:21:03.924]                       is.null <- base::is.null
[13:21:03.924]                       muffled <- FALSE
[13:21:03.924]                       if (inherits(cond, "message")) {
[13:21:03.924]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:03.924]                         if (muffled) 
[13:21:03.924]                           invokeRestart("muffleMessage")
[13:21:03.924]                       }
[13:21:03.924]                       else if (inherits(cond, "warning")) {
[13:21:03.924]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:03.924]                         if (muffled) 
[13:21:03.924]                           invokeRestart("muffleWarning")
[13:21:03.924]                       }
[13:21:03.924]                       else if (inherits(cond, "condition")) {
[13:21:03.924]                         if (!is.null(pattern)) {
[13:21:03.924]                           computeRestarts <- base::computeRestarts
[13:21:03.924]                           grepl <- base::grepl
[13:21:03.924]                           restarts <- computeRestarts(cond)
[13:21:03.924]                           for (restart in restarts) {
[13:21:03.924]                             name <- restart$name
[13:21:03.924]                             if (is.null(name)) 
[13:21:03.924]                               next
[13:21:03.924]                             if (!grepl(pattern, name)) 
[13:21:03.924]                               next
[13:21:03.924]                             invokeRestart(restart)
[13:21:03.924]                             muffled <- TRUE
[13:21:03.924]                             break
[13:21:03.924]                           }
[13:21:03.924]                         }
[13:21:03.924]                       }
[13:21:03.924]                       invisible(muffled)
[13:21:03.924]                     }
[13:21:03.924]                     muffleCondition(cond, pattern = "^muffle")
[13:21:03.924]                   }
[13:21:03.924]                 }
[13:21:03.924]             }
[13:21:03.924]         }))
[13:21:03.924]     }, error = function(ex) {
[13:21:03.924]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:03.924]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:03.924]                 ...future.rng), started = ...future.startTime, 
[13:21:03.924]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:03.924]             version = "1.8"), class = "FutureResult")
[13:21:03.924]     }, finally = {
[13:21:03.924]         if (!identical(...future.workdir, getwd())) 
[13:21:03.924]             setwd(...future.workdir)
[13:21:03.924]         {
[13:21:03.924]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:03.924]                 ...future.oldOptions$nwarnings <- NULL
[13:21:03.924]             }
[13:21:03.924]             base::options(...future.oldOptions)
[13:21:03.924]             if (.Platform$OS.type == "windows") {
[13:21:03.924]                 old_names <- names(...future.oldEnvVars)
[13:21:03.924]                 envs <- base::Sys.getenv()
[13:21:03.924]                 names <- names(envs)
[13:21:03.924]                 common <- intersect(names, old_names)
[13:21:03.924]                 added <- setdiff(names, old_names)
[13:21:03.924]                 removed <- setdiff(old_names, names)
[13:21:03.924]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:03.924]                   envs[common]]
[13:21:03.924]                 NAMES <- toupper(changed)
[13:21:03.924]                 args <- list()
[13:21:03.924]                 for (kk in seq_along(NAMES)) {
[13:21:03.924]                   name <- changed[[kk]]
[13:21:03.924]                   NAME <- NAMES[[kk]]
[13:21:03.924]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.924]                     next
[13:21:03.924]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.924]                 }
[13:21:03.924]                 NAMES <- toupper(added)
[13:21:03.924]                 for (kk in seq_along(NAMES)) {
[13:21:03.924]                   name <- added[[kk]]
[13:21:03.924]                   NAME <- NAMES[[kk]]
[13:21:03.924]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.924]                     next
[13:21:03.924]                   args[[name]] <- ""
[13:21:03.924]                 }
[13:21:03.924]                 NAMES <- toupper(removed)
[13:21:03.924]                 for (kk in seq_along(NAMES)) {
[13:21:03.924]                   name <- removed[[kk]]
[13:21:03.924]                   NAME <- NAMES[[kk]]
[13:21:03.924]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:03.924]                     next
[13:21:03.924]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:03.924]                 }
[13:21:03.924]                 if (length(args) > 0) 
[13:21:03.924]                   base::do.call(base::Sys.setenv, args = args)
[13:21:03.924]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:03.924]             }
[13:21:03.924]             else {
[13:21:03.924]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:03.924]             }
[13:21:03.924]             {
[13:21:03.924]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:03.924]                   0L) {
[13:21:03.924]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:03.924]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:03.924]                   base::options(opts)
[13:21:03.924]                 }
[13:21:03.924]                 {
[13:21:03.924]                   {
[13:21:03.924]                     NULL
[13:21:03.924]                     RNGkind("Mersenne-Twister")
[13:21:03.924]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:03.924]                       inherits = FALSE)
[13:21:03.924]                   }
[13:21:03.924]                   options(future.plan = NULL)
[13:21:03.924]                   if (is.na(NA_character_)) 
[13:21:03.924]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:03.924]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:03.924]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:03.924]                     envir = parent.frame()) 
[13:21:03.924]                   {
[13:21:03.924]                     default_workers <- missing(workers)
[13:21:03.924]                     if (is.function(workers)) 
[13:21:03.924]                       workers <- workers()
[13:21:03.924]                     workers <- structure(as.integer(workers), 
[13:21:03.924]                       class = class(workers))
[13:21:03.924]                     stop_if_not(is.finite(workers), workers >= 
[13:21:03.924]                       1L)
[13:21:03.924]                     if ((workers == 1L && !inherits(workers, 
[13:21:03.924]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:03.924]                       if (default_workers) 
[13:21:03.924]                         supportsMulticore(warn = TRUE)
[13:21:03.924]                       return(sequential(..., envir = envir))
[13:21:03.924]                     }
[13:21:03.924]                     oopts <- options(mc.cores = workers)
[13:21:03.924]                     on.exit(options(oopts))
[13:21:03.924]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:03.924]                       envir = envir)
[13:21:03.924]                     if (!future$lazy) 
[13:21:03.924]                       future <- run(future)
[13:21:03.924]                     invisible(future)
[13:21:03.924]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:03.924]                 }
[13:21:03.924]             }
[13:21:03.924]         }
[13:21:03.924]     })
[13:21:03.924]     if (TRUE) {
[13:21:03.924]         base::sink(type = "output", split = FALSE)
[13:21:03.924]         if (TRUE) {
[13:21:03.924]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:03.924]         }
[13:21:03.924]         else {
[13:21:03.924]             ...future.result["stdout"] <- base::list(NULL)
[13:21:03.924]         }
[13:21:03.924]         base::close(...future.stdout)
[13:21:03.924]         ...future.stdout <- NULL
[13:21:03.924]     }
[13:21:03.924]     ...future.result$conditions <- ...future.conditions
[13:21:03.924]     ...future.result$finished <- base::Sys.time()
[13:21:03.924]     ...future.result
[13:21:03.924] }
[13:21:03.926] assign_globals() ...
[13:21:03.926] List of 2
[13:21:03.926]  $ a: num 2
[13:21:03.926]  $ b: num 3
[13:21:03.926]  - attr(*, "where")=List of 2
[13:21:03.926]   ..$ a:<environment: R_EmptyEnv> 
[13:21:03.926]   ..$ b:<environment: R_EmptyEnv> 
[13:21:03.926]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:03.926]  - attr(*, "resolved")= logi FALSE
[13:21:03.926]  - attr(*, "total_size")= num 112
[13:21:03.930] - copied ‘a’ to environment
[13:21:03.930] - copied ‘b’ to environment
[13:21:03.930] assign_globals() ... done
[13:21:03.930] plan(): Setting new future strategy stack:
[13:21:03.930] List of future strategies:
[13:21:03.930] 1. sequential:
[13:21:03.930]    - args: function (..., envir = parent.frame())
[13:21:03.930]    - tweaked: FALSE
[13:21:03.930]    - call: NULL
[13:21:03.931] plan(): nbrOfWorkers() = 1
[13:21:03.934] plan(): Setting new future strategy stack:
[13:21:03.934] List of future strategies:
[13:21:03.934] 1. multicore:
[13:21:03.934]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:03.934]    - tweaked: FALSE
[13:21:03.934]    - call: plan(multicore)
[13:21:03.939] plan(): nbrOfWorkers() = 2
[13:21:03.939] SequentialFuture started (and completed)
[1] 6
*** multicore(..., workers = 1L) ... DONE
Testing with 2 cores ... DONE
> 
> message("*** multicore() ... DONE")
*** multicore() ... DONE
> 
> source("incl/end.R")
[13:21:03.940] plan(): Setting new future strategy stack:
[13:21:03.940] List of future strategies:
[13:21:03.940] 1. FutureStrategy:
[13:21:03.940]    - args: function (..., envir = parent.frame())
[13:21:03.940]    - tweaked: FALSE
[13:21:03.940]    - call: future::plan(oplan)
[13:21:03.941] plan(): nbrOfWorkers() = 1
> 
