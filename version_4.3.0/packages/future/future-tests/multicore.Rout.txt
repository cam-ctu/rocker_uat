
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[16:13:03.969] plan(): Setting new future strategy stack:
[16:13:03.970] List of future strategies:
[16:13:03.970] 1. sequential:
[16:13:03.970]    - args: function (..., envir = parent.frame())
[16:13:03.970]    - tweaked: FALSE
[16:13:03.970]    - call: future::plan("sequential")
[16:13:03.982] plan(): nbrOfWorkers() = 1
> library("listenv")
> plan(multicore)
[16:13:03.994] plan(): Setting new future strategy stack:
[16:13:03.995] List of future strategies:
[16:13:03.995] 1. multicore:
[16:13:03.995]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:03.995]    - tweaked: FALSE
[16:13:03.995]    - call: plan(multicore)
[16:13:04.009] plan(): nbrOfWorkers() = 2
> 
> message("*** multicore() ...")
*** multicore() ...
> 
> for (cores in 1:min(2L, availableCores("multicore"))) {
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   if (!supportsMulticore()) {
+     message(sprintf("Multicore futures are not supporting on '%s'. Falling back to use synchronous sequential futures", .Platform$OS.type))
+   }
+ 
+   nworkers <- nbrOfWorkers()
+   message("Number of workers: ", nworkers)
+   stopifnot(nworkers == cores)
+   
+   for (globals in c(FALSE, TRUE)) {
+ 
+     message(sprintf("*** multicore(..., globals = %s) without globals", globals))
+   
+     f <- multicore({
+       42L
+     }, globals = globals)
+     stopifnot(inherits(f, "MulticoreFuture") || ((cores ==1 || !supportsMulticore()) && inherits(f, "SequentialFuture")))
+   
+     print(resolved(f))
+     y <- value(f)
+     print(y)
+     stopifnot(y == 42L)
+   
+   
+     message(sprintf("*** multicore(..., globals = %s) with globals", globals))
+     ## A global variable
+     a <- 0
+     f <- multicore({
+       b <- 3
+       c <- 2
+       a * b * c
+     }, globals = globals)
+     print(f)
+   
+   
+     ## A multicore future is evaluated in a separated
+     ## forked process.  Changing the value of a global
+     ## variable should not affect the result of the
+     ## future.
+     a <- 7  ## Make sure globals are frozen
+     v <- value(f)
+     print(v)
+     stopifnot(v == 0)
+   
+   
+     message(sprintf("*** multicore(..., globals = %s) with globals and blocking", globals))
+     x <- listenv()
+     for (ii in 1:4) {
+       message(sprintf(" - Creating multicore future #%d ...", ii))
+       x[[ii]] <- multicore({ ii }, globals = globals)
+     }
+     message(sprintf(" - Resolving %d multicore futures", length(x)))
+     v <- sapply(x, FUN = value)
+     stopifnot(all(v == 1:4))
+   
+   
+     message(sprintf("*** multicore(..., globals = %s) and errors", globals))
+     f <- multicore({
+       stop("Whoops!")
+       1
+     }, globals = globals)
+     print(f)
+     v <- value(f, signal = FALSE)
+     print(v)
+     stopifnot(inherits(v, "simpleError"))
+   
+     res <- try(value(f), silent = TRUE)
+     print(res)
+     stopifnot(inherits(res, "try-error"))
+   
+     ## Error is repeated
+     res <- try(value(f), silent = TRUE)
+     print(res)
+     stopifnot(inherits(res, "try-error"))
+ 
+     ## Custom error class
+     f <- multicore({
+       stop(structure(list(message = "boom"),
+                      class = c("MyError", "error", "condition")))
+     })
+     print(f)
+     v <- value(f, signal = FALSE)
+     print(v)
+     stopifnot(inherits(v, "error"), inherits(v, "MyError"))
+   
+     ## Make sure error is signaled
+     res <- tryCatch(value(f), error = identity)
+     stopifnot(inherits(res, "error"))
+   
+     ## Issue #200: Custom condition class attributes are lost 
+     stopifnot(inherits(res, "MyError"))    
+   } # for (globals ...)
+ 
+ 
+   message("*** multicore(..., workers = 1L) ...")
+ 
+   a <- 2
+   b <- 3
+   yTruth <- a * b
+ 
+   f <- multicore({ a * b }, globals = TRUE, workers = 1L)
+   rm(list = c("a", "b"))
+ 
+   v <- value(f)
+   print(v)
+   stopifnot(v == yTruth)
+ 
+   message("*** multicore(..., workers = 1L) ... DONE")
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
Number of workers: 1
*** multicore(..., globals = FALSE) without globals
[16:13:04.065] getGlobalsAndPackages() ...
[16:13:04.066] Not searching for globals
[16:13:04.066] - globals: [0] <none>
[16:13:04.066] getGlobalsAndPackages() ... DONE
[16:13:04.068] Packages needed by the future expression (n = 0): <none>
[16:13:04.068] Packages needed by future strategies (n = 0): <none>
[16:13:04.069] {
[16:13:04.069]     {
[16:13:04.069]         {
[16:13:04.069]             ...future.startTime <- base::Sys.time()
[16:13:04.069]             {
[16:13:04.069]                 {
[16:13:04.069]                   {
[16:13:04.069]                     base::local({
[16:13:04.069]                       has_future <- base::requireNamespace("future", 
[16:13:04.069]                         quietly = TRUE)
[16:13:04.069]                       if (has_future) {
[16:13:04.069]                         ns <- base::getNamespace("future")
[16:13:04.069]                         version <- ns[[".package"]][["version"]]
[16:13:04.069]                         if (is.null(version)) 
[16:13:04.069]                           version <- utils::packageVersion("future")
[16:13:04.069]                       }
[16:13:04.069]                       else {
[16:13:04.069]                         version <- NULL
[16:13:04.069]                       }
[16:13:04.069]                       if (!has_future || version < "1.8.0") {
[16:13:04.069]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:04.069]                           "", base::R.version$version.string), 
[16:13:04.069]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:04.069]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:04.069]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:04.069]                             "release", "version")], collapse = " "), 
[16:13:04.069]                           hostname = base::Sys.info()[["nodename"]])
[16:13:04.069]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:04.069]                           info)
[16:13:04.069]                         info <- base::paste(info, collapse = "; ")
[16:13:04.069]                         if (!has_future) {
[16:13:04.069]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:04.069]                             info)
[16:13:04.069]                         }
[16:13:04.069]                         else {
[16:13:04.069]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:04.069]                             info, version)
[16:13:04.069]                         }
[16:13:04.069]                         base::stop(msg)
[16:13:04.069]                       }
[16:13:04.069]                     })
[16:13:04.069]                   }
[16:13:04.069]                   options(future.plan = NULL)
[16:13:04.069]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.069]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:04.069]                 }
[16:13:04.069]                 ...future.workdir <- getwd()
[16:13:04.069]             }
[16:13:04.069]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:04.069]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:04.069]         }
[16:13:04.069]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:04.069]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:04.069]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:04.069]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:04.069]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:04.069]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:04.069]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:04.069]             base::names(...future.oldOptions))
[16:13:04.069]     }
[16:13:04.069]     if (FALSE) {
[16:13:04.069]     }
[16:13:04.069]     else {
[16:13:04.069]         if (TRUE) {
[16:13:04.069]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:04.069]                 open = "w")
[16:13:04.069]         }
[16:13:04.069]         else {
[16:13:04.069]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:04.069]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:04.069]         }
[16:13:04.069]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:04.069]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:04.069]             base::sink(type = "output", split = FALSE)
[16:13:04.069]             base::close(...future.stdout)
[16:13:04.069]         }, add = TRUE)
[16:13:04.069]     }
[16:13:04.069]     ...future.frame <- base::sys.nframe()
[16:13:04.069]     ...future.conditions <- base::list()
[16:13:04.069]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:04.069]     if (FALSE) {
[16:13:04.069]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:04.069]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:04.069]     }
[16:13:04.069]     ...future.result <- base::tryCatch({
[16:13:04.069]         base::withCallingHandlers({
[16:13:04.069]             ...future.value <- base::withVisible(base::local({
[16:13:04.069]                 42L
[16:13:04.069]             }))
[16:13:04.069]             future::FutureResult(value = ...future.value$value, 
[16:13:04.069]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.069]                   ...future.rng), globalenv = if (FALSE) 
[16:13:04.069]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:04.069]                     ...future.globalenv.names))
[16:13:04.069]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:04.069]         }, condition = base::local({
[16:13:04.069]             c <- base::c
[16:13:04.069]             inherits <- base::inherits
[16:13:04.069]             invokeRestart <- base::invokeRestart
[16:13:04.069]             length <- base::length
[16:13:04.069]             list <- base::list
[16:13:04.069]             seq.int <- base::seq.int
[16:13:04.069]             signalCondition <- base::signalCondition
[16:13:04.069]             sys.calls <- base::sys.calls
[16:13:04.069]             `[[` <- base::`[[`
[16:13:04.069]             `+` <- base::`+`
[16:13:04.069]             `<<-` <- base::`<<-`
[16:13:04.069]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:04.069]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:04.069]                   3L)]
[16:13:04.069]             }
[16:13:04.069]             function(cond) {
[16:13:04.069]                 is_error <- inherits(cond, "error")
[16:13:04.069]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:04.069]                   NULL)
[16:13:04.069]                 if (is_error) {
[16:13:04.069]                   sessionInformation <- function() {
[16:13:04.069]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:04.069]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:04.069]                       search = base::search(), system = base::Sys.info())
[16:13:04.069]                   }
[16:13:04.069]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.069]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:04.069]                     cond$call), session = sessionInformation(), 
[16:13:04.069]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:04.069]                   signalCondition(cond)
[16:13:04.069]                 }
[16:13:04.069]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:04.069]                 "immediateCondition"))) {
[16:13:04.069]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:04.069]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.069]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:04.069]                   if (TRUE && !signal) {
[16:13:04.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.069]                     {
[16:13:04.069]                       inherits <- base::inherits
[16:13:04.069]                       invokeRestart <- base::invokeRestart
[16:13:04.069]                       is.null <- base::is.null
[16:13:04.069]                       muffled <- FALSE
[16:13:04.069]                       if (inherits(cond, "message")) {
[16:13:04.069]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.069]                         if (muffled) 
[16:13:04.069]                           invokeRestart("muffleMessage")
[16:13:04.069]                       }
[16:13:04.069]                       else if (inherits(cond, "warning")) {
[16:13:04.069]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.069]                         if (muffled) 
[16:13:04.069]                           invokeRestart("muffleWarning")
[16:13:04.069]                       }
[16:13:04.069]                       else if (inherits(cond, "condition")) {
[16:13:04.069]                         if (!is.null(pattern)) {
[16:13:04.069]                           computeRestarts <- base::computeRestarts
[16:13:04.069]                           grepl <- base::grepl
[16:13:04.069]                           restarts <- computeRestarts(cond)
[16:13:04.069]                           for (restart in restarts) {
[16:13:04.069]                             name <- restart$name
[16:13:04.069]                             if (is.null(name)) 
[16:13:04.069]                               next
[16:13:04.069]                             if (!grepl(pattern, name)) 
[16:13:04.069]                               next
[16:13:04.069]                             invokeRestart(restart)
[16:13:04.069]                             muffled <- TRUE
[16:13:04.069]                             break
[16:13:04.069]                           }
[16:13:04.069]                         }
[16:13:04.069]                       }
[16:13:04.069]                       invisible(muffled)
[16:13:04.069]                     }
[16:13:04.069]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.069]                   }
[16:13:04.069]                 }
[16:13:04.069]                 else {
[16:13:04.069]                   if (TRUE) {
[16:13:04.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.069]                     {
[16:13:04.069]                       inherits <- base::inherits
[16:13:04.069]                       invokeRestart <- base::invokeRestart
[16:13:04.069]                       is.null <- base::is.null
[16:13:04.069]                       muffled <- FALSE
[16:13:04.069]                       if (inherits(cond, "message")) {
[16:13:04.069]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.069]                         if (muffled) 
[16:13:04.069]                           invokeRestart("muffleMessage")
[16:13:04.069]                       }
[16:13:04.069]                       else if (inherits(cond, "warning")) {
[16:13:04.069]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.069]                         if (muffled) 
[16:13:04.069]                           invokeRestart("muffleWarning")
[16:13:04.069]                       }
[16:13:04.069]                       else if (inherits(cond, "condition")) {
[16:13:04.069]                         if (!is.null(pattern)) {
[16:13:04.069]                           computeRestarts <- base::computeRestarts
[16:13:04.069]                           grepl <- base::grepl
[16:13:04.069]                           restarts <- computeRestarts(cond)
[16:13:04.069]                           for (restart in restarts) {
[16:13:04.069]                             name <- restart$name
[16:13:04.069]                             if (is.null(name)) 
[16:13:04.069]                               next
[16:13:04.069]                             if (!grepl(pattern, name)) 
[16:13:04.069]                               next
[16:13:04.069]                             invokeRestart(restart)
[16:13:04.069]                             muffled <- TRUE
[16:13:04.069]                             break
[16:13:04.069]                           }
[16:13:04.069]                         }
[16:13:04.069]                       }
[16:13:04.069]                       invisible(muffled)
[16:13:04.069]                     }
[16:13:04.069]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.069]                   }
[16:13:04.069]                 }
[16:13:04.069]             }
[16:13:04.069]         }))
[16:13:04.069]     }, error = function(ex) {
[16:13:04.069]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:04.069]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.069]                 ...future.rng), started = ...future.startTime, 
[16:13:04.069]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:04.069]             version = "1.8"), class = "FutureResult")
[16:13:04.069]     }, finally = {
[16:13:04.069]         if (!identical(...future.workdir, getwd())) 
[16:13:04.069]             setwd(...future.workdir)
[16:13:04.069]         {
[16:13:04.069]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:04.069]                 ...future.oldOptions$nwarnings <- NULL
[16:13:04.069]             }
[16:13:04.069]             base::options(...future.oldOptions)
[16:13:04.069]             if (.Platform$OS.type == "windows") {
[16:13:04.069]                 old_names <- names(...future.oldEnvVars)
[16:13:04.069]                 envs <- base::Sys.getenv()
[16:13:04.069]                 names <- names(envs)
[16:13:04.069]                 common <- intersect(names, old_names)
[16:13:04.069]                 added <- setdiff(names, old_names)
[16:13:04.069]                 removed <- setdiff(old_names, names)
[16:13:04.069]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:04.069]                   envs[common]]
[16:13:04.069]                 NAMES <- toupper(changed)
[16:13:04.069]                 args <- list()
[16:13:04.069]                 for (kk in seq_along(NAMES)) {
[16:13:04.069]                   name <- changed[[kk]]
[16:13:04.069]                   NAME <- NAMES[[kk]]
[16:13:04.069]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.069]                     next
[16:13:04.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.069]                 }
[16:13:04.069]                 NAMES <- toupper(added)
[16:13:04.069]                 for (kk in seq_along(NAMES)) {
[16:13:04.069]                   name <- added[[kk]]
[16:13:04.069]                   NAME <- NAMES[[kk]]
[16:13:04.069]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.069]                     next
[16:13:04.069]                   args[[name]] <- ""
[16:13:04.069]                 }
[16:13:04.069]                 NAMES <- toupper(removed)
[16:13:04.069]                 for (kk in seq_along(NAMES)) {
[16:13:04.069]                   name <- removed[[kk]]
[16:13:04.069]                   NAME <- NAMES[[kk]]
[16:13:04.069]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.069]                     next
[16:13:04.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.069]                 }
[16:13:04.069]                 if (length(args) > 0) 
[16:13:04.069]                   base::do.call(base::Sys.setenv, args = args)
[16:13:04.069]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:04.069]             }
[16:13:04.069]             else {
[16:13:04.069]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:04.069]             }
[16:13:04.069]             {
[16:13:04.069]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:04.069]                   0L) {
[16:13:04.069]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:04.069]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:04.069]                   base::options(opts)
[16:13:04.069]                 }
[16:13:04.069]                 {
[16:13:04.069]                   {
[16:13:04.069]                     NULL
[16:13:04.069]                     RNGkind("Mersenne-Twister")
[16:13:04.069]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:04.069]                       inherits = FALSE)
[16:13:04.069]                   }
[16:13:04.069]                   options(future.plan = NULL)
[16:13:04.069]                   if (is.na(NA_character_)) 
[16:13:04.069]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.069]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:04.069]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:04.069]                     envir = parent.frame()) 
[16:13:04.069]                   {
[16:13:04.069]                     default_workers <- missing(workers)
[16:13:04.069]                     if (is.function(workers)) 
[16:13:04.069]                       workers <- workers()
[16:13:04.069]                     workers <- structure(as.integer(workers), 
[16:13:04.069]                       class = class(workers))
[16:13:04.069]                     stop_if_not(is.finite(workers), workers >= 
[16:13:04.069]                       1L)
[16:13:04.069]                     if ((workers == 1L && !inherits(workers, 
[16:13:04.069]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:04.069]                       if (default_workers) 
[16:13:04.069]                         supportsMulticore(warn = TRUE)
[16:13:04.069]                       return(sequential(..., envir = envir))
[16:13:04.069]                     }
[16:13:04.069]                     oopts <- options(mc.cores = workers)
[16:13:04.069]                     on.exit(options(oopts))
[16:13:04.069]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:04.069]                       envir = envir)
[16:13:04.069]                     if (!future$lazy) 
[16:13:04.069]                       future <- run(future)
[16:13:04.069]                     invisible(future)
[16:13:04.069]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:04.069]                 }
[16:13:04.069]             }
[16:13:04.069]         }
[16:13:04.069]     })
[16:13:04.069]     if (TRUE) {
[16:13:04.069]         base::sink(type = "output", split = FALSE)
[16:13:04.069]         if (TRUE) {
[16:13:04.069]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:04.069]         }
[16:13:04.069]         else {
[16:13:04.069]             ...future.result["stdout"] <- base::list(NULL)
[16:13:04.069]         }
[16:13:04.069]         base::close(...future.stdout)
[16:13:04.069]         ...future.stdout <- NULL
[16:13:04.069]     }
[16:13:04.069]     ...future.result$conditions <- ...future.conditions
[16:13:04.069]     ...future.result$finished <- base::Sys.time()
[16:13:04.069]     ...future.result
[16:13:04.069] }
[16:13:04.071] plan(): Setting new future strategy stack:
[16:13:04.071] List of future strategies:
[16:13:04.071] 1. sequential:
[16:13:04.071]    - args: function (..., envir = parent.frame())
[16:13:04.071]    - tweaked: FALSE
[16:13:04.071]    - call: NULL
[16:13:04.072] plan(): nbrOfWorkers() = 1
[16:13:04.073] plan(): Setting new future strategy stack:
[16:13:04.073] List of future strategies:
[16:13:04.073] 1. multicore:
[16:13:04.073]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:04.073]    - tweaked: FALSE
[16:13:04.073]    - call: plan(multicore)
[16:13:04.076] plan(): nbrOfWorkers() = 1
[16:13:04.077] SequentialFuture started (and completed)
[16:13:04.077] resolved() for ‘SequentialFuture’ ...
[16:13:04.078] - state: ‘finished’
[16:13:04.078] - run: TRUE
[16:13:04.078] - result: ‘FutureResult’
[16:13:04.078] resolved() for ‘SequentialFuture’ ... done
[1] TRUE
[1] 42
*** multicore(..., globals = FALSE) with globals
[16:13:04.081] getGlobalsAndPackages() ...
[16:13:04.082] Not searching for globals
[16:13:04.082] - globals: [0] <none>
[16:13:04.082] getGlobalsAndPackages() ... DONE
[16:13:04.082] Packages needed by the future expression (n = 0): <none>
[16:13:04.082] Packages needed by future strategies (n = 0): <none>
[16:13:04.083] {
[16:13:04.083]     {
[16:13:04.083]         {
[16:13:04.083]             ...future.startTime <- base::Sys.time()
[16:13:04.083]             {
[16:13:04.083]                 {
[16:13:04.083]                   {
[16:13:04.083]                     base::local({
[16:13:04.083]                       has_future <- base::requireNamespace("future", 
[16:13:04.083]                         quietly = TRUE)
[16:13:04.083]                       if (has_future) {
[16:13:04.083]                         ns <- base::getNamespace("future")
[16:13:04.083]                         version <- ns[[".package"]][["version"]]
[16:13:04.083]                         if (is.null(version)) 
[16:13:04.083]                           version <- utils::packageVersion("future")
[16:13:04.083]                       }
[16:13:04.083]                       else {
[16:13:04.083]                         version <- NULL
[16:13:04.083]                       }
[16:13:04.083]                       if (!has_future || version < "1.8.0") {
[16:13:04.083]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:04.083]                           "", base::R.version$version.string), 
[16:13:04.083]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:04.083]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:04.083]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:04.083]                             "release", "version")], collapse = " "), 
[16:13:04.083]                           hostname = base::Sys.info()[["nodename"]])
[16:13:04.083]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:04.083]                           info)
[16:13:04.083]                         info <- base::paste(info, collapse = "; ")
[16:13:04.083]                         if (!has_future) {
[16:13:04.083]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:04.083]                             info)
[16:13:04.083]                         }
[16:13:04.083]                         else {
[16:13:04.083]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:04.083]                             info, version)
[16:13:04.083]                         }
[16:13:04.083]                         base::stop(msg)
[16:13:04.083]                       }
[16:13:04.083]                     })
[16:13:04.083]                   }
[16:13:04.083]                   options(future.plan = NULL)
[16:13:04.083]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.083]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:04.083]                 }
[16:13:04.083]                 ...future.workdir <- getwd()
[16:13:04.083]             }
[16:13:04.083]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:04.083]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:04.083]         }
[16:13:04.083]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:04.083]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:04.083]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:04.083]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:04.083]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:04.083]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:04.083]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:04.083]             base::names(...future.oldOptions))
[16:13:04.083]     }
[16:13:04.083]     if (FALSE) {
[16:13:04.083]     }
[16:13:04.083]     else {
[16:13:04.083]         if (TRUE) {
[16:13:04.083]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:04.083]                 open = "w")
[16:13:04.083]         }
[16:13:04.083]         else {
[16:13:04.083]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:04.083]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:04.083]         }
[16:13:04.083]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:04.083]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:04.083]             base::sink(type = "output", split = FALSE)
[16:13:04.083]             base::close(...future.stdout)
[16:13:04.083]         }, add = TRUE)
[16:13:04.083]     }
[16:13:04.083]     ...future.frame <- base::sys.nframe()
[16:13:04.083]     ...future.conditions <- base::list()
[16:13:04.083]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:04.083]     if (FALSE) {
[16:13:04.083]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:04.083]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:04.083]     }
[16:13:04.083]     ...future.result <- base::tryCatch({
[16:13:04.083]         base::withCallingHandlers({
[16:13:04.083]             ...future.value <- base::withVisible(base::local({
[16:13:04.083]                 b <- 3
[16:13:04.083]                 c <- 2
[16:13:04.083]                 a * b * c
[16:13:04.083]             }))
[16:13:04.083]             future::FutureResult(value = ...future.value$value, 
[16:13:04.083]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.083]                   ...future.rng), globalenv = if (FALSE) 
[16:13:04.083]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:04.083]                     ...future.globalenv.names))
[16:13:04.083]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:04.083]         }, condition = base::local({
[16:13:04.083]             c <- base::c
[16:13:04.083]             inherits <- base::inherits
[16:13:04.083]             invokeRestart <- base::invokeRestart
[16:13:04.083]             length <- base::length
[16:13:04.083]             list <- base::list
[16:13:04.083]             seq.int <- base::seq.int
[16:13:04.083]             signalCondition <- base::signalCondition
[16:13:04.083]             sys.calls <- base::sys.calls
[16:13:04.083]             `[[` <- base::`[[`
[16:13:04.083]             `+` <- base::`+`
[16:13:04.083]             `<<-` <- base::`<<-`
[16:13:04.083]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:04.083]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:04.083]                   3L)]
[16:13:04.083]             }
[16:13:04.083]             function(cond) {
[16:13:04.083]                 is_error <- inherits(cond, "error")
[16:13:04.083]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:04.083]                   NULL)
[16:13:04.083]                 if (is_error) {
[16:13:04.083]                   sessionInformation <- function() {
[16:13:04.083]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:04.083]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:04.083]                       search = base::search(), system = base::Sys.info())
[16:13:04.083]                   }
[16:13:04.083]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.083]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:04.083]                     cond$call), session = sessionInformation(), 
[16:13:04.083]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:04.083]                   signalCondition(cond)
[16:13:04.083]                 }
[16:13:04.083]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:04.083]                 "immediateCondition"))) {
[16:13:04.083]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:04.083]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.083]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:04.083]                   if (TRUE && !signal) {
[16:13:04.083]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.083]                     {
[16:13:04.083]                       inherits <- base::inherits
[16:13:04.083]                       invokeRestart <- base::invokeRestart
[16:13:04.083]                       is.null <- base::is.null
[16:13:04.083]                       muffled <- FALSE
[16:13:04.083]                       if (inherits(cond, "message")) {
[16:13:04.083]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.083]                         if (muffled) 
[16:13:04.083]                           invokeRestart("muffleMessage")
[16:13:04.083]                       }
[16:13:04.083]                       else if (inherits(cond, "warning")) {
[16:13:04.083]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.083]                         if (muffled) 
[16:13:04.083]                           invokeRestart("muffleWarning")
[16:13:04.083]                       }
[16:13:04.083]                       else if (inherits(cond, "condition")) {
[16:13:04.083]                         if (!is.null(pattern)) {
[16:13:04.083]                           computeRestarts <- base::computeRestarts
[16:13:04.083]                           grepl <- base::grepl
[16:13:04.083]                           restarts <- computeRestarts(cond)
[16:13:04.083]                           for (restart in restarts) {
[16:13:04.083]                             name <- restart$name
[16:13:04.083]                             if (is.null(name)) 
[16:13:04.083]                               next
[16:13:04.083]                             if (!grepl(pattern, name)) 
[16:13:04.083]                               next
[16:13:04.083]                             invokeRestart(restart)
[16:13:04.083]                             muffled <- TRUE
[16:13:04.083]                             break
[16:13:04.083]                           }
[16:13:04.083]                         }
[16:13:04.083]                       }
[16:13:04.083]                       invisible(muffled)
[16:13:04.083]                     }
[16:13:04.083]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.083]                   }
[16:13:04.083]                 }
[16:13:04.083]                 else {
[16:13:04.083]                   if (TRUE) {
[16:13:04.083]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.083]                     {
[16:13:04.083]                       inherits <- base::inherits
[16:13:04.083]                       invokeRestart <- base::invokeRestart
[16:13:04.083]                       is.null <- base::is.null
[16:13:04.083]                       muffled <- FALSE
[16:13:04.083]                       if (inherits(cond, "message")) {
[16:13:04.083]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.083]                         if (muffled) 
[16:13:04.083]                           invokeRestart("muffleMessage")
[16:13:04.083]                       }
[16:13:04.083]                       else if (inherits(cond, "warning")) {
[16:13:04.083]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.083]                         if (muffled) 
[16:13:04.083]                           invokeRestart("muffleWarning")
[16:13:04.083]                       }
[16:13:04.083]                       else if (inherits(cond, "condition")) {
[16:13:04.083]                         if (!is.null(pattern)) {
[16:13:04.083]                           computeRestarts <- base::computeRestarts
[16:13:04.083]                           grepl <- base::grepl
[16:13:04.083]                           restarts <- computeRestarts(cond)
[16:13:04.083]                           for (restart in restarts) {
[16:13:04.083]                             name <- restart$name
[16:13:04.083]                             if (is.null(name)) 
[16:13:04.083]                               next
[16:13:04.083]                             if (!grepl(pattern, name)) 
[16:13:04.083]                               next
[16:13:04.083]                             invokeRestart(restart)
[16:13:04.083]                             muffled <- TRUE
[16:13:04.083]                             break
[16:13:04.083]                           }
[16:13:04.083]                         }
[16:13:04.083]                       }
[16:13:04.083]                       invisible(muffled)
[16:13:04.083]                     }
[16:13:04.083]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.083]                   }
[16:13:04.083]                 }
[16:13:04.083]             }
[16:13:04.083]         }))
[16:13:04.083]     }, error = function(ex) {
[16:13:04.083]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:04.083]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.083]                 ...future.rng), started = ...future.startTime, 
[16:13:04.083]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:04.083]             version = "1.8"), class = "FutureResult")
[16:13:04.083]     }, finally = {
[16:13:04.083]         if (!identical(...future.workdir, getwd())) 
[16:13:04.083]             setwd(...future.workdir)
[16:13:04.083]         {
[16:13:04.083]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:04.083]                 ...future.oldOptions$nwarnings <- NULL
[16:13:04.083]             }
[16:13:04.083]             base::options(...future.oldOptions)
[16:13:04.083]             if (.Platform$OS.type == "windows") {
[16:13:04.083]                 old_names <- names(...future.oldEnvVars)
[16:13:04.083]                 envs <- base::Sys.getenv()
[16:13:04.083]                 names <- names(envs)
[16:13:04.083]                 common <- intersect(names, old_names)
[16:13:04.083]                 added <- setdiff(names, old_names)
[16:13:04.083]                 removed <- setdiff(old_names, names)
[16:13:04.083]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:04.083]                   envs[common]]
[16:13:04.083]                 NAMES <- toupper(changed)
[16:13:04.083]                 args <- list()
[16:13:04.083]                 for (kk in seq_along(NAMES)) {
[16:13:04.083]                   name <- changed[[kk]]
[16:13:04.083]                   NAME <- NAMES[[kk]]
[16:13:04.083]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.083]                     next
[16:13:04.083]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.083]                 }
[16:13:04.083]                 NAMES <- toupper(added)
[16:13:04.083]                 for (kk in seq_along(NAMES)) {
[16:13:04.083]                   name <- added[[kk]]
[16:13:04.083]                   NAME <- NAMES[[kk]]
[16:13:04.083]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.083]                     next
[16:13:04.083]                   args[[name]] <- ""
[16:13:04.083]                 }
[16:13:04.083]                 NAMES <- toupper(removed)
[16:13:04.083]                 for (kk in seq_along(NAMES)) {
[16:13:04.083]                   name <- removed[[kk]]
[16:13:04.083]                   NAME <- NAMES[[kk]]
[16:13:04.083]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.083]                     next
[16:13:04.083]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.083]                 }
[16:13:04.083]                 if (length(args) > 0) 
[16:13:04.083]                   base::do.call(base::Sys.setenv, args = args)
[16:13:04.083]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:04.083]             }
[16:13:04.083]             else {
[16:13:04.083]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:04.083]             }
[16:13:04.083]             {
[16:13:04.083]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:04.083]                   0L) {
[16:13:04.083]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:04.083]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:04.083]                   base::options(opts)
[16:13:04.083]                 }
[16:13:04.083]                 {
[16:13:04.083]                   {
[16:13:04.083]                     NULL
[16:13:04.083]                     RNGkind("Mersenne-Twister")
[16:13:04.083]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:04.083]                       inherits = FALSE)
[16:13:04.083]                   }
[16:13:04.083]                   options(future.plan = NULL)
[16:13:04.083]                   if (is.na(NA_character_)) 
[16:13:04.083]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.083]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:04.083]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:04.083]                     envir = parent.frame()) 
[16:13:04.083]                   {
[16:13:04.083]                     default_workers <- missing(workers)
[16:13:04.083]                     if (is.function(workers)) 
[16:13:04.083]                       workers <- workers()
[16:13:04.083]                     workers <- structure(as.integer(workers), 
[16:13:04.083]                       class = class(workers))
[16:13:04.083]                     stop_if_not(is.finite(workers), workers >= 
[16:13:04.083]                       1L)
[16:13:04.083]                     if ((workers == 1L && !inherits(workers, 
[16:13:04.083]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:04.083]                       if (default_workers) 
[16:13:04.083]                         supportsMulticore(warn = TRUE)
[16:13:04.083]                       return(sequential(..., envir = envir))
[16:13:04.083]                     }
[16:13:04.083]                     oopts <- options(mc.cores = workers)
[16:13:04.083]                     on.exit(options(oopts))
[16:13:04.083]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:04.083]                       envir = envir)
[16:13:04.083]                     if (!future$lazy) 
[16:13:04.083]                       future <- run(future)
[16:13:04.083]                     invisible(future)
[16:13:04.083]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:04.083]                 }
[16:13:04.083]             }
[16:13:04.083]         }
[16:13:04.083]     })
[16:13:04.083]     if (TRUE) {
[16:13:04.083]         base::sink(type = "output", split = FALSE)
[16:13:04.083]         if (TRUE) {
[16:13:04.083]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:04.083]         }
[16:13:04.083]         else {
[16:13:04.083]             ...future.result["stdout"] <- base::list(NULL)
[16:13:04.083]         }
[16:13:04.083]         base::close(...future.stdout)
[16:13:04.083]         ...future.stdout <- NULL
[16:13:04.083]     }
[16:13:04.083]     ...future.result$conditions <- ...future.conditions
[16:13:04.083]     ...future.result$finished <- base::Sys.time()
[16:13:04.083]     ...future.result
[16:13:04.083] }
[16:13:04.085] plan(): Setting new future strategy stack:
[16:13:04.085] List of future strategies:
[16:13:04.085] 1. sequential:
[16:13:04.085]    - args: function (..., envir = parent.frame())
[16:13:04.085]    - tweaked: FALSE
[16:13:04.085]    - call: NULL
[16:13:04.087] plan(): nbrOfWorkers() = 1
[16:13:04.088] plan(): Setting new future strategy stack:
[16:13:04.088] List of future strategies:
[16:13:04.088] 1. multicore:
[16:13:04.088]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:04.088]    - tweaked: FALSE
[16:13:04.088]    - call: plan(multicore)
[16:13:04.091] plan(): nbrOfWorkers() = 1
[16:13:04.091] SequentialFuture started (and completed)
SequentialFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 56 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: 9cd5072f-68f7-e4f0-6d65-cff53a745767
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[1] 0
*** multicore(..., globals = FALSE) with globals and blocking
 - Creating multicore future #1 ...
[16:13:04.096] getGlobalsAndPackages() ...
[16:13:04.096] Not searching for globals
[16:13:04.096] - globals: [0] <none>
[16:13:04.096] getGlobalsAndPackages() ... DONE
[16:13:04.097] Packages needed by the future expression (n = 0): <none>
[16:13:04.097] Packages needed by future strategies (n = 0): <none>
[16:13:04.097] {
[16:13:04.097]     {
[16:13:04.097]         {
[16:13:04.097]             ...future.startTime <- base::Sys.time()
[16:13:04.097]             {
[16:13:04.097]                 {
[16:13:04.097]                   {
[16:13:04.097]                     base::local({
[16:13:04.097]                       has_future <- base::requireNamespace("future", 
[16:13:04.097]                         quietly = TRUE)
[16:13:04.097]                       if (has_future) {
[16:13:04.097]                         ns <- base::getNamespace("future")
[16:13:04.097]                         version <- ns[[".package"]][["version"]]
[16:13:04.097]                         if (is.null(version)) 
[16:13:04.097]                           version <- utils::packageVersion("future")
[16:13:04.097]                       }
[16:13:04.097]                       else {
[16:13:04.097]                         version <- NULL
[16:13:04.097]                       }
[16:13:04.097]                       if (!has_future || version < "1.8.0") {
[16:13:04.097]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:04.097]                           "", base::R.version$version.string), 
[16:13:04.097]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:04.097]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:04.097]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:04.097]                             "release", "version")], collapse = " "), 
[16:13:04.097]                           hostname = base::Sys.info()[["nodename"]])
[16:13:04.097]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:04.097]                           info)
[16:13:04.097]                         info <- base::paste(info, collapse = "; ")
[16:13:04.097]                         if (!has_future) {
[16:13:04.097]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:04.097]                             info)
[16:13:04.097]                         }
[16:13:04.097]                         else {
[16:13:04.097]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:04.097]                             info, version)
[16:13:04.097]                         }
[16:13:04.097]                         base::stop(msg)
[16:13:04.097]                       }
[16:13:04.097]                     })
[16:13:04.097]                   }
[16:13:04.097]                   options(future.plan = NULL)
[16:13:04.097]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.097]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:04.097]                 }
[16:13:04.097]                 ...future.workdir <- getwd()
[16:13:04.097]             }
[16:13:04.097]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:04.097]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:04.097]         }
[16:13:04.097]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:04.097]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:04.097]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:04.097]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:04.097]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:04.097]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:04.097]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:04.097]             base::names(...future.oldOptions))
[16:13:04.097]     }
[16:13:04.097]     if (FALSE) {
[16:13:04.097]     }
[16:13:04.097]     else {
[16:13:04.097]         if (TRUE) {
[16:13:04.097]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:04.097]                 open = "w")
[16:13:04.097]         }
[16:13:04.097]         else {
[16:13:04.097]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:04.097]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:04.097]         }
[16:13:04.097]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:04.097]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:04.097]             base::sink(type = "output", split = FALSE)
[16:13:04.097]             base::close(...future.stdout)
[16:13:04.097]         }, add = TRUE)
[16:13:04.097]     }
[16:13:04.097]     ...future.frame <- base::sys.nframe()
[16:13:04.097]     ...future.conditions <- base::list()
[16:13:04.097]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:04.097]     if (FALSE) {
[16:13:04.097]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:04.097]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:04.097]     }
[16:13:04.097]     ...future.result <- base::tryCatch({
[16:13:04.097]         base::withCallingHandlers({
[16:13:04.097]             ...future.value <- base::withVisible(base::local({
[16:13:04.097]                 ii
[16:13:04.097]             }))
[16:13:04.097]             future::FutureResult(value = ...future.value$value, 
[16:13:04.097]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.097]                   ...future.rng), globalenv = if (FALSE) 
[16:13:04.097]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:04.097]                     ...future.globalenv.names))
[16:13:04.097]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:04.097]         }, condition = base::local({
[16:13:04.097]             c <- base::c
[16:13:04.097]             inherits <- base::inherits
[16:13:04.097]             invokeRestart <- base::invokeRestart
[16:13:04.097]             length <- base::length
[16:13:04.097]             list <- base::list
[16:13:04.097]             seq.int <- base::seq.int
[16:13:04.097]             signalCondition <- base::signalCondition
[16:13:04.097]             sys.calls <- base::sys.calls
[16:13:04.097]             `[[` <- base::`[[`
[16:13:04.097]             `+` <- base::`+`
[16:13:04.097]             `<<-` <- base::`<<-`
[16:13:04.097]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:04.097]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:04.097]                   3L)]
[16:13:04.097]             }
[16:13:04.097]             function(cond) {
[16:13:04.097]                 is_error <- inherits(cond, "error")
[16:13:04.097]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:04.097]                   NULL)
[16:13:04.097]                 if (is_error) {
[16:13:04.097]                   sessionInformation <- function() {
[16:13:04.097]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:04.097]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:04.097]                       search = base::search(), system = base::Sys.info())
[16:13:04.097]                   }
[16:13:04.097]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.097]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:04.097]                     cond$call), session = sessionInformation(), 
[16:13:04.097]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:04.097]                   signalCondition(cond)
[16:13:04.097]                 }
[16:13:04.097]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:04.097]                 "immediateCondition"))) {
[16:13:04.097]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:04.097]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.097]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:04.097]                   if (TRUE && !signal) {
[16:13:04.097]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.097]                     {
[16:13:04.097]                       inherits <- base::inherits
[16:13:04.097]                       invokeRestart <- base::invokeRestart
[16:13:04.097]                       is.null <- base::is.null
[16:13:04.097]                       muffled <- FALSE
[16:13:04.097]                       if (inherits(cond, "message")) {
[16:13:04.097]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.097]                         if (muffled) 
[16:13:04.097]                           invokeRestart("muffleMessage")
[16:13:04.097]                       }
[16:13:04.097]                       else if (inherits(cond, "warning")) {
[16:13:04.097]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.097]                         if (muffled) 
[16:13:04.097]                           invokeRestart("muffleWarning")
[16:13:04.097]                       }
[16:13:04.097]                       else if (inherits(cond, "condition")) {
[16:13:04.097]                         if (!is.null(pattern)) {
[16:13:04.097]                           computeRestarts <- base::computeRestarts
[16:13:04.097]                           grepl <- base::grepl
[16:13:04.097]                           restarts <- computeRestarts(cond)
[16:13:04.097]                           for (restart in restarts) {
[16:13:04.097]                             name <- restart$name
[16:13:04.097]                             if (is.null(name)) 
[16:13:04.097]                               next
[16:13:04.097]                             if (!grepl(pattern, name)) 
[16:13:04.097]                               next
[16:13:04.097]                             invokeRestart(restart)
[16:13:04.097]                             muffled <- TRUE
[16:13:04.097]                             break
[16:13:04.097]                           }
[16:13:04.097]                         }
[16:13:04.097]                       }
[16:13:04.097]                       invisible(muffled)
[16:13:04.097]                     }
[16:13:04.097]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.097]                   }
[16:13:04.097]                 }
[16:13:04.097]                 else {
[16:13:04.097]                   if (TRUE) {
[16:13:04.097]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.097]                     {
[16:13:04.097]                       inherits <- base::inherits
[16:13:04.097]                       invokeRestart <- base::invokeRestart
[16:13:04.097]                       is.null <- base::is.null
[16:13:04.097]                       muffled <- FALSE
[16:13:04.097]                       if (inherits(cond, "message")) {
[16:13:04.097]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.097]                         if (muffled) 
[16:13:04.097]                           invokeRestart("muffleMessage")
[16:13:04.097]                       }
[16:13:04.097]                       else if (inherits(cond, "warning")) {
[16:13:04.097]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.097]                         if (muffled) 
[16:13:04.097]                           invokeRestart("muffleWarning")
[16:13:04.097]                       }
[16:13:04.097]                       else if (inherits(cond, "condition")) {
[16:13:04.097]                         if (!is.null(pattern)) {
[16:13:04.097]                           computeRestarts <- base::computeRestarts
[16:13:04.097]                           grepl <- base::grepl
[16:13:04.097]                           restarts <- computeRestarts(cond)
[16:13:04.097]                           for (restart in restarts) {
[16:13:04.097]                             name <- restart$name
[16:13:04.097]                             if (is.null(name)) 
[16:13:04.097]                               next
[16:13:04.097]                             if (!grepl(pattern, name)) 
[16:13:04.097]                               next
[16:13:04.097]                             invokeRestart(restart)
[16:13:04.097]                             muffled <- TRUE
[16:13:04.097]                             break
[16:13:04.097]                           }
[16:13:04.097]                         }
[16:13:04.097]                       }
[16:13:04.097]                       invisible(muffled)
[16:13:04.097]                     }
[16:13:04.097]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.097]                   }
[16:13:04.097]                 }
[16:13:04.097]             }
[16:13:04.097]         }))
[16:13:04.097]     }, error = function(ex) {
[16:13:04.097]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:04.097]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.097]                 ...future.rng), started = ...future.startTime, 
[16:13:04.097]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:04.097]             version = "1.8"), class = "FutureResult")
[16:13:04.097]     }, finally = {
[16:13:04.097]         if (!identical(...future.workdir, getwd())) 
[16:13:04.097]             setwd(...future.workdir)
[16:13:04.097]         {
[16:13:04.097]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:04.097]                 ...future.oldOptions$nwarnings <- NULL
[16:13:04.097]             }
[16:13:04.097]             base::options(...future.oldOptions)
[16:13:04.097]             if (.Platform$OS.type == "windows") {
[16:13:04.097]                 old_names <- names(...future.oldEnvVars)
[16:13:04.097]                 envs <- base::Sys.getenv()
[16:13:04.097]                 names <- names(envs)
[16:13:04.097]                 common <- intersect(names, old_names)
[16:13:04.097]                 added <- setdiff(names, old_names)
[16:13:04.097]                 removed <- setdiff(old_names, names)
[16:13:04.097]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:04.097]                   envs[common]]
[16:13:04.097]                 NAMES <- toupper(changed)
[16:13:04.097]                 args <- list()
[16:13:04.097]                 for (kk in seq_along(NAMES)) {
[16:13:04.097]                   name <- changed[[kk]]
[16:13:04.097]                   NAME <- NAMES[[kk]]
[16:13:04.097]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.097]                     next
[16:13:04.097]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.097]                 }
[16:13:04.097]                 NAMES <- toupper(added)
[16:13:04.097]                 for (kk in seq_along(NAMES)) {
[16:13:04.097]                   name <- added[[kk]]
[16:13:04.097]                   NAME <- NAMES[[kk]]
[16:13:04.097]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.097]                     next
[16:13:04.097]                   args[[name]] <- ""
[16:13:04.097]                 }
[16:13:04.097]                 NAMES <- toupper(removed)
[16:13:04.097]                 for (kk in seq_along(NAMES)) {
[16:13:04.097]                   name <- removed[[kk]]
[16:13:04.097]                   NAME <- NAMES[[kk]]
[16:13:04.097]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.097]                     next
[16:13:04.097]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.097]                 }
[16:13:04.097]                 if (length(args) > 0) 
[16:13:04.097]                   base::do.call(base::Sys.setenv, args = args)
[16:13:04.097]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:04.097]             }
[16:13:04.097]             else {
[16:13:04.097]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:04.097]             }
[16:13:04.097]             {
[16:13:04.097]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:04.097]                   0L) {
[16:13:04.097]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:04.097]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:04.097]                   base::options(opts)
[16:13:04.097]                 }
[16:13:04.097]                 {
[16:13:04.097]                   {
[16:13:04.097]                     NULL
[16:13:04.097]                     RNGkind("Mersenne-Twister")
[16:13:04.097]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:04.097]                       inherits = FALSE)
[16:13:04.097]                   }
[16:13:04.097]                   options(future.plan = NULL)
[16:13:04.097]                   if (is.na(NA_character_)) 
[16:13:04.097]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.097]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:04.097]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:04.097]                     envir = parent.frame()) 
[16:13:04.097]                   {
[16:13:04.097]                     default_workers <- missing(workers)
[16:13:04.097]                     if (is.function(workers)) 
[16:13:04.097]                       workers <- workers()
[16:13:04.097]                     workers <- structure(as.integer(workers), 
[16:13:04.097]                       class = class(workers))
[16:13:04.097]                     stop_if_not(is.finite(workers), workers >= 
[16:13:04.097]                       1L)
[16:13:04.097]                     if ((workers == 1L && !inherits(workers, 
[16:13:04.097]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:04.097]                       if (default_workers) 
[16:13:04.097]                         supportsMulticore(warn = TRUE)
[16:13:04.097]                       return(sequential(..., envir = envir))
[16:13:04.097]                     }
[16:13:04.097]                     oopts <- options(mc.cores = workers)
[16:13:04.097]                     on.exit(options(oopts))
[16:13:04.097]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:04.097]                       envir = envir)
[16:13:04.097]                     if (!future$lazy) 
[16:13:04.097]                       future <- run(future)
[16:13:04.097]                     invisible(future)
[16:13:04.097]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:04.097]                 }
[16:13:04.097]             }
[16:13:04.097]         }
[16:13:04.097]     })
[16:13:04.097]     if (TRUE) {
[16:13:04.097]         base::sink(type = "output", split = FALSE)
[16:13:04.097]         if (TRUE) {
[16:13:04.097]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:04.097]         }
[16:13:04.097]         else {
[16:13:04.097]             ...future.result["stdout"] <- base::list(NULL)
[16:13:04.097]         }
[16:13:04.097]         base::close(...future.stdout)
[16:13:04.097]         ...future.stdout <- NULL
[16:13:04.097]     }
[16:13:04.097]     ...future.result$conditions <- ...future.conditions
[16:13:04.097]     ...future.result$finished <- base::Sys.time()
[16:13:04.097]     ...future.result
[16:13:04.097] }
[16:13:04.099] plan(): Setting new future strategy stack:
[16:13:04.099] List of future strategies:
[16:13:04.099] 1. sequential:
[16:13:04.099]    - args: function (..., envir = parent.frame())
[16:13:04.099]    - tweaked: FALSE
[16:13:04.099]    - call: NULL
[16:13:04.099] plan(): nbrOfWorkers() = 1
[16:13:04.100] plan(): Setting new future strategy stack:
[16:13:04.100] List of future strategies:
[16:13:04.100] 1. multicore:
[16:13:04.100]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:04.100]    - tweaked: FALSE
[16:13:04.100]    - call: plan(multicore)
[16:13:04.103] plan(): nbrOfWorkers() = 1
[16:13:04.104] SequentialFuture started (and completed)
 - Creating multicore future #2 ...
[16:13:04.107] getGlobalsAndPackages() ...
[16:13:04.107] Not searching for globals
[16:13:04.107] - globals: [0] <none>
[16:13:04.107] getGlobalsAndPackages() ... DONE
[16:13:04.108] Packages needed by the future expression (n = 0): <none>
[16:13:04.108] Packages needed by future strategies (n = 0): <none>
[16:13:04.108] {
[16:13:04.108]     {
[16:13:04.108]         {
[16:13:04.108]             ...future.startTime <- base::Sys.time()
[16:13:04.108]             {
[16:13:04.108]                 {
[16:13:04.108]                   {
[16:13:04.108]                     base::local({
[16:13:04.108]                       has_future <- base::requireNamespace("future", 
[16:13:04.108]                         quietly = TRUE)
[16:13:04.108]                       if (has_future) {
[16:13:04.108]                         ns <- base::getNamespace("future")
[16:13:04.108]                         version <- ns[[".package"]][["version"]]
[16:13:04.108]                         if (is.null(version)) 
[16:13:04.108]                           version <- utils::packageVersion("future")
[16:13:04.108]                       }
[16:13:04.108]                       else {
[16:13:04.108]                         version <- NULL
[16:13:04.108]                       }
[16:13:04.108]                       if (!has_future || version < "1.8.0") {
[16:13:04.108]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:04.108]                           "", base::R.version$version.string), 
[16:13:04.108]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:04.108]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:04.108]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:04.108]                             "release", "version")], collapse = " "), 
[16:13:04.108]                           hostname = base::Sys.info()[["nodename"]])
[16:13:04.108]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:04.108]                           info)
[16:13:04.108]                         info <- base::paste(info, collapse = "; ")
[16:13:04.108]                         if (!has_future) {
[16:13:04.108]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:04.108]                             info)
[16:13:04.108]                         }
[16:13:04.108]                         else {
[16:13:04.108]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:04.108]                             info, version)
[16:13:04.108]                         }
[16:13:04.108]                         base::stop(msg)
[16:13:04.108]                       }
[16:13:04.108]                     })
[16:13:04.108]                   }
[16:13:04.108]                   options(future.plan = NULL)
[16:13:04.108]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.108]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:04.108]                 }
[16:13:04.108]                 ...future.workdir <- getwd()
[16:13:04.108]             }
[16:13:04.108]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:04.108]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:04.108]         }
[16:13:04.108]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:04.108]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:04.108]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:04.108]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:04.108]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:04.108]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:04.108]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:04.108]             base::names(...future.oldOptions))
[16:13:04.108]     }
[16:13:04.108]     if (FALSE) {
[16:13:04.108]     }
[16:13:04.108]     else {
[16:13:04.108]         if (TRUE) {
[16:13:04.108]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:04.108]                 open = "w")
[16:13:04.108]         }
[16:13:04.108]         else {
[16:13:04.108]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:04.108]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:04.108]         }
[16:13:04.108]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:04.108]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:04.108]             base::sink(type = "output", split = FALSE)
[16:13:04.108]             base::close(...future.stdout)
[16:13:04.108]         }, add = TRUE)
[16:13:04.108]     }
[16:13:04.108]     ...future.frame <- base::sys.nframe()
[16:13:04.108]     ...future.conditions <- base::list()
[16:13:04.108]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:04.108]     if (FALSE) {
[16:13:04.108]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:04.108]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:04.108]     }
[16:13:04.108]     ...future.result <- base::tryCatch({
[16:13:04.108]         base::withCallingHandlers({
[16:13:04.108]             ...future.value <- base::withVisible(base::local({
[16:13:04.108]                 ii
[16:13:04.108]             }))
[16:13:04.108]             future::FutureResult(value = ...future.value$value, 
[16:13:04.108]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.108]                   ...future.rng), globalenv = if (FALSE) 
[16:13:04.108]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:04.108]                     ...future.globalenv.names))
[16:13:04.108]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:04.108]         }, condition = base::local({
[16:13:04.108]             c <- base::c
[16:13:04.108]             inherits <- base::inherits
[16:13:04.108]             invokeRestart <- base::invokeRestart
[16:13:04.108]             length <- base::length
[16:13:04.108]             list <- base::list
[16:13:04.108]             seq.int <- base::seq.int
[16:13:04.108]             signalCondition <- base::signalCondition
[16:13:04.108]             sys.calls <- base::sys.calls
[16:13:04.108]             `[[` <- base::`[[`
[16:13:04.108]             `+` <- base::`+`
[16:13:04.108]             `<<-` <- base::`<<-`
[16:13:04.108]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:04.108]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:04.108]                   3L)]
[16:13:04.108]             }
[16:13:04.108]             function(cond) {
[16:13:04.108]                 is_error <- inherits(cond, "error")
[16:13:04.108]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:04.108]                   NULL)
[16:13:04.108]                 if (is_error) {
[16:13:04.108]                   sessionInformation <- function() {
[16:13:04.108]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:04.108]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:04.108]                       search = base::search(), system = base::Sys.info())
[16:13:04.108]                   }
[16:13:04.108]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.108]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:04.108]                     cond$call), session = sessionInformation(), 
[16:13:04.108]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:04.108]                   signalCondition(cond)
[16:13:04.108]                 }
[16:13:04.108]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:04.108]                 "immediateCondition"))) {
[16:13:04.108]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:04.108]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.108]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:04.108]                   if (TRUE && !signal) {
[16:13:04.108]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.108]                     {
[16:13:04.108]                       inherits <- base::inherits
[16:13:04.108]                       invokeRestart <- base::invokeRestart
[16:13:04.108]                       is.null <- base::is.null
[16:13:04.108]                       muffled <- FALSE
[16:13:04.108]                       if (inherits(cond, "message")) {
[16:13:04.108]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.108]                         if (muffled) 
[16:13:04.108]                           invokeRestart("muffleMessage")
[16:13:04.108]                       }
[16:13:04.108]                       else if (inherits(cond, "warning")) {
[16:13:04.108]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.108]                         if (muffled) 
[16:13:04.108]                           invokeRestart("muffleWarning")
[16:13:04.108]                       }
[16:13:04.108]                       else if (inherits(cond, "condition")) {
[16:13:04.108]                         if (!is.null(pattern)) {
[16:13:04.108]                           computeRestarts <- base::computeRestarts
[16:13:04.108]                           grepl <- base::grepl
[16:13:04.108]                           restarts <- computeRestarts(cond)
[16:13:04.108]                           for (restart in restarts) {
[16:13:04.108]                             name <- restart$name
[16:13:04.108]                             if (is.null(name)) 
[16:13:04.108]                               next
[16:13:04.108]                             if (!grepl(pattern, name)) 
[16:13:04.108]                               next
[16:13:04.108]                             invokeRestart(restart)
[16:13:04.108]                             muffled <- TRUE
[16:13:04.108]                             break
[16:13:04.108]                           }
[16:13:04.108]                         }
[16:13:04.108]                       }
[16:13:04.108]                       invisible(muffled)
[16:13:04.108]                     }
[16:13:04.108]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.108]                   }
[16:13:04.108]                 }
[16:13:04.108]                 else {
[16:13:04.108]                   if (TRUE) {
[16:13:04.108]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.108]                     {
[16:13:04.108]                       inherits <- base::inherits
[16:13:04.108]                       invokeRestart <- base::invokeRestart
[16:13:04.108]                       is.null <- base::is.null
[16:13:04.108]                       muffled <- FALSE
[16:13:04.108]                       if (inherits(cond, "message")) {
[16:13:04.108]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.108]                         if (muffled) 
[16:13:04.108]                           invokeRestart("muffleMessage")
[16:13:04.108]                       }
[16:13:04.108]                       else if (inherits(cond, "warning")) {
[16:13:04.108]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.108]                         if (muffled) 
[16:13:04.108]                           invokeRestart("muffleWarning")
[16:13:04.108]                       }
[16:13:04.108]                       else if (inherits(cond, "condition")) {
[16:13:04.108]                         if (!is.null(pattern)) {
[16:13:04.108]                           computeRestarts <- base::computeRestarts
[16:13:04.108]                           grepl <- base::grepl
[16:13:04.108]                           restarts <- computeRestarts(cond)
[16:13:04.108]                           for (restart in restarts) {
[16:13:04.108]                             name <- restart$name
[16:13:04.108]                             if (is.null(name)) 
[16:13:04.108]                               next
[16:13:04.108]                             if (!grepl(pattern, name)) 
[16:13:04.108]                               next
[16:13:04.108]                             invokeRestart(restart)
[16:13:04.108]                             muffled <- TRUE
[16:13:04.108]                             break
[16:13:04.108]                           }
[16:13:04.108]                         }
[16:13:04.108]                       }
[16:13:04.108]                       invisible(muffled)
[16:13:04.108]                     }
[16:13:04.108]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.108]                   }
[16:13:04.108]                 }
[16:13:04.108]             }
[16:13:04.108]         }))
[16:13:04.108]     }, error = function(ex) {
[16:13:04.108]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:04.108]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.108]                 ...future.rng), started = ...future.startTime, 
[16:13:04.108]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:04.108]             version = "1.8"), class = "FutureResult")
[16:13:04.108]     }, finally = {
[16:13:04.108]         if (!identical(...future.workdir, getwd())) 
[16:13:04.108]             setwd(...future.workdir)
[16:13:04.108]         {
[16:13:04.108]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:04.108]                 ...future.oldOptions$nwarnings <- NULL
[16:13:04.108]             }
[16:13:04.108]             base::options(...future.oldOptions)
[16:13:04.108]             if (.Platform$OS.type == "windows") {
[16:13:04.108]                 old_names <- names(...future.oldEnvVars)
[16:13:04.108]                 envs <- base::Sys.getenv()
[16:13:04.108]                 names <- names(envs)
[16:13:04.108]                 common <- intersect(names, old_names)
[16:13:04.108]                 added <- setdiff(names, old_names)
[16:13:04.108]                 removed <- setdiff(old_names, names)
[16:13:04.108]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:04.108]                   envs[common]]
[16:13:04.108]                 NAMES <- toupper(changed)
[16:13:04.108]                 args <- list()
[16:13:04.108]                 for (kk in seq_along(NAMES)) {
[16:13:04.108]                   name <- changed[[kk]]
[16:13:04.108]                   NAME <- NAMES[[kk]]
[16:13:04.108]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.108]                     next
[16:13:04.108]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.108]                 }
[16:13:04.108]                 NAMES <- toupper(added)
[16:13:04.108]                 for (kk in seq_along(NAMES)) {
[16:13:04.108]                   name <- added[[kk]]
[16:13:04.108]                   NAME <- NAMES[[kk]]
[16:13:04.108]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.108]                     next
[16:13:04.108]                   args[[name]] <- ""
[16:13:04.108]                 }
[16:13:04.108]                 NAMES <- toupper(removed)
[16:13:04.108]                 for (kk in seq_along(NAMES)) {
[16:13:04.108]                   name <- removed[[kk]]
[16:13:04.108]                   NAME <- NAMES[[kk]]
[16:13:04.108]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.108]                     next
[16:13:04.108]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.108]                 }
[16:13:04.108]                 if (length(args) > 0) 
[16:13:04.108]                   base::do.call(base::Sys.setenv, args = args)
[16:13:04.108]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:04.108]             }
[16:13:04.108]             else {
[16:13:04.108]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:04.108]             }
[16:13:04.108]             {
[16:13:04.108]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:04.108]                   0L) {
[16:13:04.108]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:04.108]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:04.108]                   base::options(opts)
[16:13:04.108]                 }
[16:13:04.108]                 {
[16:13:04.108]                   {
[16:13:04.108]                     NULL
[16:13:04.108]                     RNGkind("Mersenne-Twister")
[16:13:04.108]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:04.108]                       inherits = FALSE)
[16:13:04.108]                   }
[16:13:04.108]                   options(future.plan = NULL)
[16:13:04.108]                   if (is.na(NA_character_)) 
[16:13:04.108]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.108]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:04.108]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:04.108]                     envir = parent.frame()) 
[16:13:04.108]                   {
[16:13:04.108]                     default_workers <- missing(workers)
[16:13:04.108]                     if (is.function(workers)) 
[16:13:04.108]                       workers <- workers()
[16:13:04.108]                     workers <- structure(as.integer(workers), 
[16:13:04.108]                       class = class(workers))
[16:13:04.108]                     stop_if_not(is.finite(workers), workers >= 
[16:13:04.108]                       1L)
[16:13:04.108]                     if ((workers == 1L && !inherits(workers, 
[16:13:04.108]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:04.108]                       if (default_workers) 
[16:13:04.108]                         supportsMulticore(warn = TRUE)
[16:13:04.108]                       return(sequential(..., envir = envir))
[16:13:04.108]                     }
[16:13:04.108]                     oopts <- options(mc.cores = workers)
[16:13:04.108]                     on.exit(options(oopts))
[16:13:04.108]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:04.108]                       envir = envir)
[16:13:04.108]                     if (!future$lazy) 
[16:13:04.108]                       future <- run(future)
[16:13:04.108]                     invisible(future)
[16:13:04.108]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:04.108]                 }
[16:13:04.108]             }
[16:13:04.108]         }
[16:13:04.108]     })
[16:13:04.108]     if (TRUE) {
[16:13:04.108]         base::sink(type = "output", split = FALSE)
[16:13:04.108]         if (TRUE) {
[16:13:04.108]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:04.108]         }
[16:13:04.108]         else {
[16:13:04.108]             ...future.result["stdout"] <- base::list(NULL)
[16:13:04.108]         }
[16:13:04.108]         base::close(...future.stdout)
[16:13:04.108]         ...future.stdout <- NULL
[16:13:04.108]     }
[16:13:04.108]     ...future.result$conditions <- ...future.conditions
[16:13:04.108]     ...future.result$finished <- base::Sys.time()
[16:13:04.108]     ...future.result
[16:13:04.108] }
[16:13:04.110] plan(): Setting new future strategy stack:
[16:13:04.110] List of future strategies:
[16:13:04.110] 1. sequential:
[16:13:04.110]    - args: function (..., envir = parent.frame())
[16:13:04.110]    - tweaked: FALSE
[16:13:04.110]    - call: NULL
[16:13:04.111] plan(): nbrOfWorkers() = 1
[16:13:04.111] plan(): Setting new future strategy stack:
[16:13:04.111] List of future strategies:
[16:13:04.111] 1. multicore:
[16:13:04.111]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:04.111]    - tweaked: FALSE
[16:13:04.111]    - call: plan(multicore)
[16:13:04.115] plan(): nbrOfWorkers() = 1
[16:13:04.115] SequentialFuture started (and completed)
 - Creating multicore future #3 ...
[16:13:04.118] getGlobalsAndPackages() ...
[16:13:04.118] Not searching for globals
[16:13:04.118] - globals: [0] <none>
[16:13:04.119] getGlobalsAndPackages() ... DONE
[16:13:04.119] Packages needed by the future expression (n = 0): <none>
[16:13:04.119] Packages needed by future strategies (n = 0): <none>
[16:13:04.119] {
[16:13:04.119]     {
[16:13:04.119]         {
[16:13:04.119]             ...future.startTime <- base::Sys.time()
[16:13:04.119]             {
[16:13:04.119]                 {
[16:13:04.119]                   {
[16:13:04.119]                     base::local({
[16:13:04.119]                       has_future <- base::requireNamespace("future", 
[16:13:04.119]                         quietly = TRUE)
[16:13:04.119]                       if (has_future) {
[16:13:04.119]                         ns <- base::getNamespace("future")
[16:13:04.119]                         version <- ns[[".package"]][["version"]]
[16:13:04.119]                         if (is.null(version)) 
[16:13:04.119]                           version <- utils::packageVersion("future")
[16:13:04.119]                       }
[16:13:04.119]                       else {
[16:13:04.119]                         version <- NULL
[16:13:04.119]                       }
[16:13:04.119]                       if (!has_future || version < "1.8.0") {
[16:13:04.119]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:04.119]                           "", base::R.version$version.string), 
[16:13:04.119]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:04.119]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:04.119]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:04.119]                             "release", "version")], collapse = " "), 
[16:13:04.119]                           hostname = base::Sys.info()[["nodename"]])
[16:13:04.119]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:04.119]                           info)
[16:13:04.119]                         info <- base::paste(info, collapse = "; ")
[16:13:04.119]                         if (!has_future) {
[16:13:04.119]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:04.119]                             info)
[16:13:04.119]                         }
[16:13:04.119]                         else {
[16:13:04.119]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:04.119]                             info, version)
[16:13:04.119]                         }
[16:13:04.119]                         base::stop(msg)
[16:13:04.119]                       }
[16:13:04.119]                     })
[16:13:04.119]                   }
[16:13:04.119]                   options(future.plan = NULL)
[16:13:04.119]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.119]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:04.119]                 }
[16:13:04.119]                 ...future.workdir <- getwd()
[16:13:04.119]             }
[16:13:04.119]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:04.119]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:04.119]         }
[16:13:04.119]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:04.119]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:04.119]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:04.119]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:04.119]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:04.119]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:04.119]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:04.119]             base::names(...future.oldOptions))
[16:13:04.119]     }
[16:13:04.119]     if (FALSE) {
[16:13:04.119]     }
[16:13:04.119]     else {
[16:13:04.119]         if (TRUE) {
[16:13:04.119]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:04.119]                 open = "w")
[16:13:04.119]         }
[16:13:04.119]         else {
[16:13:04.119]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:04.119]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:04.119]         }
[16:13:04.119]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:04.119]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:04.119]             base::sink(type = "output", split = FALSE)
[16:13:04.119]             base::close(...future.stdout)
[16:13:04.119]         }, add = TRUE)
[16:13:04.119]     }
[16:13:04.119]     ...future.frame <- base::sys.nframe()
[16:13:04.119]     ...future.conditions <- base::list()
[16:13:04.119]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:04.119]     if (FALSE) {
[16:13:04.119]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:04.119]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:04.119]     }
[16:13:04.119]     ...future.result <- base::tryCatch({
[16:13:04.119]         base::withCallingHandlers({
[16:13:04.119]             ...future.value <- base::withVisible(base::local({
[16:13:04.119]                 ii
[16:13:04.119]             }))
[16:13:04.119]             future::FutureResult(value = ...future.value$value, 
[16:13:04.119]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.119]                   ...future.rng), globalenv = if (FALSE) 
[16:13:04.119]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:04.119]                     ...future.globalenv.names))
[16:13:04.119]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:04.119]         }, condition = base::local({
[16:13:04.119]             c <- base::c
[16:13:04.119]             inherits <- base::inherits
[16:13:04.119]             invokeRestart <- base::invokeRestart
[16:13:04.119]             length <- base::length
[16:13:04.119]             list <- base::list
[16:13:04.119]             seq.int <- base::seq.int
[16:13:04.119]             signalCondition <- base::signalCondition
[16:13:04.119]             sys.calls <- base::sys.calls
[16:13:04.119]             `[[` <- base::`[[`
[16:13:04.119]             `+` <- base::`+`
[16:13:04.119]             `<<-` <- base::`<<-`
[16:13:04.119]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:04.119]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:04.119]                   3L)]
[16:13:04.119]             }
[16:13:04.119]             function(cond) {
[16:13:04.119]                 is_error <- inherits(cond, "error")
[16:13:04.119]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:04.119]                   NULL)
[16:13:04.119]                 if (is_error) {
[16:13:04.119]                   sessionInformation <- function() {
[16:13:04.119]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:04.119]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:04.119]                       search = base::search(), system = base::Sys.info())
[16:13:04.119]                   }
[16:13:04.119]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.119]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:04.119]                     cond$call), session = sessionInformation(), 
[16:13:04.119]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:04.119]                   signalCondition(cond)
[16:13:04.119]                 }
[16:13:04.119]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:04.119]                 "immediateCondition"))) {
[16:13:04.119]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:04.119]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.119]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:04.119]                   if (TRUE && !signal) {
[16:13:04.119]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.119]                     {
[16:13:04.119]                       inherits <- base::inherits
[16:13:04.119]                       invokeRestart <- base::invokeRestart
[16:13:04.119]                       is.null <- base::is.null
[16:13:04.119]                       muffled <- FALSE
[16:13:04.119]                       if (inherits(cond, "message")) {
[16:13:04.119]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.119]                         if (muffled) 
[16:13:04.119]                           invokeRestart("muffleMessage")
[16:13:04.119]                       }
[16:13:04.119]                       else if (inherits(cond, "warning")) {
[16:13:04.119]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.119]                         if (muffled) 
[16:13:04.119]                           invokeRestart("muffleWarning")
[16:13:04.119]                       }
[16:13:04.119]                       else if (inherits(cond, "condition")) {
[16:13:04.119]                         if (!is.null(pattern)) {
[16:13:04.119]                           computeRestarts <- base::computeRestarts
[16:13:04.119]                           grepl <- base::grepl
[16:13:04.119]                           restarts <- computeRestarts(cond)
[16:13:04.119]                           for (restart in restarts) {
[16:13:04.119]                             name <- restart$name
[16:13:04.119]                             if (is.null(name)) 
[16:13:04.119]                               next
[16:13:04.119]                             if (!grepl(pattern, name)) 
[16:13:04.119]                               next
[16:13:04.119]                             invokeRestart(restart)
[16:13:04.119]                             muffled <- TRUE
[16:13:04.119]                             break
[16:13:04.119]                           }
[16:13:04.119]                         }
[16:13:04.119]                       }
[16:13:04.119]                       invisible(muffled)
[16:13:04.119]                     }
[16:13:04.119]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.119]                   }
[16:13:04.119]                 }
[16:13:04.119]                 else {
[16:13:04.119]                   if (TRUE) {
[16:13:04.119]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.119]                     {
[16:13:04.119]                       inherits <- base::inherits
[16:13:04.119]                       invokeRestart <- base::invokeRestart
[16:13:04.119]                       is.null <- base::is.null
[16:13:04.119]                       muffled <- FALSE
[16:13:04.119]                       if (inherits(cond, "message")) {
[16:13:04.119]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.119]                         if (muffled) 
[16:13:04.119]                           invokeRestart("muffleMessage")
[16:13:04.119]                       }
[16:13:04.119]                       else if (inherits(cond, "warning")) {
[16:13:04.119]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.119]                         if (muffled) 
[16:13:04.119]                           invokeRestart("muffleWarning")
[16:13:04.119]                       }
[16:13:04.119]                       else if (inherits(cond, "condition")) {
[16:13:04.119]                         if (!is.null(pattern)) {
[16:13:04.119]                           computeRestarts <- base::computeRestarts
[16:13:04.119]                           grepl <- base::grepl
[16:13:04.119]                           restarts <- computeRestarts(cond)
[16:13:04.119]                           for (restart in restarts) {
[16:13:04.119]                             name <- restart$name
[16:13:04.119]                             if (is.null(name)) 
[16:13:04.119]                               next
[16:13:04.119]                             if (!grepl(pattern, name)) 
[16:13:04.119]                               next
[16:13:04.119]                             invokeRestart(restart)
[16:13:04.119]                             muffled <- TRUE
[16:13:04.119]                             break
[16:13:04.119]                           }
[16:13:04.119]                         }
[16:13:04.119]                       }
[16:13:04.119]                       invisible(muffled)
[16:13:04.119]                     }
[16:13:04.119]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.119]                   }
[16:13:04.119]                 }
[16:13:04.119]             }
[16:13:04.119]         }))
[16:13:04.119]     }, error = function(ex) {
[16:13:04.119]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:04.119]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.119]                 ...future.rng), started = ...future.startTime, 
[16:13:04.119]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:04.119]             version = "1.8"), class = "FutureResult")
[16:13:04.119]     }, finally = {
[16:13:04.119]         if (!identical(...future.workdir, getwd())) 
[16:13:04.119]             setwd(...future.workdir)
[16:13:04.119]         {
[16:13:04.119]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:04.119]                 ...future.oldOptions$nwarnings <- NULL
[16:13:04.119]             }
[16:13:04.119]             base::options(...future.oldOptions)
[16:13:04.119]             if (.Platform$OS.type == "windows") {
[16:13:04.119]                 old_names <- names(...future.oldEnvVars)
[16:13:04.119]                 envs <- base::Sys.getenv()
[16:13:04.119]                 names <- names(envs)
[16:13:04.119]                 common <- intersect(names, old_names)
[16:13:04.119]                 added <- setdiff(names, old_names)
[16:13:04.119]                 removed <- setdiff(old_names, names)
[16:13:04.119]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:04.119]                   envs[common]]
[16:13:04.119]                 NAMES <- toupper(changed)
[16:13:04.119]                 args <- list()
[16:13:04.119]                 for (kk in seq_along(NAMES)) {
[16:13:04.119]                   name <- changed[[kk]]
[16:13:04.119]                   NAME <- NAMES[[kk]]
[16:13:04.119]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.119]                     next
[16:13:04.119]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.119]                 }
[16:13:04.119]                 NAMES <- toupper(added)
[16:13:04.119]                 for (kk in seq_along(NAMES)) {
[16:13:04.119]                   name <- added[[kk]]
[16:13:04.119]                   NAME <- NAMES[[kk]]
[16:13:04.119]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.119]                     next
[16:13:04.119]                   args[[name]] <- ""
[16:13:04.119]                 }
[16:13:04.119]                 NAMES <- toupper(removed)
[16:13:04.119]                 for (kk in seq_along(NAMES)) {
[16:13:04.119]                   name <- removed[[kk]]
[16:13:04.119]                   NAME <- NAMES[[kk]]
[16:13:04.119]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.119]                     next
[16:13:04.119]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.119]                 }
[16:13:04.119]                 if (length(args) > 0) 
[16:13:04.119]                   base::do.call(base::Sys.setenv, args = args)
[16:13:04.119]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:04.119]             }
[16:13:04.119]             else {
[16:13:04.119]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:04.119]             }
[16:13:04.119]             {
[16:13:04.119]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:04.119]                   0L) {
[16:13:04.119]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:04.119]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:04.119]                   base::options(opts)
[16:13:04.119]                 }
[16:13:04.119]                 {
[16:13:04.119]                   {
[16:13:04.119]                     NULL
[16:13:04.119]                     RNGkind("Mersenne-Twister")
[16:13:04.119]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:04.119]                       inherits = FALSE)
[16:13:04.119]                   }
[16:13:04.119]                   options(future.plan = NULL)
[16:13:04.119]                   if (is.na(NA_character_)) 
[16:13:04.119]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.119]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:04.119]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:04.119]                     envir = parent.frame()) 
[16:13:04.119]                   {
[16:13:04.119]                     default_workers <- missing(workers)
[16:13:04.119]                     if (is.function(workers)) 
[16:13:04.119]                       workers <- workers()
[16:13:04.119]                     workers <- structure(as.integer(workers), 
[16:13:04.119]                       class = class(workers))
[16:13:04.119]                     stop_if_not(is.finite(workers), workers >= 
[16:13:04.119]                       1L)
[16:13:04.119]                     if ((workers == 1L && !inherits(workers, 
[16:13:04.119]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:04.119]                       if (default_workers) 
[16:13:04.119]                         supportsMulticore(warn = TRUE)
[16:13:04.119]                       return(sequential(..., envir = envir))
[16:13:04.119]                     }
[16:13:04.119]                     oopts <- options(mc.cores = workers)
[16:13:04.119]                     on.exit(options(oopts))
[16:13:04.119]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:04.119]                       envir = envir)
[16:13:04.119]                     if (!future$lazy) 
[16:13:04.119]                       future <- run(future)
[16:13:04.119]                     invisible(future)
[16:13:04.119]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:04.119]                 }
[16:13:04.119]             }
[16:13:04.119]         }
[16:13:04.119]     })
[16:13:04.119]     if (TRUE) {
[16:13:04.119]         base::sink(type = "output", split = FALSE)
[16:13:04.119]         if (TRUE) {
[16:13:04.119]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:04.119]         }
[16:13:04.119]         else {
[16:13:04.119]             ...future.result["stdout"] <- base::list(NULL)
[16:13:04.119]         }
[16:13:04.119]         base::close(...future.stdout)
[16:13:04.119]         ...future.stdout <- NULL
[16:13:04.119]     }
[16:13:04.119]     ...future.result$conditions <- ...future.conditions
[16:13:04.119]     ...future.result$finished <- base::Sys.time()
[16:13:04.119]     ...future.result
[16:13:04.119] }
[16:13:04.121] plan(): Setting new future strategy stack:
[16:13:04.121] List of future strategies:
[16:13:04.121] 1. sequential:
[16:13:04.121]    - args: function (..., envir = parent.frame())
[16:13:04.121]    - tweaked: FALSE
[16:13:04.121]    - call: NULL
[16:13:04.122] plan(): nbrOfWorkers() = 1
[16:13:04.122] plan(): Setting new future strategy stack:
[16:13:04.122] List of future strategies:
[16:13:04.122] 1. multicore:
[16:13:04.122]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:04.122]    - tweaked: FALSE
[16:13:04.122]    - call: plan(multicore)
[16:13:04.126] plan(): nbrOfWorkers() = 1
[16:13:04.126] SequentialFuture started (and completed)
 - Creating multicore future #4 ...
[16:13:04.129] getGlobalsAndPackages() ...
[16:13:04.129] Not searching for globals
[16:13:04.129] - globals: [0] <none>
[16:13:04.130] getGlobalsAndPackages() ... DONE
[16:13:04.130] Packages needed by the future expression (n = 0): <none>
[16:13:04.130] Packages needed by future strategies (n = 0): <none>
[16:13:04.130] {
[16:13:04.130]     {
[16:13:04.130]         {
[16:13:04.130]             ...future.startTime <- base::Sys.time()
[16:13:04.130]             {
[16:13:04.130]                 {
[16:13:04.130]                   {
[16:13:04.130]                     base::local({
[16:13:04.130]                       has_future <- base::requireNamespace("future", 
[16:13:04.130]                         quietly = TRUE)
[16:13:04.130]                       if (has_future) {
[16:13:04.130]                         ns <- base::getNamespace("future")
[16:13:04.130]                         version <- ns[[".package"]][["version"]]
[16:13:04.130]                         if (is.null(version)) 
[16:13:04.130]                           version <- utils::packageVersion("future")
[16:13:04.130]                       }
[16:13:04.130]                       else {
[16:13:04.130]                         version <- NULL
[16:13:04.130]                       }
[16:13:04.130]                       if (!has_future || version < "1.8.0") {
[16:13:04.130]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:04.130]                           "", base::R.version$version.string), 
[16:13:04.130]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:04.130]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:04.130]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:04.130]                             "release", "version")], collapse = " "), 
[16:13:04.130]                           hostname = base::Sys.info()[["nodename"]])
[16:13:04.130]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:04.130]                           info)
[16:13:04.130]                         info <- base::paste(info, collapse = "; ")
[16:13:04.130]                         if (!has_future) {
[16:13:04.130]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:04.130]                             info)
[16:13:04.130]                         }
[16:13:04.130]                         else {
[16:13:04.130]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:04.130]                             info, version)
[16:13:04.130]                         }
[16:13:04.130]                         base::stop(msg)
[16:13:04.130]                       }
[16:13:04.130]                     })
[16:13:04.130]                   }
[16:13:04.130]                   options(future.plan = NULL)
[16:13:04.130]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.130]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:04.130]                 }
[16:13:04.130]                 ...future.workdir <- getwd()
[16:13:04.130]             }
[16:13:04.130]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:04.130]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:04.130]         }
[16:13:04.130]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:04.130]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:04.130]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:04.130]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:04.130]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:04.130]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:04.130]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:04.130]             base::names(...future.oldOptions))
[16:13:04.130]     }
[16:13:04.130]     if (FALSE) {
[16:13:04.130]     }
[16:13:04.130]     else {
[16:13:04.130]         if (TRUE) {
[16:13:04.130]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:04.130]                 open = "w")
[16:13:04.130]         }
[16:13:04.130]         else {
[16:13:04.130]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:04.130]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:04.130]         }
[16:13:04.130]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:04.130]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:04.130]             base::sink(type = "output", split = FALSE)
[16:13:04.130]             base::close(...future.stdout)
[16:13:04.130]         }, add = TRUE)
[16:13:04.130]     }
[16:13:04.130]     ...future.frame <- base::sys.nframe()
[16:13:04.130]     ...future.conditions <- base::list()
[16:13:04.130]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:04.130]     if (FALSE) {
[16:13:04.130]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:04.130]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:04.130]     }
[16:13:04.130]     ...future.result <- base::tryCatch({
[16:13:04.130]         base::withCallingHandlers({
[16:13:04.130]             ...future.value <- base::withVisible(base::local({
[16:13:04.130]                 ii
[16:13:04.130]             }))
[16:13:04.130]             future::FutureResult(value = ...future.value$value, 
[16:13:04.130]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.130]                   ...future.rng), globalenv = if (FALSE) 
[16:13:04.130]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:04.130]                     ...future.globalenv.names))
[16:13:04.130]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:04.130]         }, condition = base::local({
[16:13:04.130]             c <- base::c
[16:13:04.130]             inherits <- base::inherits
[16:13:04.130]             invokeRestart <- base::invokeRestart
[16:13:04.130]             length <- base::length
[16:13:04.130]             list <- base::list
[16:13:04.130]             seq.int <- base::seq.int
[16:13:04.130]             signalCondition <- base::signalCondition
[16:13:04.130]             sys.calls <- base::sys.calls
[16:13:04.130]             `[[` <- base::`[[`
[16:13:04.130]             `+` <- base::`+`
[16:13:04.130]             `<<-` <- base::`<<-`
[16:13:04.130]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:04.130]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:04.130]                   3L)]
[16:13:04.130]             }
[16:13:04.130]             function(cond) {
[16:13:04.130]                 is_error <- inherits(cond, "error")
[16:13:04.130]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:04.130]                   NULL)
[16:13:04.130]                 if (is_error) {
[16:13:04.130]                   sessionInformation <- function() {
[16:13:04.130]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:04.130]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:04.130]                       search = base::search(), system = base::Sys.info())
[16:13:04.130]                   }
[16:13:04.130]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.130]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:04.130]                     cond$call), session = sessionInformation(), 
[16:13:04.130]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:04.130]                   signalCondition(cond)
[16:13:04.130]                 }
[16:13:04.130]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:04.130]                 "immediateCondition"))) {
[16:13:04.130]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:04.130]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.130]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:04.130]                   if (TRUE && !signal) {
[16:13:04.130]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.130]                     {
[16:13:04.130]                       inherits <- base::inherits
[16:13:04.130]                       invokeRestart <- base::invokeRestart
[16:13:04.130]                       is.null <- base::is.null
[16:13:04.130]                       muffled <- FALSE
[16:13:04.130]                       if (inherits(cond, "message")) {
[16:13:04.130]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.130]                         if (muffled) 
[16:13:04.130]                           invokeRestart("muffleMessage")
[16:13:04.130]                       }
[16:13:04.130]                       else if (inherits(cond, "warning")) {
[16:13:04.130]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.130]                         if (muffled) 
[16:13:04.130]                           invokeRestart("muffleWarning")
[16:13:04.130]                       }
[16:13:04.130]                       else if (inherits(cond, "condition")) {
[16:13:04.130]                         if (!is.null(pattern)) {
[16:13:04.130]                           computeRestarts <- base::computeRestarts
[16:13:04.130]                           grepl <- base::grepl
[16:13:04.130]                           restarts <- computeRestarts(cond)
[16:13:04.130]                           for (restart in restarts) {
[16:13:04.130]                             name <- restart$name
[16:13:04.130]                             if (is.null(name)) 
[16:13:04.130]                               next
[16:13:04.130]                             if (!grepl(pattern, name)) 
[16:13:04.130]                               next
[16:13:04.130]                             invokeRestart(restart)
[16:13:04.130]                             muffled <- TRUE
[16:13:04.130]                             break
[16:13:04.130]                           }
[16:13:04.130]                         }
[16:13:04.130]                       }
[16:13:04.130]                       invisible(muffled)
[16:13:04.130]                     }
[16:13:04.130]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.130]                   }
[16:13:04.130]                 }
[16:13:04.130]                 else {
[16:13:04.130]                   if (TRUE) {
[16:13:04.130]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.130]                     {
[16:13:04.130]                       inherits <- base::inherits
[16:13:04.130]                       invokeRestart <- base::invokeRestart
[16:13:04.130]                       is.null <- base::is.null
[16:13:04.130]                       muffled <- FALSE
[16:13:04.130]                       if (inherits(cond, "message")) {
[16:13:04.130]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.130]                         if (muffled) 
[16:13:04.130]                           invokeRestart("muffleMessage")
[16:13:04.130]                       }
[16:13:04.130]                       else if (inherits(cond, "warning")) {
[16:13:04.130]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.130]                         if (muffled) 
[16:13:04.130]                           invokeRestart("muffleWarning")
[16:13:04.130]                       }
[16:13:04.130]                       else if (inherits(cond, "condition")) {
[16:13:04.130]                         if (!is.null(pattern)) {
[16:13:04.130]                           computeRestarts <- base::computeRestarts
[16:13:04.130]                           grepl <- base::grepl
[16:13:04.130]                           restarts <- computeRestarts(cond)
[16:13:04.130]                           for (restart in restarts) {
[16:13:04.130]                             name <- restart$name
[16:13:04.130]                             if (is.null(name)) 
[16:13:04.130]                               next
[16:13:04.130]                             if (!grepl(pattern, name)) 
[16:13:04.130]                               next
[16:13:04.130]                             invokeRestart(restart)
[16:13:04.130]                             muffled <- TRUE
[16:13:04.130]                             break
[16:13:04.130]                           }
[16:13:04.130]                         }
[16:13:04.130]                       }
[16:13:04.130]                       invisible(muffled)
[16:13:04.130]                     }
[16:13:04.130]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.130]                   }
[16:13:04.130]                 }
[16:13:04.130]             }
[16:13:04.130]         }))
[16:13:04.130]     }, error = function(ex) {
[16:13:04.130]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:04.130]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.130]                 ...future.rng), started = ...future.startTime, 
[16:13:04.130]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:04.130]             version = "1.8"), class = "FutureResult")
[16:13:04.130]     }, finally = {
[16:13:04.130]         if (!identical(...future.workdir, getwd())) 
[16:13:04.130]             setwd(...future.workdir)
[16:13:04.130]         {
[16:13:04.130]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:04.130]                 ...future.oldOptions$nwarnings <- NULL
[16:13:04.130]             }
[16:13:04.130]             base::options(...future.oldOptions)
[16:13:04.130]             if (.Platform$OS.type == "windows") {
[16:13:04.130]                 old_names <- names(...future.oldEnvVars)
[16:13:04.130]                 envs <- base::Sys.getenv()
[16:13:04.130]                 names <- names(envs)
[16:13:04.130]                 common <- intersect(names, old_names)
[16:13:04.130]                 added <- setdiff(names, old_names)
[16:13:04.130]                 removed <- setdiff(old_names, names)
[16:13:04.130]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:04.130]                   envs[common]]
[16:13:04.130]                 NAMES <- toupper(changed)
[16:13:04.130]                 args <- list()
[16:13:04.130]                 for (kk in seq_along(NAMES)) {
[16:13:04.130]                   name <- changed[[kk]]
[16:13:04.130]                   NAME <- NAMES[[kk]]
[16:13:04.130]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.130]                     next
[16:13:04.130]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.130]                 }
[16:13:04.130]                 NAMES <- toupper(added)
[16:13:04.130]                 for (kk in seq_along(NAMES)) {
[16:13:04.130]                   name <- added[[kk]]
[16:13:04.130]                   NAME <- NAMES[[kk]]
[16:13:04.130]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.130]                     next
[16:13:04.130]                   args[[name]] <- ""
[16:13:04.130]                 }
[16:13:04.130]                 NAMES <- toupper(removed)
[16:13:04.130]                 for (kk in seq_along(NAMES)) {
[16:13:04.130]                   name <- removed[[kk]]
[16:13:04.130]                   NAME <- NAMES[[kk]]
[16:13:04.130]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.130]                     next
[16:13:04.130]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.130]                 }
[16:13:04.130]                 if (length(args) > 0) 
[16:13:04.130]                   base::do.call(base::Sys.setenv, args = args)
[16:13:04.130]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:04.130]             }
[16:13:04.130]             else {
[16:13:04.130]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:04.130]             }
[16:13:04.130]             {
[16:13:04.130]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:04.130]                   0L) {
[16:13:04.130]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:04.130]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:04.130]                   base::options(opts)
[16:13:04.130]                 }
[16:13:04.130]                 {
[16:13:04.130]                   {
[16:13:04.130]                     NULL
[16:13:04.130]                     RNGkind("Mersenne-Twister")
[16:13:04.130]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:04.130]                       inherits = FALSE)
[16:13:04.130]                   }
[16:13:04.130]                   options(future.plan = NULL)
[16:13:04.130]                   if (is.na(NA_character_)) 
[16:13:04.130]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.130]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:04.130]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:04.130]                     envir = parent.frame()) 
[16:13:04.130]                   {
[16:13:04.130]                     default_workers <- missing(workers)
[16:13:04.130]                     if (is.function(workers)) 
[16:13:04.130]                       workers <- workers()
[16:13:04.130]                     workers <- structure(as.integer(workers), 
[16:13:04.130]                       class = class(workers))
[16:13:04.130]                     stop_if_not(is.finite(workers), workers >= 
[16:13:04.130]                       1L)
[16:13:04.130]                     if ((workers == 1L && !inherits(workers, 
[16:13:04.130]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:04.130]                       if (default_workers) 
[16:13:04.130]                         supportsMulticore(warn = TRUE)
[16:13:04.130]                       return(sequential(..., envir = envir))
[16:13:04.130]                     }
[16:13:04.130]                     oopts <- options(mc.cores = workers)
[16:13:04.130]                     on.exit(options(oopts))
[16:13:04.130]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:04.130]                       envir = envir)
[16:13:04.130]                     if (!future$lazy) 
[16:13:04.130]                       future <- run(future)
[16:13:04.130]                     invisible(future)
[16:13:04.130]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:04.130]                 }
[16:13:04.130]             }
[16:13:04.130]         }
[16:13:04.130]     })
[16:13:04.130]     if (TRUE) {
[16:13:04.130]         base::sink(type = "output", split = FALSE)
[16:13:04.130]         if (TRUE) {
[16:13:04.130]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:04.130]         }
[16:13:04.130]         else {
[16:13:04.130]             ...future.result["stdout"] <- base::list(NULL)
[16:13:04.130]         }
[16:13:04.130]         base::close(...future.stdout)
[16:13:04.130]         ...future.stdout <- NULL
[16:13:04.130]     }
[16:13:04.130]     ...future.result$conditions <- ...future.conditions
[16:13:04.130]     ...future.result$finished <- base::Sys.time()
[16:13:04.130]     ...future.result
[16:13:04.130] }
[16:13:04.132] plan(): Setting new future strategy stack:
[16:13:04.132] List of future strategies:
[16:13:04.132] 1. sequential:
[16:13:04.132]    - args: function (..., envir = parent.frame())
[16:13:04.132]    - tweaked: FALSE
[16:13:04.132]    - call: NULL
[16:13:04.133] plan(): nbrOfWorkers() = 1
[16:13:04.133] plan(): Setting new future strategy stack:
[16:13:04.133] List of future strategies:
[16:13:04.133] 1. multicore:
[16:13:04.133]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:04.133]    - tweaked: FALSE
[16:13:04.133]    - call: plan(multicore)
[16:13:04.137] plan(): nbrOfWorkers() = 1
[16:13:04.137] SequentialFuture started (and completed)
 - Resolving 4 multicore futures
*** multicore(..., globals = FALSE) and errors
[16:13:04.141] getGlobalsAndPackages() ...
[16:13:04.141] Not searching for globals
[16:13:04.141] - globals: [0] <none>
[16:13:04.141] getGlobalsAndPackages() ... DONE
[16:13:04.142] Packages needed by the future expression (n = 0): <none>
[16:13:04.142] Packages needed by future strategies (n = 0): <none>
[16:13:04.142] {
[16:13:04.142]     {
[16:13:04.142]         {
[16:13:04.142]             ...future.startTime <- base::Sys.time()
[16:13:04.142]             {
[16:13:04.142]                 {
[16:13:04.142]                   {
[16:13:04.142]                     base::local({
[16:13:04.142]                       has_future <- base::requireNamespace("future", 
[16:13:04.142]                         quietly = TRUE)
[16:13:04.142]                       if (has_future) {
[16:13:04.142]                         ns <- base::getNamespace("future")
[16:13:04.142]                         version <- ns[[".package"]][["version"]]
[16:13:04.142]                         if (is.null(version)) 
[16:13:04.142]                           version <- utils::packageVersion("future")
[16:13:04.142]                       }
[16:13:04.142]                       else {
[16:13:04.142]                         version <- NULL
[16:13:04.142]                       }
[16:13:04.142]                       if (!has_future || version < "1.8.0") {
[16:13:04.142]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:04.142]                           "", base::R.version$version.string), 
[16:13:04.142]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:04.142]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:04.142]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:04.142]                             "release", "version")], collapse = " "), 
[16:13:04.142]                           hostname = base::Sys.info()[["nodename"]])
[16:13:04.142]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:04.142]                           info)
[16:13:04.142]                         info <- base::paste(info, collapse = "; ")
[16:13:04.142]                         if (!has_future) {
[16:13:04.142]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:04.142]                             info)
[16:13:04.142]                         }
[16:13:04.142]                         else {
[16:13:04.142]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:04.142]                             info, version)
[16:13:04.142]                         }
[16:13:04.142]                         base::stop(msg)
[16:13:04.142]                       }
[16:13:04.142]                     })
[16:13:04.142]                   }
[16:13:04.142]                   options(future.plan = NULL)
[16:13:04.142]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.142]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:04.142]                 }
[16:13:04.142]                 ...future.workdir <- getwd()
[16:13:04.142]             }
[16:13:04.142]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:04.142]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:04.142]         }
[16:13:04.142]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:04.142]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:04.142]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:04.142]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:04.142]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:04.142]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:04.142]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:04.142]             base::names(...future.oldOptions))
[16:13:04.142]     }
[16:13:04.142]     if (FALSE) {
[16:13:04.142]     }
[16:13:04.142]     else {
[16:13:04.142]         if (TRUE) {
[16:13:04.142]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:04.142]                 open = "w")
[16:13:04.142]         }
[16:13:04.142]         else {
[16:13:04.142]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:04.142]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:04.142]         }
[16:13:04.142]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:04.142]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:04.142]             base::sink(type = "output", split = FALSE)
[16:13:04.142]             base::close(...future.stdout)
[16:13:04.142]         }, add = TRUE)
[16:13:04.142]     }
[16:13:04.142]     ...future.frame <- base::sys.nframe()
[16:13:04.142]     ...future.conditions <- base::list()
[16:13:04.142]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:04.142]     if (FALSE) {
[16:13:04.142]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:04.142]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:04.142]     }
[16:13:04.142]     ...future.result <- base::tryCatch({
[16:13:04.142]         base::withCallingHandlers({
[16:13:04.142]             ...future.value <- base::withVisible(base::local({
[16:13:04.142]                 stop("Whoops!")
[16:13:04.142]                 1
[16:13:04.142]             }))
[16:13:04.142]             future::FutureResult(value = ...future.value$value, 
[16:13:04.142]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.142]                   ...future.rng), globalenv = if (FALSE) 
[16:13:04.142]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:04.142]                     ...future.globalenv.names))
[16:13:04.142]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:04.142]         }, condition = base::local({
[16:13:04.142]             c <- base::c
[16:13:04.142]             inherits <- base::inherits
[16:13:04.142]             invokeRestart <- base::invokeRestart
[16:13:04.142]             length <- base::length
[16:13:04.142]             list <- base::list
[16:13:04.142]             seq.int <- base::seq.int
[16:13:04.142]             signalCondition <- base::signalCondition
[16:13:04.142]             sys.calls <- base::sys.calls
[16:13:04.142]             `[[` <- base::`[[`
[16:13:04.142]             `+` <- base::`+`
[16:13:04.142]             `<<-` <- base::`<<-`
[16:13:04.142]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:04.142]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:04.142]                   3L)]
[16:13:04.142]             }
[16:13:04.142]             function(cond) {
[16:13:04.142]                 is_error <- inherits(cond, "error")
[16:13:04.142]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:04.142]                   NULL)
[16:13:04.142]                 if (is_error) {
[16:13:04.142]                   sessionInformation <- function() {
[16:13:04.142]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:04.142]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:04.142]                       search = base::search(), system = base::Sys.info())
[16:13:04.142]                   }
[16:13:04.142]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.142]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:04.142]                     cond$call), session = sessionInformation(), 
[16:13:04.142]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:04.142]                   signalCondition(cond)
[16:13:04.142]                 }
[16:13:04.142]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:04.142]                 "immediateCondition"))) {
[16:13:04.142]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:04.142]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.142]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:04.142]                   if (TRUE && !signal) {
[16:13:04.142]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.142]                     {
[16:13:04.142]                       inherits <- base::inherits
[16:13:04.142]                       invokeRestart <- base::invokeRestart
[16:13:04.142]                       is.null <- base::is.null
[16:13:04.142]                       muffled <- FALSE
[16:13:04.142]                       if (inherits(cond, "message")) {
[16:13:04.142]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.142]                         if (muffled) 
[16:13:04.142]                           invokeRestart("muffleMessage")
[16:13:04.142]                       }
[16:13:04.142]                       else if (inherits(cond, "warning")) {
[16:13:04.142]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.142]                         if (muffled) 
[16:13:04.142]                           invokeRestart("muffleWarning")
[16:13:04.142]                       }
[16:13:04.142]                       else if (inherits(cond, "condition")) {
[16:13:04.142]                         if (!is.null(pattern)) {
[16:13:04.142]                           computeRestarts <- base::computeRestarts
[16:13:04.142]                           grepl <- base::grepl
[16:13:04.142]                           restarts <- computeRestarts(cond)
[16:13:04.142]                           for (restart in restarts) {
[16:13:04.142]                             name <- restart$name
[16:13:04.142]                             if (is.null(name)) 
[16:13:04.142]                               next
[16:13:04.142]                             if (!grepl(pattern, name)) 
[16:13:04.142]                               next
[16:13:04.142]                             invokeRestart(restart)
[16:13:04.142]                             muffled <- TRUE
[16:13:04.142]                             break
[16:13:04.142]                           }
[16:13:04.142]                         }
[16:13:04.142]                       }
[16:13:04.142]                       invisible(muffled)
[16:13:04.142]                     }
[16:13:04.142]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.142]                   }
[16:13:04.142]                 }
[16:13:04.142]                 else {
[16:13:04.142]                   if (TRUE) {
[16:13:04.142]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.142]                     {
[16:13:04.142]                       inherits <- base::inherits
[16:13:04.142]                       invokeRestart <- base::invokeRestart
[16:13:04.142]                       is.null <- base::is.null
[16:13:04.142]                       muffled <- FALSE
[16:13:04.142]                       if (inherits(cond, "message")) {
[16:13:04.142]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.142]                         if (muffled) 
[16:13:04.142]                           invokeRestart("muffleMessage")
[16:13:04.142]                       }
[16:13:04.142]                       else if (inherits(cond, "warning")) {
[16:13:04.142]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.142]                         if (muffled) 
[16:13:04.142]                           invokeRestart("muffleWarning")
[16:13:04.142]                       }
[16:13:04.142]                       else if (inherits(cond, "condition")) {
[16:13:04.142]                         if (!is.null(pattern)) {
[16:13:04.142]                           computeRestarts <- base::computeRestarts
[16:13:04.142]                           grepl <- base::grepl
[16:13:04.142]                           restarts <- computeRestarts(cond)
[16:13:04.142]                           for (restart in restarts) {
[16:13:04.142]                             name <- restart$name
[16:13:04.142]                             if (is.null(name)) 
[16:13:04.142]                               next
[16:13:04.142]                             if (!grepl(pattern, name)) 
[16:13:04.142]                               next
[16:13:04.142]                             invokeRestart(restart)
[16:13:04.142]                             muffled <- TRUE
[16:13:04.142]                             break
[16:13:04.142]                           }
[16:13:04.142]                         }
[16:13:04.142]                       }
[16:13:04.142]                       invisible(muffled)
[16:13:04.142]                     }
[16:13:04.142]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.142]                   }
[16:13:04.142]                 }
[16:13:04.142]             }
[16:13:04.142]         }))
[16:13:04.142]     }, error = function(ex) {
[16:13:04.142]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:04.142]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.142]                 ...future.rng), started = ...future.startTime, 
[16:13:04.142]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:04.142]             version = "1.8"), class = "FutureResult")
[16:13:04.142]     }, finally = {
[16:13:04.142]         if (!identical(...future.workdir, getwd())) 
[16:13:04.142]             setwd(...future.workdir)
[16:13:04.142]         {
[16:13:04.142]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:04.142]                 ...future.oldOptions$nwarnings <- NULL
[16:13:04.142]             }
[16:13:04.142]             base::options(...future.oldOptions)
[16:13:04.142]             if (.Platform$OS.type == "windows") {
[16:13:04.142]                 old_names <- names(...future.oldEnvVars)
[16:13:04.142]                 envs <- base::Sys.getenv()
[16:13:04.142]                 names <- names(envs)
[16:13:04.142]                 common <- intersect(names, old_names)
[16:13:04.142]                 added <- setdiff(names, old_names)
[16:13:04.142]                 removed <- setdiff(old_names, names)
[16:13:04.142]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:04.142]                   envs[common]]
[16:13:04.142]                 NAMES <- toupper(changed)
[16:13:04.142]                 args <- list()
[16:13:04.142]                 for (kk in seq_along(NAMES)) {
[16:13:04.142]                   name <- changed[[kk]]
[16:13:04.142]                   NAME <- NAMES[[kk]]
[16:13:04.142]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.142]                     next
[16:13:04.142]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.142]                 }
[16:13:04.142]                 NAMES <- toupper(added)
[16:13:04.142]                 for (kk in seq_along(NAMES)) {
[16:13:04.142]                   name <- added[[kk]]
[16:13:04.142]                   NAME <- NAMES[[kk]]
[16:13:04.142]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.142]                     next
[16:13:04.142]                   args[[name]] <- ""
[16:13:04.142]                 }
[16:13:04.142]                 NAMES <- toupper(removed)
[16:13:04.142]                 for (kk in seq_along(NAMES)) {
[16:13:04.142]                   name <- removed[[kk]]
[16:13:04.142]                   NAME <- NAMES[[kk]]
[16:13:04.142]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.142]                     next
[16:13:04.142]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.142]                 }
[16:13:04.142]                 if (length(args) > 0) 
[16:13:04.142]                   base::do.call(base::Sys.setenv, args = args)
[16:13:04.142]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:04.142]             }
[16:13:04.142]             else {
[16:13:04.142]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:04.142]             }
[16:13:04.142]             {
[16:13:04.142]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:04.142]                   0L) {
[16:13:04.142]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:04.142]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:04.142]                   base::options(opts)
[16:13:04.142]                 }
[16:13:04.142]                 {
[16:13:04.142]                   {
[16:13:04.142]                     NULL
[16:13:04.142]                     RNGkind("Mersenne-Twister")
[16:13:04.142]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:04.142]                       inherits = FALSE)
[16:13:04.142]                   }
[16:13:04.142]                   options(future.plan = NULL)
[16:13:04.142]                   if (is.na(NA_character_)) 
[16:13:04.142]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.142]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:04.142]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:04.142]                     envir = parent.frame()) 
[16:13:04.142]                   {
[16:13:04.142]                     default_workers <- missing(workers)
[16:13:04.142]                     if (is.function(workers)) 
[16:13:04.142]                       workers <- workers()
[16:13:04.142]                     workers <- structure(as.integer(workers), 
[16:13:04.142]                       class = class(workers))
[16:13:04.142]                     stop_if_not(is.finite(workers), workers >= 
[16:13:04.142]                       1L)
[16:13:04.142]                     if ((workers == 1L && !inherits(workers, 
[16:13:04.142]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:04.142]                       if (default_workers) 
[16:13:04.142]                         supportsMulticore(warn = TRUE)
[16:13:04.142]                       return(sequential(..., envir = envir))
[16:13:04.142]                     }
[16:13:04.142]                     oopts <- options(mc.cores = workers)
[16:13:04.142]                     on.exit(options(oopts))
[16:13:04.142]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:04.142]                       envir = envir)
[16:13:04.142]                     if (!future$lazy) 
[16:13:04.142]                       future <- run(future)
[16:13:04.142]                     invisible(future)
[16:13:04.142]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:04.142]                 }
[16:13:04.142]             }
[16:13:04.142]         }
[16:13:04.142]     })
[16:13:04.142]     if (TRUE) {
[16:13:04.142]         base::sink(type = "output", split = FALSE)
[16:13:04.142]         if (TRUE) {
[16:13:04.142]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:04.142]         }
[16:13:04.142]         else {
[16:13:04.142]             ...future.result["stdout"] <- base::list(NULL)
[16:13:04.142]         }
[16:13:04.142]         base::close(...future.stdout)
[16:13:04.142]         ...future.stdout <- NULL
[16:13:04.142]     }
[16:13:04.142]     ...future.result$conditions <- ...future.conditions
[16:13:04.142]     ...future.result$finished <- base::Sys.time()
[16:13:04.142]     ...future.result
[16:13:04.142] }
[16:13:04.144] plan(): Setting new future strategy stack:
[16:13:04.144] List of future strategies:
[16:13:04.144] 1. sequential:
[16:13:04.144]    - args: function (..., envir = parent.frame())
[16:13:04.144]    - tweaked: FALSE
[16:13:04.144]    - call: NULL
[16:13:04.144] plan(): nbrOfWorkers() = 1
[16:13:04.145] plan(): Setting new future strategy stack:
[16:13:04.145] List of future strategies:
[16:13:04.145] 1. multicore:
[16:13:04.145]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:04.145]    - tweaked: FALSE
[16:13:04.145]    - call: plan(multicore)
[16:13:04.149] plan(): nbrOfWorkers() = 1
[16:13:04.149] SequentialFuture started (and completed)
[16:13:04.149] signalConditions() ...
[16:13:04.151]  - include = ‘immediateCondition’
[16:13:04.151]  - exclude = 
[16:13:04.151]  - resignal = FALSE
[16:13:04.151]  - Number of conditions: 1
[16:13:04.151] signalConditions() ... done
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 0 bytes of class ‘NULL’
Conditions captured: [n=1] ‘simpleError’
Early signaling: FALSE
Owner process: 9cd5072f-68f7-e4f0-6d65-cff53a745767
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:04.152] signalConditions() ...
[16:13:04.152]  - include = ‘immediateCondition’
[16:13:04.152]  - exclude = 
[16:13:04.152]  - resignal = FALSE
[16:13:04.152]  - Number of conditions: 1
[16:13:04.152] signalConditions() ... done
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[16:13:04.153] signalConditions() ...
[16:13:04.153]  - include = ‘immediateCondition’
[16:13:04.153]  - exclude = 
[16:13:04.153]  - resignal = FALSE
[16:13:04.153]  - Number of conditions: 1
[16:13:04.153] signalConditions() ... done
[16:13:04.153] Future state: ‘finished’
[16:13:04.153] signalConditions() ...
[16:13:04.153]  - include = ‘condition’
[16:13:04.153]  - exclude = ‘immediateCondition’
[16:13:04.154]  - resignal = TRUE
[16:13:04.154]  - Number of conditions: 1
[16:13:04.154]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:13:04.154] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[16:13:04.154] signalConditions() ...
[16:13:04.154]  - include = ‘immediateCondition’
[16:13:04.154]  - exclude = 
[16:13:04.154]  - resignal = FALSE
[16:13:04.155]  - Number of conditions: 1
[16:13:04.155] signalConditions() ... done
[16:13:04.155] Future state: ‘finished’
[16:13:04.155] signalConditions() ...
[16:13:04.155]  - include = ‘condition’
[16:13:04.155]  - exclude = ‘immediateCondition’
[16:13:04.155]  - resignal = TRUE
[16:13:04.155]  - Number of conditions: 1
[16:13:04.155]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:13:04.155] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[16:13:04.159] getGlobalsAndPackages() ...
[16:13:04.159] Searching for globals...
[16:13:04.166] - globals found: [5] ‘{’, ‘stop’, ‘structure’, ‘list’, ‘c’
[16:13:04.166] Searching for globals ... DONE
[16:13:04.166] Resolving globals: FALSE
[16:13:04.167] 
[16:13:04.167] 
[16:13:04.167] getGlobalsAndPackages() ... DONE
[16:13:04.167] Packages needed by the future expression (n = 0): <none>
[16:13:04.167] Packages needed by future strategies (n = 0): <none>
[16:13:04.168] {
[16:13:04.168]     {
[16:13:04.168]         {
[16:13:04.168]             ...future.startTime <- base::Sys.time()
[16:13:04.168]             {
[16:13:04.168]                 {
[16:13:04.168]                   {
[16:13:04.168]                     base::local({
[16:13:04.168]                       has_future <- base::requireNamespace("future", 
[16:13:04.168]                         quietly = TRUE)
[16:13:04.168]                       if (has_future) {
[16:13:04.168]                         ns <- base::getNamespace("future")
[16:13:04.168]                         version <- ns[[".package"]][["version"]]
[16:13:04.168]                         if (is.null(version)) 
[16:13:04.168]                           version <- utils::packageVersion("future")
[16:13:04.168]                       }
[16:13:04.168]                       else {
[16:13:04.168]                         version <- NULL
[16:13:04.168]                       }
[16:13:04.168]                       if (!has_future || version < "1.8.0") {
[16:13:04.168]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:04.168]                           "", base::R.version$version.string), 
[16:13:04.168]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:04.168]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:04.168]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:04.168]                             "release", "version")], collapse = " "), 
[16:13:04.168]                           hostname = base::Sys.info()[["nodename"]])
[16:13:04.168]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:04.168]                           info)
[16:13:04.168]                         info <- base::paste(info, collapse = "; ")
[16:13:04.168]                         if (!has_future) {
[16:13:04.168]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:04.168]                             info)
[16:13:04.168]                         }
[16:13:04.168]                         else {
[16:13:04.168]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:04.168]                             info, version)
[16:13:04.168]                         }
[16:13:04.168]                         base::stop(msg)
[16:13:04.168]                       }
[16:13:04.168]                     })
[16:13:04.168]                   }
[16:13:04.168]                   options(future.plan = NULL)
[16:13:04.168]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.168]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:04.168]                 }
[16:13:04.168]                 ...future.workdir <- getwd()
[16:13:04.168]             }
[16:13:04.168]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:04.168]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:04.168]         }
[16:13:04.168]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:04.168]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:04.168]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:04.168]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:04.168]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:04.168]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:04.168]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:04.168]             base::names(...future.oldOptions))
[16:13:04.168]     }
[16:13:04.168]     if (FALSE) {
[16:13:04.168]     }
[16:13:04.168]     else {
[16:13:04.168]         if (TRUE) {
[16:13:04.168]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:04.168]                 open = "w")
[16:13:04.168]         }
[16:13:04.168]         else {
[16:13:04.168]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:04.168]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:04.168]         }
[16:13:04.168]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:04.168]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:04.168]             base::sink(type = "output", split = FALSE)
[16:13:04.168]             base::close(...future.stdout)
[16:13:04.168]         }, add = TRUE)
[16:13:04.168]     }
[16:13:04.168]     ...future.frame <- base::sys.nframe()
[16:13:04.168]     ...future.conditions <- base::list()
[16:13:04.168]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:04.168]     if (FALSE) {
[16:13:04.168]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:04.168]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:04.168]     }
[16:13:04.168]     ...future.result <- base::tryCatch({
[16:13:04.168]         base::withCallingHandlers({
[16:13:04.168]             ...future.value <- base::withVisible(base::local({
[16:13:04.168]                 stop(structure(list(message = "boom"), class = c("MyError", 
[16:13:04.168]                   "error", "condition")))
[16:13:04.168]             }))
[16:13:04.168]             future::FutureResult(value = ...future.value$value, 
[16:13:04.168]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.168]                   ...future.rng), globalenv = if (FALSE) 
[16:13:04.168]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:04.168]                     ...future.globalenv.names))
[16:13:04.168]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:04.168]         }, condition = base::local({
[16:13:04.168]             c <- base::c
[16:13:04.168]             inherits <- base::inherits
[16:13:04.168]             invokeRestart <- base::invokeRestart
[16:13:04.168]             length <- base::length
[16:13:04.168]             list <- base::list
[16:13:04.168]             seq.int <- base::seq.int
[16:13:04.168]             signalCondition <- base::signalCondition
[16:13:04.168]             sys.calls <- base::sys.calls
[16:13:04.168]             `[[` <- base::`[[`
[16:13:04.168]             `+` <- base::`+`
[16:13:04.168]             `<<-` <- base::`<<-`
[16:13:04.168]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:04.168]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:04.168]                   3L)]
[16:13:04.168]             }
[16:13:04.168]             function(cond) {
[16:13:04.168]                 is_error <- inherits(cond, "error")
[16:13:04.168]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:04.168]                   NULL)
[16:13:04.168]                 if (is_error) {
[16:13:04.168]                   sessionInformation <- function() {
[16:13:04.168]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:04.168]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:04.168]                       search = base::search(), system = base::Sys.info())
[16:13:04.168]                   }
[16:13:04.168]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.168]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:04.168]                     cond$call), session = sessionInformation(), 
[16:13:04.168]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:04.168]                   signalCondition(cond)
[16:13:04.168]                 }
[16:13:04.168]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:04.168]                 "immediateCondition"))) {
[16:13:04.168]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:04.168]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.168]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:04.168]                   if (TRUE && !signal) {
[16:13:04.168]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.168]                     {
[16:13:04.168]                       inherits <- base::inherits
[16:13:04.168]                       invokeRestart <- base::invokeRestart
[16:13:04.168]                       is.null <- base::is.null
[16:13:04.168]                       muffled <- FALSE
[16:13:04.168]                       if (inherits(cond, "message")) {
[16:13:04.168]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.168]                         if (muffled) 
[16:13:04.168]                           invokeRestart("muffleMessage")
[16:13:04.168]                       }
[16:13:04.168]                       else if (inherits(cond, "warning")) {
[16:13:04.168]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.168]                         if (muffled) 
[16:13:04.168]                           invokeRestart("muffleWarning")
[16:13:04.168]                       }
[16:13:04.168]                       else if (inherits(cond, "condition")) {
[16:13:04.168]                         if (!is.null(pattern)) {
[16:13:04.168]                           computeRestarts <- base::computeRestarts
[16:13:04.168]                           grepl <- base::grepl
[16:13:04.168]                           restarts <- computeRestarts(cond)
[16:13:04.168]                           for (restart in restarts) {
[16:13:04.168]                             name <- restart$name
[16:13:04.168]                             if (is.null(name)) 
[16:13:04.168]                               next
[16:13:04.168]                             if (!grepl(pattern, name)) 
[16:13:04.168]                               next
[16:13:04.168]                             invokeRestart(restart)
[16:13:04.168]                             muffled <- TRUE
[16:13:04.168]                             break
[16:13:04.168]                           }
[16:13:04.168]                         }
[16:13:04.168]                       }
[16:13:04.168]                       invisible(muffled)
[16:13:04.168]                     }
[16:13:04.168]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.168]                   }
[16:13:04.168]                 }
[16:13:04.168]                 else {
[16:13:04.168]                   if (TRUE) {
[16:13:04.168]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.168]                     {
[16:13:04.168]                       inherits <- base::inherits
[16:13:04.168]                       invokeRestart <- base::invokeRestart
[16:13:04.168]                       is.null <- base::is.null
[16:13:04.168]                       muffled <- FALSE
[16:13:04.168]                       if (inherits(cond, "message")) {
[16:13:04.168]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.168]                         if (muffled) 
[16:13:04.168]                           invokeRestart("muffleMessage")
[16:13:04.168]                       }
[16:13:04.168]                       else if (inherits(cond, "warning")) {
[16:13:04.168]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.168]                         if (muffled) 
[16:13:04.168]                           invokeRestart("muffleWarning")
[16:13:04.168]                       }
[16:13:04.168]                       else if (inherits(cond, "condition")) {
[16:13:04.168]                         if (!is.null(pattern)) {
[16:13:04.168]                           computeRestarts <- base::computeRestarts
[16:13:04.168]                           grepl <- base::grepl
[16:13:04.168]                           restarts <- computeRestarts(cond)
[16:13:04.168]                           for (restart in restarts) {
[16:13:04.168]                             name <- restart$name
[16:13:04.168]                             if (is.null(name)) 
[16:13:04.168]                               next
[16:13:04.168]                             if (!grepl(pattern, name)) 
[16:13:04.168]                               next
[16:13:04.168]                             invokeRestart(restart)
[16:13:04.168]                             muffled <- TRUE
[16:13:04.168]                             break
[16:13:04.168]                           }
[16:13:04.168]                         }
[16:13:04.168]                       }
[16:13:04.168]                       invisible(muffled)
[16:13:04.168]                     }
[16:13:04.168]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.168]                   }
[16:13:04.168]                 }
[16:13:04.168]             }
[16:13:04.168]         }))
[16:13:04.168]     }, error = function(ex) {
[16:13:04.168]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:04.168]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.168]                 ...future.rng), started = ...future.startTime, 
[16:13:04.168]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:04.168]             version = "1.8"), class = "FutureResult")
[16:13:04.168]     }, finally = {
[16:13:04.168]         if (!identical(...future.workdir, getwd())) 
[16:13:04.168]             setwd(...future.workdir)
[16:13:04.168]         {
[16:13:04.168]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:04.168]                 ...future.oldOptions$nwarnings <- NULL
[16:13:04.168]             }
[16:13:04.168]             base::options(...future.oldOptions)
[16:13:04.168]             if (.Platform$OS.type == "windows") {
[16:13:04.168]                 old_names <- names(...future.oldEnvVars)
[16:13:04.168]                 envs <- base::Sys.getenv()
[16:13:04.168]                 names <- names(envs)
[16:13:04.168]                 common <- intersect(names, old_names)
[16:13:04.168]                 added <- setdiff(names, old_names)
[16:13:04.168]                 removed <- setdiff(old_names, names)
[16:13:04.168]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:04.168]                   envs[common]]
[16:13:04.168]                 NAMES <- toupper(changed)
[16:13:04.168]                 args <- list()
[16:13:04.168]                 for (kk in seq_along(NAMES)) {
[16:13:04.168]                   name <- changed[[kk]]
[16:13:04.168]                   NAME <- NAMES[[kk]]
[16:13:04.168]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.168]                     next
[16:13:04.168]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.168]                 }
[16:13:04.168]                 NAMES <- toupper(added)
[16:13:04.168]                 for (kk in seq_along(NAMES)) {
[16:13:04.168]                   name <- added[[kk]]
[16:13:04.168]                   NAME <- NAMES[[kk]]
[16:13:04.168]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.168]                     next
[16:13:04.168]                   args[[name]] <- ""
[16:13:04.168]                 }
[16:13:04.168]                 NAMES <- toupper(removed)
[16:13:04.168]                 for (kk in seq_along(NAMES)) {
[16:13:04.168]                   name <- removed[[kk]]
[16:13:04.168]                   NAME <- NAMES[[kk]]
[16:13:04.168]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.168]                     next
[16:13:04.168]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.168]                 }
[16:13:04.168]                 if (length(args) > 0) 
[16:13:04.168]                   base::do.call(base::Sys.setenv, args = args)
[16:13:04.168]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:04.168]             }
[16:13:04.168]             else {
[16:13:04.168]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:04.168]             }
[16:13:04.168]             {
[16:13:04.168]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:04.168]                   0L) {
[16:13:04.168]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:04.168]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:04.168]                   base::options(opts)
[16:13:04.168]                 }
[16:13:04.168]                 {
[16:13:04.168]                   {
[16:13:04.168]                     NULL
[16:13:04.168]                     RNGkind("Mersenne-Twister")
[16:13:04.168]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:04.168]                       inherits = FALSE)
[16:13:04.168]                   }
[16:13:04.168]                   options(future.plan = NULL)
[16:13:04.168]                   if (is.na(NA_character_)) 
[16:13:04.168]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.168]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:04.168]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:04.168]                     envir = parent.frame()) 
[16:13:04.168]                   {
[16:13:04.168]                     default_workers <- missing(workers)
[16:13:04.168]                     if (is.function(workers)) 
[16:13:04.168]                       workers <- workers()
[16:13:04.168]                     workers <- structure(as.integer(workers), 
[16:13:04.168]                       class = class(workers))
[16:13:04.168]                     stop_if_not(is.finite(workers), workers >= 
[16:13:04.168]                       1L)
[16:13:04.168]                     if ((workers == 1L && !inherits(workers, 
[16:13:04.168]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:04.168]                       if (default_workers) 
[16:13:04.168]                         supportsMulticore(warn = TRUE)
[16:13:04.168]                       return(sequential(..., envir = envir))
[16:13:04.168]                     }
[16:13:04.168]                     oopts <- options(mc.cores = workers)
[16:13:04.168]                     on.exit(options(oopts))
[16:13:04.168]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:04.168]                       envir = envir)
[16:13:04.168]                     if (!future$lazy) 
[16:13:04.168]                       future <- run(future)
[16:13:04.168]                     invisible(future)
[16:13:04.168]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:04.168]                 }
[16:13:04.168]             }
[16:13:04.168]         }
[16:13:04.168]     })
[16:13:04.168]     if (TRUE) {
[16:13:04.168]         base::sink(type = "output", split = FALSE)
[16:13:04.168]         if (TRUE) {
[16:13:04.168]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:04.168]         }
[16:13:04.168]         else {
[16:13:04.168]             ...future.result["stdout"] <- base::list(NULL)
[16:13:04.168]         }
[16:13:04.168]         base::close(...future.stdout)
[16:13:04.168]         ...future.stdout <- NULL
[16:13:04.168]     }
[16:13:04.168]     ...future.result$conditions <- ...future.conditions
[16:13:04.168]     ...future.result$finished <- base::Sys.time()
[16:13:04.168]     ...future.result
[16:13:04.168] }
[16:13:04.169] plan(): Setting new future strategy stack:
[16:13:04.169] List of future strategies:
[16:13:04.169] 1. sequential:
[16:13:04.169]    - args: function (..., envir = parent.frame())
[16:13:04.169]    - tweaked: FALSE
[16:13:04.169]    - call: NULL
[16:13:04.170] plan(): nbrOfWorkers() = 1
[16:13:04.171] plan(): Setting new future strategy stack:
[16:13:04.171] List of future strategies:
[16:13:04.171] 1. multicore:
[16:13:04.171]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:04.171]    - tweaked: FALSE
[16:13:04.171]    - call: plan(multicore)
[16:13:04.174] plan(): nbrOfWorkers() = 1
[16:13:04.174] SequentialFuture started (and completed)
[16:13:04.174] signalConditions() ...
[16:13:04.174]  - include = ‘immediateCondition’
[16:13:04.175]  - exclude = 
[16:13:04.175]  - resignal = FALSE
[16:13:04.175]  - Number of conditions: 1
[16:13:04.175] signalConditions() ... done
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 0 bytes of class ‘NULL’
Conditions captured: [n=1] ‘MyError’
Early signaling: FALSE
Owner process: 9cd5072f-68f7-e4f0-6d65-cff53a745767
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:04.175] signalConditions() ...
[16:13:04.176]  - include = ‘immediateCondition’
[16:13:04.176]  - exclude = 
[16:13:04.176]  - resignal = FALSE
[16:13:04.176]  - Number of conditions: 1
[16:13:04.176] signalConditions() ... done
<MyError: boom>
[16:13:04.176] signalConditions() ...
[16:13:04.176]  - include = ‘immediateCondition’
[16:13:04.176]  - exclude = 
[16:13:04.176]  - resignal = FALSE
[16:13:04.176]  - Number of conditions: 1
[16:13:04.177] signalConditions() ... done
[16:13:04.177] Future state: ‘finished’
[16:13:04.177] signalConditions() ...
[16:13:04.177]  - include = ‘condition’
[16:13:04.177]  - exclude = ‘immediateCondition’
[16:13:04.177]  - resignal = TRUE
[16:13:04.177]  - Number of conditions: 1
[16:13:04.177]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[16:13:04.177] signalConditions() ... done
*** multicore(..., globals = TRUE) without globals
[16:13:04.181] getGlobalsAndPackages() ...
[16:13:04.181] Searching for globals...
[16:13:04.181] - globals found: [1] ‘{’
[16:13:04.181] Searching for globals ... DONE
[16:13:04.182] Resolving globals: FALSE
[16:13:04.182] 
[16:13:04.182] 
[16:13:04.182] getGlobalsAndPackages() ... DONE
[16:13:04.182] Packages needed by the future expression (n = 0): <none>
[16:13:04.182] Packages needed by future strategies (n = 0): <none>
[16:13:04.183] {
[16:13:04.183]     {
[16:13:04.183]         {
[16:13:04.183]             ...future.startTime <- base::Sys.time()
[16:13:04.183]             {
[16:13:04.183]                 {
[16:13:04.183]                   {
[16:13:04.183]                     base::local({
[16:13:04.183]                       has_future <- base::requireNamespace("future", 
[16:13:04.183]                         quietly = TRUE)
[16:13:04.183]                       if (has_future) {
[16:13:04.183]                         ns <- base::getNamespace("future")
[16:13:04.183]                         version <- ns[[".package"]][["version"]]
[16:13:04.183]                         if (is.null(version)) 
[16:13:04.183]                           version <- utils::packageVersion("future")
[16:13:04.183]                       }
[16:13:04.183]                       else {
[16:13:04.183]                         version <- NULL
[16:13:04.183]                       }
[16:13:04.183]                       if (!has_future || version < "1.8.0") {
[16:13:04.183]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:04.183]                           "", base::R.version$version.string), 
[16:13:04.183]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:04.183]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:04.183]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:04.183]                             "release", "version")], collapse = " "), 
[16:13:04.183]                           hostname = base::Sys.info()[["nodename"]])
[16:13:04.183]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:04.183]                           info)
[16:13:04.183]                         info <- base::paste(info, collapse = "; ")
[16:13:04.183]                         if (!has_future) {
[16:13:04.183]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:04.183]                             info)
[16:13:04.183]                         }
[16:13:04.183]                         else {
[16:13:04.183]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:04.183]                             info, version)
[16:13:04.183]                         }
[16:13:04.183]                         base::stop(msg)
[16:13:04.183]                       }
[16:13:04.183]                     })
[16:13:04.183]                   }
[16:13:04.183]                   options(future.plan = NULL)
[16:13:04.183]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.183]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:04.183]                 }
[16:13:04.183]                 ...future.workdir <- getwd()
[16:13:04.183]             }
[16:13:04.183]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:04.183]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:04.183]         }
[16:13:04.183]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:04.183]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:04.183]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:04.183]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:04.183]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:04.183]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:04.183]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:04.183]             base::names(...future.oldOptions))
[16:13:04.183]     }
[16:13:04.183]     if (FALSE) {
[16:13:04.183]     }
[16:13:04.183]     else {
[16:13:04.183]         if (TRUE) {
[16:13:04.183]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:04.183]                 open = "w")
[16:13:04.183]         }
[16:13:04.183]         else {
[16:13:04.183]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:04.183]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:04.183]         }
[16:13:04.183]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:04.183]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:04.183]             base::sink(type = "output", split = FALSE)
[16:13:04.183]             base::close(...future.stdout)
[16:13:04.183]         }, add = TRUE)
[16:13:04.183]     }
[16:13:04.183]     ...future.frame <- base::sys.nframe()
[16:13:04.183]     ...future.conditions <- base::list()
[16:13:04.183]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:04.183]     if (FALSE) {
[16:13:04.183]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:04.183]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:04.183]     }
[16:13:04.183]     ...future.result <- base::tryCatch({
[16:13:04.183]         base::withCallingHandlers({
[16:13:04.183]             ...future.value <- base::withVisible(base::local({
[16:13:04.183]                 42L
[16:13:04.183]             }))
[16:13:04.183]             future::FutureResult(value = ...future.value$value, 
[16:13:04.183]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.183]                   ...future.rng), globalenv = if (FALSE) 
[16:13:04.183]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:04.183]                     ...future.globalenv.names))
[16:13:04.183]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:04.183]         }, condition = base::local({
[16:13:04.183]             c <- base::c
[16:13:04.183]             inherits <- base::inherits
[16:13:04.183]             invokeRestart <- base::invokeRestart
[16:13:04.183]             length <- base::length
[16:13:04.183]             list <- base::list
[16:13:04.183]             seq.int <- base::seq.int
[16:13:04.183]             signalCondition <- base::signalCondition
[16:13:04.183]             sys.calls <- base::sys.calls
[16:13:04.183]             `[[` <- base::`[[`
[16:13:04.183]             `+` <- base::`+`
[16:13:04.183]             `<<-` <- base::`<<-`
[16:13:04.183]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:04.183]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:04.183]                   3L)]
[16:13:04.183]             }
[16:13:04.183]             function(cond) {
[16:13:04.183]                 is_error <- inherits(cond, "error")
[16:13:04.183]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:04.183]                   NULL)
[16:13:04.183]                 if (is_error) {
[16:13:04.183]                   sessionInformation <- function() {
[16:13:04.183]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:04.183]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:04.183]                       search = base::search(), system = base::Sys.info())
[16:13:04.183]                   }
[16:13:04.183]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.183]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:04.183]                     cond$call), session = sessionInformation(), 
[16:13:04.183]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:04.183]                   signalCondition(cond)
[16:13:04.183]                 }
[16:13:04.183]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:04.183]                 "immediateCondition"))) {
[16:13:04.183]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:04.183]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.183]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:04.183]                   if (TRUE && !signal) {
[16:13:04.183]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.183]                     {
[16:13:04.183]                       inherits <- base::inherits
[16:13:04.183]                       invokeRestart <- base::invokeRestart
[16:13:04.183]                       is.null <- base::is.null
[16:13:04.183]                       muffled <- FALSE
[16:13:04.183]                       if (inherits(cond, "message")) {
[16:13:04.183]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.183]                         if (muffled) 
[16:13:04.183]                           invokeRestart("muffleMessage")
[16:13:04.183]                       }
[16:13:04.183]                       else if (inherits(cond, "warning")) {
[16:13:04.183]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.183]                         if (muffled) 
[16:13:04.183]                           invokeRestart("muffleWarning")
[16:13:04.183]                       }
[16:13:04.183]                       else if (inherits(cond, "condition")) {
[16:13:04.183]                         if (!is.null(pattern)) {
[16:13:04.183]                           computeRestarts <- base::computeRestarts
[16:13:04.183]                           grepl <- base::grepl
[16:13:04.183]                           restarts <- computeRestarts(cond)
[16:13:04.183]                           for (restart in restarts) {
[16:13:04.183]                             name <- restart$name
[16:13:04.183]                             if (is.null(name)) 
[16:13:04.183]                               next
[16:13:04.183]                             if (!grepl(pattern, name)) 
[16:13:04.183]                               next
[16:13:04.183]                             invokeRestart(restart)
[16:13:04.183]                             muffled <- TRUE
[16:13:04.183]                             break
[16:13:04.183]                           }
[16:13:04.183]                         }
[16:13:04.183]                       }
[16:13:04.183]                       invisible(muffled)
[16:13:04.183]                     }
[16:13:04.183]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.183]                   }
[16:13:04.183]                 }
[16:13:04.183]                 else {
[16:13:04.183]                   if (TRUE) {
[16:13:04.183]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.183]                     {
[16:13:04.183]                       inherits <- base::inherits
[16:13:04.183]                       invokeRestart <- base::invokeRestart
[16:13:04.183]                       is.null <- base::is.null
[16:13:04.183]                       muffled <- FALSE
[16:13:04.183]                       if (inherits(cond, "message")) {
[16:13:04.183]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.183]                         if (muffled) 
[16:13:04.183]                           invokeRestart("muffleMessage")
[16:13:04.183]                       }
[16:13:04.183]                       else if (inherits(cond, "warning")) {
[16:13:04.183]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.183]                         if (muffled) 
[16:13:04.183]                           invokeRestart("muffleWarning")
[16:13:04.183]                       }
[16:13:04.183]                       else if (inherits(cond, "condition")) {
[16:13:04.183]                         if (!is.null(pattern)) {
[16:13:04.183]                           computeRestarts <- base::computeRestarts
[16:13:04.183]                           grepl <- base::grepl
[16:13:04.183]                           restarts <- computeRestarts(cond)
[16:13:04.183]                           for (restart in restarts) {
[16:13:04.183]                             name <- restart$name
[16:13:04.183]                             if (is.null(name)) 
[16:13:04.183]                               next
[16:13:04.183]                             if (!grepl(pattern, name)) 
[16:13:04.183]                               next
[16:13:04.183]                             invokeRestart(restart)
[16:13:04.183]                             muffled <- TRUE
[16:13:04.183]                             break
[16:13:04.183]                           }
[16:13:04.183]                         }
[16:13:04.183]                       }
[16:13:04.183]                       invisible(muffled)
[16:13:04.183]                     }
[16:13:04.183]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.183]                   }
[16:13:04.183]                 }
[16:13:04.183]             }
[16:13:04.183]         }))
[16:13:04.183]     }, error = function(ex) {
[16:13:04.183]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:04.183]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.183]                 ...future.rng), started = ...future.startTime, 
[16:13:04.183]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:04.183]             version = "1.8"), class = "FutureResult")
[16:13:04.183]     }, finally = {
[16:13:04.183]         if (!identical(...future.workdir, getwd())) 
[16:13:04.183]             setwd(...future.workdir)
[16:13:04.183]         {
[16:13:04.183]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:04.183]                 ...future.oldOptions$nwarnings <- NULL
[16:13:04.183]             }
[16:13:04.183]             base::options(...future.oldOptions)
[16:13:04.183]             if (.Platform$OS.type == "windows") {
[16:13:04.183]                 old_names <- names(...future.oldEnvVars)
[16:13:04.183]                 envs <- base::Sys.getenv()
[16:13:04.183]                 names <- names(envs)
[16:13:04.183]                 common <- intersect(names, old_names)
[16:13:04.183]                 added <- setdiff(names, old_names)
[16:13:04.183]                 removed <- setdiff(old_names, names)
[16:13:04.183]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:04.183]                   envs[common]]
[16:13:04.183]                 NAMES <- toupper(changed)
[16:13:04.183]                 args <- list()
[16:13:04.183]                 for (kk in seq_along(NAMES)) {
[16:13:04.183]                   name <- changed[[kk]]
[16:13:04.183]                   NAME <- NAMES[[kk]]
[16:13:04.183]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.183]                     next
[16:13:04.183]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.183]                 }
[16:13:04.183]                 NAMES <- toupper(added)
[16:13:04.183]                 for (kk in seq_along(NAMES)) {
[16:13:04.183]                   name <- added[[kk]]
[16:13:04.183]                   NAME <- NAMES[[kk]]
[16:13:04.183]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.183]                     next
[16:13:04.183]                   args[[name]] <- ""
[16:13:04.183]                 }
[16:13:04.183]                 NAMES <- toupper(removed)
[16:13:04.183]                 for (kk in seq_along(NAMES)) {
[16:13:04.183]                   name <- removed[[kk]]
[16:13:04.183]                   NAME <- NAMES[[kk]]
[16:13:04.183]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.183]                     next
[16:13:04.183]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.183]                 }
[16:13:04.183]                 if (length(args) > 0) 
[16:13:04.183]                   base::do.call(base::Sys.setenv, args = args)
[16:13:04.183]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:04.183]             }
[16:13:04.183]             else {
[16:13:04.183]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:04.183]             }
[16:13:04.183]             {
[16:13:04.183]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:04.183]                   0L) {
[16:13:04.183]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:04.183]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:04.183]                   base::options(opts)
[16:13:04.183]                 }
[16:13:04.183]                 {
[16:13:04.183]                   {
[16:13:04.183]                     NULL
[16:13:04.183]                     RNGkind("Mersenne-Twister")
[16:13:04.183]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:04.183]                       inherits = FALSE)
[16:13:04.183]                   }
[16:13:04.183]                   options(future.plan = NULL)
[16:13:04.183]                   if (is.na(NA_character_)) 
[16:13:04.183]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.183]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:04.183]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:04.183]                     envir = parent.frame()) 
[16:13:04.183]                   {
[16:13:04.183]                     default_workers <- missing(workers)
[16:13:04.183]                     if (is.function(workers)) 
[16:13:04.183]                       workers <- workers()
[16:13:04.183]                     workers <- structure(as.integer(workers), 
[16:13:04.183]                       class = class(workers))
[16:13:04.183]                     stop_if_not(is.finite(workers), workers >= 
[16:13:04.183]                       1L)
[16:13:04.183]                     if ((workers == 1L && !inherits(workers, 
[16:13:04.183]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:04.183]                       if (default_workers) 
[16:13:04.183]                         supportsMulticore(warn = TRUE)
[16:13:04.183]                       return(sequential(..., envir = envir))
[16:13:04.183]                     }
[16:13:04.183]                     oopts <- options(mc.cores = workers)
[16:13:04.183]                     on.exit(options(oopts))
[16:13:04.183]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:04.183]                       envir = envir)
[16:13:04.183]                     if (!future$lazy) 
[16:13:04.183]                       future <- run(future)
[16:13:04.183]                     invisible(future)
[16:13:04.183]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:04.183]                 }
[16:13:04.183]             }
[16:13:04.183]         }
[16:13:04.183]     })
[16:13:04.183]     if (TRUE) {
[16:13:04.183]         base::sink(type = "output", split = FALSE)
[16:13:04.183]         if (TRUE) {
[16:13:04.183]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:04.183]         }
[16:13:04.183]         else {
[16:13:04.183]             ...future.result["stdout"] <- base::list(NULL)
[16:13:04.183]         }
[16:13:04.183]         base::close(...future.stdout)
[16:13:04.183]         ...future.stdout <- NULL
[16:13:04.183]     }
[16:13:04.183]     ...future.result$conditions <- ...future.conditions
[16:13:04.183]     ...future.result$finished <- base::Sys.time()
[16:13:04.183]     ...future.result
[16:13:04.183] }
[16:13:04.185] plan(): Setting new future strategy stack:
[16:13:04.185] List of future strategies:
[16:13:04.185] 1. sequential:
[16:13:04.185]    - args: function (..., envir = parent.frame())
[16:13:04.185]    - tweaked: FALSE
[16:13:04.185]    - call: NULL
[16:13:04.185] plan(): nbrOfWorkers() = 1
[16:13:04.186] plan(): Setting new future strategy stack:
[16:13:04.186] List of future strategies:
[16:13:04.186] 1. multicore:
[16:13:04.186]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:04.186]    - tweaked: FALSE
[16:13:04.186]    - call: plan(multicore)
[16:13:04.189] plan(): nbrOfWorkers() = 1
[16:13:04.189] SequentialFuture started (and completed)
[16:13:04.190] resolved() for ‘SequentialFuture’ ...
[16:13:04.190] - state: ‘finished’
[16:13:04.190] - run: TRUE
[16:13:04.190] - result: ‘FutureResult’
[16:13:04.190] resolved() for ‘SequentialFuture’ ... done
[1] TRUE
[1] 42
*** multicore(..., globals = TRUE) with globals
[16:13:04.193] getGlobalsAndPackages() ...
[16:13:04.194] Searching for globals...
[16:13:04.197] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘a’
[16:13:04.197] Searching for globals ... DONE
[16:13:04.197] Resolving globals: FALSE
[16:13:04.198] The total size of the 1 globals is 56 bytes (56 bytes)
[16:13:04.198] The total size of the 1 globals exported for future expression (‘{; b <- 3; c <- 2; a * b * c; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:13:04.199] - globals: [1] ‘a’
[16:13:04.199] 
[16:13:04.199] getGlobalsAndPackages() ... DONE
[16:13:04.199] Packages needed by the future expression (n = 0): <none>
[16:13:04.199] Packages needed by future strategies (n = 0): <none>
[16:13:04.200] {
[16:13:04.200]     {
[16:13:04.200]         {
[16:13:04.200]             ...future.startTime <- base::Sys.time()
[16:13:04.200]             {
[16:13:04.200]                 {
[16:13:04.200]                   {
[16:13:04.200]                     base::local({
[16:13:04.200]                       has_future <- base::requireNamespace("future", 
[16:13:04.200]                         quietly = TRUE)
[16:13:04.200]                       if (has_future) {
[16:13:04.200]                         ns <- base::getNamespace("future")
[16:13:04.200]                         version <- ns[[".package"]][["version"]]
[16:13:04.200]                         if (is.null(version)) 
[16:13:04.200]                           version <- utils::packageVersion("future")
[16:13:04.200]                       }
[16:13:04.200]                       else {
[16:13:04.200]                         version <- NULL
[16:13:04.200]                       }
[16:13:04.200]                       if (!has_future || version < "1.8.0") {
[16:13:04.200]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:04.200]                           "", base::R.version$version.string), 
[16:13:04.200]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:04.200]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:04.200]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:04.200]                             "release", "version")], collapse = " "), 
[16:13:04.200]                           hostname = base::Sys.info()[["nodename"]])
[16:13:04.200]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:04.200]                           info)
[16:13:04.200]                         info <- base::paste(info, collapse = "; ")
[16:13:04.200]                         if (!has_future) {
[16:13:04.200]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:04.200]                             info)
[16:13:04.200]                         }
[16:13:04.200]                         else {
[16:13:04.200]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:04.200]                             info, version)
[16:13:04.200]                         }
[16:13:04.200]                         base::stop(msg)
[16:13:04.200]                       }
[16:13:04.200]                     })
[16:13:04.200]                   }
[16:13:04.200]                   options(future.plan = NULL)
[16:13:04.200]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.200]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:04.200]                 }
[16:13:04.200]                 ...future.workdir <- getwd()
[16:13:04.200]             }
[16:13:04.200]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:04.200]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:04.200]         }
[16:13:04.200]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:04.200]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:04.200]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:04.200]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:04.200]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:04.200]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:04.200]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:04.200]             base::names(...future.oldOptions))
[16:13:04.200]     }
[16:13:04.200]     if (FALSE) {
[16:13:04.200]     }
[16:13:04.200]     else {
[16:13:04.200]         if (TRUE) {
[16:13:04.200]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:04.200]                 open = "w")
[16:13:04.200]         }
[16:13:04.200]         else {
[16:13:04.200]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:04.200]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:04.200]         }
[16:13:04.200]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:04.200]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:04.200]             base::sink(type = "output", split = FALSE)
[16:13:04.200]             base::close(...future.stdout)
[16:13:04.200]         }, add = TRUE)
[16:13:04.200]     }
[16:13:04.200]     ...future.frame <- base::sys.nframe()
[16:13:04.200]     ...future.conditions <- base::list()
[16:13:04.200]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:04.200]     if (FALSE) {
[16:13:04.200]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:04.200]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:04.200]     }
[16:13:04.200]     ...future.result <- base::tryCatch({
[16:13:04.200]         base::withCallingHandlers({
[16:13:04.200]             ...future.value <- base::withVisible(base::local({
[16:13:04.200]                 b <- 3
[16:13:04.200]                 c <- 2
[16:13:04.200]                 a * b * c
[16:13:04.200]             }))
[16:13:04.200]             future::FutureResult(value = ...future.value$value, 
[16:13:04.200]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.200]                   ...future.rng), globalenv = if (FALSE) 
[16:13:04.200]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:04.200]                     ...future.globalenv.names))
[16:13:04.200]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:04.200]         }, condition = base::local({
[16:13:04.200]             c <- base::c
[16:13:04.200]             inherits <- base::inherits
[16:13:04.200]             invokeRestart <- base::invokeRestart
[16:13:04.200]             length <- base::length
[16:13:04.200]             list <- base::list
[16:13:04.200]             seq.int <- base::seq.int
[16:13:04.200]             signalCondition <- base::signalCondition
[16:13:04.200]             sys.calls <- base::sys.calls
[16:13:04.200]             `[[` <- base::`[[`
[16:13:04.200]             `+` <- base::`+`
[16:13:04.200]             `<<-` <- base::`<<-`
[16:13:04.200]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:04.200]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:04.200]                   3L)]
[16:13:04.200]             }
[16:13:04.200]             function(cond) {
[16:13:04.200]                 is_error <- inherits(cond, "error")
[16:13:04.200]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:04.200]                   NULL)
[16:13:04.200]                 if (is_error) {
[16:13:04.200]                   sessionInformation <- function() {
[16:13:04.200]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:04.200]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:04.200]                       search = base::search(), system = base::Sys.info())
[16:13:04.200]                   }
[16:13:04.200]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.200]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:04.200]                     cond$call), session = sessionInformation(), 
[16:13:04.200]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:04.200]                   signalCondition(cond)
[16:13:04.200]                 }
[16:13:04.200]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:04.200]                 "immediateCondition"))) {
[16:13:04.200]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:04.200]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.200]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:04.200]                   if (TRUE && !signal) {
[16:13:04.200]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.200]                     {
[16:13:04.200]                       inherits <- base::inherits
[16:13:04.200]                       invokeRestart <- base::invokeRestart
[16:13:04.200]                       is.null <- base::is.null
[16:13:04.200]                       muffled <- FALSE
[16:13:04.200]                       if (inherits(cond, "message")) {
[16:13:04.200]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.200]                         if (muffled) 
[16:13:04.200]                           invokeRestart("muffleMessage")
[16:13:04.200]                       }
[16:13:04.200]                       else if (inherits(cond, "warning")) {
[16:13:04.200]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.200]                         if (muffled) 
[16:13:04.200]                           invokeRestart("muffleWarning")
[16:13:04.200]                       }
[16:13:04.200]                       else if (inherits(cond, "condition")) {
[16:13:04.200]                         if (!is.null(pattern)) {
[16:13:04.200]                           computeRestarts <- base::computeRestarts
[16:13:04.200]                           grepl <- base::grepl
[16:13:04.200]                           restarts <- computeRestarts(cond)
[16:13:04.200]                           for (restart in restarts) {
[16:13:04.200]                             name <- restart$name
[16:13:04.200]                             if (is.null(name)) 
[16:13:04.200]                               next
[16:13:04.200]                             if (!grepl(pattern, name)) 
[16:13:04.200]                               next
[16:13:04.200]                             invokeRestart(restart)
[16:13:04.200]                             muffled <- TRUE
[16:13:04.200]                             break
[16:13:04.200]                           }
[16:13:04.200]                         }
[16:13:04.200]                       }
[16:13:04.200]                       invisible(muffled)
[16:13:04.200]                     }
[16:13:04.200]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.200]                   }
[16:13:04.200]                 }
[16:13:04.200]                 else {
[16:13:04.200]                   if (TRUE) {
[16:13:04.200]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.200]                     {
[16:13:04.200]                       inherits <- base::inherits
[16:13:04.200]                       invokeRestart <- base::invokeRestart
[16:13:04.200]                       is.null <- base::is.null
[16:13:04.200]                       muffled <- FALSE
[16:13:04.200]                       if (inherits(cond, "message")) {
[16:13:04.200]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.200]                         if (muffled) 
[16:13:04.200]                           invokeRestart("muffleMessage")
[16:13:04.200]                       }
[16:13:04.200]                       else if (inherits(cond, "warning")) {
[16:13:04.200]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.200]                         if (muffled) 
[16:13:04.200]                           invokeRestart("muffleWarning")
[16:13:04.200]                       }
[16:13:04.200]                       else if (inherits(cond, "condition")) {
[16:13:04.200]                         if (!is.null(pattern)) {
[16:13:04.200]                           computeRestarts <- base::computeRestarts
[16:13:04.200]                           grepl <- base::grepl
[16:13:04.200]                           restarts <- computeRestarts(cond)
[16:13:04.200]                           for (restart in restarts) {
[16:13:04.200]                             name <- restart$name
[16:13:04.200]                             if (is.null(name)) 
[16:13:04.200]                               next
[16:13:04.200]                             if (!grepl(pattern, name)) 
[16:13:04.200]                               next
[16:13:04.200]                             invokeRestart(restart)
[16:13:04.200]                             muffled <- TRUE
[16:13:04.200]                             break
[16:13:04.200]                           }
[16:13:04.200]                         }
[16:13:04.200]                       }
[16:13:04.200]                       invisible(muffled)
[16:13:04.200]                     }
[16:13:04.200]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.200]                   }
[16:13:04.200]                 }
[16:13:04.200]             }
[16:13:04.200]         }))
[16:13:04.200]     }, error = function(ex) {
[16:13:04.200]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:04.200]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.200]                 ...future.rng), started = ...future.startTime, 
[16:13:04.200]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:04.200]             version = "1.8"), class = "FutureResult")
[16:13:04.200]     }, finally = {
[16:13:04.200]         if (!identical(...future.workdir, getwd())) 
[16:13:04.200]             setwd(...future.workdir)
[16:13:04.200]         {
[16:13:04.200]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:04.200]                 ...future.oldOptions$nwarnings <- NULL
[16:13:04.200]             }
[16:13:04.200]             base::options(...future.oldOptions)
[16:13:04.200]             if (.Platform$OS.type == "windows") {
[16:13:04.200]                 old_names <- names(...future.oldEnvVars)
[16:13:04.200]                 envs <- base::Sys.getenv()
[16:13:04.200]                 names <- names(envs)
[16:13:04.200]                 common <- intersect(names, old_names)
[16:13:04.200]                 added <- setdiff(names, old_names)
[16:13:04.200]                 removed <- setdiff(old_names, names)
[16:13:04.200]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:04.200]                   envs[common]]
[16:13:04.200]                 NAMES <- toupper(changed)
[16:13:04.200]                 args <- list()
[16:13:04.200]                 for (kk in seq_along(NAMES)) {
[16:13:04.200]                   name <- changed[[kk]]
[16:13:04.200]                   NAME <- NAMES[[kk]]
[16:13:04.200]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.200]                     next
[16:13:04.200]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.200]                 }
[16:13:04.200]                 NAMES <- toupper(added)
[16:13:04.200]                 for (kk in seq_along(NAMES)) {
[16:13:04.200]                   name <- added[[kk]]
[16:13:04.200]                   NAME <- NAMES[[kk]]
[16:13:04.200]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.200]                     next
[16:13:04.200]                   args[[name]] <- ""
[16:13:04.200]                 }
[16:13:04.200]                 NAMES <- toupper(removed)
[16:13:04.200]                 for (kk in seq_along(NAMES)) {
[16:13:04.200]                   name <- removed[[kk]]
[16:13:04.200]                   NAME <- NAMES[[kk]]
[16:13:04.200]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.200]                     next
[16:13:04.200]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.200]                 }
[16:13:04.200]                 if (length(args) > 0) 
[16:13:04.200]                   base::do.call(base::Sys.setenv, args = args)
[16:13:04.200]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:04.200]             }
[16:13:04.200]             else {
[16:13:04.200]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:04.200]             }
[16:13:04.200]             {
[16:13:04.200]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:04.200]                   0L) {
[16:13:04.200]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:04.200]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:04.200]                   base::options(opts)
[16:13:04.200]                 }
[16:13:04.200]                 {
[16:13:04.200]                   {
[16:13:04.200]                     NULL
[16:13:04.200]                     RNGkind("Mersenne-Twister")
[16:13:04.200]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:04.200]                       inherits = FALSE)
[16:13:04.200]                   }
[16:13:04.200]                   options(future.plan = NULL)
[16:13:04.200]                   if (is.na(NA_character_)) 
[16:13:04.200]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.200]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:04.200]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:04.200]                     envir = parent.frame()) 
[16:13:04.200]                   {
[16:13:04.200]                     default_workers <- missing(workers)
[16:13:04.200]                     if (is.function(workers)) 
[16:13:04.200]                       workers <- workers()
[16:13:04.200]                     workers <- structure(as.integer(workers), 
[16:13:04.200]                       class = class(workers))
[16:13:04.200]                     stop_if_not(is.finite(workers), workers >= 
[16:13:04.200]                       1L)
[16:13:04.200]                     if ((workers == 1L && !inherits(workers, 
[16:13:04.200]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:04.200]                       if (default_workers) 
[16:13:04.200]                         supportsMulticore(warn = TRUE)
[16:13:04.200]                       return(sequential(..., envir = envir))
[16:13:04.200]                     }
[16:13:04.200]                     oopts <- options(mc.cores = workers)
[16:13:04.200]                     on.exit(options(oopts))
[16:13:04.200]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:04.200]                       envir = envir)
[16:13:04.200]                     if (!future$lazy) 
[16:13:04.200]                       future <- run(future)
[16:13:04.200]                     invisible(future)
[16:13:04.200]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:04.200]                 }
[16:13:04.200]             }
[16:13:04.200]         }
[16:13:04.200]     })
[16:13:04.200]     if (TRUE) {
[16:13:04.200]         base::sink(type = "output", split = FALSE)
[16:13:04.200]         if (TRUE) {
[16:13:04.200]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:04.200]         }
[16:13:04.200]         else {
[16:13:04.200]             ...future.result["stdout"] <- base::list(NULL)
[16:13:04.200]         }
[16:13:04.200]         base::close(...future.stdout)
[16:13:04.200]         ...future.stdout <- NULL
[16:13:04.200]     }
[16:13:04.200]     ...future.result$conditions <- ...future.conditions
[16:13:04.200]     ...future.result$finished <- base::Sys.time()
[16:13:04.200]     ...future.result
[16:13:04.200] }
[16:13:04.201] assign_globals() ...
[16:13:04.202] List of 1
[16:13:04.202]  $ a: num 0
[16:13:04.202]  - attr(*, "where")=List of 1
[16:13:04.202]   ..$ a:<environment: R_EmptyEnv> 
[16:13:04.202]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:04.202]  - attr(*, "resolved")= logi FALSE
[16:13:04.202]  - attr(*, "total_size")= num 56
[16:13:04.206] - copied ‘a’ to environment
[16:13:04.206] assign_globals() ... done
[16:13:04.206] plan(): Setting new future strategy stack:
[16:13:04.206] List of future strategies:
[16:13:04.206] 1. sequential:
[16:13:04.206]    - args: function (..., envir = parent.frame())
[16:13:04.206]    - tweaked: FALSE
[16:13:04.206]    - call: NULL
[16:13:04.207] plan(): nbrOfWorkers() = 1
[16:13:04.208] plan(): Setting new future strategy stack:
[16:13:04.208] List of future strategies:
[16:13:04.208] 1. multicore:
[16:13:04.208]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:04.208]    - tweaked: FALSE
[16:13:04.208]    - call: plan(multicore)
[16:13:04.211] plan(): nbrOfWorkers() = 1
[16:13:04.211] SequentialFuture started (and completed)
SequentialFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: 1 objects totaling 56 bytes (numeric ‘a’ of 56 bytes)
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 56 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: 9cd5072f-68f7-e4f0-6d65-cff53a745767
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[1] 0
*** multicore(..., globals = TRUE) with globals and blocking
 - Creating multicore future #1 ...
[16:13:04.215] getGlobalsAndPackages() ...
[16:13:04.215] Searching for globals...
[16:13:04.216] - globals found: [2] ‘{’, ‘ii’
[16:13:04.216] Searching for globals ... DONE
[16:13:04.216] Resolving globals: FALSE
[16:13:04.217] The total size of the 1 globals is 56 bytes (56 bytes)
[16:13:04.217] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:13:04.217] - globals: [1] ‘ii’
[16:13:04.217] 
[16:13:04.217] getGlobalsAndPackages() ... DONE
[16:13:04.218] Packages needed by the future expression (n = 0): <none>
[16:13:04.218] Packages needed by future strategies (n = 0): <none>
[16:13:04.218] {
[16:13:04.218]     {
[16:13:04.218]         {
[16:13:04.218]             ...future.startTime <- base::Sys.time()
[16:13:04.218]             {
[16:13:04.218]                 {
[16:13:04.218]                   {
[16:13:04.218]                     base::local({
[16:13:04.218]                       has_future <- base::requireNamespace("future", 
[16:13:04.218]                         quietly = TRUE)
[16:13:04.218]                       if (has_future) {
[16:13:04.218]                         ns <- base::getNamespace("future")
[16:13:04.218]                         version <- ns[[".package"]][["version"]]
[16:13:04.218]                         if (is.null(version)) 
[16:13:04.218]                           version <- utils::packageVersion("future")
[16:13:04.218]                       }
[16:13:04.218]                       else {
[16:13:04.218]                         version <- NULL
[16:13:04.218]                       }
[16:13:04.218]                       if (!has_future || version < "1.8.0") {
[16:13:04.218]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:04.218]                           "", base::R.version$version.string), 
[16:13:04.218]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:04.218]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:04.218]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:04.218]                             "release", "version")], collapse = " "), 
[16:13:04.218]                           hostname = base::Sys.info()[["nodename"]])
[16:13:04.218]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:04.218]                           info)
[16:13:04.218]                         info <- base::paste(info, collapse = "; ")
[16:13:04.218]                         if (!has_future) {
[16:13:04.218]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:04.218]                             info)
[16:13:04.218]                         }
[16:13:04.218]                         else {
[16:13:04.218]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:04.218]                             info, version)
[16:13:04.218]                         }
[16:13:04.218]                         base::stop(msg)
[16:13:04.218]                       }
[16:13:04.218]                     })
[16:13:04.218]                   }
[16:13:04.218]                   options(future.plan = NULL)
[16:13:04.218]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.218]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:04.218]                 }
[16:13:04.218]                 ...future.workdir <- getwd()
[16:13:04.218]             }
[16:13:04.218]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:04.218]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:04.218]         }
[16:13:04.218]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:04.218]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:04.218]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:04.218]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:04.218]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:04.218]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:04.218]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:04.218]             base::names(...future.oldOptions))
[16:13:04.218]     }
[16:13:04.218]     if (FALSE) {
[16:13:04.218]     }
[16:13:04.218]     else {
[16:13:04.218]         if (TRUE) {
[16:13:04.218]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:04.218]                 open = "w")
[16:13:04.218]         }
[16:13:04.218]         else {
[16:13:04.218]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:04.218]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:04.218]         }
[16:13:04.218]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:04.218]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:04.218]             base::sink(type = "output", split = FALSE)
[16:13:04.218]             base::close(...future.stdout)
[16:13:04.218]         }, add = TRUE)
[16:13:04.218]     }
[16:13:04.218]     ...future.frame <- base::sys.nframe()
[16:13:04.218]     ...future.conditions <- base::list()
[16:13:04.218]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:04.218]     if (FALSE) {
[16:13:04.218]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:04.218]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:04.218]     }
[16:13:04.218]     ...future.result <- base::tryCatch({
[16:13:04.218]         base::withCallingHandlers({
[16:13:04.218]             ...future.value <- base::withVisible(base::local({
[16:13:04.218]                 ii
[16:13:04.218]             }))
[16:13:04.218]             future::FutureResult(value = ...future.value$value, 
[16:13:04.218]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.218]                   ...future.rng), globalenv = if (FALSE) 
[16:13:04.218]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:04.218]                     ...future.globalenv.names))
[16:13:04.218]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:04.218]         }, condition = base::local({
[16:13:04.218]             c <- base::c
[16:13:04.218]             inherits <- base::inherits
[16:13:04.218]             invokeRestart <- base::invokeRestart
[16:13:04.218]             length <- base::length
[16:13:04.218]             list <- base::list
[16:13:04.218]             seq.int <- base::seq.int
[16:13:04.218]             signalCondition <- base::signalCondition
[16:13:04.218]             sys.calls <- base::sys.calls
[16:13:04.218]             `[[` <- base::`[[`
[16:13:04.218]             `+` <- base::`+`
[16:13:04.218]             `<<-` <- base::`<<-`
[16:13:04.218]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:04.218]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:04.218]                   3L)]
[16:13:04.218]             }
[16:13:04.218]             function(cond) {
[16:13:04.218]                 is_error <- inherits(cond, "error")
[16:13:04.218]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:04.218]                   NULL)
[16:13:04.218]                 if (is_error) {
[16:13:04.218]                   sessionInformation <- function() {
[16:13:04.218]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:04.218]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:04.218]                       search = base::search(), system = base::Sys.info())
[16:13:04.218]                   }
[16:13:04.218]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.218]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:04.218]                     cond$call), session = sessionInformation(), 
[16:13:04.218]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:04.218]                   signalCondition(cond)
[16:13:04.218]                 }
[16:13:04.218]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:04.218]                 "immediateCondition"))) {
[16:13:04.218]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:04.218]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.218]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:04.218]                   if (TRUE && !signal) {
[16:13:04.218]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.218]                     {
[16:13:04.218]                       inherits <- base::inherits
[16:13:04.218]                       invokeRestart <- base::invokeRestart
[16:13:04.218]                       is.null <- base::is.null
[16:13:04.218]                       muffled <- FALSE
[16:13:04.218]                       if (inherits(cond, "message")) {
[16:13:04.218]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.218]                         if (muffled) 
[16:13:04.218]                           invokeRestart("muffleMessage")
[16:13:04.218]                       }
[16:13:04.218]                       else if (inherits(cond, "warning")) {
[16:13:04.218]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.218]                         if (muffled) 
[16:13:04.218]                           invokeRestart("muffleWarning")
[16:13:04.218]                       }
[16:13:04.218]                       else if (inherits(cond, "condition")) {
[16:13:04.218]                         if (!is.null(pattern)) {
[16:13:04.218]                           computeRestarts <- base::computeRestarts
[16:13:04.218]                           grepl <- base::grepl
[16:13:04.218]                           restarts <- computeRestarts(cond)
[16:13:04.218]                           for (restart in restarts) {
[16:13:04.218]                             name <- restart$name
[16:13:04.218]                             if (is.null(name)) 
[16:13:04.218]                               next
[16:13:04.218]                             if (!grepl(pattern, name)) 
[16:13:04.218]                               next
[16:13:04.218]                             invokeRestart(restart)
[16:13:04.218]                             muffled <- TRUE
[16:13:04.218]                             break
[16:13:04.218]                           }
[16:13:04.218]                         }
[16:13:04.218]                       }
[16:13:04.218]                       invisible(muffled)
[16:13:04.218]                     }
[16:13:04.218]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.218]                   }
[16:13:04.218]                 }
[16:13:04.218]                 else {
[16:13:04.218]                   if (TRUE) {
[16:13:04.218]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.218]                     {
[16:13:04.218]                       inherits <- base::inherits
[16:13:04.218]                       invokeRestart <- base::invokeRestart
[16:13:04.218]                       is.null <- base::is.null
[16:13:04.218]                       muffled <- FALSE
[16:13:04.218]                       if (inherits(cond, "message")) {
[16:13:04.218]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.218]                         if (muffled) 
[16:13:04.218]                           invokeRestart("muffleMessage")
[16:13:04.218]                       }
[16:13:04.218]                       else if (inherits(cond, "warning")) {
[16:13:04.218]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.218]                         if (muffled) 
[16:13:04.218]                           invokeRestart("muffleWarning")
[16:13:04.218]                       }
[16:13:04.218]                       else if (inherits(cond, "condition")) {
[16:13:04.218]                         if (!is.null(pattern)) {
[16:13:04.218]                           computeRestarts <- base::computeRestarts
[16:13:04.218]                           grepl <- base::grepl
[16:13:04.218]                           restarts <- computeRestarts(cond)
[16:13:04.218]                           for (restart in restarts) {
[16:13:04.218]                             name <- restart$name
[16:13:04.218]                             if (is.null(name)) 
[16:13:04.218]                               next
[16:13:04.218]                             if (!grepl(pattern, name)) 
[16:13:04.218]                               next
[16:13:04.218]                             invokeRestart(restart)
[16:13:04.218]                             muffled <- TRUE
[16:13:04.218]                             break
[16:13:04.218]                           }
[16:13:04.218]                         }
[16:13:04.218]                       }
[16:13:04.218]                       invisible(muffled)
[16:13:04.218]                     }
[16:13:04.218]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.218]                   }
[16:13:04.218]                 }
[16:13:04.218]             }
[16:13:04.218]         }))
[16:13:04.218]     }, error = function(ex) {
[16:13:04.218]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:04.218]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.218]                 ...future.rng), started = ...future.startTime, 
[16:13:04.218]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:04.218]             version = "1.8"), class = "FutureResult")
[16:13:04.218]     }, finally = {
[16:13:04.218]         if (!identical(...future.workdir, getwd())) 
[16:13:04.218]             setwd(...future.workdir)
[16:13:04.218]         {
[16:13:04.218]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:04.218]                 ...future.oldOptions$nwarnings <- NULL
[16:13:04.218]             }
[16:13:04.218]             base::options(...future.oldOptions)
[16:13:04.218]             if (.Platform$OS.type == "windows") {
[16:13:04.218]                 old_names <- names(...future.oldEnvVars)
[16:13:04.218]                 envs <- base::Sys.getenv()
[16:13:04.218]                 names <- names(envs)
[16:13:04.218]                 common <- intersect(names, old_names)
[16:13:04.218]                 added <- setdiff(names, old_names)
[16:13:04.218]                 removed <- setdiff(old_names, names)
[16:13:04.218]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:04.218]                   envs[common]]
[16:13:04.218]                 NAMES <- toupper(changed)
[16:13:04.218]                 args <- list()
[16:13:04.218]                 for (kk in seq_along(NAMES)) {
[16:13:04.218]                   name <- changed[[kk]]
[16:13:04.218]                   NAME <- NAMES[[kk]]
[16:13:04.218]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.218]                     next
[16:13:04.218]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.218]                 }
[16:13:04.218]                 NAMES <- toupper(added)
[16:13:04.218]                 for (kk in seq_along(NAMES)) {
[16:13:04.218]                   name <- added[[kk]]
[16:13:04.218]                   NAME <- NAMES[[kk]]
[16:13:04.218]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.218]                     next
[16:13:04.218]                   args[[name]] <- ""
[16:13:04.218]                 }
[16:13:04.218]                 NAMES <- toupper(removed)
[16:13:04.218]                 for (kk in seq_along(NAMES)) {
[16:13:04.218]                   name <- removed[[kk]]
[16:13:04.218]                   NAME <- NAMES[[kk]]
[16:13:04.218]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.218]                     next
[16:13:04.218]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.218]                 }
[16:13:04.218]                 if (length(args) > 0) 
[16:13:04.218]                   base::do.call(base::Sys.setenv, args = args)
[16:13:04.218]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:04.218]             }
[16:13:04.218]             else {
[16:13:04.218]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:04.218]             }
[16:13:04.218]             {
[16:13:04.218]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:04.218]                   0L) {
[16:13:04.218]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:04.218]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:04.218]                   base::options(opts)
[16:13:04.218]                 }
[16:13:04.218]                 {
[16:13:04.218]                   {
[16:13:04.218]                     NULL
[16:13:04.218]                     RNGkind("Mersenne-Twister")
[16:13:04.218]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:04.218]                       inherits = FALSE)
[16:13:04.218]                   }
[16:13:04.218]                   options(future.plan = NULL)
[16:13:04.218]                   if (is.na(NA_character_)) 
[16:13:04.218]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.218]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:04.218]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:04.218]                     envir = parent.frame()) 
[16:13:04.218]                   {
[16:13:04.218]                     default_workers <- missing(workers)
[16:13:04.218]                     if (is.function(workers)) 
[16:13:04.218]                       workers <- workers()
[16:13:04.218]                     workers <- structure(as.integer(workers), 
[16:13:04.218]                       class = class(workers))
[16:13:04.218]                     stop_if_not(is.finite(workers), workers >= 
[16:13:04.218]                       1L)
[16:13:04.218]                     if ((workers == 1L && !inherits(workers, 
[16:13:04.218]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:04.218]                       if (default_workers) 
[16:13:04.218]                         supportsMulticore(warn = TRUE)
[16:13:04.218]                       return(sequential(..., envir = envir))
[16:13:04.218]                     }
[16:13:04.218]                     oopts <- options(mc.cores = workers)
[16:13:04.218]                     on.exit(options(oopts))
[16:13:04.218]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:04.218]                       envir = envir)
[16:13:04.218]                     if (!future$lazy) 
[16:13:04.218]                       future <- run(future)
[16:13:04.218]                     invisible(future)
[16:13:04.218]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:04.218]                 }
[16:13:04.218]             }
[16:13:04.218]         }
[16:13:04.218]     })
[16:13:04.218]     if (TRUE) {
[16:13:04.218]         base::sink(type = "output", split = FALSE)
[16:13:04.218]         if (TRUE) {
[16:13:04.218]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:04.218]         }
[16:13:04.218]         else {
[16:13:04.218]             ...future.result["stdout"] <- base::list(NULL)
[16:13:04.218]         }
[16:13:04.218]         base::close(...future.stdout)
[16:13:04.218]         ...future.stdout <- NULL
[16:13:04.218]     }
[16:13:04.218]     ...future.result$conditions <- ...future.conditions
[16:13:04.218]     ...future.result$finished <- base::Sys.time()
[16:13:04.218]     ...future.result
[16:13:04.218] }
[16:13:04.220] assign_globals() ...
[16:13:04.220] List of 1
[16:13:04.220]  $ ii: int 1
[16:13:04.220]  - attr(*, "where")=List of 1
[16:13:04.220]   ..$ ii:<environment: R_EmptyEnv> 
[16:13:04.220]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:04.220]  - attr(*, "resolved")= logi FALSE
[16:13:04.220]  - attr(*, "total_size")= num 56
[16:13:04.222] - copied ‘ii’ to environment
[16:13:04.222] assign_globals() ... done
[16:13:04.222] plan(): Setting new future strategy stack:
[16:13:04.222] List of future strategies:
[16:13:04.222] 1. sequential:
[16:13:04.222]    - args: function (..., envir = parent.frame())
[16:13:04.222]    - tweaked: FALSE
[16:13:04.222]    - call: NULL
[16:13:04.223] plan(): nbrOfWorkers() = 1
[16:13:04.223] plan(): Setting new future strategy stack:
[16:13:04.223] List of future strategies:
[16:13:04.223] 1. multicore:
[16:13:04.223]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:04.223]    - tweaked: FALSE
[16:13:04.223]    - call: plan(multicore)
[16:13:04.227] plan(): nbrOfWorkers() = 1
[16:13:04.227] SequentialFuture started (and completed)
 - Creating multicore future #2 ...
[16:13:04.230] getGlobalsAndPackages() ...
[16:13:04.230] Searching for globals...
[16:13:04.231] - globals found: [2] ‘{’, ‘ii’
[16:13:04.231] Searching for globals ... DONE
[16:13:04.231] Resolving globals: FALSE
[16:13:04.232] The total size of the 1 globals is 56 bytes (56 bytes)
[16:13:04.232] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:13:04.232] - globals: [1] ‘ii’
[16:13:04.232] 
[16:13:04.232] getGlobalsAndPackages() ... DONE
[16:13:04.232] Packages needed by the future expression (n = 0): <none>
[16:13:04.233] Packages needed by future strategies (n = 0): <none>
[16:13:04.233] {
[16:13:04.233]     {
[16:13:04.233]         {
[16:13:04.233]             ...future.startTime <- base::Sys.time()
[16:13:04.233]             {
[16:13:04.233]                 {
[16:13:04.233]                   {
[16:13:04.233]                     base::local({
[16:13:04.233]                       has_future <- base::requireNamespace("future", 
[16:13:04.233]                         quietly = TRUE)
[16:13:04.233]                       if (has_future) {
[16:13:04.233]                         ns <- base::getNamespace("future")
[16:13:04.233]                         version <- ns[[".package"]][["version"]]
[16:13:04.233]                         if (is.null(version)) 
[16:13:04.233]                           version <- utils::packageVersion("future")
[16:13:04.233]                       }
[16:13:04.233]                       else {
[16:13:04.233]                         version <- NULL
[16:13:04.233]                       }
[16:13:04.233]                       if (!has_future || version < "1.8.0") {
[16:13:04.233]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:04.233]                           "", base::R.version$version.string), 
[16:13:04.233]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:04.233]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:04.233]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:04.233]                             "release", "version")], collapse = " "), 
[16:13:04.233]                           hostname = base::Sys.info()[["nodename"]])
[16:13:04.233]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:04.233]                           info)
[16:13:04.233]                         info <- base::paste(info, collapse = "; ")
[16:13:04.233]                         if (!has_future) {
[16:13:04.233]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:04.233]                             info)
[16:13:04.233]                         }
[16:13:04.233]                         else {
[16:13:04.233]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:04.233]                             info, version)
[16:13:04.233]                         }
[16:13:04.233]                         base::stop(msg)
[16:13:04.233]                       }
[16:13:04.233]                     })
[16:13:04.233]                   }
[16:13:04.233]                   options(future.plan = NULL)
[16:13:04.233]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.233]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:04.233]                 }
[16:13:04.233]                 ...future.workdir <- getwd()
[16:13:04.233]             }
[16:13:04.233]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:04.233]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:04.233]         }
[16:13:04.233]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:04.233]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:04.233]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:04.233]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:04.233]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:04.233]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:04.233]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:04.233]             base::names(...future.oldOptions))
[16:13:04.233]     }
[16:13:04.233]     if (FALSE) {
[16:13:04.233]     }
[16:13:04.233]     else {
[16:13:04.233]         if (TRUE) {
[16:13:04.233]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:04.233]                 open = "w")
[16:13:04.233]         }
[16:13:04.233]         else {
[16:13:04.233]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:04.233]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:04.233]         }
[16:13:04.233]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:04.233]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:04.233]             base::sink(type = "output", split = FALSE)
[16:13:04.233]             base::close(...future.stdout)
[16:13:04.233]         }, add = TRUE)
[16:13:04.233]     }
[16:13:04.233]     ...future.frame <- base::sys.nframe()
[16:13:04.233]     ...future.conditions <- base::list()
[16:13:04.233]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:04.233]     if (FALSE) {
[16:13:04.233]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:04.233]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:04.233]     }
[16:13:04.233]     ...future.result <- base::tryCatch({
[16:13:04.233]         base::withCallingHandlers({
[16:13:04.233]             ...future.value <- base::withVisible(base::local({
[16:13:04.233]                 ii
[16:13:04.233]             }))
[16:13:04.233]             future::FutureResult(value = ...future.value$value, 
[16:13:04.233]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.233]                   ...future.rng), globalenv = if (FALSE) 
[16:13:04.233]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:04.233]                     ...future.globalenv.names))
[16:13:04.233]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:04.233]         }, condition = base::local({
[16:13:04.233]             c <- base::c
[16:13:04.233]             inherits <- base::inherits
[16:13:04.233]             invokeRestart <- base::invokeRestart
[16:13:04.233]             length <- base::length
[16:13:04.233]             list <- base::list
[16:13:04.233]             seq.int <- base::seq.int
[16:13:04.233]             signalCondition <- base::signalCondition
[16:13:04.233]             sys.calls <- base::sys.calls
[16:13:04.233]             `[[` <- base::`[[`
[16:13:04.233]             `+` <- base::`+`
[16:13:04.233]             `<<-` <- base::`<<-`
[16:13:04.233]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:04.233]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:04.233]                   3L)]
[16:13:04.233]             }
[16:13:04.233]             function(cond) {
[16:13:04.233]                 is_error <- inherits(cond, "error")
[16:13:04.233]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:04.233]                   NULL)
[16:13:04.233]                 if (is_error) {
[16:13:04.233]                   sessionInformation <- function() {
[16:13:04.233]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:04.233]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:04.233]                       search = base::search(), system = base::Sys.info())
[16:13:04.233]                   }
[16:13:04.233]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.233]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:04.233]                     cond$call), session = sessionInformation(), 
[16:13:04.233]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:04.233]                   signalCondition(cond)
[16:13:04.233]                 }
[16:13:04.233]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:04.233]                 "immediateCondition"))) {
[16:13:04.233]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:04.233]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.233]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:04.233]                   if (TRUE && !signal) {
[16:13:04.233]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.233]                     {
[16:13:04.233]                       inherits <- base::inherits
[16:13:04.233]                       invokeRestart <- base::invokeRestart
[16:13:04.233]                       is.null <- base::is.null
[16:13:04.233]                       muffled <- FALSE
[16:13:04.233]                       if (inherits(cond, "message")) {
[16:13:04.233]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.233]                         if (muffled) 
[16:13:04.233]                           invokeRestart("muffleMessage")
[16:13:04.233]                       }
[16:13:04.233]                       else if (inherits(cond, "warning")) {
[16:13:04.233]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.233]                         if (muffled) 
[16:13:04.233]                           invokeRestart("muffleWarning")
[16:13:04.233]                       }
[16:13:04.233]                       else if (inherits(cond, "condition")) {
[16:13:04.233]                         if (!is.null(pattern)) {
[16:13:04.233]                           computeRestarts <- base::computeRestarts
[16:13:04.233]                           grepl <- base::grepl
[16:13:04.233]                           restarts <- computeRestarts(cond)
[16:13:04.233]                           for (restart in restarts) {
[16:13:04.233]                             name <- restart$name
[16:13:04.233]                             if (is.null(name)) 
[16:13:04.233]                               next
[16:13:04.233]                             if (!grepl(pattern, name)) 
[16:13:04.233]                               next
[16:13:04.233]                             invokeRestart(restart)
[16:13:04.233]                             muffled <- TRUE
[16:13:04.233]                             break
[16:13:04.233]                           }
[16:13:04.233]                         }
[16:13:04.233]                       }
[16:13:04.233]                       invisible(muffled)
[16:13:04.233]                     }
[16:13:04.233]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.233]                   }
[16:13:04.233]                 }
[16:13:04.233]                 else {
[16:13:04.233]                   if (TRUE) {
[16:13:04.233]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.233]                     {
[16:13:04.233]                       inherits <- base::inherits
[16:13:04.233]                       invokeRestart <- base::invokeRestart
[16:13:04.233]                       is.null <- base::is.null
[16:13:04.233]                       muffled <- FALSE
[16:13:04.233]                       if (inherits(cond, "message")) {
[16:13:04.233]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.233]                         if (muffled) 
[16:13:04.233]                           invokeRestart("muffleMessage")
[16:13:04.233]                       }
[16:13:04.233]                       else if (inherits(cond, "warning")) {
[16:13:04.233]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.233]                         if (muffled) 
[16:13:04.233]                           invokeRestart("muffleWarning")
[16:13:04.233]                       }
[16:13:04.233]                       else if (inherits(cond, "condition")) {
[16:13:04.233]                         if (!is.null(pattern)) {
[16:13:04.233]                           computeRestarts <- base::computeRestarts
[16:13:04.233]                           grepl <- base::grepl
[16:13:04.233]                           restarts <- computeRestarts(cond)
[16:13:04.233]                           for (restart in restarts) {
[16:13:04.233]                             name <- restart$name
[16:13:04.233]                             if (is.null(name)) 
[16:13:04.233]                               next
[16:13:04.233]                             if (!grepl(pattern, name)) 
[16:13:04.233]                               next
[16:13:04.233]                             invokeRestart(restart)
[16:13:04.233]                             muffled <- TRUE
[16:13:04.233]                             break
[16:13:04.233]                           }
[16:13:04.233]                         }
[16:13:04.233]                       }
[16:13:04.233]                       invisible(muffled)
[16:13:04.233]                     }
[16:13:04.233]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.233]                   }
[16:13:04.233]                 }
[16:13:04.233]             }
[16:13:04.233]         }))
[16:13:04.233]     }, error = function(ex) {
[16:13:04.233]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:04.233]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.233]                 ...future.rng), started = ...future.startTime, 
[16:13:04.233]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:04.233]             version = "1.8"), class = "FutureResult")
[16:13:04.233]     }, finally = {
[16:13:04.233]         if (!identical(...future.workdir, getwd())) 
[16:13:04.233]             setwd(...future.workdir)
[16:13:04.233]         {
[16:13:04.233]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:04.233]                 ...future.oldOptions$nwarnings <- NULL
[16:13:04.233]             }
[16:13:04.233]             base::options(...future.oldOptions)
[16:13:04.233]             if (.Platform$OS.type == "windows") {
[16:13:04.233]                 old_names <- names(...future.oldEnvVars)
[16:13:04.233]                 envs <- base::Sys.getenv()
[16:13:04.233]                 names <- names(envs)
[16:13:04.233]                 common <- intersect(names, old_names)
[16:13:04.233]                 added <- setdiff(names, old_names)
[16:13:04.233]                 removed <- setdiff(old_names, names)
[16:13:04.233]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:04.233]                   envs[common]]
[16:13:04.233]                 NAMES <- toupper(changed)
[16:13:04.233]                 args <- list()
[16:13:04.233]                 for (kk in seq_along(NAMES)) {
[16:13:04.233]                   name <- changed[[kk]]
[16:13:04.233]                   NAME <- NAMES[[kk]]
[16:13:04.233]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.233]                     next
[16:13:04.233]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.233]                 }
[16:13:04.233]                 NAMES <- toupper(added)
[16:13:04.233]                 for (kk in seq_along(NAMES)) {
[16:13:04.233]                   name <- added[[kk]]
[16:13:04.233]                   NAME <- NAMES[[kk]]
[16:13:04.233]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.233]                     next
[16:13:04.233]                   args[[name]] <- ""
[16:13:04.233]                 }
[16:13:04.233]                 NAMES <- toupper(removed)
[16:13:04.233]                 for (kk in seq_along(NAMES)) {
[16:13:04.233]                   name <- removed[[kk]]
[16:13:04.233]                   NAME <- NAMES[[kk]]
[16:13:04.233]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.233]                     next
[16:13:04.233]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.233]                 }
[16:13:04.233]                 if (length(args) > 0) 
[16:13:04.233]                   base::do.call(base::Sys.setenv, args = args)
[16:13:04.233]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:04.233]             }
[16:13:04.233]             else {
[16:13:04.233]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:04.233]             }
[16:13:04.233]             {
[16:13:04.233]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:04.233]                   0L) {
[16:13:04.233]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:04.233]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:04.233]                   base::options(opts)
[16:13:04.233]                 }
[16:13:04.233]                 {
[16:13:04.233]                   {
[16:13:04.233]                     NULL
[16:13:04.233]                     RNGkind("Mersenne-Twister")
[16:13:04.233]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:04.233]                       inherits = FALSE)
[16:13:04.233]                   }
[16:13:04.233]                   options(future.plan = NULL)
[16:13:04.233]                   if (is.na(NA_character_)) 
[16:13:04.233]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.233]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:04.233]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:04.233]                     envir = parent.frame()) 
[16:13:04.233]                   {
[16:13:04.233]                     default_workers <- missing(workers)
[16:13:04.233]                     if (is.function(workers)) 
[16:13:04.233]                       workers <- workers()
[16:13:04.233]                     workers <- structure(as.integer(workers), 
[16:13:04.233]                       class = class(workers))
[16:13:04.233]                     stop_if_not(is.finite(workers), workers >= 
[16:13:04.233]                       1L)
[16:13:04.233]                     if ((workers == 1L && !inherits(workers, 
[16:13:04.233]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:04.233]                       if (default_workers) 
[16:13:04.233]                         supportsMulticore(warn = TRUE)
[16:13:04.233]                       return(sequential(..., envir = envir))
[16:13:04.233]                     }
[16:13:04.233]                     oopts <- options(mc.cores = workers)
[16:13:04.233]                     on.exit(options(oopts))
[16:13:04.233]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:04.233]                       envir = envir)
[16:13:04.233]                     if (!future$lazy) 
[16:13:04.233]                       future <- run(future)
[16:13:04.233]                     invisible(future)
[16:13:04.233]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:04.233]                 }
[16:13:04.233]             }
[16:13:04.233]         }
[16:13:04.233]     })
[16:13:04.233]     if (TRUE) {
[16:13:04.233]         base::sink(type = "output", split = FALSE)
[16:13:04.233]         if (TRUE) {
[16:13:04.233]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:04.233]         }
[16:13:04.233]         else {
[16:13:04.233]             ...future.result["stdout"] <- base::list(NULL)
[16:13:04.233]         }
[16:13:04.233]         base::close(...future.stdout)
[16:13:04.233]         ...future.stdout <- NULL
[16:13:04.233]     }
[16:13:04.233]     ...future.result$conditions <- ...future.conditions
[16:13:04.233]     ...future.result$finished <- base::Sys.time()
[16:13:04.233]     ...future.result
[16:13:04.233] }
[16:13:04.235] assign_globals() ...
[16:13:04.235] List of 1
[16:13:04.235]  $ ii: int 2
[16:13:04.235]  - attr(*, "where")=List of 1
[16:13:04.235]   ..$ ii:<environment: R_EmptyEnv> 
[16:13:04.235]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:04.235]  - attr(*, "resolved")= logi FALSE
[16:13:04.235]  - attr(*, "total_size")= num 56
[16:13:04.239] - copied ‘ii’ to environment
[16:13:04.239] assign_globals() ... done
[16:13:04.239] plan(): Setting new future strategy stack:
[16:13:04.239] List of future strategies:
[16:13:04.239] 1. sequential:
[16:13:04.239]    - args: function (..., envir = parent.frame())
[16:13:04.239]    - tweaked: FALSE
[16:13:04.239]    - call: NULL
[16:13:04.239] plan(): nbrOfWorkers() = 1
[16:13:04.240] plan(): Setting new future strategy stack:
[16:13:04.240] List of future strategies:
[16:13:04.240] 1. multicore:
[16:13:04.240]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:04.240]    - tweaked: FALSE
[16:13:04.240]    - call: plan(multicore)
[16:13:04.243] plan(): nbrOfWorkers() = 1
[16:13:04.244] SequentialFuture started (and completed)
 - Creating multicore future #3 ...
[16:13:04.247] getGlobalsAndPackages() ...
[16:13:04.247] Searching for globals...
[16:13:04.248] - globals found: [2] ‘{’, ‘ii’
[16:13:04.248] Searching for globals ... DONE
[16:13:04.248] Resolving globals: FALSE
[16:13:04.248] The total size of the 1 globals is 56 bytes (56 bytes)
[16:13:04.249] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:13:04.249] - globals: [1] ‘ii’
[16:13:04.249] 
[16:13:04.249] getGlobalsAndPackages() ... DONE
[16:13:04.249] Packages needed by the future expression (n = 0): <none>
[16:13:04.249] Packages needed by future strategies (n = 0): <none>
[16:13:04.250] {
[16:13:04.250]     {
[16:13:04.250]         {
[16:13:04.250]             ...future.startTime <- base::Sys.time()
[16:13:04.250]             {
[16:13:04.250]                 {
[16:13:04.250]                   {
[16:13:04.250]                     base::local({
[16:13:04.250]                       has_future <- base::requireNamespace("future", 
[16:13:04.250]                         quietly = TRUE)
[16:13:04.250]                       if (has_future) {
[16:13:04.250]                         ns <- base::getNamespace("future")
[16:13:04.250]                         version <- ns[[".package"]][["version"]]
[16:13:04.250]                         if (is.null(version)) 
[16:13:04.250]                           version <- utils::packageVersion("future")
[16:13:04.250]                       }
[16:13:04.250]                       else {
[16:13:04.250]                         version <- NULL
[16:13:04.250]                       }
[16:13:04.250]                       if (!has_future || version < "1.8.0") {
[16:13:04.250]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:04.250]                           "", base::R.version$version.string), 
[16:13:04.250]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:04.250]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:04.250]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:04.250]                             "release", "version")], collapse = " "), 
[16:13:04.250]                           hostname = base::Sys.info()[["nodename"]])
[16:13:04.250]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:04.250]                           info)
[16:13:04.250]                         info <- base::paste(info, collapse = "; ")
[16:13:04.250]                         if (!has_future) {
[16:13:04.250]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:04.250]                             info)
[16:13:04.250]                         }
[16:13:04.250]                         else {
[16:13:04.250]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:04.250]                             info, version)
[16:13:04.250]                         }
[16:13:04.250]                         base::stop(msg)
[16:13:04.250]                       }
[16:13:04.250]                     })
[16:13:04.250]                   }
[16:13:04.250]                   options(future.plan = NULL)
[16:13:04.250]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.250]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:04.250]                 }
[16:13:04.250]                 ...future.workdir <- getwd()
[16:13:04.250]             }
[16:13:04.250]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:04.250]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:04.250]         }
[16:13:04.250]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:04.250]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:04.250]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:04.250]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:04.250]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:04.250]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:04.250]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:04.250]             base::names(...future.oldOptions))
[16:13:04.250]     }
[16:13:04.250]     if (FALSE) {
[16:13:04.250]     }
[16:13:04.250]     else {
[16:13:04.250]         if (TRUE) {
[16:13:04.250]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:04.250]                 open = "w")
[16:13:04.250]         }
[16:13:04.250]         else {
[16:13:04.250]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:04.250]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:04.250]         }
[16:13:04.250]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:04.250]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:04.250]             base::sink(type = "output", split = FALSE)
[16:13:04.250]             base::close(...future.stdout)
[16:13:04.250]         }, add = TRUE)
[16:13:04.250]     }
[16:13:04.250]     ...future.frame <- base::sys.nframe()
[16:13:04.250]     ...future.conditions <- base::list()
[16:13:04.250]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:04.250]     if (FALSE) {
[16:13:04.250]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:04.250]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:04.250]     }
[16:13:04.250]     ...future.result <- base::tryCatch({
[16:13:04.250]         base::withCallingHandlers({
[16:13:04.250]             ...future.value <- base::withVisible(base::local({
[16:13:04.250]                 ii
[16:13:04.250]             }))
[16:13:04.250]             future::FutureResult(value = ...future.value$value, 
[16:13:04.250]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.250]                   ...future.rng), globalenv = if (FALSE) 
[16:13:04.250]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:04.250]                     ...future.globalenv.names))
[16:13:04.250]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:04.250]         }, condition = base::local({
[16:13:04.250]             c <- base::c
[16:13:04.250]             inherits <- base::inherits
[16:13:04.250]             invokeRestart <- base::invokeRestart
[16:13:04.250]             length <- base::length
[16:13:04.250]             list <- base::list
[16:13:04.250]             seq.int <- base::seq.int
[16:13:04.250]             signalCondition <- base::signalCondition
[16:13:04.250]             sys.calls <- base::sys.calls
[16:13:04.250]             `[[` <- base::`[[`
[16:13:04.250]             `+` <- base::`+`
[16:13:04.250]             `<<-` <- base::`<<-`
[16:13:04.250]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:04.250]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:04.250]                   3L)]
[16:13:04.250]             }
[16:13:04.250]             function(cond) {
[16:13:04.250]                 is_error <- inherits(cond, "error")
[16:13:04.250]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:04.250]                   NULL)
[16:13:04.250]                 if (is_error) {
[16:13:04.250]                   sessionInformation <- function() {
[16:13:04.250]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:04.250]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:04.250]                       search = base::search(), system = base::Sys.info())
[16:13:04.250]                   }
[16:13:04.250]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.250]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:04.250]                     cond$call), session = sessionInformation(), 
[16:13:04.250]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:04.250]                   signalCondition(cond)
[16:13:04.250]                 }
[16:13:04.250]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:04.250]                 "immediateCondition"))) {
[16:13:04.250]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:04.250]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.250]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:04.250]                   if (TRUE && !signal) {
[16:13:04.250]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.250]                     {
[16:13:04.250]                       inherits <- base::inherits
[16:13:04.250]                       invokeRestart <- base::invokeRestart
[16:13:04.250]                       is.null <- base::is.null
[16:13:04.250]                       muffled <- FALSE
[16:13:04.250]                       if (inherits(cond, "message")) {
[16:13:04.250]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.250]                         if (muffled) 
[16:13:04.250]                           invokeRestart("muffleMessage")
[16:13:04.250]                       }
[16:13:04.250]                       else if (inherits(cond, "warning")) {
[16:13:04.250]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.250]                         if (muffled) 
[16:13:04.250]                           invokeRestart("muffleWarning")
[16:13:04.250]                       }
[16:13:04.250]                       else if (inherits(cond, "condition")) {
[16:13:04.250]                         if (!is.null(pattern)) {
[16:13:04.250]                           computeRestarts <- base::computeRestarts
[16:13:04.250]                           grepl <- base::grepl
[16:13:04.250]                           restarts <- computeRestarts(cond)
[16:13:04.250]                           for (restart in restarts) {
[16:13:04.250]                             name <- restart$name
[16:13:04.250]                             if (is.null(name)) 
[16:13:04.250]                               next
[16:13:04.250]                             if (!grepl(pattern, name)) 
[16:13:04.250]                               next
[16:13:04.250]                             invokeRestart(restart)
[16:13:04.250]                             muffled <- TRUE
[16:13:04.250]                             break
[16:13:04.250]                           }
[16:13:04.250]                         }
[16:13:04.250]                       }
[16:13:04.250]                       invisible(muffled)
[16:13:04.250]                     }
[16:13:04.250]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.250]                   }
[16:13:04.250]                 }
[16:13:04.250]                 else {
[16:13:04.250]                   if (TRUE) {
[16:13:04.250]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.250]                     {
[16:13:04.250]                       inherits <- base::inherits
[16:13:04.250]                       invokeRestart <- base::invokeRestart
[16:13:04.250]                       is.null <- base::is.null
[16:13:04.250]                       muffled <- FALSE
[16:13:04.250]                       if (inherits(cond, "message")) {
[16:13:04.250]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.250]                         if (muffled) 
[16:13:04.250]                           invokeRestart("muffleMessage")
[16:13:04.250]                       }
[16:13:04.250]                       else if (inherits(cond, "warning")) {
[16:13:04.250]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.250]                         if (muffled) 
[16:13:04.250]                           invokeRestart("muffleWarning")
[16:13:04.250]                       }
[16:13:04.250]                       else if (inherits(cond, "condition")) {
[16:13:04.250]                         if (!is.null(pattern)) {
[16:13:04.250]                           computeRestarts <- base::computeRestarts
[16:13:04.250]                           grepl <- base::grepl
[16:13:04.250]                           restarts <- computeRestarts(cond)
[16:13:04.250]                           for (restart in restarts) {
[16:13:04.250]                             name <- restart$name
[16:13:04.250]                             if (is.null(name)) 
[16:13:04.250]                               next
[16:13:04.250]                             if (!grepl(pattern, name)) 
[16:13:04.250]                               next
[16:13:04.250]                             invokeRestart(restart)
[16:13:04.250]                             muffled <- TRUE
[16:13:04.250]                             break
[16:13:04.250]                           }
[16:13:04.250]                         }
[16:13:04.250]                       }
[16:13:04.250]                       invisible(muffled)
[16:13:04.250]                     }
[16:13:04.250]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.250]                   }
[16:13:04.250]                 }
[16:13:04.250]             }
[16:13:04.250]         }))
[16:13:04.250]     }, error = function(ex) {
[16:13:04.250]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:04.250]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.250]                 ...future.rng), started = ...future.startTime, 
[16:13:04.250]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:04.250]             version = "1.8"), class = "FutureResult")
[16:13:04.250]     }, finally = {
[16:13:04.250]         if (!identical(...future.workdir, getwd())) 
[16:13:04.250]             setwd(...future.workdir)
[16:13:04.250]         {
[16:13:04.250]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:04.250]                 ...future.oldOptions$nwarnings <- NULL
[16:13:04.250]             }
[16:13:04.250]             base::options(...future.oldOptions)
[16:13:04.250]             if (.Platform$OS.type == "windows") {
[16:13:04.250]                 old_names <- names(...future.oldEnvVars)
[16:13:04.250]                 envs <- base::Sys.getenv()
[16:13:04.250]                 names <- names(envs)
[16:13:04.250]                 common <- intersect(names, old_names)
[16:13:04.250]                 added <- setdiff(names, old_names)
[16:13:04.250]                 removed <- setdiff(old_names, names)
[16:13:04.250]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:04.250]                   envs[common]]
[16:13:04.250]                 NAMES <- toupper(changed)
[16:13:04.250]                 args <- list()
[16:13:04.250]                 for (kk in seq_along(NAMES)) {
[16:13:04.250]                   name <- changed[[kk]]
[16:13:04.250]                   NAME <- NAMES[[kk]]
[16:13:04.250]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.250]                     next
[16:13:04.250]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.250]                 }
[16:13:04.250]                 NAMES <- toupper(added)
[16:13:04.250]                 for (kk in seq_along(NAMES)) {
[16:13:04.250]                   name <- added[[kk]]
[16:13:04.250]                   NAME <- NAMES[[kk]]
[16:13:04.250]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.250]                     next
[16:13:04.250]                   args[[name]] <- ""
[16:13:04.250]                 }
[16:13:04.250]                 NAMES <- toupper(removed)
[16:13:04.250]                 for (kk in seq_along(NAMES)) {
[16:13:04.250]                   name <- removed[[kk]]
[16:13:04.250]                   NAME <- NAMES[[kk]]
[16:13:04.250]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.250]                     next
[16:13:04.250]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.250]                 }
[16:13:04.250]                 if (length(args) > 0) 
[16:13:04.250]                   base::do.call(base::Sys.setenv, args = args)
[16:13:04.250]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:04.250]             }
[16:13:04.250]             else {
[16:13:04.250]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:04.250]             }
[16:13:04.250]             {
[16:13:04.250]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:04.250]                   0L) {
[16:13:04.250]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:04.250]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:04.250]                   base::options(opts)
[16:13:04.250]                 }
[16:13:04.250]                 {
[16:13:04.250]                   {
[16:13:04.250]                     NULL
[16:13:04.250]                     RNGkind("Mersenne-Twister")
[16:13:04.250]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:04.250]                       inherits = FALSE)
[16:13:04.250]                   }
[16:13:04.250]                   options(future.plan = NULL)
[16:13:04.250]                   if (is.na(NA_character_)) 
[16:13:04.250]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.250]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:04.250]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:04.250]                     envir = parent.frame()) 
[16:13:04.250]                   {
[16:13:04.250]                     default_workers <- missing(workers)
[16:13:04.250]                     if (is.function(workers)) 
[16:13:04.250]                       workers <- workers()
[16:13:04.250]                     workers <- structure(as.integer(workers), 
[16:13:04.250]                       class = class(workers))
[16:13:04.250]                     stop_if_not(is.finite(workers), workers >= 
[16:13:04.250]                       1L)
[16:13:04.250]                     if ((workers == 1L && !inherits(workers, 
[16:13:04.250]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:04.250]                       if (default_workers) 
[16:13:04.250]                         supportsMulticore(warn = TRUE)
[16:13:04.250]                       return(sequential(..., envir = envir))
[16:13:04.250]                     }
[16:13:04.250]                     oopts <- options(mc.cores = workers)
[16:13:04.250]                     on.exit(options(oopts))
[16:13:04.250]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:04.250]                       envir = envir)
[16:13:04.250]                     if (!future$lazy) 
[16:13:04.250]                       future <- run(future)
[16:13:04.250]                     invisible(future)
[16:13:04.250]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:04.250]                 }
[16:13:04.250]             }
[16:13:04.250]         }
[16:13:04.250]     })
[16:13:04.250]     if (TRUE) {
[16:13:04.250]         base::sink(type = "output", split = FALSE)
[16:13:04.250]         if (TRUE) {
[16:13:04.250]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:04.250]         }
[16:13:04.250]         else {
[16:13:04.250]             ...future.result["stdout"] <- base::list(NULL)
[16:13:04.250]         }
[16:13:04.250]         base::close(...future.stdout)
[16:13:04.250]         ...future.stdout <- NULL
[16:13:04.250]     }
[16:13:04.250]     ...future.result$conditions <- ...future.conditions
[16:13:04.250]     ...future.result$finished <- base::Sys.time()
[16:13:04.250]     ...future.result
[16:13:04.250] }
[16:13:04.251] assign_globals() ...
[16:13:04.251] List of 1
[16:13:04.251]  $ ii: int 3
[16:13:04.251]  - attr(*, "where")=List of 1
[16:13:04.251]   ..$ ii:<environment: R_EmptyEnv> 
[16:13:04.251]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:04.251]  - attr(*, "resolved")= logi FALSE
[16:13:04.251]  - attr(*, "total_size")= num 56
[16:13:04.253] - copied ‘ii’ to environment
[16:13:04.254] assign_globals() ... done
[16:13:04.254] plan(): Setting new future strategy stack:
[16:13:04.254] List of future strategies:
[16:13:04.254] 1. sequential:
[16:13:04.254]    - args: function (..., envir = parent.frame())
[16:13:04.254]    - tweaked: FALSE
[16:13:04.254]    - call: NULL
[16:13:04.254] plan(): nbrOfWorkers() = 1
[16:13:04.255] plan(): Setting new future strategy stack:
[16:13:04.255] List of future strategies:
[16:13:04.255] 1. multicore:
[16:13:04.255]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:04.255]    - tweaked: FALSE
[16:13:04.255]    - call: plan(multicore)
[16:13:04.258] plan(): nbrOfWorkers() = 1
[16:13:04.259] SequentialFuture started (and completed)
 - Creating multicore future #4 ...
[16:13:04.262] getGlobalsAndPackages() ...
[16:13:04.262] Searching for globals...
[16:13:04.263] - globals found: [2] ‘{’, ‘ii’
[16:13:04.263] Searching for globals ... DONE
[16:13:04.263] Resolving globals: FALSE
[16:13:04.263] The total size of the 1 globals is 56 bytes (56 bytes)
[16:13:04.263] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:13:04.264] - globals: [1] ‘ii’
[16:13:04.264] 
[16:13:04.264] getGlobalsAndPackages() ... DONE
[16:13:04.264] Packages needed by the future expression (n = 0): <none>
[16:13:04.264] Packages needed by future strategies (n = 0): <none>
[16:13:04.265] {
[16:13:04.265]     {
[16:13:04.265]         {
[16:13:04.265]             ...future.startTime <- base::Sys.time()
[16:13:04.265]             {
[16:13:04.265]                 {
[16:13:04.265]                   {
[16:13:04.265]                     base::local({
[16:13:04.265]                       has_future <- base::requireNamespace("future", 
[16:13:04.265]                         quietly = TRUE)
[16:13:04.265]                       if (has_future) {
[16:13:04.265]                         ns <- base::getNamespace("future")
[16:13:04.265]                         version <- ns[[".package"]][["version"]]
[16:13:04.265]                         if (is.null(version)) 
[16:13:04.265]                           version <- utils::packageVersion("future")
[16:13:04.265]                       }
[16:13:04.265]                       else {
[16:13:04.265]                         version <- NULL
[16:13:04.265]                       }
[16:13:04.265]                       if (!has_future || version < "1.8.0") {
[16:13:04.265]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:04.265]                           "", base::R.version$version.string), 
[16:13:04.265]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:04.265]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:04.265]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:04.265]                             "release", "version")], collapse = " "), 
[16:13:04.265]                           hostname = base::Sys.info()[["nodename"]])
[16:13:04.265]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:04.265]                           info)
[16:13:04.265]                         info <- base::paste(info, collapse = "; ")
[16:13:04.265]                         if (!has_future) {
[16:13:04.265]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:04.265]                             info)
[16:13:04.265]                         }
[16:13:04.265]                         else {
[16:13:04.265]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:04.265]                             info, version)
[16:13:04.265]                         }
[16:13:04.265]                         base::stop(msg)
[16:13:04.265]                       }
[16:13:04.265]                     })
[16:13:04.265]                   }
[16:13:04.265]                   options(future.plan = NULL)
[16:13:04.265]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.265]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:04.265]                 }
[16:13:04.265]                 ...future.workdir <- getwd()
[16:13:04.265]             }
[16:13:04.265]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:04.265]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:04.265]         }
[16:13:04.265]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:04.265]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:04.265]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:04.265]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:04.265]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:04.265]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:04.265]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:04.265]             base::names(...future.oldOptions))
[16:13:04.265]     }
[16:13:04.265]     if (FALSE) {
[16:13:04.265]     }
[16:13:04.265]     else {
[16:13:04.265]         if (TRUE) {
[16:13:04.265]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:04.265]                 open = "w")
[16:13:04.265]         }
[16:13:04.265]         else {
[16:13:04.265]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:04.265]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:04.265]         }
[16:13:04.265]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:04.265]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:04.265]             base::sink(type = "output", split = FALSE)
[16:13:04.265]             base::close(...future.stdout)
[16:13:04.265]         }, add = TRUE)
[16:13:04.265]     }
[16:13:04.265]     ...future.frame <- base::sys.nframe()
[16:13:04.265]     ...future.conditions <- base::list()
[16:13:04.265]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:04.265]     if (FALSE) {
[16:13:04.265]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:04.265]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:04.265]     }
[16:13:04.265]     ...future.result <- base::tryCatch({
[16:13:04.265]         base::withCallingHandlers({
[16:13:04.265]             ...future.value <- base::withVisible(base::local({
[16:13:04.265]                 ii
[16:13:04.265]             }))
[16:13:04.265]             future::FutureResult(value = ...future.value$value, 
[16:13:04.265]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.265]                   ...future.rng), globalenv = if (FALSE) 
[16:13:04.265]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:04.265]                     ...future.globalenv.names))
[16:13:04.265]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:04.265]         }, condition = base::local({
[16:13:04.265]             c <- base::c
[16:13:04.265]             inherits <- base::inherits
[16:13:04.265]             invokeRestart <- base::invokeRestart
[16:13:04.265]             length <- base::length
[16:13:04.265]             list <- base::list
[16:13:04.265]             seq.int <- base::seq.int
[16:13:04.265]             signalCondition <- base::signalCondition
[16:13:04.265]             sys.calls <- base::sys.calls
[16:13:04.265]             `[[` <- base::`[[`
[16:13:04.265]             `+` <- base::`+`
[16:13:04.265]             `<<-` <- base::`<<-`
[16:13:04.265]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:04.265]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:04.265]                   3L)]
[16:13:04.265]             }
[16:13:04.265]             function(cond) {
[16:13:04.265]                 is_error <- inherits(cond, "error")
[16:13:04.265]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:04.265]                   NULL)
[16:13:04.265]                 if (is_error) {
[16:13:04.265]                   sessionInformation <- function() {
[16:13:04.265]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:04.265]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:04.265]                       search = base::search(), system = base::Sys.info())
[16:13:04.265]                   }
[16:13:04.265]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.265]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:04.265]                     cond$call), session = sessionInformation(), 
[16:13:04.265]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:04.265]                   signalCondition(cond)
[16:13:04.265]                 }
[16:13:04.265]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:04.265]                 "immediateCondition"))) {
[16:13:04.265]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:04.265]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.265]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:04.265]                   if (TRUE && !signal) {
[16:13:04.265]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.265]                     {
[16:13:04.265]                       inherits <- base::inherits
[16:13:04.265]                       invokeRestart <- base::invokeRestart
[16:13:04.265]                       is.null <- base::is.null
[16:13:04.265]                       muffled <- FALSE
[16:13:04.265]                       if (inherits(cond, "message")) {
[16:13:04.265]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.265]                         if (muffled) 
[16:13:04.265]                           invokeRestart("muffleMessage")
[16:13:04.265]                       }
[16:13:04.265]                       else if (inherits(cond, "warning")) {
[16:13:04.265]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.265]                         if (muffled) 
[16:13:04.265]                           invokeRestart("muffleWarning")
[16:13:04.265]                       }
[16:13:04.265]                       else if (inherits(cond, "condition")) {
[16:13:04.265]                         if (!is.null(pattern)) {
[16:13:04.265]                           computeRestarts <- base::computeRestarts
[16:13:04.265]                           grepl <- base::grepl
[16:13:04.265]                           restarts <- computeRestarts(cond)
[16:13:04.265]                           for (restart in restarts) {
[16:13:04.265]                             name <- restart$name
[16:13:04.265]                             if (is.null(name)) 
[16:13:04.265]                               next
[16:13:04.265]                             if (!grepl(pattern, name)) 
[16:13:04.265]                               next
[16:13:04.265]                             invokeRestart(restart)
[16:13:04.265]                             muffled <- TRUE
[16:13:04.265]                             break
[16:13:04.265]                           }
[16:13:04.265]                         }
[16:13:04.265]                       }
[16:13:04.265]                       invisible(muffled)
[16:13:04.265]                     }
[16:13:04.265]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.265]                   }
[16:13:04.265]                 }
[16:13:04.265]                 else {
[16:13:04.265]                   if (TRUE) {
[16:13:04.265]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.265]                     {
[16:13:04.265]                       inherits <- base::inherits
[16:13:04.265]                       invokeRestart <- base::invokeRestart
[16:13:04.265]                       is.null <- base::is.null
[16:13:04.265]                       muffled <- FALSE
[16:13:04.265]                       if (inherits(cond, "message")) {
[16:13:04.265]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.265]                         if (muffled) 
[16:13:04.265]                           invokeRestart("muffleMessage")
[16:13:04.265]                       }
[16:13:04.265]                       else if (inherits(cond, "warning")) {
[16:13:04.265]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.265]                         if (muffled) 
[16:13:04.265]                           invokeRestart("muffleWarning")
[16:13:04.265]                       }
[16:13:04.265]                       else if (inherits(cond, "condition")) {
[16:13:04.265]                         if (!is.null(pattern)) {
[16:13:04.265]                           computeRestarts <- base::computeRestarts
[16:13:04.265]                           grepl <- base::grepl
[16:13:04.265]                           restarts <- computeRestarts(cond)
[16:13:04.265]                           for (restart in restarts) {
[16:13:04.265]                             name <- restart$name
[16:13:04.265]                             if (is.null(name)) 
[16:13:04.265]                               next
[16:13:04.265]                             if (!grepl(pattern, name)) 
[16:13:04.265]                               next
[16:13:04.265]                             invokeRestart(restart)
[16:13:04.265]                             muffled <- TRUE
[16:13:04.265]                             break
[16:13:04.265]                           }
[16:13:04.265]                         }
[16:13:04.265]                       }
[16:13:04.265]                       invisible(muffled)
[16:13:04.265]                     }
[16:13:04.265]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.265]                   }
[16:13:04.265]                 }
[16:13:04.265]             }
[16:13:04.265]         }))
[16:13:04.265]     }, error = function(ex) {
[16:13:04.265]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:04.265]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.265]                 ...future.rng), started = ...future.startTime, 
[16:13:04.265]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:04.265]             version = "1.8"), class = "FutureResult")
[16:13:04.265]     }, finally = {
[16:13:04.265]         if (!identical(...future.workdir, getwd())) 
[16:13:04.265]             setwd(...future.workdir)
[16:13:04.265]         {
[16:13:04.265]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:04.265]                 ...future.oldOptions$nwarnings <- NULL
[16:13:04.265]             }
[16:13:04.265]             base::options(...future.oldOptions)
[16:13:04.265]             if (.Platform$OS.type == "windows") {
[16:13:04.265]                 old_names <- names(...future.oldEnvVars)
[16:13:04.265]                 envs <- base::Sys.getenv()
[16:13:04.265]                 names <- names(envs)
[16:13:04.265]                 common <- intersect(names, old_names)
[16:13:04.265]                 added <- setdiff(names, old_names)
[16:13:04.265]                 removed <- setdiff(old_names, names)
[16:13:04.265]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:04.265]                   envs[common]]
[16:13:04.265]                 NAMES <- toupper(changed)
[16:13:04.265]                 args <- list()
[16:13:04.265]                 for (kk in seq_along(NAMES)) {
[16:13:04.265]                   name <- changed[[kk]]
[16:13:04.265]                   NAME <- NAMES[[kk]]
[16:13:04.265]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.265]                     next
[16:13:04.265]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.265]                 }
[16:13:04.265]                 NAMES <- toupper(added)
[16:13:04.265]                 for (kk in seq_along(NAMES)) {
[16:13:04.265]                   name <- added[[kk]]
[16:13:04.265]                   NAME <- NAMES[[kk]]
[16:13:04.265]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.265]                     next
[16:13:04.265]                   args[[name]] <- ""
[16:13:04.265]                 }
[16:13:04.265]                 NAMES <- toupper(removed)
[16:13:04.265]                 for (kk in seq_along(NAMES)) {
[16:13:04.265]                   name <- removed[[kk]]
[16:13:04.265]                   NAME <- NAMES[[kk]]
[16:13:04.265]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.265]                     next
[16:13:04.265]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.265]                 }
[16:13:04.265]                 if (length(args) > 0) 
[16:13:04.265]                   base::do.call(base::Sys.setenv, args = args)
[16:13:04.265]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:04.265]             }
[16:13:04.265]             else {
[16:13:04.265]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:04.265]             }
[16:13:04.265]             {
[16:13:04.265]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:04.265]                   0L) {
[16:13:04.265]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:04.265]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:04.265]                   base::options(opts)
[16:13:04.265]                 }
[16:13:04.265]                 {
[16:13:04.265]                   {
[16:13:04.265]                     NULL
[16:13:04.265]                     RNGkind("Mersenne-Twister")
[16:13:04.265]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:04.265]                       inherits = FALSE)
[16:13:04.265]                   }
[16:13:04.265]                   options(future.plan = NULL)
[16:13:04.265]                   if (is.na(NA_character_)) 
[16:13:04.265]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.265]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:04.265]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:04.265]                     envir = parent.frame()) 
[16:13:04.265]                   {
[16:13:04.265]                     default_workers <- missing(workers)
[16:13:04.265]                     if (is.function(workers)) 
[16:13:04.265]                       workers <- workers()
[16:13:04.265]                     workers <- structure(as.integer(workers), 
[16:13:04.265]                       class = class(workers))
[16:13:04.265]                     stop_if_not(is.finite(workers), workers >= 
[16:13:04.265]                       1L)
[16:13:04.265]                     if ((workers == 1L && !inherits(workers, 
[16:13:04.265]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:04.265]                       if (default_workers) 
[16:13:04.265]                         supportsMulticore(warn = TRUE)
[16:13:04.265]                       return(sequential(..., envir = envir))
[16:13:04.265]                     }
[16:13:04.265]                     oopts <- options(mc.cores = workers)
[16:13:04.265]                     on.exit(options(oopts))
[16:13:04.265]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:04.265]                       envir = envir)
[16:13:04.265]                     if (!future$lazy) 
[16:13:04.265]                       future <- run(future)
[16:13:04.265]                     invisible(future)
[16:13:04.265]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:04.265]                 }
[16:13:04.265]             }
[16:13:04.265]         }
[16:13:04.265]     })
[16:13:04.265]     if (TRUE) {
[16:13:04.265]         base::sink(type = "output", split = FALSE)
[16:13:04.265]         if (TRUE) {
[16:13:04.265]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:04.265]         }
[16:13:04.265]         else {
[16:13:04.265]             ...future.result["stdout"] <- base::list(NULL)
[16:13:04.265]         }
[16:13:04.265]         base::close(...future.stdout)
[16:13:04.265]         ...future.stdout <- NULL
[16:13:04.265]     }
[16:13:04.265]     ...future.result$conditions <- ...future.conditions
[16:13:04.265]     ...future.result$finished <- base::Sys.time()
[16:13:04.265]     ...future.result
[16:13:04.265] }
[16:13:04.266] assign_globals() ...
[16:13:04.266] List of 1
[16:13:04.266]  $ ii: int 4
[16:13:04.266]  - attr(*, "where")=List of 1
[16:13:04.266]   ..$ ii:<environment: R_EmptyEnv> 
[16:13:04.266]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:04.266]  - attr(*, "resolved")= logi FALSE
[16:13:04.266]  - attr(*, "total_size")= num 56
[16:13:04.268] - copied ‘ii’ to environment
[16:13:04.269] assign_globals() ... done
[16:13:04.269] plan(): Setting new future strategy stack:
[16:13:04.269] List of future strategies:
[16:13:04.269] 1. sequential:
[16:13:04.269]    - args: function (..., envir = parent.frame())
[16:13:04.269]    - tweaked: FALSE
[16:13:04.269]    - call: NULL
[16:13:04.269] plan(): nbrOfWorkers() = 1
[16:13:04.270] plan(): Setting new future strategy stack:
[16:13:04.270] List of future strategies:
[16:13:04.270] 1. multicore:
[16:13:04.270]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:04.270]    - tweaked: FALSE
[16:13:04.270]    - call: plan(multicore)
[16:13:04.273] plan(): nbrOfWorkers() = 1
[16:13:04.274] SequentialFuture started (and completed)
 - Resolving 4 multicore futures
*** multicore(..., globals = TRUE) and errors
[16:13:04.277] getGlobalsAndPackages() ...
[16:13:04.277] Searching for globals...
[16:13:04.278] - globals found: [2] ‘{’, ‘stop’
[16:13:04.280] Searching for globals ... DONE
[16:13:04.280] Resolving globals: FALSE
[16:13:04.280] 
[16:13:04.281] 
[16:13:04.281] getGlobalsAndPackages() ... DONE
[16:13:04.281] Packages needed by the future expression (n = 0): <none>
[16:13:04.281] Packages needed by future strategies (n = 0): <none>
[16:13:04.282] {
[16:13:04.282]     {
[16:13:04.282]         {
[16:13:04.282]             ...future.startTime <- base::Sys.time()
[16:13:04.282]             {
[16:13:04.282]                 {
[16:13:04.282]                   {
[16:13:04.282]                     base::local({
[16:13:04.282]                       has_future <- base::requireNamespace("future", 
[16:13:04.282]                         quietly = TRUE)
[16:13:04.282]                       if (has_future) {
[16:13:04.282]                         ns <- base::getNamespace("future")
[16:13:04.282]                         version <- ns[[".package"]][["version"]]
[16:13:04.282]                         if (is.null(version)) 
[16:13:04.282]                           version <- utils::packageVersion("future")
[16:13:04.282]                       }
[16:13:04.282]                       else {
[16:13:04.282]                         version <- NULL
[16:13:04.282]                       }
[16:13:04.282]                       if (!has_future || version < "1.8.0") {
[16:13:04.282]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:04.282]                           "", base::R.version$version.string), 
[16:13:04.282]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:04.282]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:04.282]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:04.282]                             "release", "version")], collapse = " "), 
[16:13:04.282]                           hostname = base::Sys.info()[["nodename"]])
[16:13:04.282]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:04.282]                           info)
[16:13:04.282]                         info <- base::paste(info, collapse = "; ")
[16:13:04.282]                         if (!has_future) {
[16:13:04.282]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:04.282]                             info)
[16:13:04.282]                         }
[16:13:04.282]                         else {
[16:13:04.282]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:04.282]                             info, version)
[16:13:04.282]                         }
[16:13:04.282]                         base::stop(msg)
[16:13:04.282]                       }
[16:13:04.282]                     })
[16:13:04.282]                   }
[16:13:04.282]                   options(future.plan = NULL)
[16:13:04.282]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.282]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:04.282]                 }
[16:13:04.282]                 ...future.workdir <- getwd()
[16:13:04.282]             }
[16:13:04.282]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:04.282]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:04.282]         }
[16:13:04.282]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:04.282]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:04.282]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:04.282]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:04.282]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:04.282]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:04.282]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:04.282]             base::names(...future.oldOptions))
[16:13:04.282]     }
[16:13:04.282]     if (FALSE) {
[16:13:04.282]     }
[16:13:04.282]     else {
[16:13:04.282]         if (TRUE) {
[16:13:04.282]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:04.282]                 open = "w")
[16:13:04.282]         }
[16:13:04.282]         else {
[16:13:04.282]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:04.282]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:04.282]         }
[16:13:04.282]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:04.282]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:04.282]             base::sink(type = "output", split = FALSE)
[16:13:04.282]             base::close(...future.stdout)
[16:13:04.282]         }, add = TRUE)
[16:13:04.282]     }
[16:13:04.282]     ...future.frame <- base::sys.nframe()
[16:13:04.282]     ...future.conditions <- base::list()
[16:13:04.282]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:04.282]     if (FALSE) {
[16:13:04.282]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:04.282]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:04.282]     }
[16:13:04.282]     ...future.result <- base::tryCatch({
[16:13:04.282]         base::withCallingHandlers({
[16:13:04.282]             ...future.value <- base::withVisible(base::local({
[16:13:04.282]                 stop("Whoops!")
[16:13:04.282]                 1
[16:13:04.282]             }))
[16:13:04.282]             future::FutureResult(value = ...future.value$value, 
[16:13:04.282]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.282]                   ...future.rng), globalenv = if (FALSE) 
[16:13:04.282]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:04.282]                     ...future.globalenv.names))
[16:13:04.282]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:04.282]         }, condition = base::local({
[16:13:04.282]             c <- base::c
[16:13:04.282]             inherits <- base::inherits
[16:13:04.282]             invokeRestart <- base::invokeRestart
[16:13:04.282]             length <- base::length
[16:13:04.282]             list <- base::list
[16:13:04.282]             seq.int <- base::seq.int
[16:13:04.282]             signalCondition <- base::signalCondition
[16:13:04.282]             sys.calls <- base::sys.calls
[16:13:04.282]             `[[` <- base::`[[`
[16:13:04.282]             `+` <- base::`+`
[16:13:04.282]             `<<-` <- base::`<<-`
[16:13:04.282]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:04.282]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:04.282]                   3L)]
[16:13:04.282]             }
[16:13:04.282]             function(cond) {
[16:13:04.282]                 is_error <- inherits(cond, "error")
[16:13:04.282]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:04.282]                   NULL)
[16:13:04.282]                 if (is_error) {
[16:13:04.282]                   sessionInformation <- function() {
[16:13:04.282]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:04.282]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:04.282]                       search = base::search(), system = base::Sys.info())
[16:13:04.282]                   }
[16:13:04.282]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.282]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:04.282]                     cond$call), session = sessionInformation(), 
[16:13:04.282]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:04.282]                   signalCondition(cond)
[16:13:04.282]                 }
[16:13:04.282]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:04.282]                 "immediateCondition"))) {
[16:13:04.282]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:04.282]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.282]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:04.282]                   if (TRUE && !signal) {
[16:13:04.282]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.282]                     {
[16:13:04.282]                       inherits <- base::inherits
[16:13:04.282]                       invokeRestart <- base::invokeRestart
[16:13:04.282]                       is.null <- base::is.null
[16:13:04.282]                       muffled <- FALSE
[16:13:04.282]                       if (inherits(cond, "message")) {
[16:13:04.282]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.282]                         if (muffled) 
[16:13:04.282]                           invokeRestart("muffleMessage")
[16:13:04.282]                       }
[16:13:04.282]                       else if (inherits(cond, "warning")) {
[16:13:04.282]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.282]                         if (muffled) 
[16:13:04.282]                           invokeRestart("muffleWarning")
[16:13:04.282]                       }
[16:13:04.282]                       else if (inherits(cond, "condition")) {
[16:13:04.282]                         if (!is.null(pattern)) {
[16:13:04.282]                           computeRestarts <- base::computeRestarts
[16:13:04.282]                           grepl <- base::grepl
[16:13:04.282]                           restarts <- computeRestarts(cond)
[16:13:04.282]                           for (restart in restarts) {
[16:13:04.282]                             name <- restart$name
[16:13:04.282]                             if (is.null(name)) 
[16:13:04.282]                               next
[16:13:04.282]                             if (!grepl(pattern, name)) 
[16:13:04.282]                               next
[16:13:04.282]                             invokeRestart(restart)
[16:13:04.282]                             muffled <- TRUE
[16:13:04.282]                             break
[16:13:04.282]                           }
[16:13:04.282]                         }
[16:13:04.282]                       }
[16:13:04.282]                       invisible(muffled)
[16:13:04.282]                     }
[16:13:04.282]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.282]                   }
[16:13:04.282]                 }
[16:13:04.282]                 else {
[16:13:04.282]                   if (TRUE) {
[16:13:04.282]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.282]                     {
[16:13:04.282]                       inherits <- base::inherits
[16:13:04.282]                       invokeRestart <- base::invokeRestart
[16:13:04.282]                       is.null <- base::is.null
[16:13:04.282]                       muffled <- FALSE
[16:13:04.282]                       if (inherits(cond, "message")) {
[16:13:04.282]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.282]                         if (muffled) 
[16:13:04.282]                           invokeRestart("muffleMessage")
[16:13:04.282]                       }
[16:13:04.282]                       else if (inherits(cond, "warning")) {
[16:13:04.282]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.282]                         if (muffled) 
[16:13:04.282]                           invokeRestart("muffleWarning")
[16:13:04.282]                       }
[16:13:04.282]                       else if (inherits(cond, "condition")) {
[16:13:04.282]                         if (!is.null(pattern)) {
[16:13:04.282]                           computeRestarts <- base::computeRestarts
[16:13:04.282]                           grepl <- base::grepl
[16:13:04.282]                           restarts <- computeRestarts(cond)
[16:13:04.282]                           for (restart in restarts) {
[16:13:04.282]                             name <- restart$name
[16:13:04.282]                             if (is.null(name)) 
[16:13:04.282]                               next
[16:13:04.282]                             if (!grepl(pattern, name)) 
[16:13:04.282]                               next
[16:13:04.282]                             invokeRestart(restart)
[16:13:04.282]                             muffled <- TRUE
[16:13:04.282]                             break
[16:13:04.282]                           }
[16:13:04.282]                         }
[16:13:04.282]                       }
[16:13:04.282]                       invisible(muffled)
[16:13:04.282]                     }
[16:13:04.282]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.282]                   }
[16:13:04.282]                 }
[16:13:04.282]             }
[16:13:04.282]         }))
[16:13:04.282]     }, error = function(ex) {
[16:13:04.282]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:04.282]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.282]                 ...future.rng), started = ...future.startTime, 
[16:13:04.282]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:04.282]             version = "1.8"), class = "FutureResult")
[16:13:04.282]     }, finally = {
[16:13:04.282]         if (!identical(...future.workdir, getwd())) 
[16:13:04.282]             setwd(...future.workdir)
[16:13:04.282]         {
[16:13:04.282]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:04.282]                 ...future.oldOptions$nwarnings <- NULL
[16:13:04.282]             }
[16:13:04.282]             base::options(...future.oldOptions)
[16:13:04.282]             if (.Platform$OS.type == "windows") {
[16:13:04.282]                 old_names <- names(...future.oldEnvVars)
[16:13:04.282]                 envs <- base::Sys.getenv()
[16:13:04.282]                 names <- names(envs)
[16:13:04.282]                 common <- intersect(names, old_names)
[16:13:04.282]                 added <- setdiff(names, old_names)
[16:13:04.282]                 removed <- setdiff(old_names, names)
[16:13:04.282]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:04.282]                   envs[common]]
[16:13:04.282]                 NAMES <- toupper(changed)
[16:13:04.282]                 args <- list()
[16:13:04.282]                 for (kk in seq_along(NAMES)) {
[16:13:04.282]                   name <- changed[[kk]]
[16:13:04.282]                   NAME <- NAMES[[kk]]
[16:13:04.282]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.282]                     next
[16:13:04.282]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.282]                 }
[16:13:04.282]                 NAMES <- toupper(added)
[16:13:04.282]                 for (kk in seq_along(NAMES)) {
[16:13:04.282]                   name <- added[[kk]]
[16:13:04.282]                   NAME <- NAMES[[kk]]
[16:13:04.282]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.282]                     next
[16:13:04.282]                   args[[name]] <- ""
[16:13:04.282]                 }
[16:13:04.282]                 NAMES <- toupper(removed)
[16:13:04.282]                 for (kk in seq_along(NAMES)) {
[16:13:04.282]                   name <- removed[[kk]]
[16:13:04.282]                   NAME <- NAMES[[kk]]
[16:13:04.282]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.282]                     next
[16:13:04.282]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.282]                 }
[16:13:04.282]                 if (length(args) > 0) 
[16:13:04.282]                   base::do.call(base::Sys.setenv, args = args)
[16:13:04.282]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:04.282]             }
[16:13:04.282]             else {
[16:13:04.282]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:04.282]             }
[16:13:04.282]             {
[16:13:04.282]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:04.282]                   0L) {
[16:13:04.282]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:04.282]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:04.282]                   base::options(opts)
[16:13:04.282]                 }
[16:13:04.282]                 {
[16:13:04.282]                   {
[16:13:04.282]                     NULL
[16:13:04.282]                     RNGkind("Mersenne-Twister")
[16:13:04.282]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:04.282]                       inherits = FALSE)
[16:13:04.282]                   }
[16:13:04.282]                   options(future.plan = NULL)
[16:13:04.282]                   if (is.na(NA_character_)) 
[16:13:04.282]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.282]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:04.282]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:04.282]                     envir = parent.frame()) 
[16:13:04.282]                   {
[16:13:04.282]                     default_workers <- missing(workers)
[16:13:04.282]                     if (is.function(workers)) 
[16:13:04.282]                       workers <- workers()
[16:13:04.282]                     workers <- structure(as.integer(workers), 
[16:13:04.282]                       class = class(workers))
[16:13:04.282]                     stop_if_not(is.finite(workers), workers >= 
[16:13:04.282]                       1L)
[16:13:04.282]                     if ((workers == 1L && !inherits(workers, 
[16:13:04.282]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:04.282]                       if (default_workers) 
[16:13:04.282]                         supportsMulticore(warn = TRUE)
[16:13:04.282]                       return(sequential(..., envir = envir))
[16:13:04.282]                     }
[16:13:04.282]                     oopts <- options(mc.cores = workers)
[16:13:04.282]                     on.exit(options(oopts))
[16:13:04.282]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:04.282]                       envir = envir)
[16:13:04.282]                     if (!future$lazy) 
[16:13:04.282]                       future <- run(future)
[16:13:04.282]                     invisible(future)
[16:13:04.282]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:04.282]                 }
[16:13:04.282]             }
[16:13:04.282]         }
[16:13:04.282]     })
[16:13:04.282]     if (TRUE) {
[16:13:04.282]         base::sink(type = "output", split = FALSE)
[16:13:04.282]         if (TRUE) {
[16:13:04.282]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:04.282]         }
[16:13:04.282]         else {
[16:13:04.282]             ...future.result["stdout"] <- base::list(NULL)
[16:13:04.282]         }
[16:13:04.282]         base::close(...future.stdout)
[16:13:04.282]         ...future.stdout <- NULL
[16:13:04.282]     }
[16:13:04.282]     ...future.result$conditions <- ...future.conditions
[16:13:04.282]     ...future.result$finished <- base::Sys.time()
[16:13:04.282]     ...future.result
[16:13:04.282] }
[16:13:04.283] plan(): Setting new future strategy stack:
[16:13:04.283] List of future strategies:
[16:13:04.283] 1. sequential:
[16:13:04.283]    - args: function (..., envir = parent.frame())
[16:13:04.283]    - tweaked: FALSE
[16:13:04.283]    - call: NULL
[16:13:04.284] plan(): nbrOfWorkers() = 1
[16:13:04.285] plan(): Setting new future strategy stack:
[16:13:04.285] List of future strategies:
[16:13:04.285] 1. multicore:
[16:13:04.285]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:04.285]    - tweaked: FALSE
[16:13:04.285]    - call: plan(multicore)
[16:13:04.288] plan(): nbrOfWorkers() = 1
[16:13:04.288] SequentialFuture started (and completed)
[16:13:04.289] signalConditions() ...
[16:13:04.289]  - include = ‘immediateCondition’
[16:13:04.289]  - exclude = 
[16:13:04.289]  - resignal = FALSE
[16:13:04.289]  - Number of conditions: 1
[16:13:04.289] signalConditions() ... done
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 0 bytes of class ‘NULL’
Conditions captured: [n=1] ‘simpleError’
Early signaling: FALSE
Owner process: 9cd5072f-68f7-e4f0-6d65-cff53a745767
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:04.290] signalConditions() ...
[16:13:04.290]  - include = ‘immediateCondition’
[16:13:04.290]  - exclude = 
[16:13:04.290]  - resignal = FALSE
[16:13:04.290]  - Number of conditions: 1
[16:13:04.290] signalConditions() ... done
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[16:13:04.290] signalConditions() ...
[16:13:04.290]  - include = ‘immediateCondition’
[16:13:04.291]  - exclude = 
[16:13:04.291]  - resignal = FALSE
[16:13:04.291]  - Number of conditions: 1
[16:13:04.291] signalConditions() ... done
[16:13:04.291] Future state: ‘finished’
[16:13:04.291] signalConditions() ...
[16:13:04.291]  - include = ‘condition’
[16:13:04.291]  - exclude = ‘immediateCondition’
[16:13:04.291]  - resignal = TRUE
[16:13:04.291]  - Number of conditions: 1
[16:13:04.292]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:13:04.292] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[16:13:04.292] signalConditions() ...
[16:13:04.292]  - include = ‘immediateCondition’
[16:13:04.292]  - exclude = 
[16:13:04.292]  - resignal = FALSE
[16:13:04.292]  - Number of conditions: 1
[16:13:04.293] signalConditions() ... done
[16:13:04.293] Future state: ‘finished’
[16:13:04.293] signalConditions() ...
[16:13:04.293]  - include = ‘condition’
[16:13:04.293]  - exclude = ‘immediateCondition’
[16:13:04.293]  - resignal = TRUE
[16:13:04.293]  - Number of conditions: 1
[16:13:04.293]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:13:04.293] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[16:13:04.297] getGlobalsAndPackages() ...
[16:13:04.297] Searching for globals...
[16:13:04.298] - globals found: [5] ‘{’, ‘stop’, ‘structure’, ‘list’, ‘c’
[16:13:04.298] Searching for globals ... DONE
[16:13:04.298] Resolving globals: FALSE
[16:13:04.299] 
[16:13:04.299] 
[16:13:04.299] getGlobalsAndPackages() ... DONE
[16:13:04.299] Packages needed by the future expression (n = 0): <none>
[16:13:04.299] Packages needed by future strategies (n = 0): <none>
[16:13:04.300] {
[16:13:04.300]     {
[16:13:04.300]         {
[16:13:04.300]             ...future.startTime <- base::Sys.time()
[16:13:04.300]             {
[16:13:04.300]                 {
[16:13:04.300]                   {
[16:13:04.300]                     base::local({
[16:13:04.300]                       has_future <- base::requireNamespace("future", 
[16:13:04.300]                         quietly = TRUE)
[16:13:04.300]                       if (has_future) {
[16:13:04.300]                         ns <- base::getNamespace("future")
[16:13:04.300]                         version <- ns[[".package"]][["version"]]
[16:13:04.300]                         if (is.null(version)) 
[16:13:04.300]                           version <- utils::packageVersion("future")
[16:13:04.300]                       }
[16:13:04.300]                       else {
[16:13:04.300]                         version <- NULL
[16:13:04.300]                       }
[16:13:04.300]                       if (!has_future || version < "1.8.0") {
[16:13:04.300]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:04.300]                           "", base::R.version$version.string), 
[16:13:04.300]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:04.300]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:04.300]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:04.300]                             "release", "version")], collapse = " "), 
[16:13:04.300]                           hostname = base::Sys.info()[["nodename"]])
[16:13:04.300]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:04.300]                           info)
[16:13:04.300]                         info <- base::paste(info, collapse = "; ")
[16:13:04.300]                         if (!has_future) {
[16:13:04.300]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:04.300]                             info)
[16:13:04.300]                         }
[16:13:04.300]                         else {
[16:13:04.300]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:04.300]                             info, version)
[16:13:04.300]                         }
[16:13:04.300]                         base::stop(msg)
[16:13:04.300]                       }
[16:13:04.300]                     })
[16:13:04.300]                   }
[16:13:04.300]                   options(future.plan = NULL)
[16:13:04.300]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.300]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:04.300]                 }
[16:13:04.300]                 ...future.workdir <- getwd()
[16:13:04.300]             }
[16:13:04.300]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:04.300]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:04.300]         }
[16:13:04.300]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:04.300]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:04.300]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:04.300]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:04.300]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:04.300]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:04.300]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:04.300]             base::names(...future.oldOptions))
[16:13:04.300]     }
[16:13:04.300]     if (FALSE) {
[16:13:04.300]     }
[16:13:04.300]     else {
[16:13:04.300]         if (TRUE) {
[16:13:04.300]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:04.300]                 open = "w")
[16:13:04.300]         }
[16:13:04.300]         else {
[16:13:04.300]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:04.300]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:04.300]         }
[16:13:04.300]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:04.300]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:04.300]             base::sink(type = "output", split = FALSE)
[16:13:04.300]             base::close(...future.stdout)
[16:13:04.300]         }, add = TRUE)
[16:13:04.300]     }
[16:13:04.300]     ...future.frame <- base::sys.nframe()
[16:13:04.300]     ...future.conditions <- base::list()
[16:13:04.300]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:04.300]     if (FALSE) {
[16:13:04.300]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:04.300]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:04.300]     }
[16:13:04.300]     ...future.result <- base::tryCatch({
[16:13:04.300]         base::withCallingHandlers({
[16:13:04.300]             ...future.value <- base::withVisible(base::local({
[16:13:04.300]                 stop(structure(list(message = "boom"), class = c("MyError", 
[16:13:04.300]                   "error", "condition")))
[16:13:04.300]             }))
[16:13:04.300]             future::FutureResult(value = ...future.value$value, 
[16:13:04.300]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.300]                   ...future.rng), globalenv = if (FALSE) 
[16:13:04.300]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:04.300]                     ...future.globalenv.names))
[16:13:04.300]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:04.300]         }, condition = base::local({
[16:13:04.300]             c <- base::c
[16:13:04.300]             inherits <- base::inherits
[16:13:04.300]             invokeRestart <- base::invokeRestart
[16:13:04.300]             length <- base::length
[16:13:04.300]             list <- base::list
[16:13:04.300]             seq.int <- base::seq.int
[16:13:04.300]             signalCondition <- base::signalCondition
[16:13:04.300]             sys.calls <- base::sys.calls
[16:13:04.300]             `[[` <- base::`[[`
[16:13:04.300]             `+` <- base::`+`
[16:13:04.300]             `<<-` <- base::`<<-`
[16:13:04.300]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:04.300]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:04.300]                   3L)]
[16:13:04.300]             }
[16:13:04.300]             function(cond) {
[16:13:04.300]                 is_error <- inherits(cond, "error")
[16:13:04.300]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:04.300]                   NULL)
[16:13:04.300]                 if (is_error) {
[16:13:04.300]                   sessionInformation <- function() {
[16:13:04.300]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:04.300]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:04.300]                       search = base::search(), system = base::Sys.info())
[16:13:04.300]                   }
[16:13:04.300]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.300]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:04.300]                     cond$call), session = sessionInformation(), 
[16:13:04.300]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:04.300]                   signalCondition(cond)
[16:13:04.300]                 }
[16:13:04.300]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:04.300]                 "immediateCondition"))) {
[16:13:04.300]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:04.300]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.300]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:04.300]                   if (TRUE && !signal) {
[16:13:04.300]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.300]                     {
[16:13:04.300]                       inherits <- base::inherits
[16:13:04.300]                       invokeRestart <- base::invokeRestart
[16:13:04.300]                       is.null <- base::is.null
[16:13:04.300]                       muffled <- FALSE
[16:13:04.300]                       if (inherits(cond, "message")) {
[16:13:04.300]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.300]                         if (muffled) 
[16:13:04.300]                           invokeRestart("muffleMessage")
[16:13:04.300]                       }
[16:13:04.300]                       else if (inherits(cond, "warning")) {
[16:13:04.300]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.300]                         if (muffled) 
[16:13:04.300]                           invokeRestart("muffleWarning")
[16:13:04.300]                       }
[16:13:04.300]                       else if (inherits(cond, "condition")) {
[16:13:04.300]                         if (!is.null(pattern)) {
[16:13:04.300]                           computeRestarts <- base::computeRestarts
[16:13:04.300]                           grepl <- base::grepl
[16:13:04.300]                           restarts <- computeRestarts(cond)
[16:13:04.300]                           for (restart in restarts) {
[16:13:04.300]                             name <- restart$name
[16:13:04.300]                             if (is.null(name)) 
[16:13:04.300]                               next
[16:13:04.300]                             if (!grepl(pattern, name)) 
[16:13:04.300]                               next
[16:13:04.300]                             invokeRestart(restart)
[16:13:04.300]                             muffled <- TRUE
[16:13:04.300]                             break
[16:13:04.300]                           }
[16:13:04.300]                         }
[16:13:04.300]                       }
[16:13:04.300]                       invisible(muffled)
[16:13:04.300]                     }
[16:13:04.300]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.300]                   }
[16:13:04.300]                 }
[16:13:04.300]                 else {
[16:13:04.300]                   if (TRUE) {
[16:13:04.300]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.300]                     {
[16:13:04.300]                       inherits <- base::inherits
[16:13:04.300]                       invokeRestart <- base::invokeRestart
[16:13:04.300]                       is.null <- base::is.null
[16:13:04.300]                       muffled <- FALSE
[16:13:04.300]                       if (inherits(cond, "message")) {
[16:13:04.300]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.300]                         if (muffled) 
[16:13:04.300]                           invokeRestart("muffleMessage")
[16:13:04.300]                       }
[16:13:04.300]                       else if (inherits(cond, "warning")) {
[16:13:04.300]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.300]                         if (muffled) 
[16:13:04.300]                           invokeRestart("muffleWarning")
[16:13:04.300]                       }
[16:13:04.300]                       else if (inherits(cond, "condition")) {
[16:13:04.300]                         if (!is.null(pattern)) {
[16:13:04.300]                           computeRestarts <- base::computeRestarts
[16:13:04.300]                           grepl <- base::grepl
[16:13:04.300]                           restarts <- computeRestarts(cond)
[16:13:04.300]                           for (restart in restarts) {
[16:13:04.300]                             name <- restart$name
[16:13:04.300]                             if (is.null(name)) 
[16:13:04.300]                               next
[16:13:04.300]                             if (!grepl(pattern, name)) 
[16:13:04.300]                               next
[16:13:04.300]                             invokeRestart(restart)
[16:13:04.300]                             muffled <- TRUE
[16:13:04.300]                             break
[16:13:04.300]                           }
[16:13:04.300]                         }
[16:13:04.300]                       }
[16:13:04.300]                       invisible(muffled)
[16:13:04.300]                     }
[16:13:04.300]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.300]                   }
[16:13:04.300]                 }
[16:13:04.300]             }
[16:13:04.300]         }))
[16:13:04.300]     }, error = function(ex) {
[16:13:04.300]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:04.300]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.300]                 ...future.rng), started = ...future.startTime, 
[16:13:04.300]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:04.300]             version = "1.8"), class = "FutureResult")
[16:13:04.300]     }, finally = {
[16:13:04.300]         if (!identical(...future.workdir, getwd())) 
[16:13:04.300]             setwd(...future.workdir)
[16:13:04.300]         {
[16:13:04.300]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:04.300]                 ...future.oldOptions$nwarnings <- NULL
[16:13:04.300]             }
[16:13:04.300]             base::options(...future.oldOptions)
[16:13:04.300]             if (.Platform$OS.type == "windows") {
[16:13:04.300]                 old_names <- names(...future.oldEnvVars)
[16:13:04.300]                 envs <- base::Sys.getenv()
[16:13:04.300]                 names <- names(envs)
[16:13:04.300]                 common <- intersect(names, old_names)
[16:13:04.300]                 added <- setdiff(names, old_names)
[16:13:04.300]                 removed <- setdiff(old_names, names)
[16:13:04.300]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:04.300]                   envs[common]]
[16:13:04.300]                 NAMES <- toupper(changed)
[16:13:04.300]                 args <- list()
[16:13:04.300]                 for (kk in seq_along(NAMES)) {
[16:13:04.300]                   name <- changed[[kk]]
[16:13:04.300]                   NAME <- NAMES[[kk]]
[16:13:04.300]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.300]                     next
[16:13:04.300]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.300]                 }
[16:13:04.300]                 NAMES <- toupper(added)
[16:13:04.300]                 for (kk in seq_along(NAMES)) {
[16:13:04.300]                   name <- added[[kk]]
[16:13:04.300]                   NAME <- NAMES[[kk]]
[16:13:04.300]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.300]                     next
[16:13:04.300]                   args[[name]] <- ""
[16:13:04.300]                 }
[16:13:04.300]                 NAMES <- toupper(removed)
[16:13:04.300]                 for (kk in seq_along(NAMES)) {
[16:13:04.300]                   name <- removed[[kk]]
[16:13:04.300]                   NAME <- NAMES[[kk]]
[16:13:04.300]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.300]                     next
[16:13:04.300]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.300]                 }
[16:13:04.300]                 if (length(args) > 0) 
[16:13:04.300]                   base::do.call(base::Sys.setenv, args = args)
[16:13:04.300]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:04.300]             }
[16:13:04.300]             else {
[16:13:04.300]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:04.300]             }
[16:13:04.300]             {
[16:13:04.300]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:04.300]                   0L) {
[16:13:04.300]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:04.300]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:04.300]                   base::options(opts)
[16:13:04.300]                 }
[16:13:04.300]                 {
[16:13:04.300]                   {
[16:13:04.300]                     NULL
[16:13:04.300]                     RNGkind("Mersenne-Twister")
[16:13:04.300]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:04.300]                       inherits = FALSE)
[16:13:04.300]                   }
[16:13:04.300]                   options(future.plan = NULL)
[16:13:04.300]                   if (is.na(NA_character_)) 
[16:13:04.300]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.300]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:04.300]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:04.300]                     envir = parent.frame()) 
[16:13:04.300]                   {
[16:13:04.300]                     default_workers <- missing(workers)
[16:13:04.300]                     if (is.function(workers)) 
[16:13:04.300]                       workers <- workers()
[16:13:04.300]                     workers <- structure(as.integer(workers), 
[16:13:04.300]                       class = class(workers))
[16:13:04.300]                     stop_if_not(is.finite(workers), workers >= 
[16:13:04.300]                       1L)
[16:13:04.300]                     if ((workers == 1L && !inherits(workers, 
[16:13:04.300]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:04.300]                       if (default_workers) 
[16:13:04.300]                         supportsMulticore(warn = TRUE)
[16:13:04.300]                       return(sequential(..., envir = envir))
[16:13:04.300]                     }
[16:13:04.300]                     oopts <- options(mc.cores = workers)
[16:13:04.300]                     on.exit(options(oopts))
[16:13:04.300]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:04.300]                       envir = envir)
[16:13:04.300]                     if (!future$lazy) 
[16:13:04.300]                       future <- run(future)
[16:13:04.300]                     invisible(future)
[16:13:04.300]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:04.300]                 }
[16:13:04.300]             }
[16:13:04.300]         }
[16:13:04.300]     })
[16:13:04.300]     if (TRUE) {
[16:13:04.300]         base::sink(type = "output", split = FALSE)
[16:13:04.300]         if (TRUE) {
[16:13:04.300]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:04.300]         }
[16:13:04.300]         else {
[16:13:04.300]             ...future.result["stdout"] <- base::list(NULL)
[16:13:04.300]         }
[16:13:04.300]         base::close(...future.stdout)
[16:13:04.300]         ...future.stdout <- NULL
[16:13:04.300]     }
[16:13:04.300]     ...future.result$conditions <- ...future.conditions
[16:13:04.300]     ...future.result$finished <- base::Sys.time()
[16:13:04.300]     ...future.result
[16:13:04.300] }
[16:13:04.302] plan(): Setting new future strategy stack:
[16:13:04.302] List of future strategies:
[16:13:04.302] 1. sequential:
[16:13:04.302]    - args: function (..., envir = parent.frame())
[16:13:04.302]    - tweaked: FALSE
[16:13:04.302]    - call: NULL
[16:13:04.302] plan(): nbrOfWorkers() = 1
[16:13:04.303] plan(): Setting new future strategy stack:
[16:13:04.303] List of future strategies:
[16:13:04.303] 1. multicore:
[16:13:04.303]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:04.303]    - tweaked: FALSE
[16:13:04.303]    - call: plan(multicore)
[16:13:04.307] plan(): nbrOfWorkers() = 1
[16:13:04.307] SequentialFuture started (and completed)
[16:13:04.307] signalConditions() ...
[16:13:04.307]  - include = ‘immediateCondition’
[16:13:04.307]  - exclude = 
[16:13:04.307]  - resignal = FALSE
[16:13:04.307]  - Number of conditions: 1
[16:13:04.307] signalConditions() ... done
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 0 bytes of class ‘NULL’
Conditions captured: [n=1] ‘MyError’
Early signaling: FALSE
Owner process: 9cd5072f-68f7-e4f0-6d65-cff53a745767
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:04.308] signalConditions() ...
[16:13:04.308]  - include = ‘immediateCondition’
[16:13:04.308]  - exclude = 
[16:13:04.308]  - resignal = FALSE
[16:13:04.308]  - Number of conditions: 1
[16:13:04.308] signalConditions() ... done
<MyError: boom>
[16:13:04.309] signalConditions() ...
[16:13:04.309]  - include = ‘immediateCondition’
[16:13:04.309]  - exclude = 
[16:13:04.309]  - resignal = FALSE
[16:13:04.309]  - Number of conditions: 1
[16:13:04.309] signalConditions() ... done
[16:13:04.309] Future state: ‘finished’
[16:13:04.309] signalConditions() ...
[16:13:04.309]  - include = ‘condition’
[16:13:04.309]  - exclude = ‘immediateCondition’
[16:13:04.309]  - resignal = TRUE
[16:13:04.310]  - Number of conditions: 1
[16:13:04.310]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[16:13:04.310] signalConditions() ... done
*** multicore(..., workers = 1L) ...
[16:13:04.310] getGlobalsAndPackages() ...
[16:13:04.310] Searching for globals...
[16:13:04.311] - globals found: [4] ‘{’, ‘*’, ‘a’, ‘b’
[16:13:04.311] Searching for globals ... DONE
[16:13:04.311] Resolving globals: FALSE
[16:13:04.312] The total size of the 2 globals is 112 bytes (112 bytes)
[16:13:04.312] The total size of the 2 globals exported for future expression (‘{; a * b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘b’ (56 bytes of class ‘numeric’)
[16:13:04.312] - globals: [2] ‘a’, ‘b’
[16:13:04.312] 
[16:13:04.312] getGlobalsAndPackages() ... DONE
[16:13:04.313] Packages needed by the future expression (n = 0): <none>
[16:13:04.313] Packages needed by future strategies (n = 0): <none>
[16:13:04.313] {
[16:13:04.313]     {
[16:13:04.313]         {
[16:13:04.313]             ...future.startTime <- base::Sys.time()
[16:13:04.313]             {
[16:13:04.313]                 {
[16:13:04.313]                   {
[16:13:04.313]                     base::local({
[16:13:04.313]                       has_future <- base::requireNamespace("future", 
[16:13:04.313]                         quietly = TRUE)
[16:13:04.313]                       if (has_future) {
[16:13:04.313]                         ns <- base::getNamespace("future")
[16:13:04.313]                         version <- ns[[".package"]][["version"]]
[16:13:04.313]                         if (is.null(version)) 
[16:13:04.313]                           version <- utils::packageVersion("future")
[16:13:04.313]                       }
[16:13:04.313]                       else {
[16:13:04.313]                         version <- NULL
[16:13:04.313]                       }
[16:13:04.313]                       if (!has_future || version < "1.8.0") {
[16:13:04.313]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:04.313]                           "", base::R.version$version.string), 
[16:13:04.313]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:04.313]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:04.313]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:04.313]                             "release", "version")], collapse = " "), 
[16:13:04.313]                           hostname = base::Sys.info()[["nodename"]])
[16:13:04.313]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:04.313]                           info)
[16:13:04.313]                         info <- base::paste(info, collapse = "; ")
[16:13:04.313]                         if (!has_future) {
[16:13:04.313]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:04.313]                             info)
[16:13:04.313]                         }
[16:13:04.313]                         else {
[16:13:04.313]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:04.313]                             info, version)
[16:13:04.313]                         }
[16:13:04.313]                         base::stop(msg)
[16:13:04.313]                       }
[16:13:04.313]                     })
[16:13:04.313]                   }
[16:13:04.313]                   options(future.plan = NULL)
[16:13:04.313]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.313]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:04.313]                 }
[16:13:04.313]                 ...future.workdir <- getwd()
[16:13:04.313]             }
[16:13:04.313]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:04.313]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:04.313]         }
[16:13:04.313]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:04.313]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:04.313]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:04.313]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:04.313]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:04.313]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:04.313]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:04.313]             base::names(...future.oldOptions))
[16:13:04.313]     }
[16:13:04.313]     if (FALSE) {
[16:13:04.313]     }
[16:13:04.313]     else {
[16:13:04.313]         if (TRUE) {
[16:13:04.313]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:04.313]                 open = "w")
[16:13:04.313]         }
[16:13:04.313]         else {
[16:13:04.313]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:04.313]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:04.313]         }
[16:13:04.313]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:04.313]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:04.313]             base::sink(type = "output", split = FALSE)
[16:13:04.313]             base::close(...future.stdout)
[16:13:04.313]         }, add = TRUE)
[16:13:04.313]     }
[16:13:04.313]     ...future.frame <- base::sys.nframe()
[16:13:04.313]     ...future.conditions <- base::list()
[16:13:04.313]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:04.313]     if (FALSE) {
[16:13:04.313]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:04.313]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:04.313]     }
[16:13:04.313]     ...future.result <- base::tryCatch({
[16:13:04.313]         base::withCallingHandlers({
[16:13:04.313]             ...future.value <- base::withVisible(base::local({
[16:13:04.313]                 a * b
[16:13:04.313]             }))
[16:13:04.313]             future::FutureResult(value = ...future.value$value, 
[16:13:04.313]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.313]                   ...future.rng), globalenv = if (FALSE) 
[16:13:04.313]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:04.313]                     ...future.globalenv.names))
[16:13:04.313]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:04.313]         }, condition = base::local({
[16:13:04.313]             c <- base::c
[16:13:04.313]             inherits <- base::inherits
[16:13:04.313]             invokeRestart <- base::invokeRestart
[16:13:04.313]             length <- base::length
[16:13:04.313]             list <- base::list
[16:13:04.313]             seq.int <- base::seq.int
[16:13:04.313]             signalCondition <- base::signalCondition
[16:13:04.313]             sys.calls <- base::sys.calls
[16:13:04.313]             `[[` <- base::`[[`
[16:13:04.313]             `+` <- base::`+`
[16:13:04.313]             `<<-` <- base::`<<-`
[16:13:04.313]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:04.313]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:04.313]                   3L)]
[16:13:04.313]             }
[16:13:04.313]             function(cond) {
[16:13:04.313]                 is_error <- inherits(cond, "error")
[16:13:04.313]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:04.313]                   NULL)
[16:13:04.313]                 if (is_error) {
[16:13:04.313]                   sessionInformation <- function() {
[16:13:04.313]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:04.313]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:04.313]                       search = base::search(), system = base::Sys.info())
[16:13:04.313]                   }
[16:13:04.313]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.313]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:04.313]                     cond$call), session = sessionInformation(), 
[16:13:04.313]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:04.313]                   signalCondition(cond)
[16:13:04.313]                 }
[16:13:04.313]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:04.313]                 "immediateCondition"))) {
[16:13:04.313]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:04.313]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.313]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:04.313]                   if (TRUE && !signal) {
[16:13:04.313]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.313]                     {
[16:13:04.313]                       inherits <- base::inherits
[16:13:04.313]                       invokeRestart <- base::invokeRestart
[16:13:04.313]                       is.null <- base::is.null
[16:13:04.313]                       muffled <- FALSE
[16:13:04.313]                       if (inherits(cond, "message")) {
[16:13:04.313]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.313]                         if (muffled) 
[16:13:04.313]                           invokeRestart("muffleMessage")
[16:13:04.313]                       }
[16:13:04.313]                       else if (inherits(cond, "warning")) {
[16:13:04.313]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.313]                         if (muffled) 
[16:13:04.313]                           invokeRestart("muffleWarning")
[16:13:04.313]                       }
[16:13:04.313]                       else if (inherits(cond, "condition")) {
[16:13:04.313]                         if (!is.null(pattern)) {
[16:13:04.313]                           computeRestarts <- base::computeRestarts
[16:13:04.313]                           grepl <- base::grepl
[16:13:04.313]                           restarts <- computeRestarts(cond)
[16:13:04.313]                           for (restart in restarts) {
[16:13:04.313]                             name <- restart$name
[16:13:04.313]                             if (is.null(name)) 
[16:13:04.313]                               next
[16:13:04.313]                             if (!grepl(pattern, name)) 
[16:13:04.313]                               next
[16:13:04.313]                             invokeRestart(restart)
[16:13:04.313]                             muffled <- TRUE
[16:13:04.313]                             break
[16:13:04.313]                           }
[16:13:04.313]                         }
[16:13:04.313]                       }
[16:13:04.313]                       invisible(muffled)
[16:13:04.313]                     }
[16:13:04.313]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.313]                   }
[16:13:04.313]                 }
[16:13:04.313]                 else {
[16:13:04.313]                   if (TRUE) {
[16:13:04.313]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.313]                     {
[16:13:04.313]                       inherits <- base::inherits
[16:13:04.313]                       invokeRestart <- base::invokeRestart
[16:13:04.313]                       is.null <- base::is.null
[16:13:04.313]                       muffled <- FALSE
[16:13:04.313]                       if (inherits(cond, "message")) {
[16:13:04.313]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.313]                         if (muffled) 
[16:13:04.313]                           invokeRestart("muffleMessage")
[16:13:04.313]                       }
[16:13:04.313]                       else if (inherits(cond, "warning")) {
[16:13:04.313]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.313]                         if (muffled) 
[16:13:04.313]                           invokeRestart("muffleWarning")
[16:13:04.313]                       }
[16:13:04.313]                       else if (inherits(cond, "condition")) {
[16:13:04.313]                         if (!is.null(pattern)) {
[16:13:04.313]                           computeRestarts <- base::computeRestarts
[16:13:04.313]                           grepl <- base::grepl
[16:13:04.313]                           restarts <- computeRestarts(cond)
[16:13:04.313]                           for (restart in restarts) {
[16:13:04.313]                             name <- restart$name
[16:13:04.313]                             if (is.null(name)) 
[16:13:04.313]                               next
[16:13:04.313]                             if (!grepl(pattern, name)) 
[16:13:04.313]                               next
[16:13:04.313]                             invokeRestart(restart)
[16:13:04.313]                             muffled <- TRUE
[16:13:04.313]                             break
[16:13:04.313]                           }
[16:13:04.313]                         }
[16:13:04.313]                       }
[16:13:04.313]                       invisible(muffled)
[16:13:04.313]                     }
[16:13:04.313]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.313]                   }
[16:13:04.313]                 }
[16:13:04.313]             }
[16:13:04.313]         }))
[16:13:04.313]     }, error = function(ex) {
[16:13:04.313]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:04.313]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.313]                 ...future.rng), started = ...future.startTime, 
[16:13:04.313]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:04.313]             version = "1.8"), class = "FutureResult")
[16:13:04.313]     }, finally = {
[16:13:04.313]         if (!identical(...future.workdir, getwd())) 
[16:13:04.313]             setwd(...future.workdir)
[16:13:04.313]         {
[16:13:04.313]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:04.313]                 ...future.oldOptions$nwarnings <- NULL
[16:13:04.313]             }
[16:13:04.313]             base::options(...future.oldOptions)
[16:13:04.313]             if (.Platform$OS.type == "windows") {
[16:13:04.313]                 old_names <- names(...future.oldEnvVars)
[16:13:04.313]                 envs <- base::Sys.getenv()
[16:13:04.313]                 names <- names(envs)
[16:13:04.313]                 common <- intersect(names, old_names)
[16:13:04.313]                 added <- setdiff(names, old_names)
[16:13:04.313]                 removed <- setdiff(old_names, names)
[16:13:04.313]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:04.313]                   envs[common]]
[16:13:04.313]                 NAMES <- toupper(changed)
[16:13:04.313]                 args <- list()
[16:13:04.313]                 for (kk in seq_along(NAMES)) {
[16:13:04.313]                   name <- changed[[kk]]
[16:13:04.313]                   NAME <- NAMES[[kk]]
[16:13:04.313]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.313]                     next
[16:13:04.313]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.313]                 }
[16:13:04.313]                 NAMES <- toupper(added)
[16:13:04.313]                 for (kk in seq_along(NAMES)) {
[16:13:04.313]                   name <- added[[kk]]
[16:13:04.313]                   NAME <- NAMES[[kk]]
[16:13:04.313]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.313]                     next
[16:13:04.313]                   args[[name]] <- ""
[16:13:04.313]                 }
[16:13:04.313]                 NAMES <- toupper(removed)
[16:13:04.313]                 for (kk in seq_along(NAMES)) {
[16:13:04.313]                   name <- removed[[kk]]
[16:13:04.313]                   NAME <- NAMES[[kk]]
[16:13:04.313]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.313]                     next
[16:13:04.313]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.313]                 }
[16:13:04.313]                 if (length(args) > 0) 
[16:13:04.313]                   base::do.call(base::Sys.setenv, args = args)
[16:13:04.313]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:04.313]             }
[16:13:04.313]             else {
[16:13:04.313]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:04.313]             }
[16:13:04.313]             {
[16:13:04.313]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:04.313]                   0L) {
[16:13:04.313]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:04.313]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:04.313]                   base::options(opts)
[16:13:04.313]                 }
[16:13:04.313]                 {
[16:13:04.313]                   {
[16:13:04.313]                     NULL
[16:13:04.313]                     RNGkind("Mersenne-Twister")
[16:13:04.313]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:04.313]                       inherits = FALSE)
[16:13:04.313]                   }
[16:13:04.313]                   options(future.plan = NULL)
[16:13:04.313]                   if (is.na(NA_character_)) 
[16:13:04.313]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.313]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:04.313]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:04.313]                     envir = parent.frame()) 
[16:13:04.313]                   {
[16:13:04.313]                     default_workers <- missing(workers)
[16:13:04.313]                     if (is.function(workers)) 
[16:13:04.313]                       workers <- workers()
[16:13:04.313]                     workers <- structure(as.integer(workers), 
[16:13:04.313]                       class = class(workers))
[16:13:04.313]                     stop_if_not(is.finite(workers), workers >= 
[16:13:04.313]                       1L)
[16:13:04.313]                     if ((workers == 1L && !inherits(workers, 
[16:13:04.313]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:04.313]                       if (default_workers) 
[16:13:04.313]                         supportsMulticore(warn = TRUE)
[16:13:04.313]                       return(sequential(..., envir = envir))
[16:13:04.313]                     }
[16:13:04.313]                     oopts <- options(mc.cores = workers)
[16:13:04.313]                     on.exit(options(oopts))
[16:13:04.313]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:04.313]                       envir = envir)
[16:13:04.313]                     if (!future$lazy) 
[16:13:04.313]                       future <- run(future)
[16:13:04.313]                     invisible(future)
[16:13:04.313]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:04.313]                 }
[16:13:04.313]             }
[16:13:04.313]         }
[16:13:04.313]     })
[16:13:04.313]     if (TRUE) {
[16:13:04.313]         base::sink(type = "output", split = FALSE)
[16:13:04.313]         if (TRUE) {
[16:13:04.313]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:04.313]         }
[16:13:04.313]         else {
[16:13:04.313]             ...future.result["stdout"] <- base::list(NULL)
[16:13:04.313]         }
[16:13:04.313]         base::close(...future.stdout)
[16:13:04.313]         ...future.stdout <- NULL
[16:13:04.313]     }
[16:13:04.313]     ...future.result$conditions <- ...future.conditions
[16:13:04.313]     ...future.result$finished <- base::Sys.time()
[16:13:04.313]     ...future.result
[16:13:04.313] }
[16:13:04.315] assign_globals() ...
[16:13:04.315] List of 2
[16:13:04.315]  $ a: num 2
[16:13:04.315]  $ b: num 3
[16:13:04.315]  - attr(*, "where")=List of 2
[16:13:04.315]   ..$ a:<environment: R_EmptyEnv> 
[16:13:04.315]   ..$ b:<environment: R_EmptyEnv> 
[16:13:04.315]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:04.315]  - attr(*, "resolved")= logi FALSE
[16:13:04.315]  - attr(*, "total_size")= num 112
[16:13:04.319] - copied ‘a’ to environment
[16:13:04.320] - copied ‘b’ to environment
[16:13:04.320] assign_globals() ... done
[16:13:04.320] plan(): Setting new future strategy stack:
[16:13:04.320] List of future strategies:
[16:13:04.320] 1. sequential:
[16:13:04.320]    - args: function (..., envir = parent.frame())
[16:13:04.320]    - tweaked: FALSE
[16:13:04.320]    - call: NULL
[16:13:04.320] plan(): nbrOfWorkers() = 1
[16:13:04.321] plan(): Setting new future strategy stack:
[16:13:04.321] List of future strategies:
[16:13:04.321] 1. multicore:
[16:13:04.321]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:04.321]    - tweaked: FALSE
[16:13:04.321]    - call: plan(multicore)
[16:13:04.325] plan(): nbrOfWorkers() = 1
[16:13:04.325] SequentialFuture started (and completed)
[1] 6
*** multicore(..., workers = 1L) ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
Number of workers: 2
*** multicore(..., globals = FALSE) without globals
[16:13:04.332] getGlobalsAndPackages() ...
[16:13:04.332] Not searching for globals
[16:13:04.332] - globals: [0] <none>
[16:13:04.332] getGlobalsAndPackages() ... DONE
[16:13:04.333] Packages needed by the future expression (n = 0): <none>
[16:13:04.334] Packages needed by future strategies (n = 0): <none>
[16:13:04.334] {
[16:13:04.334]     {
[16:13:04.334]         {
[16:13:04.334]             ...future.startTime <- base::Sys.time()
[16:13:04.334]             {
[16:13:04.334]                 {
[16:13:04.334]                   {
[16:13:04.334]                     {
[16:13:04.334]                       base::local({
[16:13:04.334]                         has_future <- base::requireNamespace("future", 
[16:13:04.334]                           quietly = TRUE)
[16:13:04.334]                         if (has_future) {
[16:13:04.334]                           ns <- base::getNamespace("future")
[16:13:04.334]                           version <- ns[[".package"]][["version"]]
[16:13:04.334]                           if (is.null(version)) 
[16:13:04.334]                             version <- utils::packageVersion("future")
[16:13:04.334]                         }
[16:13:04.334]                         else {
[16:13:04.334]                           version <- NULL
[16:13:04.334]                         }
[16:13:04.334]                         if (!has_future || version < "1.8.0") {
[16:13:04.334]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:04.334]                             "", base::R.version$version.string), 
[16:13:04.334]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:04.334]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:04.334]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:04.334]                               "release", "version")], collapse = " "), 
[16:13:04.334]                             hostname = base::Sys.info()[["nodename"]])
[16:13:04.334]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:04.334]                             info)
[16:13:04.334]                           info <- base::paste(info, collapse = "; ")
[16:13:04.334]                           if (!has_future) {
[16:13:04.334]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:04.334]                               info)
[16:13:04.334]                           }
[16:13:04.334]                           else {
[16:13:04.334]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:04.334]                               info, version)
[16:13:04.334]                           }
[16:13:04.334]                           base::stop(msg)
[16:13:04.334]                         }
[16:13:04.334]                       })
[16:13:04.334]                     }
[16:13:04.334]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:04.334]                     base::options(mc.cores = 1L)
[16:13:04.334]                   }
[16:13:04.334]                   options(future.plan = NULL)
[16:13:04.334]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.334]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:04.334]                 }
[16:13:04.334]                 ...future.workdir <- getwd()
[16:13:04.334]             }
[16:13:04.334]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:04.334]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:04.334]         }
[16:13:04.334]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:04.334]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:04.334]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:04.334]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:04.334]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:04.334]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:04.334]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:04.334]             base::names(...future.oldOptions))
[16:13:04.334]     }
[16:13:04.334]     if (FALSE) {
[16:13:04.334]     }
[16:13:04.334]     else {
[16:13:04.334]         if (TRUE) {
[16:13:04.334]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:04.334]                 open = "w")
[16:13:04.334]         }
[16:13:04.334]         else {
[16:13:04.334]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:04.334]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:04.334]         }
[16:13:04.334]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:04.334]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:04.334]             base::sink(type = "output", split = FALSE)
[16:13:04.334]             base::close(...future.stdout)
[16:13:04.334]         }, add = TRUE)
[16:13:04.334]     }
[16:13:04.334]     ...future.frame <- base::sys.nframe()
[16:13:04.334]     ...future.conditions <- base::list()
[16:13:04.334]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:04.334]     if (FALSE) {
[16:13:04.334]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:04.334]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:04.334]     }
[16:13:04.334]     ...future.result <- base::tryCatch({
[16:13:04.334]         base::withCallingHandlers({
[16:13:04.334]             ...future.value <- base::withVisible(base::local({
[16:13:04.334]                 withCallingHandlers({
[16:13:04.334]                   {
[16:13:04.334]                     42L
[16:13:04.334]                   }
[16:13:04.334]                 }, immediateCondition = function(cond) {
[16:13:04.334]                   save_rds <- function (object, pathname, ...) 
[16:13:04.334]                   {
[16:13:04.334]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:04.334]                     if (file_test("-f", pathname_tmp)) {
[16:13:04.334]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.334]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:04.334]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.334]                         fi_tmp[["mtime"]])
[16:13:04.334]                     }
[16:13:04.334]                     tryCatch({
[16:13:04.334]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:04.334]                     }, error = function(ex) {
[16:13:04.334]                       msg <- conditionMessage(ex)
[16:13:04.334]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.334]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:04.334]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.334]                         fi_tmp[["mtime"]], msg)
[16:13:04.334]                       ex$message <- msg
[16:13:04.334]                       stop(ex)
[16:13:04.334]                     })
[16:13:04.334]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:04.334]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:04.334]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:04.334]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.334]                       fi <- file.info(pathname)
[16:13:04.334]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:04.334]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.334]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:04.334]                         fi[["size"]], fi[["mtime"]])
[16:13:04.334]                       stop(msg)
[16:13:04.334]                     }
[16:13:04.334]                     invisible(pathname)
[16:13:04.334]                   }
[16:13:04.334]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:04.334]                     rootPath = tempdir()) 
[16:13:04.334]                   {
[16:13:04.334]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:04.334]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:04.334]                       tmpdir = path, fileext = ".rds")
[16:13:04.334]                     save_rds(obj, file)
[16:13:04.334]                   }
[16:13:04.334]                   saveImmediateCondition(cond, path = "/tmp/RtmpmgpgJ1/.future/immediateConditions")
[16:13:04.334]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.334]                   {
[16:13:04.334]                     inherits <- base::inherits
[16:13:04.334]                     invokeRestart <- base::invokeRestart
[16:13:04.334]                     is.null <- base::is.null
[16:13:04.334]                     muffled <- FALSE
[16:13:04.334]                     if (inherits(cond, "message")) {
[16:13:04.334]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:04.334]                       if (muffled) 
[16:13:04.334]                         invokeRestart("muffleMessage")
[16:13:04.334]                     }
[16:13:04.334]                     else if (inherits(cond, "warning")) {
[16:13:04.334]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:04.334]                       if (muffled) 
[16:13:04.334]                         invokeRestart("muffleWarning")
[16:13:04.334]                     }
[16:13:04.334]                     else if (inherits(cond, "condition")) {
[16:13:04.334]                       if (!is.null(pattern)) {
[16:13:04.334]                         computeRestarts <- base::computeRestarts
[16:13:04.334]                         grepl <- base::grepl
[16:13:04.334]                         restarts <- computeRestarts(cond)
[16:13:04.334]                         for (restart in restarts) {
[16:13:04.334]                           name <- restart$name
[16:13:04.334]                           if (is.null(name)) 
[16:13:04.334]                             next
[16:13:04.334]                           if (!grepl(pattern, name)) 
[16:13:04.334]                             next
[16:13:04.334]                           invokeRestart(restart)
[16:13:04.334]                           muffled <- TRUE
[16:13:04.334]                           break
[16:13:04.334]                         }
[16:13:04.334]                       }
[16:13:04.334]                     }
[16:13:04.334]                     invisible(muffled)
[16:13:04.334]                   }
[16:13:04.334]                   muffleCondition(cond)
[16:13:04.334]                 })
[16:13:04.334]             }))
[16:13:04.334]             future::FutureResult(value = ...future.value$value, 
[16:13:04.334]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.334]                   ...future.rng), globalenv = if (FALSE) 
[16:13:04.334]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:04.334]                     ...future.globalenv.names))
[16:13:04.334]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:04.334]         }, condition = base::local({
[16:13:04.334]             c <- base::c
[16:13:04.334]             inherits <- base::inherits
[16:13:04.334]             invokeRestart <- base::invokeRestart
[16:13:04.334]             length <- base::length
[16:13:04.334]             list <- base::list
[16:13:04.334]             seq.int <- base::seq.int
[16:13:04.334]             signalCondition <- base::signalCondition
[16:13:04.334]             sys.calls <- base::sys.calls
[16:13:04.334]             `[[` <- base::`[[`
[16:13:04.334]             `+` <- base::`+`
[16:13:04.334]             `<<-` <- base::`<<-`
[16:13:04.334]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:04.334]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:04.334]                   3L)]
[16:13:04.334]             }
[16:13:04.334]             function(cond) {
[16:13:04.334]                 is_error <- inherits(cond, "error")
[16:13:04.334]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:04.334]                   NULL)
[16:13:04.334]                 if (is_error) {
[16:13:04.334]                   sessionInformation <- function() {
[16:13:04.334]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:04.334]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:04.334]                       search = base::search(), system = base::Sys.info())
[16:13:04.334]                   }
[16:13:04.334]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.334]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:04.334]                     cond$call), session = sessionInformation(), 
[16:13:04.334]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:04.334]                   signalCondition(cond)
[16:13:04.334]                 }
[16:13:04.334]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:04.334]                 "immediateCondition"))) {
[16:13:04.334]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:04.334]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.334]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:04.334]                   if (TRUE && !signal) {
[16:13:04.334]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.334]                     {
[16:13:04.334]                       inherits <- base::inherits
[16:13:04.334]                       invokeRestart <- base::invokeRestart
[16:13:04.334]                       is.null <- base::is.null
[16:13:04.334]                       muffled <- FALSE
[16:13:04.334]                       if (inherits(cond, "message")) {
[16:13:04.334]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.334]                         if (muffled) 
[16:13:04.334]                           invokeRestart("muffleMessage")
[16:13:04.334]                       }
[16:13:04.334]                       else if (inherits(cond, "warning")) {
[16:13:04.334]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.334]                         if (muffled) 
[16:13:04.334]                           invokeRestart("muffleWarning")
[16:13:04.334]                       }
[16:13:04.334]                       else if (inherits(cond, "condition")) {
[16:13:04.334]                         if (!is.null(pattern)) {
[16:13:04.334]                           computeRestarts <- base::computeRestarts
[16:13:04.334]                           grepl <- base::grepl
[16:13:04.334]                           restarts <- computeRestarts(cond)
[16:13:04.334]                           for (restart in restarts) {
[16:13:04.334]                             name <- restart$name
[16:13:04.334]                             if (is.null(name)) 
[16:13:04.334]                               next
[16:13:04.334]                             if (!grepl(pattern, name)) 
[16:13:04.334]                               next
[16:13:04.334]                             invokeRestart(restart)
[16:13:04.334]                             muffled <- TRUE
[16:13:04.334]                             break
[16:13:04.334]                           }
[16:13:04.334]                         }
[16:13:04.334]                       }
[16:13:04.334]                       invisible(muffled)
[16:13:04.334]                     }
[16:13:04.334]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.334]                   }
[16:13:04.334]                 }
[16:13:04.334]                 else {
[16:13:04.334]                   if (TRUE) {
[16:13:04.334]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.334]                     {
[16:13:04.334]                       inherits <- base::inherits
[16:13:04.334]                       invokeRestart <- base::invokeRestart
[16:13:04.334]                       is.null <- base::is.null
[16:13:04.334]                       muffled <- FALSE
[16:13:04.334]                       if (inherits(cond, "message")) {
[16:13:04.334]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.334]                         if (muffled) 
[16:13:04.334]                           invokeRestart("muffleMessage")
[16:13:04.334]                       }
[16:13:04.334]                       else if (inherits(cond, "warning")) {
[16:13:04.334]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.334]                         if (muffled) 
[16:13:04.334]                           invokeRestart("muffleWarning")
[16:13:04.334]                       }
[16:13:04.334]                       else if (inherits(cond, "condition")) {
[16:13:04.334]                         if (!is.null(pattern)) {
[16:13:04.334]                           computeRestarts <- base::computeRestarts
[16:13:04.334]                           grepl <- base::grepl
[16:13:04.334]                           restarts <- computeRestarts(cond)
[16:13:04.334]                           for (restart in restarts) {
[16:13:04.334]                             name <- restart$name
[16:13:04.334]                             if (is.null(name)) 
[16:13:04.334]                               next
[16:13:04.334]                             if (!grepl(pattern, name)) 
[16:13:04.334]                               next
[16:13:04.334]                             invokeRestart(restart)
[16:13:04.334]                             muffled <- TRUE
[16:13:04.334]                             break
[16:13:04.334]                           }
[16:13:04.334]                         }
[16:13:04.334]                       }
[16:13:04.334]                       invisible(muffled)
[16:13:04.334]                     }
[16:13:04.334]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.334]                   }
[16:13:04.334]                 }
[16:13:04.334]             }
[16:13:04.334]         }))
[16:13:04.334]     }, error = function(ex) {
[16:13:04.334]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:04.334]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.334]                 ...future.rng), started = ...future.startTime, 
[16:13:04.334]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:04.334]             version = "1.8"), class = "FutureResult")
[16:13:04.334]     }, finally = {
[16:13:04.334]         if (!identical(...future.workdir, getwd())) 
[16:13:04.334]             setwd(...future.workdir)
[16:13:04.334]         {
[16:13:04.334]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:04.334]                 ...future.oldOptions$nwarnings <- NULL
[16:13:04.334]             }
[16:13:04.334]             base::options(...future.oldOptions)
[16:13:04.334]             if (.Platform$OS.type == "windows") {
[16:13:04.334]                 old_names <- names(...future.oldEnvVars)
[16:13:04.334]                 envs <- base::Sys.getenv()
[16:13:04.334]                 names <- names(envs)
[16:13:04.334]                 common <- intersect(names, old_names)
[16:13:04.334]                 added <- setdiff(names, old_names)
[16:13:04.334]                 removed <- setdiff(old_names, names)
[16:13:04.334]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:04.334]                   envs[common]]
[16:13:04.334]                 NAMES <- toupper(changed)
[16:13:04.334]                 args <- list()
[16:13:04.334]                 for (kk in seq_along(NAMES)) {
[16:13:04.334]                   name <- changed[[kk]]
[16:13:04.334]                   NAME <- NAMES[[kk]]
[16:13:04.334]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.334]                     next
[16:13:04.334]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.334]                 }
[16:13:04.334]                 NAMES <- toupper(added)
[16:13:04.334]                 for (kk in seq_along(NAMES)) {
[16:13:04.334]                   name <- added[[kk]]
[16:13:04.334]                   NAME <- NAMES[[kk]]
[16:13:04.334]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.334]                     next
[16:13:04.334]                   args[[name]] <- ""
[16:13:04.334]                 }
[16:13:04.334]                 NAMES <- toupper(removed)
[16:13:04.334]                 for (kk in seq_along(NAMES)) {
[16:13:04.334]                   name <- removed[[kk]]
[16:13:04.334]                   NAME <- NAMES[[kk]]
[16:13:04.334]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.334]                     next
[16:13:04.334]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.334]                 }
[16:13:04.334]                 if (length(args) > 0) 
[16:13:04.334]                   base::do.call(base::Sys.setenv, args = args)
[16:13:04.334]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:04.334]             }
[16:13:04.334]             else {
[16:13:04.334]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:04.334]             }
[16:13:04.334]             {
[16:13:04.334]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:04.334]                   0L) {
[16:13:04.334]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:04.334]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:04.334]                   base::options(opts)
[16:13:04.334]                 }
[16:13:04.334]                 {
[16:13:04.334]                   {
[16:13:04.334]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:04.334]                     NULL
[16:13:04.334]                   }
[16:13:04.334]                   options(future.plan = NULL)
[16:13:04.334]                   if (is.na(NA_character_)) 
[16:13:04.334]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.334]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:04.334]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:04.334]                     envir = parent.frame()) 
[16:13:04.334]                   {
[16:13:04.334]                     default_workers <- missing(workers)
[16:13:04.334]                     if (is.function(workers)) 
[16:13:04.334]                       workers <- workers()
[16:13:04.334]                     workers <- structure(as.integer(workers), 
[16:13:04.334]                       class = class(workers))
[16:13:04.334]                     stop_if_not(is.finite(workers), workers >= 
[16:13:04.334]                       1L)
[16:13:04.334]                     if ((workers == 1L && !inherits(workers, 
[16:13:04.334]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:04.334]                       if (default_workers) 
[16:13:04.334]                         supportsMulticore(warn = TRUE)
[16:13:04.334]                       return(sequential(..., envir = envir))
[16:13:04.334]                     }
[16:13:04.334]                     oopts <- options(mc.cores = workers)
[16:13:04.334]                     on.exit(options(oopts))
[16:13:04.334]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:04.334]                       envir = envir)
[16:13:04.334]                     if (!future$lazy) 
[16:13:04.334]                       future <- run(future)
[16:13:04.334]                     invisible(future)
[16:13:04.334]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:04.334]                 }
[16:13:04.334]             }
[16:13:04.334]         }
[16:13:04.334]     })
[16:13:04.334]     if (TRUE) {
[16:13:04.334]         base::sink(type = "output", split = FALSE)
[16:13:04.334]         if (TRUE) {
[16:13:04.334]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:04.334]         }
[16:13:04.334]         else {
[16:13:04.334]             ...future.result["stdout"] <- base::list(NULL)
[16:13:04.334]         }
[16:13:04.334]         base::close(...future.stdout)
[16:13:04.334]         ...future.stdout <- NULL
[16:13:04.334]     }
[16:13:04.334]     ...future.result$conditions <- ...future.conditions
[16:13:04.334]     ...future.result$finished <- base::Sys.time()
[16:13:04.334]     ...future.result
[16:13:04.334] }
[16:13:04.336] requestCore(): workers = 2
[16:13:04.339] MulticoreFuture started
[16:13:04.340] plan(): Setting new future strategy stack:
[16:13:04.340] List of future strategies:
[16:13:04.340] 1. sequential:
[16:13:04.340]    - args: function (..., envir = parent.frame())
[16:13:04.340]    - tweaked: FALSE
[16:13:04.340]    - call: NULL
[16:13:04.341] plan(): nbrOfWorkers() = 1
[16:13:04.343] plan(): Setting new future strategy stack:
[16:13:04.343] List of future strategies:
[16:13:04.343] 1. multicore:
[16:13:04.343]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:04.343]    - tweaked: FALSE
[16:13:04.343]    - call: plan(multicore)
[16:13:04.347] plan(): nbrOfWorkers() = 2
[1] TRUE
[1] 42
*** multicore(..., globals = FALSE) with globals
[16:13:04.357] getGlobalsAndPackages() ...
[16:13:04.358] Not searching for globals
[16:13:04.358] - globals: [0] <none>
[16:13:04.358] getGlobalsAndPackages() ... DONE
[16:13:04.358] Packages needed by the future expression (n = 0): <none>
[16:13:04.358] Packages needed by future strategies (n = 0): <none>
[16:13:04.359] {
[16:13:04.359]     {
[16:13:04.359]         {
[16:13:04.359]             ...future.startTime <- base::Sys.time()
[16:13:04.359]             {
[16:13:04.359]                 {
[16:13:04.359]                   {
[16:13:04.359]                     {
[16:13:04.359]                       base::local({
[16:13:04.359]                         has_future <- base::requireNamespace("future", 
[16:13:04.359]                           quietly = TRUE)
[16:13:04.359]                         if (has_future) {
[16:13:04.359]                           ns <- base::getNamespace("future")
[16:13:04.359]                           version <- ns[[".package"]][["version"]]
[16:13:04.359]                           if (is.null(version)) 
[16:13:04.359]                             version <- utils::packageVersion("future")
[16:13:04.359]                         }
[16:13:04.359]                         else {
[16:13:04.359]                           version <- NULL
[16:13:04.359]                         }
[16:13:04.359]                         if (!has_future || version < "1.8.0") {
[16:13:04.359]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:04.359]                             "", base::R.version$version.string), 
[16:13:04.359]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:04.359]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:04.359]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:04.359]                               "release", "version")], collapse = " "), 
[16:13:04.359]                             hostname = base::Sys.info()[["nodename"]])
[16:13:04.359]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:04.359]                             info)
[16:13:04.359]                           info <- base::paste(info, collapse = "; ")
[16:13:04.359]                           if (!has_future) {
[16:13:04.359]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:04.359]                               info)
[16:13:04.359]                           }
[16:13:04.359]                           else {
[16:13:04.359]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:04.359]                               info, version)
[16:13:04.359]                           }
[16:13:04.359]                           base::stop(msg)
[16:13:04.359]                         }
[16:13:04.359]                       })
[16:13:04.359]                     }
[16:13:04.359]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:04.359]                     base::options(mc.cores = 1L)
[16:13:04.359]                   }
[16:13:04.359]                   options(future.plan = NULL)
[16:13:04.359]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.359]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:04.359]                 }
[16:13:04.359]                 ...future.workdir <- getwd()
[16:13:04.359]             }
[16:13:04.359]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:04.359]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:04.359]         }
[16:13:04.359]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:04.359]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:04.359]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:04.359]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:04.359]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:04.359]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:04.359]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:04.359]             base::names(...future.oldOptions))
[16:13:04.359]     }
[16:13:04.359]     if (FALSE) {
[16:13:04.359]     }
[16:13:04.359]     else {
[16:13:04.359]         if (TRUE) {
[16:13:04.359]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:04.359]                 open = "w")
[16:13:04.359]         }
[16:13:04.359]         else {
[16:13:04.359]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:04.359]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:04.359]         }
[16:13:04.359]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:04.359]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:04.359]             base::sink(type = "output", split = FALSE)
[16:13:04.359]             base::close(...future.stdout)
[16:13:04.359]         }, add = TRUE)
[16:13:04.359]     }
[16:13:04.359]     ...future.frame <- base::sys.nframe()
[16:13:04.359]     ...future.conditions <- base::list()
[16:13:04.359]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:04.359]     if (FALSE) {
[16:13:04.359]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:04.359]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:04.359]     }
[16:13:04.359]     ...future.result <- base::tryCatch({
[16:13:04.359]         base::withCallingHandlers({
[16:13:04.359]             ...future.value <- base::withVisible(base::local({
[16:13:04.359]                 withCallingHandlers({
[16:13:04.359]                   {
[16:13:04.359]                     b <- 3
[16:13:04.359]                     c <- 2
[16:13:04.359]                     a * b * c
[16:13:04.359]                   }
[16:13:04.359]                 }, immediateCondition = function(cond) {
[16:13:04.359]                   save_rds <- function (object, pathname, ...) 
[16:13:04.359]                   {
[16:13:04.359]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:04.359]                     if (file_test("-f", pathname_tmp)) {
[16:13:04.359]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.359]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:04.359]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.359]                         fi_tmp[["mtime"]])
[16:13:04.359]                     }
[16:13:04.359]                     tryCatch({
[16:13:04.359]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:04.359]                     }, error = function(ex) {
[16:13:04.359]                       msg <- conditionMessage(ex)
[16:13:04.359]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.359]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:04.359]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.359]                         fi_tmp[["mtime"]], msg)
[16:13:04.359]                       ex$message <- msg
[16:13:04.359]                       stop(ex)
[16:13:04.359]                     })
[16:13:04.359]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:04.359]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:04.359]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:04.359]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.359]                       fi <- file.info(pathname)
[16:13:04.359]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:04.359]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.359]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:04.359]                         fi[["size"]], fi[["mtime"]])
[16:13:04.359]                       stop(msg)
[16:13:04.359]                     }
[16:13:04.359]                     invisible(pathname)
[16:13:04.359]                   }
[16:13:04.359]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:04.359]                     rootPath = tempdir()) 
[16:13:04.359]                   {
[16:13:04.359]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:04.359]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:04.359]                       tmpdir = path, fileext = ".rds")
[16:13:04.359]                     save_rds(obj, file)
[16:13:04.359]                   }
[16:13:04.359]                   saveImmediateCondition(cond, path = "/tmp/RtmpmgpgJ1/.future/immediateConditions")
[16:13:04.359]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.359]                   {
[16:13:04.359]                     inherits <- base::inherits
[16:13:04.359]                     invokeRestart <- base::invokeRestart
[16:13:04.359]                     is.null <- base::is.null
[16:13:04.359]                     muffled <- FALSE
[16:13:04.359]                     if (inherits(cond, "message")) {
[16:13:04.359]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:04.359]                       if (muffled) 
[16:13:04.359]                         invokeRestart("muffleMessage")
[16:13:04.359]                     }
[16:13:04.359]                     else if (inherits(cond, "warning")) {
[16:13:04.359]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:04.359]                       if (muffled) 
[16:13:04.359]                         invokeRestart("muffleWarning")
[16:13:04.359]                     }
[16:13:04.359]                     else if (inherits(cond, "condition")) {
[16:13:04.359]                       if (!is.null(pattern)) {
[16:13:04.359]                         computeRestarts <- base::computeRestarts
[16:13:04.359]                         grepl <- base::grepl
[16:13:04.359]                         restarts <- computeRestarts(cond)
[16:13:04.359]                         for (restart in restarts) {
[16:13:04.359]                           name <- restart$name
[16:13:04.359]                           if (is.null(name)) 
[16:13:04.359]                             next
[16:13:04.359]                           if (!grepl(pattern, name)) 
[16:13:04.359]                             next
[16:13:04.359]                           invokeRestart(restart)
[16:13:04.359]                           muffled <- TRUE
[16:13:04.359]                           break
[16:13:04.359]                         }
[16:13:04.359]                       }
[16:13:04.359]                     }
[16:13:04.359]                     invisible(muffled)
[16:13:04.359]                   }
[16:13:04.359]                   muffleCondition(cond)
[16:13:04.359]                 })
[16:13:04.359]             }))
[16:13:04.359]             future::FutureResult(value = ...future.value$value, 
[16:13:04.359]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.359]                   ...future.rng), globalenv = if (FALSE) 
[16:13:04.359]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:04.359]                     ...future.globalenv.names))
[16:13:04.359]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:04.359]         }, condition = base::local({
[16:13:04.359]             c <- base::c
[16:13:04.359]             inherits <- base::inherits
[16:13:04.359]             invokeRestart <- base::invokeRestart
[16:13:04.359]             length <- base::length
[16:13:04.359]             list <- base::list
[16:13:04.359]             seq.int <- base::seq.int
[16:13:04.359]             signalCondition <- base::signalCondition
[16:13:04.359]             sys.calls <- base::sys.calls
[16:13:04.359]             `[[` <- base::`[[`
[16:13:04.359]             `+` <- base::`+`
[16:13:04.359]             `<<-` <- base::`<<-`
[16:13:04.359]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:04.359]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:04.359]                   3L)]
[16:13:04.359]             }
[16:13:04.359]             function(cond) {
[16:13:04.359]                 is_error <- inherits(cond, "error")
[16:13:04.359]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:04.359]                   NULL)
[16:13:04.359]                 if (is_error) {
[16:13:04.359]                   sessionInformation <- function() {
[16:13:04.359]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:04.359]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:04.359]                       search = base::search(), system = base::Sys.info())
[16:13:04.359]                   }
[16:13:04.359]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.359]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:04.359]                     cond$call), session = sessionInformation(), 
[16:13:04.359]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:04.359]                   signalCondition(cond)
[16:13:04.359]                 }
[16:13:04.359]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:04.359]                 "immediateCondition"))) {
[16:13:04.359]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:04.359]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.359]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:04.359]                   if (TRUE && !signal) {
[16:13:04.359]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.359]                     {
[16:13:04.359]                       inherits <- base::inherits
[16:13:04.359]                       invokeRestart <- base::invokeRestart
[16:13:04.359]                       is.null <- base::is.null
[16:13:04.359]                       muffled <- FALSE
[16:13:04.359]                       if (inherits(cond, "message")) {
[16:13:04.359]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.359]                         if (muffled) 
[16:13:04.359]                           invokeRestart("muffleMessage")
[16:13:04.359]                       }
[16:13:04.359]                       else if (inherits(cond, "warning")) {
[16:13:04.359]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.359]                         if (muffled) 
[16:13:04.359]                           invokeRestart("muffleWarning")
[16:13:04.359]                       }
[16:13:04.359]                       else if (inherits(cond, "condition")) {
[16:13:04.359]                         if (!is.null(pattern)) {
[16:13:04.359]                           computeRestarts <- base::computeRestarts
[16:13:04.359]                           grepl <- base::grepl
[16:13:04.359]                           restarts <- computeRestarts(cond)
[16:13:04.359]                           for (restart in restarts) {
[16:13:04.359]                             name <- restart$name
[16:13:04.359]                             if (is.null(name)) 
[16:13:04.359]                               next
[16:13:04.359]                             if (!grepl(pattern, name)) 
[16:13:04.359]                               next
[16:13:04.359]                             invokeRestart(restart)
[16:13:04.359]                             muffled <- TRUE
[16:13:04.359]                             break
[16:13:04.359]                           }
[16:13:04.359]                         }
[16:13:04.359]                       }
[16:13:04.359]                       invisible(muffled)
[16:13:04.359]                     }
[16:13:04.359]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.359]                   }
[16:13:04.359]                 }
[16:13:04.359]                 else {
[16:13:04.359]                   if (TRUE) {
[16:13:04.359]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.359]                     {
[16:13:04.359]                       inherits <- base::inherits
[16:13:04.359]                       invokeRestart <- base::invokeRestart
[16:13:04.359]                       is.null <- base::is.null
[16:13:04.359]                       muffled <- FALSE
[16:13:04.359]                       if (inherits(cond, "message")) {
[16:13:04.359]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.359]                         if (muffled) 
[16:13:04.359]                           invokeRestart("muffleMessage")
[16:13:04.359]                       }
[16:13:04.359]                       else if (inherits(cond, "warning")) {
[16:13:04.359]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.359]                         if (muffled) 
[16:13:04.359]                           invokeRestart("muffleWarning")
[16:13:04.359]                       }
[16:13:04.359]                       else if (inherits(cond, "condition")) {
[16:13:04.359]                         if (!is.null(pattern)) {
[16:13:04.359]                           computeRestarts <- base::computeRestarts
[16:13:04.359]                           grepl <- base::grepl
[16:13:04.359]                           restarts <- computeRestarts(cond)
[16:13:04.359]                           for (restart in restarts) {
[16:13:04.359]                             name <- restart$name
[16:13:04.359]                             if (is.null(name)) 
[16:13:04.359]                               next
[16:13:04.359]                             if (!grepl(pattern, name)) 
[16:13:04.359]                               next
[16:13:04.359]                             invokeRestart(restart)
[16:13:04.359]                             muffled <- TRUE
[16:13:04.359]                             break
[16:13:04.359]                           }
[16:13:04.359]                         }
[16:13:04.359]                       }
[16:13:04.359]                       invisible(muffled)
[16:13:04.359]                     }
[16:13:04.359]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.359]                   }
[16:13:04.359]                 }
[16:13:04.359]             }
[16:13:04.359]         }))
[16:13:04.359]     }, error = function(ex) {
[16:13:04.359]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:04.359]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.359]                 ...future.rng), started = ...future.startTime, 
[16:13:04.359]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:04.359]             version = "1.8"), class = "FutureResult")
[16:13:04.359]     }, finally = {
[16:13:04.359]         if (!identical(...future.workdir, getwd())) 
[16:13:04.359]             setwd(...future.workdir)
[16:13:04.359]         {
[16:13:04.359]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:04.359]                 ...future.oldOptions$nwarnings <- NULL
[16:13:04.359]             }
[16:13:04.359]             base::options(...future.oldOptions)
[16:13:04.359]             if (.Platform$OS.type == "windows") {
[16:13:04.359]                 old_names <- names(...future.oldEnvVars)
[16:13:04.359]                 envs <- base::Sys.getenv()
[16:13:04.359]                 names <- names(envs)
[16:13:04.359]                 common <- intersect(names, old_names)
[16:13:04.359]                 added <- setdiff(names, old_names)
[16:13:04.359]                 removed <- setdiff(old_names, names)
[16:13:04.359]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:04.359]                   envs[common]]
[16:13:04.359]                 NAMES <- toupper(changed)
[16:13:04.359]                 args <- list()
[16:13:04.359]                 for (kk in seq_along(NAMES)) {
[16:13:04.359]                   name <- changed[[kk]]
[16:13:04.359]                   NAME <- NAMES[[kk]]
[16:13:04.359]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.359]                     next
[16:13:04.359]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.359]                 }
[16:13:04.359]                 NAMES <- toupper(added)
[16:13:04.359]                 for (kk in seq_along(NAMES)) {
[16:13:04.359]                   name <- added[[kk]]
[16:13:04.359]                   NAME <- NAMES[[kk]]
[16:13:04.359]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.359]                     next
[16:13:04.359]                   args[[name]] <- ""
[16:13:04.359]                 }
[16:13:04.359]                 NAMES <- toupper(removed)
[16:13:04.359]                 for (kk in seq_along(NAMES)) {
[16:13:04.359]                   name <- removed[[kk]]
[16:13:04.359]                   NAME <- NAMES[[kk]]
[16:13:04.359]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.359]                     next
[16:13:04.359]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.359]                 }
[16:13:04.359]                 if (length(args) > 0) 
[16:13:04.359]                   base::do.call(base::Sys.setenv, args = args)
[16:13:04.359]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:04.359]             }
[16:13:04.359]             else {
[16:13:04.359]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:04.359]             }
[16:13:04.359]             {
[16:13:04.359]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:04.359]                   0L) {
[16:13:04.359]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:04.359]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:04.359]                   base::options(opts)
[16:13:04.359]                 }
[16:13:04.359]                 {
[16:13:04.359]                   {
[16:13:04.359]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:04.359]                     NULL
[16:13:04.359]                   }
[16:13:04.359]                   options(future.plan = NULL)
[16:13:04.359]                   if (is.na(NA_character_)) 
[16:13:04.359]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.359]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:04.359]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:04.359]                     envir = parent.frame()) 
[16:13:04.359]                   {
[16:13:04.359]                     default_workers <- missing(workers)
[16:13:04.359]                     if (is.function(workers)) 
[16:13:04.359]                       workers <- workers()
[16:13:04.359]                     workers <- structure(as.integer(workers), 
[16:13:04.359]                       class = class(workers))
[16:13:04.359]                     stop_if_not(is.finite(workers), workers >= 
[16:13:04.359]                       1L)
[16:13:04.359]                     if ((workers == 1L && !inherits(workers, 
[16:13:04.359]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:04.359]                       if (default_workers) 
[16:13:04.359]                         supportsMulticore(warn = TRUE)
[16:13:04.359]                       return(sequential(..., envir = envir))
[16:13:04.359]                     }
[16:13:04.359]                     oopts <- options(mc.cores = workers)
[16:13:04.359]                     on.exit(options(oopts))
[16:13:04.359]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:04.359]                       envir = envir)
[16:13:04.359]                     if (!future$lazy) 
[16:13:04.359]                       future <- run(future)
[16:13:04.359]                     invisible(future)
[16:13:04.359]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:04.359]                 }
[16:13:04.359]             }
[16:13:04.359]         }
[16:13:04.359]     })
[16:13:04.359]     if (TRUE) {
[16:13:04.359]         base::sink(type = "output", split = FALSE)
[16:13:04.359]         if (TRUE) {
[16:13:04.359]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:04.359]         }
[16:13:04.359]         else {
[16:13:04.359]             ...future.result["stdout"] <- base::list(NULL)
[16:13:04.359]         }
[16:13:04.359]         base::close(...future.stdout)
[16:13:04.359]         ...future.stdout <- NULL
[16:13:04.359]     }
[16:13:04.359]     ...future.result$conditions <- ...future.conditions
[16:13:04.359]     ...future.result$finished <- base::Sys.time()
[16:13:04.359]     ...future.result
[16:13:04.359] }
[16:13:04.362] requestCore(): workers = 2
[16:13:04.363] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:13:04.365] plan(): Setting new future strategy stack:
[16:13:04.365] List of future strategies:
[16:13:04.365] 1. sequential:
[16:13:04.365]    - args: function (..., envir = parent.frame())
[16:13:04.365]    - tweaked: FALSE
[16:13:04.365]    - call: NULL
[16:13:04.366] plan(): nbrOfWorkers() = 1
[16:13:04.367] plan(): Setting new future strategy stack:
[16:13:04.368] List of future strategies:
[16:13:04.368] 1. multicore:
[16:13:04.368]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:04.368]    - tweaked: FALSE
[16:13:04.368]    - call: plan(multicore)
[16:13:04.372] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 9cd5072f-68f7-e4f0-6d65-cff53a745767
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[1] 0
*** multicore(..., globals = FALSE) with globals and blocking
 - Creating multicore future #1 ...
[16:13:04.378] getGlobalsAndPackages() ...
[16:13:04.378] Not searching for globals
[16:13:04.378] - globals: [0] <none>
[16:13:04.378] getGlobalsAndPackages() ... DONE
[16:13:04.379] Packages needed by the future expression (n = 0): <none>
[16:13:04.379] Packages needed by future strategies (n = 0): <none>
[16:13:04.379] {
[16:13:04.379]     {
[16:13:04.379]         {
[16:13:04.379]             ...future.startTime <- base::Sys.time()
[16:13:04.379]             {
[16:13:04.379]                 {
[16:13:04.379]                   {
[16:13:04.379]                     {
[16:13:04.379]                       base::local({
[16:13:04.379]                         has_future <- base::requireNamespace("future", 
[16:13:04.379]                           quietly = TRUE)
[16:13:04.379]                         if (has_future) {
[16:13:04.379]                           ns <- base::getNamespace("future")
[16:13:04.379]                           version <- ns[[".package"]][["version"]]
[16:13:04.379]                           if (is.null(version)) 
[16:13:04.379]                             version <- utils::packageVersion("future")
[16:13:04.379]                         }
[16:13:04.379]                         else {
[16:13:04.379]                           version <- NULL
[16:13:04.379]                         }
[16:13:04.379]                         if (!has_future || version < "1.8.0") {
[16:13:04.379]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:04.379]                             "", base::R.version$version.string), 
[16:13:04.379]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:04.379]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:04.379]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:04.379]                               "release", "version")], collapse = " "), 
[16:13:04.379]                             hostname = base::Sys.info()[["nodename"]])
[16:13:04.379]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:04.379]                             info)
[16:13:04.379]                           info <- base::paste(info, collapse = "; ")
[16:13:04.379]                           if (!has_future) {
[16:13:04.379]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:04.379]                               info)
[16:13:04.379]                           }
[16:13:04.379]                           else {
[16:13:04.379]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:04.379]                               info, version)
[16:13:04.379]                           }
[16:13:04.379]                           base::stop(msg)
[16:13:04.379]                         }
[16:13:04.379]                       })
[16:13:04.379]                     }
[16:13:04.379]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:04.379]                     base::options(mc.cores = 1L)
[16:13:04.379]                   }
[16:13:04.379]                   options(future.plan = NULL)
[16:13:04.379]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.379]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:04.379]                 }
[16:13:04.379]                 ...future.workdir <- getwd()
[16:13:04.379]             }
[16:13:04.379]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:04.379]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:04.379]         }
[16:13:04.379]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:04.379]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:04.379]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:04.379]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:04.379]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:04.379]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:04.379]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:04.379]             base::names(...future.oldOptions))
[16:13:04.379]     }
[16:13:04.379]     if (FALSE) {
[16:13:04.379]     }
[16:13:04.379]     else {
[16:13:04.379]         if (TRUE) {
[16:13:04.379]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:04.379]                 open = "w")
[16:13:04.379]         }
[16:13:04.379]         else {
[16:13:04.379]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:04.379]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:04.379]         }
[16:13:04.379]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:04.379]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:04.379]             base::sink(type = "output", split = FALSE)
[16:13:04.379]             base::close(...future.stdout)
[16:13:04.379]         }, add = TRUE)
[16:13:04.379]     }
[16:13:04.379]     ...future.frame <- base::sys.nframe()
[16:13:04.379]     ...future.conditions <- base::list()
[16:13:04.379]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:04.379]     if (FALSE) {
[16:13:04.379]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:04.379]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:04.379]     }
[16:13:04.379]     ...future.result <- base::tryCatch({
[16:13:04.379]         base::withCallingHandlers({
[16:13:04.379]             ...future.value <- base::withVisible(base::local({
[16:13:04.379]                 withCallingHandlers({
[16:13:04.379]                   {
[16:13:04.379]                     ii
[16:13:04.379]                   }
[16:13:04.379]                 }, immediateCondition = function(cond) {
[16:13:04.379]                   save_rds <- function (object, pathname, ...) 
[16:13:04.379]                   {
[16:13:04.379]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:04.379]                     if (file_test("-f", pathname_tmp)) {
[16:13:04.379]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.379]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:04.379]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.379]                         fi_tmp[["mtime"]])
[16:13:04.379]                     }
[16:13:04.379]                     tryCatch({
[16:13:04.379]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:04.379]                     }, error = function(ex) {
[16:13:04.379]                       msg <- conditionMessage(ex)
[16:13:04.379]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.379]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:04.379]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.379]                         fi_tmp[["mtime"]], msg)
[16:13:04.379]                       ex$message <- msg
[16:13:04.379]                       stop(ex)
[16:13:04.379]                     })
[16:13:04.379]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:04.379]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:04.379]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:04.379]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.379]                       fi <- file.info(pathname)
[16:13:04.379]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:04.379]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.379]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:04.379]                         fi[["size"]], fi[["mtime"]])
[16:13:04.379]                       stop(msg)
[16:13:04.379]                     }
[16:13:04.379]                     invisible(pathname)
[16:13:04.379]                   }
[16:13:04.379]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:04.379]                     rootPath = tempdir()) 
[16:13:04.379]                   {
[16:13:04.379]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:04.379]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:04.379]                       tmpdir = path, fileext = ".rds")
[16:13:04.379]                     save_rds(obj, file)
[16:13:04.379]                   }
[16:13:04.379]                   saveImmediateCondition(cond, path = "/tmp/RtmpmgpgJ1/.future/immediateConditions")
[16:13:04.379]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.379]                   {
[16:13:04.379]                     inherits <- base::inherits
[16:13:04.379]                     invokeRestart <- base::invokeRestart
[16:13:04.379]                     is.null <- base::is.null
[16:13:04.379]                     muffled <- FALSE
[16:13:04.379]                     if (inherits(cond, "message")) {
[16:13:04.379]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:04.379]                       if (muffled) 
[16:13:04.379]                         invokeRestart("muffleMessage")
[16:13:04.379]                     }
[16:13:04.379]                     else if (inherits(cond, "warning")) {
[16:13:04.379]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:04.379]                       if (muffled) 
[16:13:04.379]                         invokeRestart("muffleWarning")
[16:13:04.379]                     }
[16:13:04.379]                     else if (inherits(cond, "condition")) {
[16:13:04.379]                       if (!is.null(pattern)) {
[16:13:04.379]                         computeRestarts <- base::computeRestarts
[16:13:04.379]                         grepl <- base::grepl
[16:13:04.379]                         restarts <- computeRestarts(cond)
[16:13:04.379]                         for (restart in restarts) {
[16:13:04.379]                           name <- restart$name
[16:13:04.379]                           if (is.null(name)) 
[16:13:04.379]                             next
[16:13:04.379]                           if (!grepl(pattern, name)) 
[16:13:04.379]                             next
[16:13:04.379]                           invokeRestart(restart)
[16:13:04.379]                           muffled <- TRUE
[16:13:04.379]                           break
[16:13:04.379]                         }
[16:13:04.379]                       }
[16:13:04.379]                     }
[16:13:04.379]                     invisible(muffled)
[16:13:04.379]                   }
[16:13:04.379]                   muffleCondition(cond)
[16:13:04.379]                 })
[16:13:04.379]             }))
[16:13:04.379]             future::FutureResult(value = ...future.value$value, 
[16:13:04.379]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.379]                   ...future.rng), globalenv = if (FALSE) 
[16:13:04.379]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:04.379]                     ...future.globalenv.names))
[16:13:04.379]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:04.379]         }, condition = base::local({
[16:13:04.379]             c <- base::c
[16:13:04.379]             inherits <- base::inherits
[16:13:04.379]             invokeRestart <- base::invokeRestart
[16:13:04.379]             length <- base::length
[16:13:04.379]             list <- base::list
[16:13:04.379]             seq.int <- base::seq.int
[16:13:04.379]             signalCondition <- base::signalCondition
[16:13:04.379]             sys.calls <- base::sys.calls
[16:13:04.379]             `[[` <- base::`[[`
[16:13:04.379]             `+` <- base::`+`
[16:13:04.379]             `<<-` <- base::`<<-`
[16:13:04.379]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:04.379]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:04.379]                   3L)]
[16:13:04.379]             }
[16:13:04.379]             function(cond) {
[16:13:04.379]                 is_error <- inherits(cond, "error")
[16:13:04.379]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:04.379]                   NULL)
[16:13:04.379]                 if (is_error) {
[16:13:04.379]                   sessionInformation <- function() {
[16:13:04.379]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:04.379]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:04.379]                       search = base::search(), system = base::Sys.info())
[16:13:04.379]                   }
[16:13:04.379]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.379]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:04.379]                     cond$call), session = sessionInformation(), 
[16:13:04.379]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:04.379]                   signalCondition(cond)
[16:13:04.379]                 }
[16:13:04.379]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:04.379]                 "immediateCondition"))) {
[16:13:04.379]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:04.379]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.379]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:04.379]                   if (TRUE && !signal) {
[16:13:04.379]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.379]                     {
[16:13:04.379]                       inherits <- base::inherits
[16:13:04.379]                       invokeRestart <- base::invokeRestart
[16:13:04.379]                       is.null <- base::is.null
[16:13:04.379]                       muffled <- FALSE
[16:13:04.379]                       if (inherits(cond, "message")) {
[16:13:04.379]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.379]                         if (muffled) 
[16:13:04.379]                           invokeRestart("muffleMessage")
[16:13:04.379]                       }
[16:13:04.379]                       else if (inherits(cond, "warning")) {
[16:13:04.379]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.379]                         if (muffled) 
[16:13:04.379]                           invokeRestart("muffleWarning")
[16:13:04.379]                       }
[16:13:04.379]                       else if (inherits(cond, "condition")) {
[16:13:04.379]                         if (!is.null(pattern)) {
[16:13:04.379]                           computeRestarts <- base::computeRestarts
[16:13:04.379]                           grepl <- base::grepl
[16:13:04.379]                           restarts <- computeRestarts(cond)
[16:13:04.379]                           for (restart in restarts) {
[16:13:04.379]                             name <- restart$name
[16:13:04.379]                             if (is.null(name)) 
[16:13:04.379]                               next
[16:13:04.379]                             if (!grepl(pattern, name)) 
[16:13:04.379]                               next
[16:13:04.379]                             invokeRestart(restart)
[16:13:04.379]                             muffled <- TRUE
[16:13:04.379]                             break
[16:13:04.379]                           }
[16:13:04.379]                         }
[16:13:04.379]                       }
[16:13:04.379]                       invisible(muffled)
[16:13:04.379]                     }
[16:13:04.379]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.379]                   }
[16:13:04.379]                 }
[16:13:04.379]                 else {
[16:13:04.379]                   if (TRUE) {
[16:13:04.379]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.379]                     {
[16:13:04.379]                       inherits <- base::inherits
[16:13:04.379]                       invokeRestart <- base::invokeRestart
[16:13:04.379]                       is.null <- base::is.null
[16:13:04.379]                       muffled <- FALSE
[16:13:04.379]                       if (inherits(cond, "message")) {
[16:13:04.379]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.379]                         if (muffled) 
[16:13:04.379]                           invokeRestart("muffleMessage")
[16:13:04.379]                       }
[16:13:04.379]                       else if (inherits(cond, "warning")) {
[16:13:04.379]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.379]                         if (muffled) 
[16:13:04.379]                           invokeRestart("muffleWarning")
[16:13:04.379]                       }
[16:13:04.379]                       else if (inherits(cond, "condition")) {
[16:13:04.379]                         if (!is.null(pattern)) {
[16:13:04.379]                           computeRestarts <- base::computeRestarts
[16:13:04.379]                           grepl <- base::grepl
[16:13:04.379]                           restarts <- computeRestarts(cond)
[16:13:04.379]                           for (restart in restarts) {
[16:13:04.379]                             name <- restart$name
[16:13:04.379]                             if (is.null(name)) 
[16:13:04.379]                               next
[16:13:04.379]                             if (!grepl(pattern, name)) 
[16:13:04.379]                               next
[16:13:04.379]                             invokeRestart(restart)
[16:13:04.379]                             muffled <- TRUE
[16:13:04.379]                             break
[16:13:04.379]                           }
[16:13:04.379]                         }
[16:13:04.379]                       }
[16:13:04.379]                       invisible(muffled)
[16:13:04.379]                     }
[16:13:04.379]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.379]                   }
[16:13:04.379]                 }
[16:13:04.379]             }
[16:13:04.379]         }))
[16:13:04.379]     }, error = function(ex) {
[16:13:04.379]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:04.379]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.379]                 ...future.rng), started = ...future.startTime, 
[16:13:04.379]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:04.379]             version = "1.8"), class = "FutureResult")
[16:13:04.379]     }, finally = {
[16:13:04.379]         if (!identical(...future.workdir, getwd())) 
[16:13:04.379]             setwd(...future.workdir)
[16:13:04.379]         {
[16:13:04.379]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:04.379]                 ...future.oldOptions$nwarnings <- NULL
[16:13:04.379]             }
[16:13:04.379]             base::options(...future.oldOptions)
[16:13:04.379]             if (.Platform$OS.type == "windows") {
[16:13:04.379]                 old_names <- names(...future.oldEnvVars)
[16:13:04.379]                 envs <- base::Sys.getenv()
[16:13:04.379]                 names <- names(envs)
[16:13:04.379]                 common <- intersect(names, old_names)
[16:13:04.379]                 added <- setdiff(names, old_names)
[16:13:04.379]                 removed <- setdiff(old_names, names)
[16:13:04.379]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:04.379]                   envs[common]]
[16:13:04.379]                 NAMES <- toupper(changed)
[16:13:04.379]                 args <- list()
[16:13:04.379]                 for (kk in seq_along(NAMES)) {
[16:13:04.379]                   name <- changed[[kk]]
[16:13:04.379]                   NAME <- NAMES[[kk]]
[16:13:04.379]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.379]                     next
[16:13:04.379]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.379]                 }
[16:13:04.379]                 NAMES <- toupper(added)
[16:13:04.379]                 for (kk in seq_along(NAMES)) {
[16:13:04.379]                   name <- added[[kk]]
[16:13:04.379]                   NAME <- NAMES[[kk]]
[16:13:04.379]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.379]                     next
[16:13:04.379]                   args[[name]] <- ""
[16:13:04.379]                 }
[16:13:04.379]                 NAMES <- toupper(removed)
[16:13:04.379]                 for (kk in seq_along(NAMES)) {
[16:13:04.379]                   name <- removed[[kk]]
[16:13:04.379]                   NAME <- NAMES[[kk]]
[16:13:04.379]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.379]                     next
[16:13:04.379]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.379]                 }
[16:13:04.379]                 if (length(args) > 0) 
[16:13:04.379]                   base::do.call(base::Sys.setenv, args = args)
[16:13:04.379]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:04.379]             }
[16:13:04.379]             else {
[16:13:04.379]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:04.379]             }
[16:13:04.379]             {
[16:13:04.379]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:04.379]                   0L) {
[16:13:04.379]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:04.379]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:04.379]                   base::options(opts)
[16:13:04.379]                 }
[16:13:04.379]                 {
[16:13:04.379]                   {
[16:13:04.379]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:04.379]                     NULL
[16:13:04.379]                   }
[16:13:04.379]                   options(future.plan = NULL)
[16:13:04.379]                   if (is.na(NA_character_)) 
[16:13:04.379]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.379]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:04.379]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:04.379]                     envir = parent.frame()) 
[16:13:04.379]                   {
[16:13:04.379]                     default_workers <- missing(workers)
[16:13:04.379]                     if (is.function(workers)) 
[16:13:04.379]                       workers <- workers()
[16:13:04.379]                     workers <- structure(as.integer(workers), 
[16:13:04.379]                       class = class(workers))
[16:13:04.379]                     stop_if_not(is.finite(workers), workers >= 
[16:13:04.379]                       1L)
[16:13:04.379]                     if ((workers == 1L && !inherits(workers, 
[16:13:04.379]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:04.379]                       if (default_workers) 
[16:13:04.379]                         supportsMulticore(warn = TRUE)
[16:13:04.379]                       return(sequential(..., envir = envir))
[16:13:04.379]                     }
[16:13:04.379]                     oopts <- options(mc.cores = workers)
[16:13:04.379]                     on.exit(options(oopts))
[16:13:04.379]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:04.379]                       envir = envir)
[16:13:04.379]                     if (!future$lazy) 
[16:13:04.379]                       future <- run(future)
[16:13:04.379]                     invisible(future)
[16:13:04.379]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:04.379]                 }
[16:13:04.379]             }
[16:13:04.379]         }
[16:13:04.379]     })
[16:13:04.379]     if (TRUE) {
[16:13:04.379]         base::sink(type = "output", split = FALSE)
[16:13:04.379]         if (TRUE) {
[16:13:04.379]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:04.379]         }
[16:13:04.379]         else {
[16:13:04.379]             ...future.result["stdout"] <- base::list(NULL)
[16:13:04.379]         }
[16:13:04.379]         base::close(...future.stdout)
[16:13:04.379]         ...future.stdout <- NULL
[16:13:04.379]     }
[16:13:04.379]     ...future.result$conditions <- ...future.conditions
[16:13:04.379]     ...future.result$finished <- base::Sys.time()
[16:13:04.379]     ...future.result
[16:13:04.379] }
[16:13:04.382] requestCore(): workers = 2
[16:13:04.384] MulticoreFuture started
 - Creating multicore future #2 ...
[16:13:04.385] plan(): Setting new future strategy stack:
[16:13:04.385] List of future strategies:
[16:13:04.385] 1. sequential:
[16:13:04.385]    - args: function (..., envir = parent.frame())
[16:13:04.385]    - tweaked: FALSE
[16:13:04.385]    - call: NULL
[16:13:04.386] plan(): nbrOfWorkers() = 1
[16:13:04.388] plan(): Setting new future strategy stack:
[16:13:04.388] List of future strategies:
[16:13:04.388] 1. multicore:
[16:13:04.388]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:04.388]    - tweaked: FALSE
[16:13:04.388]    - call: plan(multicore)
[16:13:04.390] getGlobalsAndPackages() ...
[16:13:04.390] Not searching for globals
[16:13:04.390] - globals: [0] <none>
[16:13:04.390] getGlobalsAndPackages() ... DONE
[16:13:04.391] Packages needed by the future expression (n = 0): <none>
[16:13:04.391] Packages needed by future strategies (n = 0): <none>
[16:13:04.393] plan(): nbrOfWorkers() = 2
[16:13:04.392] {
[16:13:04.392]     {
[16:13:04.392]         {
[16:13:04.392]             ...future.startTime <- base::Sys.time()
[16:13:04.392]             {
[16:13:04.392]                 {
[16:13:04.392]                   {
[16:13:04.392]                     {
[16:13:04.392]                       base::local({
[16:13:04.392]                         has_future <- base::requireNamespace("future", 
[16:13:04.392]                           quietly = TRUE)
[16:13:04.392]                         if (has_future) {
[16:13:04.392]                           ns <- base::getNamespace("future")
[16:13:04.392]                           version <- ns[[".package"]][["version"]]
[16:13:04.392]                           if (is.null(version)) 
[16:13:04.392]                             version <- utils::packageVersion("future")
[16:13:04.392]                         }
[16:13:04.392]                         else {
[16:13:04.392]                           version <- NULL
[16:13:04.392]                         }
[16:13:04.392]                         if (!has_future || version < "1.8.0") {
[16:13:04.392]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:04.392]                             "", base::R.version$version.string), 
[16:13:04.392]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:04.392]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:04.392]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:04.392]                               "release", "version")], collapse = " "), 
[16:13:04.392]                             hostname = base::Sys.info()[["nodename"]])
[16:13:04.392]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:04.392]                             info)
[16:13:04.392]                           info <- base::paste(info, collapse = "; ")
[16:13:04.392]                           if (!has_future) {
[16:13:04.392]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:04.392]                               info)
[16:13:04.392]                           }
[16:13:04.392]                           else {
[16:13:04.392]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:04.392]                               info, version)
[16:13:04.392]                           }
[16:13:04.392]                           base::stop(msg)
[16:13:04.392]                         }
[16:13:04.392]                       })
[16:13:04.392]                     }
[16:13:04.392]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:04.392]                     base::options(mc.cores = 1L)
[16:13:04.392]                   }
[16:13:04.392]                   options(future.plan = NULL)
[16:13:04.392]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.392]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:04.392]                 }
[16:13:04.392]                 ...future.workdir <- getwd()
[16:13:04.392]             }
[16:13:04.392]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:04.392]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:04.392]         }
[16:13:04.392]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:04.392]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:04.392]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:04.392]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:04.392]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:04.392]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:04.392]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:04.392]             base::names(...future.oldOptions))
[16:13:04.392]     }
[16:13:04.392]     if (FALSE) {
[16:13:04.392]     }
[16:13:04.392]     else {
[16:13:04.392]         if (TRUE) {
[16:13:04.392]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:04.392]                 open = "w")
[16:13:04.392]         }
[16:13:04.392]         else {
[16:13:04.392]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:04.392]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:04.392]         }
[16:13:04.392]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:04.392]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:04.392]             base::sink(type = "output", split = FALSE)
[16:13:04.392]             base::close(...future.stdout)
[16:13:04.392]         }, add = TRUE)
[16:13:04.392]     }
[16:13:04.392]     ...future.frame <- base::sys.nframe()
[16:13:04.392]     ...future.conditions <- base::list()
[16:13:04.392]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:04.392]     if (FALSE) {
[16:13:04.392]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:04.392]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:04.392]     }
[16:13:04.392]     ...future.result <- base::tryCatch({
[16:13:04.392]         base::withCallingHandlers({
[16:13:04.392]             ...future.value <- base::withVisible(base::local({
[16:13:04.392]                 withCallingHandlers({
[16:13:04.392]                   {
[16:13:04.392]                     ii
[16:13:04.392]                   }
[16:13:04.392]                 }, immediateCondition = function(cond) {
[16:13:04.392]                   save_rds <- function (object, pathname, ...) 
[16:13:04.392]                   {
[16:13:04.392]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:04.392]                     if (file_test("-f", pathname_tmp)) {
[16:13:04.392]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.392]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:04.392]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.392]                         fi_tmp[["mtime"]])
[16:13:04.392]                     }
[16:13:04.392]                     tryCatch({
[16:13:04.392]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:04.392]                     }, error = function(ex) {
[16:13:04.392]                       msg <- conditionMessage(ex)
[16:13:04.392]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.392]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:04.392]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.392]                         fi_tmp[["mtime"]], msg)
[16:13:04.392]                       ex$message <- msg
[16:13:04.392]                       stop(ex)
[16:13:04.392]                     })
[16:13:04.392]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:04.392]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:04.392]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:04.392]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.392]                       fi <- file.info(pathname)
[16:13:04.392]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:04.392]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.392]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:04.392]                         fi[["size"]], fi[["mtime"]])
[16:13:04.392]                       stop(msg)
[16:13:04.392]                     }
[16:13:04.392]                     invisible(pathname)
[16:13:04.392]                   }
[16:13:04.392]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:04.392]                     rootPath = tempdir()) 
[16:13:04.392]                   {
[16:13:04.392]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:04.392]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:04.392]                       tmpdir = path, fileext = ".rds")
[16:13:04.392]                     save_rds(obj, file)
[16:13:04.392]                   }
[16:13:04.392]                   saveImmediateCondition(cond, path = "/tmp/RtmpmgpgJ1/.future/immediateConditions")
[16:13:04.392]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.392]                   {
[16:13:04.392]                     inherits <- base::inherits
[16:13:04.392]                     invokeRestart <- base::invokeRestart
[16:13:04.392]                     is.null <- base::is.null
[16:13:04.392]                     muffled <- FALSE
[16:13:04.392]                     if (inherits(cond, "message")) {
[16:13:04.392]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:04.392]                       if (muffled) 
[16:13:04.392]                         invokeRestart("muffleMessage")
[16:13:04.392]                     }
[16:13:04.392]                     else if (inherits(cond, "warning")) {
[16:13:04.392]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:04.392]                       if (muffled) 
[16:13:04.392]                         invokeRestart("muffleWarning")
[16:13:04.392]                     }
[16:13:04.392]                     else if (inherits(cond, "condition")) {
[16:13:04.392]                       if (!is.null(pattern)) {
[16:13:04.392]                         computeRestarts <- base::computeRestarts
[16:13:04.392]                         grepl <- base::grepl
[16:13:04.392]                         restarts <- computeRestarts(cond)
[16:13:04.392]                         for (restart in restarts) {
[16:13:04.392]                           name <- restart$name
[16:13:04.392]                           if (is.null(name)) 
[16:13:04.392]                             next
[16:13:04.392]                           if (!grepl(pattern, name)) 
[16:13:04.392]                             next
[16:13:04.392]                           invokeRestart(restart)
[16:13:04.392]                           muffled <- TRUE
[16:13:04.392]                           break
[16:13:04.392]                         }
[16:13:04.392]                       }
[16:13:04.392]                     }
[16:13:04.392]                     invisible(muffled)
[16:13:04.392]                   }
[16:13:04.392]                   muffleCondition(cond)
[16:13:04.392]                 })
[16:13:04.392]             }))
[16:13:04.392]             future::FutureResult(value = ...future.value$value, 
[16:13:04.392]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.392]                   ...future.rng), globalenv = if (FALSE) 
[16:13:04.392]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:04.392]                     ...future.globalenv.names))
[16:13:04.392]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:04.392]         }, condition = base::local({
[16:13:04.392]             c <- base::c
[16:13:04.392]             inherits <- base::inherits
[16:13:04.392]             invokeRestart <- base::invokeRestart
[16:13:04.392]             length <- base::length
[16:13:04.392]             list <- base::list
[16:13:04.392]             seq.int <- base::seq.int
[16:13:04.392]             signalCondition <- base::signalCondition
[16:13:04.392]             sys.calls <- base::sys.calls
[16:13:04.392]             `[[` <- base::`[[`
[16:13:04.392]             `+` <- base::`+`
[16:13:04.392]             `<<-` <- base::`<<-`
[16:13:04.392]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:04.392]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:04.392]                   3L)]
[16:13:04.392]             }
[16:13:04.392]             function(cond) {
[16:13:04.392]                 is_error <- inherits(cond, "error")
[16:13:04.392]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:04.392]                   NULL)
[16:13:04.392]                 if (is_error) {
[16:13:04.392]                   sessionInformation <- function() {
[16:13:04.392]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:04.392]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:04.392]                       search = base::search(), system = base::Sys.info())
[16:13:04.392]                   }
[16:13:04.392]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.392]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:04.392]                     cond$call), session = sessionInformation(), 
[16:13:04.392]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:04.392]                   signalCondition(cond)
[16:13:04.392]                 }
[16:13:04.392]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:04.392]                 "immediateCondition"))) {
[16:13:04.392]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:04.392]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.392]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:04.392]                   if (TRUE && !signal) {
[16:13:04.392]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.392]                     {
[16:13:04.392]                       inherits <- base::inherits
[16:13:04.392]                       invokeRestart <- base::invokeRestart
[16:13:04.392]                       is.null <- base::is.null
[16:13:04.392]                       muffled <- FALSE
[16:13:04.392]                       if (inherits(cond, "message")) {
[16:13:04.392]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.392]                         if (muffled) 
[16:13:04.392]                           invokeRestart("muffleMessage")
[16:13:04.392]                       }
[16:13:04.392]                       else if (inherits(cond, "warning")) {
[16:13:04.392]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.392]                         if (muffled) 
[16:13:04.392]                           invokeRestart("muffleWarning")
[16:13:04.392]                       }
[16:13:04.392]                       else if (inherits(cond, "condition")) {
[16:13:04.392]                         if (!is.null(pattern)) {
[16:13:04.392]                           computeRestarts <- base::computeRestarts
[16:13:04.392]                           grepl <- base::grepl
[16:13:04.392]                           restarts <- computeRestarts(cond)
[16:13:04.392]                           for (restart in restarts) {
[16:13:04.392]                             name <- restart$name
[16:13:04.392]                             if (is.null(name)) 
[16:13:04.392]                               next
[16:13:04.392]                             if (!grepl(pattern, name)) 
[16:13:04.392]                               next
[16:13:04.392]                             invokeRestart(restart)
[16:13:04.392]                             muffled <- TRUE
[16:13:04.392]                             break
[16:13:04.392]                           }
[16:13:04.392]                         }
[16:13:04.392]                       }
[16:13:04.392]                       invisible(muffled)
[16:13:04.392]                     }
[16:13:04.392]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.392]                   }
[16:13:04.392]                 }
[16:13:04.392]                 else {
[16:13:04.392]                   if (TRUE) {
[16:13:04.392]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.392]                     {
[16:13:04.392]                       inherits <- base::inherits
[16:13:04.392]                       invokeRestart <- base::invokeRestart
[16:13:04.392]                       is.null <- base::is.null
[16:13:04.392]                       muffled <- FALSE
[16:13:04.392]                       if (inherits(cond, "message")) {
[16:13:04.392]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.392]                         if (muffled) 
[16:13:04.392]                           invokeRestart("muffleMessage")
[16:13:04.392]                       }
[16:13:04.392]                       else if (inherits(cond, "warning")) {
[16:13:04.392]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.392]                         if (muffled) 
[16:13:04.392]                           invokeRestart("muffleWarning")
[16:13:04.392]                       }
[16:13:04.392]                       else if (inherits(cond, "condition")) {
[16:13:04.392]                         if (!is.null(pattern)) {
[16:13:04.392]                           computeRestarts <- base::computeRestarts
[16:13:04.392]                           grepl <- base::grepl
[16:13:04.392]                           restarts <- computeRestarts(cond)
[16:13:04.392]                           for (restart in restarts) {
[16:13:04.392]                             name <- restart$name
[16:13:04.392]                             if (is.null(name)) 
[16:13:04.392]                               next
[16:13:04.392]                             if (!grepl(pattern, name)) 
[16:13:04.392]                               next
[16:13:04.392]                             invokeRestart(restart)
[16:13:04.392]                             muffled <- TRUE
[16:13:04.392]                             break
[16:13:04.392]                           }
[16:13:04.392]                         }
[16:13:04.392]                       }
[16:13:04.392]                       invisible(muffled)
[16:13:04.392]                     }
[16:13:04.392]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.392]                   }
[16:13:04.392]                 }
[16:13:04.392]             }
[16:13:04.392]         }))
[16:13:04.392]     }, error = function(ex) {
[16:13:04.392]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:04.392]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.392]                 ...future.rng), started = ...future.startTime, 
[16:13:04.392]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:04.392]             version = "1.8"), class = "FutureResult")
[16:13:04.392]     }, finally = {
[16:13:04.392]         if (!identical(...future.workdir, getwd())) 
[16:13:04.392]             setwd(...future.workdir)
[16:13:04.392]         {
[16:13:04.392]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:04.392]                 ...future.oldOptions$nwarnings <- NULL
[16:13:04.392]             }
[16:13:04.392]             base::options(...future.oldOptions)
[16:13:04.392]             if (.Platform$OS.type == "windows") {
[16:13:04.392]                 old_names <- names(...future.oldEnvVars)
[16:13:04.392]                 envs <- base::Sys.getenv()
[16:13:04.392]                 names <- names(envs)
[16:13:04.392]                 common <- intersect(names, old_names)
[16:13:04.392]                 added <- setdiff(names, old_names)
[16:13:04.392]                 removed <- setdiff(old_names, names)
[16:13:04.392]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:04.392]                   envs[common]]
[16:13:04.392]                 NAMES <- toupper(changed)
[16:13:04.392]                 args <- list()
[16:13:04.392]                 for (kk in seq_along(NAMES)) {
[16:13:04.392]                   name <- changed[[kk]]
[16:13:04.392]                   NAME <- NAMES[[kk]]
[16:13:04.392]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.392]                     next
[16:13:04.392]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.392]                 }
[16:13:04.392]                 NAMES <- toupper(added)
[16:13:04.392]                 for (kk in seq_along(NAMES)) {
[16:13:04.392]                   name <- added[[kk]]
[16:13:04.392]                   NAME <- NAMES[[kk]]
[16:13:04.392]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.392]                     next
[16:13:04.392]                   args[[name]] <- ""
[16:13:04.392]                 }
[16:13:04.392]                 NAMES <- toupper(removed)
[16:13:04.392]                 for (kk in seq_along(NAMES)) {
[16:13:04.392]                   name <- removed[[kk]]
[16:13:04.392]                   NAME <- NAMES[[kk]]
[16:13:04.392]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.392]                     next
[16:13:04.392]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.392]                 }
[16:13:04.392]                 if (length(args) > 0) 
[16:13:04.392]                   base::do.call(base::Sys.setenv, args = args)
[16:13:04.392]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:04.392]             }
[16:13:04.392]             else {
[16:13:04.392]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:04.392]             }
[16:13:04.392]             {
[16:13:04.392]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:04.392]                   0L) {
[16:13:04.392]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:04.392]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:04.392]                   base::options(opts)
[16:13:04.392]                 }
[16:13:04.392]                 {
[16:13:04.392]                   {
[16:13:04.392]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:04.392]                     NULL
[16:13:04.392]                   }
[16:13:04.392]                   options(future.plan = NULL)
[16:13:04.392]                   if (is.na(NA_character_)) 
[16:13:04.392]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.392]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:04.392]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:04.392]                     envir = parent.frame()) 
[16:13:04.392]                   {
[16:13:04.392]                     default_workers <- missing(workers)
[16:13:04.392]                     if (is.function(workers)) 
[16:13:04.392]                       workers <- workers()
[16:13:04.392]                     workers <- structure(as.integer(workers), 
[16:13:04.392]                       class = class(workers))
[16:13:04.392]                     stop_if_not(is.finite(workers), workers >= 
[16:13:04.392]                       1L)
[16:13:04.392]                     if ((workers == 1L && !inherits(workers, 
[16:13:04.392]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:04.392]                       if (default_workers) 
[16:13:04.392]                         supportsMulticore(warn = TRUE)
[16:13:04.392]                       return(sequential(..., envir = envir))
[16:13:04.392]                     }
[16:13:04.392]                     oopts <- options(mc.cores = workers)
[16:13:04.392]                     on.exit(options(oopts))
[16:13:04.392]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:04.392]                       envir = envir)
[16:13:04.392]                     if (!future$lazy) 
[16:13:04.392]                       future <- run(future)
[16:13:04.392]                     invisible(future)
[16:13:04.392]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:04.392]                 }
[16:13:04.392]             }
[16:13:04.392]         }
[16:13:04.392]     })
[16:13:04.392]     if (TRUE) {
[16:13:04.392]         base::sink(type = "output", split = FALSE)
[16:13:04.392]         if (TRUE) {
[16:13:04.392]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:04.392]         }
[16:13:04.392]         else {
[16:13:04.392]             ...future.result["stdout"] <- base::list(NULL)
[16:13:04.392]         }
[16:13:04.392]         base::close(...future.stdout)
[16:13:04.392]         ...future.stdout <- NULL
[16:13:04.392]     }
[16:13:04.392]     ...future.result$conditions <- ...future.conditions
[16:13:04.392]     ...future.result$finished <- base::Sys.time()
[16:13:04.392]     ...future.result
[16:13:04.392] }
[16:13:04.396] requestCore(): workers = 2
[16:13:04.398] MulticoreFuture started
 - Creating multicore future #3 ...
[16:13:04.399] plan(): Setting new future strategy stack:
[16:13:04.399] List of future strategies:
[16:13:04.399] 1. sequential:
[16:13:04.399]    - args: function (..., envir = parent.frame())
[16:13:04.399]    - tweaked: FALSE
[16:13:04.399]    - call: NULL
[16:13:04.400] plan(): nbrOfWorkers() = 1
[16:13:04.402] plan(): Setting new future strategy stack:
[16:13:04.402] List of future strategies:
[16:13:04.402] 1. multicore:
[16:13:04.402]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:04.402]    - tweaked: FALSE
[16:13:04.402]    - call: plan(multicore)
[16:13:04.404] getGlobalsAndPackages() ...
[16:13:04.404] Not searching for globals
[16:13:04.405] - globals: [0] <none>
[16:13:04.405] getGlobalsAndPackages() ... DONE
[16:13:04.412] Packages needed by the future expression (n = 0): <none>
[16:13:04.412] Packages needed by future strategies (n = 0): <none>
[16:13:04.415] plan(): nbrOfWorkers() = 2
[16:13:04.413] {
[16:13:04.413]     {
[16:13:04.413]         {
[16:13:04.413]             ...future.startTime <- base::Sys.time()
[16:13:04.413]             {
[16:13:04.413]                 {
[16:13:04.413]                   {
[16:13:04.413]                     {
[16:13:04.413]                       base::local({
[16:13:04.413]                         has_future <- base::requireNamespace("future", 
[16:13:04.413]                           quietly = TRUE)
[16:13:04.413]                         if (has_future) {
[16:13:04.413]                           ns <- base::getNamespace("future")
[16:13:04.413]                           version <- ns[[".package"]][["version"]]
[16:13:04.413]                           if (is.null(version)) 
[16:13:04.413]                             version <- utils::packageVersion("future")
[16:13:04.413]                         }
[16:13:04.413]                         else {
[16:13:04.413]                           version <- NULL
[16:13:04.413]                         }
[16:13:04.413]                         if (!has_future || version < "1.8.0") {
[16:13:04.413]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:04.413]                             "", base::R.version$version.string), 
[16:13:04.413]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:04.413]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:04.413]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:04.413]                               "release", "version")], collapse = " "), 
[16:13:04.413]                             hostname = base::Sys.info()[["nodename"]])
[16:13:04.413]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:04.413]                             info)
[16:13:04.413]                           info <- base::paste(info, collapse = "; ")
[16:13:04.413]                           if (!has_future) {
[16:13:04.413]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:04.413]                               info)
[16:13:04.413]                           }
[16:13:04.413]                           else {
[16:13:04.413]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:04.413]                               info, version)
[16:13:04.413]                           }
[16:13:04.413]                           base::stop(msg)
[16:13:04.413]                         }
[16:13:04.413]                       })
[16:13:04.413]                     }
[16:13:04.413]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:04.413]                     base::options(mc.cores = 1L)
[16:13:04.413]                   }
[16:13:04.413]                   options(future.plan = NULL)
[16:13:04.413]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.413]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:04.413]                 }
[16:13:04.413]                 ...future.workdir <- getwd()
[16:13:04.413]             }
[16:13:04.413]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:04.413]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:04.413]         }
[16:13:04.413]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:04.413]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:04.413]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:04.413]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:04.413]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:04.413]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:04.413]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:04.413]             base::names(...future.oldOptions))
[16:13:04.413]     }
[16:13:04.413]     if (FALSE) {
[16:13:04.413]     }
[16:13:04.413]     else {
[16:13:04.413]         if (TRUE) {
[16:13:04.413]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:04.413]                 open = "w")
[16:13:04.413]         }
[16:13:04.413]         else {
[16:13:04.413]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:04.413]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:04.413]         }
[16:13:04.413]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:04.413]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:04.413]             base::sink(type = "output", split = FALSE)
[16:13:04.413]             base::close(...future.stdout)
[16:13:04.413]         }, add = TRUE)
[16:13:04.413]     }
[16:13:04.413]     ...future.frame <- base::sys.nframe()
[16:13:04.413]     ...future.conditions <- base::list()
[16:13:04.413]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:04.413]     if (FALSE) {
[16:13:04.413]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:04.413]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:04.413]     }
[16:13:04.413]     ...future.result <- base::tryCatch({
[16:13:04.413]         base::withCallingHandlers({
[16:13:04.413]             ...future.value <- base::withVisible(base::local({
[16:13:04.413]                 withCallingHandlers({
[16:13:04.413]                   {
[16:13:04.413]                     ii
[16:13:04.413]                   }
[16:13:04.413]                 }, immediateCondition = function(cond) {
[16:13:04.413]                   save_rds <- function (object, pathname, ...) 
[16:13:04.413]                   {
[16:13:04.413]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:04.413]                     if (file_test("-f", pathname_tmp)) {
[16:13:04.413]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.413]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:04.413]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.413]                         fi_tmp[["mtime"]])
[16:13:04.413]                     }
[16:13:04.413]                     tryCatch({
[16:13:04.413]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:04.413]                     }, error = function(ex) {
[16:13:04.413]                       msg <- conditionMessage(ex)
[16:13:04.413]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.413]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:04.413]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.413]                         fi_tmp[["mtime"]], msg)
[16:13:04.413]                       ex$message <- msg
[16:13:04.413]                       stop(ex)
[16:13:04.413]                     })
[16:13:04.413]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:04.413]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:04.413]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:04.413]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.413]                       fi <- file.info(pathname)
[16:13:04.413]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:04.413]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.413]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:04.413]                         fi[["size"]], fi[["mtime"]])
[16:13:04.413]                       stop(msg)
[16:13:04.413]                     }
[16:13:04.413]                     invisible(pathname)
[16:13:04.413]                   }
[16:13:04.413]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:04.413]                     rootPath = tempdir()) 
[16:13:04.413]                   {
[16:13:04.413]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:04.413]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:04.413]                       tmpdir = path, fileext = ".rds")
[16:13:04.413]                     save_rds(obj, file)
[16:13:04.413]                   }
[16:13:04.413]                   saveImmediateCondition(cond, path = "/tmp/RtmpmgpgJ1/.future/immediateConditions")
[16:13:04.413]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.413]                   {
[16:13:04.413]                     inherits <- base::inherits
[16:13:04.413]                     invokeRestart <- base::invokeRestart
[16:13:04.413]                     is.null <- base::is.null
[16:13:04.413]                     muffled <- FALSE
[16:13:04.413]                     if (inherits(cond, "message")) {
[16:13:04.413]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:04.413]                       if (muffled) 
[16:13:04.413]                         invokeRestart("muffleMessage")
[16:13:04.413]                     }
[16:13:04.413]                     else if (inherits(cond, "warning")) {
[16:13:04.413]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:04.413]                       if (muffled) 
[16:13:04.413]                         invokeRestart("muffleWarning")
[16:13:04.413]                     }
[16:13:04.413]                     else if (inherits(cond, "condition")) {
[16:13:04.413]                       if (!is.null(pattern)) {
[16:13:04.413]                         computeRestarts <- base::computeRestarts
[16:13:04.413]                         grepl <- base::grepl
[16:13:04.413]                         restarts <- computeRestarts(cond)
[16:13:04.413]                         for (restart in restarts) {
[16:13:04.413]                           name <- restart$name
[16:13:04.413]                           if (is.null(name)) 
[16:13:04.413]                             next
[16:13:04.413]                           if (!grepl(pattern, name)) 
[16:13:04.413]                             next
[16:13:04.413]                           invokeRestart(restart)
[16:13:04.413]                           muffled <- TRUE
[16:13:04.413]                           break
[16:13:04.413]                         }
[16:13:04.413]                       }
[16:13:04.413]                     }
[16:13:04.413]                     invisible(muffled)
[16:13:04.413]                   }
[16:13:04.413]                   muffleCondition(cond)
[16:13:04.413]                 })
[16:13:04.413]             }))
[16:13:04.413]             future::FutureResult(value = ...future.value$value, 
[16:13:04.413]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.413]                   ...future.rng), globalenv = if (FALSE) 
[16:13:04.413]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:04.413]                     ...future.globalenv.names))
[16:13:04.413]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:04.413]         }, condition = base::local({
[16:13:04.413]             c <- base::c
[16:13:04.413]             inherits <- base::inherits
[16:13:04.413]             invokeRestart <- base::invokeRestart
[16:13:04.413]             length <- base::length
[16:13:04.413]             list <- base::list
[16:13:04.413]             seq.int <- base::seq.int
[16:13:04.413]             signalCondition <- base::signalCondition
[16:13:04.413]             sys.calls <- base::sys.calls
[16:13:04.413]             `[[` <- base::`[[`
[16:13:04.413]             `+` <- base::`+`
[16:13:04.413]             `<<-` <- base::`<<-`
[16:13:04.413]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:04.413]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:04.413]                   3L)]
[16:13:04.413]             }
[16:13:04.413]             function(cond) {
[16:13:04.413]                 is_error <- inherits(cond, "error")
[16:13:04.413]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:04.413]                   NULL)
[16:13:04.413]                 if (is_error) {
[16:13:04.413]                   sessionInformation <- function() {
[16:13:04.413]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:04.413]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:04.413]                       search = base::search(), system = base::Sys.info())
[16:13:04.413]                   }
[16:13:04.413]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.413]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:04.413]                     cond$call), session = sessionInformation(), 
[16:13:04.413]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:04.413]                   signalCondition(cond)
[16:13:04.413]                 }
[16:13:04.413]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:04.413]                 "immediateCondition"))) {
[16:13:04.413]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:04.413]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.413]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:04.413]                   if (TRUE && !signal) {
[16:13:04.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.413]                     {
[16:13:04.413]                       inherits <- base::inherits
[16:13:04.413]                       invokeRestart <- base::invokeRestart
[16:13:04.413]                       is.null <- base::is.null
[16:13:04.413]                       muffled <- FALSE
[16:13:04.413]                       if (inherits(cond, "message")) {
[16:13:04.413]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.413]                         if (muffled) 
[16:13:04.413]                           invokeRestart("muffleMessage")
[16:13:04.413]                       }
[16:13:04.413]                       else if (inherits(cond, "warning")) {
[16:13:04.413]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.413]                         if (muffled) 
[16:13:04.413]                           invokeRestart("muffleWarning")
[16:13:04.413]                       }
[16:13:04.413]                       else if (inherits(cond, "condition")) {
[16:13:04.413]                         if (!is.null(pattern)) {
[16:13:04.413]                           computeRestarts <- base::computeRestarts
[16:13:04.413]                           grepl <- base::grepl
[16:13:04.413]                           restarts <- computeRestarts(cond)
[16:13:04.413]                           for (restart in restarts) {
[16:13:04.413]                             name <- restart$name
[16:13:04.413]                             if (is.null(name)) 
[16:13:04.413]                               next
[16:13:04.413]                             if (!grepl(pattern, name)) 
[16:13:04.413]                               next
[16:13:04.413]                             invokeRestart(restart)
[16:13:04.413]                             muffled <- TRUE
[16:13:04.413]                             break
[16:13:04.413]                           }
[16:13:04.413]                         }
[16:13:04.413]                       }
[16:13:04.413]                       invisible(muffled)
[16:13:04.413]                     }
[16:13:04.413]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.413]                   }
[16:13:04.413]                 }
[16:13:04.413]                 else {
[16:13:04.413]                   if (TRUE) {
[16:13:04.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.413]                     {
[16:13:04.413]                       inherits <- base::inherits
[16:13:04.413]                       invokeRestart <- base::invokeRestart
[16:13:04.413]                       is.null <- base::is.null
[16:13:04.413]                       muffled <- FALSE
[16:13:04.413]                       if (inherits(cond, "message")) {
[16:13:04.413]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.413]                         if (muffled) 
[16:13:04.413]                           invokeRestart("muffleMessage")
[16:13:04.413]                       }
[16:13:04.413]                       else if (inherits(cond, "warning")) {
[16:13:04.413]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.413]                         if (muffled) 
[16:13:04.413]                           invokeRestart("muffleWarning")
[16:13:04.413]                       }
[16:13:04.413]                       else if (inherits(cond, "condition")) {
[16:13:04.413]                         if (!is.null(pattern)) {
[16:13:04.413]                           computeRestarts <- base::computeRestarts
[16:13:04.413]                           grepl <- base::grepl
[16:13:04.413]                           restarts <- computeRestarts(cond)
[16:13:04.413]                           for (restart in restarts) {
[16:13:04.413]                             name <- restart$name
[16:13:04.413]                             if (is.null(name)) 
[16:13:04.413]                               next
[16:13:04.413]                             if (!grepl(pattern, name)) 
[16:13:04.413]                               next
[16:13:04.413]                             invokeRestart(restart)
[16:13:04.413]                             muffled <- TRUE
[16:13:04.413]                             break
[16:13:04.413]                           }
[16:13:04.413]                         }
[16:13:04.413]                       }
[16:13:04.413]                       invisible(muffled)
[16:13:04.413]                     }
[16:13:04.413]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.413]                   }
[16:13:04.413]                 }
[16:13:04.413]             }
[16:13:04.413]         }))
[16:13:04.413]     }, error = function(ex) {
[16:13:04.413]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:04.413]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.413]                 ...future.rng), started = ...future.startTime, 
[16:13:04.413]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:04.413]             version = "1.8"), class = "FutureResult")
[16:13:04.413]     }, finally = {
[16:13:04.413]         if (!identical(...future.workdir, getwd())) 
[16:13:04.413]             setwd(...future.workdir)
[16:13:04.413]         {
[16:13:04.413]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:04.413]                 ...future.oldOptions$nwarnings <- NULL
[16:13:04.413]             }
[16:13:04.413]             base::options(...future.oldOptions)
[16:13:04.413]             if (.Platform$OS.type == "windows") {
[16:13:04.413]                 old_names <- names(...future.oldEnvVars)
[16:13:04.413]                 envs <- base::Sys.getenv()
[16:13:04.413]                 names <- names(envs)
[16:13:04.413]                 common <- intersect(names, old_names)
[16:13:04.413]                 added <- setdiff(names, old_names)
[16:13:04.413]                 removed <- setdiff(old_names, names)
[16:13:04.413]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:04.413]                   envs[common]]
[16:13:04.413]                 NAMES <- toupper(changed)
[16:13:04.413]                 args <- list()
[16:13:04.413]                 for (kk in seq_along(NAMES)) {
[16:13:04.413]                   name <- changed[[kk]]
[16:13:04.413]                   NAME <- NAMES[[kk]]
[16:13:04.413]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.413]                     next
[16:13:04.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.413]                 }
[16:13:04.413]                 NAMES <- toupper(added)
[16:13:04.413]                 for (kk in seq_along(NAMES)) {
[16:13:04.413]                   name <- added[[kk]]
[16:13:04.413]                   NAME <- NAMES[[kk]]
[16:13:04.413]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.413]                     next
[16:13:04.413]                   args[[name]] <- ""
[16:13:04.413]                 }
[16:13:04.413]                 NAMES <- toupper(removed)
[16:13:04.413]                 for (kk in seq_along(NAMES)) {
[16:13:04.413]                   name <- removed[[kk]]
[16:13:04.413]                   NAME <- NAMES[[kk]]
[16:13:04.413]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.413]                     next
[16:13:04.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.413]                 }
[16:13:04.413]                 if (length(args) > 0) 
[16:13:04.413]                   base::do.call(base::Sys.setenv, args = args)
[16:13:04.413]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:04.413]             }
[16:13:04.413]             else {
[16:13:04.413]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:04.413]             }
[16:13:04.413]             {
[16:13:04.413]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:04.413]                   0L) {
[16:13:04.413]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:04.413]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:04.413]                   base::options(opts)
[16:13:04.413]                 }
[16:13:04.413]                 {
[16:13:04.413]                   {
[16:13:04.413]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:04.413]                     NULL
[16:13:04.413]                   }
[16:13:04.413]                   options(future.plan = NULL)
[16:13:04.413]                   if (is.na(NA_character_)) 
[16:13:04.413]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.413]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:04.413]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:04.413]                     envir = parent.frame()) 
[16:13:04.413]                   {
[16:13:04.413]                     default_workers <- missing(workers)
[16:13:04.413]                     if (is.function(workers)) 
[16:13:04.413]                       workers <- workers()
[16:13:04.413]                     workers <- structure(as.integer(workers), 
[16:13:04.413]                       class = class(workers))
[16:13:04.413]                     stop_if_not(is.finite(workers), workers >= 
[16:13:04.413]                       1L)
[16:13:04.413]                     if ((workers == 1L && !inherits(workers, 
[16:13:04.413]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:04.413]                       if (default_workers) 
[16:13:04.413]                         supportsMulticore(warn = TRUE)
[16:13:04.413]                       return(sequential(..., envir = envir))
[16:13:04.413]                     }
[16:13:04.413]                     oopts <- options(mc.cores = workers)
[16:13:04.413]                     on.exit(options(oopts))
[16:13:04.413]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:04.413]                       envir = envir)
[16:13:04.413]                     if (!future$lazy) 
[16:13:04.413]                       future <- run(future)
[16:13:04.413]                     invisible(future)
[16:13:04.413]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:04.413]                 }
[16:13:04.413]             }
[16:13:04.413]         }
[16:13:04.413]     })
[16:13:04.413]     if (TRUE) {
[16:13:04.413]         base::sink(type = "output", split = FALSE)
[16:13:04.413]         if (TRUE) {
[16:13:04.413]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:04.413]         }
[16:13:04.413]         else {
[16:13:04.413]             ...future.result["stdout"] <- base::list(NULL)
[16:13:04.413]         }
[16:13:04.413]         base::close(...future.stdout)
[16:13:04.413]         ...future.stdout <- NULL
[16:13:04.413]     }
[16:13:04.413]     ...future.result$conditions <- ...future.conditions
[16:13:04.413]     ...future.result$finished <- base::Sys.time()
[16:13:04.413]     ...future.result
[16:13:04.413] }
[16:13:04.417] requestCore(): workers = 2
[16:13:04.417] Poll #1 (0): usedCores() = 2, workers = 2
[16:13:04.432] MulticoreFuture started
 - Creating multicore future #4 ...
[16:13:04.434] plan(): Setting new future strategy stack:
[16:13:04.434] List of future strategies:
[16:13:04.434] 1. sequential:
[16:13:04.434]    - args: function (..., envir = parent.frame())
[16:13:04.434]    - tweaked: FALSE
[16:13:04.434]    - call: NULL
[16:13:04.435] plan(): nbrOfWorkers() = 1
[16:13:04.438] plan(): Setting new future strategy stack:
[16:13:04.438] List of future strategies:
[16:13:04.438] 1. multicore:
[16:13:04.438]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:04.438]    - tweaked: FALSE
[16:13:04.438]    - call: plan(multicore)
[16:13:04.440] getGlobalsAndPackages() ...
[16:13:04.440] Not searching for globals
[16:13:04.441] - globals: [0] <none>
[16:13:04.441] getGlobalsAndPackages() ... DONE
[16:13:04.442] Packages needed by the future expression (n = 0): <none>
[16:13:04.442] Packages needed by future strategies (n = 0): <none>
[16:13:04.444] plan(): nbrOfWorkers() = 2
[16:13:04.443] {
[16:13:04.443]     {
[16:13:04.443]         {
[16:13:04.443]             ...future.startTime <- base::Sys.time()
[16:13:04.443]             {
[16:13:04.443]                 {
[16:13:04.443]                   {
[16:13:04.443]                     {
[16:13:04.443]                       base::local({
[16:13:04.443]                         has_future <- base::requireNamespace("future", 
[16:13:04.443]                           quietly = TRUE)
[16:13:04.443]                         if (has_future) {
[16:13:04.443]                           ns <- base::getNamespace("future")
[16:13:04.443]                           version <- ns[[".package"]][["version"]]
[16:13:04.443]                           if (is.null(version)) 
[16:13:04.443]                             version <- utils::packageVersion("future")
[16:13:04.443]                         }
[16:13:04.443]                         else {
[16:13:04.443]                           version <- NULL
[16:13:04.443]                         }
[16:13:04.443]                         if (!has_future || version < "1.8.0") {
[16:13:04.443]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:04.443]                             "", base::R.version$version.string), 
[16:13:04.443]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:04.443]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:04.443]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:04.443]                               "release", "version")], collapse = " "), 
[16:13:04.443]                             hostname = base::Sys.info()[["nodename"]])
[16:13:04.443]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:04.443]                             info)
[16:13:04.443]                           info <- base::paste(info, collapse = "; ")
[16:13:04.443]                           if (!has_future) {
[16:13:04.443]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:04.443]                               info)
[16:13:04.443]                           }
[16:13:04.443]                           else {
[16:13:04.443]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:04.443]                               info, version)
[16:13:04.443]                           }
[16:13:04.443]                           base::stop(msg)
[16:13:04.443]                         }
[16:13:04.443]                       })
[16:13:04.443]                     }
[16:13:04.443]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:04.443]                     base::options(mc.cores = 1L)
[16:13:04.443]                   }
[16:13:04.443]                   options(future.plan = NULL)
[16:13:04.443]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.443]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:04.443]                 }
[16:13:04.443]                 ...future.workdir <- getwd()
[16:13:04.443]             }
[16:13:04.443]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:04.443]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:04.443]         }
[16:13:04.443]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:04.443]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:04.443]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:04.443]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:04.443]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:04.443]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:04.443]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:04.443]             base::names(...future.oldOptions))
[16:13:04.443]     }
[16:13:04.443]     if (FALSE) {
[16:13:04.443]     }
[16:13:04.443]     else {
[16:13:04.443]         if (TRUE) {
[16:13:04.443]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:04.443]                 open = "w")
[16:13:04.443]         }
[16:13:04.443]         else {
[16:13:04.443]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:04.443]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:04.443]         }
[16:13:04.443]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:04.443]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:04.443]             base::sink(type = "output", split = FALSE)
[16:13:04.443]             base::close(...future.stdout)
[16:13:04.443]         }, add = TRUE)
[16:13:04.443]     }
[16:13:04.443]     ...future.frame <- base::sys.nframe()
[16:13:04.443]     ...future.conditions <- base::list()
[16:13:04.443]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:04.443]     if (FALSE) {
[16:13:04.443]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:04.443]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:04.443]     }
[16:13:04.443]     ...future.result <- base::tryCatch({
[16:13:04.443]         base::withCallingHandlers({
[16:13:04.443]             ...future.value <- base::withVisible(base::local({
[16:13:04.443]                 withCallingHandlers({
[16:13:04.443]                   {
[16:13:04.443]                     ii
[16:13:04.443]                   }
[16:13:04.443]                 }, immediateCondition = function(cond) {
[16:13:04.443]                   save_rds <- function (object, pathname, ...) 
[16:13:04.443]                   {
[16:13:04.443]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:04.443]                     if (file_test("-f", pathname_tmp)) {
[16:13:04.443]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.443]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:04.443]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.443]                         fi_tmp[["mtime"]])
[16:13:04.443]                     }
[16:13:04.443]                     tryCatch({
[16:13:04.443]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:04.443]                     }, error = function(ex) {
[16:13:04.443]                       msg <- conditionMessage(ex)
[16:13:04.443]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.443]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:04.443]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.443]                         fi_tmp[["mtime"]], msg)
[16:13:04.443]                       ex$message <- msg
[16:13:04.443]                       stop(ex)
[16:13:04.443]                     })
[16:13:04.443]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:04.443]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:04.443]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:04.443]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.443]                       fi <- file.info(pathname)
[16:13:04.443]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:04.443]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.443]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:04.443]                         fi[["size"]], fi[["mtime"]])
[16:13:04.443]                       stop(msg)
[16:13:04.443]                     }
[16:13:04.443]                     invisible(pathname)
[16:13:04.443]                   }
[16:13:04.443]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:04.443]                     rootPath = tempdir()) 
[16:13:04.443]                   {
[16:13:04.443]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:04.443]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:04.443]                       tmpdir = path, fileext = ".rds")
[16:13:04.443]                     save_rds(obj, file)
[16:13:04.443]                   }
[16:13:04.443]                   saveImmediateCondition(cond, path = "/tmp/RtmpmgpgJ1/.future/immediateConditions")
[16:13:04.443]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.443]                   {
[16:13:04.443]                     inherits <- base::inherits
[16:13:04.443]                     invokeRestart <- base::invokeRestart
[16:13:04.443]                     is.null <- base::is.null
[16:13:04.443]                     muffled <- FALSE
[16:13:04.443]                     if (inherits(cond, "message")) {
[16:13:04.443]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:04.443]                       if (muffled) 
[16:13:04.443]                         invokeRestart("muffleMessage")
[16:13:04.443]                     }
[16:13:04.443]                     else if (inherits(cond, "warning")) {
[16:13:04.443]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:04.443]                       if (muffled) 
[16:13:04.443]                         invokeRestart("muffleWarning")
[16:13:04.443]                     }
[16:13:04.443]                     else if (inherits(cond, "condition")) {
[16:13:04.443]                       if (!is.null(pattern)) {
[16:13:04.443]                         computeRestarts <- base::computeRestarts
[16:13:04.443]                         grepl <- base::grepl
[16:13:04.443]                         restarts <- computeRestarts(cond)
[16:13:04.443]                         for (restart in restarts) {
[16:13:04.443]                           name <- restart$name
[16:13:04.443]                           if (is.null(name)) 
[16:13:04.443]                             next
[16:13:04.443]                           if (!grepl(pattern, name)) 
[16:13:04.443]                             next
[16:13:04.443]                           invokeRestart(restart)
[16:13:04.443]                           muffled <- TRUE
[16:13:04.443]                           break
[16:13:04.443]                         }
[16:13:04.443]                       }
[16:13:04.443]                     }
[16:13:04.443]                     invisible(muffled)
[16:13:04.443]                   }
[16:13:04.443]                   muffleCondition(cond)
[16:13:04.443]                 })
[16:13:04.443]             }))
[16:13:04.443]             future::FutureResult(value = ...future.value$value, 
[16:13:04.443]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.443]                   ...future.rng), globalenv = if (FALSE) 
[16:13:04.443]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:04.443]                     ...future.globalenv.names))
[16:13:04.443]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:04.443]         }, condition = base::local({
[16:13:04.443]             c <- base::c
[16:13:04.443]             inherits <- base::inherits
[16:13:04.443]             invokeRestart <- base::invokeRestart
[16:13:04.443]             length <- base::length
[16:13:04.443]             list <- base::list
[16:13:04.443]             seq.int <- base::seq.int
[16:13:04.443]             signalCondition <- base::signalCondition
[16:13:04.443]             sys.calls <- base::sys.calls
[16:13:04.443]             `[[` <- base::`[[`
[16:13:04.443]             `+` <- base::`+`
[16:13:04.443]             `<<-` <- base::`<<-`
[16:13:04.443]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:04.443]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:04.443]                   3L)]
[16:13:04.443]             }
[16:13:04.443]             function(cond) {
[16:13:04.443]                 is_error <- inherits(cond, "error")
[16:13:04.443]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:04.443]                   NULL)
[16:13:04.443]                 if (is_error) {
[16:13:04.443]                   sessionInformation <- function() {
[16:13:04.443]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:04.443]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:04.443]                       search = base::search(), system = base::Sys.info())
[16:13:04.443]                   }
[16:13:04.443]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.443]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:04.443]                     cond$call), session = sessionInformation(), 
[16:13:04.443]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:04.443]                   signalCondition(cond)
[16:13:04.443]                 }
[16:13:04.443]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:04.443]                 "immediateCondition"))) {
[16:13:04.443]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:04.443]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.443]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:04.443]                   if (TRUE && !signal) {
[16:13:04.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.443]                     {
[16:13:04.443]                       inherits <- base::inherits
[16:13:04.443]                       invokeRestart <- base::invokeRestart
[16:13:04.443]                       is.null <- base::is.null
[16:13:04.443]                       muffled <- FALSE
[16:13:04.443]                       if (inherits(cond, "message")) {
[16:13:04.443]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.443]                         if (muffled) 
[16:13:04.443]                           invokeRestart("muffleMessage")
[16:13:04.443]                       }
[16:13:04.443]                       else if (inherits(cond, "warning")) {
[16:13:04.443]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.443]                         if (muffled) 
[16:13:04.443]                           invokeRestart("muffleWarning")
[16:13:04.443]                       }
[16:13:04.443]                       else if (inherits(cond, "condition")) {
[16:13:04.443]                         if (!is.null(pattern)) {
[16:13:04.443]                           computeRestarts <- base::computeRestarts
[16:13:04.443]                           grepl <- base::grepl
[16:13:04.443]                           restarts <- computeRestarts(cond)
[16:13:04.443]                           for (restart in restarts) {
[16:13:04.443]                             name <- restart$name
[16:13:04.443]                             if (is.null(name)) 
[16:13:04.443]                               next
[16:13:04.443]                             if (!grepl(pattern, name)) 
[16:13:04.443]                               next
[16:13:04.443]                             invokeRestart(restart)
[16:13:04.443]                             muffled <- TRUE
[16:13:04.443]                             break
[16:13:04.443]                           }
[16:13:04.443]                         }
[16:13:04.443]                       }
[16:13:04.443]                       invisible(muffled)
[16:13:04.443]                     }
[16:13:04.443]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.443]                   }
[16:13:04.443]                 }
[16:13:04.443]                 else {
[16:13:04.443]                   if (TRUE) {
[16:13:04.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.443]                     {
[16:13:04.443]                       inherits <- base::inherits
[16:13:04.443]                       invokeRestart <- base::invokeRestart
[16:13:04.443]                       is.null <- base::is.null
[16:13:04.443]                       muffled <- FALSE
[16:13:04.443]                       if (inherits(cond, "message")) {
[16:13:04.443]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.443]                         if (muffled) 
[16:13:04.443]                           invokeRestart("muffleMessage")
[16:13:04.443]                       }
[16:13:04.443]                       else if (inherits(cond, "warning")) {
[16:13:04.443]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.443]                         if (muffled) 
[16:13:04.443]                           invokeRestart("muffleWarning")
[16:13:04.443]                       }
[16:13:04.443]                       else if (inherits(cond, "condition")) {
[16:13:04.443]                         if (!is.null(pattern)) {
[16:13:04.443]                           computeRestarts <- base::computeRestarts
[16:13:04.443]                           grepl <- base::grepl
[16:13:04.443]                           restarts <- computeRestarts(cond)
[16:13:04.443]                           for (restart in restarts) {
[16:13:04.443]                             name <- restart$name
[16:13:04.443]                             if (is.null(name)) 
[16:13:04.443]                               next
[16:13:04.443]                             if (!grepl(pattern, name)) 
[16:13:04.443]                               next
[16:13:04.443]                             invokeRestart(restart)
[16:13:04.443]                             muffled <- TRUE
[16:13:04.443]                             break
[16:13:04.443]                           }
[16:13:04.443]                         }
[16:13:04.443]                       }
[16:13:04.443]                       invisible(muffled)
[16:13:04.443]                     }
[16:13:04.443]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.443]                   }
[16:13:04.443]                 }
[16:13:04.443]             }
[16:13:04.443]         }))
[16:13:04.443]     }, error = function(ex) {
[16:13:04.443]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:04.443]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.443]                 ...future.rng), started = ...future.startTime, 
[16:13:04.443]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:04.443]             version = "1.8"), class = "FutureResult")
[16:13:04.443]     }, finally = {
[16:13:04.443]         if (!identical(...future.workdir, getwd())) 
[16:13:04.443]             setwd(...future.workdir)
[16:13:04.443]         {
[16:13:04.443]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:04.443]                 ...future.oldOptions$nwarnings <- NULL
[16:13:04.443]             }
[16:13:04.443]             base::options(...future.oldOptions)
[16:13:04.443]             if (.Platform$OS.type == "windows") {
[16:13:04.443]                 old_names <- names(...future.oldEnvVars)
[16:13:04.443]                 envs <- base::Sys.getenv()
[16:13:04.443]                 names <- names(envs)
[16:13:04.443]                 common <- intersect(names, old_names)
[16:13:04.443]                 added <- setdiff(names, old_names)
[16:13:04.443]                 removed <- setdiff(old_names, names)
[16:13:04.443]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:04.443]                   envs[common]]
[16:13:04.443]                 NAMES <- toupper(changed)
[16:13:04.443]                 args <- list()
[16:13:04.443]                 for (kk in seq_along(NAMES)) {
[16:13:04.443]                   name <- changed[[kk]]
[16:13:04.443]                   NAME <- NAMES[[kk]]
[16:13:04.443]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.443]                     next
[16:13:04.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.443]                 }
[16:13:04.443]                 NAMES <- toupper(added)
[16:13:04.443]                 for (kk in seq_along(NAMES)) {
[16:13:04.443]                   name <- added[[kk]]
[16:13:04.443]                   NAME <- NAMES[[kk]]
[16:13:04.443]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.443]                     next
[16:13:04.443]                   args[[name]] <- ""
[16:13:04.443]                 }
[16:13:04.443]                 NAMES <- toupper(removed)
[16:13:04.443]                 for (kk in seq_along(NAMES)) {
[16:13:04.443]                   name <- removed[[kk]]
[16:13:04.443]                   NAME <- NAMES[[kk]]
[16:13:04.443]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.443]                     next
[16:13:04.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.443]                 }
[16:13:04.443]                 if (length(args) > 0) 
[16:13:04.443]                   base::do.call(base::Sys.setenv, args = args)
[16:13:04.443]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:04.443]             }
[16:13:04.443]             else {
[16:13:04.443]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:04.443]             }
[16:13:04.443]             {
[16:13:04.443]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:04.443]                   0L) {
[16:13:04.443]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:04.443]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:04.443]                   base::options(opts)
[16:13:04.443]                 }
[16:13:04.443]                 {
[16:13:04.443]                   {
[16:13:04.443]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:04.443]                     NULL
[16:13:04.443]                   }
[16:13:04.443]                   options(future.plan = NULL)
[16:13:04.443]                   if (is.na(NA_character_)) 
[16:13:04.443]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.443]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:04.443]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:04.443]                     envir = parent.frame()) 
[16:13:04.443]                   {
[16:13:04.443]                     default_workers <- missing(workers)
[16:13:04.443]                     if (is.function(workers)) 
[16:13:04.443]                       workers <- workers()
[16:13:04.443]                     workers <- structure(as.integer(workers), 
[16:13:04.443]                       class = class(workers))
[16:13:04.443]                     stop_if_not(is.finite(workers), workers >= 
[16:13:04.443]                       1L)
[16:13:04.443]                     if ((workers == 1L && !inherits(workers, 
[16:13:04.443]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:04.443]                       if (default_workers) 
[16:13:04.443]                         supportsMulticore(warn = TRUE)
[16:13:04.443]                       return(sequential(..., envir = envir))
[16:13:04.443]                     }
[16:13:04.443]                     oopts <- options(mc.cores = workers)
[16:13:04.443]                     on.exit(options(oopts))
[16:13:04.443]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:04.443]                       envir = envir)
[16:13:04.443]                     if (!future$lazy) 
[16:13:04.443]                       future <- run(future)
[16:13:04.443]                     invisible(future)
[16:13:04.443]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:04.443]                 }
[16:13:04.443]             }
[16:13:04.443]         }
[16:13:04.443]     })
[16:13:04.443]     if (TRUE) {
[16:13:04.443]         base::sink(type = "output", split = FALSE)
[16:13:04.443]         if (TRUE) {
[16:13:04.443]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:04.443]         }
[16:13:04.443]         else {
[16:13:04.443]             ...future.result["stdout"] <- base::list(NULL)
[16:13:04.443]         }
[16:13:04.443]         base::close(...future.stdout)
[16:13:04.443]         ...future.stdout <- NULL
[16:13:04.443]     }
[16:13:04.443]     ...future.result$conditions <- ...future.conditions
[16:13:04.443]     ...future.result$finished <- base::Sys.time()
[16:13:04.443]     ...future.result
[16:13:04.443] }
[16:13:04.447] requestCore(): workers = 2
[16:13:04.448] Poll #1 (0): usedCores() = 2, workers = 2
[16:13:04.475] MulticoreFuture started
 - Resolving 4 multicore futures
[16:13:04.476] plan(): Setting new future strategy stack:
[16:13:04.476] List of future strategies:
[16:13:04.476] 1. sequential:
[16:13:04.476]    - args: function (..., envir = parent.frame())
[16:13:04.476]    - tweaked: FALSE
[16:13:04.476]    - call: NULL
[16:13:04.477] plan(): nbrOfWorkers() = 1
[16:13:04.479] plan(): Setting new future strategy stack:
[16:13:04.479] List of future strategies:
[16:13:04.479] 1. multicore:
[16:13:04.479]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:04.479]    - tweaked: FALSE
[16:13:04.479]    - call: plan(multicore)
[16:13:04.485] plan(): nbrOfWorkers() = 2
*** multicore(..., globals = FALSE) and errors
[16:13:04.490] getGlobalsAndPackages() ...
[16:13:04.490] Not searching for globals
[16:13:04.490] - globals: [0] <none>
[16:13:04.490] getGlobalsAndPackages() ... DONE
[16:13:04.491] Packages needed by the future expression (n = 0): <none>
[16:13:04.491] Packages needed by future strategies (n = 0): <none>
[16:13:04.492] {
[16:13:04.492]     {
[16:13:04.492]         {
[16:13:04.492]             ...future.startTime <- base::Sys.time()
[16:13:04.492]             {
[16:13:04.492]                 {
[16:13:04.492]                   {
[16:13:04.492]                     {
[16:13:04.492]                       base::local({
[16:13:04.492]                         has_future <- base::requireNamespace("future", 
[16:13:04.492]                           quietly = TRUE)
[16:13:04.492]                         if (has_future) {
[16:13:04.492]                           ns <- base::getNamespace("future")
[16:13:04.492]                           version <- ns[[".package"]][["version"]]
[16:13:04.492]                           if (is.null(version)) 
[16:13:04.492]                             version <- utils::packageVersion("future")
[16:13:04.492]                         }
[16:13:04.492]                         else {
[16:13:04.492]                           version <- NULL
[16:13:04.492]                         }
[16:13:04.492]                         if (!has_future || version < "1.8.0") {
[16:13:04.492]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:04.492]                             "", base::R.version$version.string), 
[16:13:04.492]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:04.492]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:04.492]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:04.492]                               "release", "version")], collapse = " "), 
[16:13:04.492]                             hostname = base::Sys.info()[["nodename"]])
[16:13:04.492]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:04.492]                             info)
[16:13:04.492]                           info <- base::paste(info, collapse = "; ")
[16:13:04.492]                           if (!has_future) {
[16:13:04.492]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:04.492]                               info)
[16:13:04.492]                           }
[16:13:04.492]                           else {
[16:13:04.492]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:04.492]                               info, version)
[16:13:04.492]                           }
[16:13:04.492]                           base::stop(msg)
[16:13:04.492]                         }
[16:13:04.492]                       })
[16:13:04.492]                     }
[16:13:04.492]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:04.492]                     base::options(mc.cores = 1L)
[16:13:04.492]                   }
[16:13:04.492]                   options(future.plan = NULL)
[16:13:04.492]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.492]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:04.492]                 }
[16:13:04.492]                 ...future.workdir <- getwd()
[16:13:04.492]             }
[16:13:04.492]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:04.492]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:04.492]         }
[16:13:04.492]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:04.492]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:04.492]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:04.492]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:04.492]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:04.492]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:04.492]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:04.492]             base::names(...future.oldOptions))
[16:13:04.492]     }
[16:13:04.492]     if (FALSE) {
[16:13:04.492]     }
[16:13:04.492]     else {
[16:13:04.492]         if (TRUE) {
[16:13:04.492]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:04.492]                 open = "w")
[16:13:04.492]         }
[16:13:04.492]         else {
[16:13:04.492]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:04.492]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:04.492]         }
[16:13:04.492]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:04.492]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:04.492]             base::sink(type = "output", split = FALSE)
[16:13:04.492]             base::close(...future.stdout)
[16:13:04.492]         }, add = TRUE)
[16:13:04.492]     }
[16:13:04.492]     ...future.frame <- base::sys.nframe()
[16:13:04.492]     ...future.conditions <- base::list()
[16:13:04.492]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:04.492]     if (FALSE) {
[16:13:04.492]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:04.492]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:04.492]     }
[16:13:04.492]     ...future.result <- base::tryCatch({
[16:13:04.492]         base::withCallingHandlers({
[16:13:04.492]             ...future.value <- base::withVisible(base::local({
[16:13:04.492]                 withCallingHandlers({
[16:13:04.492]                   {
[16:13:04.492]                     stop("Whoops!")
[16:13:04.492]                     1
[16:13:04.492]                   }
[16:13:04.492]                 }, immediateCondition = function(cond) {
[16:13:04.492]                   save_rds <- function (object, pathname, ...) 
[16:13:04.492]                   {
[16:13:04.492]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:04.492]                     if (file_test("-f", pathname_tmp)) {
[16:13:04.492]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.492]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:04.492]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.492]                         fi_tmp[["mtime"]])
[16:13:04.492]                     }
[16:13:04.492]                     tryCatch({
[16:13:04.492]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:04.492]                     }, error = function(ex) {
[16:13:04.492]                       msg <- conditionMessage(ex)
[16:13:04.492]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.492]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:04.492]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.492]                         fi_tmp[["mtime"]], msg)
[16:13:04.492]                       ex$message <- msg
[16:13:04.492]                       stop(ex)
[16:13:04.492]                     })
[16:13:04.492]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:04.492]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:04.492]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:04.492]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.492]                       fi <- file.info(pathname)
[16:13:04.492]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:04.492]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.492]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:04.492]                         fi[["size"]], fi[["mtime"]])
[16:13:04.492]                       stop(msg)
[16:13:04.492]                     }
[16:13:04.492]                     invisible(pathname)
[16:13:04.492]                   }
[16:13:04.492]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:04.492]                     rootPath = tempdir()) 
[16:13:04.492]                   {
[16:13:04.492]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:04.492]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:04.492]                       tmpdir = path, fileext = ".rds")
[16:13:04.492]                     save_rds(obj, file)
[16:13:04.492]                   }
[16:13:04.492]                   saveImmediateCondition(cond, path = "/tmp/RtmpmgpgJ1/.future/immediateConditions")
[16:13:04.492]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.492]                   {
[16:13:04.492]                     inherits <- base::inherits
[16:13:04.492]                     invokeRestart <- base::invokeRestart
[16:13:04.492]                     is.null <- base::is.null
[16:13:04.492]                     muffled <- FALSE
[16:13:04.492]                     if (inherits(cond, "message")) {
[16:13:04.492]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:04.492]                       if (muffled) 
[16:13:04.492]                         invokeRestart("muffleMessage")
[16:13:04.492]                     }
[16:13:04.492]                     else if (inherits(cond, "warning")) {
[16:13:04.492]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:04.492]                       if (muffled) 
[16:13:04.492]                         invokeRestart("muffleWarning")
[16:13:04.492]                     }
[16:13:04.492]                     else if (inherits(cond, "condition")) {
[16:13:04.492]                       if (!is.null(pattern)) {
[16:13:04.492]                         computeRestarts <- base::computeRestarts
[16:13:04.492]                         grepl <- base::grepl
[16:13:04.492]                         restarts <- computeRestarts(cond)
[16:13:04.492]                         for (restart in restarts) {
[16:13:04.492]                           name <- restart$name
[16:13:04.492]                           if (is.null(name)) 
[16:13:04.492]                             next
[16:13:04.492]                           if (!grepl(pattern, name)) 
[16:13:04.492]                             next
[16:13:04.492]                           invokeRestart(restart)
[16:13:04.492]                           muffled <- TRUE
[16:13:04.492]                           break
[16:13:04.492]                         }
[16:13:04.492]                       }
[16:13:04.492]                     }
[16:13:04.492]                     invisible(muffled)
[16:13:04.492]                   }
[16:13:04.492]                   muffleCondition(cond)
[16:13:04.492]                 })
[16:13:04.492]             }))
[16:13:04.492]             future::FutureResult(value = ...future.value$value, 
[16:13:04.492]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.492]                   ...future.rng), globalenv = if (FALSE) 
[16:13:04.492]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:04.492]                     ...future.globalenv.names))
[16:13:04.492]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:04.492]         }, condition = base::local({
[16:13:04.492]             c <- base::c
[16:13:04.492]             inherits <- base::inherits
[16:13:04.492]             invokeRestart <- base::invokeRestart
[16:13:04.492]             length <- base::length
[16:13:04.492]             list <- base::list
[16:13:04.492]             seq.int <- base::seq.int
[16:13:04.492]             signalCondition <- base::signalCondition
[16:13:04.492]             sys.calls <- base::sys.calls
[16:13:04.492]             `[[` <- base::`[[`
[16:13:04.492]             `+` <- base::`+`
[16:13:04.492]             `<<-` <- base::`<<-`
[16:13:04.492]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:04.492]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:04.492]                   3L)]
[16:13:04.492]             }
[16:13:04.492]             function(cond) {
[16:13:04.492]                 is_error <- inherits(cond, "error")
[16:13:04.492]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:04.492]                   NULL)
[16:13:04.492]                 if (is_error) {
[16:13:04.492]                   sessionInformation <- function() {
[16:13:04.492]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:04.492]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:04.492]                       search = base::search(), system = base::Sys.info())
[16:13:04.492]                   }
[16:13:04.492]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.492]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:04.492]                     cond$call), session = sessionInformation(), 
[16:13:04.492]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:04.492]                   signalCondition(cond)
[16:13:04.492]                 }
[16:13:04.492]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:04.492]                 "immediateCondition"))) {
[16:13:04.492]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:04.492]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.492]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:04.492]                   if (TRUE && !signal) {
[16:13:04.492]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.492]                     {
[16:13:04.492]                       inherits <- base::inherits
[16:13:04.492]                       invokeRestart <- base::invokeRestart
[16:13:04.492]                       is.null <- base::is.null
[16:13:04.492]                       muffled <- FALSE
[16:13:04.492]                       if (inherits(cond, "message")) {
[16:13:04.492]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.492]                         if (muffled) 
[16:13:04.492]                           invokeRestart("muffleMessage")
[16:13:04.492]                       }
[16:13:04.492]                       else if (inherits(cond, "warning")) {
[16:13:04.492]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.492]                         if (muffled) 
[16:13:04.492]                           invokeRestart("muffleWarning")
[16:13:04.492]                       }
[16:13:04.492]                       else if (inherits(cond, "condition")) {
[16:13:04.492]                         if (!is.null(pattern)) {
[16:13:04.492]                           computeRestarts <- base::computeRestarts
[16:13:04.492]                           grepl <- base::grepl
[16:13:04.492]                           restarts <- computeRestarts(cond)
[16:13:04.492]                           for (restart in restarts) {
[16:13:04.492]                             name <- restart$name
[16:13:04.492]                             if (is.null(name)) 
[16:13:04.492]                               next
[16:13:04.492]                             if (!grepl(pattern, name)) 
[16:13:04.492]                               next
[16:13:04.492]                             invokeRestart(restart)
[16:13:04.492]                             muffled <- TRUE
[16:13:04.492]                             break
[16:13:04.492]                           }
[16:13:04.492]                         }
[16:13:04.492]                       }
[16:13:04.492]                       invisible(muffled)
[16:13:04.492]                     }
[16:13:04.492]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.492]                   }
[16:13:04.492]                 }
[16:13:04.492]                 else {
[16:13:04.492]                   if (TRUE) {
[16:13:04.492]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.492]                     {
[16:13:04.492]                       inherits <- base::inherits
[16:13:04.492]                       invokeRestart <- base::invokeRestart
[16:13:04.492]                       is.null <- base::is.null
[16:13:04.492]                       muffled <- FALSE
[16:13:04.492]                       if (inherits(cond, "message")) {
[16:13:04.492]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.492]                         if (muffled) 
[16:13:04.492]                           invokeRestart("muffleMessage")
[16:13:04.492]                       }
[16:13:04.492]                       else if (inherits(cond, "warning")) {
[16:13:04.492]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.492]                         if (muffled) 
[16:13:04.492]                           invokeRestart("muffleWarning")
[16:13:04.492]                       }
[16:13:04.492]                       else if (inherits(cond, "condition")) {
[16:13:04.492]                         if (!is.null(pattern)) {
[16:13:04.492]                           computeRestarts <- base::computeRestarts
[16:13:04.492]                           grepl <- base::grepl
[16:13:04.492]                           restarts <- computeRestarts(cond)
[16:13:04.492]                           for (restart in restarts) {
[16:13:04.492]                             name <- restart$name
[16:13:04.492]                             if (is.null(name)) 
[16:13:04.492]                               next
[16:13:04.492]                             if (!grepl(pattern, name)) 
[16:13:04.492]                               next
[16:13:04.492]                             invokeRestart(restart)
[16:13:04.492]                             muffled <- TRUE
[16:13:04.492]                             break
[16:13:04.492]                           }
[16:13:04.492]                         }
[16:13:04.492]                       }
[16:13:04.492]                       invisible(muffled)
[16:13:04.492]                     }
[16:13:04.492]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.492]                   }
[16:13:04.492]                 }
[16:13:04.492]             }
[16:13:04.492]         }))
[16:13:04.492]     }, error = function(ex) {
[16:13:04.492]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:04.492]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.492]                 ...future.rng), started = ...future.startTime, 
[16:13:04.492]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:04.492]             version = "1.8"), class = "FutureResult")
[16:13:04.492]     }, finally = {
[16:13:04.492]         if (!identical(...future.workdir, getwd())) 
[16:13:04.492]             setwd(...future.workdir)
[16:13:04.492]         {
[16:13:04.492]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:04.492]                 ...future.oldOptions$nwarnings <- NULL
[16:13:04.492]             }
[16:13:04.492]             base::options(...future.oldOptions)
[16:13:04.492]             if (.Platform$OS.type == "windows") {
[16:13:04.492]                 old_names <- names(...future.oldEnvVars)
[16:13:04.492]                 envs <- base::Sys.getenv()
[16:13:04.492]                 names <- names(envs)
[16:13:04.492]                 common <- intersect(names, old_names)
[16:13:04.492]                 added <- setdiff(names, old_names)
[16:13:04.492]                 removed <- setdiff(old_names, names)
[16:13:04.492]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:04.492]                   envs[common]]
[16:13:04.492]                 NAMES <- toupper(changed)
[16:13:04.492]                 args <- list()
[16:13:04.492]                 for (kk in seq_along(NAMES)) {
[16:13:04.492]                   name <- changed[[kk]]
[16:13:04.492]                   NAME <- NAMES[[kk]]
[16:13:04.492]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.492]                     next
[16:13:04.492]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.492]                 }
[16:13:04.492]                 NAMES <- toupper(added)
[16:13:04.492]                 for (kk in seq_along(NAMES)) {
[16:13:04.492]                   name <- added[[kk]]
[16:13:04.492]                   NAME <- NAMES[[kk]]
[16:13:04.492]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.492]                     next
[16:13:04.492]                   args[[name]] <- ""
[16:13:04.492]                 }
[16:13:04.492]                 NAMES <- toupper(removed)
[16:13:04.492]                 for (kk in seq_along(NAMES)) {
[16:13:04.492]                   name <- removed[[kk]]
[16:13:04.492]                   NAME <- NAMES[[kk]]
[16:13:04.492]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.492]                     next
[16:13:04.492]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.492]                 }
[16:13:04.492]                 if (length(args) > 0) 
[16:13:04.492]                   base::do.call(base::Sys.setenv, args = args)
[16:13:04.492]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:04.492]             }
[16:13:04.492]             else {
[16:13:04.492]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:04.492]             }
[16:13:04.492]             {
[16:13:04.492]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:04.492]                   0L) {
[16:13:04.492]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:04.492]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:04.492]                   base::options(opts)
[16:13:04.492]                 }
[16:13:04.492]                 {
[16:13:04.492]                   {
[16:13:04.492]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:04.492]                     NULL
[16:13:04.492]                   }
[16:13:04.492]                   options(future.plan = NULL)
[16:13:04.492]                   if (is.na(NA_character_)) 
[16:13:04.492]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.492]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:04.492]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:04.492]                     envir = parent.frame()) 
[16:13:04.492]                   {
[16:13:04.492]                     default_workers <- missing(workers)
[16:13:04.492]                     if (is.function(workers)) 
[16:13:04.492]                       workers <- workers()
[16:13:04.492]                     workers <- structure(as.integer(workers), 
[16:13:04.492]                       class = class(workers))
[16:13:04.492]                     stop_if_not(is.finite(workers), workers >= 
[16:13:04.492]                       1L)
[16:13:04.492]                     if ((workers == 1L && !inherits(workers, 
[16:13:04.492]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:04.492]                       if (default_workers) 
[16:13:04.492]                         supportsMulticore(warn = TRUE)
[16:13:04.492]                       return(sequential(..., envir = envir))
[16:13:04.492]                     }
[16:13:04.492]                     oopts <- options(mc.cores = workers)
[16:13:04.492]                     on.exit(options(oopts))
[16:13:04.492]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:04.492]                       envir = envir)
[16:13:04.492]                     if (!future$lazy) 
[16:13:04.492]                       future <- run(future)
[16:13:04.492]                     invisible(future)
[16:13:04.492]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:04.492]                 }
[16:13:04.492]             }
[16:13:04.492]         }
[16:13:04.492]     })
[16:13:04.492]     if (TRUE) {
[16:13:04.492]         base::sink(type = "output", split = FALSE)
[16:13:04.492]         if (TRUE) {
[16:13:04.492]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:04.492]         }
[16:13:04.492]         else {
[16:13:04.492]             ...future.result["stdout"] <- base::list(NULL)
[16:13:04.492]         }
[16:13:04.492]         base::close(...future.stdout)
[16:13:04.492]         ...future.stdout <- NULL
[16:13:04.492]     }
[16:13:04.492]     ...future.result$conditions <- ...future.conditions
[16:13:04.492]     ...future.result$finished <- base::Sys.time()
[16:13:04.492]     ...future.result
[16:13:04.492] }
[16:13:04.494] requestCore(): workers = 2
[16:13:04.496] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:13:04.497] plan(): Setting new future strategy stack:
[16:13:04.498] List of future strategies:
[16:13:04.498] 1. sequential:
[16:13:04.498]    - args: function (..., envir = parent.frame())
[16:13:04.498]    - tweaked: FALSE
[16:13:04.498]    - call: NULL
[16:13:04.499] plan(): nbrOfWorkers() = 1
[16:13:04.500] plan(): Setting new future strategy stack:
[16:13:04.501] List of future strategies:
[16:13:04.501] 1. multicore:
[16:13:04.501]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:04.501]    - tweaked: FALSE
[16:13:04.501]    - call: plan(multicore)
[16:13:04.506] plan(): nbrOfWorkers() = 2
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 9cd5072f-68f7-e4f0-6d65-cff53a745767
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:04.515] signalConditions() ...
[16:13:04.515]  - include = ‘immediateCondition’
[16:13:04.515]  - exclude = 
[16:13:04.515]  - resignal = FALSE
[16:13:04.515]  - Number of conditions: 1
[16:13:04.515] signalConditions() ... done
[16:13:04.516] signalConditions() ...
[16:13:04.516]  - include = ‘immediateCondition’
[16:13:04.516]  - exclude = 
[16:13:04.516]  - resignal = FALSE
[16:13:04.516]  - Number of conditions: 1
[16:13:04.516] signalConditions() ... done
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/RtmpmgpgJ1/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[16:13:04.517] signalConditions() ...
[16:13:04.521]  - include = ‘immediateCondition’
[16:13:04.521]  - exclude = 
[16:13:04.521]  - resignal = FALSE
[16:13:04.521]  - Number of conditions: 1
[16:13:04.521] signalConditions() ... done
[16:13:04.521] Future state: ‘finished’
[16:13:04.521] signalConditions() ...
[16:13:04.521]  - include = ‘condition’
[16:13:04.522]  - exclude = ‘immediateCondition’
[16:13:04.522]  - resignal = TRUE
[16:13:04.522]  - Number of conditions: 1
[16:13:04.522]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:13:04.522] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/RtmpmgpgJ1/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[16:13:04.523] signalConditions() ...
[16:13:04.523]  - include = ‘immediateCondition’
[16:13:04.523]  - exclude = 
[16:13:04.524]  - resignal = FALSE
[16:13:04.524]  - Number of conditions: 1
[16:13:04.524] signalConditions() ... done
[16:13:04.524] Future state: ‘finished’
[16:13:04.524] signalConditions() ...
[16:13:04.524]  - include = ‘condition’
[16:13:04.524]  - exclude = ‘immediateCondition’
[16:13:04.525]  - resignal = TRUE
[16:13:04.525]  - Number of conditions: 1
[16:13:04.525]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:13:04.525] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/RtmpmgpgJ1/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[16:13:04.530] getGlobalsAndPackages() ...
[16:13:04.530] 
[16:13:04.530] - globals: [0] <none>
[16:13:04.530] getGlobalsAndPackages() ... DONE
[16:13:04.531] Packages needed by the future expression (n = 0): <none>
[16:13:04.531] Packages needed by future strategies (n = 0): <none>
[16:13:04.532] {
[16:13:04.532]     {
[16:13:04.532]         {
[16:13:04.532]             ...future.startTime <- base::Sys.time()
[16:13:04.532]             {
[16:13:04.532]                 {
[16:13:04.532]                   {
[16:13:04.532]                     {
[16:13:04.532]                       base::local({
[16:13:04.532]                         has_future <- base::requireNamespace("future", 
[16:13:04.532]                           quietly = TRUE)
[16:13:04.532]                         if (has_future) {
[16:13:04.532]                           ns <- base::getNamespace("future")
[16:13:04.532]                           version <- ns[[".package"]][["version"]]
[16:13:04.532]                           if (is.null(version)) 
[16:13:04.532]                             version <- utils::packageVersion("future")
[16:13:04.532]                         }
[16:13:04.532]                         else {
[16:13:04.532]                           version <- NULL
[16:13:04.532]                         }
[16:13:04.532]                         if (!has_future || version < "1.8.0") {
[16:13:04.532]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:04.532]                             "", base::R.version$version.string), 
[16:13:04.532]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:04.532]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:04.532]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:04.532]                               "release", "version")], collapse = " "), 
[16:13:04.532]                             hostname = base::Sys.info()[["nodename"]])
[16:13:04.532]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:04.532]                             info)
[16:13:04.532]                           info <- base::paste(info, collapse = "; ")
[16:13:04.532]                           if (!has_future) {
[16:13:04.532]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:04.532]                               info)
[16:13:04.532]                           }
[16:13:04.532]                           else {
[16:13:04.532]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:04.532]                               info, version)
[16:13:04.532]                           }
[16:13:04.532]                           base::stop(msg)
[16:13:04.532]                         }
[16:13:04.532]                       })
[16:13:04.532]                     }
[16:13:04.532]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:04.532]                     base::options(mc.cores = 1L)
[16:13:04.532]                   }
[16:13:04.532]                   options(future.plan = NULL)
[16:13:04.532]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.532]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:04.532]                 }
[16:13:04.532]                 ...future.workdir <- getwd()
[16:13:04.532]             }
[16:13:04.532]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:04.532]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:04.532]         }
[16:13:04.532]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:04.532]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:04.532]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:04.532]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:04.532]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:04.532]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:04.532]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:04.532]             base::names(...future.oldOptions))
[16:13:04.532]     }
[16:13:04.532]     if (FALSE) {
[16:13:04.532]     }
[16:13:04.532]     else {
[16:13:04.532]         if (TRUE) {
[16:13:04.532]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:04.532]                 open = "w")
[16:13:04.532]         }
[16:13:04.532]         else {
[16:13:04.532]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:04.532]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:04.532]         }
[16:13:04.532]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:04.532]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:04.532]             base::sink(type = "output", split = FALSE)
[16:13:04.532]             base::close(...future.stdout)
[16:13:04.532]         }, add = TRUE)
[16:13:04.532]     }
[16:13:04.532]     ...future.frame <- base::sys.nframe()
[16:13:04.532]     ...future.conditions <- base::list()
[16:13:04.532]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:04.532]     if (FALSE) {
[16:13:04.532]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:04.532]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:04.532]     }
[16:13:04.532]     ...future.result <- base::tryCatch({
[16:13:04.532]         base::withCallingHandlers({
[16:13:04.532]             ...future.value <- base::withVisible(base::local({
[16:13:04.532]                 withCallingHandlers({
[16:13:04.532]                   {
[16:13:04.532]                     stop(structure(list(message = "boom"), class = c("MyError", 
[16:13:04.532]                       "error", "condition")))
[16:13:04.532]                   }
[16:13:04.532]                 }, immediateCondition = function(cond) {
[16:13:04.532]                   save_rds <- function (object, pathname, ...) 
[16:13:04.532]                   {
[16:13:04.532]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:04.532]                     if (file_test("-f", pathname_tmp)) {
[16:13:04.532]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.532]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:04.532]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.532]                         fi_tmp[["mtime"]])
[16:13:04.532]                     }
[16:13:04.532]                     tryCatch({
[16:13:04.532]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:04.532]                     }, error = function(ex) {
[16:13:04.532]                       msg <- conditionMessage(ex)
[16:13:04.532]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.532]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:04.532]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.532]                         fi_tmp[["mtime"]], msg)
[16:13:04.532]                       ex$message <- msg
[16:13:04.532]                       stop(ex)
[16:13:04.532]                     })
[16:13:04.532]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:04.532]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:04.532]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:04.532]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.532]                       fi <- file.info(pathname)
[16:13:04.532]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:04.532]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.532]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:04.532]                         fi[["size"]], fi[["mtime"]])
[16:13:04.532]                       stop(msg)
[16:13:04.532]                     }
[16:13:04.532]                     invisible(pathname)
[16:13:04.532]                   }
[16:13:04.532]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:04.532]                     rootPath = tempdir()) 
[16:13:04.532]                   {
[16:13:04.532]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:04.532]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:04.532]                       tmpdir = path, fileext = ".rds")
[16:13:04.532]                     save_rds(obj, file)
[16:13:04.532]                   }
[16:13:04.532]                   saveImmediateCondition(cond, path = "/tmp/RtmpmgpgJ1/.future/immediateConditions")
[16:13:04.532]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.532]                   {
[16:13:04.532]                     inherits <- base::inherits
[16:13:04.532]                     invokeRestart <- base::invokeRestart
[16:13:04.532]                     is.null <- base::is.null
[16:13:04.532]                     muffled <- FALSE
[16:13:04.532]                     if (inherits(cond, "message")) {
[16:13:04.532]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:04.532]                       if (muffled) 
[16:13:04.532]                         invokeRestart("muffleMessage")
[16:13:04.532]                     }
[16:13:04.532]                     else if (inherits(cond, "warning")) {
[16:13:04.532]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:04.532]                       if (muffled) 
[16:13:04.532]                         invokeRestart("muffleWarning")
[16:13:04.532]                     }
[16:13:04.532]                     else if (inherits(cond, "condition")) {
[16:13:04.532]                       if (!is.null(pattern)) {
[16:13:04.532]                         computeRestarts <- base::computeRestarts
[16:13:04.532]                         grepl <- base::grepl
[16:13:04.532]                         restarts <- computeRestarts(cond)
[16:13:04.532]                         for (restart in restarts) {
[16:13:04.532]                           name <- restart$name
[16:13:04.532]                           if (is.null(name)) 
[16:13:04.532]                             next
[16:13:04.532]                           if (!grepl(pattern, name)) 
[16:13:04.532]                             next
[16:13:04.532]                           invokeRestart(restart)
[16:13:04.532]                           muffled <- TRUE
[16:13:04.532]                           break
[16:13:04.532]                         }
[16:13:04.532]                       }
[16:13:04.532]                     }
[16:13:04.532]                     invisible(muffled)
[16:13:04.532]                   }
[16:13:04.532]                   muffleCondition(cond)
[16:13:04.532]                 })
[16:13:04.532]             }))
[16:13:04.532]             future::FutureResult(value = ...future.value$value, 
[16:13:04.532]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.532]                   ...future.rng), globalenv = if (FALSE) 
[16:13:04.532]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:04.532]                     ...future.globalenv.names))
[16:13:04.532]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:04.532]         }, condition = base::local({
[16:13:04.532]             c <- base::c
[16:13:04.532]             inherits <- base::inherits
[16:13:04.532]             invokeRestart <- base::invokeRestart
[16:13:04.532]             length <- base::length
[16:13:04.532]             list <- base::list
[16:13:04.532]             seq.int <- base::seq.int
[16:13:04.532]             signalCondition <- base::signalCondition
[16:13:04.532]             sys.calls <- base::sys.calls
[16:13:04.532]             `[[` <- base::`[[`
[16:13:04.532]             `+` <- base::`+`
[16:13:04.532]             `<<-` <- base::`<<-`
[16:13:04.532]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:04.532]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:04.532]                   3L)]
[16:13:04.532]             }
[16:13:04.532]             function(cond) {
[16:13:04.532]                 is_error <- inherits(cond, "error")
[16:13:04.532]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:04.532]                   NULL)
[16:13:04.532]                 if (is_error) {
[16:13:04.532]                   sessionInformation <- function() {
[16:13:04.532]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:04.532]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:04.532]                       search = base::search(), system = base::Sys.info())
[16:13:04.532]                   }
[16:13:04.532]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.532]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:04.532]                     cond$call), session = sessionInformation(), 
[16:13:04.532]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:04.532]                   signalCondition(cond)
[16:13:04.532]                 }
[16:13:04.532]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:04.532]                 "immediateCondition"))) {
[16:13:04.532]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:04.532]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.532]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:04.532]                   if (TRUE && !signal) {
[16:13:04.532]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.532]                     {
[16:13:04.532]                       inherits <- base::inherits
[16:13:04.532]                       invokeRestart <- base::invokeRestart
[16:13:04.532]                       is.null <- base::is.null
[16:13:04.532]                       muffled <- FALSE
[16:13:04.532]                       if (inherits(cond, "message")) {
[16:13:04.532]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.532]                         if (muffled) 
[16:13:04.532]                           invokeRestart("muffleMessage")
[16:13:04.532]                       }
[16:13:04.532]                       else if (inherits(cond, "warning")) {
[16:13:04.532]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.532]                         if (muffled) 
[16:13:04.532]                           invokeRestart("muffleWarning")
[16:13:04.532]                       }
[16:13:04.532]                       else if (inherits(cond, "condition")) {
[16:13:04.532]                         if (!is.null(pattern)) {
[16:13:04.532]                           computeRestarts <- base::computeRestarts
[16:13:04.532]                           grepl <- base::grepl
[16:13:04.532]                           restarts <- computeRestarts(cond)
[16:13:04.532]                           for (restart in restarts) {
[16:13:04.532]                             name <- restart$name
[16:13:04.532]                             if (is.null(name)) 
[16:13:04.532]                               next
[16:13:04.532]                             if (!grepl(pattern, name)) 
[16:13:04.532]                               next
[16:13:04.532]                             invokeRestart(restart)
[16:13:04.532]                             muffled <- TRUE
[16:13:04.532]                             break
[16:13:04.532]                           }
[16:13:04.532]                         }
[16:13:04.532]                       }
[16:13:04.532]                       invisible(muffled)
[16:13:04.532]                     }
[16:13:04.532]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.532]                   }
[16:13:04.532]                 }
[16:13:04.532]                 else {
[16:13:04.532]                   if (TRUE) {
[16:13:04.532]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.532]                     {
[16:13:04.532]                       inherits <- base::inherits
[16:13:04.532]                       invokeRestart <- base::invokeRestart
[16:13:04.532]                       is.null <- base::is.null
[16:13:04.532]                       muffled <- FALSE
[16:13:04.532]                       if (inherits(cond, "message")) {
[16:13:04.532]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.532]                         if (muffled) 
[16:13:04.532]                           invokeRestart("muffleMessage")
[16:13:04.532]                       }
[16:13:04.532]                       else if (inherits(cond, "warning")) {
[16:13:04.532]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.532]                         if (muffled) 
[16:13:04.532]                           invokeRestart("muffleWarning")
[16:13:04.532]                       }
[16:13:04.532]                       else if (inherits(cond, "condition")) {
[16:13:04.532]                         if (!is.null(pattern)) {
[16:13:04.532]                           computeRestarts <- base::computeRestarts
[16:13:04.532]                           grepl <- base::grepl
[16:13:04.532]                           restarts <- computeRestarts(cond)
[16:13:04.532]                           for (restart in restarts) {
[16:13:04.532]                             name <- restart$name
[16:13:04.532]                             if (is.null(name)) 
[16:13:04.532]                               next
[16:13:04.532]                             if (!grepl(pattern, name)) 
[16:13:04.532]                               next
[16:13:04.532]                             invokeRestart(restart)
[16:13:04.532]                             muffled <- TRUE
[16:13:04.532]                             break
[16:13:04.532]                           }
[16:13:04.532]                         }
[16:13:04.532]                       }
[16:13:04.532]                       invisible(muffled)
[16:13:04.532]                     }
[16:13:04.532]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.532]                   }
[16:13:04.532]                 }
[16:13:04.532]             }
[16:13:04.532]         }))
[16:13:04.532]     }, error = function(ex) {
[16:13:04.532]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:04.532]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.532]                 ...future.rng), started = ...future.startTime, 
[16:13:04.532]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:04.532]             version = "1.8"), class = "FutureResult")
[16:13:04.532]     }, finally = {
[16:13:04.532]         if (!identical(...future.workdir, getwd())) 
[16:13:04.532]             setwd(...future.workdir)
[16:13:04.532]         {
[16:13:04.532]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:04.532]                 ...future.oldOptions$nwarnings <- NULL
[16:13:04.532]             }
[16:13:04.532]             base::options(...future.oldOptions)
[16:13:04.532]             if (.Platform$OS.type == "windows") {
[16:13:04.532]                 old_names <- names(...future.oldEnvVars)
[16:13:04.532]                 envs <- base::Sys.getenv()
[16:13:04.532]                 names <- names(envs)
[16:13:04.532]                 common <- intersect(names, old_names)
[16:13:04.532]                 added <- setdiff(names, old_names)
[16:13:04.532]                 removed <- setdiff(old_names, names)
[16:13:04.532]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:04.532]                   envs[common]]
[16:13:04.532]                 NAMES <- toupper(changed)
[16:13:04.532]                 args <- list()
[16:13:04.532]                 for (kk in seq_along(NAMES)) {
[16:13:04.532]                   name <- changed[[kk]]
[16:13:04.532]                   NAME <- NAMES[[kk]]
[16:13:04.532]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.532]                     next
[16:13:04.532]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.532]                 }
[16:13:04.532]                 NAMES <- toupper(added)
[16:13:04.532]                 for (kk in seq_along(NAMES)) {
[16:13:04.532]                   name <- added[[kk]]
[16:13:04.532]                   NAME <- NAMES[[kk]]
[16:13:04.532]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.532]                     next
[16:13:04.532]                   args[[name]] <- ""
[16:13:04.532]                 }
[16:13:04.532]                 NAMES <- toupper(removed)
[16:13:04.532]                 for (kk in seq_along(NAMES)) {
[16:13:04.532]                   name <- removed[[kk]]
[16:13:04.532]                   NAME <- NAMES[[kk]]
[16:13:04.532]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.532]                     next
[16:13:04.532]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.532]                 }
[16:13:04.532]                 if (length(args) > 0) 
[16:13:04.532]                   base::do.call(base::Sys.setenv, args = args)
[16:13:04.532]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:04.532]             }
[16:13:04.532]             else {
[16:13:04.532]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:04.532]             }
[16:13:04.532]             {
[16:13:04.532]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:04.532]                   0L) {
[16:13:04.532]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:04.532]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:04.532]                   base::options(opts)
[16:13:04.532]                 }
[16:13:04.532]                 {
[16:13:04.532]                   {
[16:13:04.532]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:04.532]                     NULL
[16:13:04.532]                   }
[16:13:04.532]                   options(future.plan = NULL)
[16:13:04.532]                   if (is.na(NA_character_)) 
[16:13:04.532]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.532]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:04.532]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:04.532]                     envir = parent.frame()) 
[16:13:04.532]                   {
[16:13:04.532]                     default_workers <- missing(workers)
[16:13:04.532]                     if (is.function(workers)) 
[16:13:04.532]                       workers <- workers()
[16:13:04.532]                     workers <- structure(as.integer(workers), 
[16:13:04.532]                       class = class(workers))
[16:13:04.532]                     stop_if_not(is.finite(workers), workers >= 
[16:13:04.532]                       1L)
[16:13:04.532]                     if ((workers == 1L && !inherits(workers, 
[16:13:04.532]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:04.532]                       if (default_workers) 
[16:13:04.532]                         supportsMulticore(warn = TRUE)
[16:13:04.532]                       return(sequential(..., envir = envir))
[16:13:04.532]                     }
[16:13:04.532]                     oopts <- options(mc.cores = workers)
[16:13:04.532]                     on.exit(options(oopts))
[16:13:04.532]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:04.532]                       envir = envir)
[16:13:04.532]                     if (!future$lazy) 
[16:13:04.532]                       future <- run(future)
[16:13:04.532]                     invisible(future)
[16:13:04.532]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:04.532]                 }
[16:13:04.532]             }
[16:13:04.532]         }
[16:13:04.532]     })
[16:13:04.532]     if (TRUE) {
[16:13:04.532]         base::sink(type = "output", split = FALSE)
[16:13:04.532]         if (TRUE) {
[16:13:04.532]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:04.532]         }
[16:13:04.532]         else {
[16:13:04.532]             ...future.result["stdout"] <- base::list(NULL)
[16:13:04.532]         }
[16:13:04.532]         base::close(...future.stdout)
[16:13:04.532]         ...future.stdout <- NULL
[16:13:04.532]     }
[16:13:04.532]     ...future.result$conditions <- ...future.conditions
[16:13:04.532]     ...future.result$finished <- base::Sys.time()
[16:13:04.532]     ...future.result
[16:13:04.532] }
[16:13:04.534] requestCore(): workers = 2
[16:13:04.536] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:13:04.538] plan(): Setting new future strategy stack:
[16:13:04.538] List of future strategies:
[16:13:04.538] 1. sequential:
[16:13:04.538]    - args: function (..., envir = parent.frame())
[16:13:04.538]    - tweaked: FALSE
[16:13:04.538]    - call: NULL
[16:13:04.539] plan(): nbrOfWorkers() = 1
[16:13:04.541] plan(): Setting new future strategy stack:
[16:13:04.541] List of future strategies:
[16:13:04.541] 1. multicore:
[16:13:04.541]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:04.541]    - tweaked: FALSE
[16:13:04.541]    - call: plan(multicore)
[16:13:04.546] plan(): nbrOfWorkers() = 2
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 9cd5072f-68f7-e4f0-6d65-cff53a745767
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:04.550] signalConditions() ...
[16:13:04.551]  - include = ‘immediateCondition’
[16:13:04.551]  - exclude = 
[16:13:04.551]  - resignal = FALSE
[16:13:04.551]  - Number of conditions: 1
[16:13:04.551] signalConditions() ... done
[16:13:04.551] signalConditions() ...
[16:13:04.551]  - include = ‘immediateCondition’
[16:13:04.552]  - exclude = 
[16:13:04.552]  - resignal = FALSE
[16:13:04.552]  - Number of conditions: 1
[16:13:04.552] signalConditions() ... done
<MyError: boom>
[16:13:04.552] signalConditions() ...
[16:13:04.552]  - include = ‘immediateCondition’
[16:13:04.553]  - exclude = 
[16:13:04.553]  - resignal = FALSE
[16:13:04.553]  - Number of conditions: 1
[16:13:04.553] signalConditions() ... done
[16:13:04.553] Future state: ‘finished’
[16:13:04.553] signalConditions() ...
[16:13:04.553]  - include = ‘condition’
[16:13:04.553]  - exclude = ‘immediateCondition’
[16:13:04.553]  - resignal = TRUE
[16:13:04.554]  - Number of conditions: 1
[16:13:04.554]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[16:13:04.554] signalConditions() ... done
*** multicore(..., globals = TRUE) without globals
[16:13:04.558] getGlobalsAndPackages() ...
[16:13:04.558] Searching for globals...
[16:13:04.559] - globals found: [1] ‘{’
[16:13:04.559] Searching for globals ... DONE
[16:13:04.559] Resolving globals: FALSE
[16:13:04.560] 
[16:13:04.560] 
[16:13:04.560] getGlobalsAndPackages() ... DONE
[16:13:04.560] Packages needed by the future expression (n = 0): <none>
[16:13:04.561] Packages needed by future strategies (n = 0): <none>
[16:13:04.561] {
[16:13:04.561]     {
[16:13:04.561]         {
[16:13:04.561]             ...future.startTime <- base::Sys.time()
[16:13:04.561]             {
[16:13:04.561]                 {
[16:13:04.561]                   {
[16:13:04.561]                     {
[16:13:04.561]                       base::local({
[16:13:04.561]                         has_future <- base::requireNamespace("future", 
[16:13:04.561]                           quietly = TRUE)
[16:13:04.561]                         if (has_future) {
[16:13:04.561]                           ns <- base::getNamespace("future")
[16:13:04.561]                           version <- ns[[".package"]][["version"]]
[16:13:04.561]                           if (is.null(version)) 
[16:13:04.561]                             version <- utils::packageVersion("future")
[16:13:04.561]                         }
[16:13:04.561]                         else {
[16:13:04.561]                           version <- NULL
[16:13:04.561]                         }
[16:13:04.561]                         if (!has_future || version < "1.8.0") {
[16:13:04.561]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:04.561]                             "", base::R.version$version.string), 
[16:13:04.561]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:04.561]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:04.561]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:04.561]                               "release", "version")], collapse = " "), 
[16:13:04.561]                             hostname = base::Sys.info()[["nodename"]])
[16:13:04.561]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:04.561]                             info)
[16:13:04.561]                           info <- base::paste(info, collapse = "; ")
[16:13:04.561]                           if (!has_future) {
[16:13:04.561]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:04.561]                               info)
[16:13:04.561]                           }
[16:13:04.561]                           else {
[16:13:04.561]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:04.561]                               info, version)
[16:13:04.561]                           }
[16:13:04.561]                           base::stop(msg)
[16:13:04.561]                         }
[16:13:04.561]                       })
[16:13:04.561]                     }
[16:13:04.561]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:04.561]                     base::options(mc.cores = 1L)
[16:13:04.561]                   }
[16:13:04.561]                   options(future.plan = NULL)
[16:13:04.561]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.561]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:04.561]                 }
[16:13:04.561]                 ...future.workdir <- getwd()
[16:13:04.561]             }
[16:13:04.561]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:04.561]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:04.561]         }
[16:13:04.561]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:04.561]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:04.561]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:04.561]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:04.561]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:04.561]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:04.561]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:04.561]             base::names(...future.oldOptions))
[16:13:04.561]     }
[16:13:04.561]     if (FALSE) {
[16:13:04.561]     }
[16:13:04.561]     else {
[16:13:04.561]         if (TRUE) {
[16:13:04.561]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:04.561]                 open = "w")
[16:13:04.561]         }
[16:13:04.561]         else {
[16:13:04.561]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:04.561]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:04.561]         }
[16:13:04.561]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:04.561]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:04.561]             base::sink(type = "output", split = FALSE)
[16:13:04.561]             base::close(...future.stdout)
[16:13:04.561]         }, add = TRUE)
[16:13:04.561]     }
[16:13:04.561]     ...future.frame <- base::sys.nframe()
[16:13:04.561]     ...future.conditions <- base::list()
[16:13:04.561]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:04.561]     if (FALSE) {
[16:13:04.561]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:04.561]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:04.561]     }
[16:13:04.561]     ...future.result <- base::tryCatch({
[16:13:04.561]         base::withCallingHandlers({
[16:13:04.561]             ...future.value <- base::withVisible(base::local({
[16:13:04.561]                 withCallingHandlers({
[16:13:04.561]                   {
[16:13:04.561]                     42L
[16:13:04.561]                   }
[16:13:04.561]                 }, immediateCondition = function(cond) {
[16:13:04.561]                   save_rds <- function (object, pathname, ...) 
[16:13:04.561]                   {
[16:13:04.561]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:04.561]                     if (file_test("-f", pathname_tmp)) {
[16:13:04.561]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.561]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:04.561]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.561]                         fi_tmp[["mtime"]])
[16:13:04.561]                     }
[16:13:04.561]                     tryCatch({
[16:13:04.561]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:04.561]                     }, error = function(ex) {
[16:13:04.561]                       msg <- conditionMessage(ex)
[16:13:04.561]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.561]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:04.561]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.561]                         fi_tmp[["mtime"]], msg)
[16:13:04.561]                       ex$message <- msg
[16:13:04.561]                       stop(ex)
[16:13:04.561]                     })
[16:13:04.561]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:04.561]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:04.561]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:04.561]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.561]                       fi <- file.info(pathname)
[16:13:04.561]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:04.561]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.561]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:04.561]                         fi[["size"]], fi[["mtime"]])
[16:13:04.561]                       stop(msg)
[16:13:04.561]                     }
[16:13:04.561]                     invisible(pathname)
[16:13:04.561]                   }
[16:13:04.561]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:04.561]                     rootPath = tempdir()) 
[16:13:04.561]                   {
[16:13:04.561]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:04.561]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:04.561]                       tmpdir = path, fileext = ".rds")
[16:13:04.561]                     save_rds(obj, file)
[16:13:04.561]                   }
[16:13:04.561]                   saveImmediateCondition(cond, path = "/tmp/RtmpmgpgJ1/.future/immediateConditions")
[16:13:04.561]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.561]                   {
[16:13:04.561]                     inherits <- base::inherits
[16:13:04.561]                     invokeRestart <- base::invokeRestart
[16:13:04.561]                     is.null <- base::is.null
[16:13:04.561]                     muffled <- FALSE
[16:13:04.561]                     if (inherits(cond, "message")) {
[16:13:04.561]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:04.561]                       if (muffled) 
[16:13:04.561]                         invokeRestart("muffleMessage")
[16:13:04.561]                     }
[16:13:04.561]                     else if (inherits(cond, "warning")) {
[16:13:04.561]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:04.561]                       if (muffled) 
[16:13:04.561]                         invokeRestart("muffleWarning")
[16:13:04.561]                     }
[16:13:04.561]                     else if (inherits(cond, "condition")) {
[16:13:04.561]                       if (!is.null(pattern)) {
[16:13:04.561]                         computeRestarts <- base::computeRestarts
[16:13:04.561]                         grepl <- base::grepl
[16:13:04.561]                         restarts <- computeRestarts(cond)
[16:13:04.561]                         for (restart in restarts) {
[16:13:04.561]                           name <- restart$name
[16:13:04.561]                           if (is.null(name)) 
[16:13:04.561]                             next
[16:13:04.561]                           if (!grepl(pattern, name)) 
[16:13:04.561]                             next
[16:13:04.561]                           invokeRestart(restart)
[16:13:04.561]                           muffled <- TRUE
[16:13:04.561]                           break
[16:13:04.561]                         }
[16:13:04.561]                       }
[16:13:04.561]                     }
[16:13:04.561]                     invisible(muffled)
[16:13:04.561]                   }
[16:13:04.561]                   muffleCondition(cond)
[16:13:04.561]                 })
[16:13:04.561]             }))
[16:13:04.561]             future::FutureResult(value = ...future.value$value, 
[16:13:04.561]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.561]                   ...future.rng), globalenv = if (FALSE) 
[16:13:04.561]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:04.561]                     ...future.globalenv.names))
[16:13:04.561]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:04.561]         }, condition = base::local({
[16:13:04.561]             c <- base::c
[16:13:04.561]             inherits <- base::inherits
[16:13:04.561]             invokeRestart <- base::invokeRestart
[16:13:04.561]             length <- base::length
[16:13:04.561]             list <- base::list
[16:13:04.561]             seq.int <- base::seq.int
[16:13:04.561]             signalCondition <- base::signalCondition
[16:13:04.561]             sys.calls <- base::sys.calls
[16:13:04.561]             `[[` <- base::`[[`
[16:13:04.561]             `+` <- base::`+`
[16:13:04.561]             `<<-` <- base::`<<-`
[16:13:04.561]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:04.561]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:04.561]                   3L)]
[16:13:04.561]             }
[16:13:04.561]             function(cond) {
[16:13:04.561]                 is_error <- inherits(cond, "error")
[16:13:04.561]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:04.561]                   NULL)
[16:13:04.561]                 if (is_error) {
[16:13:04.561]                   sessionInformation <- function() {
[16:13:04.561]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:04.561]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:04.561]                       search = base::search(), system = base::Sys.info())
[16:13:04.561]                   }
[16:13:04.561]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.561]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:04.561]                     cond$call), session = sessionInformation(), 
[16:13:04.561]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:04.561]                   signalCondition(cond)
[16:13:04.561]                 }
[16:13:04.561]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:04.561]                 "immediateCondition"))) {
[16:13:04.561]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:04.561]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.561]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:04.561]                   if (TRUE && !signal) {
[16:13:04.561]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.561]                     {
[16:13:04.561]                       inherits <- base::inherits
[16:13:04.561]                       invokeRestart <- base::invokeRestart
[16:13:04.561]                       is.null <- base::is.null
[16:13:04.561]                       muffled <- FALSE
[16:13:04.561]                       if (inherits(cond, "message")) {
[16:13:04.561]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.561]                         if (muffled) 
[16:13:04.561]                           invokeRestart("muffleMessage")
[16:13:04.561]                       }
[16:13:04.561]                       else if (inherits(cond, "warning")) {
[16:13:04.561]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.561]                         if (muffled) 
[16:13:04.561]                           invokeRestart("muffleWarning")
[16:13:04.561]                       }
[16:13:04.561]                       else if (inherits(cond, "condition")) {
[16:13:04.561]                         if (!is.null(pattern)) {
[16:13:04.561]                           computeRestarts <- base::computeRestarts
[16:13:04.561]                           grepl <- base::grepl
[16:13:04.561]                           restarts <- computeRestarts(cond)
[16:13:04.561]                           for (restart in restarts) {
[16:13:04.561]                             name <- restart$name
[16:13:04.561]                             if (is.null(name)) 
[16:13:04.561]                               next
[16:13:04.561]                             if (!grepl(pattern, name)) 
[16:13:04.561]                               next
[16:13:04.561]                             invokeRestart(restart)
[16:13:04.561]                             muffled <- TRUE
[16:13:04.561]                             break
[16:13:04.561]                           }
[16:13:04.561]                         }
[16:13:04.561]                       }
[16:13:04.561]                       invisible(muffled)
[16:13:04.561]                     }
[16:13:04.561]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.561]                   }
[16:13:04.561]                 }
[16:13:04.561]                 else {
[16:13:04.561]                   if (TRUE) {
[16:13:04.561]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.561]                     {
[16:13:04.561]                       inherits <- base::inherits
[16:13:04.561]                       invokeRestart <- base::invokeRestart
[16:13:04.561]                       is.null <- base::is.null
[16:13:04.561]                       muffled <- FALSE
[16:13:04.561]                       if (inherits(cond, "message")) {
[16:13:04.561]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.561]                         if (muffled) 
[16:13:04.561]                           invokeRestart("muffleMessage")
[16:13:04.561]                       }
[16:13:04.561]                       else if (inherits(cond, "warning")) {
[16:13:04.561]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.561]                         if (muffled) 
[16:13:04.561]                           invokeRestart("muffleWarning")
[16:13:04.561]                       }
[16:13:04.561]                       else if (inherits(cond, "condition")) {
[16:13:04.561]                         if (!is.null(pattern)) {
[16:13:04.561]                           computeRestarts <- base::computeRestarts
[16:13:04.561]                           grepl <- base::grepl
[16:13:04.561]                           restarts <- computeRestarts(cond)
[16:13:04.561]                           for (restart in restarts) {
[16:13:04.561]                             name <- restart$name
[16:13:04.561]                             if (is.null(name)) 
[16:13:04.561]                               next
[16:13:04.561]                             if (!grepl(pattern, name)) 
[16:13:04.561]                               next
[16:13:04.561]                             invokeRestart(restart)
[16:13:04.561]                             muffled <- TRUE
[16:13:04.561]                             break
[16:13:04.561]                           }
[16:13:04.561]                         }
[16:13:04.561]                       }
[16:13:04.561]                       invisible(muffled)
[16:13:04.561]                     }
[16:13:04.561]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.561]                   }
[16:13:04.561]                 }
[16:13:04.561]             }
[16:13:04.561]         }))
[16:13:04.561]     }, error = function(ex) {
[16:13:04.561]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:04.561]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.561]                 ...future.rng), started = ...future.startTime, 
[16:13:04.561]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:04.561]             version = "1.8"), class = "FutureResult")
[16:13:04.561]     }, finally = {
[16:13:04.561]         if (!identical(...future.workdir, getwd())) 
[16:13:04.561]             setwd(...future.workdir)
[16:13:04.561]         {
[16:13:04.561]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:04.561]                 ...future.oldOptions$nwarnings <- NULL
[16:13:04.561]             }
[16:13:04.561]             base::options(...future.oldOptions)
[16:13:04.561]             if (.Platform$OS.type == "windows") {
[16:13:04.561]                 old_names <- names(...future.oldEnvVars)
[16:13:04.561]                 envs <- base::Sys.getenv()
[16:13:04.561]                 names <- names(envs)
[16:13:04.561]                 common <- intersect(names, old_names)
[16:13:04.561]                 added <- setdiff(names, old_names)
[16:13:04.561]                 removed <- setdiff(old_names, names)
[16:13:04.561]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:04.561]                   envs[common]]
[16:13:04.561]                 NAMES <- toupper(changed)
[16:13:04.561]                 args <- list()
[16:13:04.561]                 for (kk in seq_along(NAMES)) {
[16:13:04.561]                   name <- changed[[kk]]
[16:13:04.561]                   NAME <- NAMES[[kk]]
[16:13:04.561]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.561]                     next
[16:13:04.561]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.561]                 }
[16:13:04.561]                 NAMES <- toupper(added)
[16:13:04.561]                 for (kk in seq_along(NAMES)) {
[16:13:04.561]                   name <- added[[kk]]
[16:13:04.561]                   NAME <- NAMES[[kk]]
[16:13:04.561]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.561]                     next
[16:13:04.561]                   args[[name]] <- ""
[16:13:04.561]                 }
[16:13:04.561]                 NAMES <- toupper(removed)
[16:13:04.561]                 for (kk in seq_along(NAMES)) {
[16:13:04.561]                   name <- removed[[kk]]
[16:13:04.561]                   NAME <- NAMES[[kk]]
[16:13:04.561]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.561]                     next
[16:13:04.561]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.561]                 }
[16:13:04.561]                 if (length(args) > 0) 
[16:13:04.561]                   base::do.call(base::Sys.setenv, args = args)
[16:13:04.561]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:04.561]             }
[16:13:04.561]             else {
[16:13:04.561]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:04.561]             }
[16:13:04.561]             {
[16:13:04.561]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:04.561]                   0L) {
[16:13:04.561]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:04.561]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:04.561]                   base::options(opts)
[16:13:04.561]                 }
[16:13:04.561]                 {
[16:13:04.561]                   {
[16:13:04.561]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:04.561]                     NULL
[16:13:04.561]                   }
[16:13:04.561]                   options(future.plan = NULL)
[16:13:04.561]                   if (is.na(NA_character_)) 
[16:13:04.561]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.561]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:04.561]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:04.561]                     envir = parent.frame()) 
[16:13:04.561]                   {
[16:13:04.561]                     default_workers <- missing(workers)
[16:13:04.561]                     if (is.function(workers)) 
[16:13:04.561]                       workers <- workers()
[16:13:04.561]                     workers <- structure(as.integer(workers), 
[16:13:04.561]                       class = class(workers))
[16:13:04.561]                     stop_if_not(is.finite(workers), workers >= 
[16:13:04.561]                       1L)
[16:13:04.561]                     if ((workers == 1L && !inherits(workers, 
[16:13:04.561]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:04.561]                       if (default_workers) 
[16:13:04.561]                         supportsMulticore(warn = TRUE)
[16:13:04.561]                       return(sequential(..., envir = envir))
[16:13:04.561]                     }
[16:13:04.561]                     oopts <- options(mc.cores = workers)
[16:13:04.561]                     on.exit(options(oopts))
[16:13:04.561]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:04.561]                       envir = envir)
[16:13:04.561]                     if (!future$lazy) 
[16:13:04.561]                       future <- run(future)
[16:13:04.561]                     invisible(future)
[16:13:04.561]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:04.561]                 }
[16:13:04.561]             }
[16:13:04.561]         }
[16:13:04.561]     })
[16:13:04.561]     if (TRUE) {
[16:13:04.561]         base::sink(type = "output", split = FALSE)
[16:13:04.561]         if (TRUE) {
[16:13:04.561]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:04.561]         }
[16:13:04.561]         else {
[16:13:04.561]             ...future.result["stdout"] <- base::list(NULL)
[16:13:04.561]         }
[16:13:04.561]         base::close(...future.stdout)
[16:13:04.561]         ...future.stdout <- NULL
[16:13:04.561]     }
[16:13:04.561]     ...future.result$conditions <- ...future.conditions
[16:13:04.561]     ...future.result$finished <- base::Sys.time()
[16:13:04.561]     ...future.result
[16:13:04.561] }
[16:13:04.564] requestCore(): workers = 2
[16:13:04.566] MulticoreFuture started
[16:13:04.567] plan(): Setting new future strategy stack:
[16:13:04.567] List of future strategies:
[16:13:04.567] 1. sequential:
[16:13:04.567]    - args: function (..., envir = parent.frame())
[16:13:04.567]    - tweaked: FALSE
[16:13:04.567]    - call: NULL
[16:13:04.568] plan(): nbrOfWorkers() = 1
[16:13:04.570] plan(): Setting new future strategy stack:
[16:13:04.570] List of future strategies:
[16:13:04.570] 1. multicore:
[16:13:04.570]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:04.570]    - tweaked: FALSE
[16:13:04.570]    - call: plan(multicore)
[16:13:04.575] plan(): nbrOfWorkers() = 2
[1] TRUE
[1] 42
*** multicore(..., globals = TRUE) with globals
[16:13:04.581] getGlobalsAndPackages() ...
[16:13:04.581] Searching for globals...
[16:13:04.583] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘a’
[16:13:04.584] Searching for globals ... DONE
[16:13:04.584] Resolving globals: FALSE
[16:13:04.584] The total size of the 1 globals is 56 bytes (56 bytes)
[16:13:04.585] The total size of the 1 globals exported for future expression (‘{; b <- 3; c <- 2; a * b * c; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:13:04.585] - globals: [1] ‘a’
[16:13:04.585] 
[16:13:04.585] getGlobalsAndPackages() ... DONE
[16:13:04.586] Packages needed by the future expression (n = 0): <none>
[16:13:04.586] Packages needed by future strategies (n = 0): <none>
[16:13:04.586] {
[16:13:04.586]     {
[16:13:04.586]         {
[16:13:04.586]             ...future.startTime <- base::Sys.time()
[16:13:04.586]             {
[16:13:04.586]                 {
[16:13:04.586]                   {
[16:13:04.586]                     {
[16:13:04.586]                       base::local({
[16:13:04.586]                         has_future <- base::requireNamespace("future", 
[16:13:04.586]                           quietly = TRUE)
[16:13:04.586]                         if (has_future) {
[16:13:04.586]                           ns <- base::getNamespace("future")
[16:13:04.586]                           version <- ns[[".package"]][["version"]]
[16:13:04.586]                           if (is.null(version)) 
[16:13:04.586]                             version <- utils::packageVersion("future")
[16:13:04.586]                         }
[16:13:04.586]                         else {
[16:13:04.586]                           version <- NULL
[16:13:04.586]                         }
[16:13:04.586]                         if (!has_future || version < "1.8.0") {
[16:13:04.586]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:04.586]                             "", base::R.version$version.string), 
[16:13:04.586]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:04.586]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:04.586]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:04.586]                               "release", "version")], collapse = " "), 
[16:13:04.586]                             hostname = base::Sys.info()[["nodename"]])
[16:13:04.586]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:04.586]                             info)
[16:13:04.586]                           info <- base::paste(info, collapse = "; ")
[16:13:04.586]                           if (!has_future) {
[16:13:04.586]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:04.586]                               info)
[16:13:04.586]                           }
[16:13:04.586]                           else {
[16:13:04.586]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:04.586]                               info, version)
[16:13:04.586]                           }
[16:13:04.586]                           base::stop(msg)
[16:13:04.586]                         }
[16:13:04.586]                       })
[16:13:04.586]                     }
[16:13:04.586]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:04.586]                     base::options(mc.cores = 1L)
[16:13:04.586]                   }
[16:13:04.586]                   options(future.plan = NULL)
[16:13:04.586]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.586]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:04.586]                 }
[16:13:04.586]                 ...future.workdir <- getwd()
[16:13:04.586]             }
[16:13:04.586]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:04.586]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:04.586]         }
[16:13:04.586]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:04.586]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:04.586]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:04.586]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:04.586]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:04.586]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:04.586]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:04.586]             base::names(...future.oldOptions))
[16:13:04.586]     }
[16:13:04.586]     if (FALSE) {
[16:13:04.586]     }
[16:13:04.586]     else {
[16:13:04.586]         if (TRUE) {
[16:13:04.586]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:04.586]                 open = "w")
[16:13:04.586]         }
[16:13:04.586]         else {
[16:13:04.586]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:04.586]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:04.586]         }
[16:13:04.586]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:04.586]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:04.586]             base::sink(type = "output", split = FALSE)
[16:13:04.586]             base::close(...future.stdout)
[16:13:04.586]         }, add = TRUE)
[16:13:04.586]     }
[16:13:04.586]     ...future.frame <- base::sys.nframe()
[16:13:04.586]     ...future.conditions <- base::list()
[16:13:04.586]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:04.586]     if (FALSE) {
[16:13:04.586]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:04.586]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:04.586]     }
[16:13:04.586]     ...future.result <- base::tryCatch({
[16:13:04.586]         base::withCallingHandlers({
[16:13:04.586]             ...future.value <- base::withVisible(base::local({
[16:13:04.586]                 withCallingHandlers({
[16:13:04.586]                   {
[16:13:04.586]                     b <- 3
[16:13:04.586]                     c <- 2
[16:13:04.586]                     a * b * c
[16:13:04.586]                   }
[16:13:04.586]                 }, immediateCondition = function(cond) {
[16:13:04.586]                   save_rds <- function (object, pathname, ...) 
[16:13:04.586]                   {
[16:13:04.586]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:04.586]                     if (file_test("-f", pathname_tmp)) {
[16:13:04.586]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.586]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:04.586]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.586]                         fi_tmp[["mtime"]])
[16:13:04.586]                     }
[16:13:04.586]                     tryCatch({
[16:13:04.586]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:04.586]                     }, error = function(ex) {
[16:13:04.586]                       msg <- conditionMessage(ex)
[16:13:04.586]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.586]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:04.586]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.586]                         fi_tmp[["mtime"]], msg)
[16:13:04.586]                       ex$message <- msg
[16:13:04.586]                       stop(ex)
[16:13:04.586]                     })
[16:13:04.586]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:04.586]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:04.586]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:04.586]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.586]                       fi <- file.info(pathname)
[16:13:04.586]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:04.586]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.586]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:04.586]                         fi[["size"]], fi[["mtime"]])
[16:13:04.586]                       stop(msg)
[16:13:04.586]                     }
[16:13:04.586]                     invisible(pathname)
[16:13:04.586]                   }
[16:13:04.586]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:04.586]                     rootPath = tempdir()) 
[16:13:04.586]                   {
[16:13:04.586]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:04.586]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:04.586]                       tmpdir = path, fileext = ".rds")
[16:13:04.586]                     save_rds(obj, file)
[16:13:04.586]                   }
[16:13:04.586]                   saveImmediateCondition(cond, path = "/tmp/RtmpmgpgJ1/.future/immediateConditions")
[16:13:04.586]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.586]                   {
[16:13:04.586]                     inherits <- base::inherits
[16:13:04.586]                     invokeRestart <- base::invokeRestart
[16:13:04.586]                     is.null <- base::is.null
[16:13:04.586]                     muffled <- FALSE
[16:13:04.586]                     if (inherits(cond, "message")) {
[16:13:04.586]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:04.586]                       if (muffled) 
[16:13:04.586]                         invokeRestart("muffleMessage")
[16:13:04.586]                     }
[16:13:04.586]                     else if (inherits(cond, "warning")) {
[16:13:04.586]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:04.586]                       if (muffled) 
[16:13:04.586]                         invokeRestart("muffleWarning")
[16:13:04.586]                     }
[16:13:04.586]                     else if (inherits(cond, "condition")) {
[16:13:04.586]                       if (!is.null(pattern)) {
[16:13:04.586]                         computeRestarts <- base::computeRestarts
[16:13:04.586]                         grepl <- base::grepl
[16:13:04.586]                         restarts <- computeRestarts(cond)
[16:13:04.586]                         for (restart in restarts) {
[16:13:04.586]                           name <- restart$name
[16:13:04.586]                           if (is.null(name)) 
[16:13:04.586]                             next
[16:13:04.586]                           if (!grepl(pattern, name)) 
[16:13:04.586]                             next
[16:13:04.586]                           invokeRestart(restart)
[16:13:04.586]                           muffled <- TRUE
[16:13:04.586]                           break
[16:13:04.586]                         }
[16:13:04.586]                       }
[16:13:04.586]                     }
[16:13:04.586]                     invisible(muffled)
[16:13:04.586]                   }
[16:13:04.586]                   muffleCondition(cond)
[16:13:04.586]                 })
[16:13:04.586]             }))
[16:13:04.586]             future::FutureResult(value = ...future.value$value, 
[16:13:04.586]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.586]                   ...future.rng), globalenv = if (FALSE) 
[16:13:04.586]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:04.586]                     ...future.globalenv.names))
[16:13:04.586]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:04.586]         }, condition = base::local({
[16:13:04.586]             c <- base::c
[16:13:04.586]             inherits <- base::inherits
[16:13:04.586]             invokeRestart <- base::invokeRestart
[16:13:04.586]             length <- base::length
[16:13:04.586]             list <- base::list
[16:13:04.586]             seq.int <- base::seq.int
[16:13:04.586]             signalCondition <- base::signalCondition
[16:13:04.586]             sys.calls <- base::sys.calls
[16:13:04.586]             `[[` <- base::`[[`
[16:13:04.586]             `+` <- base::`+`
[16:13:04.586]             `<<-` <- base::`<<-`
[16:13:04.586]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:04.586]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:04.586]                   3L)]
[16:13:04.586]             }
[16:13:04.586]             function(cond) {
[16:13:04.586]                 is_error <- inherits(cond, "error")
[16:13:04.586]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:04.586]                   NULL)
[16:13:04.586]                 if (is_error) {
[16:13:04.586]                   sessionInformation <- function() {
[16:13:04.586]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:04.586]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:04.586]                       search = base::search(), system = base::Sys.info())
[16:13:04.586]                   }
[16:13:04.586]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.586]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:04.586]                     cond$call), session = sessionInformation(), 
[16:13:04.586]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:04.586]                   signalCondition(cond)
[16:13:04.586]                 }
[16:13:04.586]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:04.586]                 "immediateCondition"))) {
[16:13:04.586]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:04.586]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.586]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:04.586]                   if (TRUE && !signal) {
[16:13:04.586]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.586]                     {
[16:13:04.586]                       inherits <- base::inherits
[16:13:04.586]                       invokeRestart <- base::invokeRestart
[16:13:04.586]                       is.null <- base::is.null
[16:13:04.586]                       muffled <- FALSE
[16:13:04.586]                       if (inherits(cond, "message")) {
[16:13:04.586]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.586]                         if (muffled) 
[16:13:04.586]                           invokeRestart("muffleMessage")
[16:13:04.586]                       }
[16:13:04.586]                       else if (inherits(cond, "warning")) {
[16:13:04.586]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.586]                         if (muffled) 
[16:13:04.586]                           invokeRestart("muffleWarning")
[16:13:04.586]                       }
[16:13:04.586]                       else if (inherits(cond, "condition")) {
[16:13:04.586]                         if (!is.null(pattern)) {
[16:13:04.586]                           computeRestarts <- base::computeRestarts
[16:13:04.586]                           grepl <- base::grepl
[16:13:04.586]                           restarts <- computeRestarts(cond)
[16:13:04.586]                           for (restart in restarts) {
[16:13:04.586]                             name <- restart$name
[16:13:04.586]                             if (is.null(name)) 
[16:13:04.586]                               next
[16:13:04.586]                             if (!grepl(pattern, name)) 
[16:13:04.586]                               next
[16:13:04.586]                             invokeRestart(restart)
[16:13:04.586]                             muffled <- TRUE
[16:13:04.586]                             break
[16:13:04.586]                           }
[16:13:04.586]                         }
[16:13:04.586]                       }
[16:13:04.586]                       invisible(muffled)
[16:13:04.586]                     }
[16:13:04.586]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.586]                   }
[16:13:04.586]                 }
[16:13:04.586]                 else {
[16:13:04.586]                   if (TRUE) {
[16:13:04.586]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.586]                     {
[16:13:04.586]                       inherits <- base::inherits
[16:13:04.586]                       invokeRestart <- base::invokeRestart
[16:13:04.586]                       is.null <- base::is.null
[16:13:04.586]                       muffled <- FALSE
[16:13:04.586]                       if (inherits(cond, "message")) {
[16:13:04.586]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.586]                         if (muffled) 
[16:13:04.586]                           invokeRestart("muffleMessage")
[16:13:04.586]                       }
[16:13:04.586]                       else if (inherits(cond, "warning")) {
[16:13:04.586]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.586]                         if (muffled) 
[16:13:04.586]                           invokeRestart("muffleWarning")
[16:13:04.586]                       }
[16:13:04.586]                       else if (inherits(cond, "condition")) {
[16:13:04.586]                         if (!is.null(pattern)) {
[16:13:04.586]                           computeRestarts <- base::computeRestarts
[16:13:04.586]                           grepl <- base::grepl
[16:13:04.586]                           restarts <- computeRestarts(cond)
[16:13:04.586]                           for (restart in restarts) {
[16:13:04.586]                             name <- restart$name
[16:13:04.586]                             if (is.null(name)) 
[16:13:04.586]                               next
[16:13:04.586]                             if (!grepl(pattern, name)) 
[16:13:04.586]                               next
[16:13:04.586]                             invokeRestart(restart)
[16:13:04.586]                             muffled <- TRUE
[16:13:04.586]                             break
[16:13:04.586]                           }
[16:13:04.586]                         }
[16:13:04.586]                       }
[16:13:04.586]                       invisible(muffled)
[16:13:04.586]                     }
[16:13:04.586]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.586]                   }
[16:13:04.586]                 }
[16:13:04.586]             }
[16:13:04.586]         }))
[16:13:04.586]     }, error = function(ex) {
[16:13:04.586]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:04.586]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.586]                 ...future.rng), started = ...future.startTime, 
[16:13:04.586]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:04.586]             version = "1.8"), class = "FutureResult")
[16:13:04.586]     }, finally = {
[16:13:04.586]         if (!identical(...future.workdir, getwd())) 
[16:13:04.586]             setwd(...future.workdir)
[16:13:04.586]         {
[16:13:04.586]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:04.586]                 ...future.oldOptions$nwarnings <- NULL
[16:13:04.586]             }
[16:13:04.586]             base::options(...future.oldOptions)
[16:13:04.586]             if (.Platform$OS.type == "windows") {
[16:13:04.586]                 old_names <- names(...future.oldEnvVars)
[16:13:04.586]                 envs <- base::Sys.getenv()
[16:13:04.586]                 names <- names(envs)
[16:13:04.586]                 common <- intersect(names, old_names)
[16:13:04.586]                 added <- setdiff(names, old_names)
[16:13:04.586]                 removed <- setdiff(old_names, names)
[16:13:04.586]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:04.586]                   envs[common]]
[16:13:04.586]                 NAMES <- toupper(changed)
[16:13:04.586]                 args <- list()
[16:13:04.586]                 for (kk in seq_along(NAMES)) {
[16:13:04.586]                   name <- changed[[kk]]
[16:13:04.586]                   NAME <- NAMES[[kk]]
[16:13:04.586]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.586]                     next
[16:13:04.586]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.586]                 }
[16:13:04.586]                 NAMES <- toupper(added)
[16:13:04.586]                 for (kk in seq_along(NAMES)) {
[16:13:04.586]                   name <- added[[kk]]
[16:13:04.586]                   NAME <- NAMES[[kk]]
[16:13:04.586]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.586]                     next
[16:13:04.586]                   args[[name]] <- ""
[16:13:04.586]                 }
[16:13:04.586]                 NAMES <- toupper(removed)
[16:13:04.586]                 for (kk in seq_along(NAMES)) {
[16:13:04.586]                   name <- removed[[kk]]
[16:13:04.586]                   NAME <- NAMES[[kk]]
[16:13:04.586]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.586]                     next
[16:13:04.586]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.586]                 }
[16:13:04.586]                 if (length(args) > 0) 
[16:13:04.586]                   base::do.call(base::Sys.setenv, args = args)
[16:13:04.586]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:04.586]             }
[16:13:04.586]             else {
[16:13:04.586]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:04.586]             }
[16:13:04.586]             {
[16:13:04.586]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:04.586]                   0L) {
[16:13:04.586]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:04.586]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:04.586]                   base::options(opts)
[16:13:04.586]                 }
[16:13:04.586]                 {
[16:13:04.586]                   {
[16:13:04.586]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:04.586]                     NULL
[16:13:04.586]                   }
[16:13:04.586]                   options(future.plan = NULL)
[16:13:04.586]                   if (is.na(NA_character_)) 
[16:13:04.586]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.586]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:04.586]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:04.586]                     envir = parent.frame()) 
[16:13:04.586]                   {
[16:13:04.586]                     default_workers <- missing(workers)
[16:13:04.586]                     if (is.function(workers)) 
[16:13:04.586]                       workers <- workers()
[16:13:04.586]                     workers <- structure(as.integer(workers), 
[16:13:04.586]                       class = class(workers))
[16:13:04.586]                     stop_if_not(is.finite(workers), workers >= 
[16:13:04.586]                       1L)
[16:13:04.586]                     if ((workers == 1L && !inherits(workers, 
[16:13:04.586]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:04.586]                       if (default_workers) 
[16:13:04.586]                         supportsMulticore(warn = TRUE)
[16:13:04.586]                       return(sequential(..., envir = envir))
[16:13:04.586]                     }
[16:13:04.586]                     oopts <- options(mc.cores = workers)
[16:13:04.586]                     on.exit(options(oopts))
[16:13:04.586]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:04.586]                       envir = envir)
[16:13:04.586]                     if (!future$lazy) 
[16:13:04.586]                       future <- run(future)
[16:13:04.586]                     invisible(future)
[16:13:04.586]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:04.586]                 }
[16:13:04.586]             }
[16:13:04.586]         }
[16:13:04.586]     })
[16:13:04.586]     if (TRUE) {
[16:13:04.586]         base::sink(type = "output", split = FALSE)
[16:13:04.586]         if (TRUE) {
[16:13:04.586]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:04.586]         }
[16:13:04.586]         else {
[16:13:04.586]             ...future.result["stdout"] <- base::list(NULL)
[16:13:04.586]         }
[16:13:04.586]         base::close(...future.stdout)
[16:13:04.586]         ...future.stdout <- NULL
[16:13:04.586]     }
[16:13:04.586]     ...future.result$conditions <- ...future.conditions
[16:13:04.586]     ...future.result$finished <- base::Sys.time()
[16:13:04.586]     ...future.result
[16:13:04.586] }
[16:13:04.589] assign_globals() ...
[16:13:04.589] List of 1
[16:13:04.589]  $ a: num 0
[16:13:04.589]  - attr(*, "where")=List of 1
[16:13:04.589]   ..$ a:<environment: R_EmptyEnv> 
[16:13:04.589]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:04.589]  - attr(*, "resolved")= logi FALSE
[16:13:04.589]  - attr(*, "total_size")= num 56
[16:13:04.595] - copied ‘a’ to environment
[16:13:04.595] assign_globals() ... done
[16:13:04.595] requestCore(): workers = 2
[16:13:04.597] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:13:04.599] plan(): Setting new future strategy stack:
Globals: 1 objects totaling 56 bytes (numeric ‘a’ of 56 bytes)
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:13:04.599] List of future strategies:
[16:13:04.599] 1. sequential:
[16:13:04.599]    - args: function (..., envir = parent.frame())
[16:13:04.599]    - tweaked: FALSE
[16:13:04.599]    - call: NULL
[16:13:04.600] plan(): nbrOfWorkers() = 1
[16:13:04.602] plan(): Setting new future strategy stack:
[16:13:04.602] List of future strategies:
[16:13:04.602] 1. multicore:
[16:13:04.602]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:04.602]    - tweaked: FALSE
[16:13:04.602]    - call: plan(multicore)
[16:13:04.607] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 9cd5072f-68f7-e4f0-6d65-cff53a745767
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[1] 0
*** multicore(..., globals = TRUE) with globals and blocking
 - Creating multicore future #1 ...
[16:13:04.613] getGlobalsAndPackages() ...
[16:13:04.613] Searching for globals...
[16:13:04.614] - globals found: [2] ‘{’, ‘ii’
[16:13:04.615] Searching for globals ... DONE
[16:13:04.615] Resolving globals: FALSE
[16:13:04.615] The total size of the 1 globals is 56 bytes (56 bytes)
[16:13:04.616] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:13:04.616] - globals: [1] ‘ii’
[16:13:04.616] 
[16:13:04.616] getGlobalsAndPackages() ... DONE
[16:13:04.617] Packages needed by the future expression (n = 0): <none>
[16:13:04.617] Packages needed by future strategies (n = 0): <none>
[16:13:04.617] {
[16:13:04.617]     {
[16:13:04.617]         {
[16:13:04.617]             ...future.startTime <- base::Sys.time()
[16:13:04.617]             {
[16:13:04.617]                 {
[16:13:04.617]                   {
[16:13:04.617]                     {
[16:13:04.617]                       base::local({
[16:13:04.617]                         has_future <- base::requireNamespace("future", 
[16:13:04.617]                           quietly = TRUE)
[16:13:04.617]                         if (has_future) {
[16:13:04.617]                           ns <- base::getNamespace("future")
[16:13:04.617]                           version <- ns[[".package"]][["version"]]
[16:13:04.617]                           if (is.null(version)) 
[16:13:04.617]                             version <- utils::packageVersion("future")
[16:13:04.617]                         }
[16:13:04.617]                         else {
[16:13:04.617]                           version <- NULL
[16:13:04.617]                         }
[16:13:04.617]                         if (!has_future || version < "1.8.0") {
[16:13:04.617]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:04.617]                             "", base::R.version$version.string), 
[16:13:04.617]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:04.617]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:04.617]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:04.617]                               "release", "version")], collapse = " "), 
[16:13:04.617]                             hostname = base::Sys.info()[["nodename"]])
[16:13:04.617]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:04.617]                             info)
[16:13:04.617]                           info <- base::paste(info, collapse = "; ")
[16:13:04.617]                           if (!has_future) {
[16:13:04.617]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:04.617]                               info)
[16:13:04.617]                           }
[16:13:04.617]                           else {
[16:13:04.617]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:04.617]                               info, version)
[16:13:04.617]                           }
[16:13:04.617]                           base::stop(msg)
[16:13:04.617]                         }
[16:13:04.617]                       })
[16:13:04.617]                     }
[16:13:04.617]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:04.617]                     base::options(mc.cores = 1L)
[16:13:04.617]                   }
[16:13:04.617]                   options(future.plan = NULL)
[16:13:04.617]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.617]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:04.617]                 }
[16:13:04.617]                 ...future.workdir <- getwd()
[16:13:04.617]             }
[16:13:04.617]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:04.617]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:04.617]         }
[16:13:04.617]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:04.617]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:04.617]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:04.617]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:04.617]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:04.617]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:04.617]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:04.617]             base::names(...future.oldOptions))
[16:13:04.617]     }
[16:13:04.617]     if (FALSE) {
[16:13:04.617]     }
[16:13:04.617]     else {
[16:13:04.617]         if (TRUE) {
[16:13:04.617]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:04.617]                 open = "w")
[16:13:04.617]         }
[16:13:04.617]         else {
[16:13:04.617]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:04.617]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:04.617]         }
[16:13:04.617]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:04.617]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:04.617]             base::sink(type = "output", split = FALSE)
[16:13:04.617]             base::close(...future.stdout)
[16:13:04.617]         }, add = TRUE)
[16:13:04.617]     }
[16:13:04.617]     ...future.frame <- base::sys.nframe()
[16:13:04.617]     ...future.conditions <- base::list()
[16:13:04.617]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:04.617]     if (FALSE) {
[16:13:04.617]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:04.617]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:04.617]     }
[16:13:04.617]     ...future.result <- base::tryCatch({
[16:13:04.617]         base::withCallingHandlers({
[16:13:04.617]             ...future.value <- base::withVisible(base::local({
[16:13:04.617]                 withCallingHandlers({
[16:13:04.617]                   {
[16:13:04.617]                     ii
[16:13:04.617]                   }
[16:13:04.617]                 }, immediateCondition = function(cond) {
[16:13:04.617]                   save_rds <- function (object, pathname, ...) 
[16:13:04.617]                   {
[16:13:04.617]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:04.617]                     if (file_test("-f", pathname_tmp)) {
[16:13:04.617]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.617]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:04.617]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.617]                         fi_tmp[["mtime"]])
[16:13:04.617]                     }
[16:13:04.617]                     tryCatch({
[16:13:04.617]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:04.617]                     }, error = function(ex) {
[16:13:04.617]                       msg <- conditionMessage(ex)
[16:13:04.617]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.617]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:04.617]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.617]                         fi_tmp[["mtime"]], msg)
[16:13:04.617]                       ex$message <- msg
[16:13:04.617]                       stop(ex)
[16:13:04.617]                     })
[16:13:04.617]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:04.617]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:04.617]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:04.617]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.617]                       fi <- file.info(pathname)
[16:13:04.617]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:04.617]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.617]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:04.617]                         fi[["size"]], fi[["mtime"]])
[16:13:04.617]                       stop(msg)
[16:13:04.617]                     }
[16:13:04.617]                     invisible(pathname)
[16:13:04.617]                   }
[16:13:04.617]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:04.617]                     rootPath = tempdir()) 
[16:13:04.617]                   {
[16:13:04.617]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:04.617]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:04.617]                       tmpdir = path, fileext = ".rds")
[16:13:04.617]                     save_rds(obj, file)
[16:13:04.617]                   }
[16:13:04.617]                   saveImmediateCondition(cond, path = "/tmp/RtmpmgpgJ1/.future/immediateConditions")
[16:13:04.617]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.617]                   {
[16:13:04.617]                     inherits <- base::inherits
[16:13:04.617]                     invokeRestart <- base::invokeRestart
[16:13:04.617]                     is.null <- base::is.null
[16:13:04.617]                     muffled <- FALSE
[16:13:04.617]                     if (inherits(cond, "message")) {
[16:13:04.617]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:04.617]                       if (muffled) 
[16:13:04.617]                         invokeRestart("muffleMessage")
[16:13:04.617]                     }
[16:13:04.617]                     else if (inherits(cond, "warning")) {
[16:13:04.617]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:04.617]                       if (muffled) 
[16:13:04.617]                         invokeRestart("muffleWarning")
[16:13:04.617]                     }
[16:13:04.617]                     else if (inherits(cond, "condition")) {
[16:13:04.617]                       if (!is.null(pattern)) {
[16:13:04.617]                         computeRestarts <- base::computeRestarts
[16:13:04.617]                         grepl <- base::grepl
[16:13:04.617]                         restarts <- computeRestarts(cond)
[16:13:04.617]                         for (restart in restarts) {
[16:13:04.617]                           name <- restart$name
[16:13:04.617]                           if (is.null(name)) 
[16:13:04.617]                             next
[16:13:04.617]                           if (!grepl(pattern, name)) 
[16:13:04.617]                             next
[16:13:04.617]                           invokeRestart(restart)
[16:13:04.617]                           muffled <- TRUE
[16:13:04.617]                           break
[16:13:04.617]                         }
[16:13:04.617]                       }
[16:13:04.617]                     }
[16:13:04.617]                     invisible(muffled)
[16:13:04.617]                   }
[16:13:04.617]                   muffleCondition(cond)
[16:13:04.617]                 })
[16:13:04.617]             }))
[16:13:04.617]             future::FutureResult(value = ...future.value$value, 
[16:13:04.617]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.617]                   ...future.rng), globalenv = if (FALSE) 
[16:13:04.617]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:04.617]                     ...future.globalenv.names))
[16:13:04.617]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:04.617]         }, condition = base::local({
[16:13:04.617]             c <- base::c
[16:13:04.617]             inherits <- base::inherits
[16:13:04.617]             invokeRestart <- base::invokeRestart
[16:13:04.617]             length <- base::length
[16:13:04.617]             list <- base::list
[16:13:04.617]             seq.int <- base::seq.int
[16:13:04.617]             signalCondition <- base::signalCondition
[16:13:04.617]             sys.calls <- base::sys.calls
[16:13:04.617]             `[[` <- base::`[[`
[16:13:04.617]             `+` <- base::`+`
[16:13:04.617]             `<<-` <- base::`<<-`
[16:13:04.617]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:04.617]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:04.617]                   3L)]
[16:13:04.617]             }
[16:13:04.617]             function(cond) {
[16:13:04.617]                 is_error <- inherits(cond, "error")
[16:13:04.617]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:04.617]                   NULL)
[16:13:04.617]                 if (is_error) {
[16:13:04.617]                   sessionInformation <- function() {
[16:13:04.617]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:04.617]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:04.617]                       search = base::search(), system = base::Sys.info())
[16:13:04.617]                   }
[16:13:04.617]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.617]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:04.617]                     cond$call), session = sessionInformation(), 
[16:13:04.617]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:04.617]                   signalCondition(cond)
[16:13:04.617]                 }
[16:13:04.617]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:04.617]                 "immediateCondition"))) {
[16:13:04.617]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:04.617]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.617]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:04.617]                   if (TRUE && !signal) {
[16:13:04.617]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.617]                     {
[16:13:04.617]                       inherits <- base::inherits
[16:13:04.617]                       invokeRestart <- base::invokeRestart
[16:13:04.617]                       is.null <- base::is.null
[16:13:04.617]                       muffled <- FALSE
[16:13:04.617]                       if (inherits(cond, "message")) {
[16:13:04.617]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.617]                         if (muffled) 
[16:13:04.617]                           invokeRestart("muffleMessage")
[16:13:04.617]                       }
[16:13:04.617]                       else if (inherits(cond, "warning")) {
[16:13:04.617]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.617]                         if (muffled) 
[16:13:04.617]                           invokeRestart("muffleWarning")
[16:13:04.617]                       }
[16:13:04.617]                       else if (inherits(cond, "condition")) {
[16:13:04.617]                         if (!is.null(pattern)) {
[16:13:04.617]                           computeRestarts <- base::computeRestarts
[16:13:04.617]                           grepl <- base::grepl
[16:13:04.617]                           restarts <- computeRestarts(cond)
[16:13:04.617]                           for (restart in restarts) {
[16:13:04.617]                             name <- restart$name
[16:13:04.617]                             if (is.null(name)) 
[16:13:04.617]                               next
[16:13:04.617]                             if (!grepl(pattern, name)) 
[16:13:04.617]                               next
[16:13:04.617]                             invokeRestart(restart)
[16:13:04.617]                             muffled <- TRUE
[16:13:04.617]                             break
[16:13:04.617]                           }
[16:13:04.617]                         }
[16:13:04.617]                       }
[16:13:04.617]                       invisible(muffled)
[16:13:04.617]                     }
[16:13:04.617]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.617]                   }
[16:13:04.617]                 }
[16:13:04.617]                 else {
[16:13:04.617]                   if (TRUE) {
[16:13:04.617]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.617]                     {
[16:13:04.617]                       inherits <- base::inherits
[16:13:04.617]                       invokeRestart <- base::invokeRestart
[16:13:04.617]                       is.null <- base::is.null
[16:13:04.617]                       muffled <- FALSE
[16:13:04.617]                       if (inherits(cond, "message")) {
[16:13:04.617]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.617]                         if (muffled) 
[16:13:04.617]                           invokeRestart("muffleMessage")
[16:13:04.617]                       }
[16:13:04.617]                       else if (inherits(cond, "warning")) {
[16:13:04.617]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.617]                         if (muffled) 
[16:13:04.617]                           invokeRestart("muffleWarning")
[16:13:04.617]                       }
[16:13:04.617]                       else if (inherits(cond, "condition")) {
[16:13:04.617]                         if (!is.null(pattern)) {
[16:13:04.617]                           computeRestarts <- base::computeRestarts
[16:13:04.617]                           grepl <- base::grepl
[16:13:04.617]                           restarts <- computeRestarts(cond)
[16:13:04.617]                           for (restart in restarts) {
[16:13:04.617]                             name <- restart$name
[16:13:04.617]                             if (is.null(name)) 
[16:13:04.617]                               next
[16:13:04.617]                             if (!grepl(pattern, name)) 
[16:13:04.617]                               next
[16:13:04.617]                             invokeRestart(restart)
[16:13:04.617]                             muffled <- TRUE
[16:13:04.617]                             break
[16:13:04.617]                           }
[16:13:04.617]                         }
[16:13:04.617]                       }
[16:13:04.617]                       invisible(muffled)
[16:13:04.617]                     }
[16:13:04.617]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.617]                   }
[16:13:04.617]                 }
[16:13:04.617]             }
[16:13:04.617]         }))
[16:13:04.617]     }, error = function(ex) {
[16:13:04.617]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:04.617]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.617]                 ...future.rng), started = ...future.startTime, 
[16:13:04.617]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:04.617]             version = "1.8"), class = "FutureResult")
[16:13:04.617]     }, finally = {
[16:13:04.617]         if (!identical(...future.workdir, getwd())) 
[16:13:04.617]             setwd(...future.workdir)
[16:13:04.617]         {
[16:13:04.617]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:04.617]                 ...future.oldOptions$nwarnings <- NULL
[16:13:04.617]             }
[16:13:04.617]             base::options(...future.oldOptions)
[16:13:04.617]             if (.Platform$OS.type == "windows") {
[16:13:04.617]                 old_names <- names(...future.oldEnvVars)
[16:13:04.617]                 envs <- base::Sys.getenv()
[16:13:04.617]                 names <- names(envs)
[16:13:04.617]                 common <- intersect(names, old_names)
[16:13:04.617]                 added <- setdiff(names, old_names)
[16:13:04.617]                 removed <- setdiff(old_names, names)
[16:13:04.617]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:04.617]                   envs[common]]
[16:13:04.617]                 NAMES <- toupper(changed)
[16:13:04.617]                 args <- list()
[16:13:04.617]                 for (kk in seq_along(NAMES)) {
[16:13:04.617]                   name <- changed[[kk]]
[16:13:04.617]                   NAME <- NAMES[[kk]]
[16:13:04.617]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.617]                     next
[16:13:04.617]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.617]                 }
[16:13:04.617]                 NAMES <- toupper(added)
[16:13:04.617]                 for (kk in seq_along(NAMES)) {
[16:13:04.617]                   name <- added[[kk]]
[16:13:04.617]                   NAME <- NAMES[[kk]]
[16:13:04.617]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.617]                     next
[16:13:04.617]                   args[[name]] <- ""
[16:13:04.617]                 }
[16:13:04.617]                 NAMES <- toupper(removed)
[16:13:04.617]                 for (kk in seq_along(NAMES)) {
[16:13:04.617]                   name <- removed[[kk]]
[16:13:04.617]                   NAME <- NAMES[[kk]]
[16:13:04.617]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.617]                     next
[16:13:04.617]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.617]                 }
[16:13:04.617]                 if (length(args) > 0) 
[16:13:04.617]                   base::do.call(base::Sys.setenv, args = args)
[16:13:04.617]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:04.617]             }
[16:13:04.617]             else {
[16:13:04.617]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:04.617]             }
[16:13:04.617]             {
[16:13:04.617]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:04.617]                   0L) {
[16:13:04.617]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:04.617]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:04.617]                   base::options(opts)
[16:13:04.617]                 }
[16:13:04.617]                 {
[16:13:04.617]                   {
[16:13:04.617]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:04.617]                     NULL
[16:13:04.617]                   }
[16:13:04.617]                   options(future.plan = NULL)
[16:13:04.617]                   if (is.na(NA_character_)) 
[16:13:04.617]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.617]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:04.617]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:04.617]                     envir = parent.frame()) 
[16:13:04.617]                   {
[16:13:04.617]                     default_workers <- missing(workers)
[16:13:04.617]                     if (is.function(workers)) 
[16:13:04.617]                       workers <- workers()
[16:13:04.617]                     workers <- structure(as.integer(workers), 
[16:13:04.617]                       class = class(workers))
[16:13:04.617]                     stop_if_not(is.finite(workers), workers >= 
[16:13:04.617]                       1L)
[16:13:04.617]                     if ((workers == 1L && !inherits(workers, 
[16:13:04.617]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:04.617]                       if (default_workers) 
[16:13:04.617]                         supportsMulticore(warn = TRUE)
[16:13:04.617]                       return(sequential(..., envir = envir))
[16:13:04.617]                     }
[16:13:04.617]                     oopts <- options(mc.cores = workers)
[16:13:04.617]                     on.exit(options(oopts))
[16:13:04.617]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:04.617]                       envir = envir)
[16:13:04.617]                     if (!future$lazy) 
[16:13:04.617]                       future <- run(future)
[16:13:04.617]                     invisible(future)
[16:13:04.617]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:04.617]                 }
[16:13:04.617]             }
[16:13:04.617]         }
[16:13:04.617]     })
[16:13:04.617]     if (TRUE) {
[16:13:04.617]         base::sink(type = "output", split = FALSE)
[16:13:04.617]         if (TRUE) {
[16:13:04.617]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:04.617]         }
[16:13:04.617]         else {
[16:13:04.617]             ...future.result["stdout"] <- base::list(NULL)
[16:13:04.617]         }
[16:13:04.617]         base::close(...future.stdout)
[16:13:04.617]         ...future.stdout <- NULL
[16:13:04.617]     }
[16:13:04.617]     ...future.result$conditions <- ...future.conditions
[16:13:04.617]     ...future.result$finished <- base::Sys.time()
[16:13:04.617]     ...future.result
[16:13:04.617] }
[16:13:04.620] assign_globals() ...
[16:13:04.620] List of 1
[16:13:04.620]  $ ii: int 1
[16:13:04.620]  - attr(*, "where")=List of 1
[16:13:04.620]   ..$ ii:<environment: R_EmptyEnv> 
[16:13:04.620]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:04.620]  - attr(*, "resolved")= logi FALSE
[16:13:04.620]  - attr(*, "total_size")= num 56
[16:13:04.623] - copied ‘ii’ to environment
[16:13:04.623] assign_globals() ... done
[16:13:04.623] requestCore(): workers = 2
[16:13:04.625] MulticoreFuture started
 - Creating multicore future #2 ...
[16:13:04.626] plan(): Setting new future strategy stack:
[16:13:04.626] List of future strategies:
[16:13:04.626] 1. sequential:
[16:13:04.626]    - args: function (..., envir = parent.frame())
[16:13:04.626]    - tweaked: FALSE
[16:13:04.626]    - call: NULL
[16:13:04.627] plan(): nbrOfWorkers() = 1
[16:13:04.629] plan(): Setting new future strategy stack:
[16:13:04.629] List of future strategies:
[16:13:04.629] 1. multicore:
[16:13:04.629]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:04.629]    - tweaked: FALSE
[16:13:04.629]    - call: plan(multicore)
[16:13:04.631] getGlobalsAndPackages() ...
[16:13:04.631] Searching for globals...
[16:13:04.633] - globals found: [2] ‘{’, ‘ii’
[16:13:04.633] Searching for globals ... DONE
[16:13:04.633] Resolving globals: FALSE
[16:13:04.634] The total size of the 1 globals is 56 bytes (56 bytes)
[16:13:04.635] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:13:04.635] - globals: [1] ‘ii’
[16:13:04.635] plan(): nbrOfWorkers() = 2
[16:13:04.635] 
[16:13:04.635] getGlobalsAndPackages() ... DONE
[16:13:04.636] Packages needed by the future expression (n = 0): <none>
[16:13:04.636] Packages needed by future strategies (n = 0): <none>
[16:13:04.637] {
[16:13:04.637]     {
[16:13:04.637]         {
[16:13:04.637]             ...future.startTime <- base::Sys.time()
[16:13:04.637]             {
[16:13:04.637]                 {
[16:13:04.637]                   {
[16:13:04.637]                     {
[16:13:04.637]                       base::local({
[16:13:04.637]                         has_future <- base::requireNamespace("future", 
[16:13:04.637]                           quietly = TRUE)
[16:13:04.637]                         if (has_future) {
[16:13:04.637]                           ns <- base::getNamespace("future")
[16:13:04.637]                           version <- ns[[".package"]][["version"]]
[16:13:04.637]                           if (is.null(version)) 
[16:13:04.637]                             version <- utils::packageVersion("future")
[16:13:04.637]                         }
[16:13:04.637]                         else {
[16:13:04.637]                           version <- NULL
[16:13:04.637]                         }
[16:13:04.637]                         if (!has_future || version < "1.8.0") {
[16:13:04.637]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:04.637]                             "", base::R.version$version.string), 
[16:13:04.637]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:04.637]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:04.637]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:04.637]                               "release", "version")], collapse = " "), 
[16:13:04.637]                             hostname = base::Sys.info()[["nodename"]])
[16:13:04.637]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:04.637]                             info)
[16:13:04.637]                           info <- base::paste(info, collapse = "; ")
[16:13:04.637]                           if (!has_future) {
[16:13:04.637]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:04.637]                               info)
[16:13:04.637]                           }
[16:13:04.637]                           else {
[16:13:04.637]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:04.637]                               info, version)
[16:13:04.637]                           }
[16:13:04.637]                           base::stop(msg)
[16:13:04.637]                         }
[16:13:04.637]                       })
[16:13:04.637]                     }
[16:13:04.637]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:04.637]                     base::options(mc.cores = 1L)
[16:13:04.637]                   }
[16:13:04.637]                   options(future.plan = NULL)
[16:13:04.637]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.637]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:04.637]                 }
[16:13:04.637]                 ...future.workdir <- getwd()
[16:13:04.637]             }
[16:13:04.637]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:04.637]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:04.637]         }
[16:13:04.637]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:04.637]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:04.637]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:04.637]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:04.637]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:04.637]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:04.637]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:04.637]             base::names(...future.oldOptions))
[16:13:04.637]     }
[16:13:04.637]     if (FALSE) {
[16:13:04.637]     }
[16:13:04.637]     else {
[16:13:04.637]         if (TRUE) {
[16:13:04.637]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:04.637]                 open = "w")
[16:13:04.637]         }
[16:13:04.637]         else {
[16:13:04.637]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:04.637]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:04.637]         }
[16:13:04.637]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:04.637]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:04.637]             base::sink(type = "output", split = FALSE)
[16:13:04.637]             base::close(...future.stdout)
[16:13:04.637]         }, add = TRUE)
[16:13:04.637]     }
[16:13:04.637]     ...future.frame <- base::sys.nframe()
[16:13:04.637]     ...future.conditions <- base::list()
[16:13:04.637]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:04.637]     if (FALSE) {
[16:13:04.637]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:04.637]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:04.637]     }
[16:13:04.637]     ...future.result <- base::tryCatch({
[16:13:04.637]         base::withCallingHandlers({
[16:13:04.637]             ...future.value <- base::withVisible(base::local({
[16:13:04.637]                 withCallingHandlers({
[16:13:04.637]                   {
[16:13:04.637]                     ii
[16:13:04.637]                   }
[16:13:04.637]                 }, immediateCondition = function(cond) {
[16:13:04.637]                   save_rds <- function (object, pathname, ...) 
[16:13:04.637]                   {
[16:13:04.637]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:04.637]                     if (file_test("-f", pathname_tmp)) {
[16:13:04.637]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.637]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:04.637]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.637]                         fi_tmp[["mtime"]])
[16:13:04.637]                     }
[16:13:04.637]                     tryCatch({
[16:13:04.637]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:04.637]                     }, error = function(ex) {
[16:13:04.637]                       msg <- conditionMessage(ex)
[16:13:04.637]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.637]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:04.637]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.637]                         fi_tmp[["mtime"]], msg)
[16:13:04.637]                       ex$message <- msg
[16:13:04.637]                       stop(ex)
[16:13:04.637]                     })
[16:13:04.637]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:04.637]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:04.637]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:04.637]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.637]                       fi <- file.info(pathname)
[16:13:04.637]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:04.637]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.637]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:04.637]                         fi[["size"]], fi[["mtime"]])
[16:13:04.637]                       stop(msg)
[16:13:04.637]                     }
[16:13:04.637]                     invisible(pathname)
[16:13:04.637]                   }
[16:13:04.637]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:04.637]                     rootPath = tempdir()) 
[16:13:04.637]                   {
[16:13:04.637]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:04.637]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:04.637]                       tmpdir = path, fileext = ".rds")
[16:13:04.637]                     save_rds(obj, file)
[16:13:04.637]                   }
[16:13:04.637]                   saveImmediateCondition(cond, path = "/tmp/RtmpmgpgJ1/.future/immediateConditions")
[16:13:04.637]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.637]                   {
[16:13:04.637]                     inherits <- base::inherits
[16:13:04.637]                     invokeRestart <- base::invokeRestart
[16:13:04.637]                     is.null <- base::is.null
[16:13:04.637]                     muffled <- FALSE
[16:13:04.637]                     if (inherits(cond, "message")) {
[16:13:04.637]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:04.637]                       if (muffled) 
[16:13:04.637]                         invokeRestart("muffleMessage")
[16:13:04.637]                     }
[16:13:04.637]                     else if (inherits(cond, "warning")) {
[16:13:04.637]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:04.637]                       if (muffled) 
[16:13:04.637]                         invokeRestart("muffleWarning")
[16:13:04.637]                     }
[16:13:04.637]                     else if (inherits(cond, "condition")) {
[16:13:04.637]                       if (!is.null(pattern)) {
[16:13:04.637]                         computeRestarts <- base::computeRestarts
[16:13:04.637]                         grepl <- base::grepl
[16:13:04.637]                         restarts <- computeRestarts(cond)
[16:13:04.637]                         for (restart in restarts) {
[16:13:04.637]                           name <- restart$name
[16:13:04.637]                           if (is.null(name)) 
[16:13:04.637]                             next
[16:13:04.637]                           if (!grepl(pattern, name)) 
[16:13:04.637]                             next
[16:13:04.637]                           invokeRestart(restart)
[16:13:04.637]                           muffled <- TRUE
[16:13:04.637]                           break
[16:13:04.637]                         }
[16:13:04.637]                       }
[16:13:04.637]                     }
[16:13:04.637]                     invisible(muffled)
[16:13:04.637]                   }
[16:13:04.637]                   muffleCondition(cond)
[16:13:04.637]                 })
[16:13:04.637]             }))
[16:13:04.637]             future::FutureResult(value = ...future.value$value, 
[16:13:04.637]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.637]                   ...future.rng), globalenv = if (FALSE) 
[16:13:04.637]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:04.637]                     ...future.globalenv.names))
[16:13:04.637]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:04.637]         }, condition = base::local({
[16:13:04.637]             c <- base::c
[16:13:04.637]             inherits <- base::inherits
[16:13:04.637]             invokeRestart <- base::invokeRestart
[16:13:04.637]             length <- base::length
[16:13:04.637]             list <- base::list
[16:13:04.637]             seq.int <- base::seq.int
[16:13:04.637]             signalCondition <- base::signalCondition
[16:13:04.637]             sys.calls <- base::sys.calls
[16:13:04.637]             `[[` <- base::`[[`
[16:13:04.637]             `+` <- base::`+`
[16:13:04.637]             `<<-` <- base::`<<-`
[16:13:04.637]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:04.637]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:04.637]                   3L)]
[16:13:04.637]             }
[16:13:04.637]             function(cond) {
[16:13:04.637]                 is_error <- inherits(cond, "error")
[16:13:04.637]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:04.637]                   NULL)
[16:13:04.637]                 if (is_error) {
[16:13:04.637]                   sessionInformation <- function() {
[16:13:04.637]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:04.637]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:04.637]                       search = base::search(), system = base::Sys.info())
[16:13:04.637]                   }
[16:13:04.637]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.637]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:04.637]                     cond$call), session = sessionInformation(), 
[16:13:04.637]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:04.637]                   signalCondition(cond)
[16:13:04.637]                 }
[16:13:04.637]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:04.637]                 "immediateCondition"))) {
[16:13:04.637]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:04.637]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.637]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:04.637]                   if (TRUE && !signal) {
[16:13:04.637]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.637]                     {
[16:13:04.637]                       inherits <- base::inherits
[16:13:04.637]                       invokeRestart <- base::invokeRestart
[16:13:04.637]                       is.null <- base::is.null
[16:13:04.637]                       muffled <- FALSE
[16:13:04.637]                       if (inherits(cond, "message")) {
[16:13:04.637]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.637]                         if (muffled) 
[16:13:04.637]                           invokeRestart("muffleMessage")
[16:13:04.637]                       }
[16:13:04.637]                       else if (inherits(cond, "warning")) {
[16:13:04.637]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.637]                         if (muffled) 
[16:13:04.637]                           invokeRestart("muffleWarning")
[16:13:04.637]                       }
[16:13:04.637]                       else if (inherits(cond, "condition")) {
[16:13:04.637]                         if (!is.null(pattern)) {
[16:13:04.637]                           computeRestarts <- base::computeRestarts
[16:13:04.637]                           grepl <- base::grepl
[16:13:04.637]                           restarts <- computeRestarts(cond)
[16:13:04.637]                           for (restart in restarts) {
[16:13:04.637]                             name <- restart$name
[16:13:04.637]                             if (is.null(name)) 
[16:13:04.637]                               next
[16:13:04.637]                             if (!grepl(pattern, name)) 
[16:13:04.637]                               next
[16:13:04.637]                             invokeRestart(restart)
[16:13:04.637]                             muffled <- TRUE
[16:13:04.637]                             break
[16:13:04.637]                           }
[16:13:04.637]                         }
[16:13:04.637]                       }
[16:13:04.637]                       invisible(muffled)
[16:13:04.637]                     }
[16:13:04.637]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.637]                   }
[16:13:04.637]                 }
[16:13:04.637]                 else {
[16:13:04.637]                   if (TRUE) {
[16:13:04.637]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.637]                     {
[16:13:04.637]                       inherits <- base::inherits
[16:13:04.637]                       invokeRestart <- base::invokeRestart
[16:13:04.637]                       is.null <- base::is.null
[16:13:04.637]                       muffled <- FALSE
[16:13:04.637]                       if (inherits(cond, "message")) {
[16:13:04.637]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.637]                         if (muffled) 
[16:13:04.637]                           invokeRestart("muffleMessage")
[16:13:04.637]                       }
[16:13:04.637]                       else if (inherits(cond, "warning")) {
[16:13:04.637]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.637]                         if (muffled) 
[16:13:04.637]                           invokeRestart("muffleWarning")
[16:13:04.637]                       }
[16:13:04.637]                       else if (inherits(cond, "condition")) {
[16:13:04.637]                         if (!is.null(pattern)) {
[16:13:04.637]                           computeRestarts <- base::computeRestarts
[16:13:04.637]                           grepl <- base::grepl
[16:13:04.637]                           restarts <- computeRestarts(cond)
[16:13:04.637]                           for (restart in restarts) {
[16:13:04.637]                             name <- restart$name
[16:13:04.637]                             if (is.null(name)) 
[16:13:04.637]                               next
[16:13:04.637]                             if (!grepl(pattern, name)) 
[16:13:04.637]                               next
[16:13:04.637]                             invokeRestart(restart)
[16:13:04.637]                             muffled <- TRUE
[16:13:04.637]                             break
[16:13:04.637]                           }
[16:13:04.637]                         }
[16:13:04.637]                       }
[16:13:04.637]                       invisible(muffled)
[16:13:04.637]                     }
[16:13:04.637]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.637]                   }
[16:13:04.637]                 }
[16:13:04.637]             }
[16:13:04.637]         }))
[16:13:04.637]     }, error = function(ex) {
[16:13:04.637]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:04.637]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.637]                 ...future.rng), started = ...future.startTime, 
[16:13:04.637]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:04.637]             version = "1.8"), class = "FutureResult")
[16:13:04.637]     }, finally = {
[16:13:04.637]         if (!identical(...future.workdir, getwd())) 
[16:13:04.637]             setwd(...future.workdir)
[16:13:04.637]         {
[16:13:04.637]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:04.637]                 ...future.oldOptions$nwarnings <- NULL
[16:13:04.637]             }
[16:13:04.637]             base::options(...future.oldOptions)
[16:13:04.637]             if (.Platform$OS.type == "windows") {
[16:13:04.637]                 old_names <- names(...future.oldEnvVars)
[16:13:04.637]                 envs <- base::Sys.getenv()
[16:13:04.637]                 names <- names(envs)
[16:13:04.637]                 common <- intersect(names, old_names)
[16:13:04.637]                 added <- setdiff(names, old_names)
[16:13:04.637]                 removed <- setdiff(old_names, names)
[16:13:04.637]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:04.637]                   envs[common]]
[16:13:04.637]                 NAMES <- toupper(changed)
[16:13:04.637]                 args <- list()
[16:13:04.637]                 for (kk in seq_along(NAMES)) {
[16:13:04.637]                   name <- changed[[kk]]
[16:13:04.637]                   NAME <- NAMES[[kk]]
[16:13:04.637]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.637]                     next
[16:13:04.637]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.637]                 }
[16:13:04.637]                 NAMES <- toupper(added)
[16:13:04.637]                 for (kk in seq_along(NAMES)) {
[16:13:04.637]                   name <- added[[kk]]
[16:13:04.637]                   NAME <- NAMES[[kk]]
[16:13:04.637]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.637]                     next
[16:13:04.637]                   args[[name]] <- ""
[16:13:04.637]                 }
[16:13:04.637]                 NAMES <- toupper(removed)
[16:13:04.637]                 for (kk in seq_along(NAMES)) {
[16:13:04.637]                   name <- removed[[kk]]
[16:13:04.637]                   NAME <- NAMES[[kk]]
[16:13:04.637]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.637]                     next
[16:13:04.637]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.637]                 }
[16:13:04.637]                 if (length(args) > 0) 
[16:13:04.637]                   base::do.call(base::Sys.setenv, args = args)
[16:13:04.637]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:04.637]             }
[16:13:04.637]             else {
[16:13:04.637]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:04.637]             }
[16:13:04.637]             {
[16:13:04.637]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:04.637]                   0L) {
[16:13:04.637]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:04.637]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:04.637]                   base::options(opts)
[16:13:04.637]                 }
[16:13:04.637]                 {
[16:13:04.637]                   {
[16:13:04.637]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:04.637]                     NULL
[16:13:04.637]                   }
[16:13:04.637]                   options(future.plan = NULL)
[16:13:04.637]                   if (is.na(NA_character_)) 
[16:13:04.637]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.637]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:04.637]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:04.637]                     envir = parent.frame()) 
[16:13:04.637]                   {
[16:13:04.637]                     default_workers <- missing(workers)
[16:13:04.637]                     if (is.function(workers)) 
[16:13:04.637]                       workers <- workers()
[16:13:04.637]                     workers <- structure(as.integer(workers), 
[16:13:04.637]                       class = class(workers))
[16:13:04.637]                     stop_if_not(is.finite(workers), workers >= 
[16:13:04.637]                       1L)
[16:13:04.637]                     if ((workers == 1L && !inherits(workers, 
[16:13:04.637]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:04.637]                       if (default_workers) 
[16:13:04.637]                         supportsMulticore(warn = TRUE)
[16:13:04.637]                       return(sequential(..., envir = envir))
[16:13:04.637]                     }
[16:13:04.637]                     oopts <- options(mc.cores = workers)
[16:13:04.637]                     on.exit(options(oopts))
[16:13:04.637]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:04.637]                       envir = envir)
[16:13:04.637]                     if (!future$lazy) 
[16:13:04.637]                       future <- run(future)
[16:13:04.637]                     invisible(future)
[16:13:04.637]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:04.637]                 }
[16:13:04.637]             }
[16:13:04.637]         }
[16:13:04.637]     })
[16:13:04.637]     if (TRUE) {
[16:13:04.637]         base::sink(type = "output", split = FALSE)
[16:13:04.637]         if (TRUE) {
[16:13:04.637]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:04.637]         }
[16:13:04.637]         else {
[16:13:04.637]             ...future.result["stdout"] <- base::list(NULL)
[16:13:04.637]         }
[16:13:04.637]         base::close(...future.stdout)
[16:13:04.637]         ...future.stdout <- NULL
[16:13:04.637]     }
[16:13:04.637]     ...future.result$conditions <- ...future.conditions
[16:13:04.637]     ...future.result$finished <- base::Sys.time()
[16:13:04.637]     ...future.result
[16:13:04.637] }
[16:13:04.640] assign_globals() ...
[16:13:04.640] List of 1
[16:13:04.640]  $ ii: int 2
[16:13:04.640]  - attr(*, "where")=List of 1
[16:13:04.640]   ..$ ii:<environment: R_EmptyEnv> 
[16:13:04.640]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:04.640]  - attr(*, "resolved")= logi FALSE
[16:13:04.640]  - attr(*, "total_size")= num 56
[16:13:04.644] - copied ‘ii’ to environment
[16:13:04.644] assign_globals() ... done
[16:13:04.644] requestCore(): workers = 2
[16:13:04.646] MulticoreFuture started
 - Creating multicore future #3 ...
[16:13:04.647] plan(): Setting new future strategy stack:
[16:13:04.647] List of future strategies:
[16:13:04.647] 1. sequential:
[16:13:04.647]    - args: function (..., envir = parent.frame())
[16:13:04.647]    - tweaked: FALSE
[16:13:04.647]    - call: NULL
[16:13:04.648] plan(): nbrOfWorkers() = 1
[16:13:04.650] plan(): Setting new future strategy stack:
[16:13:04.651] List of future strategies:
[16:13:04.651] 1. multicore:
[16:13:04.651]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:04.651]    - tweaked: FALSE
[16:13:04.651]    - call: plan(multicore)
[16:13:04.652] getGlobalsAndPackages() ...
[16:13:04.653] Searching for globals...
[16:13:04.654] - globals found: [2] ‘{’, ‘ii’
[16:13:04.654] Searching for globals ... DONE
[16:13:04.655] Resolving globals: FALSE
[16:13:04.655] The total size of the 1 globals is 56 bytes (56 bytes)
[16:13:04.656] plan(): nbrOfWorkers() = 2
[16:13:04.656] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:13:04.657] - globals: [1] ‘ii’
[16:13:04.657] 
[16:13:04.657] getGlobalsAndPackages() ... DONE
[16:13:04.661] Packages needed by the future expression (n = 0): <none>
[16:13:04.662] Packages needed by future strategies (n = 0): <none>
[16:13:04.662] {
[16:13:04.662]     {
[16:13:04.662]         {
[16:13:04.662]             ...future.startTime <- base::Sys.time()
[16:13:04.662]             {
[16:13:04.662]                 {
[16:13:04.662]                   {
[16:13:04.662]                     {
[16:13:04.662]                       base::local({
[16:13:04.662]                         has_future <- base::requireNamespace("future", 
[16:13:04.662]                           quietly = TRUE)
[16:13:04.662]                         if (has_future) {
[16:13:04.662]                           ns <- base::getNamespace("future")
[16:13:04.662]                           version <- ns[[".package"]][["version"]]
[16:13:04.662]                           if (is.null(version)) 
[16:13:04.662]                             version <- utils::packageVersion("future")
[16:13:04.662]                         }
[16:13:04.662]                         else {
[16:13:04.662]                           version <- NULL
[16:13:04.662]                         }
[16:13:04.662]                         if (!has_future || version < "1.8.0") {
[16:13:04.662]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:04.662]                             "", base::R.version$version.string), 
[16:13:04.662]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:04.662]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:04.662]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:04.662]                               "release", "version")], collapse = " "), 
[16:13:04.662]                             hostname = base::Sys.info()[["nodename"]])
[16:13:04.662]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:04.662]                             info)
[16:13:04.662]                           info <- base::paste(info, collapse = "; ")
[16:13:04.662]                           if (!has_future) {
[16:13:04.662]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:04.662]                               info)
[16:13:04.662]                           }
[16:13:04.662]                           else {
[16:13:04.662]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:04.662]                               info, version)
[16:13:04.662]                           }
[16:13:04.662]                           base::stop(msg)
[16:13:04.662]                         }
[16:13:04.662]                       })
[16:13:04.662]                     }
[16:13:04.662]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:04.662]                     base::options(mc.cores = 1L)
[16:13:04.662]                   }
[16:13:04.662]                   options(future.plan = NULL)
[16:13:04.662]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.662]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:04.662]                 }
[16:13:04.662]                 ...future.workdir <- getwd()
[16:13:04.662]             }
[16:13:04.662]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:04.662]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:04.662]         }
[16:13:04.662]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:04.662]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:04.662]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:04.662]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:04.662]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:04.662]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:04.662]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:04.662]             base::names(...future.oldOptions))
[16:13:04.662]     }
[16:13:04.662]     if (FALSE) {
[16:13:04.662]     }
[16:13:04.662]     else {
[16:13:04.662]         if (TRUE) {
[16:13:04.662]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:04.662]                 open = "w")
[16:13:04.662]         }
[16:13:04.662]         else {
[16:13:04.662]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:04.662]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:04.662]         }
[16:13:04.662]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:04.662]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:04.662]             base::sink(type = "output", split = FALSE)
[16:13:04.662]             base::close(...future.stdout)
[16:13:04.662]         }, add = TRUE)
[16:13:04.662]     }
[16:13:04.662]     ...future.frame <- base::sys.nframe()
[16:13:04.662]     ...future.conditions <- base::list()
[16:13:04.662]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:04.662]     if (FALSE) {
[16:13:04.662]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:04.662]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:04.662]     }
[16:13:04.662]     ...future.result <- base::tryCatch({
[16:13:04.662]         base::withCallingHandlers({
[16:13:04.662]             ...future.value <- base::withVisible(base::local({
[16:13:04.662]                 withCallingHandlers({
[16:13:04.662]                   {
[16:13:04.662]                     ii
[16:13:04.662]                   }
[16:13:04.662]                 }, immediateCondition = function(cond) {
[16:13:04.662]                   save_rds <- function (object, pathname, ...) 
[16:13:04.662]                   {
[16:13:04.662]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:04.662]                     if (file_test("-f", pathname_tmp)) {
[16:13:04.662]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.662]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:04.662]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.662]                         fi_tmp[["mtime"]])
[16:13:04.662]                     }
[16:13:04.662]                     tryCatch({
[16:13:04.662]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:04.662]                     }, error = function(ex) {
[16:13:04.662]                       msg <- conditionMessage(ex)
[16:13:04.662]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.662]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:04.662]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.662]                         fi_tmp[["mtime"]], msg)
[16:13:04.662]                       ex$message <- msg
[16:13:04.662]                       stop(ex)
[16:13:04.662]                     })
[16:13:04.662]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:04.662]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:04.662]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:04.662]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.662]                       fi <- file.info(pathname)
[16:13:04.662]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:04.662]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.662]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:04.662]                         fi[["size"]], fi[["mtime"]])
[16:13:04.662]                       stop(msg)
[16:13:04.662]                     }
[16:13:04.662]                     invisible(pathname)
[16:13:04.662]                   }
[16:13:04.662]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:04.662]                     rootPath = tempdir()) 
[16:13:04.662]                   {
[16:13:04.662]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:04.662]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:04.662]                       tmpdir = path, fileext = ".rds")
[16:13:04.662]                     save_rds(obj, file)
[16:13:04.662]                   }
[16:13:04.662]                   saveImmediateCondition(cond, path = "/tmp/RtmpmgpgJ1/.future/immediateConditions")
[16:13:04.662]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.662]                   {
[16:13:04.662]                     inherits <- base::inherits
[16:13:04.662]                     invokeRestart <- base::invokeRestart
[16:13:04.662]                     is.null <- base::is.null
[16:13:04.662]                     muffled <- FALSE
[16:13:04.662]                     if (inherits(cond, "message")) {
[16:13:04.662]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:04.662]                       if (muffled) 
[16:13:04.662]                         invokeRestart("muffleMessage")
[16:13:04.662]                     }
[16:13:04.662]                     else if (inherits(cond, "warning")) {
[16:13:04.662]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:04.662]                       if (muffled) 
[16:13:04.662]                         invokeRestart("muffleWarning")
[16:13:04.662]                     }
[16:13:04.662]                     else if (inherits(cond, "condition")) {
[16:13:04.662]                       if (!is.null(pattern)) {
[16:13:04.662]                         computeRestarts <- base::computeRestarts
[16:13:04.662]                         grepl <- base::grepl
[16:13:04.662]                         restarts <- computeRestarts(cond)
[16:13:04.662]                         for (restart in restarts) {
[16:13:04.662]                           name <- restart$name
[16:13:04.662]                           if (is.null(name)) 
[16:13:04.662]                             next
[16:13:04.662]                           if (!grepl(pattern, name)) 
[16:13:04.662]                             next
[16:13:04.662]                           invokeRestart(restart)
[16:13:04.662]                           muffled <- TRUE
[16:13:04.662]                           break
[16:13:04.662]                         }
[16:13:04.662]                       }
[16:13:04.662]                     }
[16:13:04.662]                     invisible(muffled)
[16:13:04.662]                   }
[16:13:04.662]                   muffleCondition(cond)
[16:13:04.662]                 })
[16:13:04.662]             }))
[16:13:04.662]             future::FutureResult(value = ...future.value$value, 
[16:13:04.662]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.662]                   ...future.rng), globalenv = if (FALSE) 
[16:13:04.662]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:04.662]                     ...future.globalenv.names))
[16:13:04.662]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:04.662]         }, condition = base::local({
[16:13:04.662]             c <- base::c
[16:13:04.662]             inherits <- base::inherits
[16:13:04.662]             invokeRestart <- base::invokeRestart
[16:13:04.662]             length <- base::length
[16:13:04.662]             list <- base::list
[16:13:04.662]             seq.int <- base::seq.int
[16:13:04.662]             signalCondition <- base::signalCondition
[16:13:04.662]             sys.calls <- base::sys.calls
[16:13:04.662]             `[[` <- base::`[[`
[16:13:04.662]             `+` <- base::`+`
[16:13:04.662]             `<<-` <- base::`<<-`
[16:13:04.662]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:04.662]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:04.662]                   3L)]
[16:13:04.662]             }
[16:13:04.662]             function(cond) {
[16:13:04.662]                 is_error <- inherits(cond, "error")
[16:13:04.662]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:04.662]                   NULL)
[16:13:04.662]                 if (is_error) {
[16:13:04.662]                   sessionInformation <- function() {
[16:13:04.662]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:04.662]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:04.662]                       search = base::search(), system = base::Sys.info())
[16:13:04.662]                   }
[16:13:04.662]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.662]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:04.662]                     cond$call), session = sessionInformation(), 
[16:13:04.662]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:04.662]                   signalCondition(cond)
[16:13:04.662]                 }
[16:13:04.662]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:04.662]                 "immediateCondition"))) {
[16:13:04.662]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:04.662]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.662]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:04.662]                   if (TRUE && !signal) {
[16:13:04.662]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.662]                     {
[16:13:04.662]                       inherits <- base::inherits
[16:13:04.662]                       invokeRestart <- base::invokeRestart
[16:13:04.662]                       is.null <- base::is.null
[16:13:04.662]                       muffled <- FALSE
[16:13:04.662]                       if (inherits(cond, "message")) {
[16:13:04.662]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.662]                         if (muffled) 
[16:13:04.662]                           invokeRestart("muffleMessage")
[16:13:04.662]                       }
[16:13:04.662]                       else if (inherits(cond, "warning")) {
[16:13:04.662]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.662]                         if (muffled) 
[16:13:04.662]                           invokeRestart("muffleWarning")
[16:13:04.662]                       }
[16:13:04.662]                       else if (inherits(cond, "condition")) {
[16:13:04.662]                         if (!is.null(pattern)) {
[16:13:04.662]                           computeRestarts <- base::computeRestarts
[16:13:04.662]                           grepl <- base::grepl
[16:13:04.662]                           restarts <- computeRestarts(cond)
[16:13:04.662]                           for (restart in restarts) {
[16:13:04.662]                             name <- restart$name
[16:13:04.662]                             if (is.null(name)) 
[16:13:04.662]                               next
[16:13:04.662]                             if (!grepl(pattern, name)) 
[16:13:04.662]                               next
[16:13:04.662]                             invokeRestart(restart)
[16:13:04.662]                             muffled <- TRUE
[16:13:04.662]                             break
[16:13:04.662]                           }
[16:13:04.662]                         }
[16:13:04.662]                       }
[16:13:04.662]                       invisible(muffled)
[16:13:04.662]                     }
[16:13:04.662]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.662]                   }
[16:13:04.662]                 }
[16:13:04.662]                 else {
[16:13:04.662]                   if (TRUE) {
[16:13:04.662]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.662]                     {
[16:13:04.662]                       inherits <- base::inherits
[16:13:04.662]                       invokeRestart <- base::invokeRestart
[16:13:04.662]                       is.null <- base::is.null
[16:13:04.662]                       muffled <- FALSE
[16:13:04.662]                       if (inherits(cond, "message")) {
[16:13:04.662]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.662]                         if (muffled) 
[16:13:04.662]                           invokeRestart("muffleMessage")
[16:13:04.662]                       }
[16:13:04.662]                       else if (inherits(cond, "warning")) {
[16:13:04.662]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.662]                         if (muffled) 
[16:13:04.662]                           invokeRestart("muffleWarning")
[16:13:04.662]                       }
[16:13:04.662]                       else if (inherits(cond, "condition")) {
[16:13:04.662]                         if (!is.null(pattern)) {
[16:13:04.662]                           computeRestarts <- base::computeRestarts
[16:13:04.662]                           grepl <- base::grepl
[16:13:04.662]                           restarts <- computeRestarts(cond)
[16:13:04.662]                           for (restart in restarts) {
[16:13:04.662]                             name <- restart$name
[16:13:04.662]                             if (is.null(name)) 
[16:13:04.662]                               next
[16:13:04.662]                             if (!grepl(pattern, name)) 
[16:13:04.662]                               next
[16:13:04.662]                             invokeRestart(restart)
[16:13:04.662]                             muffled <- TRUE
[16:13:04.662]                             break
[16:13:04.662]                           }
[16:13:04.662]                         }
[16:13:04.662]                       }
[16:13:04.662]                       invisible(muffled)
[16:13:04.662]                     }
[16:13:04.662]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.662]                   }
[16:13:04.662]                 }
[16:13:04.662]             }
[16:13:04.662]         }))
[16:13:04.662]     }, error = function(ex) {
[16:13:04.662]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:04.662]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.662]                 ...future.rng), started = ...future.startTime, 
[16:13:04.662]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:04.662]             version = "1.8"), class = "FutureResult")
[16:13:04.662]     }, finally = {
[16:13:04.662]         if (!identical(...future.workdir, getwd())) 
[16:13:04.662]             setwd(...future.workdir)
[16:13:04.662]         {
[16:13:04.662]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:04.662]                 ...future.oldOptions$nwarnings <- NULL
[16:13:04.662]             }
[16:13:04.662]             base::options(...future.oldOptions)
[16:13:04.662]             if (.Platform$OS.type == "windows") {
[16:13:04.662]                 old_names <- names(...future.oldEnvVars)
[16:13:04.662]                 envs <- base::Sys.getenv()
[16:13:04.662]                 names <- names(envs)
[16:13:04.662]                 common <- intersect(names, old_names)
[16:13:04.662]                 added <- setdiff(names, old_names)
[16:13:04.662]                 removed <- setdiff(old_names, names)
[16:13:04.662]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:04.662]                   envs[common]]
[16:13:04.662]                 NAMES <- toupper(changed)
[16:13:04.662]                 args <- list()
[16:13:04.662]                 for (kk in seq_along(NAMES)) {
[16:13:04.662]                   name <- changed[[kk]]
[16:13:04.662]                   NAME <- NAMES[[kk]]
[16:13:04.662]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.662]                     next
[16:13:04.662]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.662]                 }
[16:13:04.662]                 NAMES <- toupper(added)
[16:13:04.662]                 for (kk in seq_along(NAMES)) {
[16:13:04.662]                   name <- added[[kk]]
[16:13:04.662]                   NAME <- NAMES[[kk]]
[16:13:04.662]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.662]                     next
[16:13:04.662]                   args[[name]] <- ""
[16:13:04.662]                 }
[16:13:04.662]                 NAMES <- toupper(removed)
[16:13:04.662]                 for (kk in seq_along(NAMES)) {
[16:13:04.662]                   name <- removed[[kk]]
[16:13:04.662]                   NAME <- NAMES[[kk]]
[16:13:04.662]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.662]                     next
[16:13:04.662]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.662]                 }
[16:13:04.662]                 if (length(args) > 0) 
[16:13:04.662]                   base::do.call(base::Sys.setenv, args = args)
[16:13:04.662]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:04.662]             }
[16:13:04.662]             else {
[16:13:04.662]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:04.662]             }
[16:13:04.662]             {
[16:13:04.662]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:04.662]                   0L) {
[16:13:04.662]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:04.662]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:04.662]                   base::options(opts)
[16:13:04.662]                 }
[16:13:04.662]                 {
[16:13:04.662]                   {
[16:13:04.662]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:04.662]                     NULL
[16:13:04.662]                   }
[16:13:04.662]                   options(future.plan = NULL)
[16:13:04.662]                   if (is.na(NA_character_)) 
[16:13:04.662]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.662]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:04.662]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:04.662]                     envir = parent.frame()) 
[16:13:04.662]                   {
[16:13:04.662]                     default_workers <- missing(workers)
[16:13:04.662]                     if (is.function(workers)) 
[16:13:04.662]                       workers <- workers()
[16:13:04.662]                     workers <- structure(as.integer(workers), 
[16:13:04.662]                       class = class(workers))
[16:13:04.662]                     stop_if_not(is.finite(workers), workers >= 
[16:13:04.662]                       1L)
[16:13:04.662]                     if ((workers == 1L && !inherits(workers, 
[16:13:04.662]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:04.662]                       if (default_workers) 
[16:13:04.662]                         supportsMulticore(warn = TRUE)
[16:13:04.662]                       return(sequential(..., envir = envir))
[16:13:04.662]                     }
[16:13:04.662]                     oopts <- options(mc.cores = workers)
[16:13:04.662]                     on.exit(options(oopts))
[16:13:04.662]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:04.662]                       envir = envir)
[16:13:04.662]                     if (!future$lazy) 
[16:13:04.662]                       future <- run(future)
[16:13:04.662]                     invisible(future)
[16:13:04.662]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:04.662]                 }
[16:13:04.662]             }
[16:13:04.662]         }
[16:13:04.662]     })
[16:13:04.662]     if (TRUE) {
[16:13:04.662]         base::sink(type = "output", split = FALSE)
[16:13:04.662]         if (TRUE) {
[16:13:04.662]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:04.662]         }
[16:13:04.662]         else {
[16:13:04.662]             ...future.result["stdout"] <- base::list(NULL)
[16:13:04.662]         }
[16:13:04.662]         base::close(...future.stdout)
[16:13:04.662]         ...future.stdout <- NULL
[16:13:04.662]     }
[16:13:04.662]     ...future.result$conditions <- ...future.conditions
[16:13:04.662]     ...future.result$finished <- base::Sys.time()
[16:13:04.662]     ...future.result
[16:13:04.662] }
[16:13:04.665] assign_globals() ...
[16:13:04.665] List of 1
[16:13:04.665]  $ ii: int 3
[16:13:04.665]  - attr(*, "where")=List of 1
[16:13:04.665]   ..$ ii:<environment: R_EmptyEnv> 
[16:13:04.665]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:04.665]  - attr(*, "resolved")= logi FALSE
[16:13:04.665]  - attr(*, "total_size")= num 56
[16:13:04.670] - copied ‘ii’ to environment
[16:13:04.670] assign_globals() ... done
[16:13:04.670] requestCore(): workers = 2
[16:13:04.670] Poll #1 (0): usedCores() = 2, workers = 2
[16:13:04.684] MulticoreFuture started
 - Creating multicore future #4 ...
[16:13:04.685] plan(): Setting new future strategy stack:
[16:13:04.686] List of future strategies:
[16:13:04.686] 1. sequential:
[16:13:04.686]    - args: function (..., envir = parent.frame())
[16:13:04.686]    - tweaked: FALSE
[16:13:04.686]    - call: NULL
[16:13:04.687] plan(): nbrOfWorkers() = 1
[16:13:04.689] plan(): Setting new future strategy stack:
[16:13:04.689] List of future strategies:
[16:13:04.689] 1. multicore:
[16:13:04.689]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:04.689]    - tweaked: FALSE
[16:13:04.689]    - call: plan(multicore)
[16:13:04.692] getGlobalsAndPackages() ...
[16:13:04.692] Searching for globals...
[16:13:04.693] - globals found: [2] ‘{’, ‘ii’
[16:13:04.694] Searching for globals ... DONE
[16:13:04.694] Resolving globals: FALSE
[16:13:04.694] plan(): nbrOfWorkers() = 2
[16:13:04.694] The total size of the 1 globals is 56 bytes (56 bytes)
[16:13:04.695] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:13:04.695] - globals: [1] ‘ii’
[16:13:04.695] 
[16:13:04.696] getGlobalsAndPackages() ... DONE
[16:13:04.696] Packages needed by the future expression (n = 0): <none>
[16:13:04.697] Packages needed by future strategies (n = 0): <none>
[16:13:04.697] {
[16:13:04.697]     {
[16:13:04.697]         {
[16:13:04.697]             ...future.startTime <- base::Sys.time()
[16:13:04.697]             {
[16:13:04.697]                 {
[16:13:04.697]                   {
[16:13:04.697]                     {
[16:13:04.697]                       base::local({
[16:13:04.697]                         has_future <- base::requireNamespace("future", 
[16:13:04.697]                           quietly = TRUE)
[16:13:04.697]                         if (has_future) {
[16:13:04.697]                           ns <- base::getNamespace("future")
[16:13:04.697]                           version <- ns[[".package"]][["version"]]
[16:13:04.697]                           if (is.null(version)) 
[16:13:04.697]                             version <- utils::packageVersion("future")
[16:13:04.697]                         }
[16:13:04.697]                         else {
[16:13:04.697]                           version <- NULL
[16:13:04.697]                         }
[16:13:04.697]                         if (!has_future || version < "1.8.0") {
[16:13:04.697]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:04.697]                             "", base::R.version$version.string), 
[16:13:04.697]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:04.697]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:04.697]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:04.697]                               "release", "version")], collapse = " "), 
[16:13:04.697]                             hostname = base::Sys.info()[["nodename"]])
[16:13:04.697]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:04.697]                             info)
[16:13:04.697]                           info <- base::paste(info, collapse = "; ")
[16:13:04.697]                           if (!has_future) {
[16:13:04.697]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:04.697]                               info)
[16:13:04.697]                           }
[16:13:04.697]                           else {
[16:13:04.697]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:04.697]                               info, version)
[16:13:04.697]                           }
[16:13:04.697]                           base::stop(msg)
[16:13:04.697]                         }
[16:13:04.697]                       })
[16:13:04.697]                     }
[16:13:04.697]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:04.697]                     base::options(mc.cores = 1L)
[16:13:04.697]                   }
[16:13:04.697]                   options(future.plan = NULL)
[16:13:04.697]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.697]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:04.697]                 }
[16:13:04.697]                 ...future.workdir <- getwd()
[16:13:04.697]             }
[16:13:04.697]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:04.697]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:04.697]         }
[16:13:04.697]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:04.697]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:04.697]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:04.697]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:04.697]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:04.697]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:04.697]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:04.697]             base::names(...future.oldOptions))
[16:13:04.697]     }
[16:13:04.697]     if (FALSE) {
[16:13:04.697]     }
[16:13:04.697]     else {
[16:13:04.697]         if (TRUE) {
[16:13:04.697]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:04.697]                 open = "w")
[16:13:04.697]         }
[16:13:04.697]         else {
[16:13:04.697]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:04.697]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:04.697]         }
[16:13:04.697]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:04.697]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:04.697]             base::sink(type = "output", split = FALSE)
[16:13:04.697]             base::close(...future.stdout)
[16:13:04.697]         }, add = TRUE)
[16:13:04.697]     }
[16:13:04.697]     ...future.frame <- base::sys.nframe()
[16:13:04.697]     ...future.conditions <- base::list()
[16:13:04.697]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:04.697]     if (FALSE) {
[16:13:04.697]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:04.697]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:04.697]     }
[16:13:04.697]     ...future.result <- base::tryCatch({
[16:13:04.697]         base::withCallingHandlers({
[16:13:04.697]             ...future.value <- base::withVisible(base::local({
[16:13:04.697]                 withCallingHandlers({
[16:13:04.697]                   {
[16:13:04.697]                     ii
[16:13:04.697]                   }
[16:13:04.697]                 }, immediateCondition = function(cond) {
[16:13:04.697]                   save_rds <- function (object, pathname, ...) 
[16:13:04.697]                   {
[16:13:04.697]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:04.697]                     if (file_test("-f", pathname_tmp)) {
[16:13:04.697]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.697]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:04.697]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.697]                         fi_tmp[["mtime"]])
[16:13:04.697]                     }
[16:13:04.697]                     tryCatch({
[16:13:04.697]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:04.697]                     }, error = function(ex) {
[16:13:04.697]                       msg <- conditionMessage(ex)
[16:13:04.697]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.697]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:04.697]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.697]                         fi_tmp[["mtime"]], msg)
[16:13:04.697]                       ex$message <- msg
[16:13:04.697]                       stop(ex)
[16:13:04.697]                     })
[16:13:04.697]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:04.697]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:04.697]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:04.697]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.697]                       fi <- file.info(pathname)
[16:13:04.697]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:04.697]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.697]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:04.697]                         fi[["size"]], fi[["mtime"]])
[16:13:04.697]                       stop(msg)
[16:13:04.697]                     }
[16:13:04.697]                     invisible(pathname)
[16:13:04.697]                   }
[16:13:04.697]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:04.697]                     rootPath = tempdir()) 
[16:13:04.697]                   {
[16:13:04.697]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:04.697]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:04.697]                       tmpdir = path, fileext = ".rds")
[16:13:04.697]                     save_rds(obj, file)
[16:13:04.697]                   }
[16:13:04.697]                   saveImmediateCondition(cond, path = "/tmp/RtmpmgpgJ1/.future/immediateConditions")
[16:13:04.697]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.697]                   {
[16:13:04.697]                     inherits <- base::inherits
[16:13:04.697]                     invokeRestart <- base::invokeRestart
[16:13:04.697]                     is.null <- base::is.null
[16:13:04.697]                     muffled <- FALSE
[16:13:04.697]                     if (inherits(cond, "message")) {
[16:13:04.697]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:04.697]                       if (muffled) 
[16:13:04.697]                         invokeRestart("muffleMessage")
[16:13:04.697]                     }
[16:13:04.697]                     else if (inherits(cond, "warning")) {
[16:13:04.697]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:04.697]                       if (muffled) 
[16:13:04.697]                         invokeRestart("muffleWarning")
[16:13:04.697]                     }
[16:13:04.697]                     else if (inherits(cond, "condition")) {
[16:13:04.697]                       if (!is.null(pattern)) {
[16:13:04.697]                         computeRestarts <- base::computeRestarts
[16:13:04.697]                         grepl <- base::grepl
[16:13:04.697]                         restarts <- computeRestarts(cond)
[16:13:04.697]                         for (restart in restarts) {
[16:13:04.697]                           name <- restart$name
[16:13:04.697]                           if (is.null(name)) 
[16:13:04.697]                             next
[16:13:04.697]                           if (!grepl(pattern, name)) 
[16:13:04.697]                             next
[16:13:04.697]                           invokeRestart(restart)
[16:13:04.697]                           muffled <- TRUE
[16:13:04.697]                           break
[16:13:04.697]                         }
[16:13:04.697]                       }
[16:13:04.697]                     }
[16:13:04.697]                     invisible(muffled)
[16:13:04.697]                   }
[16:13:04.697]                   muffleCondition(cond)
[16:13:04.697]                 })
[16:13:04.697]             }))
[16:13:04.697]             future::FutureResult(value = ...future.value$value, 
[16:13:04.697]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.697]                   ...future.rng), globalenv = if (FALSE) 
[16:13:04.697]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:04.697]                     ...future.globalenv.names))
[16:13:04.697]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:04.697]         }, condition = base::local({
[16:13:04.697]             c <- base::c
[16:13:04.697]             inherits <- base::inherits
[16:13:04.697]             invokeRestart <- base::invokeRestart
[16:13:04.697]             length <- base::length
[16:13:04.697]             list <- base::list
[16:13:04.697]             seq.int <- base::seq.int
[16:13:04.697]             signalCondition <- base::signalCondition
[16:13:04.697]             sys.calls <- base::sys.calls
[16:13:04.697]             `[[` <- base::`[[`
[16:13:04.697]             `+` <- base::`+`
[16:13:04.697]             `<<-` <- base::`<<-`
[16:13:04.697]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:04.697]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:04.697]                   3L)]
[16:13:04.697]             }
[16:13:04.697]             function(cond) {
[16:13:04.697]                 is_error <- inherits(cond, "error")
[16:13:04.697]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:04.697]                   NULL)
[16:13:04.697]                 if (is_error) {
[16:13:04.697]                   sessionInformation <- function() {
[16:13:04.697]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:04.697]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:04.697]                       search = base::search(), system = base::Sys.info())
[16:13:04.697]                   }
[16:13:04.697]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.697]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:04.697]                     cond$call), session = sessionInformation(), 
[16:13:04.697]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:04.697]                   signalCondition(cond)
[16:13:04.697]                 }
[16:13:04.697]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:04.697]                 "immediateCondition"))) {
[16:13:04.697]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:04.697]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.697]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:04.697]                   if (TRUE && !signal) {
[16:13:04.697]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.697]                     {
[16:13:04.697]                       inherits <- base::inherits
[16:13:04.697]                       invokeRestart <- base::invokeRestart
[16:13:04.697]                       is.null <- base::is.null
[16:13:04.697]                       muffled <- FALSE
[16:13:04.697]                       if (inherits(cond, "message")) {
[16:13:04.697]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.697]                         if (muffled) 
[16:13:04.697]                           invokeRestart("muffleMessage")
[16:13:04.697]                       }
[16:13:04.697]                       else if (inherits(cond, "warning")) {
[16:13:04.697]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.697]                         if (muffled) 
[16:13:04.697]                           invokeRestart("muffleWarning")
[16:13:04.697]                       }
[16:13:04.697]                       else if (inherits(cond, "condition")) {
[16:13:04.697]                         if (!is.null(pattern)) {
[16:13:04.697]                           computeRestarts <- base::computeRestarts
[16:13:04.697]                           grepl <- base::grepl
[16:13:04.697]                           restarts <- computeRestarts(cond)
[16:13:04.697]                           for (restart in restarts) {
[16:13:04.697]                             name <- restart$name
[16:13:04.697]                             if (is.null(name)) 
[16:13:04.697]                               next
[16:13:04.697]                             if (!grepl(pattern, name)) 
[16:13:04.697]                               next
[16:13:04.697]                             invokeRestart(restart)
[16:13:04.697]                             muffled <- TRUE
[16:13:04.697]                             break
[16:13:04.697]                           }
[16:13:04.697]                         }
[16:13:04.697]                       }
[16:13:04.697]                       invisible(muffled)
[16:13:04.697]                     }
[16:13:04.697]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.697]                   }
[16:13:04.697]                 }
[16:13:04.697]                 else {
[16:13:04.697]                   if (TRUE) {
[16:13:04.697]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.697]                     {
[16:13:04.697]                       inherits <- base::inherits
[16:13:04.697]                       invokeRestart <- base::invokeRestart
[16:13:04.697]                       is.null <- base::is.null
[16:13:04.697]                       muffled <- FALSE
[16:13:04.697]                       if (inherits(cond, "message")) {
[16:13:04.697]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.697]                         if (muffled) 
[16:13:04.697]                           invokeRestart("muffleMessage")
[16:13:04.697]                       }
[16:13:04.697]                       else if (inherits(cond, "warning")) {
[16:13:04.697]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.697]                         if (muffled) 
[16:13:04.697]                           invokeRestart("muffleWarning")
[16:13:04.697]                       }
[16:13:04.697]                       else if (inherits(cond, "condition")) {
[16:13:04.697]                         if (!is.null(pattern)) {
[16:13:04.697]                           computeRestarts <- base::computeRestarts
[16:13:04.697]                           grepl <- base::grepl
[16:13:04.697]                           restarts <- computeRestarts(cond)
[16:13:04.697]                           for (restart in restarts) {
[16:13:04.697]                             name <- restart$name
[16:13:04.697]                             if (is.null(name)) 
[16:13:04.697]                               next
[16:13:04.697]                             if (!grepl(pattern, name)) 
[16:13:04.697]                               next
[16:13:04.697]                             invokeRestart(restart)
[16:13:04.697]                             muffled <- TRUE
[16:13:04.697]                             break
[16:13:04.697]                           }
[16:13:04.697]                         }
[16:13:04.697]                       }
[16:13:04.697]                       invisible(muffled)
[16:13:04.697]                     }
[16:13:04.697]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.697]                   }
[16:13:04.697]                 }
[16:13:04.697]             }
[16:13:04.697]         }))
[16:13:04.697]     }, error = function(ex) {
[16:13:04.697]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:04.697]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.697]                 ...future.rng), started = ...future.startTime, 
[16:13:04.697]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:04.697]             version = "1.8"), class = "FutureResult")
[16:13:04.697]     }, finally = {
[16:13:04.697]         if (!identical(...future.workdir, getwd())) 
[16:13:04.697]             setwd(...future.workdir)
[16:13:04.697]         {
[16:13:04.697]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:04.697]                 ...future.oldOptions$nwarnings <- NULL
[16:13:04.697]             }
[16:13:04.697]             base::options(...future.oldOptions)
[16:13:04.697]             if (.Platform$OS.type == "windows") {
[16:13:04.697]                 old_names <- names(...future.oldEnvVars)
[16:13:04.697]                 envs <- base::Sys.getenv()
[16:13:04.697]                 names <- names(envs)
[16:13:04.697]                 common <- intersect(names, old_names)
[16:13:04.697]                 added <- setdiff(names, old_names)
[16:13:04.697]                 removed <- setdiff(old_names, names)
[16:13:04.697]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:04.697]                   envs[common]]
[16:13:04.697]                 NAMES <- toupper(changed)
[16:13:04.697]                 args <- list()
[16:13:04.697]                 for (kk in seq_along(NAMES)) {
[16:13:04.697]                   name <- changed[[kk]]
[16:13:04.697]                   NAME <- NAMES[[kk]]
[16:13:04.697]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.697]                     next
[16:13:04.697]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.697]                 }
[16:13:04.697]                 NAMES <- toupper(added)
[16:13:04.697]                 for (kk in seq_along(NAMES)) {
[16:13:04.697]                   name <- added[[kk]]
[16:13:04.697]                   NAME <- NAMES[[kk]]
[16:13:04.697]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.697]                     next
[16:13:04.697]                   args[[name]] <- ""
[16:13:04.697]                 }
[16:13:04.697]                 NAMES <- toupper(removed)
[16:13:04.697]                 for (kk in seq_along(NAMES)) {
[16:13:04.697]                   name <- removed[[kk]]
[16:13:04.697]                   NAME <- NAMES[[kk]]
[16:13:04.697]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.697]                     next
[16:13:04.697]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.697]                 }
[16:13:04.697]                 if (length(args) > 0) 
[16:13:04.697]                   base::do.call(base::Sys.setenv, args = args)
[16:13:04.697]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:04.697]             }
[16:13:04.697]             else {
[16:13:04.697]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:04.697]             }
[16:13:04.697]             {
[16:13:04.697]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:04.697]                   0L) {
[16:13:04.697]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:04.697]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:04.697]                   base::options(opts)
[16:13:04.697]                 }
[16:13:04.697]                 {
[16:13:04.697]                   {
[16:13:04.697]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:04.697]                     NULL
[16:13:04.697]                   }
[16:13:04.697]                   options(future.plan = NULL)
[16:13:04.697]                   if (is.na(NA_character_)) 
[16:13:04.697]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.697]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:04.697]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:04.697]                     envir = parent.frame()) 
[16:13:04.697]                   {
[16:13:04.697]                     default_workers <- missing(workers)
[16:13:04.697]                     if (is.function(workers)) 
[16:13:04.697]                       workers <- workers()
[16:13:04.697]                     workers <- structure(as.integer(workers), 
[16:13:04.697]                       class = class(workers))
[16:13:04.697]                     stop_if_not(is.finite(workers), workers >= 
[16:13:04.697]                       1L)
[16:13:04.697]                     if ((workers == 1L && !inherits(workers, 
[16:13:04.697]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:04.697]                       if (default_workers) 
[16:13:04.697]                         supportsMulticore(warn = TRUE)
[16:13:04.697]                       return(sequential(..., envir = envir))
[16:13:04.697]                     }
[16:13:04.697]                     oopts <- options(mc.cores = workers)
[16:13:04.697]                     on.exit(options(oopts))
[16:13:04.697]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:04.697]                       envir = envir)
[16:13:04.697]                     if (!future$lazy) 
[16:13:04.697]                       future <- run(future)
[16:13:04.697]                     invisible(future)
[16:13:04.697]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:04.697]                 }
[16:13:04.697]             }
[16:13:04.697]         }
[16:13:04.697]     })
[16:13:04.697]     if (TRUE) {
[16:13:04.697]         base::sink(type = "output", split = FALSE)
[16:13:04.697]         if (TRUE) {
[16:13:04.697]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:04.697]         }
[16:13:04.697]         else {
[16:13:04.697]             ...future.result["stdout"] <- base::list(NULL)
[16:13:04.697]         }
[16:13:04.697]         base::close(...future.stdout)
[16:13:04.697]         ...future.stdout <- NULL
[16:13:04.697]     }
[16:13:04.697]     ...future.result$conditions <- ...future.conditions
[16:13:04.697]     ...future.result$finished <- base::Sys.time()
[16:13:04.697]     ...future.result
[16:13:04.697] }
[16:13:04.701] assign_globals() ...
[16:13:04.701] List of 1
[16:13:04.701]  $ ii: int 4
[16:13:04.701]  - attr(*, "where")=List of 1
[16:13:04.701]   ..$ ii:<environment: R_EmptyEnv> 
[16:13:04.701]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:04.701]  - attr(*, "resolved")= logi FALSE
[16:13:04.701]  - attr(*, "total_size")= num 56
[16:13:04.705] - copied ‘ii’ to environment
[16:13:04.705] assign_globals() ... done
[16:13:04.705] requestCore(): workers = 2
[16:13:04.705] Poll #1 (0): usedCores() = 2, workers = 2
[16:13:04.719] MulticoreFuture started
 - Resolving 4 multicore futures
[16:13:04.720] plan(): Setting new future strategy stack:
[16:13:04.721] List of future strategies:
[16:13:04.721] 1. sequential:
[16:13:04.721]    - args: function (..., envir = parent.frame())
[16:13:04.721]    - tweaked: FALSE
[16:13:04.721]    - call: NULL
[16:13:04.722] plan(): nbrOfWorkers() = 1
[16:13:04.724] plan(): Setting new future strategy stack:
[16:13:04.724] List of future strategies:
[16:13:04.724] 1. multicore:
[16:13:04.724]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:04.724]    - tweaked: FALSE
[16:13:04.724]    - call: plan(multicore)
[16:13:04.730] plan(): nbrOfWorkers() = 2
*** multicore(..., globals = TRUE) and errors
[16:13:04.735] getGlobalsAndPackages() ...
[16:13:04.735] Searching for globals...
[16:13:04.736] - globals found: [2] ‘{’, ‘stop’
[16:13:04.737] Searching for globals ... DONE
[16:13:04.737] Resolving globals: FALSE
[16:13:04.737] 
[16:13:04.737] 
[16:13:04.737] getGlobalsAndPackages() ... DONE
[16:13:04.738] Packages needed by the future expression (n = 0): <none>
[16:13:04.738] Packages needed by future strategies (n = 0): <none>
[16:13:04.739] {
[16:13:04.739]     {
[16:13:04.739]         {
[16:13:04.739]             ...future.startTime <- base::Sys.time()
[16:13:04.739]             {
[16:13:04.739]                 {
[16:13:04.739]                   {
[16:13:04.739]                     {
[16:13:04.739]                       base::local({
[16:13:04.739]                         has_future <- base::requireNamespace("future", 
[16:13:04.739]                           quietly = TRUE)
[16:13:04.739]                         if (has_future) {
[16:13:04.739]                           ns <- base::getNamespace("future")
[16:13:04.739]                           version <- ns[[".package"]][["version"]]
[16:13:04.739]                           if (is.null(version)) 
[16:13:04.739]                             version <- utils::packageVersion("future")
[16:13:04.739]                         }
[16:13:04.739]                         else {
[16:13:04.739]                           version <- NULL
[16:13:04.739]                         }
[16:13:04.739]                         if (!has_future || version < "1.8.0") {
[16:13:04.739]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:04.739]                             "", base::R.version$version.string), 
[16:13:04.739]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:04.739]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:04.739]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:04.739]                               "release", "version")], collapse = " "), 
[16:13:04.739]                             hostname = base::Sys.info()[["nodename"]])
[16:13:04.739]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:04.739]                             info)
[16:13:04.739]                           info <- base::paste(info, collapse = "; ")
[16:13:04.739]                           if (!has_future) {
[16:13:04.739]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:04.739]                               info)
[16:13:04.739]                           }
[16:13:04.739]                           else {
[16:13:04.739]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:04.739]                               info, version)
[16:13:04.739]                           }
[16:13:04.739]                           base::stop(msg)
[16:13:04.739]                         }
[16:13:04.739]                       })
[16:13:04.739]                     }
[16:13:04.739]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:04.739]                     base::options(mc.cores = 1L)
[16:13:04.739]                   }
[16:13:04.739]                   options(future.plan = NULL)
[16:13:04.739]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.739]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:04.739]                 }
[16:13:04.739]                 ...future.workdir <- getwd()
[16:13:04.739]             }
[16:13:04.739]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:04.739]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:04.739]         }
[16:13:04.739]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:04.739]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:04.739]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:04.739]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:04.739]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:04.739]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:04.739]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:04.739]             base::names(...future.oldOptions))
[16:13:04.739]     }
[16:13:04.739]     if (FALSE) {
[16:13:04.739]     }
[16:13:04.739]     else {
[16:13:04.739]         if (TRUE) {
[16:13:04.739]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:04.739]                 open = "w")
[16:13:04.739]         }
[16:13:04.739]         else {
[16:13:04.739]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:04.739]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:04.739]         }
[16:13:04.739]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:04.739]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:04.739]             base::sink(type = "output", split = FALSE)
[16:13:04.739]             base::close(...future.stdout)
[16:13:04.739]         }, add = TRUE)
[16:13:04.739]     }
[16:13:04.739]     ...future.frame <- base::sys.nframe()
[16:13:04.739]     ...future.conditions <- base::list()
[16:13:04.739]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:04.739]     if (FALSE) {
[16:13:04.739]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:04.739]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:04.739]     }
[16:13:04.739]     ...future.result <- base::tryCatch({
[16:13:04.739]         base::withCallingHandlers({
[16:13:04.739]             ...future.value <- base::withVisible(base::local({
[16:13:04.739]                 withCallingHandlers({
[16:13:04.739]                   {
[16:13:04.739]                     stop("Whoops!")
[16:13:04.739]                     1
[16:13:04.739]                   }
[16:13:04.739]                 }, immediateCondition = function(cond) {
[16:13:04.739]                   save_rds <- function (object, pathname, ...) 
[16:13:04.739]                   {
[16:13:04.739]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:04.739]                     if (file_test("-f", pathname_tmp)) {
[16:13:04.739]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.739]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:04.739]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.739]                         fi_tmp[["mtime"]])
[16:13:04.739]                     }
[16:13:04.739]                     tryCatch({
[16:13:04.739]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:04.739]                     }, error = function(ex) {
[16:13:04.739]                       msg <- conditionMessage(ex)
[16:13:04.739]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.739]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:04.739]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.739]                         fi_tmp[["mtime"]], msg)
[16:13:04.739]                       ex$message <- msg
[16:13:04.739]                       stop(ex)
[16:13:04.739]                     })
[16:13:04.739]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:04.739]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:04.739]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:04.739]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.739]                       fi <- file.info(pathname)
[16:13:04.739]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:04.739]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.739]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:04.739]                         fi[["size"]], fi[["mtime"]])
[16:13:04.739]                       stop(msg)
[16:13:04.739]                     }
[16:13:04.739]                     invisible(pathname)
[16:13:04.739]                   }
[16:13:04.739]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:04.739]                     rootPath = tempdir()) 
[16:13:04.739]                   {
[16:13:04.739]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:04.739]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:04.739]                       tmpdir = path, fileext = ".rds")
[16:13:04.739]                     save_rds(obj, file)
[16:13:04.739]                   }
[16:13:04.739]                   saveImmediateCondition(cond, path = "/tmp/RtmpmgpgJ1/.future/immediateConditions")
[16:13:04.739]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.739]                   {
[16:13:04.739]                     inherits <- base::inherits
[16:13:04.739]                     invokeRestart <- base::invokeRestart
[16:13:04.739]                     is.null <- base::is.null
[16:13:04.739]                     muffled <- FALSE
[16:13:04.739]                     if (inherits(cond, "message")) {
[16:13:04.739]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:04.739]                       if (muffled) 
[16:13:04.739]                         invokeRestart("muffleMessage")
[16:13:04.739]                     }
[16:13:04.739]                     else if (inherits(cond, "warning")) {
[16:13:04.739]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:04.739]                       if (muffled) 
[16:13:04.739]                         invokeRestart("muffleWarning")
[16:13:04.739]                     }
[16:13:04.739]                     else if (inherits(cond, "condition")) {
[16:13:04.739]                       if (!is.null(pattern)) {
[16:13:04.739]                         computeRestarts <- base::computeRestarts
[16:13:04.739]                         grepl <- base::grepl
[16:13:04.739]                         restarts <- computeRestarts(cond)
[16:13:04.739]                         for (restart in restarts) {
[16:13:04.739]                           name <- restart$name
[16:13:04.739]                           if (is.null(name)) 
[16:13:04.739]                             next
[16:13:04.739]                           if (!grepl(pattern, name)) 
[16:13:04.739]                             next
[16:13:04.739]                           invokeRestart(restart)
[16:13:04.739]                           muffled <- TRUE
[16:13:04.739]                           break
[16:13:04.739]                         }
[16:13:04.739]                       }
[16:13:04.739]                     }
[16:13:04.739]                     invisible(muffled)
[16:13:04.739]                   }
[16:13:04.739]                   muffleCondition(cond)
[16:13:04.739]                 })
[16:13:04.739]             }))
[16:13:04.739]             future::FutureResult(value = ...future.value$value, 
[16:13:04.739]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.739]                   ...future.rng), globalenv = if (FALSE) 
[16:13:04.739]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:04.739]                     ...future.globalenv.names))
[16:13:04.739]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:04.739]         }, condition = base::local({
[16:13:04.739]             c <- base::c
[16:13:04.739]             inherits <- base::inherits
[16:13:04.739]             invokeRestart <- base::invokeRestart
[16:13:04.739]             length <- base::length
[16:13:04.739]             list <- base::list
[16:13:04.739]             seq.int <- base::seq.int
[16:13:04.739]             signalCondition <- base::signalCondition
[16:13:04.739]             sys.calls <- base::sys.calls
[16:13:04.739]             `[[` <- base::`[[`
[16:13:04.739]             `+` <- base::`+`
[16:13:04.739]             `<<-` <- base::`<<-`
[16:13:04.739]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:04.739]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:04.739]                   3L)]
[16:13:04.739]             }
[16:13:04.739]             function(cond) {
[16:13:04.739]                 is_error <- inherits(cond, "error")
[16:13:04.739]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:04.739]                   NULL)
[16:13:04.739]                 if (is_error) {
[16:13:04.739]                   sessionInformation <- function() {
[16:13:04.739]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:04.739]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:04.739]                       search = base::search(), system = base::Sys.info())
[16:13:04.739]                   }
[16:13:04.739]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.739]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:04.739]                     cond$call), session = sessionInformation(), 
[16:13:04.739]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:04.739]                   signalCondition(cond)
[16:13:04.739]                 }
[16:13:04.739]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:04.739]                 "immediateCondition"))) {
[16:13:04.739]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:04.739]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.739]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:04.739]                   if (TRUE && !signal) {
[16:13:04.739]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.739]                     {
[16:13:04.739]                       inherits <- base::inherits
[16:13:04.739]                       invokeRestart <- base::invokeRestart
[16:13:04.739]                       is.null <- base::is.null
[16:13:04.739]                       muffled <- FALSE
[16:13:04.739]                       if (inherits(cond, "message")) {
[16:13:04.739]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.739]                         if (muffled) 
[16:13:04.739]                           invokeRestart("muffleMessage")
[16:13:04.739]                       }
[16:13:04.739]                       else if (inherits(cond, "warning")) {
[16:13:04.739]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.739]                         if (muffled) 
[16:13:04.739]                           invokeRestart("muffleWarning")
[16:13:04.739]                       }
[16:13:04.739]                       else if (inherits(cond, "condition")) {
[16:13:04.739]                         if (!is.null(pattern)) {
[16:13:04.739]                           computeRestarts <- base::computeRestarts
[16:13:04.739]                           grepl <- base::grepl
[16:13:04.739]                           restarts <- computeRestarts(cond)
[16:13:04.739]                           for (restart in restarts) {
[16:13:04.739]                             name <- restart$name
[16:13:04.739]                             if (is.null(name)) 
[16:13:04.739]                               next
[16:13:04.739]                             if (!grepl(pattern, name)) 
[16:13:04.739]                               next
[16:13:04.739]                             invokeRestart(restart)
[16:13:04.739]                             muffled <- TRUE
[16:13:04.739]                             break
[16:13:04.739]                           }
[16:13:04.739]                         }
[16:13:04.739]                       }
[16:13:04.739]                       invisible(muffled)
[16:13:04.739]                     }
[16:13:04.739]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.739]                   }
[16:13:04.739]                 }
[16:13:04.739]                 else {
[16:13:04.739]                   if (TRUE) {
[16:13:04.739]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.739]                     {
[16:13:04.739]                       inherits <- base::inherits
[16:13:04.739]                       invokeRestart <- base::invokeRestart
[16:13:04.739]                       is.null <- base::is.null
[16:13:04.739]                       muffled <- FALSE
[16:13:04.739]                       if (inherits(cond, "message")) {
[16:13:04.739]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.739]                         if (muffled) 
[16:13:04.739]                           invokeRestart("muffleMessage")
[16:13:04.739]                       }
[16:13:04.739]                       else if (inherits(cond, "warning")) {
[16:13:04.739]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.739]                         if (muffled) 
[16:13:04.739]                           invokeRestart("muffleWarning")
[16:13:04.739]                       }
[16:13:04.739]                       else if (inherits(cond, "condition")) {
[16:13:04.739]                         if (!is.null(pattern)) {
[16:13:04.739]                           computeRestarts <- base::computeRestarts
[16:13:04.739]                           grepl <- base::grepl
[16:13:04.739]                           restarts <- computeRestarts(cond)
[16:13:04.739]                           for (restart in restarts) {
[16:13:04.739]                             name <- restart$name
[16:13:04.739]                             if (is.null(name)) 
[16:13:04.739]                               next
[16:13:04.739]                             if (!grepl(pattern, name)) 
[16:13:04.739]                               next
[16:13:04.739]                             invokeRestart(restart)
[16:13:04.739]                             muffled <- TRUE
[16:13:04.739]                             break
[16:13:04.739]                           }
[16:13:04.739]                         }
[16:13:04.739]                       }
[16:13:04.739]                       invisible(muffled)
[16:13:04.739]                     }
[16:13:04.739]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.739]                   }
[16:13:04.739]                 }
[16:13:04.739]             }
[16:13:04.739]         }))
[16:13:04.739]     }, error = function(ex) {
[16:13:04.739]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:04.739]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.739]                 ...future.rng), started = ...future.startTime, 
[16:13:04.739]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:04.739]             version = "1.8"), class = "FutureResult")
[16:13:04.739]     }, finally = {
[16:13:04.739]         if (!identical(...future.workdir, getwd())) 
[16:13:04.739]             setwd(...future.workdir)
[16:13:04.739]         {
[16:13:04.739]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:04.739]                 ...future.oldOptions$nwarnings <- NULL
[16:13:04.739]             }
[16:13:04.739]             base::options(...future.oldOptions)
[16:13:04.739]             if (.Platform$OS.type == "windows") {
[16:13:04.739]                 old_names <- names(...future.oldEnvVars)
[16:13:04.739]                 envs <- base::Sys.getenv()
[16:13:04.739]                 names <- names(envs)
[16:13:04.739]                 common <- intersect(names, old_names)
[16:13:04.739]                 added <- setdiff(names, old_names)
[16:13:04.739]                 removed <- setdiff(old_names, names)
[16:13:04.739]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:04.739]                   envs[common]]
[16:13:04.739]                 NAMES <- toupper(changed)
[16:13:04.739]                 args <- list()
[16:13:04.739]                 for (kk in seq_along(NAMES)) {
[16:13:04.739]                   name <- changed[[kk]]
[16:13:04.739]                   NAME <- NAMES[[kk]]
[16:13:04.739]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.739]                     next
[16:13:04.739]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.739]                 }
[16:13:04.739]                 NAMES <- toupper(added)
[16:13:04.739]                 for (kk in seq_along(NAMES)) {
[16:13:04.739]                   name <- added[[kk]]
[16:13:04.739]                   NAME <- NAMES[[kk]]
[16:13:04.739]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.739]                     next
[16:13:04.739]                   args[[name]] <- ""
[16:13:04.739]                 }
[16:13:04.739]                 NAMES <- toupper(removed)
[16:13:04.739]                 for (kk in seq_along(NAMES)) {
[16:13:04.739]                   name <- removed[[kk]]
[16:13:04.739]                   NAME <- NAMES[[kk]]
[16:13:04.739]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.739]                     next
[16:13:04.739]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.739]                 }
[16:13:04.739]                 if (length(args) > 0) 
[16:13:04.739]                   base::do.call(base::Sys.setenv, args = args)
[16:13:04.739]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:04.739]             }
[16:13:04.739]             else {
[16:13:04.739]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:04.739]             }
[16:13:04.739]             {
[16:13:04.739]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:04.739]                   0L) {
[16:13:04.739]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:04.739]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:04.739]                   base::options(opts)
[16:13:04.739]                 }
[16:13:04.739]                 {
[16:13:04.739]                   {
[16:13:04.739]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:04.739]                     NULL
[16:13:04.739]                   }
[16:13:04.739]                   options(future.plan = NULL)
[16:13:04.739]                   if (is.na(NA_character_)) 
[16:13:04.739]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.739]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:04.739]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:04.739]                     envir = parent.frame()) 
[16:13:04.739]                   {
[16:13:04.739]                     default_workers <- missing(workers)
[16:13:04.739]                     if (is.function(workers)) 
[16:13:04.739]                       workers <- workers()
[16:13:04.739]                     workers <- structure(as.integer(workers), 
[16:13:04.739]                       class = class(workers))
[16:13:04.739]                     stop_if_not(is.finite(workers), workers >= 
[16:13:04.739]                       1L)
[16:13:04.739]                     if ((workers == 1L && !inherits(workers, 
[16:13:04.739]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:04.739]                       if (default_workers) 
[16:13:04.739]                         supportsMulticore(warn = TRUE)
[16:13:04.739]                       return(sequential(..., envir = envir))
[16:13:04.739]                     }
[16:13:04.739]                     oopts <- options(mc.cores = workers)
[16:13:04.739]                     on.exit(options(oopts))
[16:13:04.739]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:04.739]                       envir = envir)
[16:13:04.739]                     if (!future$lazy) 
[16:13:04.739]                       future <- run(future)
[16:13:04.739]                     invisible(future)
[16:13:04.739]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:04.739]                 }
[16:13:04.739]             }
[16:13:04.739]         }
[16:13:04.739]     })
[16:13:04.739]     if (TRUE) {
[16:13:04.739]         base::sink(type = "output", split = FALSE)
[16:13:04.739]         if (TRUE) {
[16:13:04.739]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:04.739]         }
[16:13:04.739]         else {
[16:13:04.739]             ...future.result["stdout"] <- base::list(NULL)
[16:13:04.739]         }
[16:13:04.739]         base::close(...future.stdout)
[16:13:04.739]         ...future.stdout <- NULL
[16:13:04.739]     }
[16:13:04.739]     ...future.result$conditions <- ...future.conditions
[16:13:04.739]     ...future.result$finished <- base::Sys.time()
[16:13:04.739]     ...future.result
[16:13:04.739] }
[16:13:04.741] requestCore(): workers = 2
[16:13:04.743] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:13:04.744] plan(): Setting new future strategy stack:
[16:13:04.745] List of future strategies:
[16:13:04.745] 1. sequential:
[16:13:04.745]    - args: function (..., envir = parent.frame())
[16:13:04.745]    - tweaked: FALSE
[16:13:04.745]    - call: NULL
[16:13:04.745] plan(): nbrOfWorkers() = 1
[16:13:04.747] plan(): Setting new future strategy stack:
[16:13:04.747] List of future strategies:
[16:13:04.747] 1. multicore:
[16:13:04.747]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:04.747]    - tweaked: FALSE
[16:13:04.747]    - call: plan(multicore)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 9cd5072f-68f7-e4f0-6d65-cff53a745767
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:04.758] plan(): nbrOfWorkers() = 2
[16:13:04.763] signalConditions() ...
[16:13:04.763]  - include = ‘immediateCondition’
[16:13:04.763]  - exclude = 
[16:13:04.763]  - resignal = FALSE
[16:13:04.763]  - Number of conditions: 1
[16:13:04.767] signalConditions() ... done
[16:13:04.767] signalConditions() ...
[16:13:04.767]  - include = ‘immediateCondition’
[16:13:04.767]  - exclude = 
[16:13:04.767]  - resignal = FALSE
[16:13:04.767]  - Number of conditions: 1
[16:13:04.767] signalConditions() ... done
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/RtmpmgpgJ1/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[16:13:04.768] signalConditions() ...
[16:13:04.768]  - include = ‘immediateCondition’
[16:13:04.769]  - exclude = 
[16:13:04.769]  - resignal = FALSE
[16:13:04.769]  - Number of conditions: 1
[16:13:04.769] signalConditions() ... done
[16:13:04.769] Future state: ‘finished’
[16:13:04.769] signalConditions() ...
[16:13:04.770]  - include = ‘condition’
[16:13:04.770]  - exclude = ‘immediateCondition’
[16:13:04.770]  - resignal = TRUE
[16:13:04.770]  - Number of conditions: 1
[16:13:04.770]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:13:04.770] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/RtmpmgpgJ1/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[16:13:04.771] signalConditions() ...
[16:13:04.771]  - include = ‘immediateCondition’
[16:13:04.772]  - exclude = 
[16:13:04.772]  - resignal = FALSE
[16:13:04.772]  - Number of conditions: 1
[16:13:04.772] signalConditions() ... done
[16:13:04.772] Future state: ‘finished’
[16:13:04.772] signalConditions() ...
[16:13:04.772]  - include = ‘condition’
[16:13:04.772]  - exclude = ‘immediateCondition’
[16:13:04.773]  - resignal = TRUE
[16:13:04.773]  - Number of conditions: 1
[16:13:04.773]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:13:04.773] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/RtmpmgpgJ1/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[16:13:04.778] getGlobalsAndPackages() ...
[16:13:04.778] 
[16:13:04.778] - globals: [0] <none>
[16:13:04.779] getGlobalsAndPackages() ... DONE
[16:13:04.779] Packages needed by the future expression (n = 0): <none>
[16:13:04.779] Packages needed by future strategies (n = 0): <none>
[16:13:04.780] {
[16:13:04.780]     {
[16:13:04.780]         {
[16:13:04.780]             ...future.startTime <- base::Sys.time()
[16:13:04.780]             {
[16:13:04.780]                 {
[16:13:04.780]                   {
[16:13:04.780]                     {
[16:13:04.780]                       base::local({
[16:13:04.780]                         has_future <- base::requireNamespace("future", 
[16:13:04.780]                           quietly = TRUE)
[16:13:04.780]                         if (has_future) {
[16:13:04.780]                           ns <- base::getNamespace("future")
[16:13:04.780]                           version <- ns[[".package"]][["version"]]
[16:13:04.780]                           if (is.null(version)) 
[16:13:04.780]                             version <- utils::packageVersion("future")
[16:13:04.780]                         }
[16:13:04.780]                         else {
[16:13:04.780]                           version <- NULL
[16:13:04.780]                         }
[16:13:04.780]                         if (!has_future || version < "1.8.0") {
[16:13:04.780]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:04.780]                             "", base::R.version$version.string), 
[16:13:04.780]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:04.780]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:04.780]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:04.780]                               "release", "version")], collapse = " "), 
[16:13:04.780]                             hostname = base::Sys.info()[["nodename"]])
[16:13:04.780]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:04.780]                             info)
[16:13:04.780]                           info <- base::paste(info, collapse = "; ")
[16:13:04.780]                           if (!has_future) {
[16:13:04.780]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:04.780]                               info)
[16:13:04.780]                           }
[16:13:04.780]                           else {
[16:13:04.780]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:04.780]                               info, version)
[16:13:04.780]                           }
[16:13:04.780]                           base::stop(msg)
[16:13:04.780]                         }
[16:13:04.780]                       })
[16:13:04.780]                     }
[16:13:04.780]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:04.780]                     base::options(mc.cores = 1L)
[16:13:04.780]                   }
[16:13:04.780]                   options(future.plan = NULL)
[16:13:04.780]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.780]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:04.780]                 }
[16:13:04.780]                 ...future.workdir <- getwd()
[16:13:04.780]             }
[16:13:04.780]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:04.780]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:04.780]         }
[16:13:04.780]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:04.780]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:04.780]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:04.780]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:04.780]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:04.780]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:04.780]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:04.780]             base::names(...future.oldOptions))
[16:13:04.780]     }
[16:13:04.780]     if (FALSE) {
[16:13:04.780]     }
[16:13:04.780]     else {
[16:13:04.780]         if (TRUE) {
[16:13:04.780]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:04.780]                 open = "w")
[16:13:04.780]         }
[16:13:04.780]         else {
[16:13:04.780]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:04.780]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:04.780]         }
[16:13:04.780]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:04.780]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:04.780]             base::sink(type = "output", split = FALSE)
[16:13:04.780]             base::close(...future.stdout)
[16:13:04.780]         }, add = TRUE)
[16:13:04.780]     }
[16:13:04.780]     ...future.frame <- base::sys.nframe()
[16:13:04.780]     ...future.conditions <- base::list()
[16:13:04.780]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:04.780]     if (FALSE) {
[16:13:04.780]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:04.780]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:04.780]     }
[16:13:04.780]     ...future.result <- base::tryCatch({
[16:13:04.780]         base::withCallingHandlers({
[16:13:04.780]             ...future.value <- base::withVisible(base::local({
[16:13:04.780]                 withCallingHandlers({
[16:13:04.780]                   {
[16:13:04.780]                     stop(structure(list(message = "boom"), class = c("MyError", 
[16:13:04.780]                       "error", "condition")))
[16:13:04.780]                   }
[16:13:04.780]                 }, immediateCondition = function(cond) {
[16:13:04.780]                   save_rds <- function (object, pathname, ...) 
[16:13:04.780]                   {
[16:13:04.780]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:04.780]                     if (file_test("-f", pathname_tmp)) {
[16:13:04.780]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.780]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:04.780]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.780]                         fi_tmp[["mtime"]])
[16:13:04.780]                     }
[16:13:04.780]                     tryCatch({
[16:13:04.780]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:04.780]                     }, error = function(ex) {
[16:13:04.780]                       msg <- conditionMessage(ex)
[16:13:04.780]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.780]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:04.780]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.780]                         fi_tmp[["mtime"]], msg)
[16:13:04.780]                       ex$message <- msg
[16:13:04.780]                       stop(ex)
[16:13:04.780]                     })
[16:13:04.780]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:04.780]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:04.780]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:04.780]                       fi_tmp <- file.info(pathname_tmp)
[16:13:04.780]                       fi <- file.info(pathname)
[16:13:04.780]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:04.780]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:04.780]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:04.780]                         fi[["size"]], fi[["mtime"]])
[16:13:04.780]                       stop(msg)
[16:13:04.780]                     }
[16:13:04.780]                     invisible(pathname)
[16:13:04.780]                   }
[16:13:04.780]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:04.780]                     rootPath = tempdir()) 
[16:13:04.780]                   {
[16:13:04.780]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:04.780]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:04.780]                       tmpdir = path, fileext = ".rds")
[16:13:04.780]                     save_rds(obj, file)
[16:13:04.780]                   }
[16:13:04.780]                   saveImmediateCondition(cond, path = "/tmp/RtmpmgpgJ1/.future/immediateConditions")
[16:13:04.780]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.780]                   {
[16:13:04.780]                     inherits <- base::inherits
[16:13:04.780]                     invokeRestart <- base::invokeRestart
[16:13:04.780]                     is.null <- base::is.null
[16:13:04.780]                     muffled <- FALSE
[16:13:04.780]                     if (inherits(cond, "message")) {
[16:13:04.780]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:04.780]                       if (muffled) 
[16:13:04.780]                         invokeRestart("muffleMessage")
[16:13:04.780]                     }
[16:13:04.780]                     else if (inherits(cond, "warning")) {
[16:13:04.780]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:04.780]                       if (muffled) 
[16:13:04.780]                         invokeRestart("muffleWarning")
[16:13:04.780]                     }
[16:13:04.780]                     else if (inherits(cond, "condition")) {
[16:13:04.780]                       if (!is.null(pattern)) {
[16:13:04.780]                         computeRestarts <- base::computeRestarts
[16:13:04.780]                         grepl <- base::grepl
[16:13:04.780]                         restarts <- computeRestarts(cond)
[16:13:04.780]                         for (restart in restarts) {
[16:13:04.780]                           name <- restart$name
[16:13:04.780]                           if (is.null(name)) 
[16:13:04.780]                             next
[16:13:04.780]                           if (!grepl(pattern, name)) 
[16:13:04.780]                             next
[16:13:04.780]                           invokeRestart(restart)
[16:13:04.780]                           muffled <- TRUE
[16:13:04.780]                           break
[16:13:04.780]                         }
[16:13:04.780]                       }
[16:13:04.780]                     }
[16:13:04.780]                     invisible(muffled)
[16:13:04.780]                   }
[16:13:04.780]                   muffleCondition(cond)
[16:13:04.780]                 })
[16:13:04.780]             }))
[16:13:04.780]             future::FutureResult(value = ...future.value$value, 
[16:13:04.780]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.780]                   ...future.rng), globalenv = if (FALSE) 
[16:13:04.780]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:04.780]                     ...future.globalenv.names))
[16:13:04.780]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:04.780]         }, condition = base::local({
[16:13:04.780]             c <- base::c
[16:13:04.780]             inherits <- base::inherits
[16:13:04.780]             invokeRestart <- base::invokeRestart
[16:13:04.780]             length <- base::length
[16:13:04.780]             list <- base::list
[16:13:04.780]             seq.int <- base::seq.int
[16:13:04.780]             signalCondition <- base::signalCondition
[16:13:04.780]             sys.calls <- base::sys.calls
[16:13:04.780]             `[[` <- base::`[[`
[16:13:04.780]             `+` <- base::`+`
[16:13:04.780]             `<<-` <- base::`<<-`
[16:13:04.780]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:04.780]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:04.780]                   3L)]
[16:13:04.780]             }
[16:13:04.780]             function(cond) {
[16:13:04.780]                 is_error <- inherits(cond, "error")
[16:13:04.780]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:04.780]                   NULL)
[16:13:04.780]                 if (is_error) {
[16:13:04.780]                   sessionInformation <- function() {
[16:13:04.780]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:04.780]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:04.780]                       search = base::search(), system = base::Sys.info())
[16:13:04.780]                   }
[16:13:04.780]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.780]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:04.780]                     cond$call), session = sessionInformation(), 
[16:13:04.780]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:04.780]                   signalCondition(cond)
[16:13:04.780]                 }
[16:13:04.780]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:04.780]                 "immediateCondition"))) {
[16:13:04.780]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:04.780]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.780]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:04.780]                   if (TRUE && !signal) {
[16:13:04.780]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.780]                     {
[16:13:04.780]                       inherits <- base::inherits
[16:13:04.780]                       invokeRestart <- base::invokeRestart
[16:13:04.780]                       is.null <- base::is.null
[16:13:04.780]                       muffled <- FALSE
[16:13:04.780]                       if (inherits(cond, "message")) {
[16:13:04.780]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.780]                         if (muffled) 
[16:13:04.780]                           invokeRestart("muffleMessage")
[16:13:04.780]                       }
[16:13:04.780]                       else if (inherits(cond, "warning")) {
[16:13:04.780]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.780]                         if (muffled) 
[16:13:04.780]                           invokeRestart("muffleWarning")
[16:13:04.780]                       }
[16:13:04.780]                       else if (inherits(cond, "condition")) {
[16:13:04.780]                         if (!is.null(pattern)) {
[16:13:04.780]                           computeRestarts <- base::computeRestarts
[16:13:04.780]                           grepl <- base::grepl
[16:13:04.780]                           restarts <- computeRestarts(cond)
[16:13:04.780]                           for (restart in restarts) {
[16:13:04.780]                             name <- restart$name
[16:13:04.780]                             if (is.null(name)) 
[16:13:04.780]                               next
[16:13:04.780]                             if (!grepl(pattern, name)) 
[16:13:04.780]                               next
[16:13:04.780]                             invokeRestart(restart)
[16:13:04.780]                             muffled <- TRUE
[16:13:04.780]                             break
[16:13:04.780]                           }
[16:13:04.780]                         }
[16:13:04.780]                       }
[16:13:04.780]                       invisible(muffled)
[16:13:04.780]                     }
[16:13:04.780]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.780]                   }
[16:13:04.780]                 }
[16:13:04.780]                 else {
[16:13:04.780]                   if (TRUE) {
[16:13:04.780]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.780]                     {
[16:13:04.780]                       inherits <- base::inherits
[16:13:04.780]                       invokeRestart <- base::invokeRestart
[16:13:04.780]                       is.null <- base::is.null
[16:13:04.780]                       muffled <- FALSE
[16:13:04.780]                       if (inherits(cond, "message")) {
[16:13:04.780]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.780]                         if (muffled) 
[16:13:04.780]                           invokeRestart("muffleMessage")
[16:13:04.780]                       }
[16:13:04.780]                       else if (inherits(cond, "warning")) {
[16:13:04.780]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.780]                         if (muffled) 
[16:13:04.780]                           invokeRestart("muffleWarning")
[16:13:04.780]                       }
[16:13:04.780]                       else if (inherits(cond, "condition")) {
[16:13:04.780]                         if (!is.null(pattern)) {
[16:13:04.780]                           computeRestarts <- base::computeRestarts
[16:13:04.780]                           grepl <- base::grepl
[16:13:04.780]                           restarts <- computeRestarts(cond)
[16:13:04.780]                           for (restart in restarts) {
[16:13:04.780]                             name <- restart$name
[16:13:04.780]                             if (is.null(name)) 
[16:13:04.780]                               next
[16:13:04.780]                             if (!grepl(pattern, name)) 
[16:13:04.780]                               next
[16:13:04.780]                             invokeRestart(restart)
[16:13:04.780]                             muffled <- TRUE
[16:13:04.780]                             break
[16:13:04.780]                           }
[16:13:04.780]                         }
[16:13:04.780]                       }
[16:13:04.780]                       invisible(muffled)
[16:13:04.780]                     }
[16:13:04.780]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.780]                   }
[16:13:04.780]                 }
[16:13:04.780]             }
[16:13:04.780]         }))
[16:13:04.780]     }, error = function(ex) {
[16:13:04.780]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:04.780]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.780]                 ...future.rng), started = ...future.startTime, 
[16:13:04.780]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:04.780]             version = "1.8"), class = "FutureResult")
[16:13:04.780]     }, finally = {
[16:13:04.780]         if (!identical(...future.workdir, getwd())) 
[16:13:04.780]             setwd(...future.workdir)
[16:13:04.780]         {
[16:13:04.780]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:04.780]                 ...future.oldOptions$nwarnings <- NULL
[16:13:04.780]             }
[16:13:04.780]             base::options(...future.oldOptions)
[16:13:04.780]             if (.Platform$OS.type == "windows") {
[16:13:04.780]                 old_names <- names(...future.oldEnvVars)
[16:13:04.780]                 envs <- base::Sys.getenv()
[16:13:04.780]                 names <- names(envs)
[16:13:04.780]                 common <- intersect(names, old_names)
[16:13:04.780]                 added <- setdiff(names, old_names)
[16:13:04.780]                 removed <- setdiff(old_names, names)
[16:13:04.780]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:04.780]                   envs[common]]
[16:13:04.780]                 NAMES <- toupper(changed)
[16:13:04.780]                 args <- list()
[16:13:04.780]                 for (kk in seq_along(NAMES)) {
[16:13:04.780]                   name <- changed[[kk]]
[16:13:04.780]                   NAME <- NAMES[[kk]]
[16:13:04.780]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.780]                     next
[16:13:04.780]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.780]                 }
[16:13:04.780]                 NAMES <- toupper(added)
[16:13:04.780]                 for (kk in seq_along(NAMES)) {
[16:13:04.780]                   name <- added[[kk]]
[16:13:04.780]                   NAME <- NAMES[[kk]]
[16:13:04.780]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.780]                     next
[16:13:04.780]                   args[[name]] <- ""
[16:13:04.780]                 }
[16:13:04.780]                 NAMES <- toupper(removed)
[16:13:04.780]                 for (kk in seq_along(NAMES)) {
[16:13:04.780]                   name <- removed[[kk]]
[16:13:04.780]                   NAME <- NAMES[[kk]]
[16:13:04.780]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.780]                     next
[16:13:04.780]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.780]                 }
[16:13:04.780]                 if (length(args) > 0) 
[16:13:04.780]                   base::do.call(base::Sys.setenv, args = args)
[16:13:04.780]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:04.780]             }
[16:13:04.780]             else {
[16:13:04.780]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:04.780]             }
[16:13:04.780]             {
[16:13:04.780]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:04.780]                   0L) {
[16:13:04.780]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:04.780]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:04.780]                   base::options(opts)
[16:13:04.780]                 }
[16:13:04.780]                 {
[16:13:04.780]                   {
[16:13:04.780]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:04.780]                     NULL
[16:13:04.780]                   }
[16:13:04.780]                   options(future.plan = NULL)
[16:13:04.780]                   if (is.na(NA_character_)) 
[16:13:04.780]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.780]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:04.780]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:04.780]                     envir = parent.frame()) 
[16:13:04.780]                   {
[16:13:04.780]                     default_workers <- missing(workers)
[16:13:04.780]                     if (is.function(workers)) 
[16:13:04.780]                       workers <- workers()
[16:13:04.780]                     workers <- structure(as.integer(workers), 
[16:13:04.780]                       class = class(workers))
[16:13:04.780]                     stop_if_not(is.finite(workers), workers >= 
[16:13:04.780]                       1L)
[16:13:04.780]                     if ((workers == 1L && !inherits(workers, 
[16:13:04.780]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:04.780]                       if (default_workers) 
[16:13:04.780]                         supportsMulticore(warn = TRUE)
[16:13:04.780]                       return(sequential(..., envir = envir))
[16:13:04.780]                     }
[16:13:04.780]                     oopts <- options(mc.cores = workers)
[16:13:04.780]                     on.exit(options(oopts))
[16:13:04.780]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:04.780]                       envir = envir)
[16:13:04.780]                     if (!future$lazy) 
[16:13:04.780]                       future <- run(future)
[16:13:04.780]                     invisible(future)
[16:13:04.780]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:04.780]                 }
[16:13:04.780]             }
[16:13:04.780]         }
[16:13:04.780]     })
[16:13:04.780]     if (TRUE) {
[16:13:04.780]         base::sink(type = "output", split = FALSE)
[16:13:04.780]         if (TRUE) {
[16:13:04.780]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:04.780]         }
[16:13:04.780]         else {
[16:13:04.780]             ...future.result["stdout"] <- base::list(NULL)
[16:13:04.780]         }
[16:13:04.780]         base::close(...future.stdout)
[16:13:04.780]         ...future.stdout <- NULL
[16:13:04.780]     }
[16:13:04.780]     ...future.result$conditions <- ...future.conditions
[16:13:04.780]     ...future.result$finished <- base::Sys.time()
[16:13:04.780]     ...future.result
[16:13:04.780] }
[16:13:04.782] requestCore(): workers = 2
[16:13:04.785] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:13:04.786] plan(): Setting new future strategy stack:
[16:13:04.786] List of future strategies:
[16:13:04.786] 1. sequential:
[16:13:04.786]    - args: function (..., envir = parent.frame())
[16:13:04.786]    - tweaked: FALSE
[16:13:04.786]    - call: NULL
[16:13:04.787] plan(): nbrOfWorkers() = 1
[16:13:04.789] plan(): Setting new future strategy stack:
[16:13:04.789] List of future strategies:
[16:13:04.789] 1. multicore:
[16:13:04.789]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:04.789]    - tweaked: FALSE
[16:13:04.789]    - call: plan(multicore)
[16:13:04.794] plan(): nbrOfWorkers() = 2
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 9cd5072f-68f7-e4f0-6d65-cff53a745767
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:04.799] signalConditions() ...
[16:13:04.799]  - include = ‘immediateCondition’
[16:13:04.799]  - exclude = 
[16:13:04.799]  - resignal = FALSE
[16:13:04.799]  - Number of conditions: 1
[16:13:04.799] signalConditions() ... done
[16:13:04.799] signalConditions() ...
[16:13:04.800]  - include = ‘immediateCondition’
[16:13:04.800]  - exclude = 
[16:13:04.800]  - resignal = FALSE
[16:13:04.800]  - Number of conditions: 1
[16:13:04.800] signalConditions() ... done
<MyError: boom>
[16:13:04.800] signalConditions() ...
[16:13:04.800]  - include = ‘immediateCondition’
[16:13:04.801]  - exclude = 
[16:13:04.801]  - resignal = FALSE
[16:13:04.801]  - Number of conditions: 1
[16:13:04.801] signalConditions() ... done
[16:13:04.801] Future state: ‘finished’
[16:13:04.801] signalConditions() ...
[16:13:04.801]  - include = ‘condition’
[16:13:04.801]  - exclude = ‘immediateCondition’
[16:13:04.802]  - resignal = TRUE
[16:13:04.802]  - Number of conditions: 1
[16:13:04.802]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[16:13:04.802] signalConditions() ... done
*** multicore(..., workers = 1L) ...
[16:13:04.802] getGlobalsAndPackages() ...
[16:13:04.802] Searching for globals...
[16:13:04.804] - globals found: [4] ‘{’, ‘*’, ‘a’, ‘b’
[16:13:04.804] Searching for globals ... DONE
[16:13:04.804] Resolving globals: FALSE
[16:13:04.805] The total size of the 2 globals is 112 bytes (112 bytes)
[16:13:04.805] The total size of the 2 globals exported for future expression (‘{; a * b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘b’ (56 bytes of class ‘numeric’)
[16:13:04.805] - globals: [2] ‘a’, ‘b’
[16:13:04.805] 
[16:13:04.806] getGlobalsAndPackages() ... DONE
[16:13:04.806] Packages needed by the future expression (n = 0): <none>
[16:13:04.806] Packages needed by future strategies (n = 0): <none>
[16:13:04.807] {
[16:13:04.807]     {
[16:13:04.807]         {
[16:13:04.807]             ...future.startTime <- base::Sys.time()
[16:13:04.807]             {
[16:13:04.807]                 {
[16:13:04.807]                   {
[16:13:04.807]                     base::local({
[16:13:04.807]                       has_future <- base::requireNamespace("future", 
[16:13:04.807]                         quietly = TRUE)
[16:13:04.807]                       if (has_future) {
[16:13:04.807]                         ns <- base::getNamespace("future")
[16:13:04.807]                         version <- ns[[".package"]][["version"]]
[16:13:04.807]                         if (is.null(version)) 
[16:13:04.807]                           version <- utils::packageVersion("future")
[16:13:04.807]                       }
[16:13:04.807]                       else {
[16:13:04.807]                         version <- NULL
[16:13:04.807]                       }
[16:13:04.807]                       if (!has_future || version < "1.8.0") {
[16:13:04.807]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:04.807]                           "", base::R.version$version.string), 
[16:13:04.807]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:04.807]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:04.807]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:04.807]                             "release", "version")], collapse = " "), 
[16:13:04.807]                           hostname = base::Sys.info()[["nodename"]])
[16:13:04.807]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:04.807]                           info)
[16:13:04.807]                         info <- base::paste(info, collapse = "; ")
[16:13:04.807]                         if (!has_future) {
[16:13:04.807]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:04.807]                             info)
[16:13:04.807]                         }
[16:13:04.807]                         else {
[16:13:04.807]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:04.807]                             info, version)
[16:13:04.807]                         }
[16:13:04.807]                         base::stop(msg)
[16:13:04.807]                       }
[16:13:04.807]                     })
[16:13:04.807]                   }
[16:13:04.807]                   options(future.plan = NULL)
[16:13:04.807]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.807]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:04.807]                 }
[16:13:04.807]                 ...future.workdir <- getwd()
[16:13:04.807]             }
[16:13:04.807]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:04.807]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:04.807]         }
[16:13:04.807]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:04.807]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:04.807]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:04.807]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:04.807]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:04.807]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:04.807]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:04.807]             base::names(...future.oldOptions))
[16:13:04.807]     }
[16:13:04.807]     if (FALSE) {
[16:13:04.807]     }
[16:13:04.807]     else {
[16:13:04.807]         if (TRUE) {
[16:13:04.807]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:04.807]                 open = "w")
[16:13:04.807]         }
[16:13:04.807]         else {
[16:13:04.807]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:04.807]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:04.807]         }
[16:13:04.807]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:04.807]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:04.807]             base::sink(type = "output", split = FALSE)
[16:13:04.807]             base::close(...future.stdout)
[16:13:04.807]         }, add = TRUE)
[16:13:04.807]     }
[16:13:04.807]     ...future.frame <- base::sys.nframe()
[16:13:04.807]     ...future.conditions <- base::list()
[16:13:04.807]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:04.807]     if (FALSE) {
[16:13:04.807]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:04.807]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:04.807]     }
[16:13:04.807]     ...future.result <- base::tryCatch({
[16:13:04.807]         base::withCallingHandlers({
[16:13:04.807]             ...future.value <- base::withVisible(base::local({
[16:13:04.807]                 a * b
[16:13:04.807]             }))
[16:13:04.807]             future::FutureResult(value = ...future.value$value, 
[16:13:04.807]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.807]                   ...future.rng), globalenv = if (FALSE) 
[16:13:04.807]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:04.807]                     ...future.globalenv.names))
[16:13:04.807]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:04.807]         }, condition = base::local({
[16:13:04.807]             c <- base::c
[16:13:04.807]             inherits <- base::inherits
[16:13:04.807]             invokeRestart <- base::invokeRestart
[16:13:04.807]             length <- base::length
[16:13:04.807]             list <- base::list
[16:13:04.807]             seq.int <- base::seq.int
[16:13:04.807]             signalCondition <- base::signalCondition
[16:13:04.807]             sys.calls <- base::sys.calls
[16:13:04.807]             `[[` <- base::`[[`
[16:13:04.807]             `+` <- base::`+`
[16:13:04.807]             `<<-` <- base::`<<-`
[16:13:04.807]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:04.807]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:04.807]                   3L)]
[16:13:04.807]             }
[16:13:04.807]             function(cond) {
[16:13:04.807]                 is_error <- inherits(cond, "error")
[16:13:04.807]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:04.807]                   NULL)
[16:13:04.807]                 if (is_error) {
[16:13:04.807]                   sessionInformation <- function() {
[16:13:04.807]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:04.807]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:04.807]                       search = base::search(), system = base::Sys.info())
[16:13:04.807]                   }
[16:13:04.807]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.807]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:04.807]                     cond$call), session = sessionInformation(), 
[16:13:04.807]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:04.807]                   signalCondition(cond)
[16:13:04.807]                 }
[16:13:04.807]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:04.807]                 "immediateCondition"))) {
[16:13:04.807]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:04.807]                   ...future.conditions[[length(...future.conditions) + 
[16:13:04.807]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:04.807]                   if (TRUE && !signal) {
[16:13:04.807]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.807]                     {
[16:13:04.807]                       inherits <- base::inherits
[16:13:04.807]                       invokeRestart <- base::invokeRestart
[16:13:04.807]                       is.null <- base::is.null
[16:13:04.807]                       muffled <- FALSE
[16:13:04.807]                       if (inherits(cond, "message")) {
[16:13:04.807]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.807]                         if (muffled) 
[16:13:04.807]                           invokeRestart("muffleMessage")
[16:13:04.807]                       }
[16:13:04.807]                       else if (inherits(cond, "warning")) {
[16:13:04.807]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.807]                         if (muffled) 
[16:13:04.807]                           invokeRestart("muffleWarning")
[16:13:04.807]                       }
[16:13:04.807]                       else if (inherits(cond, "condition")) {
[16:13:04.807]                         if (!is.null(pattern)) {
[16:13:04.807]                           computeRestarts <- base::computeRestarts
[16:13:04.807]                           grepl <- base::grepl
[16:13:04.807]                           restarts <- computeRestarts(cond)
[16:13:04.807]                           for (restart in restarts) {
[16:13:04.807]                             name <- restart$name
[16:13:04.807]                             if (is.null(name)) 
[16:13:04.807]                               next
[16:13:04.807]                             if (!grepl(pattern, name)) 
[16:13:04.807]                               next
[16:13:04.807]                             invokeRestart(restart)
[16:13:04.807]                             muffled <- TRUE
[16:13:04.807]                             break
[16:13:04.807]                           }
[16:13:04.807]                         }
[16:13:04.807]                       }
[16:13:04.807]                       invisible(muffled)
[16:13:04.807]                     }
[16:13:04.807]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.807]                   }
[16:13:04.807]                 }
[16:13:04.807]                 else {
[16:13:04.807]                   if (TRUE) {
[16:13:04.807]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:04.807]                     {
[16:13:04.807]                       inherits <- base::inherits
[16:13:04.807]                       invokeRestart <- base::invokeRestart
[16:13:04.807]                       is.null <- base::is.null
[16:13:04.807]                       muffled <- FALSE
[16:13:04.807]                       if (inherits(cond, "message")) {
[16:13:04.807]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:04.807]                         if (muffled) 
[16:13:04.807]                           invokeRestart("muffleMessage")
[16:13:04.807]                       }
[16:13:04.807]                       else if (inherits(cond, "warning")) {
[16:13:04.807]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:04.807]                         if (muffled) 
[16:13:04.807]                           invokeRestart("muffleWarning")
[16:13:04.807]                       }
[16:13:04.807]                       else if (inherits(cond, "condition")) {
[16:13:04.807]                         if (!is.null(pattern)) {
[16:13:04.807]                           computeRestarts <- base::computeRestarts
[16:13:04.807]                           grepl <- base::grepl
[16:13:04.807]                           restarts <- computeRestarts(cond)
[16:13:04.807]                           for (restart in restarts) {
[16:13:04.807]                             name <- restart$name
[16:13:04.807]                             if (is.null(name)) 
[16:13:04.807]                               next
[16:13:04.807]                             if (!grepl(pattern, name)) 
[16:13:04.807]                               next
[16:13:04.807]                             invokeRestart(restart)
[16:13:04.807]                             muffled <- TRUE
[16:13:04.807]                             break
[16:13:04.807]                           }
[16:13:04.807]                         }
[16:13:04.807]                       }
[16:13:04.807]                       invisible(muffled)
[16:13:04.807]                     }
[16:13:04.807]                     muffleCondition(cond, pattern = "^muffle")
[16:13:04.807]                   }
[16:13:04.807]                 }
[16:13:04.807]             }
[16:13:04.807]         }))
[16:13:04.807]     }, error = function(ex) {
[16:13:04.807]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:04.807]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:04.807]                 ...future.rng), started = ...future.startTime, 
[16:13:04.807]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:04.807]             version = "1.8"), class = "FutureResult")
[16:13:04.807]     }, finally = {
[16:13:04.807]         if (!identical(...future.workdir, getwd())) 
[16:13:04.807]             setwd(...future.workdir)
[16:13:04.807]         {
[16:13:04.807]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:04.807]                 ...future.oldOptions$nwarnings <- NULL
[16:13:04.807]             }
[16:13:04.807]             base::options(...future.oldOptions)
[16:13:04.807]             if (.Platform$OS.type == "windows") {
[16:13:04.807]                 old_names <- names(...future.oldEnvVars)
[16:13:04.807]                 envs <- base::Sys.getenv()
[16:13:04.807]                 names <- names(envs)
[16:13:04.807]                 common <- intersect(names, old_names)
[16:13:04.807]                 added <- setdiff(names, old_names)
[16:13:04.807]                 removed <- setdiff(old_names, names)
[16:13:04.807]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:04.807]                   envs[common]]
[16:13:04.807]                 NAMES <- toupper(changed)
[16:13:04.807]                 args <- list()
[16:13:04.807]                 for (kk in seq_along(NAMES)) {
[16:13:04.807]                   name <- changed[[kk]]
[16:13:04.807]                   NAME <- NAMES[[kk]]
[16:13:04.807]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.807]                     next
[16:13:04.807]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.807]                 }
[16:13:04.807]                 NAMES <- toupper(added)
[16:13:04.807]                 for (kk in seq_along(NAMES)) {
[16:13:04.807]                   name <- added[[kk]]
[16:13:04.807]                   NAME <- NAMES[[kk]]
[16:13:04.807]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.807]                     next
[16:13:04.807]                   args[[name]] <- ""
[16:13:04.807]                 }
[16:13:04.807]                 NAMES <- toupper(removed)
[16:13:04.807]                 for (kk in seq_along(NAMES)) {
[16:13:04.807]                   name <- removed[[kk]]
[16:13:04.807]                   NAME <- NAMES[[kk]]
[16:13:04.807]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:04.807]                     next
[16:13:04.807]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:04.807]                 }
[16:13:04.807]                 if (length(args) > 0) 
[16:13:04.807]                   base::do.call(base::Sys.setenv, args = args)
[16:13:04.807]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:04.807]             }
[16:13:04.807]             else {
[16:13:04.807]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:04.807]             }
[16:13:04.807]             {
[16:13:04.807]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:04.807]                   0L) {
[16:13:04.807]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:04.807]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:04.807]                   base::options(opts)
[16:13:04.807]                 }
[16:13:04.807]                 {
[16:13:04.807]                   {
[16:13:04.807]                     NULL
[16:13:04.807]                     RNGkind("Mersenne-Twister")
[16:13:04.807]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:04.807]                       inherits = FALSE)
[16:13:04.807]                   }
[16:13:04.807]                   options(future.plan = NULL)
[16:13:04.807]                   if (is.na(NA_character_)) 
[16:13:04.807]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:04.807]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:04.807]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:04.807]                     envir = parent.frame()) 
[16:13:04.807]                   {
[16:13:04.807]                     default_workers <- missing(workers)
[16:13:04.807]                     if (is.function(workers)) 
[16:13:04.807]                       workers <- workers()
[16:13:04.807]                     workers <- structure(as.integer(workers), 
[16:13:04.807]                       class = class(workers))
[16:13:04.807]                     stop_if_not(is.finite(workers), workers >= 
[16:13:04.807]                       1L)
[16:13:04.807]                     if ((workers == 1L && !inherits(workers, 
[16:13:04.807]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:04.807]                       if (default_workers) 
[16:13:04.807]                         supportsMulticore(warn = TRUE)
[16:13:04.807]                       return(sequential(..., envir = envir))
[16:13:04.807]                     }
[16:13:04.807]                     oopts <- options(mc.cores = workers)
[16:13:04.807]                     on.exit(options(oopts))
[16:13:04.807]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:04.807]                       envir = envir)
[16:13:04.807]                     if (!future$lazy) 
[16:13:04.807]                       future <- run(future)
[16:13:04.807]                     invisible(future)
[16:13:04.807]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:04.807]                 }
[16:13:04.807]             }
[16:13:04.807]         }
[16:13:04.807]     })
[16:13:04.807]     if (TRUE) {
[16:13:04.807]         base::sink(type = "output", split = FALSE)
[16:13:04.807]         if (TRUE) {
[16:13:04.807]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:04.807]         }
[16:13:04.807]         else {
[16:13:04.807]             ...future.result["stdout"] <- base::list(NULL)
[16:13:04.807]         }
[16:13:04.807]         base::close(...future.stdout)
[16:13:04.807]         ...future.stdout <- NULL
[16:13:04.807]     }
[16:13:04.807]     ...future.result$conditions <- ...future.conditions
[16:13:04.807]     ...future.result$finished <- base::Sys.time()
[16:13:04.807]     ...future.result
[16:13:04.807] }
[16:13:04.809] assign_globals() ...
[16:13:04.809] List of 2
[16:13:04.809]  $ a: num 2
[16:13:04.809]  $ b: num 3
[16:13:04.809]  - attr(*, "where")=List of 2
[16:13:04.809]   ..$ a:<environment: R_EmptyEnv> 
[16:13:04.809]   ..$ b:<environment: R_EmptyEnv> 
[16:13:04.809]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:04.809]  - attr(*, "resolved")= logi FALSE
[16:13:04.809]  - attr(*, "total_size")= num 112
[16:13:04.812] - copied ‘a’ to environment
[16:13:04.813] - copied ‘b’ to environment
[16:13:04.813] assign_globals() ... done
[16:13:04.814] plan(): Setting new future strategy stack:
[16:13:04.814] List of future strategies:
[16:13:04.814] 1. sequential:
[16:13:04.814]    - args: function (..., envir = parent.frame())
[16:13:04.814]    - tweaked: FALSE
[16:13:04.814]    - call: NULL
[16:13:04.814] plan(): nbrOfWorkers() = 1
[16:13:04.818] plan(): Setting new future strategy stack:
[16:13:04.818] List of future strategies:
[16:13:04.818] 1. multicore:
[16:13:04.818]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:04.818]    - tweaked: FALSE
[16:13:04.818]    - call: plan(multicore)
[16:13:04.822] plan(): nbrOfWorkers() = 2
[16:13:04.822] SequentialFuture started (and completed)
[1] 6
*** multicore(..., workers = 1L) ... DONE
Testing with 2 cores ... DONE
> 
> message("*** multicore() ... DONE")
*** multicore() ... DONE
> 
> source("incl/end.R")
[16:13:04.824] plan(): Setting new future strategy stack:
[16:13:04.824] List of future strategies:
[16:13:04.824] 1. FutureStrategy:
[16:13:04.824]    - args: function (..., envir = parent.frame())
[16:13:04.824]    - tweaked: FALSE
[16:13:04.824]    - call: future::plan(oplan)
[16:13:04.824] plan(): nbrOfWorkers() = 1
> 
