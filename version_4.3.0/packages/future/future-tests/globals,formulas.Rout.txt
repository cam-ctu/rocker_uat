
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[17:42:25.725] plan(): Setting new future strategy stack:
[17:42:25.726] List of future strategies:
[17:42:25.726] 1. sequential:
[17:42:25.726]    - args: function (..., envir = parent.frame())
[17:42:25.726]    - tweaked: FALSE
[17:42:25.726]    - call: future::plan("sequential")
[17:42:25.739] plan(): nbrOfWorkers() = 1
> 
> library("datasets") ## cars data set
> library("stats")    ## lm(), poly(), xtabs()
> 
> message("*** Globals - formulas ...")
*** Globals - formulas ...
> 
> ## (i) lm(<formula>):
> ## From example("lm", package = "stats")
> ctl <- c(4.17, 5.58, 5.18, 6.11, 4.50, 4.61, 5.17, 4.53, 5.33, 5.14)
> trt <- c(4.81, 4.17, 4.41, 3.59, 5.87, 3.83, 6.03, 4.89, 4.32, 4.69)
> group <- gl(2, 10, 20, labels = c("Ctl", "Trt"))
> weight <- c(ctl, trt)
> ctl <- trt <- NULL
> ## Truth:
> fit_i <- lm(weight ~ group - 1)
> print(fit_i)

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

> 
> ## (ii) xtabs(~ x):
> x <- c(1, 1, 2, 2, 2)
> ## Truth:
> tbl_ii <- xtabs(~ x)
> print(tbl_ii)
x
1 2 
2 3 
> 
> ## (iii) lm(<formula>, data = cars):
> exprs <- list(
+   # "remove-intercept-term" form of no-intercept
+   a = substitute({ lm(dist ~ . -1, data = cars) }),
+   # "make-intercept-zero" form of no-intercept
+   b = substitute({ lm(dist ~ . +0, data = cars) }),
+   # doesn't do what we want here
+   c = substitute({ lm(dist ~ speed + speed ^ 2, data = cars) }),
+   # gets us a quadratic term
+   d = substitute({ lm(dist ~ speed + I(speed ^ 2), data = cars) }),
+   # avoid potential multicollinearity
+   e = substitute({ lm(dist ~ poly(speed, 2), data = cars) })
+ )
> 
> ## (iv) Globals - map(x, ~ expr):
> ## A fake purrr::map() function with limited functionality
> map <- function(.x, .f, ...) {
+   if (inherits(.f, "formula")) {
+     expr <- .f[[-1]]
+     .f <- eval(bquote(function(...) {
+       .(expr)
+     }))
+   }
+   eval(lapply(.x, FUN = .f, ...))
+ }
> 
> inner_function <- function(x) { x + 1 }
> 
> outer_function <- function(x) {
+   map(1:2, ~ inner_function(.x))
+ }
> 
> y_iv <- outer_function(1L)
> str(y_iv)
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
> 
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     message("- lm(<formula>) ...")
+     
+     ## Explicit future
+     f <- future({ lm(weight ~ group - 1) })
+     fit <- value(f)
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Explicit future (lazy)
+     f <- future({ lm(weight ~ group - 1) }, lazy = TRUE)
+     fit <- value(f)
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment
+     fit %<-% { lm(weight ~ group - 1) }
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment (non-lazy)
+     fit %<-% { lm(weight ~ group - 1) } %lazy% FALSE
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment (lazy)
+     fit %<-% { lm(weight ~ group - 1) } %lazy% TRUE
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     message("- Globals - one-side formulas, e.g. xtabs(~ x) ...")
+     ## Explicit future
+     f <- future({ xtabs(~ x) })
+     tbl <- value(f)
+     print(tbl)
+     stopifnot(all.equal(tbl, tbl_ii))
+ 
+     ## Future assignment
+     tbl %<-% { xtabs(~ x) }
+     print(tbl)
+     stopifnot(all.equal(tbl, tbl_ii))
+ 
+     message("- Globals - lm(<formula>, data = cars) ...")
+     for (kk in seq_along(exprs)) {
+       expr <- exprs[[kk]]
+       name <- names(exprs)[kk]
+       message(sprintf("- Globals - lm(<formula #%d (%s)>, data = cars) ...",
+                       kk, sQuote(name)))
+     
+       fit_iii <- eval(expr)
+       print(fit_iii)
+     
+       f <- future(expr, substitute = FALSE)
+       fit <- value(f)
+       print(fit)
+     
+       stopifnot(all.equal(fit, fit_iii))
+     } ## for (kk ...)
+ 
+     message("- Globals - map(x, ~ expr) ...")
+     f <- future({ outer_function(1L) })
+     y <- value(f)
+     str(y)
+     stopifnot(all.equal(y, y_iv))
+ 
+     y %<-% { outer_function(1L) }
+     str(y)
+     stopifnot(all.equal(y, y_iv))
+   } ## for (strategy ...)
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- plan('sequential') ...
[17:42:25.797] plan(): Setting new future strategy stack:
[17:42:25.797] List of future strategies:
[17:42:25.797] 1. sequential:
[17:42:25.797]    - args: function (..., envir = parent.frame())
[17:42:25.797]    - tweaked: FALSE
[17:42:25.797]    - call: plan(strategy)
[17:42:25.810] plan(): nbrOfWorkers() = 1
- lm(<formula>) ...
[17:42:25.811] getGlobalsAndPackages() ...
[17:42:25.811] Searching for globals...
[17:42:25.818] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:42:25.818] Searching for globals ... DONE
[17:42:25.818] Resolving globals: FALSE
[17:42:25.819] The total size of the 2 globals is 896 bytes (896 bytes)
[17:42:25.820] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:42:25.820] - globals: [2] ‘weight’, ‘group’
[17:42:25.820] - packages: [1] ‘stats’
[17:42:25.820] getGlobalsAndPackages() ... DONE
[17:42:25.821] run() for ‘Future’ ...
[17:42:25.821] - state: ‘created’
[17:42:25.821] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:25.821] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:25.822] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:25.822]   - Field: ‘label’
[17:42:25.822]   - Field: ‘local’
[17:42:25.822]   - Field: ‘owner’
[17:42:25.822]   - Field: ‘envir’
[17:42:25.822]   - Field: ‘packages’
[17:42:25.822]   - Field: ‘gc’
[17:42:25.822]   - Field: ‘conditions’
[17:42:25.822]   - Field: ‘expr’
[17:42:25.822]   - Field: ‘uuid’
[17:42:25.823]   - Field: ‘seed’
[17:42:25.823]   - Field: ‘version’
[17:42:25.823]   - Field: ‘result’
[17:42:25.823]   - Field: ‘asynchronous’
[17:42:25.823]   - Field: ‘calls’
[17:42:25.823]   - Field: ‘globals’
[17:42:25.823]   - Field: ‘stdout’
[17:42:25.823]   - Field: ‘earlySignal’
[17:42:25.823]   - Field: ‘lazy’
[17:42:25.823]   - Field: ‘state’
[17:42:25.824] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:25.824] - Launch lazy future ...
[17:42:25.824] Packages needed by the future expression (n = 1): ‘stats’
[17:42:25.825] Packages needed by future strategies (n = 0): <none>
[17:42:25.825] {
[17:42:25.825]     {
[17:42:25.825]         {
[17:42:25.825]             ...future.startTime <- base::Sys.time()
[17:42:25.825]             {
[17:42:25.825]                 {
[17:42:25.825]                   {
[17:42:25.825]                     {
[17:42:25.825]                       base::local({
[17:42:25.825]                         has_future <- base::requireNamespace("future", 
[17:42:25.825]                           quietly = TRUE)
[17:42:25.825]                         if (has_future) {
[17:42:25.825]                           ns <- base::getNamespace("future")
[17:42:25.825]                           version <- ns[[".package"]][["version"]]
[17:42:25.825]                           if (is.null(version)) 
[17:42:25.825]                             version <- utils::packageVersion("future")
[17:42:25.825]                         }
[17:42:25.825]                         else {
[17:42:25.825]                           version <- NULL
[17:42:25.825]                         }
[17:42:25.825]                         if (!has_future || version < "1.8.0") {
[17:42:25.825]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:25.825]                             "", base::R.version$version.string), 
[17:42:25.825]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:25.825]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:25.825]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:25.825]                               "release", "version")], collapse = " "), 
[17:42:25.825]                             hostname = base::Sys.info()[["nodename"]])
[17:42:25.825]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:25.825]                             info)
[17:42:25.825]                           info <- base::paste(info, collapse = "; ")
[17:42:25.825]                           if (!has_future) {
[17:42:25.825]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:25.825]                               info)
[17:42:25.825]                           }
[17:42:25.825]                           else {
[17:42:25.825]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:25.825]                               info, version)
[17:42:25.825]                           }
[17:42:25.825]                           base::stop(msg)
[17:42:25.825]                         }
[17:42:25.825]                       })
[17:42:25.825]                     }
[17:42:25.825]                     base::local({
[17:42:25.825]                       for (pkg in "stats") {
[17:42:25.825]                         base::loadNamespace(pkg)
[17:42:25.825]                         base::library(pkg, character.only = TRUE)
[17:42:25.825]                       }
[17:42:25.825]                     })
[17:42:25.825]                   }
[17:42:25.825]                   options(future.plan = NULL)
[17:42:25.825]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:25.825]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:25.825]                 }
[17:42:25.825]                 ...future.workdir <- getwd()
[17:42:25.825]             }
[17:42:25.825]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:25.825]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:25.825]         }
[17:42:25.825]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:25.825]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:25.825]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:25.825]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:25.825]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:25.825]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:25.825]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:25.825]             base::names(...future.oldOptions))
[17:42:25.825]     }
[17:42:25.825]     if (FALSE) {
[17:42:25.825]     }
[17:42:25.825]     else {
[17:42:25.825]         if (TRUE) {
[17:42:25.825]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:25.825]                 open = "w")
[17:42:25.825]         }
[17:42:25.825]         else {
[17:42:25.825]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:25.825]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:25.825]         }
[17:42:25.825]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:25.825]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:25.825]             base::sink(type = "output", split = FALSE)
[17:42:25.825]             base::close(...future.stdout)
[17:42:25.825]         }, add = TRUE)
[17:42:25.825]     }
[17:42:25.825]     ...future.frame <- base::sys.nframe()
[17:42:25.825]     ...future.conditions <- base::list()
[17:42:25.825]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:25.825]     if (FALSE) {
[17:42:25.825]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:25.825]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:25.825]     }
[17:42:25.825]     ...future.result <- base::tryCatch({
[17:42:25.825]         base::withCallingHandlers({
[17:42:25.825]             ...future.value <- base::withVisible(base::local({
[17:42:25.825]                 lm(weight ~ group - 1)
[17:42:25.825]             }))
[17:42:25.825]             future::FutureResult(value = ...future.value$value, 
[17:42:25.825]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:25.825]                   ...future.rng), globalenv = if (FALSE) 
[17:42:25.825]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:25.825]                     ...future.globalenv.names))
[17:42:25.825]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:25.825]         }, condition = base::local({
[17:42:25.825]             c <- base::c
[17:42:25.825]             inherits <- base::inherits
[17:42:25.825]             invokeRestart <- base::invokeRestart
[17:42:25.825]             length <- base::length
[17:42:25.825]             list <- base::list
[17:42:25.825]             seq.int <- base::seq.int
[17:42:25.825]             signalCondition <- base::signalCondition
[17:42:25.825]             sys.calls <- base::sys.calls
[17:42:25.825]             `[[` <- base::`[[`
[17:42:25.825]             `+` <- base::`+`
[17:42:25.825]             `<<-` <- base::`<<-`
[17:42:25.825]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:25.825]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:25.825]                   3L)]
[17:42:25.825]             }
[17:42:25.825]             function(cond) {
[17:42:25.825]                 is_error <- inherits(cond, "error")
[17:42:25.825]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:25.825]                   NULL)
[17:42:25.825]                 if (is_error) {
[17:42:25.825]                   sessionInformation <- function() {
[17:42:25.825]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:25.825]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:25.825]                       search = base::search(), system = base::Sys.info())
[17:42:25.825]                   }
[17:42:25.825]                   ...future.conditions[[length(...future.conditions) + 
[17:42:25.825]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:25.825]                     cond$call), session = sessionInformation(), 
[17:42:25.825]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:25.825]                   signalCondition(cond)
[17:42:25.825]                 }
[17:42:25.825]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:25.825]                 "immediateCondition"))) {
[17:42:25.825]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:25.825]                   ...future.conditions[[length(...future.conditions) + 
[17:42:25.825]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:25.825]                   if (TRUE && !signal) {
[17:42:25.825]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:25.825]                     {
[17:42:25.825]                       inherits <- base::inherits
[17:42:25.825]                       invokeRestart <- base::invokeRestart
[17:42:25.825]                       is.null <- base::is.null
[17:42:25.825]                       muffled <- FALSE
[17:42:25.825]                       if (inherits(cond, "message")) {
[17:42:25.825]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:25.825]                         if (muffled) 
[17:42:25.825]                           invokeRestart("muffleMessage")
[17:42:25.825]                       }
[17:42:25.825]                       else if (inherits(cond, "warning")) {
[17:42:25.825]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:25.825]                         if (muffled) 
[17:42:25.825]                           invokeRestart("muffleWarning")
[17:42:25.825]                       }
[17:42:25.825]                       else if (inherits(cond, "condition")) {
[17:42:25.825]                         if (!is.null(pattern)) {
[17:42:25.825]                           computeRestarts <- base::computeRestarts
[17:42:25.825]                           grepl <- base::grepl
[17:42:25.825]                           restarts <- computeRestarts(cond)
[17:42:25.825]                           for (restart in restarts) {
[17:42:25.825]                             name <- restart$name
[17:42:25.825]                             if (is.null(name)) 
[17:42:25.825]                               next
[17:42:25.825]                             if (!grepl(pattern, name)) 
[17:42:25.825]                               next
[17:42:25.825]                             invokeRestart(restart)
[17:42:25.825]                             muffled <- TRUE
[17:42:25.825]                             break
[17:42:25.825]                           }
[17:42:25.825]                         }
[17:42:25.825]                       }
[17:42:25.825]                       invisible(muffled)
[17:42:25.825]                     }
[17:42:25.825]                     muffleCondition(cond, pattern = "^muffle")
[17:42:25.825]                   }
[17:42:25.825]                 }
[17:42:25.825]                 else {
[17:42:25.825]                   if (TRUE) {
[17:42:25.825]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:25.825]                     {
[17:42:25.825]                       inherits <- base::inherits
[17:42:25.825]                       invokeRestart <- base::invokeRestart
[17:42:25.825]                       is.null <- base::is.null
[17:42:25.825]                       muffled <- FALSE
[17:42:25.825]                       if (inherits(cond, "message")) {
[17:42:25.825]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:25.825]                         if (muffled) 
[17:42:25.825]                           invokeRestart("muffleMessage")
[17:42:25.825]                       }
[17:42:25.825]                       else if (inherits(cond, "warning")) {
[17:42:25.825]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:25.825]                         if (muffled) 
[17:42:25.825]                           invokeRestart("muffleWarning")
[17:42:25.825]                       }
[17:42:25.825]                       else if (inherits(cond, "condition")) {
[17:42:25.825]                         if (!is.null(pattern)) {
[17:42:25.825]                           computeRestarts <- base::computeRestarts
[17:42:25.825]                           grepl <- base::grepl
[17:42:25.825]                           restarts <- computeRestarts(cond)
[17:42:25.825]                           for (restart in restarts) {
[17:42:25.825]                             name <- restart$name
[17:42:25.825]                             if (is.null(name)) 
[17:42:25.825]                               next
[17:42:25.825]                             if (!grepl(pattern, name)) 
[17:42:25.825]                               next
[17:42:25.825]                             invokeRestart(restart)
[17:42:25.825]                             muffled <- TRUE
[17:42:25.825]                             break
[17:42:25.825]                           }
[17:42:25.825]                         }
[17:42:25.825]                       }
[17:42:25.825]                       invisible(muffled)
[17:42:25.825]                     }
[17:42:25.825]                     muffleCondition(cond, pattern = "^muffle")
[17:42:25.825]                   }
[17:42:25.825]                 }
[17:42:25.825]             }
[17:42:25.825]         }))
[17:42:25.825]     }, error = function(ex) {
[17:42:25.825]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:25.825]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:25.825]                 ...future.rng), started = ...future.startTime, 
[17:42:25.825]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:25.825]             version = "1.8"), class = "FutureResult")
[17:42:25.825]     }, finally = {
[17:42:25.825]         if (!identical(...future.workdir, getwd())) 
[17:42:25.825]             setwd(...future.workdir)
[17:42:25.825]         {
[17:42:25.825]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:25.825]                 ...future.oldOptions$nwarnings <- NULL
[17:42:25.825]             }
[17:42:25.825]             base::options(...future.oldOptions)
[17:42:25.825]             if (.Platform$OS.type == "windows") {
[17:42:25.825]                 old_names <- names(...future.oldEnvVars)
[17:42:25.825]                 envs <- base::Sys.getenv()
[17:42:25.825]                 names <- names(envs)
[17:42:25.825]                 common <- intersect(names, old_names)
[17:42:25.825]                 added <- setdiff(names, old_names)
[17:42:25.825]                 removed <- setdiff(old_names, names)
[17:42:25.825]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:25.825]                   envs[common]]
[17:42:25.825]                 NAMES <- toupper(changed)
[17:42:25.825]                 args <- list()
[17:42:25.825]                 for (kk in seq_along(NAMES)) {
[17:42:25.825]                   name <- changed[[kk]]
[17:42:25.825]                   NAME <- NAMES[[kk]]
[17:42:25.825]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:25.825]                     next
[17:42:25.825]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:25.825]                 }
[17:42:25.825]                 NAMES <- toupper(added)
[17:42:25.825]                 for (kk in seq_along(NAMES)) {
[17:42:25.825]                   name <- added[[kk]]
[17:42:25.825]                   NAME <- NAMES[[kk]]
[17:42:25.825]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:25.825]                     next
[17:42:25.825]                   args[[name]] <- ""
[17:42:25.825]                 }
[17:42:25.825]                 NAMES <- toupper(removed)
[17:42:25.825]                 for (kk in seq_along(NAMES)) {
[17:42:25.825]                   name <- removed[[kk]]
[17:42:25.825]                   NAME <- NAMES[[kk]]
[17:42:25.825]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:25.825]                     next
[17:42:25.825]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:25.825]                 }
[17:42:25.825]                 if (length(args) > 0) 
[17:42:25.825]                   base::do.call(base::Sys.setenv, args = args)
[17:42:25.825]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:25.825]             }
[17:42:25.825]             else {
[17:42:25.825]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:25.825]             }
[17:42:25.825]             {
[17:42:25.825]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:25.825]                   0L) {
[17:42:25.825]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:25.825]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:25.825]                   base::options(opts)
[17:42:25.825]                 }
[17:42:25.825]                 {
[17:42:25.825]                   {
[17:42:25.825]                     NULL
[17:42:25.825]                     RNGkind("Mersenne-Twister")
[17:42:25.825]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:25.825]                       inherits = FALSE)
[17:42:25.825]                   }
[17:42:25.825]                   options(future.plan = NULL)
[17:42:25.825]                   if (is.na(NA_character_)) 
[17:42:25.825]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:25.825]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:25.825]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:25.825]                   {
[17:42:25.825]                     future <- SequentialFuture(..., envir = envir)
[17:42:25.825]                     if (!future$lazy) 
[17:42:25.825]                       future <- run(future)
[17:42:25.825]                     invisible(future)
[17:42:25.825]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:25.825]                 }
[17:42:25.825]             }
[17:42:25.825]         }
[17:42:25.825]     })
[17:42:25.825]     if (TRUE) {
[17:42:25.825]         base::sink(type = "output", split = FALSE)
[17:42:25.825]         if (TRUE) {
[17:42:25.825]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:25.825]         }
[17:42:25.825]         else {
[17:42:25.825]             ...future.result["stdout"] <- base::list(NULL)
[17:42:25.825]         }
[17:42:25.825]         base::close(...future.stdout)
[17:42:25.825]         ...future.stdout <- NULL
[17:42:25.825]     }
[17:42:25.825]     ...future.result$conditions <- ...future.conditions
[17:42:25.825]     ...future.result$finished <- base::Sys.time()
[17:42:25.825]     ...future.result
[17:42:25.825] }
[17:42:25.828] assign_globals() ...
[17:42:25.828] List of 2
[17:42:25.828]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[17:42:25.828]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[17:42:25.828]  - attr(*, "where")=List of 2
[17:42:25.828]   ..$ weight:<environment: R_EmptyEnv> 
[17:42:25.828]   ..$ group :<environment: R_EmptyEnv> 
[17:42:25.828]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:25.828]  - attr(*, "resolved")= logi FALSE
[17:42:25.828]  - attr(*, "total_size")= num 896
[17:42:25.828]  - attr(*, "already-done")= logi TRUE
[17:42:25.833] - copied ‘weight’ to environment
[17:42:25.833] - copied ‘group’ to environment
[17:42:25.834] assign_globals() ... done
[17:42:25.834] plan(): Setting new future strategy stack:
[17:42:25.834] List of future strategies:
[17:42:25.834] 1. sequential:
[17:42:25.834]    - args: function (..., envir = parent.frame())
[17:42:25.834]    - tweaked: FALSE
[17:42:25.834]    - call: NULL
[17:42:25.835] plan(): nbrOfWorkers() = 1
[17:42:25.837] plan(): Setting new future strategy stack:
[17:42:25.837] List of future strategies:
[17:42:25.837] 1. sequential:
[17:42:25.837]    - args: function (..., envir = parent.frame())
[17:42:25.837]    - tweaked: FALSE
[17:42:25.837]    - call: plan(strategy)
[17:42:25.837] plan(): nbrOfWorkers() = 1
[17:42:25.837] SequentialFuture started (and completed)
[17:42:25.838] - Launch lazy future ... done
[17:42:25.838] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[17:42:25.841] getGlobalsAndPackages() ...
[17:42:25.841] Searching for globals...
[17:42:25.843] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:42:25.843] Searching for globals ... DONE
[17:42:25.843] Resolving globals: FALSE
[17:42:25.843] The total size of the 2 globals is 896 bytes (896 bytes)
[17:42:25.844] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:42:25.844] - globals: [2] ‘weight’, ‘group’
[17:42:25.844] - packages: [1] ‘stats’
[17:42:25.844] getGlobalsAndPackages() ... DONE
[17:42:25.844] run() for ‘Future’ ...
[17:42:25.844] - state: ‘created’
[17:42:25.845] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:25.845] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:25.845] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:25.845]   - Field: ‘label’
[17:42:25.845]   - Field: ‘local’
[17:42:25.845]   - Field: ‘owner’
[17:42:25.845]   - Field: ‘envir’
[17:42:25.845]   - Field: ‘packages’
[17:42:25.846]   - Field: ‘gc’
[17:42:25.846]   - Field: ‘conditions’
[17:42:25.846]   - Field: ‘expr’
[17:42:25.846]   - Field: ‘uuid’
[17:42:25.846]   - Field: ‘seed’
[17:42:25.846]   - Field: ‘version’
[17:42:25.846]   - Field: ‘result’
[17:42:25.846]   - Field: ‘asynchronous’
[17:42:25.846]   - Field: ‘calls’
[17:42:25.846]   - Field: ‘globals’
[17:42:25.847]   - Field: ‘stdout’
[17:42:25.847]   - Field: ‘earlySignal’
[17:42:25.847]   - Field: ‘lazy’
[17:42:25.847]   - Field: ‘state’
[17:42:25.847] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:25.847] - Launch lazy future ...
[17:42:25.847] Packages needed by the future expression (n = 1): ‘stats’
[17:42:25.847] Packages needed by future strategies (n = 0): <none>
[17:42:25.848] {
[17:42:25.848]     {
[17:42:25.848]         {
[17:42:25.848]             ...future.startTime <- base::Sys.time()
[17:42:25.848]             {
[17:42:25.848]                 {
[17:42:25.848]                   {
[17:42:25.848]                     {
[17:42:25.848]                       base::local({
[17:42:25.848]                         has_future <- base::requireNamespace("future", 
[17:42:25.848]                           quietly = TRUE)
[17:42:25.848]                         if (has_future) {
[17:42:25.848]                           ns <- base::getNamespace("future")
[17:42:25.848]                           version <- ns[[".package"]][["version"]]
[17:42:25.848]                           if (is.null(version)) 
[17:42:25.848]                             version <- utils::packageVersion("future")
[17:42:25.848]                         }
[17:42:25.848]                         else {
[17:42:25.848]                           version <- NULL
[17:42:25.848]                         }
[17:42:25.848]                         if (!has_future || version < "1.8.0") {
[17:42:25.848]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:25.848]                             "", base::R.version$version.string), 
[17:42:25.848]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:25.848]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:25.848]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:25.848]                               "release", "version")], collapse = " "), 
[17:42:25.848]                             hostname = base::Sys.info()[["nodename"]])
[17:42:25.848]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:25.848]                             info)
[17:42:25.848]                           info <- base::paste(info, collapse = "; ")
[17:42:25.848]                           if (!has_future) {
[17:42:25.848]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:25.848]                               info)
[17:42:25.848]                           }
[17:42:25.848]                           else {
[17:42:25.848]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:25.848]                               info, version)
[17:42:25.848]                           }
[17:42:25.848]                           base::stop(msg)
[17:42:25.848]                         }
[17:42:25.848]                       })
[17:42:25.848]                     }
[17:42:25.848]                     base::local({
[17:42:25.848]                       for (pkg in "stats") {
[17:42:25.848]                         base::loadNamespace(pkg)
[17:42:25.848]                         base::library(pkg, character.only = TRUE)
[17:42:25.848]                       }
[17:42:25.848]                     })
[17:42:25.848]                   }
[17:42:25.848]                   options(future.plan = NULL)
[17:42:25.848]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:25.848]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:25.848]                 }
[17:42:25.848]                 ...future.workdir <- getwd()
[17:42:25.848]             }
[17:42:25.848]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:25.848]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:25.848]         }
[17:42:25.848]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:25.848]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:25.848]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:25.848]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:25.848]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:25.848]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:25.848]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:25.848]             base::names(...future.oldOptions))
[17:42:25.848]     }
[17:42:25.848]     if (FALSE) {
[17:42:25.848]     }
[17:42:25.848]     else {
[17:42:25.848]         if (TRUE) {
[17:42:25.848]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:25.848]                 open = "w")
[17:42:25.848]         }
[17:42:25.848]         else {
[17:42:25.848]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:25.848]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:25.848]         }
[17:42:25.848]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:25.848]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:25.848]             base::sink(type = "output", split = FALSE)
[17:42:25.848]             base::close(...future.stdout)
[17:42:25.848]         }, add = TRUE)
[17:42:25.848]     }
[17:42:25.848]     ...future.frame <- base::sys.nframe()
[17:42:25.848]     ...future.conditions <- base::list()
[17:42:25.848]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:25.848]     if (FALSE) {
[17:42:25.848]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:25.848]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:25.848]     }
[17:42:25.848]     ...future.result <- base::tryCatch({
[17:42:25.848]         base::withCallingHandlers({
[17:42:25.848]             ...future.value <- base::withVisible(base::local({
[17:42:25.848]                 lm(weight ~ group - 1)
[17:42:25.848]             }))
[17:42:25.848]             future::FutureResult(value = ...future.value$value, 
[17:42:25.848]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:25.848]                   ...future.rng), globalenv = if (FALSE) 
[17:42:25.848]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:25.848]                     ...future.globalenv.names))
[17:42:25.848]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:25.848]         }, condition = base::local({
[17:42:25.848]             c <- base::c
[17:42:25.848]             inherits <- base::inherits
[17:42:25.848]             invokeRestart <- base::invokeRestart
[17:42:25.848]             length <- base::length
[17:42:25.848]             list <- base::list
[17:42:25.848]             seq.int <- base::seq.int
[17:42:25.848]             signalCondition <- base::signalCondition
[17:42:25.848]             sys.calls <- base::sys.calls
[17:42:25.848]             `[[` <- base::`[[`
[17:42:25.848]             `+` <- base::`+`
[17:42:25.848]             `<<-` <- base::`<<-`
[17:42:25.848]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:25.848]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:25.848]                   3L)]
[17:42:25.848]             }
[17:42:25.848]             function(cond) {
[17:42:25.848]                 is_error <- inherits(cond, "error")
[17:42:25.848]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:25.848]                   NULL)
[17:42:25.848]                 if (is_error) {
[17:42:25.848]                   sessionInformation <- function() {
[17:42:25.848]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:25.848]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:25.848]                       search = base::search(), system = base::Sys.info())
[17:42:25.848]                   }
[17:42:25.848]                   ...future.conditions[[length(...future.conditions) + 
[17:42:25.848]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:25.848]                     cond$call), session = sessionInformation(), 
[17:42:25.848]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:25.848]                   signalCondition(cond)
[17:42:25.848]                 }
[17:42:25.848]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:25.848]                 "immediateCondition"))) {
[17:42:25.848]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:25.848]                   ...future.conditions[[length(...future.conditions) + 
[17:42:25.848]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:25.848]                   if (TRUE && !signal) {
[17:42:25.848]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:25.848]                     {
[17:42:25.848]                       inherits <- base::inherits
[17:42:25.848]                       invokeRestart <- base::invokeRestart
[17:42:25.848]                       is.null <- base::is.null
[17:42:25.848]                       muffled <- FALSE
[17:42:25.848]                       if (inherits(cond, "message")) {
[17:42:25.848]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:25.848]                         if (muffled) 
[17:42:25.848]                           invokeRestart("muffleMessage")
[17:42:25.848]                       }
[17:42:25.848]                       else if (inherits(cond, "warning")) {
[17:42:25.848]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:25.848]                         if (muffled) 
[17:42:25.848]                           invokeRestart("muffleWarning")
[17:42:25.848]                       }
[17:42:25.848]                       else if (inherits(cond, "condition")) {
[17:42:25.848]                         if (!is.null(pattern)) {
[17:42:25.848]                           computeRestarts <- base::computeRestarts
[17:42:25.848]                           grepl <- base::grepl
[17:42:25.848]                           restarts <- computeRestarts(cond)
[17:42:25.848]                           for (restart in restarts) {
[17:42:25.848]                             name <- restart$name
[17:42:25.848]                             if (is.null(name)) 
[17:42:25.848]                               next
[17:42:25.848]                             if (!grepl(pattern, name)) 
[17:42:25.848]                               next
[17:42:25.848]                             invokeRestart(restart)
[17:42:25.848]                             muffled <- TRUE
[17:42:25.848]                             break
[17:42:25.848]                           }
[17:42:25.848]                         }
[17:42:25.848]                       }
[17:42:25.848]                       invisible(muffled)
[17:42:25.848]                     }
[17:42:25.848]                     muffleCondition(cond, pattern = "^muffle")
[17:42:25.848]                   }
[17:42:25.848]                 }
[17:42:25.848]                 else {
[17:42:25.848]                   if (TRUE) {
[17:42:25.848]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:25.848]                     {
[17:42:25.848]                       inherits <- base::inherits
[17:42:25.848]                       invokeRestart <- base::invokeRestart
[17:42:25.848]                       is.null <- base::is.null
[17:42:25.848]                       muffled <- FALSE
[17:42:25.848]                       if (inherits(cond, "message")) {
[17:42:25.848]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:25.848]                         if (muffled) 
[17:42:25.848]                           invokeRestart("muffleMessage")
[17:42:25.848]                       }
[17:42:25.848]                       else if (inherits(cond, "warning")) {
[17:42:25.848]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:25.848]                         if (muffled) 
[17:42:25.848]                           invokeRestart("muffleWarning")
[17:42:25.848]                       }
[17:42:25.848]                       else if (inherits(cond, "condition")) {
[17:42:25.848]                         if (!is.null(pattern)) {
[17:42:25.848]                           computeRestarts <- base::computeRestarts
[17:42:25.848]                           grepl <- base::grepl
[17:42:25.848]                           restarts <- computeRestarts(cond)
[17:42:25.848]                           for (restart in restarts) {
[17:42:25.848]                             name <- restart$name
[17:42:25.848]                             if (is.null(name)) 
[17:42:25.848]                               next
[17:42:25.848]                             if (!grepl(pattern, name)) 
[17:42:25.848]                               next
[17:42:25.848]                             invokeRestart(restart)
[17:42:25.848]                             muffled <- TRUE
[17:42:25.848]                             break
[17:42:25.848]                           }
[17:42:25.848]                         }
[17:42:25.848]                       }
[17:42:25.848]                       invisible(muffled)
[17:42:25.848]                     }
[17:42:25.848]                     muffleCondition(cond, pattern = "^muffle")
[17:42:25.848]                   }
[17:42:25.848]                 }
[17:42:25.848]             }
[17:42:25.848]         }))
[17:42:25.848]     }, error = function(ex) {
[17:42:25.848]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:25.848]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:25.848]                 ...future.rng), started = ...future.startTime, 
[17:42:25.848]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:25.848]             version = "1.8"), class = "FutureResult")
[17:42:25.848]     }, finally = {
[17:42:25.848]         if (!identical(...future.workdir, getwd())) 
[17:42:25.848]             setwd(...future.workdir)
[17:42:25.848]         {
[17:42:25.848]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:25.848]                 ...future.oldOptions$nwarnings <- NULL
[17:42:25.848]             }
[17:42:25.848]             base::options(...future.oldOptions)
[17:42:25.848]             if (.Platform$OS.type == "windows") {
[17:42:25.848]                 old_names <- names(...future.oldEnvVars)
[17:42:25.848]                 envs <- base::Sys.getenv()
[17:42:25.848]                 names <- names(envs)
[17:42:25.848]                 common <- intersect(names, old_names)
[17:42:25.848]                 added <- setdiff(names, old_names)
[17:42:25.848]                 removed <- setdiff(old_names, names)
[17:42:25.848]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:25.848]                   envs[common]]
[17:42:25.848]                 NAMES <- toupper(changed)
[17:42:25.848]                 args <- list()
[17:42:25.848]                 for (kk in seq_along(NAMES)) {
[17:42:25.848]                   name <- changed[[kk]]
[17:42:25.848]                   NAME <- NAMES[[kk]]
[17:42:25.848]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:25.848]                     next
[17:42:25.848]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:25.848]                 }
[17:42:25.848]                 NAMES <- toupper(added)
[17:42:25.848]                 for (kk in seq_along(NAMES)) {
[17:42:25.848]                   name <- added[[kk]]
[17:42:25.848]                   NAME <- NAMES[[kk]]
[17:42:25.848]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:25.848]                     next
[17:42:25.848]                   args[[name]] <- ""
[17:42:25.848]                 }
[17:42:25.848]                 NAMES <- toupper(removed)
[17:42:25.848]                 for (kk in seq_along(NAMES)) {
[17:42:25.848]                   name <- removed[[kk]]
[17:42:25.848]                   NAME <- NAMES[[kk]]
[17:42:25.848]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:25.848]                     next
[17:42:25.848]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:25.848]                 }
[17:42:25.848]                 if (length(args) > 0) 
[17:42:25.848]                   base::do.call(base::Sys.setenv, args = args)
[17:42:25.848]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:25.848]             }
[17:42:25.848]             else {
[17:42:25.848]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:25.848]             }
[17:42:25.848]             {
[17:42:25.848]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:25.848]                   0L) {
[17:42:25.848]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:25.848]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:25.848]                   base::options(opts)
[17:42:25.848]                 }
[17:42:25.848]                 {
[17:42:25.848]                   {
[17:42:25.848]                     NULL
[17:42:25.848]                     RNGkind("Mersenne-Twister")
[17:42:25.848]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:25.848]                       inherits = FALSE)
[17:42:25.848]                   }
[17:42:25.848]                   options(future.plan = NULL)
[17:42:25.848]                   if (is.na(NA_character_)) 
[17:42:25.848]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:25.848]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:25.848]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:25.848]                   {
[17:42:25.848]                     future <- SequentialFuture(..., envir = envir)
[17:42:25.848]                     if (!future$lazy) 
[17:42:25.848]                       future <- run(future)
[17:42:25.848]                     invisible(future)
[17:42:25.848]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:25.848]                 }
[17:42:25.848]             }
[17:42:25.848]         }
[17:42:25.848]     })
[17:42:25.848]     if (TRUE) {
[17:42:25.848]         base::sink(type = "output", split = FALSE)
[17:42:25.848]         if (TRUE) {
[17:42:25.848]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:25.848]         }
[17:42:25.848]         else {
[17:42:25.848]             ...future.result["stdout"] <- base::list(NULL)
[17:42:25.848]         }
[17:42:25.848]         base::close(...future.stdout)
[17:42:25.848]         ...future.stdout <- NULL
[17:42:25.848]     }
[17:42:25.848]     ...future.result$conditions <- ...future.conditions
[17:42:25.848]     ...future.result$finished <- base::Sys.time()
[17:42:25.848]     ...future.result
[17:42:25.848] }
[17:42:25.850] assign_globals() ...
[17:42:25.850] List of 2
[17:42:25.850]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[17:42:25.850]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[17:42:25.850]  - attr(*, "where")=List of 2
[17:42:25.850]   ..$ weight:<environment: R_EmptyEnv> 
[17:42:25.850]   ..$ group :<environment: R_EmptyEnv> 
[17:42:25.850]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:25.850]  - attr(*, "resolved")= logi FALSE
[17:42:25.850]  - attr(*, "total_size")= num 896
[17:42:25.850]  - attr(*, "already-done")= logi TRUE
[17:42:25.853] - copied ‘weight’ to environment
[17:42:25.853] - copied ‘group’ to environment
[17:42:25.853] assign_globals() ... done
[17:42:25.853] plan(): Setting new future strategy stack:
[17:42:25.853] List of future strategies:
[17:42:25.853] 1. sequential:
[17:42:25.853]    - args: function (..., envir = parent.frame())
[17:42:25.853]    - tweaked: FALSE
[17:42:25.853]    - call: NULL
[17:42:25.854] plan(): nbrOfWorkers() = 1
[17:42:25.855] plan(): Setting new future strategy stack:
[17:42:25.855] List of future strategies:
[17:42:25.855] 1. sequential:
[17:42:25.855]    - args: function (..., envir = parent.frame())
[17:42:25.855]    - tweaked: FALSE
[17:42:25.855]    - call: plan(strategy)
[17:42:25.856] plan(): nbrOfWorkers() = 1
[17:42:25.856] SequentialFuture started (and completed)
[17:42:25.856] - Launch lazy future ... done
[17:42:25.856] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[17:42:25.860] getGlobalsAndPackages() ...
[17:42:25.861] Searching for globals...
[17:42:25.862] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:42:25.862] Searching for globals ... DONE
[17:42:25.862] Resolving globals: FALSE
[17:42:25.863] The total size of the 2 globals is 896 bytes (896 bytes)
[17:42:25.863] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:42:25.863] - globals: [2] ‘weight’, ‘group’
[17:42:25.863] - packages: [1] ‘stats’
[17:42:25.864] getGlobalsAndPackages() ... DONE
[17:42:25.864] run() for ‘Future’ ...
[17:42:25.864] - state: ‘created’
[17:42:25.864] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:25.864] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:25.864] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:25.865]   - Field: ‘label’
[17:42:25.865]   - Field: ‘local’
[17:42:25.865]   - Field: ‘owner’
[17:42:25.865]   - Field: ‘envir’
[17:42:25.865]   - Field: ‘packages’
[17:42:25.865]   - Field: ‘gc’
[17:42:25.865]   - Field: ‘conditions’
[17:42:25.865]   - Field: ‘expr’
[17:42:25.865]   - Field: ‘uuid’
[17:42:25.865]   - Field: ‘seed’
[17:42:25.866]   - Field: ‘version’
[17:42:25.866]   - Field: ‘result’
[17:42:25.866]   - Field: ‘asynchronous’
[17:42:25.866]   - Field: ‘calls’
[17:42:25.866]   - Field: ‘globals’
[17:42:25.866]   - Field: ‘stdout’
[17:42:25.866]   - Field: ‘earlySignal’
[17:42:25.866]   - Field: ‘lazy’
[17:42:25.866]   - Field: ‘state’
[17:42:25.866] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:25.866] - Launch lazy future ...
[17:42:25.867] Packages needed by the future expression (n = 1): ‘stats’
[17:42:25.867] Packages needed by future strategies (n = 0): <none>
[17:42:25.867] {
[17:42:25.867]     {
[17:42:25.867]         {
[17:42:25.867]             ...future.startTime <- base::Sys.time()
[17:42:25.867]             {
[17:42:25.867]                 {
[17:42:25.867]                   {
[17:42:25.867]                     {
[17:42:25.867]                       base::local({
[17:42:25.867]                         has_future <- base::requireNamespace("future", 
[17:42:25.867]                           quietly = TRUE)
[17:42:25.867]                         if (has_future) {
[17:42:25.867]                           ns <- base::getNamespace("future")
[17:42:25.867]                           version <- ns[[".package"]][["version"]]
[17:42:25.867]                           if (is.null(version)) 
[17:42:25.867]                             version <- utils::packageVersion("future")
[17:42:25.867]                         }
[17:42:25.867]                         else {
[17:42:25.867]                           version <- NULL
[17:42:25.867]                         }
[17:42:25.867]                         if (!has_future || version < "1.8.0") {
[17:42:25.867]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:25.867]                             "", base::R.version$version.string), 
[17:42:25.867]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:25.867]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:25.867]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:25.867]                               "release", "version")], collapse = " "), 
[17:42:25.867]                             hostname = base::Sys.info()[["nodename"]])
[17:42:25.867]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:25.867]                             info)
[17:42:25.867]                           info <- base::paste(info, collapse = "; ")
[17:42:25.867]                           if (!has_future) {
[17:42:25.867]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:25.867]                               info)
[17:42:25.867]                           }
[17:42:25.867]                           else {
[17:42:25.867]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:25.867]                               info, version)
[17:42:25.867]                           }
[17:42:25.867]                           base::stop(msg)
[17:42:25.867]                         }
[17:42:25.867]                       })
[17:42:25.867]                     }
[17:42:25.867]                     base::local({
[17:42:25.867]                       for (pkg in "stats") {
[17:42:25.867]                         base::loadNamespace(pkg)
[17:42:25.867]                         base::library(pkg, character.only = TRUE)
[17:42:25.867]                       }
[17:42:25.867]                     })
[17:42:25.867]                   }
[17:42:25.867]                   options(future.plan = NULL)
[17:42:25.867]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:25.867]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:25.867]                 }
[17:42:25.867]                 ...future.workdir <- getwd()
[17:42:25.867]             }
[17:42:25.867]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:25.867]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:25.867]         }
[17:42:25.867]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:25.867]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:25.867]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:25.867]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:25.867]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:25.867]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:25.867]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:25.867]             base::names(...future.oldOptions))
[17:42:25.867]     }
[17:42:25.867]     if (FALSE) {
[17:42:25.867]     }
[17:42:25.867]     else {
[17:42:25.867]         if (TRUE) {
[17:42:25.867]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:25.867]                 open = "w")
[17:42:25.867]         }
[17:42:25.867]         else {
[17:42:25.867]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:25.867]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:25.867]         }
[17:42:25.867]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:25.867]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:25.867]             base::sink(type = "output", split = FALSE)
[17:42:25.867]             base::close(...future.stdout)
[17:42:25.867]         }, add = TRUE)
[17:42:25.867]     }
[17:42:25.867]     ...future.frame <- base::sys.nframe()
[17:42:25.867]     ...future.conditions <- base::list()
[17:42:25.867]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:25.867]     if (FALSE) {
[17:42:25.867]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:25.867]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:25.867]     }
[17:42:25.867]     ...future.result <- base::tryCatch({
[17:42:25.867]         base::withCallingHandlers({
[17:42:25.867]             ...future.value <- base::withVisible(base::local({
[17:42:25.867]                 lm(weight ~ group - 1)
[17:42:25.867]             }))
[17:42:25.867]             future::FutureResult(value = ...future.value$value, 
[17:42:25.867]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:25.867]                   ...future.rng), globalenv = if (FALSE) 
[17:42:25.867]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:25.867]                     ...future.globalenv.names))
[17:42:25.867]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:25.867]         }, condition = base::local({
[17:42:25.867]             c <- base::c
[17:42:25.867]             inherits <- base::inherits
[17:42:25.867]             invokeRestart <- base::invokeRestart
[17:42:25.867]             length <- base::length
[17:42:25.867]             list <- base::list
[17:42:25.867]             seq.int <- base::seq.int
[17:42:25.867]             signalCondition <- base::signalCondition
[17:42:25.867]             sys.calls <- base::sys.calls
[17:42:25.867]             `[[` <- base::`[[`
[17:42:25.867]             `+` <- base::`+`
[17:42:25.867]             `<<-` <- base::`<<-`
[17:42:25.867]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:25.867]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:25.867]                   3L)]
[17:42:25.867]             }
[17:42:25.867]             function(cond) {
[17:42:25.867]                 is_error <- inherits(cond, "error")
[17:42:25.867]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:25.867]                   NULL)
[17:42:25.867]                 if (is_error) {
[17:42:25.867]                   sessionInformation <- function() {
[17:42:25.867]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:25.867]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:25.867]                       search = base::search(), system = base::Sys.info())
[17:42:25.867]                   }
[17:42:25.867]                   ...future.conditions[[length(...future.conditions) + 
[17:42:25.867]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:25.867]                     cond$call), session = sessionInformation(), 
[17:42:25.867]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:25.867]                   signalCondition(cond)
[17:42:25.867]                 }
[17:42:25.867]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:25.867]                 "immediateCondition"))) {
[17:42:25.867]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:25.867]                   ...future.conditions[[length(...future.conditions) + 
[17:42:25.867]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:25.867]                   if (TRUE && !signal) {
[17:42:25.867]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:25.867]                     {
[17:42:25.867]                       inherits <- base::inherits
[17:42:25.867]                       invokeRestart <- base::invokeRestart
[17:42:25.867]                       is.null <- base::is.null
[17:42:25.867]                       muffled <- FALSE
[17:42:25.867]                       if (inherits(cond, "message")) {
[17:42:25.867]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:25.867]                         if (muffled) 
[17:42:25.867]                           invokeRestart("muffleMessage")
[17:42:25.867]                       }
[17:42:25.867]                       else if (inherits(cond, "warning")) {
[17:42:25.867]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:25.867]                         if (muffled) 
[17:42:25.867]                           invokeRestart("muffleWarning")
[17:42:25.867]                       }
[17:42:25.867]                       else if (inherits(cond, "condition")) {
[17:42:25.867]                         if (!is.null(pattern)) {
[17:42:25.867]                           computeRestarts <- base::computeRestarts
[17:42:25.867]                           grepl <- base::grepl
[17:42:25.867]                           restarts <- computeRestarts(cond)
[17:42:25.867]                           for (restart in restarts) {
[17:42:25.867]                             name <- restart$name
[17:42:25.867]                             if (is.null(name)) 
[17:42:25.867]                               next
[17:42:25.867]                             if (!grepl(pattern, name)) 
[17:42:25.867]                               next
[17:42:25.867]                             invokeRestart(restart)
[17:42:25.867]                             muffled <- TRUE
[17:42:25.867]                             break
[17:42:25.867]                           }
[17:42:25.867]                         }
[17:42:25.867]                       }
[17:42:25.867]                       invisible(muffled)
[17:42:25.867]                     }
[17:42:25.867]                     muffleCondition(cond, pattern = "^muffle")
[17:42:25.867]                   }
[17:42:25.867]                 }
[17:42:25.867]                 else {
[17:42:25.867]                   if (TRUE) {
[17:42:25.867]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:25.867]                     {
[17:42:25.867]                       inherits <- base::inherits
[17:42:25.867]                       invokeRestart <- base::invokeRestart
[17:42:25.867]                       is.null <- base::is.null
[17:42:25.867]                       muffled <- FALSE
[17:42:25.867]                       if (inherits(cond, "message")) {
[17:42:25.867]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:25.867]                         if (muffled) 
[17:42:25.867]                           invokeRestart("muffleMessage")
[17:42:25.867]                       }
[17:42:25.867]                       else if (inherits(cond, "warning")) {
[17:42:25.867]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:25.867]                         if (muffled) 
[17:42:25.867]                           invokeRestart("muffleWarning")
[17:42:25.867]                       }
[17:42:25.867]                       else if (inherits(cond, "condition")) {
[17:42:25.867]                         if (!is.null(pattern)) {
[17:42:25.867]                           computeRestarts <- base::computeRestarts
[17:42:25.867]                           grepl <- base::grepl
[17:42:25.867]                           restarts <- computeRestarts(cond)
[17:42:25.867]                           for (restart in restarts) {
[17:42:25.867]                             name <- restart$name
[17:42:25.867]                             if (is.null(name)) 
[17:42:25.867]                               next
[17:42:25.867]                             if (!grepl(pattern, name)) 
[17:42:25.867]                               next
[17:42:25.867]                             invokeRestart(restart)
[17:42:25.867]                             muffled <- TRUE
[17:42:25.867]                             break
[17:42:25.867]                           }
[17:42:25.867]                         }
[17:42:25.867]                       }
[17:42:25.867]                       invisible(muffled)
[17:42:25.867]                     }
[17:42:25.867]                     muffleCondition(cond, pattern = "^muffle")
[17:42:25.867]                   }
[17:42:25.867]                 }
[17:42:25.867]             }
[17:42:25.867]         }))
[17:42:25.867]     }, error = function(ex) {
[17:42:25.867]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:25.867]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:25.867]                 ...future.rng), started = ...future.startTime, 
[17:42:25.867]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:25.867]             version = "1.8"), class = "FutureResult")
[17:42:25.867]     }, finally = {
[17:42:25.867]         if (!identical(...future.workdir, getwd())) 
[17:42:25.867]             setwd(...future.workdir)
[17:42:25.867]         {
[17:42:25.867]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:25.867]                 ...future.oldOptions$nwarnings <- NULL
[17:42:25.867]             }
[17:42:25.867]             base::options(...future.oldOptions)
[17:42:25.867]             if (.Platform$OS.type == "windows") {
[17:42:25.867]                 old_names <- names(...future.oldEnvVars)
[17:42:25.867]                 envs <- base::Sys.getenv()
[17:42:25.867]                 names <- names(envs)
[17:42:25.867]                 common <- intersect(names, old_names)
[17:42:25.867]                 added <- setdiff(names, old_names)
[17:42:25.867]                 removed <- setdiff(old_names, names)
[17:42:25.867]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:25.867]                   envs[common]]
[17:42:25.867]                 NAMES <- toupper(changed)
[17:42:25.867]                 args <- list()
[17:42:25.867]                 for (kk in seq_along(NAMES)) {
[17:42:25.867]                   name <- changed[[kk]]
[17:42:25.867]                   NAME <- NAMES[[kk]]
[17:42:25.867]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:25.867]                     next
[17:42:25.867]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:25.867]                 }
[17:42:25.867]                 NAMES <- toupper(added)
[17:42:25.867]                 for (kk in seq_along(NAMES)) {
[17:42:25.867]                   name <- added[[kk]]
[17:42:25.867]                   NAME <- NAMES[[kk]]
[17:42:25.867]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:25.867]                     next
[17:42:25.867]                   args[[name]] <- ""
[17:42:25.867]                 }
[17:42:25.867]                 NAMES <- toupper(removed)
[17:42:25.867]                 for (kk in seq_along(NAMES)) {
[17:42:25.867]                   name <- removed[[kk]]
[17:42:25.867]                   NAME <- NAMES[[kk]]
[17:42:25.867]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:25.867]                     next
[17:42:25.867]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:25.867]                 }
[17:42:25.867]                 if (length(args) > 0) 
[17:42:25.867]                   base::do.call(base::Sys.setenv, args = args)
[17:42:25.867]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:25.867]             }
[17:42:25.867]             else {
[17:42:25.867]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:25.867]             }
[17:42:25.867]             {
[17:42:25.867]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:25.867]                   0L) {
[17:42:25.867]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:25.867]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:25.867]                   base::options(opts)
[17:42:25.867]                 }
[17:42:25.867]                 {
[17:42:25.867]                   {
[17:42:25.867]                     NULL
[17:42:25.867]                     RNGkind("Mersenne-Twister")
[17:42:25.867]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:25.867]                       inherits = FALSE)
[17:42:25.867]                   }
[17:42:25.867]                   options(future.plan = NULL)
[17:42:25.867]                   if (is.na(NA_character_)) 
[17:42:25.867]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:25.867]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:25.867]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:25.867]                   {
[17:42:25.867]                     future <- SequentialFuture(..., envir = envir)
[17:42:25.867]                     if (!future$lazy) 
[17:42:25.867]                       future <- run(future)
[17:42:25.867]                     invisible(future)
[17:42:25.867]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:25.867]                 }
[17:42:25.867]             }
[17:42:25.867]         }
[17:42:25.867]     })
[17:42:25.867]     if (TRUE) {
[17:42:25.867]         base::sink(type = "output", split = FALSE)
[17:42:25.867]         if (TRUE) {
[17:42:25.867]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:25.867]         }
[17:42:25.867]         else {
[17:42:25.867]             ...future.result["stdout"] <- base::list(NULL)
[17:42:25.867]         }
[17:42:25.867]         base::close(...future.stdout)
[17:42:25.867]         ...future.stdout <- NULL
[17:42:25.867]     }
[17:42:25.867]     ...future.result$conditions <- ...future.conditions
[17:42:25.867]     ...future.result$finished <- base::Sys.time()
[17:42:25.867]     ...future.result
[17:42:25.867] }
[17:42:25.869] assign_globals() ...
[17:42:25.869] List of 2
[17:42:25.869]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[17:42:25.869]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[17:42:25.869]  - attr(*, "where")=List of 2
[17:42:25.869]   ..$ weight:<environment: R_EmptyEnv> 
[17:42:25.869]   ..$ group :<environment: R_EmptyEnv> 
[17:42:25.869]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:25.869]  - attr(*, "resolved")= logi FALSE
[17:42:25.869]  - attr(*, "total_size")= num 896
[17:42:25.869]  - attr(*, "already-done")= logi TRUE
[17:42:25.872] - copied ‘weight’ to environment
[17:42:25.872] - copied ‘group’ to environment
[17:42:25.873] assign_globals() ... done
[17:42:25.873] plan(): Setting new future strategy stack:
[17:42:25.873] List of future strategies:
[17:42:25.873] 1. sequential:
[17:42:25.873]    - args: function (..., envir = parent.frame())
[17:42:25.873]    - tweaked: FALSE
[17:42:25.873]    - call: NULL
[17:42:25.873] plan(): nbrOfWorkers() = 1
[17:42:25.875] plan(): Setting new future strategy stack:
[17:42:25.875] List of future strategies:
[17:42:25.875] 1. sequential:
[17:42:25.875]    - args: function (..., envir = parent.frame())
[17:42:25.875]    - tweaked: FALSE
[17:42:25.875]    - call: plan(strategy)
[17:42:25.876] plan(): nbrOfWorkers() = 1
[17:42:25.876] SequentialFuture started (and completed)
[17:42:25.876] - Launch lazy future ... done
[17:42:25.876] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[17:42:25.878] getGlobalsAndPackages() ...
[17:42:25.878] Searching for globals...
[17:42:25.879] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:42:25.879] Searching for globals ... DONE
[17:42:25.880] Resolving globals: FALSE
[17:42:25.880] The total size of the 2 globals is 896 bytes (896 bytes)
[17:42:25.880] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:42:25.881] - globals: [2] ‘weight’, ‘group’
[17:42:25.881] - packages: [1] ‘stats’
[17:42:25.881] getGlobalsAndPackages() ... DONE
[17:42:25.881] run() for ‘Future’ ...
[17:42:25.881] - state: ‘created’
[17:42:25.881] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:25.882] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:25.882] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:25.882]   - Field: ‘label’
[17:42:25.882]   - Field: ‘local’
[17:42:25.882]   - Field: ‘owner’
[17:42:25.882]   - Field: ‘envir’
[17:42:25.882]   - Field: ‘packages’
[17:42:25.882]   - Field: ‘gc’
[17:42:25.882]   - Field: ‘conditions’
[17:42:25.882]   - Field: ‘expr’
[17:42:25.883]   - Field: ‘uuid’
[17:42:25.883]   - Field: ‘seed’
[17:42:25.883]   - Field: ‘version’
[17:42:25.883]   - Field: ‘result’
[17:42:25.883]   - Field: ‘asynchronous’
[17:42:25.883]   - Field: ‘calls’
[17:42:25.883]   - Field: ‘globals’
[17:42:25.883]   - Field: ‘stdout’
[17:42:25.883]   - Field: ‘earlySignal’
[17:42:25.883]   - Field: ‘lazy’
[17:42:25.884]   - Field: ‘state’
[17:42:25.884] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:25.884] - Launch lazy future ...
[17:42:25.884] Packages needed by the future expression (n = 1): ‘stats’
[17:42:25.886] Packages needed by future strategies (n = 0): <none>
[17:42:25.886] {
[17:42:25.886]     {
[17:42:25.886]         {
[17:42:25.886]             ...future.startTime <- base::Sys.time()
[17:42:25.886]             {
[17:42:25.886]                 {
[17:42:25.886]                   {
[17:42:25.886]                     {
[17:42:25.886]                       base::local({
[17:42:25.886]                         has_future <- base::requireNamespace("future", 
[17:42:25.886]                           quietly = TRUE)
[17:42:25.886]                         if (has_future) {
[17:42:25.886]                           ns <- base::getNamespace("future")
[17:42:25.886]                           version <- ns[[".package"]][["version"]]
[17:42:25.886]                           if (is.null(version)) 
[17:42:25.886]                             version <- utils::packageVersion("future")
[17:42:25.886]                         }
[17:42:25.886]                         else {
[17:42:25.886]                           version <- NULL
[17:42:25.886]                         }
[17:42:25.886]                         if (!has_future || version < "1.8.0") {
[17:42:25.886]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:25.886]                             "", base::R.version$version.string), 
[17:42:25.886]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:25.886]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:25.886]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:25.886]                               "release", "version")], collapse = " "), 
[17:42:25.886]                             hostname = base::Sys.info()[["nodename"]])
[17:42:25.886]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:25.886]                             info)
[17:42:25.886]                           info <- base::paste(info, collapse = "; ")
[17:42:25.886]                           if (!has_future) {
[17:42:25.886]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:25.886]                               info)
[17:42:25.886]                           }
[17:42:25.886]                           else {
[17:42:25.886]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:25.886]                               info, version)
[17:42:25.886]                           }
[17:42:25.886]                           base::stop(msg)
[17:42:25.886]                         }
[17:42:25.886]                       })
[17:42:25.886]                     }
[17:42:25.886]                     base::local({
[17:42:25.886]                       for (pkg in "stats") {
[17:42:25.886]                         base::loadNamespace(pkg)
[17:42:25.886]                         base::library(pkg, character.only = TRUE)
[17:42:25.886]                       }
[17:42:25.886]                     })
[17:42:25.886]                   }
[17:42:25.886]                   options(future.plan = NULL)
[17:42:25.886]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:25.886]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:25.886]                 }
[17:42:25.886]                 ...future.workdir <- getwd()
[17:42:25.886]             }
[17:42:25.886]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:25.886]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:25.886]         }
[17:42:25.886]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:25.886]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:25.886]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:25.886]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:25.886]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:25.886]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:25.886]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:25.886]             base::names(...future.oldOptions))
[17:42:25.886]     }
[17:42:25.886]     if (FALSE) {
[17:42:25.886]     }
[17:42:25.886]     else {
[17:42:25.886]         if (TRUE) {
[17:42:25.886]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:25.886]                 open = "w")
[17:42:25.886]         }
[17:42:25.886]         else {
[17:42:25.886]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:25.886]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:25.886]         }
[17:42:25.886]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:25.886]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:25.886]             base::sink(type = "output", split = FALSE)
[17:42:25.886]             base::close(...future.stdout)
[17:42:25.886]         }, add = TRUE)
[17:42:25.886]     }
[17:42:25.886]     ...future.frame <- base::sys.nframe()
[17:42:25.886]     ...future.conditions <- base::list()
[17:42:25.886]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:25.886]     if (FALSE) {
[17:42:25.886]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:25.886]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:25.886]     }
[17:42:25.886]     ...future.result <- base::tryCatch({
[17:42:25.886]         base::withCallingHandlers({
[17:42:25.886]             ...future.value <- base::withVisible(base::local({
[17:42:25.886]                 lm(weight ~ group - 1)
[17:42:25.886]             }))
[17:42:25.886]             future::FutureResult(value = ...future.value$value, 
[17:42:25.886]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:25.886]                   ...future.rng), globalenv = if (FALSE) 
[17:42:25.886]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:25.886]                     ...future.globalenv.names))
[17:42:25.886]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:25.886]         }, condition = base::local({
[17:42:25.886]             c <- base::c
[17:42:25.886]             inherits <- base::inherits
[17:42:25.886]             invokeRestart <- base::invokeRestart
[17:42:25.886]             length <- base::length
[17:42:25.886]             list <- base::list
[17:42:25.886]             seq.int <- base::seq.int
[17:42:25.886]             signalCondition <- base::signalCondition
[17:42:25.886]             sys.calls <- base::sys.calls
[17:42:25.886]             `[[` <- base::`[[`
[17:42:25.886]             `+` <- base::`+`
[17:42:25.886]             `<<-` <- base::`<<-`
[17:42:25.886]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:25.886]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:25.886]                   3L)]
[17:42:25.886]             }
[17:42:25.886]             function(cond) {
[17:42:25.886]                 is_error <- inherits(cond, "error")
[17:42:25.886]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:25.886]                   NULL)
[17:42:25.886]                 if (is_error) {
[17:42:25.886]                   sessionInformation <- function() {
[17:42:25.886]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:25.886]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:25.886]                       search = base::search(), system = base::Sys.info())
[17:42:25.886]                   }
[17:42:25.886]                   ...future.conditions[[length(...future.conditions) + 
[17:42:25.886]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:25.886]                     cond$call), session = sessionInformation(), 
[17:42:25.886]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:25.886]                   signalCondition(cond)
[17:42:25.886]                 }
[17:42:25.886]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:25.886]                 "immediateCondition"))) {
[17:42:25.886]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:25.886]                   ...future.conditions[[length(...future.conditions) + 
[17:42:25.886]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:25.886]                   if (TRUE && !signal) {
[17:42:25.886]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:25.886]                     {
[17:42:25.886]                       inherits <- base::inherits
[17:42:25.886]                       invokeRestart <- base::invokeRestart
[17:42:25.886]                       is.null <- base::is.null
[17:42:25.886]                       muffled <- FALSE
[17:42:25.886]                       if (inherits(cond, "message")) {
[17:42:25.886]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:25.886]                         if (muffled) 
[17:42:25.886]                           invokeRestart("muffleMessage")
[17:42:25.886]                       }
[17:42:25.886]                       else if (inherits(cond, "warning")) {
[17:42:25.886]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:25.886]                         if (muffled) 
[17:42:25.886]                           invokeRestart("muffleWarning")
[17:42:25.886]                       }
[17:42:25.886]                       else if (inherits(cond, "condition")) {
[17:42:25.886]                         if (!is.null(pattern)) {
[17:42:25.886]                           computeRestarts <- base::computeRestarts
[17:42:25.886]                           grepl <- base::grepl
[17:42:25.886]                           restarts <- computeRestarts(cond)
[17:42:25.886]                           for (restart in restarts) {
[17:42:25.886]                             name <- restart$name
[17:42:25.886]                             if (is.null(name)) 
[17:42:25.886]                               next
[17:42:25.886]                             if (!grepl(pattern, name)) 
[17:42:25.886]                               next
[17:42:25.886]                             invokeRestart(restart)
[17:42:25.886]                             muffled <- TRUE
[17:42:25.886]                             break
[17:42:25.886]                           }
[17:42:25.886]                         }
[17:42:25.886]                       }
[17:42:25.886]                       invisible(muffled)
[17:42:25.886]                     }
[17:42:25.886]                     muffleCondition(cond, pattern = "^muffle")
[17:42:25.886]                   }
[17:42:25.886]                 }
[17:42:25.886]                 else {
[17:42:25.886]                   if (TRUE) {
[17:42:25.886]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:25.886]                     {
[17:42:25.886]                       inherits <- base::inherits
[17:42:25.886]                       invokeRestart <- base::invokeRestart
[17:42:25.886]                       is.null <- base::is.null
[17:42:25.886]                       muffled <- FALSE
[17:42:25.886]                       if (inherits(cond, "message")) {
[17:42:25.886]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:25.886]                         if (muffled) 
[17:42:25.886]                           invokeRestart("muffleMessage")
[17:42:25.886]                       }
[17:42:25.886]                       else if (inherits(cond, "warning")) {
[17:42:25.886]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:25.886]                         if (muffled) 
[17:42:25.886]                           invokeRestart("muffleWarning")
[17:42:25.886]                       }
[17:42:25.886]                       else if (inherits(cond, "condition")) {
[17:42:25.886]                         if (!is.null(pattern)) {
[17:42:25.886]                           computeRestarts <- base::computeRestarts
[17:42:25.886]                           grepl <- base::grepl
[17:42:25.886]                           restarts <- computeRestarts(cond)
[17:42:25.886]                           for (restart in restarts) {
[17:42:25.886]                             name <- restart$name
[17:42:25.886]                             if (is.null(name)) 
[17:42:25.886]                               next
[17:42:25.886]                             if (!grepl(pattern, name)) 
[17:42:25.886]                               next
[17:42:25.886]                             invokeRestart(restart)
[17:42:25.886]                             muffled <- TRUE
[17:42:25.886]                             break
[17:42:25.886]                           }
[17:42:25.886]                         }
[17:42:25.886]                       }
[17:42:25.886]                       invisible(muffled)
[17:42:25.886]                     }
[17:42:25.886]                     muffleCondition(cond, pattern = "^muffle")
[17:42:25.886]                   }
[17:42:25.886]                 }
[17:42:25.886]             }
[17:42:25.886]         }))
[17:42:25.886]     }, error = function(ex) {
[17:42:25.886]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:25.886]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:25.886]                 ...future.rng), started = ...future.startTime, 
[17:42:25.886]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:25.886]             version = "1.8"), class = "FutureResult")
[17:42:25.886]     }, finally = {
[17:42:25.886]         if (!identical(...future.workdir, getwd())) 
[17:42:25.886]             setwd(...future.workdir)
[17:42:25.886]         {
[17:42:25.886]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:25.886]                 ...future.oldOptions$nwarnings <- NULL
[17:42:25.886]             }
[17:42:25.886]             base::options(...future.oldOptions)
[17:42:25.886]             if (.Platform$OS.type == "windows") {
[17:42:25.886]                 old_names <- names(...future.oldEnvVars)
[17:42:25.886]                 envs <- base::Sys.getenv()
[17:42:25.886]                 names <- names(envs)
[17:42:25.886]                 common <- intersect(names, old_names)
[17:42:25.886]                 added <- setdiff(names, old_names)
[17:42:25.886]                 removed <- setdiff(old_names, names)
[17:42:25.886]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:25.886]                   envs[common]]
[17:42:25.886]                 NAMES <- toupper(changed)
[17:42:25.886]                 args <- list()
[17:42:25.886]                 for (kk in seq_along(NAMES)) {
[17:42:25.886]                   name <- changed[[kk]]
[17:42:25.886]                   NAME <- NAMES[[kk]]
[17:42:25.886]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:25.886]                     next
[17:42:25.886]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:25.886]                 }
[17:42:25.886]                 NAMES <- toupper(added)
[17:42:25.886]                 for (kk in seq_along(NAMES)) {
[17:42:25.886]                   name <- added[[kk]]
[17:42:25.886]                   NAME <- NAMES[[kk]]
[17:42:25.886]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:25.886]                     next
[17:42:25.886]                   args[[name]] <- ""
[17:42:25.886]                 }
[17:42:25.886]                 NAMES <- toupper(removed)
[17:42:25.886]                 for (kk in seq_along(NAMES)) {
[17:42:25.886]                   name <- removed[[kk]]
[17:42:25.886]                   NAME <- NAMES[[kk]]
[17:42:25.886]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:25.886]                     next
[17:42:25.886]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:25.886]                 }
[17:42:25.886]                 if (length(args) > 0) 
[17:42:25.886]                   base::do.call(base::Sys.setenv, args = args)
[17:42:25.886]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:25.886]             }
[17:42:25.886]             else {
[17:42:25.886]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:25.886]             }
[17:42:25.886]             {
[17:42:25.886]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:25.886]                   0L) {
[17:42:25.886]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:25.886]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:25.886]                   base::options(opts)
[17:42:25.886]                 }
[17:42:25.886]                 {
[17:42:25.886]                   {
[17:42:25.886]                     NULL
[17:42:25.886]                     RNGkind("Mersenne-Twister")
[17:42:25.886]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:25.886]                       inherits = FALSE)
[17:42:25.886]                   }
[17:42:25.886]                   options(future.plan = NULL)
[17:42:25.886]                   if (is.na(NA_character_)) 
[17:42:25.886]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:25.886]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:25.886]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:25.886]                   {
[17:42:25.886]                     future <- SequentialFuture(..., envir = envir)
[17:42:25.886]                     if (!future$lazy) 
[17:42:25.886]                       future <- run(future)
[17:42:25.886]                     invisible(future)
[17:42:25.886]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:25.886]                 }
[17:42:25.886]             }
[17:42:25.886]         }
[17:42:25.886]     })
[17:42:25.886]     if (TRUE) {
[17:42:25.886]         base::sink(type = "output", split = FALSE)
[17:42:25.886]         if (TRUE) {
[17:42:25.886]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:25.886]         }
[17:42:25.886]         else {
[17:42:25.886]             ...future.result["stdout"] <- base::list(NULL)
[17:42:25.886]         }
[17:42:25.886]         base::close(...future.stdout)
[17:42:25.886]         ...future.stdout <- NULL
[17:42:25.886]     }
[17:42:25.886]     ...future.result$conditions <- ...future.conditions
[17:42:25.886]     ...future.result$finished <- base::Sys.time()
[17:42:25.886]     ...future.result
[17:42:25.886] }
[17:42:25.888] assign_globals() ...
[17:42:25.888] List of 2
[17:42:25.888]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[17:42:25.888]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[17:42:25.888]  - attr(*, "where")=List of 2
[17:42:25.888]   ..$ weight:<environment: R_EmptyEnv> 
[17:42:25.888]   ..$ group :<environment: R_EmptyEnv> 
[17:42:25.888]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:25.888]  - attr(*, "resolved")= logi FALSE
[17:42:25.888]  - attr(*, "total_size")= num 896
[17:42:25.888]  - attr(*, "already-done")= logi TRUE
[17:42:25.891] - copied ‘weight’ to environment
[17:42:25.891] - copied ‘group’ to environment
[17:42:25.891] assign_globals() ... done
[17:42:25.892] plan(): Setting new future strategy stack:
[17:42:25.892] List of future strategies:
[17:42:25.892] 1. sequential:
[17:42:25.892]    - args: function (..., envir = parent.frame())
[17:42:25.892]    - tweaked: FALSE
[17:42:25.892]    - call: NULL
[17:42:25.892] plan(): nbrOfWorkers() = 1
[17:42:25.893] plan(): Setting new future strategy stack:
[17:42:25.894] List of future strategies:
[17:42:25.894] 1. sequential:
[17:42:25.894]    - args: function (..., envir = parent.frame())
[17:42:25.894]    - tweaked: FALSE
[17:42:25.894]    - call: plan(strategy)
[17:42:25.894] plan(): nbrOfWorkers() = 1
[17:42:25.894] SequentialFuture started (and completed)
[17:42:25.894] - Launch lazy future ... done
[17:42:25.894] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[17:42:25.896] getGlobalsAndPackages() ...
[17:42:25.896] Searching for globals...
[17:42:25.898] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:42:25.898] Searching for globals ... DONE
[17:42:25.898] Resolving globals: FALSE
[17:42:25.898] The total size of the 2 globals is 896 bytes (896 bytes)
[17:42:25.899] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:42:25.899] - globals: [2] ‘weight’, ‘group’
[17:42:25.899] - packages: [1] ‘stats’
[17:42:25.899] getGlobalsAndPackages() ... DONE
[17:42:25.899] run() for ‘Future’ ...
[17:42:25.900] - state: ‘created’
[17:42:25.900] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:25.900] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:25.900] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:25.900]   - Field: ‘label’
[17:42:25.900]   - Field: ‘local’
[17:42:25.900]   - Field: ‘owner’
[17:42:25.900]   - Field: ‘envir’
[17:42:25.901]   - Field: ‘packages’
[17:42:25.901]   - Field: ‘gc’
[17:42:25.901]   - Field: ‘conditions’
[17:42:25.901]   - Field: ‘expr’
[17:42:25.901]   - Field: ‘uuid’
[17:42:25.901]   - Field: ‘seed’
[17:42:25.901]   - Field: ‘version’
[17:42:25.901]   - Field: ‘result’
[17:42:25.901]   - Field: ‘asynchronous’
[17:42:25.901]   - Field: ‘calls’
[17:42:25.901]   - Field: ‘globals’
[17:42:25.902]   - Field: ‘stdout’
[17:42:25.902]   - Field: ‘earlySignal’
[17:42:25.902]   - Field: ‘lazy’
[17:42:25.902]   - Field: ‘state’
[17:42:25.902] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:25.902] - Launch lazy future ...
[17:42:25.902] Packages needed by the future expression (n = 1): ‘stats’
[17:42:25.902] Packages needed by future strategies (n = 0): <none>
[17:42:25.903] {
[17:42:25.903]     {
[17:42:25.903]         {
[17:42:25.903]             ...future.startTime <- base::Sys.time()
[17:42:25.903]             {
[17:42:25.903]                 {
[17:42:25.903]                   {
[17:42:25.903]                     {
[17:42:25.903]                       base::local({
[17:42:25.903]                         has_future <- base::requireNamespace("future", 
[17:42:25.903]                           quietly = TRUE)
[17:42:25.903]                         if (has_future) {
[17:42:25.903]                           ns <- base::getNamespace("future")
[17:42:25.903]                           version <- ns[[".package"]][["version"]]
[17:42:25.903]                           if (is.null(version)) 
[17:42:25.903]                             version <- utils::packageVersion("future")
[17:42:25.903]                         }
[17:42:25.903]                         else {
[17:42:25.903]                           version <- NULL
[17:42:25.903]                         }
[17:42:25.903]                         if (!has_future || version < "1.8.0") {
[17:42:25.903]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:25.903]                             "", base::R.version$version.string), 
[17:42:25.903]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:25.903]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:25.903]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:25.903]                               "release", "version")], collapse = " "), 
[17:42:25.903]                             hostname = base::Sys.info()[["nodename"]])
[17:42:25.903]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:25.903]                             info)
[17:42:25.903]                           info <- base::paste(info, collapse = "; ")
[17:42:25.903]                           if (!has_future) {
[17:42:25.903]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:25.903]                               info)
[17:42:25.903]                           }
[17:42:25.903]                           else {
[17:42:25.903]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:25.903]                               info, version)
[17:42:25.903]                           }
[17:42:25.903]                           base::stop(msg)
[17:42:25.903]                         }
[17:42:25.903]                       })
[17:42:25.903]                     }
[17:42:25.903]                     base::local({
[17:42:25.903]                       for (pkg in "stats") {
[17:42:25.903]                         base::loadNamespace(pkg)
[17:42:25.903]                         base::library(pkg, character.only = TRUE)
[17:42:25.903]                       }
[17:42:25.903]                     })
[17:42:25.903]                   }
[17:42:25.903]                   options(future.plan = NULL)
[17:42:25.903]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:25.903]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:25.903]                 }
[17:42:25.903]                 ...future.workdir <- getwd()
[17:42:25.903]             }
[17:42:25.903]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:25.903]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:25.903]         }
[17:42:25.903]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:25.903]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:25.903]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:25.903]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:25.903]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:25.903]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:25.903]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:25.903]             base::names(...future.oldOptions))
[17:42:25.903]     }
[17:42:25.903]     if (FALSE) {
[17:42:25.903]     }
[17:42:25.903]     else {
[17:42:25.903]         if (TRUE) {
[17:42:25.903]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:25.903]                 open = "w")
[17:42:25.903]         }
[17:42:25.903]         else {
[17:42:25.903]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:25.903]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:25.903]         }
[17:42:25.903]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:25.903]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:25.903]             base::sink(type = "output", split = FALSE)
[17:42:25.903]             base::close(...future.stdout)
[17:42:25.903]         }, add = TRUE)
[17:42:25.903]     }
[17:42:25.903]     ...future.frame <- base::sys.nframe()
[17:42:25.903]     ...future.conditions <- base::list()
[17:42:25.903]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:25.903]     if (FALSE) {
[17:42:25.903]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:25.903]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:25.903]     }
[17:42:25.903]     ...future.result <- base::tryCatch({
[17:42:25.903]         base::withCallingHandlers({
[17:42:25.903]             ...future.value <- base::withVisible(base::local({
[17:42:25.903]                 lm(weight ~ group - 1)
[17:42:25.903]             }))
[17:42:25.903]             future::FutureResult(value = ...future.value$value, 
[17:42:25.903]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:25.903]                   ...future.rng), globalenv = if (FALSE) 
[17:42:25.903]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:25.903]                     ...future.globalenv.names))
[17:42:25.903]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:25.903]         }, condition = base::local({
[17:42:25.903]             c <- base::c
[17:42:25.903]             inherits <- base::inherits
[17:42:25.903]             invokeRestart <- base::invokeRestart
[17:42:25.903]             length <- base::length
[17:42:25.903]             list <- base::list
[17:42:25.903]             seq.int <- base::seq.int
[17:42:25.903]             signalCondition <- base::signalCondition
[17:42:25.903]             sys.calls <- base::sys.calls
[17:42:25.903]             `[[` <- base::`[[`
[17:42:25.903]             `+` <- base::`+`
[17:42:25.903]             `<<-` <- base::`<<-`
[17:42:25.903]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:25.903]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:25.903]                   3L)]
[17:42:25.903]             }
[17:42:25.903]             function(cond) {
[17:42:25.903]                 is_error <- inherits(cond, "error")
[17:42:25.903]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:25.903]                   NULL)
[17:42:25.903]                 if (is_error) {
[17:42:25.903]                   sessionInformation <- function() {
[17:42:25.903]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:25.903]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:25.903]                       search = base::search(), system = base::Sys.info())
[17:42:25.903]                   }
[17:42:25.903]                   ...future.conditions[[length(...future.conditions) + 
[17:42:25.903]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:25.903]                     cond$call), session = sessionInformation(), 
[17:42:25.903]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:25.903]                   signalCondition(cond)
[17:42:25.903]                 }
[17:42:25.903]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:25.903]                 "immediateCondition"))) {
[17:42:25.903]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:25.903]                   ...future.conditions[[length(...future.conditions) + 
[17:42:25.903]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:25.903]                   if (TRUE && !signal) {
[17:42:25.903]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:25.903]                     {
[17:42:25.903]                       inherits <- base::inherits
[17:42:25.903]                       invokeRestart <- base::invokeRestart
[17:42:25.903]                       is.null <- base::is.null
[17:42:25.903]                       muffled <- FALSE
[17:42:25.903]                       if (inherits(cond, "message")) {
[17:42:25.903]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:25.903]                         if (muffled) 
[17:42:25.903]                           invokeRestart("muffleMessage")
[17:42:25.903]                       }
[17:42:25.903]                       else if (inherits(cond, "warning")) {
[17:42:25.903]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:25.903]                         if (muffled) 
[17:42:25.903]                           invokeRestart("muffleWarning")
[17:42:25.903]                       }
[17:42:25.903]                       else if (inherits(cond, "condition")) {
[17:42:25.903]                         if (!is.null(pattern)) {
[17:42:25.903]                           computeRestarts <- base::computeRestarts
[17:42:25.903]                           grepl <- base::grepl
[17:42:25.903]                           restarts <- computeRestarts(cond)
[17:42:25.903]                           for (restart in restarts) {
[17:42:25.903]                             name <- restart$name
[17:42:25.903]                             if (is.null(name)) 
[17:42:25.903]                               next
[17:42:25.903]                             if (!grepl(pattern, name)) 
[17:42:25.903]                               next
[17:42:25.903]                             invokeRestart(restart)
[17:42:25.903]                             muffled <- TRUE
[17:42:25.903]                             break
[17:42:25.903]                           }
[17:42:25.903]                         }
[17:42:25.903]                       }
[17:42:25.903]                       invisible(muffled)
[17:42:25.903]                     }
[17:42:25.903]                     muffleCondition(cond, pattern = "^muffle")
[17:42:25.903]                   }
[17:42:25.903]                 }
[17:42:25.903]                 else {
[17:42:25.903]                   if (TRUE) {
[17:42:25.903]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:25.903]                     {
[17:42:25.903]                       inherits <- base::inherits
[17:42:25.903]                       invokeRestart <- base::invokeRestart
[17:42:25.903]                       is.null <- base::is.null
[17:42:25.903]                       muffled <- FALSE
[17:42:25.903]                       if (inherits(cond, "message")) {
[17:42:25.903]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:25.903]                         if (muffled) 
[17:42:25.903]                           invokeRestart("muffleMessage")
[17:42:25.903]                       }
[17:42:25.903]                       else if (inherits(cond, "warning")) {
[17:42:25.903]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:25.903]                         if (muffled) 
[17:42:25.903]                           invokeRestart("muffleWarning")
[17:42:25.903]                       }
[17:42:25.903]                       else if (inherits(cond, "condition")) {
[17:42:25.903]                         if (!is.null(pattern)) {
[17:42:25.903]                           computeRestarts <- base::computeRestarts
[17:42:25.903]                           grepl <- base::grepl
[17:42:25.903]                           restarts <- computeRestarts(cond)
[17:42:25.903]                           for (restart in restarts) {
[17:42:25.903]                             name <- restart$name
[17:42:25.903]                             if (is.null(name)) 
[17:42:25.903]                               next
[17:42:25.903]                             if (!grepl(pattern, name)) 
[17:42:25.903]                               next
[17:42:25.903]                             invokeRestart(restart)
[17:42:25.903]                             muffled <- TRUE
[17:42:25.903]                             break
[17:42:25.903]                           }
[17:42:25.903]                         }
[17:42:25.903]                       }
[17:42:25.903]                       invisible(muffled)
[17:42:25.903]                     }
[17:42:25.903]                     muffleCondition(cond, pattern = "^muffle")
[17:42:25.903]                   }
[17:42:25.903]                 }
[17:42:25.903]             }
[17:42:25.903]         }))
[17:42:25.903]     }, error = function(ex) {
[17:42:25.903]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:25.903]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:25.903]                 ...future.rng), started = ...future.startTime, 
[17:42:25.903]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:25.903]             version = "1.8"), class = "FutureResult")
[17:42:25.903]     }, finally = {
[17:42:25.903]         if (!identical(...future.workdir, getwd())) 
[17:42:25.903]             setwd(...future.workdir)
[17:42:25.903]         {
[17:42:25.903]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:25.903]                 ...future.oldOptions$nwarnings <- NULL
[17:42:25.903]             }
[17:42:25.903]             base::options(...future.oldOptions)
[17:42:25.903]             if (.Platform$OS.type == "windows") {
[17:42:25.903]                 old_names <- names(...future.oldEnvVars)
[17:42:25.903]                 envs <- base::Sys.getenv()
[17:42:25.903]                 names <- names(envs)
[17:42:25.903]                 common <- intersect(names, old_names)
[17:42:25.903]                 added <- setdiff(names, old_names)
[17:42:25.903]                 removed <- setdiff(old_names, names)
[17:42:25.903]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:25.903]                   envs[common]]
[17:42:25.903]                 NAMES <- toupper(changed)
[17:42:25.903]                 args <- list()
[17:42:25.903]                 for (kk in seq_along(NAMES)) {
[17:42:25.903]                   name <- changed[[kk]]
[17:42:25.903]                   NAME <- NAMES[[kk]]
[17:42:25.903]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:25.903]                     next
[17:42:25.903]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:25.903]                 }
[17:42:25.903]                 NAMES <- toupper(added)
[17:42:25.903]                 for (kk in seq_along(NAMES)) {
[17:42:25.903]                   name <- added[[kk]]
[17:42:25.903]                   NAME <- NAMES[[kk]]
[17:42:25.903]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:25.903]                     next
[17:42:25.903]                   args[[name]] <- ""
[17:42:25.903]                 }
[17:42:25.903]                 NAMES <- toupper(removed)
[17:42:25.903]                 for (kk in seq_along(NAMES)) {
[17:42:25.903]                   name <- removed[[kk]]
[17:42:25.903]                   NAME <- NAMES[[kk]]
[17:42:25.903]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:25.903]                     next
[17:42:25.903]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:25.903]                 }
[17:42:25.903]                 if (length(args) > 0) 
[17:42:25.903]                   base::do.call(base::Sys.setenv, args = args)
[17:42:25.903]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:25.903]             }
[17:42:25.903]             else {
[17:42:25.903]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:25.903]             }
[17:42:25.903]             {
[17:42:25.903]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:25.903]                   0L) {
[17:42:25.903]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:25.903]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:25.903]                   base::options(opts)
[17:42:25.903]                 }
[17:42:25.903]                 {
[17:42:25.903]                   {
[17:42:25.903]                     NULL
[17:42:25.903]                     RNGkind("Mersenne-Twister")
[17:42:25.903]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:25.903]                       inherits = FALSE)
[17:42:25.903]                   }
[17:42:25.903]                   options(future.plan = NULL)
[17:42:25.903]                   if (is.na(NA_character_)) 
[17:42:25.903]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:25.903]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:25.903]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:25.903]                   {
[17:42:25.903]                     future <- SequentialFuture(..., envir = envir)
[17:42:25.903]                     if (!future$lazy) 
[17:42:25.903]                       future <- run(future)
[17:42:25.903]                     invisible(future)
[17:42:25.903]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:25.903]                 }
[17:42:25.903]             }
[17:42:25.903]         }
[17:42:25.903]     })
[17:42:25.903]     if (TRUE) {
[17:42:25.903]         base::sink(type = "output", split = FALSE)
[17:42:25.903]         if (TRUE) {
[17:42:25.903]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:25.903]         }
[17:42:25.903]         else {
[17:42:25.903]             ...future.result["stdout"] <- base::list(NULL)
[17:42:25.903]         }
[17:42:25.903]         base::close(...future.stdout)
[17:42:25.903]         ...future.stdout <- NULL
[17:42:25.903]     }
[17:42:25.903]     ...future.result$conditions <- ...future.conditions
[17:42:25.903]     ...future.result$finished <- base::Sys.time()
[17:42:25.903]     ...future.result
[17:42:25.903] }
[17:42:25.904] assign_globals() ...
[17:42:25.905] List of 2
[17:42:25.905]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[17:42:25.905]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[17:42:25.905]  - attr(*, "where")=List of 2
[17:42:25.905]   ..$ weight:<environment: R_EmptyEnv> 
[17:42:25.905]   ..$ group :<environment: R_EmptyEnv> 
[17:42:25.905]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:25.905]  - attr(*, "resolved")= logi FALSE
[17:42:25.905]  - attr(*, "total_size")= num 896
[17:42:25.905]  - attr(*, "already-done")= logi TRUE
[17:42:25.908] - copied ‘weight’ to environment
[17:42:25.908] - copied ‘group’ to environment
[17:42:25.908] assign_globals() ... done
[17:42:25.908] plan(): Setting new future strategy stack:
[17:42:25.908] List of future strategies:
[17:42:25.908] 1. sequential:
[17:42:25.908]    - args: function (..., envir = parent.frame())
[17:42:25.908]    - tweaked: FALSE
[17:42:25.908]    - call: NULL
[17:42:25.909] plan(): nbrOfWorkers() = 1
[17:42:25.910] plan(): Setting new future strategy stack:
[17:42:25.910] List of future strategies:
[17:42:25.910] 1. sequential:
[17:42:25.910]    - args: function (..., envir = parent.frame())
[17:42:25.910]    - tweaked: FALSE
[17:42:25.910]    - call: plan(strategy)
[17:42:25.910] plan(): nbrOfWorkers() = 1
[17:42:25.912] SequentialFuture started (and completed)
[17:42:25.912] - Launch lazy future ... done
[17:42:25.912] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[17:42:25.914] getGlobalsAndPackages() ...
[17:42:25.914] Searching for globals...
[17:42:25.915] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[17:42:25.915] Searching for globals ... DONE
[17:42:25.915] Resolving globals: FALSE
[17:42:25.916] The total size of the 1 globals is 96 bytes (96 bytes)
[17:42:25.916] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[17:42:25.916] - globals: [1] ‘x’
[17:42:25.916] - packages: [1] ‘stats’
[17:42:25.916] getGlobalsAndPackages() ... DONE
[17:42:25.916] run() for ‘Future’ ...
[17:42:25.917] - state: ‘created’
[17:42:25.917] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:25.917] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:25.917] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:25.917]   - Field: ‘label’
[17:42:25.917]   - Field: ‘local’
[17:42:25.917]   - Field: ‘owner’
[17:42:25.917]   - Field: ‘envir’
[17:42:25.918]   - Field: ‘packages’
[17:42:25.918]   - Field: ‘gc’
[17:42:25.918]   - Field: ‘conditions’
[17:42:25.918]   - Field: ‘expr’
[17:42:25.918]   - Field: ‘uuid’
[17:42:25.918]   - Field: ‘seed’
[17:42:25.918]   - Field: ‘version’
[17:42:25.918]   - Field: ‘result’
[17:42:25.918]   - Field: ‘asynchronous’
[17:42:25.919]   - Field: ‘calls’
[17:42:25.919]   - Field: ‘globals’
[17:42:25.919]   - Field: ‘stdout’
[17:42:25.919]   - Field: ‘earlySignal’
[17:42:25.919]   - Field: ‘lazy’
[17:42:25.919]   - Field: ‘state’
[17:42:25.919] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:25.919] - Launch lazy future ...
[17:42:25.920] Packages needed by the future expression (n = 1): ‘stats’
[17:42:25.920] Packages needed by future strategies (n = 0): <none>
[17:42:25.920] {
[17:42:25.920]     {
[17:42:25.920]         {
[17:42:25.920]             ...future.startTime <- base::Sys.time()
[17:42:25.920]             {
[17:42:25.920]                 {
[17:42:25.920]                   {
[17:42:25.920]                     {
[17:42:25.920]                       base::local({
[17:42:25.920]                         has_future <- base::requireNamespace("future", 
[17:42:25.920]                           quietly = TRUE)
[17:42:25.920]                         if (has_future) {
[17:42:25.920]                           ns <- base::getNamespace("future")
[17:42:25.920]                           version <- ns[[".package"]][["version"]]
[17:42:25.920]                           if (is.null(version)) 
[17:42:25.920]                             version <- utils::packageVersion("future")
[17:42:25.920]                         }
[17:42:25.920]                         else {
[17:42:25.920]                           version <- NULL
[17:42:25.920]                         }
[17:42:25.920]                         if (!has_future || version < "1.8.0") {
[17:42:25.920]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:25.920]                             "", base::R.version$version.string), 
[17:42:25.920]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:25.920]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:25.920]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:25.920]                               "release", "version")], collapse = " "), 
[17:42:25.920]                             hostname = base::Sys.info()[["nodename"]])
[17:42:25.920]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:25.920]                             info)
[17:42:25.920]                           info <- base::paste(info, collapse = "; ")
[17:42:25.920]                           if (!has_future) {
[17:42:25.920]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:25.920]                               info)
[17:42:25.920]                           }
[17:42:25.920]                           else {
[17:42:25.920]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:25.920]                               info, version)
[17:42:25.920]                           }
[17:42:25.920]                           base::stop(msg)
[17:42:25.920]                         }
[17:42:25.920]                       })
[17:42:25.920]                     }
[17:42:25.920]                     base::local({
[17:42:25.920]                       for (pkg in "stats") {
[17:42:25.920]                         base::loadNamespace(pkg)
[17:42:25.920]                         base::library(pkg, character.only = TRUE)
[17:42:25.920]                       }
[17:42:25.920]                     })
[17:42:25.920]                   }
[17:42:25.920]                   options(future.plan = NULL)
[17:42:25.920]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:25.920]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:25.920]                 }
[17:42:25.920]                 ...future.workdir <- getwd()
[17:42:25.920]             }
[17:42:25.920]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:25.920]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:25.920]         }
[17:42:25.920]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:25.920]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:25.920]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:25.920]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:25.920]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:25.920]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:25.920]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:25.920]             base::names(...future.oldOptions))
[17:42:25.920]     }
[17:42:25.920]     if (FALSE) {
[17:42:25.920]     }
[17:42:25.920]     else {
[17:42:25.920]         if (TRUE) {
[17:42:25.920]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:25.920]                 open = "w")
[17:42:25.920]         }
[17:42:25.920]         else {
[17:42:25.920]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:25.920]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:25.920]         }
[17:42:25.920]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:25.920]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:25.920]             base::sink(type = "output", split = FALSE)
[17:42:25.920]             base::close(...future.stdout)
[17:42:25.920]         }, add = TRUE)
[17:42:25.920]     }
[17:42:25.920]     ...future.frame <- base::sys.nframe()
[17:42:25.920]     ...future.conditions <- base::list()
[17:42:25.920]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:25.920]     if (FALSE) {
[17:42:25.920]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:25.920]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:25.920]     }
[17:42:25.920]     ...future.result <- base::tryCatch({
[17:42:25.920]         base::withCallingHandlers({
[17:42:25.920]             ...future.value <- base::withVisible(base::local({
[17:42:25.920]                 xtabs(~x)
[17:42:25.920]             }))
[17:42:25.920]             future::FutureResult(value = ...future.value$value, 
[17:42:25.920]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:25.920]                   ...future.rng), globalenv = if (FALSE) 
[17:42:25.920]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:25.920]                     ...future.globalenv.names))
[17:42:25.920]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:25.920]         }, condition = base::local({
[17:42:25.920]             c <- base::c
[17:42:25.920]             inherits <- base::inherits
[17:42:25.920]             invokeRestart <- base::invokeRestart
[17:42:25.920]             length <- base::length
[17:42:25.920]             list <- base::list
[17:42:25.920]             seq.int <- base::seq.int
[17:42:25.920]             signalCondition <- base::signalCondition
[17:42:25.920]             sys.calls <- base::sys.calls
[17:42:25.920]             `[[` <- base::`[[`
[17:42:25.920]             `+` <- base::`+`
[17:42:25.920]             `<<-` <- base::`<<-`
[17:42:25.920]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:25.920]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:25.920]                   3L)]
[17:42:25.920]             }
[17:42:25.920]             function(cond) {
[17:42:25.920]                 is_error <- inherits(cond, "error")
[17:42:25.920]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:25.920]                   NULL)
[17:42:25.920]                 if (is_error) {
[17:42:25.920]                   sessionInformation <- function() {
[17:42:25.920]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:25.920]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:25.920]                       search = base::search(), system = base::Sys.info())
[17:42:25.920]                   }
[17:42:25.920]                   ...future.conditions[[length(...future.conditions) + 
[17:42:25.920]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:25.920]                     cond$call), session = sessionInformation(), 
[17:42:25.920]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:25.920]                   signalCondition(cond)
[17:42:25.920]                 }
[17:42:25.920]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:25.920]                 "immediateCondition"))) {
[17:42:25.920]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:25.920]                   ...future.conditions[[length(...future.conditions) + 
[17:42:25.920]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:25.920]                   if (TRUE && !signal) {
[17:42:25.920]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:25.920]                     {
[17:42:25.920]                       inherits <- base::inherits
[17:42:25.920]                       invokeRestart <- base::invokeRestart
[17:42:25.920]                       is.null <- base::is.null
[17:42:25.920]                       muffled <- FALSE
[17:42:25.920]                       if (inherits(cond, "message")) {
[17:42:25.920]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:25.920]                         if (muffled) 
[17:42:25.920]                           invokeRestart("muffleMessage")
[17:42:25.920]                       }
[17:42:25.920]                       else if (inherits(cond, "warning")) {
[17:42:25.920]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:25.920]                         if (muffled) 
[17:42:25.920]                           invokeRestart("muffleWarning")
[17:42:25.920]                       }
[17:42:25.920]                       else if (inherits(cond, "condition")) {
[17:42:25.920]                         if (!is.null(pattern)) {
[17:42:25.920]                           computeRestarts <- base::computeRestarts
[17:42:25.920]                           grepl <- base::grepl
[17:42:25.920]                           restarts <- computeRestarts(cond)
[17:42:25.920]                           for (restart in restarts) {
[17:42:25.920]                             name <- restart$name
[17:42:25.920]                             if (is.null(name)) 
[17:42:25.920]                               next
[17:42:25.920]                             if (!grepl(pattern, name)) 
[17:42:25.920]                               next
[17:42:25.920]                             invokeRestart(restart)
[17:42:25.920]                             muffled <- TRUE
[17:42:25.920]                             break
[17:42:25.920]                           }
[17:42:25.920]                         }
[17:42:25.920]                       }
[17:42:25.920]                       invisible(muffled)
[17:42:25.920]                     }
[17:42:25.920]                     muffleCondition(cond, pattern = "^muffle")
[17:42:25.920]                   }
[17:42:25.920]                 }
[17:42:25.920]                 else {
[17:42:25.920]                   if (TRUE) {
[17:42:25.920]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:25.920]                     {
[17:42:25.920]                       inherits <- base::inherits
[17:42:25.920]                       invokeRestart <- base::invokeRestart
[17:42:25.920]                       is.null <- base::is.null
[17:42:25.920]                       muffled <- FALSE
[17:42:25.920]                       if (inherits(cond, "message")) {
[17:42:25.920]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:25.920]                         if (muffled) 
[17:42:25.920]                           invokeRestart("muffleMessage")
[17:42:25.920]                       }
[17:42:25.920]                       else if (inherits(cond, "warning")) {
[17:42:25.920]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:25.920]                         if (muffled) 
[17:42:25.920]                           invokeRestart("muffleWarning")
[17:42:25.920]                       }
[17:42:25.920]                       else if (inherits(cond, "condition")) {
[17:42:25.920]                         if (!is.null(pattern)) {
[17:42:25.920]                           computeRestarts <- base::computeRestarts
[17:42:25.920]                           grepl <- base::grepl
[17:42:25.920]                           restarts <- computeRestarts(cond)
[17:42:25.920]                           for (restart in restarts) {
[17:42:25.920]                             name <- restart$name
[17:42:25.920]                             if (is.null(name)) 
[17:42:25.920]                               next
[17:42:25.920]                             if (!grepl(pattern, name)) 
[17:42:25.920]                               next
[17:42:25.920]                             invokeRestart(restart)
[17:42:25.920]                             muffled <- TRUE
[17:42:25.920]                             break
[17:42:25.920]                           }
[17:42:25.920]                         }
[17:42:25.920]                       }
[17:42:25.920]                       invisible(muffled)
[17:42:25.920]                     }
[17:42:25.920]                     muffleCondition(cond, pattern = "^muffle")
[17:42:25.920]                   }
[17:42:25.920]                 }
[17:42:25.920]             }
[17:42:25.920]         }))
[17:42:25.920]     }, error = function(ex) {
[17:42:25.920]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:25.920]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:25.920]                 ...future.rng), started = ...future.startTime, 
[17:42:25.920]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:25.920]             version = "1.8"), class = "FutureResult")
[17:42:25.920]     }, finally = {
[17:42:25.920]         if (!identical(...future.workdir, getwd())) 
[17:42:25.920]             setwd(...future.workdir)
[17:42:25.920]         {
[17:42:25.920]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:25.920]                 ...future.oldOptions$nwarnings <- NULL
[17:42:25.920]             }
[17:42:25.920]             base::options(...future.oldOptions)
[17:42:25.920]             if (.Platform$OS.type == "windows") {
[17:42:25.920]                 old_names <- names(...future.oldEnvVars)
[17:42:25.920]                 envs <- base::Sys.getenv()
[17:42:25.920]                 names <- names(envs)
[17:42:25.920]                 common <- intersect(names, old_names)
[17:42:25.920]                 added <- setdiff(names, old_names)
[17:42:25.920]                 removed <- setdiff(old_names, names)
[17:42:25.920]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:25.920]                   envs[common]]
[17:42:25.920]                 NAMES <- toupper(changed)
[17:42:25.920]                 args <- list()
[17:42:25.920]                 for (kk in seq_along(NAMES)) {
[17:42:25.920]                   name <- changed[[kk]]
[17:42:25.920]                   NAME <- NAMES[[kk]]
[17:42:25.920]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:25.920]                     next
[17:42:25.920]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:25.920]                 }
[17:42:25.920]                 NAMES <- toupper(added)
[17:42:25.920]                 for (kk in seq_along(NAMES)) {
[17:42:25.920]                   name <- added[[kk]]
[17:42:25.920]                   NAME <- NAMES[[kk]]
[17:42:25.920]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:25.920]                     next
[17:42:25.920]                   args[[name]] <- ""
[17:42:25.920]                 }
[17:42:25.920]                 NAMES <- toupper(removed)
[17:42:25.920]                 for (kk in seq_along(NAMES)) {
[17:42:25.920]                   name <- removed[[kk]]
[17:42:25.920]                   NAME <- NAMES[[kk]]
[17:42:25.920]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:25.920]                     next
[17:42:25.920]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:25.920]                 }
[17:42:25.920]                 if (length(args) > 0) 
[17:42:25.920]                   base::do.call(base::Sys.setenv, args = args)
[17:42:25.920]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:25.920]             }
[17:42:25.920]             else {
[17:42:25.920]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:25.920]             }
[17:42:25.920]             {
[17:42:25.920]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:25.920]                   0L) {
[17:42:25.920]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:25.920]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:25.920]                   base::options(opts)
[17:42:25.920]                 }
[17:42:25.920]                 {
[17:42:25.920]                   {
[17:42:25.920]                     NULL
[17:42:25.920]                     RNGkind("Mersenne-Twister")
[17:42:25.920]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:25.920]                       inherits = FALSE)
[17:42:25.920]                   }
[17:42:25.920]                   options(future.plan = NULL)
[17:42:25.920]                   if (is.na(NA_character_)) 
[17:42:25.920]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:25.920]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:25.920]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:25.920]                   {
[17:42:25.920]                     future <- SequentialFuture(..., envir = envir)
[17:42:25.920]                     if (!future$lazy) 
[17:42:25.920]                       future <- run(future)
[17:42:25.920]                     invisible(future)
[17:42:25.920]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:25.920]                 }
[17:42:25.920]             }
[17:42:25.920]         }
[17:42:25.920]     })
[17:42:25.920]     if (TRUE) {
[17:42:25.920]         base::sink(type = "output", split = FALSE)
[17:42:25.920]         if (TRUE) {
[17:42:25.920]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:25.920]         }
[17:42:25.920]         else {
[17:42:25.920]             ...future.result["stdout"] <- base::list(NULL)
[17:42:25.920]         }
[17:42:25.920]         base::close(...future.stdout)
[17:42:25.920]         ...future.stdout <- NULL
[17:42:25.920]     }
[17:42:25.920]     ...future.result$conditions <- ...future.conditions
[17:42:25.920]     ...future.result$finished <- base::Sys.time()
[17:42:25.920]     ...future.result
[17:42:25.920] }
[17:42:25.922] assign_globals() ...
[17:42:25.922] List of 1
[17:42:25.922]  $ x: num [1:5] 1 1 2 2 2
[17:42:25.922]  - attr(*, "where")=List of 1
[17:42:25.922]   ..$ x:<environment: R_EmptyEnv> 
[17:42:25.922]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:25.922]  - attr(*, "resolved")= logi FALSE
[17:42:25.922]  - attr(*, "total_size")= num 96
[17:42:25.922]  - attr(*, "already-done")= logi TRUE
[17:42:25.925] - copied ‘x’ to environment
[17:42:25.925] assign_globals() ... done
[17:42:25.925] plan(): Setting new future strategy stack:
[17:42:25.925] List of future strategies:
[17:42:25.925] 1. sequential:
[17:42:25.925]    - args: function (..., envir = parent.frame())
[17:42:25.925]    - tweaked: FALSE
[17:42:25.925]    - call: NULL
[17:42:25.926] plan(): nbrOfWorkers() = 1
[17:42:25.927] plan(): Setting new future strategy stack:
[17:42:25.927] List of future strategies:
[17:42:25.927] 1. sequential:
[17:42:25.927]    - args: function (..., envir = parent.frame())
[17:42:25.927]    - tweaked: FALSE
[17:42:25.927]    - call: plan(strategy)
[17:42:25.927] plan(): nbrOfWorkers() = 1
[17:42:25.927] SequentialFuture started (and completed)
[17:42:25.928] - Launch lazy future ... done
[17:42:25.928] run() for ‘SequentialFuture’ ... done
x
1 2 
2 3 
[17:42:25.928] getGlobalsAndPackages() ...
[17:42:25.928] Searching for globals...
[17:42:25.930] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[17:42:25.930] Searching for globals ... DONE
[17:42:25.930] Resolving globals: FALSE
[17:42:25.930] The total size of the 1 globals is 96 bytes (96 bytes)
[17:42:25.930] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[17:42:25.931] - globals: [1] ‘x’
[17:42:25.931] - packages: [1] ‘stats’
[17:42:25.931] getGlobalsAndPackages() ... DONE
[17:42:25.931] run() for ‘Future’ ...
[17:42:25.931] - state: ‘created’
[17:42:25.931] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:25.932] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:25.932] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:25.932]   - Field: ‘label’
[17:42:25.932]   - Field: ‘local’
[17:42:25.932]   - Field: ‘owner’
[17:42:25.932]   - Field: ‘envir’
[17:42:25.932]   - Field: ‘packages’
[17:42:25.932]   - Field: ‘gc’
[17:42:25.932]   - Field: ‘conditions’
[17:42:25.933]   - Field: ‘expr’
[17:42:25.933]   - Field: ‘uuid’
[17:42:25.933]   - Field: ‘seed’
[17:42:25.933]   - Field: ‘version’
[17:42:25.933]   - Field: ‘result’
[17:42:25.933]   - Field: ‘asynchronous’
[17:42:25.933]   - Field: ‘calls’
[17:42:25.933]   - Field: ‘globals’
[17:42:25.933]   - Field: ‘stdout’
[17:42:25.933]   - Field: ‘earlySignal’
[17:42:25.933]   - Field: ‘lazy’
[17:42:25.934]   - Field: ‘state’
[17:42:25.934] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:25.934] - Launch lazy future ...
[17:42:25.934] Packages needed by the future expression (n = 1): ‘stats’
[17:42:25.934] Packages needed by future strategies (n = 0): <none>
[17:42:25.935] {
[17:42:25.935]     {
[17:42:25.935]         {
[17:42:25.935]             ...future.startTime <- base::Sys.time()
[17:42:25.935]             {
[17:42:25.935]                 {
[17:42:25.935]                   {
[17:42:25.935]                     {
[17:42:25.935]                       base::local({
[17:42:25.935]                         has_future <- base::requireNamespace("future", 
[17:42:25.935]                           quietly = TRUE)
[17:42:25.935]                         if (has_future) {
[17:42:25.935]                           ns <- base::getNamespace("future")
[17:42:25.935]                           version <- ns[[".package"]][["version"]]
[17:42:25.935]                           if (is.null(version)) 
[17:42:25.935]                             version <- utils::packageVersion("future")
[17:42:25.935]                         }
[17:42:25.935]                         else {
[17:42:25.935]                           version <- NULL
[17:42:25.935]                         }
[17:42:25.935]                         if (!has_future || version < "1.8.0") {
[17:42:25.935]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:25.935]                             "", base::R.version$version.string), 
[17:42:25.935]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:25.935]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:25.935]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:25.935]                               "release", "version")], collapse = " "), 
[17:42:25.935]                             hostname = base::Sys.info()[["nodename"]])
[17:42:25.935]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:25.935]                             info)
[17:42:25.935]                           info <- base::paste(info, collapse = "; ")
[17:42:25.935]                           if (!has_future) {
[17:42:25.935]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:25.935]                               info)
[17:42:25.935]                           }
[17:42:25.935]                           else {
[17:42:25.935]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:25.935]                               info, version)
[17:42:25.935]                           }
[17:42:25.935]                           base::stop(msg)
[17:42:25.935]                         }
[17:42:25.935]                       })
[17:42:25.935]                     }
[17:42:25.935]                     base::local({
[17:42:25.935]                       for (pkg in "stats") {
[17:42:25.935]                         base::loadNamespace(pkg)
[17:42:25.935]                         base::library(pkg, character.only = TRUE)
[17:42:25.935]                       }
[17:42:25.935]                     })
[17:42:25.935]                   }
[17:42:25.935]                   options(future.plan = NULL)
[17:42:25.935]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:25.935]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:25.935]                 }
[17:42:25.935]                 ...future.workdir <- getwd()
[17:42:25.935]             }
[17:42:25.935]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:25.935]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:25.935]         }
[17:42:25.935]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:25.935]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:25.935]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:25.935]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:25.935]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:25.935]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:25.935]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:25.935]             base::names(...future.oldOptions))
[17:42:25.935]     }
[17:42:25.935]     if (FALSE) {
[17:42:25.935]     }
[17:42:25.935]     else {
[17:42:25.935]         if (TRUE) {
[17:42:25.935]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:25.935]                 open = "w")
[17:42:25.935]         }
[17:42:25.935]         else {
[17:42:25.935]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:25.935]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:25.935]         }
[17:42:25.935]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:25.935]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:25.935]             base::sink(type = "output", split = FALSE)
[17:42:25.935]             base::close(...future.stdout)
[17:42:25.935]         }, add = TRUE)
[17:42:25.935]     }
[17:42:25.935]     ...future.frame <- base::sys.nframe()
[17:42:25.935]     ...future.conditions <- base::list()
[17:42:25.935]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:25.935]     if (FALSE) {
[17:42:25.935]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:25.935]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:25.935]     }
[17:42:25.935]     ...future.result <- base::tryCatch({
[17:42:25.935]         base::withCallingHandlers({
[17:42:25.935]             ...future.value <- base::withVisible(base::local({
[17:42:25.935]                 xtabs(~x)
[17:42:25.935]             }))
[17:42:25.935]             future::FutureResult(value = ...future.value$value, 
[17:42:25.935]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:25.935]                   ...future.rng), globalenv = if (FALSE) 
[17:42:25.935]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:25.935]                     ...future.globalenv.names))
[17:42:25.935]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:25.935]         }, condition = base::local({
[17:42:25.935]             c <- base::c
[17:42:25.935]             inherits <- base::inherits
[17:42:25.935]             invokeRestart <- base::invokeRestart
[17:42:25.935]             length <- base::length
[17:42:25.935]             list <- base::list
[17:42:25.935]             seq.int <- base::seq.int
[17:42:25.935]             signalCondition <- base::signalCondition
[17:42:25.935]             sys.calls <- base::sys.calls
[17:42:25.935]             `[[` <- base::`[[`
[17:42:25.935]             `+` <- base::`+`
[17:42:25.935]             `<<-` <- base::`<<-`
[17:42:25.935]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:25.935]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:25.935]                   3L)]
[17:42:25.935]             }
[17:42:25.935]             function(cond) {
[17:42:25.935]                 is_error <- inherits(cond, "error")
[17:42:25.935]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:25.935]                   NULL)
[17:42:25.935]                 if (is_error) {
[17:42:25.935]                   sessionInformation <- function() {
[17:42:25.935]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:25.935]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:25.935]                       search = base::search(), system = base::Sys.info())
[17:42:25.935]                   }
[17:42:25.935]                   ...future.conditions[[length(...future.conditions) + 
[17:42:25.935]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:25.935]                     cond$call), session = sessionInformation(), 
[17:42:25.935]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:25.935]                   signalCondition(cond)
[17:42:25.935]                 }
[17:42:25.935]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:25.935]                 "immediateCondition"))) {
[17:42:25.935]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:25.935]                   ...future.conditions[[length(...future.conditions) + 
[17:42:25.935]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:25.935]                   if (TRUE && !signal) {
[17:42:25.935]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:25.935]                     {
[17:42:25.935]                       inherits <- base::inherits
[17:42:25.935]                       invokeRestart <- base::invokeRestart
[17:42:25.935]                       is.null <- base::is.null
[17:42:25.935]                       muffled <- FALSE
[17:42:25.935]                       if (inherits(cond, "message")) {
[17:42:25.935]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:25.935]                         if (muffled) 
[17:42:25.935]                           invokeRestart("muffleMessage")
[17:42:25.935]                       }
[17:42:25.935]                       else if (inherits(cond, "warning")) {
[17:42:25.935]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:25.935]                         if (muffled) 
[17:42:25.935]                           invokeRestart("muffleWarning")
[17:42:25.935]                       }
[17:42:25.935]                       else if (inherits(cond, "condition")) {
[17:42:25.935]                         if (!is.null(pattern)) {
[17:42:25.935]                           computeRestarts <- base::computeRestarts
[17:42:25.935]                           grepl <- base::grepl
[17:42:25.935]                           restarts <- computeRestarts(cond)
[17:42:25.935]                           for (restart in restarts) {
[17:42:25.935]                             name <- restart$name
[17:42:25.935]                             if (is.null(name)) 
[17:42:25.935]                               next
[17:42:25.935]                             if (!grepl(pattern, name)) 
[17:42:25.935]                               next
[17:42:25.935]                             invokeRestart(restart)
[17:42:25.935]                             muffled <- TRUE
[17:42:25.935]                             break
[17:42:25.935]                           }
[17:42:25.935]                         }
[17:42:25.935]                       }
[17:42:25.935]                       invisible(muffled)
[17:42:25.935]                     }
[17:42:25.935]                     muffleCondition(cond, pattern = "^muffle")
[17:42:25.935]                   }
[17:42:25.935]                 }
[17:42:25.935]                 else {
[17:42:25.935]                   if (TRUE) {
[17:42:25.935]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:25.935]                     {
[17:42:25.935]                       inherits <- base::inherits
[17:42:25.935]                       invokeRestart <- base::invokeRestart
[17:42:25.935]                       is.null <- base::is.null
[17:42:25.935]                       muffled <- FALSE
[17:42:25.935]                       if (inherits(cond, "message")) {
[17:42:25.935]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:25.935]                         if (muffled) 
[17:42:25.935]                           invokeRestart("muffleMessage")
[17:42:25.935]                       }
[17:42:25.935]                       else if (inherits(cond, "warning")) {
[17:42:25.935]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:25.935]                         if (muffled) 
[17:42:25.935]                           invokeRestart("muffleWarning")
[17:42:25.935]                       }
[17:42:25.935]                       else if (inherits(cond, "condition")) {
[17:42:25.935]                         if (!is.null(pattern)) {
[17:42:25.935]                           computeRestarts <- base::computeRestarts
[17:42:25.935]                           grepl <- base::grepl
[17:42:25.935]                           restarts <- computeRestarts(cond)
[17:42:25.935]                           for (restart in restarts) {
[17:42:25.935]                             name <- restart$name
[17:42:25.935]                             if (is.null(name)) 
[17:42:25.935]                               next
[17:42:25.935]                             if (!grepl(pattern, name)) 
[17:42:25.935]                               next
[17:42:25.935]                             invokeRestart(restart)
[17:42:25.935]                             muffled <- TRUE
[17:42:25.935]                             break
[17:42:25.935]                           }
[17:42:25.935]                         }
[17:42:25.935]                       }
[17:42:25.935]                       invisible(muffled)
[17:42:25.935]                     }
[17:42:25.935]                     muffleCondition(cond, pattern = "^muffle")
[17:42:25.935]                   }
[17:42:25.935]                 }
[17:42:25.935]             }
[17:42:25.935]         }))
[17:42:25.935]     }, error = function(ex) {
[17:42:25.935]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:25.935]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:25.935]                 ...future.rng), started = ...future.startTime, 
[17:42:25.935]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:25.935]             version = "1.8"), class = "FutureResult")
[17:42:25.935]     }, finally = {
[17:42:25.935]         if (!identical(...future.workdir, getwd())) 
[17:42:25.935]             setwd(...future.workdir)
[17:42:25.935]         {
[17:42:25.935]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:25.935]                 ...future.oldOptions$nwarnings <- NULL
[17:42:25.935]             }
[17:42:25.935]             base::options(...future.oldOptions)
[17:42:25.935]             if (.Platform$OS.type == "windows") {
[17:42:25.935]                 old_names <- names(...future.oldEnvVars)
[17:42:25.935]                 envs <- base::Sys.getenv()
[17:42:25.935]                 names <- names(envs)
[17:42:25.935]                 common <- intersect(names, old_names)
[17:42:25.935]                 added <- setdiff(names, old_names)
[17:42:25.935]                 removed <- setdiff(old_names, names)
[17:42:25.935]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:25.935]                   envs[common]]
[17:42:25.935]                 NAMES <- toupper(changed)
[17:42:25.935]                 args <- list()
[17:42:25.935]                 for (kk in seq_along(NAMES)) {
[17:42:25.935]                   name <- changed[[kk]]
[17:42:25.935]                   NAME <- NAMES[[kk]]
[17:42:25.935]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:25.935]                     next
[17:42:25.935]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:25.935]                 }
[17:42:25.935]                 NAMES <- toupper(added)
[17:42:25.935]                 for (kk in seq_along(NAMES)) {
[17:42:25.935]                   name <- added[[kk]]
[17:42:25.935]                   NAME <- NAMES[[kk]]
[17:42:25.935]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:25.935]                     next
[17:42:25.935]                   args[[name]] <- ""
[17:42:25.935]                 }
[17:42:25.935]                 NAMES <- toupper(removed)
[17:42:25.935]                 for (kk in seq_along(NAMES)) {
[17:42:25.935]                   name <- removed[[kk]]
[17:42:25.935]                   NAME <- NAMES[[kk]]
[17:42:25.935]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:25.935]                     next
[17:42:25.935]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:25.935]                 }
[17:42:25.935]                 if (length(args) > 0) 
[17:42:25.935]                   base::do.call(base::Sys.setenv, args = args)
[17:42:25.935]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:25.935]             }
[17:42:25.935]             else {
[17:42:25.935]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:25.935]             }
[17:42:25.935]             {
[17:42:25.935]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:25.935]                   0L) {
[17:42:25.935]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:25.935]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:25.935]                   base::options(opts)
[17:42:25.935]                 }
[17:42:25.935]                 {
[17:42:25.935]                   {
[17:42:25.935]                     NULL
[17:42:25.935]                     RNGkind("Mersenne-Twister")
[17:42:25.935]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:25.935]                       inherits = FALSE)
[17:42:25.935]                   }
[17:42:25.935]                   options(future.plan = NULL)
[17:42:25.935]                   if (is.na(NA_character_)) 
[17:42:25.935]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:25.935]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:25.935]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:25.935]                   {
[17:42:25.935]                     future <- SequentialFuture(..., envir = envir)
[17:42:25.935]                     if (!future$lazy) 
[17:42:25.935]                       future <- run(future)
[17:42:25.935]                     invisible(future)
[17:42:25.935]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:25.935]                 }
[17:42:25.935]             }
[17:42:25.935]         }
[17:42:25.935]     })
[17:42:25.935]     if (TRUE) {
[17:42:25.935]         base::sink(type = "output", split = FALSE)
[17:42:25.935]         if (TRUE) {
[17:42:25.935]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:25.935]         }
[17:42:25.935]         else {
[17:42:25.935]             ...future.result["stdout"] <- base::list(NULL)
[17:42:25.935]         }
[17:42:25.935]         base::close(...future.stdout)
[17:42:25.935]         ...future.stdout <- NULL
[17:42:25.935]     }
[17:42:25.935]     ...future.result$conditions <- ...future.conditions
[17:42:25.935]     ...future.result$finished <- base::Sys.time()
[17:42:25.935]     ...future.result
[17:42:25.935] }
[17:42:25.936] assign_globals() ...
[17:42:25.936] List of 1
[17:42:25.936]  $ x: num [1:5] 1 1 2 2 2
[17:42:25.936]  - attr(*, "where")=List of 1
[17:42:25.936]   ..$ x:<environment: R_EmptyEnv> 
[17:42:25.936]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:25.936]  - attr(*, "resolved")= logi FALSE
[17:42:25.936]  - attr(*, "total_size")= num 96
[17:42:25.936]  - attr(*, "already-done")= logi TRUE
[17:42:25.941] - copied ‘x’ to environment
[17:42:25.941] assign_globals() ... done
[17:42:25.941] plan(): Setting new future strategy stack:
[17:42:25.941] List of future strategies:
[17:42:25.941] 1. sequential:
[17:42:25.941]    - args: function (..., envir = parent.frame())
[17:42:25.941]    - tweaked: FALSE
[17:42:25.941]    - call: NULL
[17:42:25.942] plan(): nbrOfWorkers() = 1
[17:42:25.943] plan(): Setting new future strategy stack:
[17:42:25.943] List of future strategies:
[17:42:25.943] 1. sequential:
[17:42:25.943]    - args: function (..., envir = parent.frame())
[17:42:25.943]    - tweaked: FALSE
[17:42:25.943]    - call: plan(strategy)
[17:42:25.943] plan(): nbrOfWorkers() = 1
[17:42:25.943] SequentialFuture started (and completed)
[17:42:25.943] - Launch lazy future ... done
[17:42:25.944] run() for ‘SequentialFuture’ ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[17:42:25.946] getGlobalsAndPackages() ...
[17:42:25.946] Searching for globals...
[17:42:25.947] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[17:42:25.947] Searching for globals ... DONE
[17:42:25.948] Resolving globals: FALSE
[17:42:25.948] 
[17:42:25.948] - packages: [2] ‘stats’, ‘datasets’
[17:42:25.948] getGlobalsAndPackages() ... DONE
[17:42:25.949] run() for ‘Future’ ...
[17:42:25.949] - state: ‘created’
[17:42:25.949] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:25.949] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:25.949] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:25.949]   - Field: ‘label’
[17:42:25.949]   - Field: ‘local’
[17:42:25.949]   - Field: ‘owner’
[17:42:25.950]   - Field: ‘envir’
[17:42:25.950]   - Field: ‘packages’
[17:42:25.950]   - Field: ‘gc’
[17:42:25.950]   - Field: ‘conditions’
[17:42:25.950]   - Field: ‘expr’
[17:42:25.950]   - Field: ‘uuid’
[17:42:25.950]   - Field: ‘seed’
[17:42:25.950]   - Field: ‘version’
[17:42:25.950]   - Field: ‘result’
[17:42:25.950]   - Field: ‘asynchronous’
[17:42:25.951]   - Field: ‘calls’
[17:42:25.951]   - Field: ‘globals’
[17:42:25.951]   - Field: ‘stdout’
[17:42:25.951]   - Field: ‘earlySignal’
[17:42:25.951]   - Field: ‘lazy’
[17:42:25.951]   - Field: ‘state’
[17:42:25.951] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:25.951] - Launch lazy future ...
[17:42:25.951] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:42:25.952] Packages needed by future strategies (n = 0): <none>
[17:42:25.952] {
[17:42:25.952]     {
[17:42:25.952]         {
[17:42:25.952]             ...future.startTime <- base::Sys.time()
[17:42:25.952]             {
[17:42:25.952]                 {
[17:42:25.952]                   {
[17:42:25.952]                     {
[17:42:25.952]                       base::local({
[17:42:25.952]                         has_future <- base::requireNamespace("future", 
[17:42:25.952]                           quietly = TRUE)
[17:42:25.952]                         if (has_future) {
[17:42:25.952]                           ns <- base::getNamespace("future")
[17:42:25.952]                           version <- ns[[".package"]][["version"]]
[17:42:25.952]                           if (is.null(version)) 
[17:42:25.952]                             version <- utils::packageVersion("future")
[17:42:25.952]                         }
[17:42:25.952]                         else {
[17:42:25.952]                           version <- NULL
[17:42:25.952]                         }
[17:42:25.952]                         if (!has_future || version < "1.8.0") {
[17:42:25.952]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:25.952]                             "", base::R.version$version.string), 
[17:42:25.952]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:25.952]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:25.952]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:25.952]                               "release", "version")], collapse = " "), 
[17:42:25.952]                             hostname = base::Sys.info()[["nodename"]])
[17:42:25.952]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:25.952]                             info)
[17:42:25.952]                           info <- base::paste(info, collapse = "; ")
[17:42:25.952]                           if (!has_future) {
[17:42:25.952]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:25.952]                               info)
[17:42:25.952]                           }
[17:42:25.952]                           else {
[17:42:25.952]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:25.952]                               info, version)
[17:42:25.952]                           }
[17:42:25.952]                           base::stop(msg)
[17:42:25.952]                         }
[17:42:25.952]                       })
[17:42:25.952]                     }
[17:42:25.952]                     base::local({
[17:42:25.952]                       for (pkg in c("stats", "datasets")) {
[17:42:25.952]                         base::loadNamespace(pkg)
[17:42:25.952]                         base::library(pkg, character.only = TRUE)
[17:42:25.952]                       }
[17:42:25.952]                     })
[17:42:25.952]                   }
[17:42:25.952]                   options(future.plan = NULL)
[17:42:25.952]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:25.952]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:25.952]                 }
[17:42:25.952]                 ...future.workdir <- getwd()
[17:42:25.952]             }
[17:42:25.952]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:25.952]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:25.952]         }
[17:42:25.952]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:25.952]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:25.952]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:25.952]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:25.952]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:25.952]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:25.952]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:25.952]             base::names(...future.oldOptions))
[17:42:25.952]     }
[17:42:25.952]     if (FALSE) {
[17:42:25.952]     }
[17:42:25.952]     else {
[17:42:25.952]         if (TRUE) {
[17:42:25.952]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:25.952]                 open = "w")
[17:42:25.952]         }
[17:42:25.952]         else {
[17:42:25.952]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:25.952]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:25.952]         }
[17:42:25.952]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:25.952]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:25.952]             base::sink(type = "output", split = FALSE)
[17:42:25.952]             base::close(...future.stdout)
[17:42:25.952]         }, add = TRUE)
[17:42:25.952]     }
[17:42:25.952]     ...future.frame <- base::sys.nframe()
[17:42:25.952]     ...future.conditions <- base::list()
[17:42:25.952]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:25.952]     if (FALSE) {
[17:42:25.952]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:25.952]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:25.952]     }
[17:42:25.952]     ...future.result <- base::tryCatch({
[17:42:25.952]         base::withCallingHandlers({
[17:42:25.952]             ...future.value <- base::withVisible(base::local({
[17:42:25.952]                 lm(dist ~ . - 1, data = cars)
[17:42:25.952]             }))
[17:42:25.952]             future::FutureResult(value = ...future.value$value, 
[17:42:25.952]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:25.952]                   ...future.rng), globalenv = if (FALSE) 
[17:42:25.952]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:25.952]                     ...future.globalenv.names))
[17:42:25.952]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:25.952]         }, condition = base::local({
[17:42:25.952]             c <- base::c
[17:42:25.952]             inherits <- base::inherits
[17:42:25.952]             invokeRestart <- base::invokeRestart
[17:42:25.952]             length <- base::length
[17:42:25.952]             list <- base::list
[17:42:25.952]             seq.int <- base::seq.int
[17:42:25.952]             signalCondition <- base::signalCondition
[17:42:25.952]             sys.calls <- base::sys.calls
[17:42:25.952]             `[[` <- base::`[[`
[17:42:25.952]             `+` <- base::`+`
[17:42:25.952]             `<<-` <- base::`<<-`
[17:42:25.952]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:25.952]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:25.952]                   3L)]
[17:42:25.952]             }
[17:42:25.952]             function(cond) {
[17:42:25.952]                 is_error <- inherits(cond, "error")
[17:42:25.952]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:25.952]                   NULL)
[17:42:25.952]                 if (is_error) {
[17:42:25.952]                   sessionInformation <- function() {
[17:42:25.952]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:25.952]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:25.952]                       search = base::search(), system = base::Sys.info())
[17:42:25.952]                   }
[17:42:25.952]                   ...future.conditions[[length(...future.conditions) + 
[17:42:25.952]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:25.952]                     cond$call), session = sessionInformation(), 
[17:42:25.952]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:25.952]                   signalCondition(cond)
[17:42:25.952]                 }
[17:42:25.952]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:25.952]                 "immediateCondition"))) {
[17:42:25.952]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:25.952]                   ...future.conditions[[length(...future.conditions) + 
[17:42:25.952]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:25.952]                   if (TRUE && !signal) {
[17:42:25.952]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:25.952]                     {
[17:42:25.952]                       inherits <- base::inherits
[17:42:25.952]                       invokeRestart <- base::invokeRestart
[17:42:25.952]                       is.null <- base::is.null
[17:42:25.952]                       muffled <- FALSE
[17:42:25.952]                       if (inherits(cond, "message")) {
[17:42:25.952]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:25.952]                         if (muffled) 
[17:42:25.952]                           invokeRestart("muffleMessage")
[17:42:25.952]                       }
[17:42:25.952]                       else if (inherits(cond, "warning")) {
[17:42:25.952]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:25.952]                         if (muffled) 
[17:42:25.952]                           invokeRestart("muffleWarning")
[17:42:25.952]                       }
[17:42:25.952]                       else if (inherits(cond, "condition")) {
[17:42:25.952]                         if (!is.null(pattern)) {
[17:42:25.952]                           computeRestarts <- base::computeRestarts
[17:42:25.952]                           grepl <- base::grepl
[17:42:25.952]                           restarts <- computeRestarts(cond)
[17:42:25.952]                           for (restart in restarts) {
[17:42:25.952]                             name <- restart$name
[17:42:25.952]                             if (is.null(name)) 
[17:42:25.952]                               next
[17:42:25.952]                             if (!grepl(pattern, name)) 
[17:42:25.952]                               next
[17:42:25.952]                             invokeRestart(restart)
[17:42:25.952]                             muffled <- TRUE
[17:42:25.952]                             break
[17:42:25.952]                           }
[17:42:25.952]                         }
[17:42:25.952]                       }
[17:42:25.952]                       invisible(muffled)
[17:42:25.952]                     }
[17:42:25.952]                     muffleCondition(cond, pattern = "^muffle")
[17:42:25.952]                   }
[17:42:25.952]                 }
[17:42:25.952]                 else {
[17:42:25.952]                   if (TRUE) {
[17:42:25.952]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:25.952]                     {
[17:42:25.952]                       inherits <- base::inherits
[17:42:25.952]                       invokeRestart <- base::invokeRestart
[17:42:25.952]                       is.null <- base::is.null
[17:42:25.952]                       muffled <- FALSE
[17:42:25.952]                       if (inherits(cond, "message")) {
[17:42:25.952]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:25.952]                         if (muffled) 
[17:42:25.952]                           invokeRestart("muffleMessage")
[17:42:25.952]                       }
[17:42:25.952]                       else if (inherits(cond, "warning")) {
[17:42:25.952]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:25.952]                         if (muffled) 
[17:42:25.952]                           invokeRestart("muffleWarning")
[17:42:25.952]                       }
[17:42:25.952]                       else if (inherits(cond, "condition")) {
[17:42:25.952]                         if (!is.null(pattern)) {
[17:42:25.952]                           computeRestarts <- base::computeRestarts
[17:42:25.952]                           grepl <- base::grepl
[17:42:25.952]                           restarts <- computeRestarts(cond)
[17:42:25.952]                           for (restart in restarts) {
[17:42:25.952]                             name <- restart$name
[17:42:25.952]                             if (is.null(name)) 
[17:42:25.952]                               next
[17:42:25.952]                             if (!grepl(pattern, name)) 
[17:42:25.952]                               next
[17:42:25.952]                             invokeRestart(restart)
[17:42:25.952]                             muffled <- TRUE
[17:42:25.952]                             break
[17:42:25.952]                           }
[17:42:25.952]                         }
[17:42:25.952]                       }
[17:42:25.952]                       invisible(muffled)
[17:42:25.952]                     }
[17:42:25.952]                     muffleCondition(cond, pattern = "^muffle")
[17:42:25.952]                   }
[17:42:25.952]                 }
[17:42:25.952]             }
[17:42:25.952]         }))
[17:42:25.952]     }, error = function(ex) {
[17:42:25.952]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:25.952]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:25.952]                 ...future.rng), started = ...future.startTime, 
[17:42:25.952]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:25.952]             version = "1.8"), class = "FutureResult")
[17:42:25.952]     }, finally = {
[17:42:25.952]         if (!identical(...future.workdir, getwd())) 
[17:42:25.952]             setwd(...future.workdir)
[17:42:25.952]         {
[17:42:25.952]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:25.952]                 ...future.oldOptions$nwarnings <- NULL
[17:42:25.952]             }
[17:42:25.952]             base::options(...future.oldOptions)
[17:42:25.952]             if (.Platform$OS.type == "windows") {
[17:42:25.952]                 old_names <- names(...future.oldEnvVars)
[17:42:25.952]                 envs <- base::Sys.getenv()
[17:42:25.952]                 names <- names(envs)
[17:42:25.952]                 common <- intersect(names, old_names)
[17:42:25.952]                 added <- setdiff(names, old_names)
[17:42:25.952]                 removed <- setdiff(old_names, names)
[17:42:25.952]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:25.952]                   envs[common]]
[17:42:25.952]                 NAMES <- toupper(changed)
[17:42:25.952]                 args <- list()
[17:42:25.952]                 for (kk in seq_along(NAMES)) {
[17:42:25.952]                   name <- changed[[kk]]
[17:42:25.952]                   NAME <- NAMES[[kk]]
[17:42:25.952]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:25.952]                     next
[17:42:25.952]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:25.952]                 }
[17:42:25.952]                 NAMES <- toupper(added)
[17:42:25.952]                 for (kk in seq_along(NAMES)) {
[17:42:25.952]                   name <- added[[kk]]
[17:42:25.952]                   NAME <- NAMES[[kk]]
[17:42:25.952]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:25.952]                     next
[17:42:25.952]                   args[[name]] <- ""
[17:42:25.952]                 }
[17:42:25.952]                 NAMES <- toupper(removed)
[17:42:25.952]                 for (kk in seq_along(NAMES)) {
[17:42:25.952]                   name <- removed[[kk]]
[17:42:25.952]                   NAME <- NAMES[[kk]]
[17:42:25.952]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:25.952]                     next
[17:42:25.952]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:25.952]                 }
[17:42:25.952]                 if (length(args) > 0) 
[17:42:25.952]                   base::do.call(base::Sys.setenv, args = args)
[17:42:25.952]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:25.952]             }
[17:42:25.952]             else {
[17:42:25.952]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:25.952]             }
[17:42:25.952]             {
[17:42:25.952]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:25.952]                   0L) {
[17:42:25.952]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:25.952]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:25.952]                   base::options(opts)
[17:42:25.952]                 }
[17:42:25.952]                 {
[17:42:25.952]                   {
[17:42:25.952]                     NULL
[17:42:25.952]                     RNGkind("Mersenne-Twister")
[17:42:25.952]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:25.952]                       inherits = FALSE)
[17:42:25.952]                   }
[17:42:25.952]                   options(future.plan = NULL)
[17:42:25.952]                   if (is.na(NA_character_)) 
[17:42:25.952]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:25.952]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:25.952]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:25.952]                   {
[17:42:25.952]                     future <- SequentialFuture(..., envir = envir)
[17:42:25.952]                     if (!future$lazy) 
[17:42:25.952]                       future <- run(future)
[17:42:25.952]                     invisible(future)
[17:42:25.952]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:25.952]                 }
[17:42:25.952]             }
[17:42:25.952]         }
[17:42:25.952]     })
[17:42:25.952]     if (TRUE) {
[17:42:25.952]         base::sink(type = "output", split = FALSE)
[17:42:25.952]         if (TRUE) {
[17:42:25.952]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:25.952]         }
[17:42:25.952]         else {
[17:42:25.952]             ...future.result["stdout"] <- base::list(NULL)
[17:42:25.952]         }
[17:42:25.952]         base::close(...future.stdout)
[17:42:25.952]         ...future.stdout <- NULL
[17:42:25.952]     }
[17:42:25.952]     ...future.result$conditions <- ...future.conditions
[17:42:25.952]     ...future.result$finished <- base::Sys.time()
[17:42:25.952]     ...future.result
[17:42:25.952] }
[17:42:25.954] plan(): Setting new future strategy stack:
[17:42:25.955] List of future strategies:
[17:42:25.955] 1. sequential:
[17:42:25.955]    - args: function (..., envir = parent.frame())
[17:42:25.955]    - tweaked: FALSE
[17:42:25.955]    - call: NULL
[17:42:25.955] plan(): nbrOfWorkers() = 1
[17:42:25.956] plan(): Setting new future strategy stack:
[17:42:25.956] List of future strategies:
[17:42:25.956] 1. sequential:
[17:42:25.956]    - args: function (..., envir = parent.frame())
[17:42:25.956]    - tweaked: FALSE
[17:42:25.956]    - call: plan(strategy)
[17:42:25.957] plan(): nbrOfWorkers() = 1
[17:42:25.957] SequentialFuture started (and completed)
[17:42:25.957] - Launch lazy future ... done
[17:42:25.957] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[17:42:25.960] getGlobalsAndPackages() ...
[17:42:25.960] Searching for globals...
[17:42:25.961] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[17:42:25.961] Searching for globals ... DONE
[17:42:25.961] Resolving globals: FALSE
[17:42:25.962] 
[17:42:25.962] - packages: [2] ‘stats’, ‘datasets’
[17:42:25.962] getGlobalsAndPackages() ... DONE
[17:42:25.962] run() for ‘Future’ ...
[17:42:25.962] - state: ‘created’
[17:42:25.963] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:25.963] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:25.963] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:25.963]   - Field: ‘label’
[17:42:25.963]   - Field: ‘local’
[17:42:25.963]   - Field: ‘owner’
[17:42:25.963]   - Field: ‘envir’
[17:42:25.964]   - Field: ‘packages’
[17:42:25.965]   - Field: ‘gc’
[17:42:25.965]   - Field: ‘conditions’
[17:42:25.965]   - Field: ‘expr’
[17:42:25.965]   - Field: ‘uuid’
[17:42:25.966]   - Field: ‘seed’
[17:42:25.966]   - Field: ‘version’
[17:42:25.966]   - Field: ‘result’
[17:42:25.966]   - Field: ‘asynchronous’
[17:42:25.966]   - Field: ‘calls’
[17:42:25.966]   - Field: ‘globals’
[17:42:25.966]   - Field: ‘stdout’
[17:42:25.966]   - Field: ‘earlySignal’
[17:42:25.966]   - Field: ‘lazy’
[17:42:25.966]   - Field: ‘state’
[17:42:25.966] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:25.967] - Launch lazy future ...
[17:42:25.967] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:42:25.967] Packages needed by future strategies (n = 0): <none>
[17:42:25.967] {
[17:42:25.967]     {
[17:42:25.967]         {
[17:42:25.967]             ...future.startTime <- base::Sys.time()
[17:42:25.967]             {
[17:42:25.967]                 {
[17:42:25.967]                   {
[17:42:25.967]                     {
[17:42:25.967]                       base::local({
[17:42:25.967]                         has_future <- base::requireNamespace("future", 
[17:42:25.967]                           quietly = TRUE)
[17:42:25.967]                         if (has_future) {
[17:42:25.967]                           ns <- base::getNamespace("future")
[17:42:25.967]                           version <- ns[[".package"]][["version"]]
[17:42:25.967]                           if (is.null(version)) 
[17:42:25.967]                             version <- utils::packageVersion("future")
[17:42:25.967]                         }
[17:42:25.967]                         else {
[17:42:25.967]                           version <- NULL
[17:42:25.967]                         }
[17:42:25.967]                         if (!has_future || version < "1.8.0") {
[17:42:25.967]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:25.967]                             "", base::R.version$version.string), 
[17:42:25.967]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:25.967]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:25.967]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:25.967]                               "release", "version")], collapse = " "), 
[17:42:25.967]                             hostname = base::Sys.info()[["nodename"]])
[17:42:25.967]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:25.967]                             info)
[17:42:25.967]                           info <- base::paste(info, collapse = "; ")
[17:42:25.967]                           if (!has_future) {
[17:42:25.967]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:25.967]                               info)
[17:42:25.967]                           }
[17:42:25.967]                           else {
[17:42:25.967]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:25.967]                               info, version)
[17:42:25.967]                           }
[17:42:25.967]                           base::stop(msg)
[17:42:25.967]                         }
[17:42:25.967]                       })
[17:42:25.967]                     }
[17:42:25.967]                     base::local({
[17:42:25.967]                       for (pkg in c("stats", "datasets")) {
[17:42:25.967]                         base::loadNamespace(pkg)
[17:42:25.967]                         base::library(pkg, character.only = TRUE)
[17:42:25.967]                       }
[17:42:25.967]                     })
[17:42:25.967]                   }
[17:42:25.967]                   options(future.plan = NULL)
[17:42:25.967]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:25.967]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:25.967]                 }
[17:42:25.967]                 ...future.workdir <- getwd()
[17:42:25.967]             }
[17:42:25.967]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:25.967]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:25.967]         }
[17:42:25.967]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:25.967]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:25.967]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:25.967]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:25.967]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:25.967]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:25.967]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:25.967]             base::names(...future.oldOptions))
[17:42:25.967]     }
[17:42:25.967]     if (FALSE) {
[17:42:25.967]     }
[17:42:25.967]     else {
[17:42:25.967]         if (TRUE) {
[17:42:25.967]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:25.967]                 open = "w")
[17:42:25.967]         }
[17:42:25.967]         else {
[17:42:25.967]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:25.967]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:25.967]         }
[17:42:25.967]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:25.967]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:25.967]             base::sink(type = "output", split = FALSE)
[17:42:25.967]             base::close(...future.stdout)
[17:42:25.967]         }, add = TRUE)
[17:42:25.967]     }
[17:42:25.967]     ...future.frame <- base::sys.nframe()
[17:42:25.967]     ...future.conditions <- base::list()
[17:42:25.967]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:25.967]     if (FALSE) {
[17:42:25.967]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:25.967]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:25.967]     }
[17:42:25.967]     ...future.result <- base::tryCatch({
[17:42:25.967]         base::withCallingHandlers({
[17:42:25.967]             ...future.value <- base::withVisible(base::local({
[17:42:25.967]                 lm(dist ~ . + 0, data = cars)
[17:42:25.967]             }))
[17:42:25.967]             future::FutureResult(value = ...future.value$value, 
[17:42:25.967]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:25.967]                   ...future.rng), globalenv = if (FALSE) 
[17:42:25.967]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:25.967]                     ...future.globalenv.names))
[17:42:25.967]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:25.967]         }, condition = base::local({
[17:42:25.967]             c <- base::c
[17:42:25.967]             inherits <- base::inherits
[17:42:25.967]             invokeRestart <- base::invokeRestart
[17:42:25.967]             length <- base::length
[17:42:25.967]             list <- base::list
[17:42:25.967]             seq.int <- base::seq.int
[17:42:25.967]             signalCondition <- base::signalCondition
[17:42:25.967]             sys.calls <- base::sys.calls
[17:42:25.967]             `[[` <- base::`[[`
[17:42:25.967]             `+` <- base::`+`
[17:42:25.967]             `<<-` <- base::`<<-`
[17:42:25.967]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:25.967]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:25.967]                   3L)]
[17:42:25.967]             }
[17:42:25.967]             function(cond) {
[17:42:25.967]                 is_error <- inherits(cond, "error")
[17:42:25.967]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:25.967]                   NULL)
[17:42:25.967]                 if (is_error) {
[17:42:25.967]                   sessionInformation <- function() {
[17:42:25.967]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:25.967]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:25.967]                       search = base::search(), system = base::Sys.info())
[17:42:25.967]                   }
[17:42:25.967]                   ...future.conditions[[length(...future.conditions) + 
[17:42:25.967]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:25.967]                     cond$call), session = sessionInformation(), 
[17:42:25.967]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:25.967]                   signalCondition(cond)
[17:42:25.967]                 }
[17:42:25.967]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:25.967]                 "immediateCondition"))) {
[17:42:25.967]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:25.967]                   ...future.conditions[[length(...future.conditions) + 
[17:42:25.967]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:25.967]                   if (TRUE && !signal) {
[17:42:25.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:25.967]                     {
[17:42:25.967]                       inherits <- base::inherits
[17:42:25.967]                       invokeRestart <- base::invokeRestart
[17:42:25.967]                       is.null <- base::is.null
[17:42:25.967]                       muffled <- FALSE
[17:42:25.967]                       if (inherits(cond, "message")) {
[17:42:25.967]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:25.967]                         if (muffled) 
[17:42:25.967]                           invokeRestart("muffleMessage")
[17:42:25.967]                       }
[17:42:25.967]                       else if (inherits(cond, "warning")) {
[17:42:25.967]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:25.967]                         if (muffled) 
[17:42:25.967]                           invokeRestart("muffleWarning")
[17:42:25.967]                       }
[17:42:25.967]                       else if (inherits(cond, "condition")) {
[17:42:25.967]                         if (!is.null(pattern)) {
[17:42:25.967]                           computeRestarts <- base::computeRestarts
[17:42:25.967]                           grepl <- base::grepl
[17:42:25.967]                           restarts <- computeRestarts(cond)
[17:42:25.967]                           for (restart in restarts) {
[17:42:25.967]                             name <- restart$name
[17:42:25.967]                             if (is.null(name)) 
[17:42:25.967]                               next
[17:42:25.967]                             if (!grepl(pattern, name)) 
[17:42:25.967]                               next
[17:42:25.967]                             invokeRestart(restart)
[17:42:25.967]                             muffled <- TRUE
[17:42:25.967]                             break
[17:42:25.967]                           }
[17:42:25.967]                         }
[17:42:25.967]                       }
[17:42:25.967]                       invisible(muffled)
[17:42:25.967]                     }
[17:42:25.967]                     muffleCondition(cond, pattern = "^muffle")
[17:42:25.967]                   }
[17:42:25.967]                 }
[17:42:25.967]                 else {
[17:42:25.967]                   if (TRUE) {
[17:42:25.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:25.967]                     {
[17:42:25.967]                       inherits <- base::inherits
[17:42:25.967]                       invokeRestart <- base::invokeRestart
[17:42:25.967]                       is.null <- base::is.null
[17:42:25.967]                       muffled <- FALSE
[17:42:25.967]                       if (inherits(cond, "message")) {
[17:42:25.967]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:25.967]                         if (muffled) 
[17:42:25.967]                           invokeRestart("muffleMessage")
[17:42:25.967]                       }
[17:42:25.967]                       else if (inherits(cond, "warning")) {
[17:42:25.967]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:25.967]                         if (muffled) 
[17:42:25.967]                           invokeRestart("muffleWarning")
[17:42:25.967]                       }
[17:42:25.967]                       else if (inherits(cond, "condition")) {
[17:42:25.967]                         if (!is.null(pattern)) {
[17:42:25.967]                           computeRestarts <- base::computeRestarts
[17:42:25.967]                           grepl <- base::grepl
[17:42:25.967]                           restarts <- computeRestarts(cond)
[17:42:25.967]                           for (restart in restarts) {
[17:42:25.967]                             name <- restart$name
[17:42:25.967]                             if (is.null(name)) 
[17:42:25.967]                               next
[17:42:25.967]                             if (!grepl(pattern, name)) 
[17:42:25.967]                               next
[17:42:25.967]                             invokeRestart(restart)
[17:42:25.967]                             muffled <- TRUE
[17:42:25.967]                             break
[17:42:25.967]                           }
[17:42:25.967]                         }
[17:42:25.967]                       }
[17:42:25.967]                       invisible(muffled)
[17:42:25.967]                     }
[17:42:25.967]                     muffleCondition(cond, pattern = "^muffle")
[17:42:25.967]                   }
[17:42:25.967]                 }
[17:42:25.967]             }
[17:42:25.967]         }))
[17:42:25.967]     }, error = function(ex) {
[17:42:25.967]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:25.967]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:25.967]                 ...future.rng), started = ...future.startTime, 
[17:42:25.967]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:25.967]             version = "1.8"), class = "FutureResult")
[17:42:25.967]     }, finally = {
[17:42:25.967]         if (!identical(...future.workdir, getwd())) 
[17:42:25.967]             setwd(...future.workdir)
[17:42:25.967]         {
[17:42:25.967]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:25.967]                 ...future.oldOptions$nwarnings <- NULL
[17:42:25.967]             }
[17:42:25.967]             base::options(...future.oldOptions)
[17:42:25.967]             if (.Platform$OS.type == "windows") {
[17:42:25.967]                 old_names <- names(...future.oldEnvVars)
[17:42:25.967]                 envs <- base::Sys.getenv()
[17:42:25.967]                 names <- names(envs)
[17:42:25.967]                 common <- intersect(names, old_names)
[17:42:25.967]                 added <- setdiff(names, old_names)
[17:42:25.967]                 removed <- setdiff(old_names, names)
[17:42:25.967]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:25.967]                   envs[common]]
[17:42:25.967]                 NAMES <- toupper(changed)
[17:42:25.967]                 args <- list()
[17:42:25.967]                 for (kk in seq_along(NAMES)) {
[17:42:25.967]                   name <- changed[[kk]]
[17:42:25.967]                   NAME <- NAMES[[kk]]
[17:42:25.967]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:25.967]                     next
[17:42:25.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:25.967]                 }
[17:42:25.967]                 NAMES <- toupper(added)
[17:42:25.967]                 for (kk in seq_along(NAMES)) {
[17:42:25.967]                   name <- added[[kk]]
[17:42:25.967]                   NAME <- NAMES[[kk]]
[17:42:25.967]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:25.967]                     next
[17:42:25.967]                   args[[name]] <- ""
[17:42:25.967]                 }
[17:42:25.967]                 NAMES <- toupper(removed)
[17:42:25.967]                 for (kk in seq_along(NAMES)) {
[17:42:25.967]                   name <- removed[[kk]]
[17:42:25.967]                   NAME <- NAMES[[kk]]
[17:42:25.967]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:25.967]                     next
[17:42:25.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:25.967]                 }
[17:42:25.967]                 if (length(args) > 0) 
[17:42:25.967]                   base::do.call(base::Sys.setenv, args = args)
[17:42:25.967]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:25.967]             }
[17:42:25.967]             else {
[17:42:25.967]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:25.967]             }
[17:42:25.967]             {
[17:42:25.967]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:25.967]                   0L) {
[17:42:25.967]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:25.967]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:25.967]                   base::options(opts)
[17:42:25.967]                 }
[17:42:25.967]                 {
[17:42:25.967]                   {
[17:42:25.967]                     NULL
[17:42:25.967]                     RNGkind("Mersenne-Twister")
[17:42:25.967]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:25.967]                       inherits = FALSE)
[17:42:25.967]                   }
[17:42:25.967]                   options(future.plan = NULL)
[17:42:25.967]                   if (is.na(NA_character_)) 
[17:42:25.967]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:25.967]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:25.967]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:25.967]                   {
[17:42:25.967]                     future <- SequentialFuture(..., envir = envir)
[17:42:25.967]                     if (!future$lazy) 
[17:42:25.967]                       future <- run(future)
[17:42:25.967]                     invisible(future)
[17:42:25.967]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:25.967]                 }
[17:42:25.967]             }
[17:42:25.967]         }
[17:42:25.967]     })
[17:42:25.967]     if (TRUE) {
[17:42:25.967]         base::sink(type = "output", split = FALSE)
[17:42:25.967]         if (TRUE) {
[17:42:25.967]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:25.967]         }
[17:42:25.967]         else {
[17:42:25.967]             ...future.result["stdout"] <- base::list(NULL)
[17:42:25.967]         }
[17:42:25.967]         base::close(...future.stdout)
[17:42:25.967]         ...future.stdout <- NULL
[17:42:25.967]     }
[17:42:25.967]     ...future.result$conditions <- ...future.conditions
[17:42:25.967]     ...future.result$finished <- base::Sys.time()
[17:42:25.967]     ...future.result
[17:42:25.967] }
[17:42:25.969] plan(): Setting new future strategy stack:
[17:42:25.970] List of future strategies:
[17:42:25.970] 1. sequential:
[17:42:25.970]    - args: function (..., envir = parent.frame())
[17:42:25.970]    - tweaked: FALSE
[17:42:25.970]    - call: NULL
[17:42:25.970] plan(): nbrOfWorkers() = 1
[17:42:25.971] plan(): Setting new future strategy stack:
[17:42:25.971] List of future strategies:
[17:42:25.971] 1. sequential:
[17:42:25.971]    - args: function (..., envir = parent.frame())
[17:42:25.971]    - tweaked: FALSE
[17:42:25.971]    - call: plan(strategy)
[17:42:25.972] plan(): nbrOfWorkers() = 1
[17:42:25.972] SequentialFuture started (and completed)
[17:42:25.972] - Launch lazy future ... done
[17:42:25.972] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[17:42:25.975] getGlobalsAndPackages() ...
[17:42:25.975] Searching for globals...
[17:42:25.976] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[17:42:25.977] Searching for globals ... DONE
[17:42:25.977] Resolving globals: FALSE
[17:42:25.977] 
[17:42:25.977] - packages: [2] ‘stats’, ‘datasets’
[17:42:25.977] getGlobalsAndPackages() ... DONE
[17:42:25.978] run() for ‘Future’ ...
[17:42:25.978] - state: ‘created’
[17:42:25.978] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:25.978] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:25.978] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:25.978]   - Field: ‘label’
[17:42:25.979]   - Field: ‘local’
[17:42:25.979]   - Field: ‘owner’
[17:42:25.979]   - Field: ‘envir’
[17:42:25.979]   - Field: ‘packages’
[17:42:25.979]   - Field: ‘gc’
[17:42:25.979]   - Field: ‘conditions’
[17:42:25.979]   - Field: ‘expr’
[17:42:25.979]   - Field: ‘uuid’
[17:42:25.979]   - Field: ‘seed’
[17:42:25.979]   - Field: ‘version’
[17:42:25.980]   - Field: ‘result’
[17:42:25.980]   - Field: ‘asynchronous’
[17:42:25.980]   - Field: ‘calls’
[17:42:25.980]   - Field: ‘globals’
[17:42:25.980]   - Field: ‘stdout’
[17:42:25.980]   - Field: ‘earlySignal’
[17:42:25.980]   - Field: ‘lazy’
[17:42:25.980]   - Field: ‘state’
[17:42:25.980] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:25.980] - Launch lazy future ...
[17:42:25.981] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:42:25.981] Packages needed by future strategies (n = 0): <none>
[17:42:25.981] {
[17:42:25.981]     {
[17:42:25.981]         {
[17:42:25.981]             ...future.startTime <- base::Sys.time()
[17:42:25.981]             {
[17:42:25.981]                 {
[17:42:25.981]                   {
[17:42:25.981]                     {
[17:42:25.981]                       base::local({
[17:42:25.981]                         has_future <- base::requireNamespace("future", 
[17:42:25.981]                           quietly = TRUE)
[17:42:25.981]                         if (has_future) {
[17:42:25.981]                           ns <- base::getNamespace("future")
[17:42:25.981]                           version <- ns[[".package"]][["version"]]
[17:42:25.981]                           if (is.null(version)) 
[17:42:25.981]                             version <- utils::packageVersion("future")
[17:42:25.981]                         }
[17:42:25.981]                         else {
[17:42:25.981]                           version <- NULL
[17:42:25.981]                         }
[17:42:25.981]                         if (!has_future || version < "1.8.0") {
[17:42:25.981]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:25.981]                             "", base::R.version$version.string), 
[17:42:25.981]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:25.981]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:25.981]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:25.981]                               "release", "version")], collapse = " "), 
[17:42:25.981]                             hostname = base::Sys.info()[["nodename"]])
[17:42:25.981]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:25.981]                             info)
[17:42:25.981]                           info <- base::paste(info, collapse = "; ")
[17:42:25.981]                           if (!has_future) {
[17:42:25.981]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:25.981]                               info)
[17:42:25.981]                           }
[17:42:25.981]                           else {
[17:42:25.981]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:25.981]                               info, version)
[17:42:25.981]                           }
[17:42:25.981]                           base::stop(msg)
[17:42:25.981]                         }
[17:42:25.981]                       })
[17:42:25.981]                     }
[17:42:25.981]                     base::local({
[17:42:25.981]                       for (pkg in c("stats", "datasets")) {
[17:42:25.981]                         base::loadNamespace(pkg)
[17:42:25.981]                         base::library(pkg, character.only = TRUE)
[17:42:25.981]                       }
[17:42:25.981]                     })
[17:42:25.981]                   }
[17:42:25.981]                   options(future.plan = NULL)
[17:42:25.981]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:25.981]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:25.981]                 }
[17:42:25.981]                 ...future.workdir <- getwd()
[17:42:25.981]             }
[17:42:25.981]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:25.981]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:25.981]         }
[17:42:25.981]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:25.981]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:25.981]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:25.981]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:25.981]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:25.981]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:25.981]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:25.981]             base::names(...future.oldOptions))
[17:42:25.981]     }
[17:42:25.981]     if (FALSE) {
[17:42:25.981]     }
[17:42:25.981]     else {
[17:42:25.981]         if (TRUE) {
[17:42:25.981]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:25.981]                 open = "w")
[17:42:25.981]         }
[17:42:25.981]         else {
[17:42:25.981]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:25.981]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:25.981]         }
[17:42:25.981]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:25.981]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:25.981]             base::sink(type = "output", split = FALSE)
[17:42:25.981]             base::close(...future.stdout)
[17:42:25.981]         }, add = TRUE)
[17:42:25.981]     }
[17:42:25.981]     ...future.frame <- base::sys.nframe()
[17:42:25.981]     ...future.conditions <- base::list()
[17:42:25.981]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:25.981]     if (FALSE) {
[17:42:25.981]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:25.981]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:25.981]     }
[17:42:25.981]     ...future.result <- base::tryCatch({
[17:42:25.981]         base::withCallingHandlers({
[17:42:25.981]             ...future.value <- base::withVisible(base::local({
[17:42:25.981]                 lm(dist ~ speed + speed^2, data = cars)
[17:42:25.981]             }))
[17:42:25.981]             future::FutureResult(value = ...future.value$value, 
[17:42:25.981]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:25.981]                   ...future.rng), globalenv = if (FALSE) 
[17:42:25.981]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:25.981]                     ...future.globalenv.names))
[17:42:25.981]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:25.981]         }, condition = base::local({
[17:42:25.981]             c <- base::c
[17:42:25.981]             inherits <- base::inherits
[17:42:25.981]             invokeRestart <- base::invokeRestart
[17:42:25.981]             length <- base::length
[17:42:25.981]             list <- base::list
[17:42:25.981]             seq.int <- base::seq.int
[17:42:25.981]             signalCondition <- base::signalCondition
[17:42:25.981]             sys.calls <- base::sys.calls
[17:42:25.981]             `[[` <- base::`[[`
[17:42:25.981]             `+` <- base::`+`
[17:42:25.981]             `<<-` <- base::`<<-`
[17:42:25.981]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:25.981]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:25.981]                   3L)]
[17:42:25.981]             }
[17:42:25.981]             function(cond) {
[17:42:25.981]                 is_error <- inherits(cond, "error")
[17:42:25.981]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:25.981]                   NULL)
[17:42:25.981]                 if (is_error) {
[17:42:25.981]                   sessionInformation <- function() {
[17:42:25.981]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:25.981]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:25.981]                       search = base::search(), system = base::Sys.info())
[17:42:25.981]                   }
[17:42:25.981]                   ...future.conditions[[length(...future.conditions) + 
[17:42:25.981]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:25.981]                     cond$call), session = sessionInformation(), 
[17:42:25.981]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:25.981]                   signalCondition(cond)
[17:42:25.981]                 }
[17:42:25.981]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:25.981]                 "immediateCondition"))) {
[17:42:25.981]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:25.981]                   ...future.conditions[[length(...future.conditions) + 
[17:42:25.981]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:25.981]                   if (TRUE && !signal) {
[17:42:25.981]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:25.981]                     {
[17:42:25.981]                       inherits <- base::inherits
[17:42:25.981]                       invokeRestart <- base::invokeRestart
[17:42:25.981]                       is.null <- base::is.null
[17:42:25.981]                       muffled <- FALSE
[17:42:25.981]                       if (inherits(cond, "message")) {
[17:42:25.981]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:25.981]                         if (muffled) 
[17:42:25.981]                           invokeRestart("muffleMessage")
[17:42:25.981]                       }
[17:42:25.981]                       else if (inherits(cond, "warning")) {
[17:42:25.981]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:25.981]                         if (muffled) 
[17:42:25.981]                           invokeRestart("muffleWarning")
[17:42:25.981]                       }
[17:42:25.981]                       else if (inherits(cond, "condition")) {
[17:42:25.981]                         if (!is.null(pattern)) {
[17:42:25.981]                           computeRestarts <- base::computeRestarts
[17:42:25.981]                           grepl <- base::grepl
[17:42:25.981]                           restarts <- computeRestarts(cond)
[17:42:25.981]                           for (restart in restarts) {
[17:42:25.981]                             name <- restart$name
[17:42:25.981]                             if (is.null(name)) 
[17:42:25.981]                               next
[17:42:25.981]                             if (!grepl(pattern, name)) 
[17:42:25.981]                               next
[17:42:25.981]                             invokeRestart(restart)
[17:42:25.981]                             muffled <- TRUE
[17:42:25.981]                             break
[17:42:25.981]                           }
[17:42:25.981]                         }
[17:42:25.981]                       }
[17:42:25.981]                       invisible(muffled)
[17:42:25.981]                     }
[17:42:25.981]                     muffleCondition(cond, pattern = "^muffle")
[17:42:25.981]                   }
[17:42:25.981]                 }
[17:42:25.981]                 else {
[17:42:25.981]                   if (TRUE) {
[17:42:25.981]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:25.981]                     {
[17:42:25.981]                       inherits <- base::inherits
[17:42:25.981]                       invokeRestart <- base::invokeRestart
[17:42:25.981]                       is.null <- base::is.null
[17:42:25.981]                       muffled <- FALSE
[17:42:25.981]                       if (inherits(cond, "message")) {
[17:42:25.981]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:25.981]                         if (muffled) 
[17:42:25.981]                           invokeRestart("muffleMessage")
[17:42:25.981]                       }
[17:42:25.981]                       else if (inherits(cond, "warning")) {
[17:42:25.981]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:25.981]                         if (muffled) 
[17:42:25.981]                           invokeRestart("muffleWarning")
[17:42:25.981]                       }
[17:42:25.981]                       else if (inherits(cond, "condition")) {
[17:42:25.981]                         if (!is.null(pattern)) {
[17:42:25.981]                           computeRestarts <- base::computeRestarts
[17:42:25.981]                           grepl <- base::grepl
[17:42:25.981]                           restarts <- computeRestarts(cond)
[17:42:25.981]                           for (restart in restarts) {
[17:42:25.981]                             name <- restart$name
[17:42:25.981]                             if (is.null(name)) 
[17:42:25.981]                               next
[17:42:25.981]                             if (!grepl(pattern, name)) 
[17:42:25.981]                               next
[17:42:25.981]                             invokeRestart(restart)
[17:42:25.981]                             muffled <- TRUE
[17:42:25.981]                             break
[17:42:25.981]                           }
[17:42:25.981]                         }
[17:42:25.981]                       }
[17:42:25.981]                       invisible(muffled)
[17:42:25.981]                     }
[17:42:25.981]                     muffleCondition(cond, pattern = "^muffle")
[17:42:25.981]                   }
[17:42:25.981]                 }
[17:42:25.981]             }
[17:42:25.981]         }))
[17:42:25.981]     }, error = function(ex) {
[17:42:25.981]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:25.981]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:25.981]                 ...future.rng), started = ...future.startTime, 
[17:42:25.981]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:25.981]             version = "1.8"), class = "FutureResult")
[17:42:25.981]     }, finally = {
[17:42:25.981]         if (!identical(...future.workdir, getwd())) 
[17:42:25.981]             setwd(...future.workdir)
[17:42:25.981]         {
[17:42:25.981]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:25.981]                 ...future.oldOptions$nwarnings <- NULL
[17:42:25.981]             }
[17:42:25.981]             base::options(...future.oldOptions)
[17:42:25.981]             if (.Platform$OS.type == "windows") {
[17:42:25.981]                 old_names <- names(...future.oldEnvVars)
[17:42:25.981]                 envs <- base::Sys.getenv()
[17:42:25.981]                 names <- names(envs)
[17:42:25.981]                 common <- intersect(names, old_names)
[17:42:25.981]                 added <- setdiff(names, old_names)
[17:42:25.981]                 removed <- setdiff(old_names, names)
[17:42:25.981]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:25.981]                   envs[common]]
[17:42:25.981]                 NAMES <- toupper(changed)
[17:42:25.981]                 args <- list()
[17:42:25.981]                 for (kk in seq_along(NAMES)) {
[17:42:25.981]                   name <- changed[[kk]]
[17:42:25.981]                   NAME <- NAMES[[kk]]
[17:42:25.981]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:25.981]                     next
[17:42:25.981]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:25.981]                 }
[17:42:25.981]                 NAMES <- toupper(added)
[17:42:25.981]                 for (kk in seq_along(NAMES)) {
[17:42:25.981]                   name <- added[[kk]]
[17:42:25.981]                   NAME <- NAMES[[kk]]
[17:42:25.981]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:25.981]                     next
[17:42:25.981]                   args[[name]] <- ""
[17:42:25.981]                 }
[17:42:25.981]                 NAMES <- toupper(removed)
[17:42:25.981]                 for (kk in seq_along(NAMES)) {
[17:42:25.981]                   name <- removed[[kk]]
[17:42:25.981]                   NAME <- NAMES[[kk]]
[17:42:25.981]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:25.981]                     next
[17:42:25.981]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:25.981]                 }
[17:42:25.981]                 if (length(args) > 0) 
[17:42:25.981]                   base::do.call(base::Sys.setenv, args = args)
[17:42:25.981]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:25.981]             }
[17:42:25.981]             else {
[17:42:25.981]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:25.981]             }
[17:42:25.981]             {
[17:42:25.981]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:25.981]                   0L) {
[17:42:25.981]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:25.981]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:25.981]                   base::options(opts)
[17:42:25.981]                 }
[17:42:25.981]                 {
[17:42:25.981]                   {
[17:42:25.981]                     NULL
[17:42:25.981]                     RNGkind("Mersenne-Twister")
[17:42:25.981]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:25.981]                       inherits = FALSE)
[17:42:25.981]                   }
[17:42:25.981]                   options(future.plan = NULL)
[17:42:25.981]                   if (is.na(NA_character_)) 
[17:42:25.981]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:25.981]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:25.981]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:25.981]                   {
[17:42:25.981]                     future <- SequentialFuture(..., envir = envir)
[17:42:25.981]                     if (!future$lazy) 
[17:42:25.981]                       future <- run(future)
[17:42:25.981]                     invisible(future)
[17:42:25.981]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:25.981]                 }
[17:42:25.981]             }
[17:42:25.981]         }
[17:42:25.981]     })
[17:42:25.981]     if (TRUE) {
[17:42:25.981]         base::sink(type = "output", split = FALSE)
[17:42:25.981]         if (TRUE) {
[17:42:25.981]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:25.981]         }
[17:42:25.981]         else {
[17:42:25.981]             ...future.result["stdout"] <- base::list(NULL)
[17:42:25.981]         }
[17:42:25.981]         base::close(...future.stdout)
[17:42:25.981]         ...future.stdout <- NULL
[17:42:25.981]     }
[17:42:25.981]     ...future.result$conditions <- ...future.conditions
[17:42:25.981]     ...future.result$finished <- base::Sys.time()
[17:42:25.981]     ...future.result
[17:42:25.981] }
[17:42:25.983] plan(): Setting new future strategy stack:
[17:42:25.983] List of future strategies:
[17:42:25.983] 1. sequential:
[17:42:25.983]    - args: function (..., envir = parent.frame())
[17:42:25.983]    - tweaked: FALSE
[17:42:25.983]    - call: NULL
[17:42:25.984] plan(): nbrOfWorkers() = 1
[17:42:25.985] plan(): Setting new future strategy stack:
[17:42:25.985] List of future strategies:
[17:42:25.985] 1. sequential:
[17:42:25.985]    - args: function (..., envir = parent.frame())
[17:42:25.985]    - tweaked: FALSE
[17:42:25.985]    - call: plan(strategy)
[17:42:25.985] plan(): nbrOfWorkers() = 1
[17:42:25.986] SequentialFuture started (and completed)
[17:42:25.986] - Launch lazy future ... done
[17:42:25.986] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[17:42:25.988] getGlobalsAndPackages() ...
[17:42:25.988] Searching for globals...
[17:42:25.992] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[17:42:25.992] Searching for globals ... DONE
[17:42:25.992] Resolving globals: FALSE
[17:42:25.993] 
[17:42:25.993] - packages: [2] ‘stats’, ‘datasets’
[17:42:25.993] getGlobalsAndPackages() ... DONE
[17:42:25.993] run() for ‘Future’ ...
[17:42:25.993] - state: ‘created’
[17:42:25.993] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:25.993] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:25.994] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:25.994]   - Field: ‘label’
[17:42:25.994]   - Field: ‘local’
[17:42:25.994]   - Field: ‘owner’
[17:42:25.994]   - Field: ‘envir’
[17:42:25.994]   - Field: ‘packages’
[17:42:25.994]   - Field: ‘gc’
[17:42:25.994]   - Field: ‘conditions’
[17:42:25.994]   - Field: ‘expr’
[17:42:25.994]   - Field: ‘uuid’
[17:42:25.995]   - Field: ‘seed’
[17:42:25.995]   - Field: ‘version’
[17:42:25.995]   - Field: ‘result’
[17:42:25.995]   - Field: ‘asynchronous’
[17:42:25.995]   - Field: ‘calls’
[17:42:25.995]   - Field: ‘globals’
[17:42:25.995]   - Field: ‘stdout’
[17:42:25.995]   - Field: ‘earlySignal’
[17:42:25.995]   - Field: ‘lazy’
[17:42:25.995]   - Field: ‘state’
[17:42:25.996] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:25.996] - Launch lazy future ...
[17:42:25.996] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:42:25.996] Packages needed by future strategies (n = 0): <none>
[17:42:25.996] {
[17:42:25.996]     {
[17:42:25.996]         {
[17:42:25.996]             ...future.startTime <- base::Sys.time()
[17:42:25.996]             {
[17:42:25.996]                 {
[17:42:25.996]                   {
[17:42:25.996]                     {
[17:42:25.996]                       base::local({
[17:42:25.996]                         has_future <- base::requireNamespace("future", 
[17:42:25.996]                           quietly = TRUE)
[17:42:25.996]                         if (has_future) {
[17:42:25.996]                           ns <- base::getNamespace("future")
[17:42:25.996]                           version <- ns[[".package"]][["version"]]
[17:42:25.996]                           if (is.null(version)) 
[17:42:25.996]                             version <- utils::packageVersion("future")
[17:42:25.996]                         }
[17:42:25.996]                         else {
[17:42:25.996]                           version <- NULL
[17:42:25.996]                         }
[17:42:25.996]                         if (!has_future || version < "1.8.0") {
[17:42:25.996]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:25.996]                             "", base::R.version$version.string), 
[17:42:25.996]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:25.996]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:25.996]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:25.996]                               "release", "version")], collapse = " "), 
[17:42:25.996]                             hostname = base::Sys.info()[["nodename"]])
[17:42:25.996]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:25.996]                             info)
[17:42:25.996]                           info <- base::paste(info, collapse = "; ")
[17:42:25.996]                           if (!has_future) {
[17:42:25.996]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:25.996]                               info)
[17:42:25.996]                           }
[17:42:25.996]                           else {
[17:42:25.996]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:25.996]                               info, version)
[17:42:25.996]                           }
[17:42:25.996]                           base::stop(msg)
[17:42:25.996]                         }
[17:42:25.996]                       })
[17:42:25.996]                     }
[17:42:25.996]                     base::local({
[17:42:25.996]                       for (pkg in c("stats", "datasets")) {
[17:42:25.996]                         base::loadNamespace(pkg)
[17:42:25.996]                         base::library(pkg, character.only = TRUE)
[17:42:25.996]                       }
[17:42:25.996]                     })
[17:42:25.996]                   }
[17:42:25.996]                   options(future.plan = NULL)
[17:42:25.996]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:25.996]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:25.996]                 }
[17:42:25.996]                 ...future.workdir <- getwd()
[17:42:25.996]             }
[17:42:25.996]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:25.996]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:25.996]         }
[17:42:25.996]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:25.996]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:25.996]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:25.996]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:25.996]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:25.996]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:25.996]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:25.996]             base::names(...future.oldOptions))
[17:42:25.996]     }
[17:42:25.996]     if (FALSE) {
[17:42:25.996]     }
[17:42:25.996]     else {
[17:42:25.996]         if (TRUE) {
[17:42:25.996]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:25.996]                 open = "w")
[17:42:25.996]         }
[17:42:25.996]         else {
[17:42:25.996]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:25.996]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:25.996]         }
[17:42:25.996]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:25.996]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:25.996]             base::sink(type = "output", split = FALSE)
[17:42:25.996]             base::close(...future.stdout)
[17:42:25.996]         }, add = TRUE)
[17:42:25.996]     }
[17:42:25.996]     ...future.frame <- base::sys.nframe()
[17:42:25.996]     ...future.conditions <- base::list()
[17:42:25.996]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:25.996]     if (FALSE) {
[17:42:25.996]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:25.996]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:25.996]     }
[17:42:25.996]     ...future.result <- base::tryCatch({
[17:42:25.996]         base::withCallingHandlers({
[17:42:25.996]             ...future.value <- base::withVisible(base::local({
[17:42:25.996]                 lm(dist ~ speed + I(speed^2), data = cars)
[17:42:25.996]             }))
[17:42:25.996]             future::FutureResult(value = ...future.value$value, 
[17:42:25.996]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:25.996]                   ...future.rng), globalenv = if (FALSE) 
[17:42:25.996]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:25.996]                     ...future.globalenv.names))
[17:42:25.996]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:25.996]         }, condition = base::local({
[17:42:25.996]             c <- base::c
[17:42:25.996]             inherits <- base::inherits
[17:42:25.996]             invokeRestart <- base::invokeRestart
[17:42:25.996]             length <- base::length
[17:42:25.996]             list <- base::list
[17:42:25.996]             seq.int <- base::seq.int
[17:42:25.996]             signalCondition <- base::signalCondition
[17:42:25.996]             sys.calls <- base::sys.calls
[17:42:25.996]             `[[` <- base::`[[`
[17:42:25.996]             `+` <- base::`+`
[17:42:25.996]             `<<-` <- base::`<<-`
[17:42:25.996]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:25.996]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:25.996]                   3L)]
[17:42:25.996]             }
[17:42:25.996]             function(cond) {
[17:42:25.996]                 is_error <- inherits(cond, "error")
[17:42:25.996]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:25.996]                   NULL)
[17:42:25.996]                 if (is_error) {
[17:42:25.996]                   sessionInformation <- function() {
[17:42:25.996]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:25.996]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:25.996]                       search = base::search(), system = base::Sys.info())
[17:42:25.996]                   }
[17:42:25.996]                   ...future.conditions[[length(...future.conditions) + 
[17:42:25.996]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:25.996]                     cond$call), session = sessionInformation(), 
[17:42:25.996]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:25.996]                   signalCondition(cond)
[17:42:25.996]                 }
[17:42:25.996]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:25.996]                 "immediateCondition"))) {
[17:42:25.996]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:25.996]                   ...future.conditions[[length(...future.conditions) + 
[17:42:25.996]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:25.996]                   if (TRUE && !signal) {
[17:42:25.996]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:25.996]                     {
[17:42:25.996]                       inherits <- base::inherits
[17:42:25.996]                       invokeRestart <- base::invokeRestart
[17:42:25.996]                       is.null <- base::is.null
[17:42:25.996]                       muffled <- FALSE
[17:42:25.996]                       if (inherits(cond, "message")) {
[17:42:25.996]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:25.996]                         if (muffled) 
[17:42:25.996]                           invokeRestart("muffleMessage")
[17:42:25.996]                       }
[17:42:25.996]                       else if (inherits(cond, "warning")) {
[17:42:25.996]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:25.996]                         if (muffled) 
[17:42:25.996]                           invokeRestart("muffleWarning")
[17:42:25.996]                       }
[17:42:25.996]                       else if (inherits(cond, "condition")) {
[17:42:25.996]                         if (!is.null(pattern)) {
[17:42:25.996]                           computeRestarts <- base::computeRestarts
[17:42:25.996]                           grepl <- base::grepl
[17:42:25.996]                           restarts <- computeRestarts(cond)
[17:42:25.996]                           for (restart in restarts) {
[17:42:25.996]                             name <- restart$name
[17:42:25.996]                             if (is.null(name)) 
[17:42:25.996]                               next
[17:42:25.996]                             if (!grepl(pattern, name)) 
[17:42:25.996]                               next
[17:42:25.996]                             invokeRestart(restart)
[17:42:25.996]                             muffled <- TRUE
[17:42:25.996]                             break
[17:42:25.996]                           }
[17:42:25.996]                         }
[17:42:25.996]                       }
[17:42:25.996]                       invisible(muffled)
[17:42:25.996]                     }
[17:42:25.996]                     muffleCondition(cond, pattern = "^muffle")
[17:42:25.996]                   }
[17:42:25.996]                 }
[17:42:25.996]                 else {
[17:42:25.996]                   if (TRUE) {
[17:42:25.996]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:25.996]                     {
[17:42:25.996]                       inherits <- base::inherits
[17:42:25.996]                       invokeRestart <- base::invokeRestart
[17:42:25.996]                       is.null <- base::is.null
[17:42:25.996]                       muffled <- FALSE
[17:42:25.996]                       if (inherits(cond, "message")) {
[17:42:25.996]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:25.996]                         if (muffled) 
[17:42:25.996]                           invokeRestart("muffleMessage")
[17:42:25.996]                       }
[17:42:25.996]                       else if (inherits(cond, "warning")) {
[17:42:25.996]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:25.996]                         if (muffled) 
[17:42:25.996]                           invokeRestart("muffleWarning")
[17:42:25.996]                       }
[17:42:25.996]                       else if (inherits(cond, "condition")) {
[17:42:25.996]                         if (!is.null(pattern)) {
[17:42:25.996]                           computeRestarts <- base::computeRestarts
[17:42:25.996]                           grepl <- base::grepl
[17:42:25.996]                           restarts <- computeRestarts(cond)
[17:42:25.996]                           for (restart in restarts) {
[17:42:25.996]                             name <- restart$name
[17:42:25.996]                             if (is.null(name)) 
[17:42:25.996]                               next
[17:42:25.996]                             if (!grepl(pattern, name)) 
[17:42:25.996]                               next
[17:42:25.996]                             invokeRestart(restart)
[17:42:25.996]                             muffled <- TRUE
[17:42:25.996]                             break
[17:42:25.996]                           }
[17:42:25.996]                         }
[17:42:25.996]                       }
[17:42:25.996]                       invisible(muffled)
[17:42:25.996]                     }
[17:42:25.996]                     muffleCondition(cond, pattern = "^muffle")
[17:42:25.996]                   }
[17:42:25.996]                 }
[17:42:25.996]             }
[17:42:25.996]         }))
[17:42:25.996]     }, error = function(ex) {
[17:42:25.996]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:25.996]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:25.996]                 ...future.rng), started = ...future.startTime, 
[17:42:25.996]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:25.996]             version = "1.8"), class = "FutureResult")
[17:42:25.996]     }, finally = {
[17:42:25.996]         if (!identical(...future.workdir, getwd())) 
[17:42:25.996]             setwd(...future.workdir)
[17:42:25.996]         {
[17:42:25.996]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:25.996]                 ...future.oldOptions$nwarnings <- NULL
[17:42:25.996]             }
[17:42:25.996]             base::options(...future.oldOptions)
[17:42:25.996]             if (.Platform$OS.type == "windows") {
[17:42:25.996]                 old_names <- names(...future.oldEnvVars)
[17:42:25.996]                 envs <- base::Sys.getenv()
[17:42:25.996]                 names <- names(envs)
[17:42:25.996]                 common <- intersect(names, old_names)
[17:42:25.996]                 added <- setdiff(names, old_names)
[17:42:25.996]                 removed <- setdiff(old_names, names)
[17:42:25.996]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:25.996]                   envs[common]]
[17:42:25.996]                 NAMES <- toupper(changed)
[17:42:25.996]                 args <- list()
[17:42:25.996]                 for (kk in seq_along(NAMES)) {
[17:42:25.996]                   name <- changed[[kk]]
[17:42:25.996]                   NAME <- NAMES[[kk]]
[17:42:25.996]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:25.996]                     next
[17:42:25.996]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:25.996]                 }
[17:42:25.996]                 NAMES <- toupper(added)
[17:42:25.996]                 for (kk in seq_along(NAMES)) {
[17:42:25.996]                   name <- added[[kk]]
[17:42:25.996]                   NAME <- NAMES[[kk]]
[17:42:25.996]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:25.996]                     next
[17:42:25.996]                   args[[name]] <- ""
[17:42:25.996]                 }
[17:42:25.996]                 NAMES <- toupper(removed)
[17:42:25.996]                 for (kk in seq_along(NAMES)) {
[17:42:25.996]                   name <- removed[[kk]]
[17:42:25.996]                   NAME <- NAMES[[kk]]
[17:42:25.996]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:25.996]                     next
[17:42:25.996]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:25.996]                 }
[17:42:25.996]                 if (length(args) > 0) 
[17:42:25.996]                   base::do.call(base::Sys.setenv, args = args)
[17:42:25.996]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:25.996]             }
[17:42:25.996]             else {
[17:42:25.996]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:25.996]             }
[17:42:25.996]             {
[17:42:25.996]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:25.996]                   0L) {
[17:42:25.996]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:25.996]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:25.996]                   base::options(opts)
[17:42:25.996]                 }
[17:42:25.996]                 {
[17:42:25.996]                   {
[17:42:25.996]                     NULL
[17:42:25.996]                     RNGkind("Mersenne-Twister")
[17:42:25.996]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:25.996]                       inherits = FALSE)
[17:42:25.996]                   }
[17:42:25.996]                   options(future.plan = NULL)
[17:42:25.996]                   if (is.na(NA_character_)) 
[17:42:25.996]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:25.996]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:25.996]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:25.996]                   {
[17:42:25.996]                     future <- SequentialFuture(..., envir = envir)
[17:42:25.996]                     if (!future$lazy) 
[17:42:25.996]                       future <- run(future)
[17:42:25.996]                     invisible(future)
[17:42:25.996]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:25.996]                 }
[17:42:25.996]             }
[17:42:25.996]         }
[17:42:25.996]     })
[17:42:25.996]     if (TRUE) {
[17:42:25.996]         base::sink(type = "output", split = FALSE)
[17:42:25.996]         if (TRUE) {
[17:42:25.996]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:25.996]         }
[17:42:25.996]         else {
[17:42:25.996]             ...future.result["stdout"] <- base::list(NULL)
[17:42:25.996]         }
[17:42:25.996]         base::close(...future.stdout)
[17:42:25.996]         ...future.stdout <- NULL
[17:42:25.996]     }
[17:42:25.996]     ...future.result$conditions <- ...future.conditions
[17:42:25.996]     ...future.result$finished <- base::Sys.time()
[17:42:25.996]     ...future.result
[17:42:25.996] }
[17:42:25.998] plan(): Setting new future strategy stack:
[17:42:25.998] List of future strategies:
[17:42:25.998] 1. sequential:
[17:42:25.998]    - args: function (..., envir = parent.frame())
[17:42:25.998]    - tweaked: FALSE
[17:42:25.998]    - call: NULL
[17:42:25.999] plan(): nbrOfWorkers() = 1
[17:42:26.000] plan(): Setting new future strategy stack:
[17:42:26.000] List of future strategies:
[17:42:26.000] 1. sequential:
[17:42:26.000]    - args: function (..., envir = parent.frame())
[17:42:26.000]    - tweaked: FALSE
[17:42:26.000]    - call: plan(strategy)
[17:42:26.001] plan(): nbrOfWorkers() = 1
[17:42:26.001] SequentialFuture started (and completed)
[17:42:26.001] - Launch lazy future ... done
[17:42:26.001] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[17:42:26.005] getGlobalsAndPackages() ...
[17:42:26.005] Searching for globals...
[17:42:26.006] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[17:42:26.006] Searching for globals ... DONE
[17:42:26.006] Resolving globals: FALSE
[17:42:26.007] 
[17:42:26.007] - packages: [2] ‘stats’, ‘datasets’
[17:42:26.007] getGlobalsAndPackages() ... DONE
[17:42:26.007] run() for ‘Future’ ...
[17:42:26.007] - state: ‘created’
[17:42:26.007] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:26.008] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:26.008] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:26.008]   - Field: ‘label’
[17:42:26.008]   - Field: ‘local’
[17:42:26.008]   - Field: ‘owner’
[17:42:26.008]   - Field: ‘envir’
[17:42:26.008]   - Field: ‘packages’
[17:42:26.008]   - Field: ‘gc’
[17:42:26.009]   - Field: ‘conditions’
[17:42:26.009]   - Field: ‘expr’
[17:42:26.009]   - Field: ‘uuid’
[17:42:26.009]   - Field: ‘seed’
[17:42:26.009]   - Field: ‘version’
[17:42:26.009]   - Field: ‘result’
[17:42:26.009]   - Field: ‘asynchronous’
[17:42:26.009]   - Field: ‘calls’
[17:42:26.009]   - Field: ‘globals’
[17:42:26.009]   - Field: ‘stdout’
[17:42:26.009]   - Field: ‘earlySignal’
[17:42:26.010]   - Field: ‘lazy’
[17:42:26.010]   - Field: ‘state’
[17:42:26.010] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:26.010] - Launch lazy future ...
[17:42:26.010] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:42:26.010] Packages needed by future strategies (n = 0): <none>
[17:42:26.011] {
[17:42:26.011]     {
[17:42:26.011]         {
[17:42:26.011]             ...future.startTime <- base::Sys.time()
[17:42:26.011]             {
[17:42:26.011]                 {
[17:42:26.011]                   {
[17:42:26.011]                     {
[17:42:26.011]                       base::local({
[17:42:26.011]                         has_future <- base::requireNamespace("future", 
[17:42:26.011]                           quietly = TRUE)
[17:42:26.011]                         if (has_future) {
[17:42:26.011]                           ns <- base::getNamespace("future")
[17:42:26.011]                           version <- ns[[".package"]][["version"]]
[17:42:26.011]                           if (is.null(version)) 
[17:42:26.011]                             version <- utils::packageVersion("future")
[17:42:26.011]                         }
[17:42:26.011]                         else {
[17:42:26.011]                           version <- NULL
[17:42:26.011]                         }
[17:42:26.011]                         if (!has_future || version < "1.8.0") {
[17:42:26.011]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:26.011]                             "", base::R.version$version.string), 
[17:42:26.011]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:26.011]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:26.011]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:26.011]                               "release", "version")], collapse = " "), 
[17:42:26.011]                             hostname = base::Sys.info()[["nodename"]])
[17:42:26.011]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:26.011]                             info)
[17:42:26.011]                           info <- base::paste(info, collapse = "; ")
[17:42:26.011]                           if (!has_future) {
[17:42:26.011]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:26.011]                               info)
[17:42:26.011]                           }
[17:42:26.011]                           else {
[17:42:26.011]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:26.011]                               info, version)
[17:42:26.011]                           }
[17:42:26.011]                           base::stop(msg)
[17:42:26.011]                         }
[17:42:26.011]                       })
[17:42:26.011]                     }
[17:42:26.011]                     base::local({
[17:42:26.011]                       for (pkg in c("stats", "datasets")) {
[17:42:26.011]                         base::loadNamespace(pkg)
[17:42:26.011]                         base::library(pkg, character.only = TRUE)
[17:42:26.011]                       }
[17:42:26.011]                     })
[17:42:26.011]                   }
[17:42:26.011]                   options(future.plan = NULL)
[17:42:26.011]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:26.011]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:26.011]                 }
[17:42:26.011]                 ...future.workdir <- getwd()
[17:42:26.011]             }
[17:42:26.011]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:26.011]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:26.011]         }
[17:42:26.011]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:26.011]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:26.011]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:26.011]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:26.011]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:26.011]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:26.011]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:26.011]             base::names(...future.oldOptions))
[17:42:26.011]     }
[17:42:26.011]     if (FALSE) {
[17:42:26.011]     }
[17:42:26.011]     else {
[17:42:26.011]         if (TRUE) {
[17:42:26.011]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:26.011]                 open = "w")
[17:42:26.011]         }
[17:42:26.011]         else {
[17:42:26.011]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:26.011]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:26.011]         }
[17:42:26.011]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:26.011]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:26.011]             base::sink(type = "output", split = FALSE)
[17:42:26.011]             base::close(...future.stdout)
[17:42:26.011]         }, add = TRUE)
[17:42:26.011]     }
[17:42:26.011]     ...future.frame <- base::sys.nframe()
[17:42:26.011]     ...future.conditions <- base::list()
[17:42:26.011]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:26.011]     if (FALSE) {
[17:42:26.011]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:26.011]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:26.011]     }
[17:42:26.011]     ...future.result <- base::tryCatch({
[17:42:26.011]         base::withCallingHandlers({
[17:42:26.011]             ...future.value <- base::withVisible(base::local({
[17:42:26.011]                 lm(dist ~ poly(speed, 2), data = cars)
[17:42:26.011]             }))
[17:42:26.011]             future::FutureResult(value = ...future.value$value, 
[17:42:26.011]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:26.011]                   ...future.rng), globalenv = if (FALSE) 
[17:42:26.011]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:26.011]                     ...future.globalenv.names))
[17:42:26.011]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:26.011]         }, condition = base::local({
[17:42:26.011]             c <- base::c
[17:42:26.011]             inherits <- base::inherits
[17:42:26.011]             invokeRestart <- base::invokeRestart
[17:42:26.011]             length <- base::length
[17:42:26.011]             list <- base::list
[17:42:26.011]             seq.int <- base::seq.int
[17:42:26.011]             signalCondition <- base::signalCondition
[17:42:26.011]             sys.calls <- base::sys.calls
[17:42:26.011]             `[[` <- base::`[[`
[17:42:26.011]             `+` <- base::`+`
[17:42:26.011]             `<<-` <- base::`<<-`
[17:42:26.011]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:26.011]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:26.011]                   3L)]
[17:42:26.011]             }
[17:42:26.011]             function(cond) {
[17:42:26.011]                 is_error <- inherits(cond, "error")
[17:42:26.011]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:26.011]                   NULL)
[17:42:26.011]                 if (is_error) {
[17:42:26.011]                   sessionInformation <- function() {
[17:42:26.011]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:26.011]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:26.011]                       search = base::search(), system = base::Sys.info())
[17:42:26.011]                   }
[17:42:26.011]                   ...future.conditions[[length(...future.conditions) + 
[17:42:26.011]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:26.011]                     cond$call), session = sessionInformation(), 
[17:42:26.011]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:26.011]                   signalCondition(cond)
[17:42:26.011]                 }
[17:42:26.011]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:26.011]                 "immediateCondition"))) {
[17:42:26.011]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:26.011]                   ...future.conditions[[length(...future.conditions) + 
[17:42:26.011]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:26.011]                   if (TRUE && !signal) {
[17:42:26.011]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.011]                     {
[17:42:26.011]                       inherits <- base::inherits
[17:42:26.011]                       invokeRestart <- base::invokeRestart
[17:42:26.011]                       is.null <- base::is.null
[17:42:26.011]                       muffled <- FALSE
[17:42:26.011]                       if (inherits(cond, "message")) {
[17:42:26.011]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:26.011]                         if (muffled) 
[17:42:26.011]                           invokeRestart("muffleMessage")
[17:42:26.011]                       }
[17:42:26.011]                       else if (inherits(cond, "warning")) {
[17:42:26.011]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:26.011]                         if (muffled) 
[17:42:26.011]                           invokeRestart("muffleWarning")
[17:42:26.011]                       }
[17:42:26.011]                       else if (inherits(cond, "condition")) {
[17:42:26.011]                         if (!is.null(pattern)) {
[17:42:26.011]                           computeRestarts <- base::computeRestarts
[17:42:26.011]                           grepl <- base::grepl
[17:42:26.011]                           restarts <- computeRestarts(cond)
[17:42:26.011]                           for (restart in restarts) {
[17:42:26.011]                             name <- restart$name
[17:42:26.011]                             if (is.null(name)) 
[17:42:26.011]                               next
[17:42:26.011]                             if (!grepl(pattern, name)) 
[17:42:26.011]                               next
[17:42:26.011]                             invokeRestart(restart)
[17:42:26.011]                             muffled <- TRUE
[17:42:26.011]                             break
[17:42:26.011]                           }
[17:42:26.011]                         }
[17:42:26.011]                       }
[17:42:26.011]                       invisible(muffled)
[17:42:26.011]                     }
[17:42:26.011]                     muffleCondition(cond, pattern = "^muffle")
[17:42:26.011]                   }
[17:42:26.011]                 }
[17:42:26.011]                 else {
[17:42:26.011]                   if (TRUE) {
[17:42:26.011]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.011]                     {
[17:42:26.011]                       inherits <- base::inherits
[17:42:26.011]                       invokeRestart <- base::invokeRestart
[17:42:26.011]                       is.null <- base::is.null
[17:42:26.011]                       muffled <- FALSE
[17:42:26.011]                       if (inherits(cond, "message")) {
[17:42:26.011]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:26.011]                         if (muffled) 
[17:42:26.011]                           invokeRestart("muffleMessage")
[17:42:26.011]                       }
[17:42:26.011]                       else if (inherits(cond, "warning")) {
[17:42:26.011]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:26.011]                         if (muffled) 
[17:42:26.011]                           invokeRestart("muffleWarning")
[17:42:26.011]                       }
[17:42:26.011]                       else if (inherits(cond, "condition")) {
[17:42:26.011]                         if (!is.null(pattern)) {
[17:42:26.011]                           computeRestarts <- base::computeRestarts
[17:42:26.011]                           grepl <- base::grepl
[17:42:26.011]                           restarts <- computeRestarts(cond)
[17:42:26.011]                           for (restart in restarts) {
[17:42:26.011]                             name <- restart$name
[17:42:26.011]                             if (is.null(name)) 
[17:42:26.011]                               next
[17:42:26.011]                             if (!grepl(pattern, name)) 
[17:42:26.011]                               next
[17:42:26.011]                             invokeRestart(restart)
[17:42:26.011]                             muffled <- TRUE
[17:42:26.011]                             break
[17:42:26.011]                           }
[17:42:26.011]                         }
[17:42:26.011]                       }
[17:42:26.011]                       invisible(muffled)
[17:42:26.011]                     }
[17:42:26.011]                     muffleCondition(cond, pattern = "^muffle")
[17:42:26.011]                   }
[17:42:26.011]                 }
[17:42:26.011]             }
[17:42:26.011]         }))
[17:42:26.011]     }, error = function(ex) {
[17:42:26.011]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:26.011]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:26.011]                 ...future.rng), started = ...future.startTime, 
[17:42:26.011]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:26.011]             version = "1.8"), class = "FutureResult")
[17:42:26.011]     }, finally = {
[17:42:26.011]         if (!identical(...future.workdir, getwd())) 
[17:42:26.011]             setwd(...future.workdir)
[17:42:26.011]         {
[17:42:26.011]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:26.011]                 ...future.oldOptions$nwarnings <- NULL
[17:42:26.011]             }
[17:42:26.011]             base::options(...future.oldOptions)
[17:42:26.011]             if (.Platform$OS.type == "windows") {
[17:42:26.011]                 old_names <- names(...future.oldEnvVars)
[17:42:26.011]                 envs <- base::Sys.getenv()
[17:42:26.011]                 names <- names(envs)
[17:42:26.011]                 common <- intersect(names, old_names)
[17:42:26.011]                 added <- setdiff(names, old_names)
[17:42:26.011]                 removed <- setdiff(old_names, names)
[17:42:26.011]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:26.011]                   envs[common]]
[17:42:26.011]                 NAMES <- toupper(changed)
[17:42:26.011]                 args <- list()
[17:42:26.011]                 for (kk in seq_along(NAMES)) {
[17:42:26.011]                   name <- changed[[kk]]
[17:42:26.011]                   NAME <- NAMES[[kk]]
[17:42:26.011]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.011]                     next
[17:42:26.011]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:26.011]                 }
[17:42:26.011]                 NAMES <- toupper(added)
[17:42:26.011]                 for (kk in seq_along(NAMES)) {
[17:42:26.011]                   name <- added[[kk]]
[17:42:26.011]                   NAME <- NAMES[[kk]]
[17:42:26.011]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.011]                     next
[17:42:26.011]                   args[[name]] <- ""
[17:42:26.011]                 }
[17:42:26.011]                 NAMES <- toupper(removed)
[17:42:26.011]                 for (kk in seq_along(NAMES)) {
[17:42:26.011]                   name <- removed[[kk]]
[17:42:26.011]                   NAME <- NAMES[[kk]]
[17:42:26.011]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.011]                     next
[17:42:26.011]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:26.011]                 }
[17:42:26.011]                 if (length(args) > 0) 
[17:42:26.011]                   base::do.call(base::Sys.setenv, args = args)
[17:42:26.011]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:26.011]             }
[17:42:26.011]             else {
[17:42:26.011]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:26.011]             }
[17:42:26.011]             {
[17:42:26.011]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:26.011]                   0L) {
[17:42:26.011]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:26.011]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:26.011]                   base::options(opts)
[17:42:26.011]                 }
[17:42:26.011]                 {
[17:42:26.011]                   {
[17:42:26.011]                     NULL
[17:42:26.011]                     RNGkind("Mersenne-Twister")
[17:42:26.011]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:26.011]                       inherits = FALSE)
[17:42:26.011]                   }
[17:42:26.011]                   options(future.plan = NULL)
[17:42:26.011]                   if (is.na(NA_character_)) 
[17:42:26.011]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:26.011]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:26.011]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:26.011]                   {
[17:42:26.011]                     future <- SequentialFuture(..., envir = envir)
[17:42:26.011]                     if (!future$lazy) 
[17:42:26.011]                       future <- run(future)
[17:42:26.011]                     invisible(future)
[17:42:26.011]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:26.011]                 }
[17:42:26.011]             }
[17:42:26.011]         }
[17:42:26.011]     })
[17:42:26.011]     if (TRUE) {
[17:42:26.011]         base::sink(type = "output", split = FALSE)
[17:42:26.011]         if (TRUE) {
[17:42:26.011]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:26.011]         }
[17:42:26.011]         else {
[17:42:26.011]             ...future.result["stdout"] <- base::list(NULL)
[17:42:26.011]         }
[17:42:26.011]         base::close(...future.stdout)
[17:42:26.011]         ...future.stdout <- NULL
[17:42:26.011]     }
[17:42:26.011]     ...future.result$conditions <- ...future.conditions
[17:42:26.011]     ...future.result$finished <- base::Sys.time()
[17:42:26.011]     ...future.result
[17:42:26.011] }
[17:42:26.013] plan(): Setting new future strategy stack:
[17:42:26.013] List of future strategies:
[17:42:26.013] 1. sequential:
[17:42:26.013]    - args: function (..., envir = parent.frame())
[17:42:26.013]    - tweaked: FALSE
[17:42:26.013]    - call: NULL
[17:42:26.013] plan(): nbrOfWorkers() = 1
[17:42:26.015] plan(): Setting new future strategy stack:
[17:42:26.015] List of future strategies:
[17:42:26.015] 1. sequential:
[17:42:26.015]    - args: function (..., envir = parent.frame())
[17:42:26.015]    - tweaked: FALSE
[17:42:26.015]    - call: plan(strategy)
[17:42:26.015] plan(): nbrOfWorkers() = 1
[17:42:26.017] SequentialFuture started (and completed)
[17:42:26.017] - Launch lazy future ... done
[17:42:26.017] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[17:42:26.019] getGlobalsAndPackages() ...
[17:42:26.019] Searching for globals...
[17:42:26.024] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[17:42:26.024] Searching for globals ... DONE
[17:42:26.024] Resolving globals: FALSE
[17:42:26.025] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[17:42:26.025] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[17:42:26.025] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[17:42:26.025] 
[17:42:26.026] getGlobalsAndPackages() ... DONE
[17:42:26.026] run() for ‘Future’ ...
[17:42:26.026] - state: ‘created’
[17:42:26.026] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:26.026] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:26.026] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:26.026]   - Field: ‘label’
[17:42:26.027]   - Field: ‘local’
[17:42:26.027]   - Field: ‘owner’
[17:42:26.027]   - Field: ‘envir’
[17:42:26.027]   - Field: ‘packages’
[17:42:26.027]   - Field: ‘gc’
[17:42:26.027]   - Field: ‘conditions’
[17:42:26.027]   - Field: ‘expr’
[17:42:26.027]   - Field: ‘uuid’
[17:42:26.027]   - Field: ‘seed’
[17:42:26.027]   - Field: ‘version’
[17:42:26.028]   - Field: ‘result’
[17:42:26.028]   - Field: ‘asynchronous’
[17:42:26.028]   - Field: ‘calls’
[17:42:26.028]   - Field: ‘globals’
[17:42:26.028]   - Field: ‘stdout’
[17:42:26.028]   - Field: ‘earlySignal’
[17:42:26.028]   - Field: ‘lazy’
[17:42:26.028]   - Field: ‘state’
[17:42:26.028] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:26.028] - Launch lazy future ...
[17:42:26.029] Packages needed by the future expression (n = 0): <none>
[17:42:26.029] Packages needed by future strategies (n = 0): <none>
[17:42:26.029] {
[17:42:26.029]     {
[17:42:26.029]         {
[17:42:26.029]             ...future.startTime <- base::Sys.time()
[17:42:26.029]             {
[17:42:26.029]                 {
[17:42:26.029]                   {
[17:42:26.029]                     base::local({
[17:42:26.029]                       has_future <- base::requireNamespace("future", 
[17:42:26.029]                         quietly = TRUE)
[17:42:26.029]                       if (has_future) {
[17:42:26.029]                         ns <- base::getNamespace("future")
[17:42:26.029]                         version <- ns[[".package"]][["version"]]
[17:42:26.029]                         if (is.null(version)) 
[17:42:26.029]                           version <- utils::packageVersion("future")
[17:42:26.029]                       }
[17:42:26.029]                       else {
[17:42:26.029]                         version <- NULL
[17:42:26.029]                       }
[17:42:26.029]                       if (!has_future || version < "1.8.0") {
[17:42:26.029]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:26.029]                           "", base::R.version$version.string), 
[17:42:26.029]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:26.029]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:26.029]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:26.029]                             "release", "version")], collapse = " "), 
[17:42:26.029]                           hostname = base::Sys.info()[["nodename"]])
[17:42:26.029]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:26.029]                           info)
[17:42:26.029]                         info <- base::paste(info, collapse = "; ")
[17:42:26.029]                         if (!has_future) {
[17:42:26.029]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:26.029]                             info)
[17:42:26.029]                         }
[17:42:26.029]                         else {
[17:42:26.029]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:26.029]                             info, version)
[17:42:26.029]                         }
[17:42:26.029]                         base::stop(msg)
[17:42:26.029]                       }
[17:42:26.029]                     })
[17:42:26.029]                   }
[17:42:26.029]                   options(future.plan = NULL)
[17:42:26.029]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:26.029]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:26.029]                 }
[17:42:26.029]                 ...future.workdir <- getwd()
[17:42:26.029]             }
[17:42:26.029]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:26.029]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:26.029]         }
[17:42:26.029]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:26.029]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:26.029]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:26.029]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:26.029]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:26.029]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:26.029]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:26.029]             base::names(...future.oldOptions))
[17:42:26.029]     }
[17:42:26.029]     if (FALSE) {
[17:42:26.029]     }
[17:42:26.029]     else {
[17:42:26.029]         if (TRUE) {
[17:42:26.029]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:26.029]                 open = "w")
[17:42:26.029]         }
[17:42:26.029]         else {
[17:42:26.029]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:26.029]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:26.029]         }
[17:42:26.029]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:26.029]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:26.029]             base::sink(type = "output", split = FALSE)
[17:42:26.029]             base::close(...future.stdout)
[17:42:26.029]         }, add = TRUE)
[17:42:26.029]     }
[17:42:26.029]     ...future.frame <- base::sys.nframe()
[17:42:26.029]     ...future.conditions <- base::list()
[17:42:26.029]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:26.029]     if (FALSE) {
[17:42:26.029]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:26.029]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:26.029]     }
[17:42:26.029]     ...future.result <- base::tryCatch({
[17:42:26.029]         base::withCallingHandlers({
[17:42:26.029]             ...future.value <- base::withVisible(base::local({
[17:42:26.029]                 outer_function(1L)
[17:42:26.029]             }))
[17:42:26.029]             future::FutureResult(value = ...future.value$value, 
[17:42:26.029]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:26.029]                   ...future.rng), globalenv = if (FALSE) 
[17:42:26.029]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:26.029]                     ...future.globalenv.names))
[17:42:26.029]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:26.029]         }, condition = base::local({
[17:42:26.029]             c <- base::c
[17:42:26.029]             inherits <- base::inherits
[17:42:26.029]             invokeRestart <- base::invokeRestart
[17:42:26.029]             length <- base::length
[17:42:26.029]             list <- base::list
[17:42:26.029]             seq.int <- base::seq.int
[17:42:26.029]             signalCondition <- base::signalCondition
[17:42:26.029]             sys.calls <- base::sys.calls
[17:42:26.029]             `[[` <- base::`[[`
[17:42:26.029]             `+` <- base::`+`
[17:42:26.029]             `<<-` <- base::`<<-`
[17:42:26.029]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:26.029]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:26.029]                   3L)]
[17:42:26.029]             }
[17:42:26.029]             function(cond) {
[17:42:26.029]                 is_error <- inherits(cond, "error")
[17:42:26.029]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:26.029]                   NULL)
[17:42:26.029]                 if (is_error) {
[17:42:26.029]                   sessionInformation <- function() {
[17:42:26.029]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:26.029]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:26.029]                       search = base::search(), system = base::Sys.info())
[17:42:26.029]                   }
[17:42:26.029]                   ...future.conditions[[length(...future.conditions) + 
[17:42:26.029]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:26.029]                     cond$call), session = sessionInformation(), 
[17:42:26.029]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:26.029]                   signalCondition(cond)
[17:42:26.029]                 }
[17:42:26.029]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:26.029]                 "immediateCondition"))) {
[17:42:26.029]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:26.029]                   ...future.conditions[[length(...future.conditions) + 
[17:42:26.029]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:26.029]                   if (TRUE && !signal) {
[17:42:26.029]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.029]                     {
[17:42:26.029]                       inherits <- base::inherits
[17:42:26.029]                       invokeRestart <- base::invokeRestart
[17:42:26.029]                       is.null <- base::is.null
[17:42:26.029]                       muffled <- FALSE
[17:42:26.029]                       if (inherits(cond, "message")) {
[17:42:26.029]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:26.029]                         if (muffled) 
[17:42:26.029]                           invokeRestart("muffleMessage")
[17:42:26.029]                       }
[17:42:26.029]                       else if (inherits(cond, "warning")) {
[17:42:26.029]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:26.029]                         if (muffled) 
[17:42:26.029]                           invokeRestart("muffleWarning")
[17:42:26.029]                       }
[17:42:26.029]                       else if (inherits(cond, "condition")) {
[17:42:26.029]                         if (!is.null(pattern)) {
[17:42:26.029]                           computeRestarts <- base::computeRestarts
[17:42:26.029]                           grepl <- base::grepl
[17:42:26.029]                           restarts <- computeRestarts(cond)
[17:42:26.029]                           for (restart in restarts) {
[17:42:26.029]                             name <- restart$name
[17:42:26.029]                             if (is.null(name)) 
[17:42:26.029]                               next
[17:42:26.029]                             if (!grepl(pattern, name)) 
[17:42:26.029]                               next
[17:42:26.029]                             invokeRestart(restart)
[17:42:26.029]                             muffled <- TRUE
[17:42:26.029]                             break
[17:42:26.029]                           }
[17:42:26.029]                         }
[17:42:26.029]                       }
[17:42:26.029]                       invisible(muffled)
[17:42:26.029]                     }
[17:42:26.029]                     muffleCondition(cond, pattern = "^muffle")
[17:42:26.029]                   }
[17:42:26.029]                 }
[17:42:26.029]                 else {
[17:42:26.029]                   if (TRUE) {
[17:42:26.029]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.029]                     {
[17:42:26.029]                       inherits <- base::inherits
[17:42:26.029]                       invokeRestart <- base::invokeRestart
[17:42:26.029]                       is.null <- base::is.null
[17:42:26.029]                       muffled <- FALSE
[17:42:26.029]                       if (inherits(cond, "message")) {
[17:42:26.029]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:26.029]                         if (muffled) 
[17:42:26.029]                           invokeRestart("muffleMessage")
[17:42:26.029]                       }
[17:42:26.029]                       else if (inherits(cond, "warning")) {
[17:42:26.029]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:26.029]                         if (muffled) 
[17:42:26.029]                           invokeRestart("muffleWarning")
[17:42:26.029]                       }
[17:42:26.029]                       else if (inherits(cond, "condition")) {
[17:42:26.029]                         if (!is.null(pattern)) {
[17:42:26.029]                           computeRestarts <- base::computeRestarts
[17:42:26.029]                           grepl <- base::grepl
[17:42:26.029]                           restarts <- computeRestarts(cond)
[17:42:26.029]                           for (restart in restarts) {
[17:42:26.029]                             name <- restart$name
[17:42:26.029]                             if (is.null(name)) 
[17:42:26.029]                               next
[17:42:26.029]                             if (!grepl(pattern, name)) 
[17:42:26.029]                               next
[17:42:26.029]                             invokeRestart(restart)
[17:42:26.029]                             muffled <- TRUE
[17:42:26.029]                             break
[17:42:26.029]                           }
[17:42:26.029]                         }
[17:42:26.029]                       }
[17:42:26.029]                       invisible(muffled)
[17:42:26.029]                     }
[17:42:26.029]                     muffleCondition(cond, pattern = "^muffle")
[17:42:26.029]                   }
[17:42:26.029]                 }
[17:42:26.029]             }
[17:42:26.029]         }))
[17:42:26.029]     }, error = function(ex) {
[17:42:26.029]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:26.029]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:26.029]                 ...future.rng), started = ...future.startTime, 
[17:42:26.029]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:26.029]             version = "1.8"), class = "FutureResult")
[17:42:26.029]     }, finally = {
[17:42:26.029]         if (!identical(...future.workdir, getwd())) 
[17:42:26.029]             setwd(...future.workdir)
[17:42:26.029]         {
[17:42:26.029]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:26.029]                 ...future.oldOptions$nwarnings <- NULL
[17:42:26.029]             }
[17:42:26.029]             base::options(...future.oldOptions)
[17:42:26.029]             if (.Platform$OS.type == "windows") {
[17:42:26.029]                 old_names <- names(...future.oldEnvVars)
[17:42:26.029]                 envs <- base::Sys.getenv()
[17:42:26.029]                 names <- names(envs)
[17:42:26.029]                 common <- intersect(names, old_names)
[17:42:26.029]                 added <- setdiff(names, old_names)
[17:42:26.029]                 removed <- setdiff(old_names, names)
[17:42:26.029]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:26.029]                   envs[common]]
[17:42:26.029]                 NAMES <- toupper(changed)
[17:42:26.029]                 args <- list()
[17:42:26.029]                 for (kk in seq_along(NAMES)) {
[17:42:26.029]                   name <- changed[[kk]]
[17:42:26.029]                   NAME <- NAMES[[kk]]
[17:42:26.029]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.029]                     next
[17:42:26.029]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:26.029]                 }
[17:42:26.029]                 NAMES <- toupper(added)
[17:42:26.029]                 for (kk in seq_along(NAMES)) {
[17:42:26.029]                   name <- added[[kk]]
[17:42:26.029]                   NAME <- NAMES[[kk]]
[17:42:26.029]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.029]                     next
[17:42:26.029]                   args[[name]] <- ""
[17:42:26.029]                 }
[17:42:26.029]                 NAMES <- toupper(removed)
[17:42:26.029]                 for (kk in seq_along(NAMES)) {
[17:42:26.029]                   name <- removed[[kk]]
[17:42:26.029]                   NAME <- NAMES[[kk]]
[17:42:26.029]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.029]                     next
[17:42:26.029]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:26.029]                 }
[17:42:26.029]                 if (length(args) > 0) 
[17:42:26.029]                   base::do.call(base::Sys.setenv, args = args)
[17:42:26.029]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:26.029]             }
[17:42:26.029]             else {
[17:42:26.029]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:26.029]             }
[17:42:26.029]             {
[17:42:26.029]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:26.029]                   0L) {
[17:42:26.029]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:26.029]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:26.029]                   base::options(opts)
[17:42:26.029]                 }
[17:42:26.029]                 {
[17:42:26.029]                   {
[17:42:26.029]                     NULL
[17:42:26.029]                     RNGkind("Mersenne-Twister")
[17:42:26.029]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:26.029]                       inherits = FALSE)
[17:42:26.029]                   }
[17:42:26.029]                   options(future.plan = NULL)
[17:42:26.029]                   if (is.na(NA_character_)) 
[17:42:26.029]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:26.029]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:26.029]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:26.029]                   {
[17:42:26.029]                     future <- SequentialFuture(..., envir = envir)
[17:42:26.029]                     if (!future$lazy) 
[17:42:26.029]                       future <- run(future)
[17:42:26.029]                     invisible(future)
[17:42:26.029]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:26.029]                 }
[17:42:26.029]             }
[17:42:26.029]         }
[17:42:26.029]     })
[17:42:26.029]     if (TRUE) {
[17:42:26.029]         base::sink(type = "output", split = FALSE)
[17:42:26.029]         if (TRUE) {
[17:42:26.029]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:26.029]         }
[17:42:26.029]         else {
[17:42:26.029]             ...future.result["stdout"] <- base::list(NULL)
[17:42:26.029]         }
[17:42:26.029]         base::close(...future.stdout)
[17:42:26.029]         ...future.stdout <- NULL
[17:42:26.029]     }
[17:42:26.029]     ...future.result$conditions <- ...future.conditions
[17:42:26.029]     ...future.result$finished <- base::Sys.time()
[17:42:26.029]     ...future.result
[17:42:26.029] }
[17:42:26.031] assign_globals() ...
[17:42:26.031] List of 3
[17:42:26.031]  $ outer_function:function (x)  
[17:42:26.031]  $ map           :function (.x, .f, ...)  
[17:42:26.031]  $ inner_function:function (x)  
[17:42:26.031]  - attr(*, "where")=List of 3
[17:42:26.031]   ..$ outer_function:<environment: R_EmptyEnv> 
[17:42:26.031]   ..$ map           :<environment: R_EmptyEnv> 
[17:42:26.031]   ..$ inner_function:<environment: R_EmptyEnv> 
[17:42:26.031]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:26.031]  - attr(*, "resolved")= logi FALSE
[17:42:26.031]  - attr(*, "total_size")= num 7704
[17:42:26.031]  - attr(*, "already-done")= logi TRUE
[17:42:26.034] - reassign environment for ‘outer_function’
[17:42:26.034] - copied ‘outer_function’ to environment
[17:42:26.034] - reassign environment for ‘map’
[17:42:26.034] - copied ‘map’ to environment
[17:42:26.034] - reassign environment for ‘inner_function’
[17:42:26.034] - copied ‘inner_function’ to environment
[17:42:26.035] assign_globals() ... done
[17:42:26.035] plan(): Setting new future strategy stack:
[17:42:26.035] List of future strategies:
[17:42:26.035] 1. sequential:
[17:42:26.035]    - args: function (..., envir = parent.frame())
[17:42:26.035]    - tweaked: FALSE
[17:42:26.035]    - call: NULL
[17:42:26.035] plan(): nbrOfWorkers() = 1
[17:42:26.042] plan(): Setting new future strategy stack:
[17:42:26.042] List of future strategies:
[17:42:26.042] 1. sequential:
[17:42:26.042]    - args: function (..., envir = parent.frame())
[17:42:26.042]    - tweaked: FALSE
[17:42:26.042]    - call: plan(strategy)
[17:42:26.043] plan(): nbrOfWorkers() = 1
[17:42:26.043] SequentialFuture started (and completed)
[17:42:26.043] - Launch lazy future ... done
[17:42:26.043] run() for ‘SequentialFuture’ ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[17:42:26.045] getGlobalsAndPackages() ...
[17:42:26.045] Searching for globals...
[17:42:26.049] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[17:42:26.049] Searching for globals ... DONE
[17:42:26.049] Resolving globals: FALSE
[17:42:26.050] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[17:42:26.050] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[17:42:26.050] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[17:42:26.051] 
[17:42:26.051] getGlobalsAndPackages() ... DONE
[17:42:26.051] run() for ‘Future’ ...
[17:42:26.051] - state: ‘created’
[17:42:26.051] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:26.051] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:26.052] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:26.052]   - Field: ‘label’
[17:42:26.052]   - Field: ‘local’
[17:42:26.052]   - Field: ‘owner’
[17:42:26.052]   - Field: ‘envir’
[17:42:26.052]   - Field: ‘packages’
[17:42:26.052]   - Field: ‘gc’
[17:42:26.052]   - Field: ‘conditions’
[17:42:26.052]   - Field: ‘expr’
[17:42:26.052]   - Field: ‘uuid’
[17:42:26.053]   - Field: ‘seed’
[17:42:26.053]   - Field: ‘version’
[17:42:26.053]   - Field: ‘result’
[17:42:26.053]   - Field: ‘asynchronous’
[17:42:26.053]   - Field: ‘calls’
[17:42:26.053]   - Field: ‘globals’
[17:42:26.053]   - Field: ‘stdout’
[17:42:26.053]   - Field: ‘earlySignal’
[17:42:26.053]   - Field: ‘lazy’
[17:42:26.053]   - Field: ‘state’
[17:42:26.053] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:26.054] - Launch lazy future ...
[17:42:26.054] Packages needed by the future expression (n = 0): <none>
[17:42:26.054] Packages needed by future strategies (n = 0): <none>
[17:42:26.054] {
[17:42:26.054]     {
[17:42:26.054]         {
[17:42:26.054]             ...future.startTime <- base::Sys.time()
[17:42:26.054]             {
[17:42:26.054]                 {
[17:42:26.054]                   {
[17:42:26.054]                     base::local({
[17:42:26.054]                       has_future <- base::requireNamespace("future", 
[17:42:26.054]                         quietly = TRUE)
[17:42:26.054]                       if (has_future) {
[17:42:26.054]                         ns <- base::getNamespace("future")
[17:42:26.054]                         version <- ns[[".package"]][["version"]]
[17:42:26.054]                         if (is.null(version)) 
[17:42:26.054]                           version <- utils::packageVersion("future")
[17:42:26.054]                       }
[17:42:26.054]                       else {
[17:42:26.054]                         version <- NULL
[17:42:26.054]                       }
[17:42:26.054]                       if (!has_future || version < "1.8.0") {
[17:42:26.054]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:26.054]                           "", base::R.version$version.string), 
[17:42:26.054]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:26.054]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:26.054]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:26.054]                             "release", "version")], collapse = " "), 
[17:42:26.054]                           hostname = base::Sys.info()[["nodename"]])
[17:42:26.054]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:26.054]                           info)
[17:42:26.054]                         info <- base::paste(info, collapse = "; ")
[17:42:26.054]                         if (!has_future) {
[17:42:26.054]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:26.054]                             info)
[17:42:26.054]                         }
[17:42:26.054]                         else {
[17:42:26.054]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:26.054]                             info, version)
[17:42:26.054]                         }
[17:42:26.054]                         base::stop(msg)
[17:42:26.054]                       }
[17:42:26.054]                     })
[17:42:26.054]                   }
[17:42:26.054]                   options(future.plan = NULL)
[17:42:26.054]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:26.054]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:26.054]                 }
[17:42:26.054]                 ...future.workdir <- getwd()
[17:42:26.054]             }
[17:42:26.054]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:26.054]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:26.054]         }
[17:42:26.054]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:26.054]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:26.054]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:26.054]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:26.054]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:26.054]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:26.054]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:26.054]             base::names(...future.oldOptions))
[17:42:26.054]     }
[17:42:26.054]     if (FALSE) {
[17:42:26.054]     }
[17:42:26.054]     else {
[17:42:26.054]         if (TRUE) {
[17:42:26.054]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:26.054]                 open = "w")
[17:42:26.054]         }
[17:42:26.054]         else {
[17:42:26.054]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:26.054]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:26.054]         }
[17:42:26.054]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:26.054]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:26.054]             base::sink(type = "output", split = FALSE)
[17:42:26.054]             base::close(...future.stdout)
[17:42:26.054]         }, add = TRUE)
[17:42:26.054]     }
[17:42:26.054]     ...future.frame <- base::sys.nframe()
[17:42:26.054]     ...future.conditions <- base::list()
[17:42:26.054]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:26.054]     if (FALSE) {
[17:42:26.054]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:26.054]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:26.054]     }
[17:42:26.054]     ...future.result <- base::tryCatch({
[17:42:26.054]         base::withCallingHandlers({
[17:42:26.054]             ...future.value <- base::withVisible(base::local({
[17:42:26.054]                 outer_function(1L)
[17:42:26.054]             }))
[17:42:26.054]             future::FutureResult(value = ...future.value$value, 
[17:42:26.054]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:26.054]                   ...future.rng), globalenv = if (FALSE) 
[17:42:26.054]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:26.054]                     ...future.globalenv.names))
[17:42:26.054]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:26.054]         }, condition = base::local({
[17:42:26.054]             c <- base::c
[17:42:26.054]             inherits <- base::inherits
[17:42:26.054]             invokeRestart <- base::invokeRestart
[17:42:26.054]             length <- base::length
[17:42:26.054]             list <- base::list
[17:42:26.054]             seq.int <- base::seq.int
[17:42:26.054]             signalCondition <- base::signalCondition
[17:42:26.054]             sys.calls <- base::sys.calls
[17:42:26.054]             `[[` <- base::`[[`
[17:42:26.054]             `+` <- base::`+`
[17:42:26.054]             `<<-` <- base::`<<-`
[17:42:26.054]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:26.054]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:26.054]                   3L)]
[17:42:26.054]             }
[17:42:26.054]             function(cond) {
[17:42:26.054]                 is_error <- inherits(cond, "error")
[17:42:26.054]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:26.054]                   NULL)
[17:42:26.054]                 if (is_error) {
[17:42:26.054]                   sessionInformation <- function() {
[17:42:26.054]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:26.054]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:26.054]                       search = base::search(), system = base::Sys.info())
[17:42:26.054]                   }
[17:42:26.054]                   ...future.conditions[[length(...future.conditions) + 
[17:42:26.054]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:26.054]                     cond$call), session = sessionInformation(), 
[17:42:26.054]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:26.054]                   signalCondition(cond)
[17:42:26.054]                 }
[17:42:26.054]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:26.054]                 "immediateCondition"))) {
[17:42:26.054]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:26.054]                   ...future.conditions[[length(...future.conditions) + 
[17:42:26.054]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:26.054]                   if (TRUE && !signal) {
[17:42:26.054]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.054]                     {
[17:42:26.054]                       inherits <- base::inherits
[17:42:26.054]                       invokeRestart <- base::invokeRestart
[17:42:26.054]                       is.null <- base::is.null
[17:42:26.054]                       muffled <- FALSE
[17:42:26.054]                       if (inherits(cond, "message")) {
[17:42:26.054]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:26.054]                         if (muffled) 
[17:42:26.054]                           invokeRestart("muffleMessage")
[17:42:26.054]                       }
[17:42:26.054]                       else if (inherits(cond, "warning")) {
[17:42:26.054]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:26.054]                         if (muffled) 
[17:42:26.054]                           invokeRestart("muffleWarning")
[17:42:26.054]                       }
[17:42:26.054]                       else if (inherits(cond, "condition")) {
[17:42:26.054]                         if (!is.null(pattern)) {
[17:42:26.054]                           computeRestarts <- base::computeRestarts
[17:42:26.054]                           grepl <- base::grepl
[17:42:26.054]                           restarts <- computeRestarts(cond)
[17:42:26.054]                           for (restart in restarts) {
[17:42:26.054]                             name <- restart$name
[17:42:26.054]                             if (is.null(name)) 
[17:42:26.054]                               next
[17:42:26.054]                             if (!grepl(pattern, name)) 
[17:42:26.054]                               next
[17:42:26.054]                             invokeRestart(restart)
[17:42:26.054]                             muffled <- TRUE
[17:42:26.054]                             break
[17:42:26.054]                           }
[17:42:26.054]                         }
[17:42:26.054]                       }
[17:42:26.054]                       invisible(muffled)
[17:42:26.054]                     }
[17:42:26.054]                     muffleCondition(cond, pattern = "^muffle")
[17:42:26.054]                   }
[17:42:26.054]                 }
[17:42:26.054]                 else {
[17:42:26.054]                   if (TRUE) {
[17:42:26.054]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.054]                     {
[17:42:26.054]                       inherits <- base::inherits
[17:42:26.054]                       invokeRestart <- base::invokeRestart
[17:42:26.054]                       is.null <- base::is.null
[17:42:26.054]                       muffled <- FALSE
[17:42:26.054]                       if (inherits(cond, "message")) {
[17:42:26.054]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:26.054]                         if (muffled) 
[17:42:26.054]                           invokeRestart("muffleMessage")
[17:42:26.054]                       }
[17:42:26.054]                       else if (inherits(cond, "warning")) {
[17:42:26.054]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:26.054]                         if (muffled) 
[17:42:26.054]                           invokeRestart("muffleWarning")
[17:42:26.054]                       }
[17:42:26.054]                       else if (inherits(cond, "condition")) {
[17:42:26.054]                         if (!is.null(pattern)) {
[17:42:26.054]                           computeRestarts <- base::computeRestarts
[17:42:26.054]                           grepl <- base::grepl
[17:42:26.054]                           restarts <- computeRestarts(cond)
[17:42:26.054]                           for (restart in restarts) {
[17:42:26.054]                             name <- restart$name
[17:42:26.054]                             if (is.null(name)) 
[17:42:26.054]                               next
[17:42:26.054]                             if (!grepl(pattern, name)) 
[17:42:26.054]                               next
[17:42:26.054]                             invokeRestart(restart)
[17:42:26.054]                             muffled <- TRUE
[17:42:26.054]                             break
[17:42:26.054]                           }
[17:42:26.054]                         }
[17:42:26.054]                       }
[17:42:26.054]                       invisible(muffled)
[17:42:26.054]                     }
[17:42:26.054]                     muffleCondition(cond, pattern = "^muffle")
[17:42:26.054]                   }
[17:42:26.054]                 }
[17:42:26.054]             }
[17:42:26.054]         }))
[17:42:26.054]     }, error = function(ex) {
[17:42:26.054]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:26.054]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:26.054]                 ...future.rng), started = ...future.startTime, 
[17:42:26.054]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:26.054]             version = "1.8"), class = "FutureResult")
[17:42:26.054]     }, finally = {
[17:42:26.054]         if (!identical(...future.workdir, getwd())) 
[17:42:26.054]             setwd(...future.workdir)
[17:42:26.054]         {
[17:42:26.054]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:26.054]                 ...future.oldOptions$nwarnings <- NULL
[17:42:26.054]             }
[17:42:26.054]             base::options(...future.oldOptions)
[17:42:26.054]             if (.Platform$OS.type == "windows") {
[17:42:26.054]                 old_names <- names(...future.oldEnvVars)
[17:42:26.054]                 envs <- base::Sys.getenv()
[17:42:26.054]                 names <- names(envs)
[17:42:26.054]                 common <- intersect(names, old_names)
[17:42:26.054]                 added <- setdiff(names, old_names)
[17:42:26.054]                 removed <- setdiff(old_names, names)
[17:42:26.054]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:26.054]                   envs[common]]
[17:42:26.054]                 NAMES <- toupper(changed)
[17:42:26.054]                 args <- list()
[17:42:26.054]                 for (kk in seq_along(NAMES)) {
[17:42:26.054]                   name <- changed[[kk]]
[17:42:26.054]                   NAME <- NAMES[[kk]]
[17:42:26.054]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.054]                     next
[17:42:26.054]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:26.054]                 }
[17:42:26.054]                 NAMES <- toupper(added)
[17:42:26.054]                 for (kk in seq_along(NAMES)) {
[17:42:26.054]                   name <- added[[kk]]
[17:42:26.054]                   NAME <- NAMES[[kk]]
[17:42:26.054]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.054]                     next
[17:42:26.054]                   args[[name]] <- ""
[17:42:26.054]                 }
[17:42:26.054]                 NAMES <- toupper(removed)
[17:42:26.054]                 for (kk in seq_along(NAMES)) {
[17:42:26.054]                   name <- removed[[kk]]
[17:42:26.054]                   NAME <- NAMES[[kk]]
[17:42:26.054]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.054]                     next
[17:42:26.054]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:26.054]                 }
[17:42:26.054]                 if (length(args) > 0) 
[17:42:26.054]                   base::do.call(base::Sys.setenv, args = args)
[17:42:26.054]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:26.054]             }
[17:42:26.054]             else {
[17:42:26.054]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:26.054]             }
[17:42:26.054]             {
[17:42:26.054]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:26.054]                   0L) {
[17:42:26.054]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:26.054]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:26.054]                   base::options(opts)
[17:42:26.054]                 }
[17:42:26.054]                 {
[17:42:26.054]                   {
[17:42:26.054]                     NULL
[17:42:26.054]                     RNGkind("Mersenne-Twister")
[17:42:26.054]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:26.054]                       inherits = FALSE)
[17:42:26.054]                   }
[17:42:26.054]                   options(future.plan = NULL)
[17:42:26.054]                   if (is.na(NA_character_)) 
[17:42:26.054]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:26.054]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:26.054]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:26.054]                   {
[17:42:26.054]                     future <- SequentialFuture(..., envir = envir)
[17:42:26.054]                     if (!future$lazy) 
[17:42:26.054]                       future <- run(future)
[17:42:26.054]                     invisible(future)
[17:42:26.054]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:26.054]                 }
[17:42:26.054]             }
[17:42:26.054]         }
[17:42:26.054]     })
[17:42:26.054]     if (TRUE) {
[17:42:26.054]         base::sink(type = "output", split = FALSE)
[17:42:26.054]         if (TRUE) {
[17:42:26.054]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:26.054]         }
[17:42:26.054]         else {
[17:42:26.054]             ...future.result["stdout"] <- base::list(NULL)
[17:42:26.054]         }
[17:42:26.054]         base::close(...future.stdout)
[17:42:26.054]         ...future.stdout <- NULL
[17:42:26.054]     }
[17:42:26.054]     ...future.result$conditions <- ...future.conditions
[17:42:26.054]     ...future.result$finished <- base::Sys.time()
[17:42:26.054]     ...future.result
[17:42:26.054] }
[17:42:26.056] assign_globals() ...
[17:42:26.056] List of 3
[17:42:26.056]  $ outer_function:function (x)  
[17:42:26.056]  $ map           :function (.x, .f, ...)  
[17:42:26.056]  $ inner_function:function (x)  
[17:42:26.056]  - attr(*, "where")=List of 3
[17:42:26.056]   ..$ outer_function:<environment: R_EmptyEnv> 
[17:42:26.056]   ..$ map           :<environment: R_EmptyEnv> 
[17:42:26.056]   ..$ inner_function:<environment: R_EmptyEnv> 
[17:42:26.056]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:26.056]  - attr(*, "resolved")= logi FALSE
[17:42:26.056]  - attr(*, "total_size")= num 7704
[17:42:26.056]  - attr(*, "already-done")= logi TRUE
[17:42:26.059] - reassign environment for ‘outer_function’
[17:42:26.059] - copied ‘outer_function’ to environment
[17:42:26.060] - reassign environment for ‘map’
[17:42:26.061] - copied ‘map’ to environment
[17:42:26.061] - reassign environment for ‘inner_function’
[17:42:26.061] - copied ‘inner_function’ to environment
[17:42:26.061] assign_globals() ... done
[17:42:26.062] plan(): Setting new future strategy stack:
[17:42:26.062] List of future strategies:
[17:42:26.062] 1. sequential:
[17:42:26.062]    - args: function (..., envir = parent.frame())
[17:42:26.062]    - tweaked: FALSE
[17:42:26.062]    - call: NULL
[17:42:26.062] plan(): nbrOfWorkers() = 1
[17:42:26.063] plan(): Setting new future strategy stack:
[17:42:26.063] List of future strategies:
[17:42:26.063] 1. sequential:
[17:42:26.063]    - args: function (..., envir = parent.frame())
[17:42:26.063]    - tweaked: FALSE
[17:42:26.063]    - call: plan(strategy)
[17:42:26.063] plan(): nbrOfWorkers() = 1
[17:42:26.064] SequentialFuture started (and completed)
[17:42:26.064] - Launch lazy future ... done
[17:42:26.064] run() for ‘SequentialFuture’ ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- plan('multicore') ...
[17:42:26.075] plan(): Setting new future strategy stack:
[17:42:26.075] List of future strategies:
[17:42:26.075] 1. multicore:
[17:42:26.075]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:26.075]    - tweaked: FALSE
[17:42:26.075]    - call: plan(strategy)
[17:42:26.079] plan(): nbrOfWorkers() = 2
- lm(<formula>) ...
[17:42:26.079] getGlobalsAndPackages() ...
[17:42:26.079] Searching for globals...
[17:42:26.080] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:42:26.080] Searching for globals ... DONE
[17:42:26.081] Resolving globals: FALSE
[17:42:26.081] The total size of the 2 globals is 896 bytes (896 bytes)
[17:42:26.081] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:42:26.082] - globals: [2] ‘weight’, ‘group’
[17:42:26.082] - packages: [1] ‘stats’
[17:42:26.082] getGlobalsAndPackages() ... DONE
[17:42:26.082] run() for ‘Future’ ...
[17:42:26.082] - state: ‘created’
[17:42:26.082] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:26.086] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:26.086] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:26.086]   - Field: ‘label’
[17:42:26.086]   - Field: ‘local’
[17:42:26.086]   - Field: ‘owner’
[17:42:26.087]   - Field: ‘envir’
[17:42:26.087]   - Field: ‘workers’
[17:42:26.087]   - Field: ‘packages’
[17:42:26.087]   - Field: ‘gc’
[17:42:26.087]   - Field: ‘job’
[17:42:26.087]   - Field: ‘conditions’
[17:42:26.087]   - Field: ‘expr’
[17:42:26.087]   - Field: ‘uuid’
[17:42:26.087]   - Field: ‘seed’
[17:42:26.088]   - Field: ‘version’
[17:42:26.088]   - Field: ‘result’
[17:42:26.088]   - Field: ‘asynchronous’
[17:42:26.088]   - Field: ‘calls’
[17:42:26.088]   - Field: ‘globals’
[17:42:26.088]   - Field: ‘stdout’
[17:42:26.088]   - Field: ‘earlySignal’
[17:42:26.088]   - Field: ‘lazy’
[17:42:26.090]   - Field: ‘state’
[17:42:26.090] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:26.090] - Launch lazy future ...
[17:42:26.091] Packages needed by the future expression (n = 1): ‘stats’
[17:42:26.091] Packages needed by future strategies (n = 0): <none>
[17:42:26.092] {
[17:42:26.092]     {
[17:42:26.092]         {
[17:42:26.092]             ...future.startTime <- base::Sys.time()
[17:42:26.092]             {
[17:42:26.092]                 {
[17:42:26.092]                   {
[17:42:26.092]                     {
[17:42:26.092]                       {
[17:42:26.092]                         base::local({
[17:42:26.092]                           has_future <- base::requireNamespace("future", 
[17:42:26.092]                             quietly = TRUE)
[17:42:26.092]                           if (has_future) {
[17:42:26.092]                             ns <- base::getNamespace("future")
[17:42:26.092]                             version <- ns[[".package"]][["version"]]
[17:42:26.092]                             if (is.null(version)) 
[17:42:26.092]                               version <- utils::packageVersion("future")
[17:42:26.092]                           }
[17:42:26.092]                           else {
[17:42:26.092]                             version <- NULL
[17:42:26.092]                           }
[17:42:26.092]                           if (!has_future || version < "1.8.0") {
[17:42:26.092]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:26.092]                               "", base::R.version$version.string), 
[17:42:26.092]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:26.092]                                 base::R.version$platform, 8 * 
[17:42:26.092]                                   base::.Machine$sizeof.pointer), 
[17:42:26.092]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:26.092]                                 "release", "version")], collapse = " "), 
[17:42:26.092]                               hostname = base::Sys.info()[["nodename"]])
[17:42:26.092]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:26.092]                               info)
[17:42:26.092]                             info <- base::paste(info, collapse = "; ")
[17:42:26.092]                             if (!has_future) {
[17:42:26.092]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:26.092]                                 info)
[17:42:26.092]                             }
[17:42:26.092]                             else {
[17:42:26.092]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:26.092]                                 info, version)
[17:42:26.092]                             }
[17:42:26.092]                             base::stop(msg)
[17:42:26.092]                           }
[17:42:26.092]                         })
[17:42:26.092]                       }
[17:42:26.092]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:26.092]                       base::options(mc.cores = 1L)
[17:42:26.092]                     }
[17:42:26.092]                     base::local({
[17:42:26.092]                       for (pkg in "stats") {
[17:42:26.092]                         base::loadNamespace(pkg)
[17:42:26.092]                         base::library(pkg, character.only = TRUE)
[17:42:26.092]                       }
[17:42:26.092]                     })
[17:42:26.092]                   }
[17:42:26.092]                   options(future.plan = NULL)
[17:42:26.092]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:26.092]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:26.092]                 }
[17:42:26.092]                 ...future.workdir <- getwd()
[17:42:26.092]             }
[17:42:26.092]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:26.092]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:26.092]         }
[17:42:26.092]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:26.092]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:26.092]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:26.092]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:26.092]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:26.092]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:26.092]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:26.092]             base::names(...future.oldOptions))
[17:42:26.092]     }
[17:42:26.092]     if (FALSE) {
[17:42:26.092]     }
[17:42:26.092]     else {
[17:42:26.092]         if (TRUE) {
[17:42:26.092]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:26.092]                 open = "w")
[17:42:26.092]         }
[17:42:26.092]         else {
[17:42:26.092]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:26.092]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:26.092]         }
[17:42:26.092]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:26.092]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:26.092]             base::sink(type = "output", split = FALSE)
[17:42:26.092]             base::close(...future.stdout)
[17:42:26.092]         }, add = TRUE)
[17:42:26.092]     }
[17:42:26.092]     ...future.frame <- base::sys.nframe()
[17:42:26.092]     ...future.conditions <- base::list()
[17:42:26.092]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:26.092]     if (FALSE) {
[17:42:26.092]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:26.092]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:26.092]     }
[17:42:26.092]     ...future.result <- base::tryCatch({
[17:42:26.092]         base::withCallingHandlers({
[17:42:26.092]             ...future.value <- base::withVisible(base::local({
[17:42:26.092]                 withCallingHandlers({
[17:42:26.092]                   {
[17:42:26.092]                     lm(weight ~ group - 1)
[17:42:26.092]                   }
[17:42:26.092]                 }, immediateCondition = function(cond) {
[17:42:26.092]                   save_rds <- function (object, pathname, ...) 
[17:42:26.092]                   {
[17:42:26.092]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:26.092]                     if (file_test("-f", pathname_tmp)) {
[17:42:26.092]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.092]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:26.092]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.092]                         fi_tmp[["mtime"]])
[17:42:26.092]                     }
[17:42:26.092]                     tryCatch({
[17:42:26.092]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:26.092]                     }, error = function(ex) {
[17:42:26.092]                       msg <- conditionMessage(ex)
[17:42:26.092]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.092]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:26.092]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.092]                         fi_tmp[["mtime"]], msg)
[17:42:26.092]                       ex$message <- msg
[17:42:26.092]                       stop(ex)
[17:42:26.092]                     })
[17:42:26.092]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:26.092]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:26.092]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:26.092]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.092]                       fi <- file.info(pathname)
[17:42:26.092]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:26.092]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.092]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:26.092]                         fi[["size"]], fi[["mtime"]])
[17:42:26.092]                       stop(msg)
[17:42:26.092]                     }
[17:42:26.092]                     invisible(pathname)
[17:42:26.092]                   }
[17:42:26.092]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:26.092]                     rootPath = tempdir()) 
[17:42:26.092]                   {
[17:42:26.092]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:26.092]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:26.092]                       tmpdir = path, fileext = ".rds")
[17:42:26.092]                     save_rds(obj, file)
[17:42:26.092]                   }
[17:42:26.092]                   saveImmediateCondition(cond, path = "/tmp/RtmpNwFxwa/.future/immediateConditions")
[17:42:26.092]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.092]                   {
[17:42:26.092]                     inherits <- base::inherits
[17:42:26.092]                     invokeRestart <- base::invokeRestart
[17:42:26.092]                     is.null <- base::is.null
[17:42:26.092]                     muffled <- FALSE
[17:42:26.092]                     if (inherits(cond, "message")) {
[17:42:26.092]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:26.092]                       if (muffled) 
[17:42:26.092]                         invokeRestart("muffleMessage")
[17:42:26.092]                     }
[17:42:26.092]                     else if (inherits(cond, "warning")) {
[17:42:26.092]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:26.092]                       if (muffled) 
[17:42:26.092]                         invokeRestart("muffleWarning")
[17:42:26.092]                     }
[17:42:26.092]                     else if (inherits(cond, "condition")) {
[17:42:26.092]                       if (!is.null(pattern)) {
[17:42:26.092]                         computeRestarts <- base::computeRestarts
[17:42:26.092]                         grepl <- base::grepl
[17:42:26.092]                         restarts <- computeRestarts(cond)
[17:42:26.092]                         for (restart in restarts) {
[17:42:26.092]                           name <- restart$name
[17:42:26.092]                           if (is.null(name)) 
[17:42:26.092]                             next
[17:42:26.092]                           if (!grepl(pattern, name)) 
[17:42:26.092]                             next
[17:42:26.092]                           invokeRestart(restart)
[17:42:26.092]                           muffled <- TRUE
[17:42:26.092]                           break
[17:42:26.092]                         }
[17:42:26.092]                       }
[17:42:26.092]                     }
[17:42:26.092]                     invisible(muffled)
[17:42:26.092]                   }
[17:42:26.092]                   muffleCondition(cond)
[17:42:26.092]                 })
[17:42:26.092]             }))
[17:42:26.092]             future::FutureResult(value = ...future.value$value, 
[17:42:26.092]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:26.092]                   ...future.rng), globalenv = if (FALSE) 
[17:42:26.092]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:26.092]                     ...future.globalenv.names))
[17:42:26.092]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:26.092]         }, condition = base::local({
[17:42:26.092]             c <- base::c
[17:42:26.092]             inherits <- base::inherits
[17:42:26.092]             invokeRestart <- base::invokeRestart
[17:42:26.092]             length <- base::length
[17:42:26.092]             list <- base::list
[17:42:26.092]             seq.int <- base::seq.int
[17:42:26.092]             signalCondition <- base::signalCondition
[17:42:26.092]             sys.calls <- base::sys.calls
[17:42:26.092]             `[[` <- base::`[[`
[17:42:26.092]             `+` <- base::`+`
[17:42:26.092]             `<<-` <- base::`<<-`
[17:42:26.092]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:26.092]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:26.092]                   3L)]
[17:42:26.092]             }
[17:42:26.092]             function(cond) {
[17:42:26.092]                 is_error <- inherits(cond, "error")
[17:42:26.092]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:26.092]                   NULL)
[17:42:26.092]                 if (is_error) {
[17:42:26.092]                   sessionInformation <- function() {
[17:42:26.092]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:26.092]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:26.092]                       search = base::search(), system = base::Sys.info())
[17:42:26.092]                   }
[17:42:26.092]                   ...future.conditions[[length(...future.conditions) + 
[17:42:26.092]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:26.092]                     cond$call), session = sessionInformation(), 
[17:42:26.092]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:26.092]                   signalCondition(cond)
[17:42:26.092]                 }
[17:42:26.092]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:26.092]                 "immediateCondition"))) {
[17:42:26.092]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:26.092]                   ...future.conditions[[length(...future.conditions) + 
[17:42:26.092]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:26.092]                   if (TRUE && !signal) {
[17:42:26.092]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.092]                     {
[17:42:26.092]                       inherits <- base::inherits
[17:42:26.092]                       invokeRestart <- base::invokeRestart
[17:42:26.092]                       is.null <- base::is.null
[17:42:26.092]                       muffled <- FALSE
[17:42:26.092]                       if (inherits(cond, "message")) {
[17:42:26.092]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:26.092]                         if (muffled) 
[17:42:26.092]                           invokeRestart("muffleMessage")
[17:42:26.092]                       }
[17:42:26.092]                       else if (inherits(cond, "warning")) {
[17:42:26.092]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:26.092]                         if (muffled) 
[17:42:26.092]                           invokeRestart("muffleWarning")
[17:42:26.092]                       }
[17:42:26.092]                       else if (inherits(cond, "condition")) {
[17:42:26.092]                         if (!is.null(pattern)) {
[17:42:26.092]                           computeRestarts <- base::computeRestarts
[17:42:26.092]                           grepl <- base::grepl
[17:42:26.092]                           restarts <- computeRestarts(cond)
[17:42:26.092]                           for (restart in restarts) {
[17:42:26.092]                             name <- restart$name
[17:42:26.092]                             if (is.null(name)) 
[17:42:26.092]                               next
[17:42:26.092]                             if (!grepl(pattern, name)) 
[17:42:26.092]                               next
[17:42:26.092]                             invokeRestart(restart)
[17:42:26.092]                             muffled <- TRUE
[17:42:26.092]                             break
[17:42:26.092]                           }
[17:42:26.092]                         }
[17:42:26.092]                       }
[17:42:26.092]                       invisible(muffled)
[17:42:26.092]                     }
[17:42:26.092]                     muffleCondition(cond, pattern = "^muffle")
[17:42:26.092]                   }
[17:42:26.092]                 }
[17:42:26.092]                 else {
[17:42:26.092]                   if (TRUE) {
[17:42:26.092]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.092]                     {
[17:42:26.092]                       inherits <- base::inherits
[17:42:26.092]                       invokeRestart <- base::invokeRestart
[17:42:26.092]                       is.null <- base::is.null
[17:42:26.092]                       muffled <- FALSE
[17:42:26.092]                       if (inherits(cond, "message")) {
[17:42:26.092]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:26.092]                         if (muffled) 
[17:42:26.092]                           invokeRestart("muffleMessage")
[17:42:26.092]                       }
[17:42:26.092]                       else if (inherits(cond, "warning")) {
[17:42:26.092]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:26.092]                         if (muffled) 
[17:42:26.092]                           invokeRestart("muffleWarning")
[17:42:26.092]                       }
[17:42:26.092]                       else if (inherits(cond, "condition")) {
[17:42:26.092]                         if (!is.null(pattern)) {
[17:42:26.092]                           computeRestarts <- base::computeRestarts
[17:42:26.092]                           grepl <- base::grepl
[17:42:26.092]                           restarts <- computeRestarts(cond)
[17:42:26.092]                           for (restart in restarts) {
[17:42:26.092]                             name <- restart$name
[17:42:26.092]                             if (is.null(name)) 
[17:42:26.092]                               next
[17:42:26.092]                             if (!grepl(pattern, name)) 
[17:42:26.092]                               next
[17:42:26.092]                             invokeRestart(restart)
[17:42:26.092]                             muffled <- TRUE
[17:42:26.092]                             break
[17:42:26.092]                           }
[17:42:26.092]                         }
[17:42:26.092]                       }
[17:42:26.092]                       invisible(muffled)
[17:42:26.092]                     }
[17:42:26.092]                     muffleCondition(cond, pattern = "^muffle")
[17:42:26.092]                   }
[17:42:26.092]                 }
[17:42:26.092]             }
[17:42:26.092]         }))
[17:42:26.092]     }, error = function(ex) {
[17:42:26.092]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:26.092]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:26.092]                 ...future.rng), started = ...future.startTime, 
[17:42:26.092]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:26.092]             version = "1.8"), class = "FutureResult")
[17:42:26.092]     }, finally = {
[17:42:26.092]         if (!identical(...future.workdir, getwd())) 
[17:42:26.092]             setwd(...future.workdir)
[17:42:26.092]         {
[17:42:26.092]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:26.092]                 ...future.oldOptions$nwarnings <- NULL
[17:42:26.092]             }
[17:42:26.092]             base::options(...future.oldOptions)
[17:42:26.092]             if (.Platform$OS.type == "windows") {
[17:42:26.092]                 old_names <- names(...future.oldEnvVars)
[17:42:26.092]                 envs <- base::Sys.getenv()
[17:42:26.092]                 names <- names(envs)
[17:42:26.092]                 common <- intersect(names, old_names)
[17:42:26.092]                 added <- setdiff(names, old_names)
[17:42:26.092]                 removed <- setdiff(old_names, names)
[17:42:26.092]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:26.092]                   envs[common]]
[17:42:26.092]                 NAMES <- toupper(changed)
[17:42:26.092]                 args <- list()
[17:42:26.092]                 for (kk in seq_along(NAMES)) {
[17:42:26.092]                   name <- changed[[kk]]
[17:42:26.092]                   NAME <- NAMES[[kk]]
[17:42:26.092]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.092]                     next
[17:42:26.092]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:26.092]                 }
[17:42:26.092]                 NAMES <- toupper(added)
[17:42:26.092]                 for (kk in seq_along(NAMES)) {
[17:42:26.092]                   name <- added[[kk]]
[17:42:26.092]                   NAME <- NAMES[[kk]]
[17:42:26.092]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.092]                     next
[17:42:26.092]                   args[[name]] <- ""
[17:42:26.092]                 }
[17:42:26.092]                 NAMES <- toupper(removed)
[17:42:26.092]                 for (kk in seq_along(NAMES)) {
[17:42:26.092]                   name <- removed[[kk]]
[17:42:26.092]                   NAME <- NAMES[[kk]]
[17:42:26.092]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.092]                     next
[17:42:26.092]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:26.092]                 }
[17:42:26.092]                 if (length(args) > 0) 
[17:42:26.092]                   base::do.call(base::Sys.setenv, args = args)
[17:42:26.092]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:26.092]             }
[17:42:26.092]             else {
[17:42:26.092]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:26.092]             }
[17:42:26.092]             {
[17:42:26.092]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:26.092]                   0L) {
[17:42:26.092]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:26.092]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:26.092]                   base::options(opts)
[17:42:26.092]                 }
[17:42:26.092]                 {
[17:42:26.092]                   {
[17:42:26.092]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:26.092]                     NULL
[17:42:26.092]                   }
[17:42:26.092]                   options(future.plan = NULL)
[17:42:26.092]                   if (is.na(NA_character_)) 
[17:42:26.092]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:26.092]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:26.092]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:26.092]                     envir = parent.frame()) 
[17:42:26.092]                   {
[17:42:26.092]                     default_workers <- missing(workers)
[17:42:26.092]                     if (is.function(workers)) 
[17:42:26.092]                       workers <- workers()
[17:42:26.092]                     workers <- structure(as.integer(workers), 
[17:42:26.092]                       class = class(workers))
[17:42:26.092]                     stop_if_not(is.finite(workers), workers >= 
[17:42:26.092]                       1L)
[17:42:26.092]                     if ((workers == 1L && !inherits(workers, 
[17:42:26.092]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:26.092]                       if (default_workers) 
[17:42:26.092]                         supportsMulticore(warn = TRUE)
[17:42:26.092]                       return(sequential(..., envir = envir))
[17:42:26.092]                     }
[17:42:26.092]                     oopts <- options(mc.cores = workers)
[17:42:26.092]                     on.exit(options(oopts))
[17:42:26.092]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:26.092]                       envir = envir)
[17:42:26.092]                     if (!future$lazy) 
[17:42:26.092]                       future <- run(future)
[17:42:26.092]                     invisible(future)
[17:42:26.092]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:26.092]                 }
[17:42:26.092]             }
[17:42:26.092]         }
[17:42:26.092]     })
[17:42:26.092]     if (TRUE) {
[17:42:26.092]         base::sink(type = "output", split = FALSE)
[17:42:26.092]         if (TRUE) {
[17:42:26.092]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:26.092]         }
[17:42:26.092]         else {
[17:42:26.092]             ...future.result["stdout"] <- base::list(NULL)
[17:42:26.092]         }
[17:42:26.092]         base::close(...future.stdout)
[17:42:26.092]         ...future.stdout <- NULL
[17:42:26.092]     }
[17:42:26.092]     ...future.result$conditions <- ...future.conditions
[17:42:26.092]     ...future.result$finished <- base::Sys.time()
[17:42:26.092]     ...future.result
[17:42:26.092] }
[17:42:26.094] assign_globals() ...
[17:42:26.094] List of 2
[17:42:26.094]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[17:42:26.094]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[17:42:26.094]  - attr(*, "where")=List of 2
[17:42:26.094]   ..$ weight:<environment: R_EmptyEnv> 
[17:42:26.094]   ..$ group :<environment: R_EmptyEnv> 
[17:42:26.094]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:26.094]  - attr(*, "resolved")= logi FALSE
[17:42:26.094]  - attr(*, "total_size")= num 896
[17:42:26.094]  - attr(*, "already-done")= logi TRUE
[17:42:26.097] - copied ‘weight’ to environment
[17:42:26.098] - copied ‘group’ to environment
[17:42:26.098] assign_globals() ... done
[17:42:26.098] requestCore(): workers = 2
[17:42:26.101] MulticoreFuture started
[17:42:26.101] - Launch lazy future ... done
[17:42:26.101] run() for ‘MulticoreFuture’ ... done
[17:42:26.102] plan(): Setting new future strategy stack:
[17:42:26.102] List of future strategies:
[17:42:26.102] 1. sequential:
[17:42:26.102]    - args: function (..., envir = parent.frame())
[17:42:26.102]    - tweaked: FALSE
[17:42:26.102]    - call: NULL
[17:42:26.103] plan(): nbrOfWorkers() = 1
[17:42:26.106] plan(): Setting new future strategy stack:
[17:42:26.106] List of future strategies:
[17:42:26.106] 1. multicore:
[17:42:26.106]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:26.106]    - tweaked: FALSE
[17:42:26.106]    - call: plan(strategy)
[17:42:26.111] plan(): nbrOfWorkers() = 2

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[17:42:26.119] getGlobalsAndPackages() ...
[17:42:26.119] Searching for globals...
[17:42:26.121] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:42:26.121] Searching for globals ... DONE
[17:42:26.122] Resolving globals: FALSE
[17:42:26.122] The total size of the 2 globals is 896 bytes (896 bytes)
[17:42:26.123] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:42:26.123] - globals: [2] ‘weight’, ‘group’
[17:42:26.123] - packages: [1] ‘stats’
[17:42:26.123] getGlobalsAndPackages() ... DONE
[17:42:26.123] run() for ‘Future’ ...
[17:42:26.124] - state: ‘created’
[17:42:26.124] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:26.128] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:26.128] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:26.128]   - Field: ‘label’
[17:42:26.128]   - Field: ‘local’
[17:42:26.128]   - Field: ‘owner’
[17:42:26.129]   - Field: ‘envir’
[17:42:26.129]   - Field: ‘workers’
[17:42:26.129]   - Field: ‘packages’
[17:42:26.129]   - Field: ‘gc’
[17:42:26.129]   - Field: ‘job’
[17:42:26.129]   - Field: ‘conditions’
[17:42:26.129]   - Field: ‘expr’
[17:42:26.129]   - Field: ‘uuid’
[17:42:26.129]   - Field: ‘seed’
[17:42:26.130]   - Field: ‘version’
[17:42:26.130]   - Field: ‘result’
[17:42:26.130]   - Field: ‘asynchronous’
[17:42:26.130]   - Field: ‘calls’
[17:42:26.130]   - Field: ‘globals’
[17:42:26.130]   - Field: ‘stdout’
[17:42:26.130]   - Field: ‘earlySignal’
[17:42:26.130]   - Field: ‘lazy’
[17:42:26.130]   - Field: ‘state’
[17:42:26.131] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:26.131] - Launch lazy future ...
[17:42:26.131] Packages needed by the future expression (n = 1): ‘stats’
[17:42:26.131] Packages needed by future strategies (n = 0): <none>
[17:42:26.132] {
[17:42:26.132]     {
[17:42:26.132]         {
[17:42:26.132]             ...future.startTime <- base::Sys.time()
[17:42:26.132]             {
[17:42:26.132]                 {
[17:42:26.132]                   {
[17:42:26.132]                     {
[17:42:26.132]                       {
[17:42:26.132]                         base::local({
[17:42:26.132]                           has_future <- base::requireNamespace("future", 
[17:42:26.132]                             quietly = TRUE)
[17:42:26.132]                           if (has_future) {
[17:42:26.132]                             ns <- base::getNamespace("future")
[17:42:26.132]                             version <- ns[[".package"]][["version"]]
[17:42:26.132]                             if (is.null(version)) 
[17:42:26.132]                               version <- utils::packageVersion("future")
[17:42:26.132]                           }
[17:42:26.132]                           else {
[17:42:26.132]                             version <- NULL
[17:42:26.132]                           }
[17:42:26.132]                           if (!has_future || version < "1.8.0") {
[17:42:26.132]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:26.132]                               "", base::R.version$version.string), 
[17:42:26.132]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:26.132]                                 base::R.version$platform, 8 * 
[17:42:26.132]                                   base::.Machine$sizeof.pointer), 
[17:42:26.132]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:26.132]                                 "release", "version")], collapse = " "), 
[17:42:26.132]                               hostname = base::Sys.info()[["nodename"]])
[17:42:26.132]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:26.132]                               info)
[17:42:26.132]                             info <- base::paste(info, collapse = "; ")
[17:42:26.132]                             if (!has_future) {
[17:42:26.132]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:26.132]                                 info)
[17:42:26.132]                             }
[17:42:26.132]                             else {
[17:42:26.132]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:26.132]                                 info, version)
[17:42:26.132]                             }
[17:42:26.132]                             base::stop(msg)
[17:42:26.132]                           }
[17:42:26.132]                         })
[17:42:26.132]                       }
[17:42:26.132]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:26.132]                       base::options(mc.cores = 1L)
[17:42:26.132]                     }
[17:42:26.132]                     base::local({
[17:42:26.132]                       for (pkg in "stats") {
[17:42:26.132]                         base::loadNamespace(pkg)
[17:42:26.132]                         base::library(pkg, character.only = TRUE)
[17:42:26.132]                       }
[17:42:26.132]                     })
[17:42:26.132]                   }
[17:42:26.132]                   options(future.plan = NULL)
[17:42:26.132]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:26.132]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:26.132]                 }
[17:42:26.132]                 ...future.workdir <- getwd()
[17:42:26.132]             }
[17:42:26.132]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:26.132]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:26.132]         }
[17:42:26.132]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:26.132]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:26.132]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:26.132]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:26.132]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:26.132]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:26.132]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:26.132]             base::names(...future.oldOptions))
[17:42:26.132]     }
[17:42:26.132]     if (FALSE) {
[17:42:26.132]     }
[17:42:26.132]     else {
[17:42:26.132]         if (TRUE) {
[17:42:26.132]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:26.132]                 open = "w")
[17:42:26.132]         }
[17:42:26.132]         else {
[17:42:26.132]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:26.132]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:26.132]         }
[17:42:26.132]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:26.132]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:26.132]             base::sink(type = "output", split = FALSE)
[17:42:26.132]             base::close(...future.stdout)
[17:42:26.132]         }, add = TRUE)
[17:42:26.132]     }
[17:42:26.132]     ...future.frame <- base::sys.nframe()
[17:42:26.132]     ...future.conditions <- base::list()
[17:42:26.132]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:26.132]     if (FALSE) {
[17:42:26.132]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:26.132]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:26.132]     }
[17:42:26.132]     ...future.result <- base::tryCatch({
[17:42:26.132]         base::withCallingHandlers({
[17:42:26.132]             ...future.value <- base::withVisible(base::local({
[17:42:26.132]                 withCallingHandlers({
[17:42:26.132]                   {
[17:42:26.132]                     lm(weight ~ group - 1)
[17:42:26.132]                   }
[17:42:26.132]                 }, immediateCondition = function(cond) {
[17:42:26.132]                   save_rds <- function (object, pathname, ...) 
[17:42:26.132]                   {
[17:42:26.132]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:26.132]                     if (file_test("-f", pathname_tmp)) {
[17:42:26.132]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.132]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:26.132]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.132]                         fi_tmp[["mtime"]])
[17:42:26.132]                     }
[17:42:26.132]                     tryCatch({
[17:42:26.132]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:26.132]                     }, error = function(ex) {
[17:42:26.132]                       msg <- conditionMessage(ex)
[17:42:26.132]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.132]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:26.132]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.132]                         fi_tmp[["mtime"]], msg)
[17:42:26.132]                       ex$message <- msg
[17:42:26.132]                       stop(ex)
[17:42:26.132]                     })
[17:42:26.132]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:26.132]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:26.132]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:26.132]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.132]                       fi <- file.info(pathname)
[17:42:26.132]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:26.132]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.132]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:26.132]                         fi[["size"]], fi[["mtime"]])
[17:42:26.132]                       stop(msg)
[17:42:26.132]                     }
[17:42:26.132]                     invisible(pathname)
[17:42:26.132]                   }
[17:42:26.132]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:26.132]                     rootPath = tempdir()) 
[17:42:26.132]                   {
[17:42:26.132]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:26.132]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:26.132]                       tmpdir = path, fileext = ".rds")
[17:42:26.132]                     save_rds(obj, file)
[17:42:26.132]                   }
[17:42:26.132]                   saveImmediateCondition(cond, path = "/tmp/RtmpNwFxwa/.future/immediateConditions")
[17:42:26.132]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.132]                   {
[17:42:26.132]                     inherits <- base::inherits
[17:42:26.132]                     invokeRestart <- base::invokeRestart
[17:42:26.132]                     is.null <- base::is.null
[17:42:26.132]                     muffled <- FALSE
[17:42:26.132]                     if (inherits(cond, "message")) {
[17:42:26.132]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:26.132]                       if (muffled) 
[17:42:26.132]                         invokeRestart("muffleMessage")
[17:42:26.132]                     }
[17:42:26.132]                     else if (inherits(cond, "warning")) {
[17:42:26.132]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:26.132]                       if (muffled) 
[17:42:26.132]                         invokeRestart("muffleWarning")
[17:42:26.132]                     }
[17:42:26.132]                     else if (inherits(cond, "condition")) {
[17:42:26.132]                       if (!is.null(pattern)) {
[17:42:26.132]                         computeRestarts <- base::computeRestarts
[17:42:26.132]                         grepl <- base::grepl
[17:42:26.132]                         restarts <- computeRestarts(cond)
[17:42:26.132]                         for (restart in restarts) {
[17:42:26.132]                           name <- restart$name
[17:42:26.132]                           if (is.null(name)) 
[17:42:26.132]                             next
[17:42:26.132]                           if (!grepl(pattern, name)) 
[17:42:26.132]                             next
[17:42:26.132]                           invokeRestart(restart)
[17:42:26.132]                           muffled <- TRUE
[17:42:26.132]                           break
[17:42:26.132]                         }
[17:42:26.132]                       }
[17:42:26.132]                     }
[17:42:26.132]                     invisible(muffled)
[17:42:26.132]                   }
[17:42:26.132]                   muffleCondition(cond)
[17:42:26.132]                 })
[17:42:26.132]             }))
[17:42:26.132]             future::FutureResult(value = ...future.value$value, 
[17:42:26.132]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:26.132]                   ...future.rng), globalenv = if (FALSE) 
[17:42:26.132]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:26.132]                     ...future.globalenv.names))
[17:42:26.132]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:26.132]         }, condition = base::local({
[17:42:26.132]             c <- base::c
[17:42:26.132]             inherits <- base::inherits
[17:42:26.132]             invokeRestart <- base::invokeRestart
[17:42:26.132]             length <- base::length
[17:42:26.132]             list <- base::list
[17:42:26.132]             seq.int <- base::seq.int
[17:42:26.132]             signalCondition <- base::signalCondition
[17:42:26.132]             sys.calls <- base::sys.calls
[17:42:26.132]             `[[` <- base::`[[`
[17:42:26.132]             `+` <- base::`+`
[17:42:26.132]             `<<-` <- base::`<<-`
[17:42:26.132]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:26.132]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:26.132]                   3L)]
[17:42:26.132]             }
[17:42:26.132]             function(cond) {
[17:42:26.132]                 is_error <- inherits(cond, "error")
[17:42:26.132]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:26.132]                   NULL)
[17:42:26.132]                 if (is_error) {
[17:42:26.132]                   sessionInformation <- function() {
[17:42:26.132]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:26.132]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:26.132]                       search = base::search(), system = base::Sys.info())
[17:42:26.132]                   }
[17:42:26.132]                   ...future.conditions[[length(...future.conditions) + 
[17:42:26.132]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:26.132]                     cond$call), session = sessionInformation(), 
[17:42:26.132]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:26.132]                   signalCondition(cond)
[17:42:26.132]                 }
[17:42:26.132]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:26.132]                 "immediateCondition"))) {
[17:42:26.132]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:26.132]                   ...future.conditions[[length(...future.conditions) + 
[17:42:26.132]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:26.132]                   if (TRUE && !signal) {
[17:42:26.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.132]                     {
[17:42:26.132]                       inherits <- base::inherits
[17:42:26.132]                       invokeRestart <- base::invokeRestart
[17:42:26.132]                       is.null <- base::is.null
[17:42:26.132]                       muffled <- FALSE
[17:42:26.132]                       if (inherits(cond, "message")) {
[17:42:26.132]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:26.132]                         if (muffled) 
[17:42:26.132]                           invokeRestart("muffleMessage")
[17:42:26.132]                       }
[17:42:26.132]                       else if (inherits(cond, "warning")) {
[17:42:26.132]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:26.132]                         if (muffled) 
[17:42:26.132]                           invokeRestart("muffleWarning")
[17:42:26.132]                       }
[17:42:26.132]                       else if (inherits(cond, "condition")) {
[17:42:26.132]                         if (!is.null(pattern)) {
[17:42:26.132]                           computeRestarts <- base::computeRestarts
[17:42:26.132]                           grepl <- base::grepl
[17:42:26.132]                           restarts <- computeRestarts(cond)
[17:42:26.132]                           for (restart in restarts) {
[17:42:26.132]                             name <- restart$name
[17:42:26.132]                             if (is.null(name)) 
[17:42:26.132]                               next
[17:42:26.132]                             if (!grepl(pattern, name)) 
[17:42:26.132]                               next
[17:42:26.132]                             invokeRestart(restart)
[17:42:26.132]                             muffled <- TRUE
[17:42:26.132]                             break
[17:42:26.132]                           }
[17:42:26.132]                         }
[17:42:26.132]                       }
[17:42:26.132]                       invisible(muffled)
[17:42:26.132]                     }
[17:42:26.132]                     muffleCondition(cond, pattern = "^muffle")
[17:42:26.132]                   }
[17:42:26.132]                 }
[17:42:26.132]                 else {
[17:42:26.132]                   if (TRUE) {
[17:42:26.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.132]                     {
[17:42:26.132]                       inherits <- base::inherits
[17:42:26.132]                       invokeRestart <- base::invokeRestart
[17:42:26.132]                       is.null <- base::is.null
[17:42:26.132]                       muffled <- FALSE
[17:42:26.132]                       if (inherits(cond, "message")) {
[17:42:26.132]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:26.132]                         if (muffled) 
[17:42:26.132]                           invokeRestart("muffleMessage")
[17:42:26.132]                       }
[17:42:26.132]                       else if (inherits(cond, "warning")) {
[17:42:26.132]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:26.132]                         if (muffled) 
[17:42:26.132]                           invokeRestart("muffleWarning")
[17:42:26.132]                       }
[17:42:26.132]                       else if (inherits(cond, "condition")) {
[17:42:26.132]                         if (!is.null(pattern)) {
[17:42:26.132]                           computeRestarts <- base::computeRestarts
[17:42:26.132]                           grepl <- base::grepl
[17:42:26.132]                           restarts <- computeRestarts(cond)
[17:42:26.132]                           for (restart in restarts) {
[17:42:26.132]                             name <- restart$name
[17:42:26.132]                             if (is.null(name)) 
[17:42:26.132]                               next
[17:42:26.132]                             if (!grepl(pattern, name)) 
[17:42:26.132]                               next
[17:42:26.132]                             invokeRestart(restart)
[17:42:26.132]                             muffled <- TRUE
[17:42:26.132]                             break
[17:42:26.132]                           }
[17:42:26.132]                         }
[17:42:26.132]                       }
[17:42:26.132]                       invisible(muffled)
[17:42:26.132]                     }
[17:42:26.132]                     muffleCondition(cond, pattern = "^muffle")
[17:42:26.132]                   }
[17:42:26.132]                 }
[17:42:26.132]             }
[17:42:26.132]         }))
[17:42:26.132]     }, error = function(ex) {
[17:42:26.132]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:26.132]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:26.132]                 ...future.rng), started = ...future.startTime, 
[17:42:26.132]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:26.132]             version = "1.8"), class = "FutureResult")
[17:42:26.132]     }, finally = {
[17:42:26.132]         if (!identical(...future.workdir, getwd())) 
[17:42:26.132]             setwd(...future.workdir)
[17:42:26.132]         {
[17:42:26.132]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:26.132]                 ...future.oldOptions$nwarnings <- NULL
[17:42:26.132]             }
[17:42:26.132]             base::options(...future.oldOptions)
[17:42:26.132]             if (.Platform$OS.type == "windows") {
[17:42:26.132]                 old_names <- names(...future.oldEnvVars)
[17:42:26.132]                 envs <- base::Sys.getenv()
[17:42:26.132]                 names <- names(envs)
[17:42:26.132]                 common <- intersect(names, old_names)
[17:42:26.132]                 added <- setdiff(names, old_names)
[17:42:26.132]                 removed <- setdiff(old_names, names)
[17:42:26.132]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:26.132]                   envs[common]]
[17:42:26.132]                 NAMES <- toupper(changed)
[17:42:26.132]                 args <- list()
[17:42:26.132]                 for (kk in seq_along(NAMES)) {
[17:42:26.132]                   name <- changed[[kk]]
[17:42:26.132]                   NAME <- NAMES[[kk]]
[17:42:26.132]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.132]                     next
[17:42:26.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:26.132]                 }
[17:42:26.132]                 NAMES <- toupper(added)
[17:42:26.132]                 for (kk in seq_along(NAMES)) {
[17:42:26.132]                   name <- added[[kk]]
[17:42:26.132]                   NAME <- NAMES[[kk]]
[17:42:26.132]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.132]                     next
[17:42:26.132]                   args[[name]] <- ""
[17:42:26.132]                 }
[17:42:26.132]                 NAMES <- toupper(removed)
[17:42:26.132]                 for (kk in seq_along(NAMES)) {
[17:42:26.132]                   name <- removed[[kk]]
[17:42:26.132]                   NAME <- NAMES[[kk]]
[17:42:26.132]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.132]                     next
[17:42:26.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:26.132]                 }
[17:42:26.132]                 if (length(args) > 0) 
[17:42:26.132]                   base::do.call(base::Sys.setenv, args = args)
[17:42:26.132]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:26.132]             }
[17:42:26.132]             else {
[17:42:26.132]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:26.132]             }
[17:42:26.132]             {
[17:42:26.132]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:26.132]                   0L) {
[17:42:26.132]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:26.132]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:26.132]                   base::options(opts)
[17:42:26.132]                 }
[17:42:26.132]                 {
[17:42:26.132]                   {
[17:42:26.132]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:26.132]                     NULL
[17:42:26.132]                   }
[17:42:26.132]                   options(future.plan = NULL)
[17:42:26.132]                   if (is.na(NA_character_)) 
[17:42:26.132]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:26.132]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:26.132]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:26.132]                     envir = parent.frame()) 
[17:42:26.132]                   {
[17:42:26.132]                     default_workers <- missing(workers)
[17:42:26.132]                     if (is.function(workers)) 
[17:42:26.132]                       workers <- workers()
[17:42:26.132]                     workers <- structure(as.integer(workers), 
[17:42:26.132]                       class = class(workers))
[17:42:26.132]                     stop_if_not(is.finite(workers), workers >= 
[17:42:26.132]                       1L)
[17:42:26.132]                     if ((workers == 1L && !inherits(workers, 
[17:42:26.132]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:26.132]                       if (default_workers) 
[17:42:26.132]                         supportsMulticore(warn = TRUE)
[17:42:26.132]                       return(sequential(..., envir = envir))
[17:42:26.132]                     }
[17:42:26.132]                     oopts <- options(mc.cores = workers)
[17:42:26.132]                     on.exit(options(oopts))
[17:42:26.132]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:26.132]                       envir = envir)
[17:42:26.132]                     if (!future$lazy) 
[17:42:26.132]                       future <- run(future)
[17:42:26.132]                     invisible(future)
[17:42:26.132]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:26.132]                 }
[17:42:26.132]             }
[17:42:26.132]         }
[17:42:26.132]     })
[17:42:26.132]     if (TRUE) {
[17:42:26.132]         base::sink(type = "output", split = FALSE)
[17:42:26.132]         if (TRUE) {
[17:42:26.132]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:26.132]         }
[17:42:26.132]         else {
[17:42:26.132]             ...future.result["stdout"] <- base::list(NULL)
[17:42:26.132]         }
[17:42:26.132]         base::close(...future.stdout)
[17:42:26.132]         ...future.stdout <- NULL
[17:42:26.132]     }
[17:42:26.132]     ...future.result$conditions <- ...future.conditions
[17:42:26.132]     ...future.result$finished <- base::Sys.time()
[17:42:26.132]     ...future.result
[17:42:26.132] }
[17:42:26.135] assign_globals() ...
[17:42:26.135] List of 2
[17:42:26.135]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[17:42:26.135]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[17:42:26.135]  - attr(*, "where")=List of 2
[17:42:26.135]   ..$ weight:<environment: R_EmptyEnv> 
[17:42:26.135]   ..$ group :<environment: R_EmptyEnv> 
[17:42:26.135]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:26.135]  - attr(*, "resolved")= logi FALSE
[17:42:26.135]  - attr(*, "total_size")= num 896
[17:42:26.135]  - attr(*, "already-done")= logi TRUE
[17:42:26.142] - copied ‘weight’ to environment
[17:42:26.142] - copied ‘group’ to environment
[17:42:26.142] assign_globals() ... done
[17:42:26.142] requestCore(): workers = 2
[17:42:26.144] MulticoreFuture started
[17:42:26.145] - Launch lazy future ... done
[17:42:26.145] run() for ‘MulticoreFuture’ ... done
[17:42:26.146] plan(): Setting new future strategy stack:
[17:42:26.146] List of future strategies:
[17:42:26.146] 1. sequential:
[17:42:26.146]    - args: function (..., envir = parent.frame())
[17:42:26.146]    - tweaked: FALSE
[17:42:26.146]    - call: NULL
[17:42:26.147] plan(): nbrOfWorkers() = 1
[17:42:26.151] plan(): Setting new future strategy stack:
[17:42:26.151] List of future strategies:
[17:42:26.151] 1. multicore:
[17:42:26.151]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:26.151]    - tweaked: FALSE
[17:42:26.151]    - call: plan(strategy)
[17:42:26.156] plan(): nbrOfWorkers() = 2

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[17:42:26.161] getGlobalsAndPackages() ...
[17:42:26.161] Searching for globals...
[17:42:26.163] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:42:26.164] Searching for globals ... DONE
[17:42:26.164] Resolving globals: FALSE
[17:42:26.164] The total size of the 2 globals is 896 bytes (896 bytes)
[17:42:26.165] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:42:26.165] - globals: [2] ‘weight’, ‘group’
[17:42:26.165] - packages: [1] ‘stats’
[17:42:26.165] getGlobalsAndPackages() ... DONE
[17:42:26.166] run() for ‘Future’ ...
[17:42:26.166] - state: ‘created’
[17:42:26.166] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:26.171] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:26.171] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:26.171]   - Field: ‘label’
[17:42:26.171]   - Field: ‘local’
[17:42:26.172]   - Field: ‘owner’
[17:42:26.172]   - Field: ‘envir’
[17:42:26.172]   - Field: ‘workers’
[17:42:26.172]   - Field: ‘packages’
[17:42:26.172]   - Field: ‘gc’
[17:42:26.172]   - Field: ‘job’
[17:42:26.172]   - Field: ‘conditions’
[17:42:26.172]   - Field: ‘expr’
[17:42:26.173]   - Field: ‘uuid’
[17:42:26.173]   - Field: ‘seed’
[17:42:26.173]   - Field: ‘version’
[17:42:26.173]   - Field: ‘result’
[17:42:26.173]   - Field: ‘asynchronous’
[17:42:26.173]   - Field: ‘calls’
[17:42:26.173]   - Field: ‘globals’
[17:42:26.173]   - Field: ‘stdout’
[17:42:26.173]   - Field: ‘earlySignal’
[17:42:26.174]   - Field: ‘lazy’
[17:42:26.174]   - Field: ‘state’
[17:42:26.174] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:26.174] - Launch lazy future ...
[17:42:26.174] Packages needed by the future expression (n = 1): ‘stats’
[17:42:26.174] Packages needed by future strategies (n = 0): <none>
[17:42:26.175] {
[17:42:26.175]     {
[17:42:26.175]         {
[17:42:26.175]             ...future.startTime <- base::Sys.time()
[17:42:26.175]             {
[17:42:26.175]                 {
[17:42:26.175]                   {
[17:42:26.175]                     {
[17:42:26.175]                       {
[17:42:26.175]                         base::local({
[17:42:26.175]                           has_future <- base::requireNamespace("future", 
[17:42:26.175]                             quietly = TRUE)
[17:42:26.175]                           if (has_future) {
[17:42:26.175]                             ns <- base::getNamespace("future")
[17:42:26.175]                             version <- ns[[".package"]][["version"]]
[17:42:26.175]                             if (is.null(version)) 
[17:42:26.175]                               version <- utils::packageVersion("future")
[17:42:26.175]                           }
[17:42:26.175]                           else {
[17:42:26.175]                             version <- NULL
[17:42:26.175]                           }
[17:42:26.175]                           if (!has_future || version < "1.8.0") {
[17:42:26.175]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:26.175]                               "", base::R.version$version.string), 
[17:42:26.175]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:26.175]                                 base::R.version$platform, 8 * 
[17:42:26.175]                                   base::.Machine$sizeof.pointer), 
[17:42:26.175]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:26.175]                                 "release", "version")], collapse = " "), 
[17:42:26.175]                               hostname = base::Sys.info()[["nodename"]])
[17:42:26.175]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:26.175]                               info)
[17:42:26.175]                             info <- base::paste(info, collapse = "; ")
[17:42:26.175]                             if (!has_future) {
[17:42:26.175]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:26.175]                                 info)
[17:42:26.175]                             }
[17:42:26.175]                             else {
[17:42:26.175]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:26.175]                                 info, version)
[17:42:26.175]                             }
[17:42:26.175]                             base::stop(msg)
[17:42:26.175]                           }
[17:42:26.175]                         })
[17:42:26.175]                       }
[17:42:26.175]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:26.175]                       base::options(mc.cores = 1L)
[17:42:26.175]                     }
[17:42:26.175]                     base::local({
[17:42:26.175]                       for (pkg in "stats") {
[17:42:26.175]                         base::loadNamespace(pkg)
[17:42:26.175]                         base::library(pkg, character.only = TRUE)
[17:42:26.175]                       }
[17:42:26.175]                     })
[17:42:26.175]                   }
[17:42:26.175]                   options(future.plan = NULL)
[17:42:26.175]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:26.175]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:26.175]                 }
[17:42:26.175]                 ...future.workdir <- getwd()
[17:42:26.175]             }
[17:42:26.175]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:26.175]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:26.175]         }
[17:42:26.175]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:26.175]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:26.175]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:26.175]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:26.175]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:26.175]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:26.175]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:26.175]             base::names(...future.oldOptions))
[17:42:26.175]     }
[17:42:26.175]     if (FALSE) {
[17:42:26.175]     }
[17:42:26.175]     else {
[17:42:26.175]         if (TRUE) {
[17:42:26.175]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:26.175]                 open = "w")
[17:42:26.175]         }
[17:42:26.175]         else {
[17:42:26.175]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:26.175]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:26.175]         }
[17:42:26.175]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:26.175]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:26.175]             base::sink(type = "output", split = FALSE)
[17:42:26.175]             base::close(...future.stdout)
[17:42:26.175]         }, add = TRUE)
[17:42:26.175]     }
[17:42:26.175]     ...future.frame <- base::sys.nframe()
[17:42:26.175]     ...future.conditions <- base::list()
[17:42:26.175]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:26.175]     if (FALSE) {
[17:42:26.175]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:26.175]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:26.175]     }
[17:42:26.175]     ...future.result <- base::tryCatch({
[17:42:26.175]         base::withCallingHandlers({
[17:42:26.175]             ...future.value <- base::withVisible(base::local({
[17:42:26.175]                 withCallingHandlers({
[17:42:26.175]                   {
[17:42:26.175]                     lm(weight ~ group - 1)
[17:42:26.175]                   }
[17:42:26.175]                 }, immediateCondition = function(cond) {
[17:42:26.175]                   save_rds <- function (object, pathname, ...) 
[17:42:26.175]                   {
[17:42:26.175]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:26.175]                     if (file_test("-f", pathname_tmp)) {
[17:42:26.175]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.175]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:26.175]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.175]                         fi_tmp[["mtime"]])
[17:42:26.175]                     }
[17:42:26.175]                     tryCatch({
[17:42:26.175]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:26.175]                     }, error = function(ex) {
[17:42:26.175]                       msg <- conditionMessage(ex)
[17:42:26.175]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.175]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:26.175]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.175]                         fi_tmp[["mtime"]], msg)
[17:42:26.175]                       ex$message <- msg
[17:42:26.175]                       stop(ex)
[17:42:26.175]                     })
[17:42:26.175]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:26.175]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:26.175]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:26.175]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.175]                       fi <- file.info(pathname)
[17:42:26.175]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:26.175]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.175]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:26.175]                         fi[["size"]], fi[["mtime"]])
[17:42:26.175]                       stop(msg)
[17:42:26.175]                     }
[17:42:26.175]                     invisible(pathname)
[17:42:26.175]                   }
[17:42:26.175]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:26.175]                     rootPath = tempdir()) 
[17:42:26.175]                   {
[17:42:26.175]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:26.175]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:26.175]                       tmpdir = path, fileext = ".rds")
[17:42:26.175]                     save_rds(obj, file)
[17:42:26.175]                   }
[17:42:26.175]                   saveImmediateCondition(cond, path = "/tmp/RtmpNwFxwa/.future/immediateConditions")
[17:42:26.175]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.175]                   {
[17:42:26.175]                     inherits <- base::inherits
[17:42:26.175]                     invokeRestart <- base::invokeRestart
[17:42:26.175]                     is.null <- base::is.null
[17:42:26.175]                     muffled <- FALSE
[17:42:26.175]                     if (inherits(cond, "message")) {
[17:42:26.175]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:26.175]                       if (muffled) 
[17:42:26.175]                         invokeRestart("muffleMessage")
[17:42:26.175]                     }
[17:42:26.175]                     else if (inherits(cond, "warning")) {
[17:42:26.175]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:26.175]                       if (muffled) 
[17:42:26.175]                         invokeRestart("muffleWarning")
[17:42:26.175]                     }
[17:42:26.175]                     else if (inherits(cond, "condition")) {
[17:42:26.175]                       if (!is.null(pattern)) {
[17:42:26.175]                         computeRestarts <- base::computeRestarts
[17:42:26.175]                         grepl <- base::grepl
[17:42:26.175]                         restarts <- computeRestarts(cond)
[17:42:26.175]                         for (restart in restarts) {
[17:42:26.175]                           name <- restart$name
[17:42:26.175]                           if (is.null(name)) 
[17:42:26.175]                             next
[17:42:26.175]                           if (!grepl(pattern, name)) 
[17:42:26.175]                             next
[17:42:26.175]                           invokeRestart(restart)
[17:42:26.175]                           muffled <- TRUE
[17:42:26.175]                           break
[17:42:26.175]                         }
[17:42:26.175]                       }
[17:42:26.175]                     }
[17:42:26.175]                     invisible(muffled)
[17:42:26.175]                   }
[17:42:26.175]                   muffleCondition(cond)
[17:42:26.175]                 })
[17:42:26.175]             }))
[17:42:26.175]             future::FutureResult(value = ...future.value$value, 
[17:42:26.175]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:26.175]                   ...future.rng), globalenv = if (FALSE) 
[17:42:26.175]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:26.175]                     ...future.globalenv.names))
[17:42:26.175]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:26.175]         }, condition = base::local({
[17:42:26.175]             c <- base::c
[17:42:26.175]             inherits <- base::inherits
[17:42:26.175]             invokeRestart <- base::invokeRestart
[17:42:26.175]             length <- base::length
[17:42:26.175]             list <- base::list
[17:42:26.175]             seq.int <- base::seq.int
[17:42:26.175]             signalCondition <- base::signalCondition
[17:42:26.175]             sys.calls <- base::sys.calls
[17:42:26.175]             `[[` <- base::`[[`
[17:42:26.175]             `+` <- base::`+`
[17:42:26.175]             `<<-` <- base::`<<-`
[17:42:26.175]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:26.175]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:26.175]                   3L)]
[17:42:26.175]             }
[17:42:26.175]             function(cond) {
[17:42:26.175]                 is_error <- inherits(cond, "error")
[17:42:26.175]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:26.175]                   NULL)
[17:42:26.175]                 if (is_error) {
[17:42:26.175]                   sessionInformation <- function() {
[17:42:26.175]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:26.175]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:26.175]                       search = base::search(), system = base::Sys.info())
[17:42:26.175]                   }
[17:42:26.175]                   ...future.conditions[[length(...future.conditions) + 
[17:42:26.175]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:26.175]                     cond$call), session = sessionInformation(), 
[17:42:26.175]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:26.175]                   signalCondition(cond)
[17:42:26.175]                 }
[17:42:26.175]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:26.175]                 "immediateCondition"))) {
[17:42:26.175]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:26.175]                   ...future.conditions[[length(...future.conditions) + 
[17:42:26.175]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:26.175]                   if (TRUE && !signal) {
[17:42:26.175]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.175]                     {
[17:42:26.175]                       inherits <- base::inherits
[17:42:26.175]                       invokeRestart <- base::invokeRestart
[17:42:26.175]                       is.null <- base::is.null
[17:42:26.175]                       muffled <- FALSE
[17:42:26.175]                       if (inherits(cond, "message")) {
[17:42:26.175]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:26.175]                         if (muffled) 
[17:42:26.175]                           invokeRestart("muffleMessage")
[17:42:26.175]                       }
[17:42:26.175]                       else if (inherits(cond, "warning")) {
[17:42:26.175]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:26.175]                         if (muffled) 
[17:42:26.175]                           invokeRestart("muffleWarning")
[17:42:26.175]                       }
[17:42:26.175]                       else if (inherits(cond, "condition")) {
[17:42:26.175]                         if (!is.null(pattern)) {
[17:42:26.175]                           computeRestarts <- base::computeRestarts
[17:42:26.175]                           grepl <- base::grepl
[17:42:26.175]                           restarts <- computeRestarts(cond)
[17:42:26.175]                           for (restart in restarts) {
[17:42:26.175]                             name <- restart$name
[17:42:26.175]                             if (is.null(name)) 
[17:42:26.175]                               next
[17:42:26.175]                             if (!grepl(pattern, name)) 
[17:42:26.175]                               next
[17:42:26.175]                             invokeRestart(restart)
[17:42:26.175]                             muffled <- TRUE
[17:42:26.175]                             break
[17:42:26.175]                           }
[17:42:26.175]                         }
[17:42:26.175]                       }
[17:42:26.175]                       invisible(muffled)
[17:42:26.175]                     }
[17:42:26.175]                     muffleCondition(cond, pattern = "^muffle")
[17:42:26.175]                   }
[17:42:26.175]                 }
[17:42:26.175]                 else {
[17:42:26.175]                   if (TRUE) {
[17:42:26.175]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.175]                     {
[17:42:26.175]                       inherits <- base::inherits
[17:42:26.175]                       invokeRestart <- base::invokeRestart
[17:42:26.175]                       is.null <- base::is.null
[17:42:26.175]                       muffled <- FALSE
[17:42:26.175]                       if (inherits(cond, "message")) {
[17:42:26.175]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:26.175]                         if (muffled) 
[17:42:26.175]                           invokeRestart("muffleMessage")
[17:42:26.175]                       }
[17:42:26.175]                       else if (inherits(cond, "warning")) {
[17:42:26.175]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:26.175]                         if (muffled) 
[17:42:26.175]                           invokeRestart("muffleWarning")
[17:42:26.175]                       }
[17:42:26.175]                       else if (inherits(cond, "condition")) {
[17:42:26.175]                         if (!is.null(pattern)) {
[17:42:26.175]                           computeRestarts <- base::computeRestarts
[17:42:26.175]                           grepl <- base::grepl
[17:42:26.175]                           restarts <- computeRestarts(cond)
[17:42:26.175]                           for (restart in restarts) {
[17:42:26.175]                             name <- restart$name
[17:42:26.175]                             if (is.null(name)) 
[17:42:26.175]                               next
[17:42:26.175]                             if (!grepl(pattern, name)) 
[17:42:26.175]                               next
[17:42:26.175]                             invokeRestart(restart)
[17:42:26.175]                             muffled <- TRUE
[17:42:26.175]                             break
[17:42:26.175]                           }
[17:42:26.175]                         }
[17:42:26.175]                       }
[17:42:26.175]                       invisible(muffled)
[17:42:26.175]                     }
[17:42:26.175]                     muffleCondition(cond, pattern = "^muffle")
[17:42:26.175]                   }
[17:42:26.175]                 }
[17:42:26.175]             }
[17:42:26.175]         }))
[17:42:26.175]     }, error = function(ex) {
[17:42:26.175]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:26.175]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:26.175]                 ...future.rng), started = ...future.startTime, 
[17:42:26.175]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:26.175]             version = "1.8"), class = "FutureResult")
[17:42:26.175]     }, finally = {
[17:42:26.175]         if (!identical(...future.workdir, getwd())) 
[17:42:26.175]             setwd(...future.workdir)
[17:42:26.175]         {
[17:42:26.175]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:26.175]                 ...future.oldOptions$nwarnings <- NULL
[17:42:26.175]             }
[17:42:26.175]             base::options(...future.oldOptions)
[17:42:26.175]             if (.Platform$OS.type == "windows") {
[17:42:26.175]                 old_names <- names(...future.oldEnvVars)
[17:42:26.175]                 envs <- base::Sys.getenv()
[17:42:26.175]                 names <- names(envs)
[17:42:26.175]                 common <- intersect(names, old_names)
[17:42:26.175]                 added <- setdiff(names, old_names)
[17:42:26.175]                 removed <- setdiff(old_names, names)
[17:42:26.175]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:26.175]                   envs[common]]
[17:42:26.175]                 NAMES <- toupper(changed)
[17:42:26.175]                 args <- list()
[17:42:26.175]                 for (kk in seq_along(NAMES)) {
[17:42:26.175]                   name <- changed[[kk]]
[17:42:26.175]                   NAME <- NAMES[[kk]]
[17:42:26.175]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.175]                     next
[17:42:26.175]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:26.175]                 }
[17:42:26.175]                 NAMES <- toupper(added)
[17:42:26.175]                 for (kk in seq_along(NAMES)) {
[17:42:26.175]                   name <- added[[kk]]
[17:42:26.175]                   NAME <- NAMES[[kk]]
[17:42:26.175]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.175]                     next
[17:42:26.175]                   args[[name]] <- ""
[17:42:26.175]                 }
[17:42:26.175]                 NAMES <- toupper(removed)
[17:42:26.175]                 for (kk in seq_along(NAMES)) {
[17:42:26.175]                   name <- removed[[kk]]
[17:42:26.175]                   NAME <- NAMES[[kk]]
[17:42:26.175]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.175]                     next
[17:42:26.175]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:26.175]                 }
[17:42:26.175]                 if (length(args) > 0) 
[17:42:26.175]                   base::do.call(base::Sys.setenv, args = args)
[17:42:26.175]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:26.175]             }
[17:42:26.175]             else {
[17:42:26.175]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:26.175]             }
[17:42:26.175]             {
[17:42:26.175]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:26.175]                   0L) {
[17:42:26.175]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:26.175]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:26.175]                   base::options(opts)
[17:42:26.175]                 }
[17:42:26.175]                 {
[17:42:26.175]                   {
[17:42:26.175]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:26.175]                     NULL
[17:42:26.175]                   }
[17:42:26.175]                   options(future.plan = NULL)
[17:42:26.175]                   if (is.na(NA_character_)) 
[17:42:26.175]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:26.175]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:26.175]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:26.175]                     envir = parent.frame()) 
[17:42:26.175]                   {
[17:42:26.175]                     default_workers <- missing(workers)
[17:42:26.175]                     if (is.function(workers)) 
[17:42:26.175]                       workers <- workers()
[17:42:26.175]                     workers <- structure(as.integer(workers), 
[17:42:26.175]                       class = class(workers))
[17:42:26.175]                     stop_if_not(is.finite(workers), workers >= 
[17:42:26.175]                       1L)
[17:42:26.175]                     if ((workers == 1L && !inherits(workers, 
[17:42:26.175]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:26.175]                       if (default_workers) 
[17:42:26.175]                         supportsMulticore(warn = TRUE)
[17:42:26.175]                       return(sequential(..., envir = envir))
[17:42:26.175]                     }
[17:42:26.175]                     oopts <- options(mc.cores = workers)
[17:42:26.175]                     on.exit(options(oopts))
[17:42:26.175]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:26.175]                       envir = envir)
[17:42:26.175]                     if (!future$lazy) 
[17:42:26.175]                       future <- run(future)
[17:42:26.175]                     invisible(future)
[17:42:26.175]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:26.175]                 }
[17:42:26.175]             }
[17:42:26.175]         }
[17:42:26.175]     })
[17:42:26.175]     if (TRUE) {
[17:42:26.175]         base::sink(type = "output", split = FALSE)
[17:42:26.175]         if (TRUE) {
[17:42:26.175]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:26.175]         }
[17:42:26.175]         else {
[17:42:26.175]             ...future.result["stdout"] <- base::list(NULL)
[17:42:26.175]         }
[17:42:26.175]         base::close(...future.stdout)
[17:42:26.175]         ...future.stdout <- NULL
[17:42:26.175]     }
[17:42:26.175]     ...future.result$conditions <- ...future.conditions
[17:42:26.175]     ...future.result$finished <- base::Sys.time()
[17:42:26.175]     ...future.result
[17:42:26.175] }
[17:42:26.178] assign_globals() ...
[17:42:26.178] List of 2
[17:42:26.178]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[17:42:26.178]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[17:42:26.178]  - attr(*, "where")=List of 2
[17:42:26.178]   ..$ weight:<environment: R_EmptyEnv> 
[17:42:26.178]   ..$ group :<environment: R_EmptyEnv> 
[17:42:26.178]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:26.178]  - attr(*, "resolved")= logi FALSE
[17:42:26.178]  - attr(*, "total_size")= num 896
[17:42:26.178]  - attr(*, "already-done")= logi TRUE
[17:42:26.182] - copied ‘weight’ to environment
[17:42:26.182] - copied ‘group’ to environment
[17:42:26.182] assign_globals() ... done
[17:42:26.182] requestCore(): workers = 2
[17:42:26.184] MulticoreFuture started
[17:42:26.185] - Launch lazy future ... done
[17:42:26.185] run() for ‘MulticoreFuture’ ... done
[17:42:26.186] plan(): Setting new future strategy stack:
[17:42:26.186] List of future strategies:
[17:42:26.186] 1. sequential:
[17:42:26.186]    - args: function (..., envir = parent.frame())
[17:42:26.186]    - tweaked: FALSE
[17:42:26.186]    - call: NULL
[17:42:26.191] plan(): nbrOfWorkers() = 1
[17:42:26.196] plan(): Setting new future strategy stack:
[17:42:26.196] List of future strategies:
[17:42:26.196] 1. multicore:
[17:42:26.196]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:26.196]    - tweaked: FALSE
[17:42:26.196]    - call: plan(strategy)
[17:42:26.202] plan(): nbrOfWorkers() = 2

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[17:42:26.211] getGlobalsAndPackages() ...
[17:42:26.211] Searching for globals...
[17:42:26.213] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:42:26.213] Searching for globals ... DONE
[17:42:26.213] Resolving globals: FALSE
[17:42:26.214] The total size of the 2 globals is 896 bytes (896 bytes)
[17:42:26.214] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:42:26.215] - globals: [2] ‘weight’, ‘group’
[17:42:26.215] - packages: [1] ‘stats’
[17:42:26.215] getGlobalsAndPackages() ... DONE
[17:42:26.215] run() for ‘Future’ ...
[17:42:26.215] - state: ‘created’
[17:42:26.216] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:26.220] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:26.220] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:26.220]   - Field: ‘label’
[17:42:26.220]   - Field: ‘local’
[17:42:26.221]   - Field: ‘owner’
[17:42:26.221]   - Field: ‘envir’
[17:42:26.221]   - Field: ‘workers’
[17:42:26.221]   - Field: ‘packages’
[17:42:26.221]   - Field: ‘gc’
[17:42:26.221]   - Field: ‘job’
[17:42:26.221]   - Field: ‘conditions’
[17:42:26.222]   - Field: ‘expr’
[17:42:26.222]   - Field: ‘uuid’
[17:42:26.222]   - Field: ‘seed’
[17:42:26.222]   - Field: ‘version’
[17:42:26.222]   - Field: ‘result’
[17:42:26.222]   - Field: ‘asynchronous’
[17:42:26.222]   - Field: ‘calls’
[17:42:26.222]   - Field: ‘globals’
[17:42:26.222]   - Field: ‘stdout’
[17:42:26.223]   - Field: ‘earlySignal’
[17:42:26.223]   - Field: ‘lazy’
[17:42:26.223]   - Field: ‘state’
[17:42:26.223] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:26.223] - Launch lazy future ...
[17:42:26.223] Packages needed by the future expression (n = 1): ‘stats’
[17:42:26.224] Packages needed by future strategies (n = 0): <none>
[17:42:26.224] {
[17:42:26.224]     {
[17:42:26.224]         {
[17:42:26.224]             ...future.startTime <- base::Sys.time()
[17:42:26.224]             {
[17:42:26.224]                 {
[17:42:26.224]                   {
[17:42:26.224]                     {
[17:42:26.224]                       {
[17:42:26.224]                         base::local({
[17:42:26.224]                           has_future <- base::requireNamespace("future", 
[17:42:26.224]                             quietly = TRUE)
[17:42:26.224]                           if (has_future) {
[17:42:26.224]                             ns <- base::getNamespace("future")
[17:42:26.224]                             version <- ns[[".package"]][["version"]]
[17:42:26.224]                             if (is.null(version)) 
[17:42:26.224]                               version <- utils::packageVersion("future")
[17:42:26.224]                           }
[17:42:26.224]                           else {
[17:42:26.224]                             version <- NULL
[17:42:26.224]                           }
[17:42:26.224]                           if (!has_future || version < "1.8.0") {
[17:42:26.224]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:26.224]                               "", base::R.version$version.string), 
[17:42:26.224]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:26.224]                                 base::R.version$platform, 8 * 
[17:42:26.224]                                   base::.Machine$sizeof.pointer), 
[17:42:26.224]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:26.224]                                 "release", "version")], collapse = " "), 
[17:42:26.224]                               hostname = base::Sys.info()[["nodename"]])
[17:42:26.224]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:26.224]                               info)
[17:42:26.224]                             info <- base::paste(info, collapse = "; ")
[17:42:26.224]                             if (!has_future) {
[17:42:26.224]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:26.224]                                 info)
[17:42:26.224]                             }
[17:42:26.224]                             else {
[17:42:26.224]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:26.224]                                 info, version)
[17:42:26.224]                             }
[17:42:26.224]                             base::stop(msg)
[17:42:26.224]                           }
[17:42:26.224]                         })
[17:42:26.224]                       }
[17:42:26.224]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:26.224]                       base::options(mc.cores = 1L)
[17:42:26.224]                     }
[17:42:26.224]                     base::local({
[17:42:26.224]                       for (pkg in "stats") {
[17:42:26.224]                         base::loadNamespace(pkg)
[17:42:26.224]                         base::library(pkg, character.only = TRUE)
[17:42:26.224]                       }
[17:42:26.224]                     })
[17:42:26.224]                   }
[17:42:26.224]                   options(future.plan = NULL)
[17:42:26.224]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:26.224]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:26.224]                 }
[17:42:26.224]                 ...future.workdir <- getwd()
[17:42:26.224]             }
[17:42:26.224]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:26.224]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:26.224]         }
[17:42:26.224]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:26.224]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:26.224]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:26.224]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:26.224]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:26.224]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:26.224]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:26.224]             base::names(...future.oldOptions))
[17:42:26.224]     }
[17:42:26.224]     if (FALSE) {
[17:42:26.224]     }
[17:42:26.224]     else {
[17:42:26.224]         if (TRUE) {
[17:42:26.224]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:26.224]                 open = "w")
[17:42:26.224]         }
[17:42:26.224]         else {
[17:42:26.224]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:26.224]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:26.224]         }
[17:42:26.224]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:26.224]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:26.224]             base::sink(type = "output", split = FALSE)
[17:42:26.224]             base::close(...future.stdout)
[17:42:26.224]         }, add = TRUE)
[17:42:26.224]     }
[17:42:26.224]     ...future.frame <- base::sys.nframe()
[17:42:26.224]     ...future.conditions <- base::list()
[17:42:26.224]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:26.224]     if (FALSE) {
[17:42:26.224]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:26.224]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:26.224]     }
[17:42:26.224]     ...future.result <- base::tryCatch({
[17:42:26.224]         base::withCallingHandlers({
[17:42:26.224]             ...future.value <- base::withVisible(base::local({
[17:42:26.224]                 withCallingHandlers({
[17:42:26.224]                   {
[17:42:26.224]                     lm(weight ~ group - 1)
[17:42:26.224]                   }
[17:42:26.224]                 }, immediateCondition = function(cond) {
[17:42:26.224]                   save_rds <- function (object, pathname, ...) 
[17:42:26.224]                   {
[17:42:26.224]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:26.224]                     if (file_test("-f", pathname_tmp)) {
[17:42:26.224]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.224]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:26.224]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.224]                         fi_tmp[["mtime"]])
[17:42:26.224]                     }
[17:42:26.224]                     tryCatch({
[17:42:26.224]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:26.224]                     }, error = function(ex) {
[17:42:26.224]                       msg <- conditionMessage(ex)
[17:42:26.224]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.224]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:26.224]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.224]                         fi_tmp[["mtime"]], msg)
[17:42:26.224]                       ex$message <- msg
[17:42:26.224]                       stop(ex)
[17:42:26.224]                     })
[17:42:26.224]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:26.224]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:26.224]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:26.224]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.224]                       fi <- file.info(pathname)
[17:42:26.224]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:26.224]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.224]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:26.224]                         fi[["size"]], fi[["mtime"]])
[17:42:26.224]                       stop(msg)
[17:42:26.224]                     }
[17:42:26.224]                     invisible(pathname)
[17:42:26.224]                   }
[17:42:26.224]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:26.224]                     rootPath = tempdir()) 
[17:42:26.224]                   {
[17:42:26.224]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:26.224]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:26.224]                       tmpdir = path, fileext = ".rds")
[17:42:26.224]                     save_rds(obj, file)
[17:42:26.224]                   }
[17:42:26.224]                   saveImmediateCondition(cond, path = "/tmp/RtmpNwFxwa/.future/immediateConditions")
[17:42:26.224]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.224]                   {
[17:42:26.224]                     inherits <- base::inherits
[17:42:26.224]                     invokeRestart <- base::invokeRestart
[17:42:26.224]                     is.null <- base::is.null
[17:42:26.224]                     muffled <- FALSE
[17:42:26.224]                     if (inherits(cond, "message")) {
[17:42:26.224]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:26.224]                       if (muffled) 
[17:42:26.224]                         invokeRestart("muffleMessage")
[17:42:26.224]                     }
[17:42:26.224]                     else if (inherits(cond, "warning")) {
[17:42:26.224]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:26.224]                       if (muffled) 
[17:42:26.224]                         invokeRestart("muffleWarning")
[17:42:26.224]                     }
[17:42:26.224]                     else if (inherits(cond, "condition")) {
[17:42:26.224]                       if (!is.null(pattern)) {
[17:42:26.224]                         computeRestarts <- base::computeRestarts
[17:42:26.224]                         grepl <- base::grepl
[17:42:26.224]                         restarts <- computeRestarts(cond)
[17:42:26.224]                         for (restart in restarts) {
[17:42:26.224]                           name <- restart$name
[17:42:26.224]                           if (is.null(name)) 
[17:42:26.224]                             next
[17:42:26.224]                           if (!grepl(pattern, name)) 
[17:42:26.224]                             next
[17:42:26.224]                           invokeRestart(restart)
[17:42:26.224]                           muffled <- TRUE
[17:42:26.224]                           break
[17:42:26.224]                         }
[17:42:26.224]                       }
[17:42:26.224]                     }
[17:42:26.224]                     invisible(muffled)
[17:42:26.224]                   }
[17:42:26.224]                   muffleCondition(cond)
[17:42:26.224]                 })
[17:42:26.224]             }))
[17:42:26.224]             future::FutureResult(value = ...future.value$value, 
[17:42:26.224]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:26.224]                   ...future.rng), globalenv = if (FALSE) 
[17:42:26.224]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:26.224]                     ...future.globalenv.names))
[17:42:26.224]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:26.224]         }, condition = base::local({
[17:42:26.224]             c <- base::c
[17:42:26.224]             inherits <- base::inherits
[17:42:26.224]             invokeRestart <- base::invokeRestart
[17:42:26.224]             length <- base::length
[17:42:26.224]             list <- base::list
[17:42:26.224]             seq.int <- base::seq.int
[17:42:26.224]             signalCondition <- base::signalCondition
[17:42:26.224]             sys.calls <- base::sys.calls
[17:42:26.224]             `[[` <- base::`[[`
[17:42:26.224]             `+` <- base::`+`
[17:42:26.224]             `<<-` <- base::`<<-`
[17:42:26.224]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:26.224]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:26.224]                   3L)]
[17:42:26.224]             }
[17:42:26.224]             function(cond) {
[17:42:26.224]                 is_error <- inherits(cond, "error")
[17:42:26.224]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:26.224]                   NULL)
[17:42:26.224]                 if (is_error) {
[17:42:26.224]                   sessionInformation <- function() {
[17:42:26.224]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:26.224]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:26.224]                       search = base::search(), system = base::Sys.info())
[17:42:26.224]                   }
[17:42:26.224]                   ...future.conditions[[length(...future.conditions) + 
[17:42:26.224]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:26.224]                     cond$call), session = sessionInformation(), 
[17:42:26.224]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:26.224]                   signalCondition(cond)
[17:42:26.224]                 }
[17:42:26.224]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:26.224]                 "immediateCondition"))) {
[17:42:26.224]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:26.224]                   ...future.conditions[[length(...future.conditions) + 
[17:42:26.224]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:26.224]                   if (TRUE && !signal) {
[17:42:26.224]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.224]                     {
[17:42:26.224]                       inherits <- base::inherits
[17:42:26.224]                       invokeRestart <- base::invokeRestart
[17:42:26.224]                       is.null <- base::is.null
[17:42:26.224]                       muffled <- FALSE
[17:42:26.224]                       if (inherits(cond, "message")) {
[17:42:26.224]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:26.224]                         if (muffled) 
[17:42:26.224]                           invokeRestart("muffleMessage")
[17:42:26.224]                       }
[17:42:26.224]                       else if (inherits(cond, "warning")) {
[17:42:26.224]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:26.224]                         if (muffled) 
[17:42:26.224]                           invokeRestart("muffleWarning")
[17:42:26.224]                       }
[17:42:26.224]                       else if (inherits(cond, "condition")) {
[17:42:26.224]                         if (!is.null(pattern)) {
[17:42:26.224]                           computeRestarts <- base::computeRestarts
[17:42:26.224]                           grepl <- base::grepl
[17:42:26.224]                           restarts <- computeRestarts(cond)
[17:42:26.224]                           for (restart in restarts) {
[17:42:26.224]                             name <- restart$name
[17:42:26.224]                             if (is.null(name)) 
[17:42:26.224]                               next
[17:42:26.224]                             if (!grepl(pattern, name)) 
[17:42:26.224]                               next
[17:42:26.224]                             invokeRestart(restart)
[17:42:26.224]                             muffled <- TRUE
[17:42:26.224]                             break
[17:42:26.224]                           }
[17:42:26.224]                         }
[17:42:26.224]                       }
[17:42:26.224]                       invisible(muffled)
[17:42:26.224]                     }
[17:42:26.224]                     muffleCondition(cond, pattern = "^muffle")
[17:42:26.224]                   }
[17:42:26.224]                 }
[17:42:26.224]                 else {
[17:42:26.224]                   if (TRUE) {
[17:42:26.224]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.224]                     {
[17:42:26.224]                       inherits <- base::inherits
[17:42:26.224]                       invokeRestart <- base::invokeRestart
[17:42:26.224]                       is.null <- base::is.null
[17:42:26.224]                       muffled <- FALSE
[17:42:26.224]                       if (inherits(cond, "message")) {
[17:42:26.224]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:26.224]                         if (muffled) 
[17:42:26.224]                           invokeRestart("muffleMessage")
[17:42:26.224]                       }
[17:42:26.224]                       else if (inherits(cond, "warning")) {
[17:42:26.224]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:26.224]                         if (muffled) 
[17:42:26.224]                           invokeRestart("muffleWarning")
[17:42:26.224]                       }
[17:42:26.224]                       else if (inherits(cond, "condition")) {
[17:42:26.224]                         if (!is.null(pattern)) {
[17:42:26.224]                           computeRestarts <- base::computeRestarts
[17:42:26.224]                           grepl <- base::grepl
[17:42:26.224]                           restarts <- computeRestarts(cond)
[17:42:26.224]                           for (restart in restarts) {
[17:42:26.224]                             name <- restart$name
[17:42:26.224]                             if (is.null(name)) 
[17:42:26.224]                               next
[17:42:26.224]                             if (!grepl(pattern, name)) 
[17:42:26.224]                               next
[17:42:26.224]                             invokeRestart(restart)
[17:42:26.224]                             muffled <- TRUE
[17:42:26.224]                             break
[17:42:26.224]                           }
[17:42:26.224]                         }
[17:42:26.224]                       }
[17:42:26.224]                       invisible(muffled)
[17:42:26.224]                     }
[17:42:26.224]                     muffleCondition(cond, pattern = "^muffle")
[17:42:26.224]                   }
[17:42:26.224]                 }
[17:42:26.224]             }
[17:42:26.224]         }))
[17:42:26.224]     }, error = function(ex) {
[17:42:26.224]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:26.224]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:26.224]                 ...future.rng), started = ...future.startTime, 
[17:42:26.224]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:26.224]             version = "1.8"), class = "FutureResult")
[17:42:26.224]     }, finally = {
[17:42:26.224]         if (!identical(...future.workdir, getwd())) 
[17:42:26.224]             setwd(...future.workdir)
[17:42:26.224]         {
[17:42:26.224]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:26.224]                 ...future.oldOptions$nwarnings <- NULL
[17:42:26.224]             }
[17:42:26.224]             base::options(...future.oldOptions)
[17:42:26.224]             if (.Platform$OS.type == "windows") {
[17:42:26.224]                 old_names <- names(...future.oldEnvVars)
[17:42:26.224]                 envs <- base::Sys.getenv()
[17:42:26.224]                 names <- names(envs)
[17:42:26.224]                 common <- intersect(names, old_names)
[17:42:26.224]                 added <- setdiff(names, old_names)
[17:42:26.224]                 removed <- setdiff(old_names, names)
[17:42:26.224]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:26.224]                   envs[common]]
[17:42:26.224]                 NAMES <- toupper(changed)
[17:42:26.224]                 args <- list()
[17:42:26.224]                 for (kk in seq_along(NAMES)) {
[17:42:26.224]                   name <- changed[[kk]]
[17:42:26.224]                   NAME <- NAMES[[kk]]
[17:42:26.224]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.224]                     next
[17:42:26.224]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:26.224]                 }
[17:42:26.224]                 NAMES <- toupper(added)
[17:42:26.224]                 for (kk in seq_along(NAMES)) {
[17:42:26.224]                   name <- added[[kk]]
[17:42:26.224]                   NAME <- NAMES[[kk]]
[17:42:26.224]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.224]                     next
[17:42:26.224]                   args[[name]] <- ""
[17:42:26.224]                 }
[17:42:26.224]                 NAMES <- toupper(removed)
[17:42:26.224]                 for (kk in seq_along(NAMES)) {
[17:42:26.224]                   name <- removed[[kk]]
[17:42:26.224]                   NAME <- NAMES[[kk]]
[17:42:26.224]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.224]                     next
[17:42:26.224]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:26.224]                 }
[17:42:26.224]                 if (length(args) > 0) 
[17:42:26.224]                   base::do.call(base::Sys.setenv, args = args)
[17:42:26.224]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:26.224]             }
[17:42:26.224]             else {
[17:42:26.224]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:26.224]             }
[17:42:26.224]             {
[17:42:26.224]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:26.224]                   0L) {
[17:42:26.224]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:26.224]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:26.224]                   base::options(opts)
[17:42:26.224]                 }
[17:42:26.224]                 {
[17:42:26.224]                   {
[17:42:26.224]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:26.224]                     NULL
[17:42:26.224]                   }
[17:42:26.224]                   options(future.plan = NULL)
[17:42:26.224]                   if (is.na(NA_character_)) 
[17:42:26.224]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:26.224]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:26.224]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:26.224]                     envir = parent.frame()) 
[17:42:26.224]                   {
[17:42:26.224]                     default_workers <- missing(workers)
[17:42:26.224]                     if (is.function(workers)) 
[17:42:26.224]                       workers <- workers()
[17:42:26.224]                     workers <- structure(as.integer(workers), 
[17:42:26.224]                       class = class(workers))
[17:42:26.224]                     stop_if_not(is.finite(workers), workers >= 
[17:42:26.224]                       1L)
[17:42:26.224]                     if ((workers == 1L && !inherits(workers, 
[17:42:26.224]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:26.224]                       if (default_workers) 
[17:42:26.224]                         supportsMulticore(warn = TRUE)
[17:42:26.224]                       return(sequential(..., envir = envir))
[17:42:26.224]                     }
[17:42:26.224]                     oopts <- options(mc.cores = workers)
[17:42:26.224]                     on.exit(options(oopts))
[17:42:26.224]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:26.224]                       envir = envir)
[17:42:26.224]                     if (!future$lazy) 
[17:42:26.224]                       future <- run(future)
[17:42:26.224]                     invisible(future)
[17:42:26.224]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:26.224]                 }
[17:42:26.224]             }
[17:42:26.224]         }
[17:42:26.224]     })
[17:42:26.224]     if (TRUE) {
[17:42:26.224]         base::sink(type = "output", split = FALSE)
[17:42:26.224]         if (TRUE) {
[17:42:26.224]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:26.224]         }
[17:42:26.224]         else {
[17:42:26.224]             ...future.result["stdout"] <- base::list(NULL)
[17:42:26.224]         }
[17:42:26.224]         base::close(...future.stdout)
[17:42:26.224]         ...future.stdout <- NULL
[17:42:26.224]     }
[17:42:26.224]     ...future.result$conditions <- ...future.conditions
[17:42:26.224]     ...future.result$finished <- base::Sys.time()
[17:42:26.224]     ...future.result
[17:42:26.224] }
[17:42:26.227] assign_globals() ...
[17:42:26.227] List of 2
[17:42:26.227]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[17:42:26.227]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[17:42:26.227]  - attr(*, "where")=List of 2
[17:42:26.227]   ..$ weight:<environment: R_EmptyEnv> 
[17:42:26.227]   ..$ group :<environment: R_EmptyEnv> 
[17:42:26.227]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:26.227]  - attr(*, "resolved")= logi FALSE
[17:42:26.227]  - attr(*, "total_size")= num 896
[17:42:26.227]  - attr(*, "already-done")= logi TRUE
[17:42:26.231] - copied ‘weight’ to environment
[17:42:26.231] - copied ‘group’ to environment
[17:42:26.231] assign_globals() ... done
[17:42:26.231] requestCore(): workers = 2
[17:42:26.233] MulticoreFuture started
[17:42:26.234] - Launch lazy future ... done
[17:42:26.234] run() for ‘MulticoreFuture’ ... done
[17:42:26.235] plan(): Setting new future strategy stack:
[17:42:26.235] List of future strategies:
[17:42:26.235] 1. sequential:
[17:42:26.235]    - args: function (..., envir = parent.frame())
[17:42:26.235]    - tweaked: FALSE
[17:42:26.235]    - call: NULL
[17:42:26.236] plan(): nbrOfWorkers() = 1
[17:42:26.240] plan(): Setting new future strategy stack:
[17:42:26.240] List of future strategies:
[17:42:26.240] 1. multicore:
[17:42:26.240]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:26.240]    - tweaked: FALSE
[17:42:26.240]    - call: plan(strategy)
[17:42:26.245] plan(): nbrOfWorkers() = 2

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[17:42:26.250] getGlobalsAndPackages() ...
[17:42:26.250] Searching for globals...
[17:42:26.255] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:42:26.255] Searching for globals ... DONE
[17:42:26.255] Resolving globals: FALSE
[17:42:26.256] The total size of the 2 globals is 896 bytes (896 bytes)
[17:42:26.256] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:42:26.257] - globals: [2] ‘weight’, ‘group’
[17:42:26.257] - packages: [1] ‘stats’
[17:42:26.257] getGlobalsAndPackages() ... DONE
[17:42:26.257] run() for ‘Future’ ...
[17:42:26.257] - state: ‘created’
[17:42:26.258] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:26.262] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:26.262] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:26.262]   - Field: ‘label’
[17:42:26.262]   - Field: ‘local’
[17:42:26.262]   - Field: ‘owner’
[17:42:26.262]   - Field: ‘envir’
[17:42:26.262]   - Field: ‘workers’
[17:42:26.263]   - Field: ‘packages’
[17:42:26.263]   - Field: ‘gc’
[17:42:26.263]   - Field: ‘job’
[17:42:26.263]   - Field: ‘conditions’
[17:42:26.263]   - Field: ‘expr’
[17:42:26.263]   - Field: ‘uuid’
[17:42:26.263]   - Field: ‘seed’
[17:42:26.264]   - Field: ‘version’
[17:42:26.264]   - Field: ‘result’
[17:42:26.264]   - Field: ‘asynchronous’
[17:42:26.264]   - Field: ‘calls’
[17:42:26.264]   - Field: ‘globals’
[17:42:26.264]   - Field: ‘stdout’
[17:42:26.264]   - Field: ‘earlySignal’
[17:42:26.264]   - Field: ‘lazy’
[17:42:26.264]   - Field: ‘state’
[17:42:26.265] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:26.265] - Launch lazy future ...
[17:42:26.265] Packages needed by the future expression (n = 1): ‘stats’
[17:42:26.265] Packages needed by future strategies (n = 0): <none>
[17:42:26.266] {
[17:42:26.266]     {
[17:42:26.266]         {
[17:42:26.266]             ...future.startTime <- base::Sys.time()
[17:42:26.266]             {
[17:42:26.266]                 {
[17:42:26.266]                   {
[17:42:26.266]                     {
[17:42:26.266]                       {
[17:42:26.266]                         base::local({
[17:42:26.266]                           has_future <- base::requireNamespace("future", 
[17:42:26.266]                             quietly = TRUE)
[17:42:26.266]                           if (has_future) {
[17:42:26.266]                             ns <- base::getNamespace("future")
[17:42:26.266]                             version <- ns[[".package"]][["version"]]
[17:42:26.266]                             if (is.null(version)) 
[17:42:26.266]                               version <- utils::packageVersion("future")
[17:42:26.266]                           }
[17:42:26.266]                           else {
[17:42:26.266]                             version <- NULL
[17:42:26.266]                           }
[17:42:26.266]                           if (!has_future || version < "1.8.0") {
[17:42:26.266]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:26.266]                               "", base::R.version$version.string), 
[17:42:26.266]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:26.266]                                 base::R.version$platform, 8 * 
[17:42:26.266]                                   base::.Machine$sizeof.pointer), 
[17:42:26.266]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:26.266]                                 "release", "version")], collapse = " "), 
[17:42:26.266]                               hostname = base::Sys.info()[["nodename"]])
[17:42:26.266]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:26.266]                               info)
[17:42:26.266]                             info <- base::paste(info, collapse = "; ")
[17:42:26.266]                             if (!has_future) {
[17:42:26.266]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:26.266]                                 info)
[17:42:26.266]                             }
[17:42:26.266]                             else {
[17:42:26.266]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:26.266]                                 info, version)
[17:42:26.266]                             }
[17:42:26.266]                             base::stop(msg)
[17:42:26.266]                           }
[17:42:26.266]                         })
[17:42:26.266]                       }
[17:42:26.266]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:26.266]                       base::options(mc.cores = 1L)
[17:42:26.266]                     }
[17:42:26.266]                     base::local({
[17:42:26.266]                       for (pkg in "stats") {
[17:42:26.266]                         base::loadNamespace(pkg)
[17:42:26.266]                         base::library(pkg, character.only = TRUE)
[17:42:26.266]                       }
[17:42:26.266]                     })
[17:42:26.266]                   }
[17:42:26.266]                   options(future.plan = NULL)
[17:42:26.266]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:26.266]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:26.266]                 }
[17:42:26.266]                 ...future.workdir <- getwd()
[17:42:26.266]             }
[17:42:26.266]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:26.266]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:26.266]         }
[17:42:26.266]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:26.266]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:26.266]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:26.266]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:26.266]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:26.266]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:26.266]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:26.266]             base::names(...future.oldOptions))
[17:42:26.266]     }
[17:42:26.266]     if (FALSE) {
[17:42:26.266]     }
[17:42:26.266]     else {
[17:42:26.266]         if (TRUE) {
[17:42:26.266]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:26.266]                 open = "w")
[17:42:26.266]         }
[17:42:26.266]         else {
[17:42:26.266]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:26.266]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:26.266]         }
[17:42:26.266]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:26.266]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:26.266]             base::sink(type = "output", split = FALSE)
[17:42:26.266]             base::close(...future.stdout)
[17:42:26.266]         }, add = TRUE)
[17:42:26.266]     }
[17:42:26.266]     ...future.frame <- base::sys.nframe()
[17:42:26.266]     ...future.conditions <- base::list()
[17:42:26.266]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:26.266]     if (FALSE) {
[17:42:26.266]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:26.266]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:26.266]     }
[17:42:26.266]     ...future.result <- base::tryCatch({
[17:42:26.266]         base::withCallingHandlers({
[17:42:26.266]             ...future.value <- base::withVisible(base::local({
[17:42:26.266]                 withCallingHandlers({
[17:42:26.266]                   {
[17:42:26.266]                     lm(weight ~ group - 1)
[17:42:26.266]                   }
[17:42:26.266]                 }, immediateCondition = function(cond) {
[17:42:26.266]                   save_rds <- function (object, pathname, ...) 
[17:42:26.266]                   {
[17:42:26.266]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:26.266]                     if (file_test("-f", pathname_tmp)) {
[17:42:26.266]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.266]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:26.266]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.266]                         fi_tmp[["mtime"]])
[17:42:26.266]                     }
[17:42:26.266]                     tryCatch({
[17:42:26.266]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:26.266]                     }, error = function(ex) {
[17:42:26.266]                       msg <- conditionMessage(ex)
[17:42:26.266]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.266]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:26.266]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.266]                         fi_tmp[["mtime"]], msg)
[17:42:26.266]                       ex$message <- msg
[17:42:26.266]                       stop(ex)
[17:42:26.266]                     })
[17:42:26.266]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:26.266]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:26.266]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:26.266]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.266]                       fi <- file.info(pathname)
[17:42:26.266]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:26.266]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.266]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:26.266]                         fi[["size"]], fi[["mtime"]])
[17:42:26.266]                       stop(msg)
[17:42:26.266]                     }
[17:42:26.266]                     invisible(pathname)
[17:42:26.266]                   }
[17:42:26.266]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:26.266]                     rootPath = tempdir()) 
[17:42:26.266]                   {
[17:42:26.266]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:26.266]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:26.266]                       tmpdir = path, fileext = ".rds")
[17:42:26.266]                     save_rds(obj, file)
[17:42:26.266]                   }
[17:42:26.266]                   saveImmediateCondition(cond, path = "/tmp/RtmpNwFxwa/.future/immediateConditions")
[17:42:26.266]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.266]                   {
[17:42:26.266]                     inherits <- base::inherits
[17:42:26.266]                     invokeRestart <- base::invokeRestart
[17:42:26.266]                     is.null <- base::is.null
[17:42:26.266]                     muffled <- FALSE
[17:42:26.266]                     if (inherits(cond, "message")) {
[17:42:26.266]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:26.266]                       if (muffled) 
[17:42:26.266]                         invokeRestart("muffleMessage")
[17:42:26.266]                     }
[17:42:26.266]                     else if (inherits(cond, "warning")) {
[17:42:26.266]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:26.266]                       if (muffled) 
[17:42:26.266]                         invokeRestart("muffleWarning")
[17:42:26.266]                     }
[17:42:26.266]                     else if (inherits(cond, "condition")) {
[17:42:26.266]                       if (!is.null(pattern)) {
[17:42:26.266]                         computeRestarts <- base::computeRestarts
[17:42:26.266]                         grepl <- base::grepl
[17:42:26.266]                         restarts <- computeRestarts(cond)
[17:42:26.266]                         for (restart in restarts) {
[17:42:26.266]                           name <- restart$name
[17:42:26.266]                           if (is.null(name)) 
[17:42:26.266]                             next
[17:42:26.266]                           if (!grepl(pattern, name)) 
[17:42:26.266]                             next
[17:42:26.266]                           invokeRestart(restart)
[17:42:26.266]                           muffled <- TRUE
[17:42:26.266]                           break
[17:42:26.266]                         }
[17:42:26.266]                       }
[17:42:26.266]                     }
[17:42:26.266]                     invisible(muffled)
[17:42:26.266]                   }
[17:42:26.266]                   muffleCondition(cond)
[17:42:26.266]                 })
[17:42:26.266]             }))
[17:42:26.266]             future::FutureResult(value = ...future.value$value, 
[17:42:26.266]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:26.266]                   ...future.rng), globalenv = if (FALSE) 
[17:42:26.266]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:26.266]                     ...future.globalenv.names))
[17:42:26.266]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:26.266]         }, condition = base::local({
[17:42:26.266]             c <- base::c
[17:42:26.266]             inherits <- base::inherits
[17:42:26.266]             invokeRestart <- base::invokeRestart
[17:42:26.266]             length <- base::length
[17:42:26.266]             list <- base::list
[17:42:26.266]             seq.int <- base::seq.int
[17:42:26.266]             signalCondition <- base::signalCondition
[17:42:26.266]             sys.calls <- base::sys.calls
[17:42:26.266]             `[[` <- base::`[[`
[17:42:26.266]             `+` <- base::`+`
[17:42:26.266]             `<<-` <- base::`<<-`
[17:42:26.266]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:26.266]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:26.266]                   3L)]
[17:42:26.266]             }
[17:42:26.266]             function(cond) {
[17:42:26.266]                 is_error <- inherits(cond, "error")
[17:42:26.266]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:26.266]                   NULL)
[17:42:26.266]                 if (is_error) {
[17:42:26.266]                   sessionInformation <- function() {
[17:42:26.266]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:26.266]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:26.266]                       search = base::search(), system = base::Sys.info())
[17:42:26.266]                   }
[17:42:26.266]                   ...future.conditions[[length(...future.conditions) + 
[17:42:26.266]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:26.266]                     cond$call), session = sessionInformation(), 
[17:42:26.266]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:26.266]                   signalCondition(cond)
[17:42:26.266]                 }
[17:42:26.266]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:26.266]                 "immediateCondition"))) {
[17:42:26.266]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:26.266]                   ...future.conditions[[length(...future.conditions) + 
[17:42:26.266]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:26.266]                   if (TRUE && !signal) {
[17:42:26.266]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.266]                     {
[17:42:26.266]                       inherits <- base::inherits
[17:42:26.266]                       invokeRestart <- base::invokeRestart
[17:42:26.266]                       is.null <- base::is.null
[17:42:26.266]                       muffled <- FALSE
[17:42:26.266]                       if (inherits(cond, "message")) {
[17:42:26.266]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:26.266]                         if (muffled) 
[17:42:26.266]                           invokeRestart("muffleMessage")
[17:42:26.266]                       }
[17:42:26.266]                       else if (inherits(cond, "warning")) {
[17:42:26.266]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:26.266]                         if (muffled) 
[17:42:26.266]                           invokeRestart("muffleWarning")
[17:42:26.266]                       }
[17:42:26.266]                       else if (inherits(cond, "condition")) {
[17:42:26.266]                         if (!is.null(pattern)) {
[17:42:26.266]                           computeRestarts <- base::computeRestarts
[17:42:26.266]                           grepl <- base::grepl
[17:42:26.266]                           restarts <- computeRestarts(cond)
[17:42:26.266]                           for (restart in restarts) {
[17:42:26.266]                             name <- restart$name
[17:42:26.266]                             if (is.null(name)) 
[17:42:26.266]                               next
[17:42:26.266]                             if (!grepl(pattern, name)) 
[17:42:26.266]                               next
[17:42:26.266]                             invokeRestart(restart)
[17:42:26.266]                             muffled <- TRUE
[17:42:26.266]                             break
[17:42:26.266]                           }
[17:42:26.266]                         }
[17:42:26.266]                       }
[17:42:26.266]                       invisible(muffled)
[17:42:26.266]                     }
[17:42:26.266]                     muffleCondition(cond, pattern = "^muffle")
[17:42:26.266]                   }
[17:42:26.266]                 }
[17:42:26.266]                 else {
[17:42:26.266]                   if (TRUE) {
[17:42:26.266]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.266]                     {
[17:42:26.266]                       inherits <- base::inherits
[17:42:26.266]                       invokeRestart <- base::invokeRestart
[17:42:26.266]                       is.null <- base::is.null
[17:42:26.266]                       muffled <- FALSE
[17:42:26.266]                       if (inherits(cond, "message")) {
[17:42:26.266]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:26.266]                         if (muffled) 
[17:42:26.266]                           invokeRestart("muffleMessage")
[17:42:26.266]                       }
[17:42:26.266]                       else if (inherits(cond, "warning")) {
[17:42:26.266]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:26.266]                         if (muffled) 
[17:42:26.266]                           invokeRestart("muffleWarning")
[17:42:26.266]                       }
[17:42:26.266]                       else if (inherits(cond, "condition")) {
[17:42:26.266]                         if (!is.null(pattern)) {
[17:42:26.266]                           computeRestarts <- base::computeRestarts
[17:42:26.266]                           grepl <- base::grepl
[17:42:26.266]                           restarts <- computeRestarts(cond)
[17:42:26.266]                           for (restart in restarts) {
[17:42:26.266]                             name <- restart$name
[17:42:26.266]                             if (is.null(name)) 
[17:42:26.266]                               next
[17:42:26.266]                             if (!grepl(pattern, name)) 
[17:42:26.266]                               next
[17:42:26.266]                             invokeRestart(restart)
[17:42:26.266]                             muffled <- TRUE
[17:42:26.266]                             break
[17:42:26.266]                           }
[17:42:26.266]                         }
[17:42:26.266]                       }
[17:42:26.266]                       invisible(muffled)
[17:42:26.266]                     }
[17:42:26.266]                     muffleCondition(cond, pattern = "^muffle")
[17:42:26.266]                   }
[17:42:26.266]                 }
[17:42:26.266]             }
[17:42:26.266]         }))
[17:42:26.266]     }, error = function(ex) {
[17:42:26.266]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:26.266]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:26.266]                 ...future.rng), started = ...future.startTime, 
[17:42:26.266]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:26.266]             version = "1.8"), class = "FutureResult")
[17:42:26.266]     }, finally = {
[17:42:26.266]         if (!identical(...future.workdir, getwd())) 
[17:42:26.266]             setwd(...future.workdir)
[17:42:26.266]         {
[17:42:26.266]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:26.266]                 ...future.oldOptions$nwarnings <- NULL
[17:42:26.266]             }
[17:42:26.266]             base::options(...future.oldOptions)
[17:42:26.266]             if (.Platform$OS.type == "windows") {
[17:42:26.266]                 old_names <- names(...future.oldEnvVars)
[17:42:26.266]                 envs <- base::Sys.getenv()
[17:42:26.266]                 names <- names(envs)
[17:42:26.266]                 common <- intersect(names, old_names)
[17:42:26.266]                 added <- setdiff(names, old_names)
[17:42:26.266]                 removed <- setdiff(old_names, names)
[17:42:26.266]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:26.266]                   envs[common]]
[17:42:26.266]                 NAMES <- toupper(changed)
[17:42:26.266]                 args <- list()
[17:42:26.266]                 for (kk in seq_along(NAMES)) {
[17:42:26.266]                   name <- changed[[kk]]
[17:42:26.266]                   NAME <- NAMES[[kk]]
[17:42:26.266]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.266]                     next
[17:42:26.266]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:26.266]                 }
[17:42:26.266]                 NAMES <- toupper(added)
[17:42:26.266]                 for (kk in seq_along(NAMES)) {
[17:42:26.266]                   name <- added[[kk]]
[17:42:26.266]                   NAME <- NAMES[[kk]]
[17:42:26.266]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.266]                     next
[17:42:26.266]                   args[[name]] <- ""
[17:42:26.266]                 }
[17:42:26.266]                 NAMES <- toupper(removed)
[17:42:26.266]                 for (kk in seq_along(NAMES)) {
[17:42:26.266]                   name <- removed[[kk]]
[17:42:26.266]                   NAME <- NAMES[[kk]]
[17:42:26.266]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.266]                     next
[17:42:26.266]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:26.266]                 }
[17:42:26.266]                 if (length(args) > 0) 
[17:42:26.266]                   base::do.call(base::Sys.setenv, args = args)
[17:42:26.266]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:26.266]             }
[17:42:26.266]             else {
[17:42:26.266]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:26.266]             }
[17:42:26.266]             {
[17:42:26.266]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:26.266]                   0L) {
[17:42:26.266]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:26.266]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:26.266]                   base::options(opts)
[17:42:26.266]                 }
[17:42:26.266]                 {
[17:42:26.266]                   {
[17:42:26.266]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:26.266]                     NULL
[17:42:26.266]                   }
[17:42:26.266]                   options(future.plan = NULL)
[17:42:26.266]                   if (is.na(NA_character_)) 
[17:42:26.266]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:26.266]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:26.266]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:26.266]                     envir = parent.frame()) 
[17:42:26.266]                   {
[17:42:26.266]                     default_workers <- missing(workers)
[17:42:26.266]                     if (is.function(workers)) 
[17:42:26.266]                       workers <- workers()
[17:42:26.266]                     workers <- structure(as.integer(workers), 
[17:42:26.266]                       class = class(workers))
[17:42:26.266]                     stop_if_not(is.finite(workers), workers >= 
[17:42:26.266]                       1L)
[17:42:26.266]                     if ((workers == 1L && !inherits(workers, 
[17:42:26.266]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:26.266]                       if (default_workers) 
[17:42:26.266]                         supportsMulticore(warn = TRUE)
[17:42:26.266]                       return(sequential(..., envir = envir))
[17:42:26.266]                     }
[17:42:26.266]                     oopts <- options(mc.cores = workers)
[17:42:26.266]                     on.exit(options(oopts))
[17:42:26.266]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:26.266]                       envir = envir)
[17:42:26.266]                     if (!future$lazy) 
[17:42:26.266]                       future <- run(future)
[17:42:26.266]                     invisible(future)
[17:42:26.266]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:26.266]                 }
[17:42:26.266]             }
[17:42:26.266]         }
[17:42:26.266]     })
[17:42:26.266]     if (TRUE) {
[17:42:26.266]         base::sink(type = "output", split = FALSE)
[17:42:26.266]         if (TRUE) {
[17:42:26.266]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:26.266]         }
[17:42:26.266]         else {
[17:42:26.266]             ...future.result["stdout"] <- base::list(NULL)
[17:42:26.266]         }
[17:42:26.266]         base::close(...future.stdout)
[17:42:26.266]         ...future.stdout <- NULL
[17:42:26.266]     }
[17:42:26.266]     ...future.result$conditions <- ...future.conditions
[17:42:26.266]     ...future.result$finished <- base::Sys.time()
[17:42:26.266]     ...future.result
[17:42:26.266] }
[17:42:26.268] assign_globals() ...
[17:42:26.269] List of 2
[17:42:26.269]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[17:42:26.269]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[17:42:26.269]  - attr(*, "where")=List of 2
[17:42:26.269]   ..$ weight:<environment: R_EmptyEnv> 
[17:42:26.269]   ..$ group :<environment: R_EmptyEnv> 
[17:42:26.269]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:26.269]  - attr(*, "resolved")= logi FALSE
[17:42:26.269]  - attr(*, "total_size")= num 896
[17:42:26.269]  - attr(*, "already-done")= logi TRUE
[17:42:26.273] - copied ‘weight’ to environment
[17:42:26.273] - copied ‘group’ to environment
[17:42:26.273] assign_globals() ... done
[17:42:26.273] requestCore(): workers = 2
[17:42:26.275] MulticoreFuture started
[17:42:26.276] - Launch lazy future ... done
[17:42:26.276] run() for ‘MulticoreFuture’ ... done
[17:42:26.277] plan(): Setting new future strategy stack:
[17:42:26.277] List of future strategies:
[17:42:26.277] 1. sequential:
[17:42:26.277]    - args: function (..., envir = parent.frame())
[17:42:26.277]    - tweaked: FALSE
[17:42:26.277]    - call: NULL
[17:42:26.278] plan(): nbrOfWorkers() = 1
[17:42:26.281] plan(): Setting new future strategy stack:
[17:42:26.282] List of future strategies:
[17:42:26.282] 1. multicore:
[17:42:26.282]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:26.282]    - tweaked: FALSE
[17:42:26.282]    - call: plan(strategy)
[17:42:26.286] plan(): nbrOfWorkers() = 2

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[17:42:26.291] getGlobalsAndPackages() ...
[17:42:26.291] Searching for globals...
[17:42:26.293] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[17:42:26.293] Searching for globals ... DONE
[17:42:26.293] Resolving globals: FALSE
[17:42:26.293] The total size of the 1 globals is 96 bytes (96 bytes)
[17:42:26.294] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[17:42:26.294] - globals: [1] ‘x’
[17:42:26.294] - packages: [1] ‘stats’
[17:42:26.294] getGlobalsAndPackages() ... DONE
[17:42:26.295] run() for ‘Future’ ...
[17:42:26.295] - state: ‘created’
[17:42:26.295] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:26.300] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:26.300] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:26.302]   - Field: ‘label’
[17:42:26.303]   - Field: ‘local’
[17:42:26.303]   - Field: ‘owner’
[17:42:26.303]   - Field: ‘envir’
[17:42:26.303]   - Field: ‘workers’
[17:42:26.303]   - Field: ‘packages’
[17:42:26.304]   - Field: ‘gc’
[17:42:26.304]   - Field: ‘job’
[17:42:26.304]   - Field: ‘conditions’
[17:42:26.304]   - Field: ‘expr’
[17:42:26.304]   - Field: ‘uuid’
[17:42:26.304]   - Field: ‘seed’
[17:42:26.304]   - Field: ‘version’
[17:42:26.304]   - Field: ‘result’
[17:42:26.305]   - Field: ‘asynchronous’
[17:42:26.305]   - Field: ‘calls’
[17:42:26.305]   - Field: ‘globals’
[17:42:26.305]   - Field: ‘stdout’
[17:42:26.305]   - Field: ‘earlySignal’
[17:42:26.305]   - Field: ‘lazy’
[17:42:26.305]   - Field: ‘state’
[17:42:26.305] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:26.306] - Launch lazy future ...
[17:42:26.306] Packages needed by the future expression (n = 1): ‘stats’
[17:42:26.306] Packages needed by future strategies (n = 0): <none>
[17:42:26.307] {
[17:42:26.307]     {
[17:42:26.307]         {
[17:42:26.307]             ...future.startTime <- base::Sys.time()
[17:42:26.307]             {
[17:42:26.307]                 {
[17:42:26.307]                   {
[17:42:26.307]                     {
[17:42:26.307]                       {
[17:42:26.307]                         base::local({
[17:42:26.307]                           has_future <- base::requireNamespace("future", 
[17:42:26.307]                             quietly = TRUE)
[17:42:26.307]                           if (has_future) {
[17:42:26.307]                             ns <- base::getNamespace("future")
[17:42:26.307]                             version <- ns[[".package"]][["version"]]
[17:42:26.307]                             if (is.null(version)) 
[17:42:26.307]                               version <- utils::packageVersion("future")
[17:42:26.307]                           }
[17:42:26.307]                           else {
[17:42:26.307]                             version <- NULL
[17:42:26.307]                           }
[17:42:26.307]                           if (!has_future || version < "1.8.0") {
[17:42:26.307]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:26.307]                               "", base::R.version$version.string), 
[17:42:26.307]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:26.307]                                 base::R.version$platform, 8 * 
[17:42:26.307]                                   base::.Machine$sizeof.pointer), 
[17:42:26.307]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:26.307]                                 "release", "version")], collapse = " "), 
[17:42:26.307]                               hostname = base::Sys.info()[["nodename"]])
[17:42:26.307]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:26.307]                               info)
[17:42:26.307]                             info <- base::paste(info, collapse = "; ")
[17:42:26.307]                             if (!has_future) {
[17:42:26.307]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:26.307]                                 info)
[17:42:26.307]                             }
[17:42:26.307]                             else {
[17:42:26.307]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:26.307]                                 info, version)
[17:42:26.307]                             }
[17:42:26.307]                             base::stop(msg)
[17:42:26.307]                           }
[17:42:26.307]                         })
[17:42:26.307]                       }
[17:42:26.307]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:26.307]                       base::options(mc.cores = 1L)
[17:42:26.307]                     }
[17:42:26.307]                     base::local({
[17:42:26.307]                       for (pkg in "stats") {
[17:42:26.307]                         base::loadNamespace(pkg)
[17:42:26.307]                         base::library(pkg, character.only = TRUE)
[17:42:26.307]                       }
[17:42:26.307]                     })
[17:42:26.307]                   }
[17:42:26.307]                   options(future.plan = NULL)
[17:42:26.307]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:26.307]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:26.307]                 }
[17:42:26.307]                 ...future.workdir <- getwd()
[17:42:26.307]             }
[17:42:26.307]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:26.307]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:26.307]         }
[17:42:26.307]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:26.307]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:26.307]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:26.307]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:26.307]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:26.307]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:26.307]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:26.307]             base::names(...future.oldOptions))
[17:42:26.307]     }
[17:42:26.307]     if (FALSE) {
[17:42:26.307]     }
[17:42:26.307]     else {
[17:42:26.307]         if (TRUE) {
[17:42:26.307]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:26.307]                 open = "w")
[17:42:26.307]         }
[17:42:26.307]         else {
[17:42:26.307]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:26.307]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:26.307]         }
[17:42:26.307]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:26.307]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:26.307]             base::sink(type = "output", split = FALSE)
[17:42:26.307]             base::close(...future.stdout)
[17:42:26.307]         }, add = TRUE)
[17:42:26.307]     }
[17:42:26.307]     ...future.frame <- base::sys.nframe()
[17:42:26.307]     ...future.conditions <- base::list()
[17:42:26.307]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:26.307]     if (FALSE) {
[17:42:26.307]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:26.307]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:26.307]     }
[17:42:26.307]     ...future.result <- base::tryCatch({
[17:42:26.307]         base::withCallingHandlers({
[17:42:26.307]             ...future.value <- base::withVisible(base::local({
[17:42:26.307]                 withCallingHandlers({
[17:42:26.307]                   {
[17:42:26.307]                     xtabs(~x)
[17:42:26.307]                   }
[17:42:26.307]                 }, immediateCondition = function(cond) {
[17:42:26.307]                   save_rds <- function (object, pathname, ...) 
[17:42:26.307]                   {
[17:42:26.307]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:26.307]                     if (file_test("-f", pathname_tmp)) {
[17:42:26.307]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.307]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:26.307]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.307]                         fi_tmp[["mtime"]])
[17:42:26.307]                     }
[17:42:26.307]                     tryCatch({
[17:42:26.307]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:26.307]                     }, error = function(ex) {
[17:42:26.307]                       msg <- conditionMessage(ex)
[17:42:26.307]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.307]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:26.307]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.307]                         fi_tmp[["mtime"]], msg)
[17:42:26.307]                       ex$message <- msg
[17:42:26.307]                       stop(ex)
[17:42:26.307]                     })
[17:42:26.307]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:26.307]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:26.307]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:26.307]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.307]                       fi <- file.info(pathname)
[17:42:26.307]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:26.307]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.307]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:26.307]                         fi[["size"]], fi[["mtime"]])
[17:42:26.307]                       stop(msg)
[17:42:26.307]                     }
[17:42:26.307]                     invisible(pathname)
[17:42:26.307]                   }
[17:42:26.307]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:26.307]                     rootPath = tempdir()) 
[17:42:26.307]                   {
[17:42:26.307]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:26.307]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:26.307]                       tmpdir = path, fileext = ".rds")
[17:42:26.307]                     save_rds(obj, file)
[17:42:26.307]                   }
[17:42:26.307]                   saveImmediateCondition(cond, path = "/tmp/RtmpNwFxwa/.future/immediateConditions")
[17:42:26.307]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.307]                   {
[17:42:26.307]                     inherits <- base::inherits
[17:42:26.307]                     invokeRestart <- base::invokeRestart
[17:42:26.307]                     is.null <- base::is.null
[17:42:26.307]                     muffled <- FALSE
[17:42:26.307]                     if (inherits(cond, "message")) {
[17:42:26.307]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:26.307]                       if (muffled) 
[17:42:26.307]                         invokeRestart("muffleMessage")
[17:42:26.307]                     }
[17:42:26.307]                     else if (inherits(cond, "warning")) {
[17:42:26.307]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:26.307]                       if (muffled) 
[17:42:26.307]                         invokeRestart("muffleWarning")
[17:42:26.307]                     }
[17:42:26.307]                     else if (inherits(cond, "condition")) {
[17:42:26.307]                       if (!is.null(pattern)) {
[17:42:26.307]                         computeRestarts <- base::computeRestarts
[17:42:26.307]                         grepl <- base::grepl
[17:42:26.307]                         restarts <- computeRestarts(cond)
[17:42:26.307]                         for (restart in restarts) {
[17:42:26.307]                           name <- restart$name
[17:42:26.307]                           if (is.null(name)) 
[17:42:26.307]                             next
[17:42:26.307]                           if (!grepl(pattern, name)) 
[17:42:26.307]                             next
[17:42:26.307]                           invokeRestart(restart)
[17:42:26.307]                           muffled <- TRUE
[17:42:26.307]                           break
[17:42:26.307]                         }
[17:42:26.307]                       }
[17:42:26.307]                     }
[17:42:26.307]                     invisible(muffled)
[17:42:26.307]                   }
[17:42:26.307]                   muffleCondition(cond)
[17:42:26.307]                 })
[17:42:26.307]             }))
[17:42:26.307]             future::FutureResult(value = ...future.value$value, 
[17:42:26.307]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:26.307]                   ...future.rng), globalenv = if (FALSE) 
[17:42:26.307]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:26.307]                     ...future.globalenv.names))
[17:42:26.307]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:26.307]         }, condition = base::local({
[17:42:26.307]             c <- base::c
[17:42:26.307]             inherits <- base::inherits
[17:42:26.307]             invokeRestart <- base::invokeRestart
[17:42:26.307]             length <- base::length
[17:42:26.307]             list <- base::list
[17:42:26.307]             seq.int <- base::seq.int
[17:42:26.307]             signalCondition <- base::signalCondition
[17:42:26.307]             sys.calls <- base::sys.calls
[17:42:26.307]             `[[` <- base::`[[`
[17:42:26.307]             `+` <- base::`+`
[17:42:26.307]             `<<-` <- base::`<<-`
[17:42:26.307]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:26.307]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:26.307]                   3L)]
[17:42:26.307]             }
[17:42:26.307]             function(cond) {
[17:42:26.307]                 is_error <- inherits(cond, "error")
[17:42:26.307]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:26.307]                   NULL)
[17:42:26.307]                 if (is_error) {
[17:42:26.307]                   sessionInformation <- function() {
[17:42:26.307]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:26.307]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:26.307]                       search = base::search(), system = base::Sys.info())
[17:42:26.307]                   }
[17:42:26.307]                   ...future.conditions[[length(...future.conditions) + 
[17:42:26.307]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:26.307]                     cond$call), session = sessionInformation(), 
[17:42:26.307]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:26.307]                   signalCondition(cond)
[17:42:26.307]                 }
[17:42:26.307]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:26.307]                 "immediateCondition"))) {
[17:42:26.307]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:26.307]                   ...future.conditions[[length(...future.conditions) + 
[17:42:26.307]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:26.307]                   if (TRUE && !signal) {
[17:42:26.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.307]                     {
[17:42:26.307]                       inherits <- base::inherits
[17:42:26.307]                       invokeRestart <- base::invokeRestart
[17:42:26.307]                       is.null <- base::is.null
[17:42:26.307]                       muffled <- FALSE
[17:42:26.307]                       if (inherits(cond, "message")) {
[17:42:26.307]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:26.307]                         if (muffled) 
[17:42:26.307]                           invokeRestart("muffleMessage")
[17:42:26.307]                       }
[17:42:26.307]                       else if (inherits(cond, "warning")) {
[17:42:26.307]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:26.307]                         if (muffled) 
[17:42:26.307]                           invokeRestart("muffleWarning")
[17:42:26.307]                       }
[17:42:26.307]                       else if (inherits(cond, "condition")) {
[17:42:26.307]                         if (!is.null(pattern)) {
[17:42:26.307]                           computeRestarts <- base::computeRestarts
[17:42:26.307]                           grepl <- base::grepl
[17:42:26.307]                           restarts <- computeRestarts(cond)
[17:42:26.307]                           for (restart in restarts) {
[17:42:26.307]                             name <- restart$name
[17:42:26.307]                             if (is.null(name)) 
[17:42:26.307]                               next
[17:42:26.307]                             if (!grepl(pattern, name)) 
[17:42:26.307]                               next
[17:42:26.307]                             invokeRestart(restart)
[17:42:26.307]                             muffled <- TRUE
[17:42:26.307]                             break
[17:42:26.307]                           }
[17:42:26.307]                         }
[17:42:26.307]                       }
[17:42:26.307]                       invisible(muffled)
[17:42:26.307]                     }
[17:42:26.307]                     muffleCondition(cond, pattern = "^muffle")
[17:42:26.307]                   }
[17:42:26.307]                 }
[17:42:26.307]                 else {
[17:42:26.307]                   if (TRUE) {
[17:42:26.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.307]                     {
[17:42:26.307]                       inherits <- base::inherits
[17:42:26.307]                       invokeRestart <- base::invokeRestart
[17:42:26.307]                       is.null <- base::is.null
[17:42:26.307]                       muffled <- FALSE
[17:42:26.307]                       if (inherits(cond, "message")) {
[17:42:26.307]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:26.307]                         if (muffled) 
[17:42:26.307]                           invokeRestart("muffleMessage")
[17:42:26.307]                       }
[17:42:26.307]                       else if (inherits(cond, "warning")) {
[17:42:26.307]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:26.307]                         if (muffled) 
[17:42:26.307]                           invokeRestart("muffleWarning")
[17:42:26.307]                       }
[17:42:26.307]                       else if (inherits(cond, "condition")) {
[17:42:26.307]                         if (!is.null(pattern)) {
[17:42:26.307]                           computeRestarts <- base::computeRestarts
[17:42:26.307]                           grepl <- base::grepl
[17:42:26.307]                           restarts <- computeRestarts(cond)
[17:42:26.307]                           for (restart in restarts) {
[17:42:26.307]                             name <- restart$name
[17:42:26.307]                             if (is.null(name)) 
[17:42:26.307]                               next
[17:42:26.307]                             if (!grepl(pattern, name)) 
[17:42:26.307]                               next
[17:42:26.307]                             invokeRestart(restart)
[17:42:26.307]                             muffled <- TRUE
[17:42:26.307]                             break
[17:42:26.307]                           }
[17:42:26.307]                         }
[17:42:26.307]                       }
[17:42:26.307]                       invisible(muffled)
[17:42:26.307]                     }
[17:42:26.307]                     muffleCondition(cond, pattern = "^muffle")
[17:42:26.307]                   }
[17:42:26.307]                 }
[17:42:26.307]             }
[17:42:26.307]         }))
[17:42:26.307]     }, error = function(ex) {
[17:42:26.307]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:26.307]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:26.307]                 ...future.rng), started = ...future.startTime, 
[17:42:26.307]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:26.307]             version = "1.8"), class = "FutureResult")
[17:42:26.307]     }, finally = {
[17:42:26.307]         if (!identical(...future.workdir, getwd())) 
[17:42:26.307]             setwd(...future.workdir)
[17:42:26.307]         {
[17:42:26.307]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:26.307]                 ...future.oldOptions$nwarnings <- NULL
[17:42:26.307]             }
[17:42:26.307]             base::options(...future.oldOptions)
[17:42:26.307]             if (.Platform$OS.type == "windows") {
[17:42:26.307]                 old_names <- names(...future.oldEnvVars)
[17:42:26.307]                 envs <- base::Sys.getenv()
[17:42:26.307]                 names <- names(envs)
[17:42:26.307]                 common <- intersect(names, old_names)
[17:42:26.307]                 added <- setdiff(names, old_names)
[17:42:26.307]                 removed <- setdiff(old_names, names)
[17:42:26.307]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:26.307]                   envs[common]]
[17:42:26.307]                 NAMES <- toupper(changed)
[17:42:26.307]                 args <- list()
[17:42:26.307]                 for (kk in seq_along(NAMES)) {
[17:42:26.307]                   name <- changed[[kk]]
[17:42:26.307]                   NAME <- NAMES[[kk]]
[17:42:26.307]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.307]                     next
[17:42:26.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:26.307]                 }
[17:42:26.307]                 NAMES <- toupper(added)
[17:42:26.307]                 for (kk in seq_along(NAMES)) {
[17:42:26.307]                   name <- added[[kk]]
[17:42:26.307]                   NAME <- NAMES[[kk]]
[17:42:26.307]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.307]                     next
[17:42:26.307]                   args[[name]] <- ""
[17:42:26.307]                 }
[17:42:26.307]                 NAMES <- toupper(removed)
[17:42:26.307]                 for (kk in seq_along(NAMES)) {
[17:42:26.307]                   name <- removed[[kk]]
[17:42:26.307]                   NAME <- NAMES[[kk]]
[17:42:26.307]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.307]                     next
[17:42:26.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:26.307]                 }
[17:42:26.307]                 if (length(args) > 0) 
[17:42:26.307]                   base::do.call(base::Sys.setenv, args = args)
[17:42:26.307]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:26.307]             }
[17:42:26.307]             else {
[17:42:26.307]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:26.307]             }
[17:42:26.307]             {
[17:42:26.307]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:26.307]                   0L) {
[17:42:26.307]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:26.307]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:26.307]                   base::options(opts)
[17:42:26.307]                 }
[17:42:26.307]                 {
[17:42:26.307]                   {
[17:42:26.307]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:26.307]                     NULL
[17:42:26.307]                   }
[17:42:26.307]                   options(future.plan = NULL)
[17:42:26.307]                   if (is.na(NA_character_)) 
[17:42:26.307]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:26.307]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:26.307]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:26.307]                     envir = parent.frame()) 
[17:42:26.307]                   {
[17:42:26.307]                     default_workers <- missing(workers)
[17:42:26.307]                     if (is.function(workers)) 
[17:42:26.307]                       workers <- workers()
[17:42:26.307]                     workers <- structure(as.integer(workers), 
[17:42:26.307]                       class = class(workers))
[17:42:26.307]                     stop_if_not(is.finite(workers), workers >= 
[17:42:26.307]                       1L)
[17:42:26.307]                     if ((workers == 1L && !inherits(workers, 
[17:42:26.307]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:26.307]                       if (default_workers) 
[17:42:26.307]                         supportsMulticore(warn = TRUE)
[17:42:26.307]                       return(sequential(..., envir = envir))
[17:42:26.307]                     }
[17:42:26.307]                     oopts <- options(mc.cores = workers)
[17:42:26.307]                     on.exit(options(oopts))
[17:42:26.307]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:26.307]                       envir = envir)
[17:42:26.307]                     if (!future$lazy) 
[17:42:26.307]                       future <- run(future)
[17:42:26.307]                     invisible(future)
[17:42:26.307]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:26.307]                 }
[17:42:26.307]             }
[17:42:26.307]         }
[17:42:26.307]     })
[17:42:26.307]     if (TRUE) {
[17:42:26.307]         base::sink(type = "output", split = FALSE)
[17:42:26.307]         if (TRUE) {
[17:42:26.307]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:26.307]         }
[17:42:26.307]         else {
[17:42:26.307]             ...future.result["stdout"] <- base::list(NULL)
[17:42:26.307]         }
[17:42:26.307]         base::close(...future.stdout)
[17:42:26.307]         ...future.stdout <- NULL
[17:42:26.307]     }
[17:42:26.307]     ...future.result$conditions <- ...future.conditions
[17:42:26.307]     ...future.result$finished <- base::Sys.time()
[17:42:26.307]     ...future.result
[17:42:26.307] }
[17:42:26.309] assign_globals() ...
[17:42:26.309] List of 1
[17:42:26.309]  $ x: num [1:5] 1 1 2 2 2
[17:42:26.309]  - attr(*, "where")=List of 1
[17:42:26.309]   ..$ x:<environment: R_EmptyEnv> 
[17:42:26.309]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:26.309]  - attr(*, "resolved")= logi FALSE
[17:42:26.309]  - attr(*, "total_size")= num 96
[17:42:26.309]  - attr(*, "already-done")= logi TRUE
[17:42:26.313] - copied ‘x’ to environment
[17:42:26.313] assign_globals() ... done
[17:42:26.313] requestCore(): workers = 2
[17:42:26.315] MulticoreFuture started
[17:42:26.316] - Launch lazy future ... done
[17:42:26.316] run() for ‘MulticoreFuture’ ... done
[17:42:26.317] plan(): Setting new future strategy stack:
[17:42:26.317] List of future strategies:
[17:42:26.317] 1. sequential:
[17:42:26.317]    - args: function (..., envir = parent.frame())
[17:42:26.317]    - tweaked: FALSE
[17:42:26.317]    - call: NULL
[17:42:26.318] plan(): nbrOfWorkers() = 1
[17:42:26.321] plan(): Setting new future strategy stack:
[17:42:26.321] List of future strategies:
[17:42:26.321] 1. multicore:
[17:42:26.321]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:26.321]    - tweaked: FALSE
[17:42:26.321]    - call: plan(strategy)
[17:42:26.326] plan(): nbrOfWorkers() = 2
x
1 2 
2 3 
[17:42:26.328] getGlobalsAndPackages() ...
[17:42:26.328] Searching for globals...
[17:42:26.330] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[17:42:26.330] Searching for globals ... DONE
[17:42:26.331] Resolving globals: FALSE
[17:42:26.331] The total size of the 1 globals is 96 bytes (96 bytes)
[17:42:26.332] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[17:42:26.332] - globals: [1] ‘x’
[17:42:26.332] - packages: [1] ‘stats’
[17:42:26.332] getGlobalsAndPackages() ... DONE
[17:42:26.332] run() for ‘Future’ ...
[17:42:26.333] - state: ‘created’
[17:42:26.333] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:26.337] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:26.337] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:26.337]   - Field: ‘label’
[17:42:26.338]   - Field: ‘local’
[17:42:26.338]   - Field: ‘owner’
[17:42:26.338]   - Field: ‘envir’
[17:42:26.338]   - Field: ‘workers’
[17:42:26.338]   - Field: ‘packages’
[17:42:26.338]   - Field: ‘gc’
[17:42:26.338]   - Field: ‘job’
[17:42:26.338]   - Field: ‘conditions’
[17:42:26.339]   - Field: ‘expr’
[17:42:26.339]   - Field: ‘uuid’
[17:42:26.339]   - Field: ‘seed’
[17:42:26.339]   - Field: ‘version’
[17:42:26.339]   - Field: ‘result’
[17:42:26.339]   - Field: ‘asynchronous’
[17:42:26.339]   - Field: ‘calls’
[17:42:26.339]   - Field: ‘globals’
[17:42:26.339]   - Field: ‘stdout’
[17:42:26.340]   - Field: ‘earlySignal’
[17:42:26.340]   - Field: ‘lazy’
[17:42:26.340]   - Field: ‘state’
[17:42:26.340] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:26.340] - Launch lazy future ...
[17:42:26.340] Packages needed by the future expression (n = 1): ‘stats’
[17:42:26.341] Packages needed by future strategies (n = 0): <none>
[17:42:26.341] {
[17:42:26.341]     {
[17:42:26.341]         {
[17:42:26.341]             ...future.startTime <- base::Sys.time()
[17:42:26.341]             {
[17:42:26.341]                 {
[17:42:26.341]                   {
[17:42:26.341]                     {
[17:42:26.341]                       {
[17:42:26.341]                         base::local({
[17:42:26.341]                           has_future <- base::requireNamespace("future", 
[17:42:26.341]                             quietly = TRUE)
[17:42:26.341]                           if (has_future) {
[17:42:26.341]                             ns <- base::getNamespace("future")
[17:42:26.341]                             version <- ns[[".package"]][["version"]]
[17:42:26.341]                             if (is.null(version)) 
[17:42:26.341]                               version <- utils::packageVersion("future")
[17:42:26.341]                           }
[17:42:26.341]                           else {
[17:42:26.341]                             version <- NULL
[17:42:26.341]                           }
[17:42:26.341]                           if (!has_future || version < "1.8.0") {
[17:42:26.341]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:26.341]                               "", base::R.version$version.string), 
[17:42:26.341]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:26.341]                                 base::R.version$platform, 8 * 
[17:42:26.341]                                   base::.Machine$sizeof.pointer), 
[17:42:26.341]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:26.341]                                 "release", "version")], collapse = " "), 
[17:42:26.341]                               hostname = base::Sys.info()[["nodename"]])
[17:42:26.341]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:26.341]                               info)
[17:42:26.341]                             info <- base::paste(info, collapse = "; ")
[17:42:26.341]                             if (!has_future) {
[17:42:26.341]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:26.341]                                 info)
[17:42:26.341]                             }
[17:42:26.341]                             else {
[17:42:26.341]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:26.341]                                 info, version)
[17:42:26.341]                             }
[17:42:26.341]                             base::stop(msg)
[17:42:26.341]                           }
[17:42:26.341]                         })
[17:42:26.341]                       }
[17:42:26.341]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:26.341]                       base::options(mc.cores = 1L)
[17:42:26.341]                     }
[17:42:26.341]                     base::local({
[17:42:26.341]                       for (pkg in "stats") {
[17:42:26.341]                         base::loadNamespace(pkg)
[17:42:26.341]                         base::library(pkg, character.only = TRUE)
[17:42:26.341]                       }
[17:42:26.341]                     })
[17:42:26.341]                   }
[17:42:26.341]                   options(future.plan = NULL)
[17:42:26.341]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:26.341]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:26.341]                 }
[17:42:26.341]                 ...future.workdir <- getwd()
[17:42:26.341]             }
[17:42:26.341]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:26.341]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:26.341]         }
[17:42:26.341]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:26.341]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:26.341]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:26.341]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:26.341]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:26.341]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:26.341]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:26.341]             base::names(...future.oldOptions))
[17:42:26.341]     }
[17:42:26.341]     if (FALSE) {
[17:42:26.341]     }
[17:42:26.341]     else {
[17:42:26.341]         if (TRUE) {
[17:42:26.341]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:26.341]                 open = "w")
[17:42:26.341]         }
[17:42:26.341]         else {
[17:42:26.341]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:26.341]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:26.341]         }
[17:42:26.341]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:26.341]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:26.341]             base::sink(type = "output", split = FALSE)
[17:42:26.341]             base::close(...future.stdout)
[17:42:26.341]         }, add = TRUE)
[17:42:26.341]     }
[17:42:26.341]     ...future.frame <- base::sys.nframe()
[17:42:26.341]     ...future.conditions <- base::list()
[17:42:26.341]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:26.341]     if (FALSE) {
[17:42:26.341]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:26.341]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:26.341]     }
[17:42:26.341]     ...future.result <- base::tryCatch({
[17:42:26.341]         base::withCallingHandlers({
[17:42:26.341]             ...future.value <- base::withVisible(base::local({
[17:42:26.341]                 withCallingHandlers({
[17:42:26.341]                   {
[17:42:26.341]                     xtabs(~x)
[17:42:26.341]                   }
[17:42:26.341]                 }, immediateCondition = function(cond) {
[17:42:26.341]                   save_rds <- function (object, pathname, ...) 
[17:42:26.341]                   {
[17:42:26.341]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:26.341]                     if (file_test("-f", pathname_tmp)) {
[17:42:26.341]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.341]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:26.341]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.341]                         fi_tmp[["mtime"]])
[17:42:26.341]                     }
[17:42:26.341]                     tryCatch({
[17:42:26.341]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:26.341]                     }, error = function(ex) {
[17:42:26.341]                       msg <- conditionMessage(ex)
[17:42:26.341]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.341]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:26.341]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.341]                         fi_tmp[["mtime"]], msg)
[17:42:26.341]                       ex$message <- msg
[17:42:26.341]                       stop(ex)
[17:42:26.341]                     })
[17:42:26.341]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:26.341]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:26.341]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:26.341]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.341]                       fi <- file.info(pathname)
[17:42:26.341]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:26.341]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.341]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:26.341]                         fi[["size"]], fi[["mtime"]])
[17:42:26.341]                       stop(msg)
[17:42:26.341]                     }
[17:42:26.341]                     invisible(pathname)
[17:42:26.341]                   }
[17:42:26.341]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:26.341]                     rootPath = tempdir()) 
[17:42:26.341]                   {
[17:42:26.341]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:26.341]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:26.341]                       tmpdir = path, fileext = ".rds")
[17:42:26.341]                     save_rds(obj, file)
[17:42:26.341]                   }
[17:42:26.341]                   saveImmediateCondition(cond, path = "/tmp/RtmpNwFxwa/.future/immediateConditions")
[17:42:26.341]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.341]                   {
[17:42:26.341]                     inherits <- base::inherits
[17:42:26.341]                     invokeRestart <- base::invokeRestart
[17:42:26.341]                     is.null <- base::is.null
[17:42:26.341]                     muffled <- FALSE
[17:42:26.341]                     if (inherits(cond, "message")) {
[17:42:26.341]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:26.341]                       if (muffled) 
[17:42:26.341]                         invokeRestart("muffleMessage")
[17:42:26.341]                     }
[17:42:26.341]                     else if (inherits(cond, "warning")) {
[17:42:26.341]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:26.341]                       if (muffled) 
[17:42:26.341]                         invokeRestart("muffleWarning")
[17:42:26.341]                     }
[17:42:26.341]                     else if (inherits(cond, "condition")) {
[17:42:26.341]                       if (!is.null(pattern)) {
[17:42:26.341]                         computeRestarts <- base::computeRestarts
[17:42:26.341]                         grepl <- base::grepl
[17:42:26.341]                         restarts <- computeRestarts(cond)
[17:42:26.341]                         for (restart in restarts) {
[17:42:26.341]                           name <- restart$name
[17:42:26.341]                           if (is.null(name)) 
[17:42:26.341]                             next
[17:42:26.341]                           if (!grepl(pattern, name)) 
[17:42:26.341]                             next
[17:42:26.341]                           invokeRestart(restart)
[17:42:26.341]                           muffled <- TRUE
[17:42:26.341]                           break
[17:42:26.341]                         }
[17:42:26.341]                       }
[17:42:26.341]                     }
[17:42:26.341]                     invisible(muffled)
[17:42:26.341]                   }
[17:42:26.341]                   muffleCondition(cond)
[17:42:26.341]                 })
[17:42:26.341]             }))
[17:42:26.341]             future::FutureResult(value = ...future.value$value, 
[17:42:26.341]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:26.341]                   ...future.rng), globalenv = if (FALSE) 
[17:42:26.341]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:26.341]                     ...future.globalenv.names))
[17:42:26.341]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:26.341]         }, condition = base::local({
[17:42:26.341]             c <- base::c
[17:42:26.341]             inherits <- base::inherits
[17:42:26.341]             invokeRestart <- base::invokeRestart
[17:42:26.341]             length <- base::length
[17:42:26.341]             list <- base::list
[17:42:26.341]             seq.int <- base::seq.int
[17:42:26.341]             signalCondition <- base::signalCondition
[17:42:26.341]             sys.calls <- base::sys.calls
[17:42:26.341]             `[[` <- base::`[[`
[17:42:26.341]             `+` <- base::`+`
[17:42:26.341]             `<<-` <- base::`<<-`
[17:42:26.341]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:26.341]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:26.341]                   3L)]
[17:42:26.341]             }
[17:42:26.341]             function(cond) {
[17:42:26.341]                 is_error <- inherits(cond, "error")
[17:42:26.341]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:26.341]                   NULL)
[17:42:26.341]                 if (is_error) {
[17:42:26.341]                   sessionInformation <- function() {
[17:42:26.341]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:26.341]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:26.341]                       search = base::search(), system = base::Sys.info())
[17:42:26.341]                   }
[17:42:26.341]                   ...future.conditions[[length(...future.conditions) + 
[17:42:26.341]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:26.341]                     cond$call), session = sessionInformation(), 
[17:42:26.341]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:26.341]                   signalCondition(cond)
[17:42:26.341]                 }
[17:42:26.341]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:26.341]                 "immediateCondition"))) {
[17:42:26.341]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:26.341]                   ...future.conditions[[length(...future.conditions) + 
[17:42:26.341]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:26.341]                   if (TRUE && !signal) {
[17:42:26.341]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.341]                     {
[17:42:26.341]                       inherits <- base::inherits
[17:42:26.341]                       invokeRestart <- base::invokeRestart
[17:42:26.341]                       is.null <- base::is.null
[17:42:26.341]                       muffled <- FALSE
[17:42:26.341]                       if (inherits(cond, "message")) {
[17:42:26.341]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:26.341]                         if (muffled) 
[17:42:26.341]                           invokeRestart("muffleMessage")
[17:42:26.341]                       }
[17:42:26.341]                       else if (inherits(cond, "warning")) {
[17:42:26.341]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:26.341]                         if (muffled) 
[17:42:26.341]                           invokeRestart("muffleWarning")
[17:42:26.341]                       }
[17:42:26.341]                       else if (inherits(cond, "condition")) {
[17:42:26.341]                         if (!is.null(pattern)) {
[17:42:26.341]                           computeRestarts <- base::computeRestarts
[17:42:26.341]                           grepl <- base::grepl
[17:42:26.341]                           restarts <- computeRestarts(cond)
[17:42:26.341]                           for (restart in restarts) {
[17:42:26.341]                             name <- restart$name
[17:42:26.341]                             if (is.null(name)) 
[17:42:26.341]                               next
[17:42:26.341]                             if (!grepl(pattern, name)) 
[17:42:26.341]                               next
[17:42:26.341]                             invokeRestart(restart)
[17:42:26.341]                             muffled <- TRUE
[17:42:26.341]                             break
[17:42:26.341]                           }
[17:42:26.341]                         }
[17:42:26.341]                       }
[17:42:26.341]                       invisible(muffled)
[17:42:26.341]                     }
[17:42:26.341]                     muffleCondition(cond, pattern = "^muffle")
[17:42:26.341]                   }
[17:42:26.341]                 }
[17:42:26.341]                 else {
[17:42:26.341]                   if (TRUE) {
[17:42:26.341]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.341]                     {
[17:42:26.341]                       inherits <- base::inherits
[17:42:26.341]                       invokeRestart <- base::invokeRestart
[17:42:26.341]                       is.null <- base::is.null
[17:42:26.341]                       muffled <- FALSE
[17:42:26.341]                       if (inherits(cond, "message")) {
[17:42:26.341]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:26.341]                         if (muffled) 
[17:42:26.341]                           invokeRestart("muffleMessage")
[17:42:26.341]                       }
[17:42:26.341]                       else if (inherits(cond, "warning")) {
[17:42:26.341]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:26.341]                         if (muffled) 
[17:42:26.341]                           invokeRestart("muffleWarning")
[17:42:26.341]                       }
[17:42:26.341]                       else if (inherits(cond, "condition")) {
[17:42:26.341]                         if (!is.null(pattern)) {
[17:42:26.341]                           computeRestarts <- base::computeRestarts
[17:42:26.341]                           grepl <- base::grepl
[17:42:26.341]                           restarts <- computeRestarts(cond)
[17:42:26.341]                           for (restart in restarts) {
[17:42:26.341]                             name <- restart$name
[17:42:26.341]                             if (is.null(name)) 
[17:42:26.341]                               next
[17:42:26.341]                             if (!grepl(pattern, name)) 
[17:42:26.341]                               next
[17:42:26.341]                             invokeRestart(restart)
[17:42:26.341]                             muffled <- TRUE
[17:42:26.341]                             break
[17:42:26.341]                           }
[17:42:26.341]                         }
[17:42:26.341]                       }
[17:42:26.341]                       invisible(muffled)
[17:42:26.341]                     }
[17:42:26.341]                     muffleCondition(cond, pattern = "^muffle")
[17:42:26.341]                   }
[17:42:26.341]                 }
[17:42:26.341]             }
[17:42:26.341]         }))
[17:42:26.341]     }, error = function(ex) {
[17:42:26.341]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:26.341]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:26.341]                 ...future.rng), started = ...future.startTime, 
[17:42:26.341]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:26.341]             version = "1.8"), class = "FutureResult")
[17:42:26.341]     }, finally = {
[17:42:26.341]         if (!identical(...future.workdir, getwd())) 
[17:42:26.341]             setwd(...future.workdir)
[17:42:26.341]         {
[17:42:26.341]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:26.341]                 ...future.oldOptions$nwarnings <- NULL
[17:42:26.341]             }
[17:42:26.341]             base::options(...future.oldOptions)
[17:42:26.341]             if (.Platform$OS.type == "windows") {
[17:42:26.341]                 old_names <- names(...future.oldEnvVars)
[17:42:26.341]                 envs <- base::Sys.getenv()
[17:42:26.341]                 names <- names(envs)
[17:42:26.341]                 common <- intersect(names, old_names)
[17:42:26.341]                 added <- setdiff(names, old_names)
[17:42:26.341]                 removed <- setdiff(old_names, names)
[17:42:26.341]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:26.341]                   envs[common]]
[17:42:26.341]                 NAMES <- toupper(changed)
[17:42:26.341]                 args <- list()
[17:42:26.341]                 for (kk in seq_along(NAMES)) {
[17:42:26.341]                   name <- changed[[kk]]
[17:42:26.341]                   NAME <- NAMES[[kk]]
[17:42:26.341]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.341]                     next
[17:42:26.341]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:26.341]                 }
[17:42:26.341]                 NAMES <- toupper(added)
[17:42:26.341]                 for (kk in seq_along(NAMES)) {
[17:42:26.341]                   name <- added[[kk]]
[17:42:26.341]                   NAME <- NAMES[[kk]]
[17:42:26.341]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.341]                     next
[17:42:26.341]                   args[[name]] <- ""
[17:42:26.341]                 }
[17:42:26.341]                 NAMES <- toupper(removed)
[17:42:26.341]                 for (kk in seq_along(NAMES)) {
[17:42:26.341]                   name <- removed[[kk]]
[17:42:26.341]                   NAME <- NAMES[[kk]]
[17:42:26.341]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.341]                     next
[17:42:26.341]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:26.341]                 }
[17:42:26.341]                 if (length(args) > 0) 
[17:42:26.341]                   base::do.call(base::Sys.setenv, args = args)
[17:42:26.341]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:26.341]             }
[17:42:26.341]             else {
[17:42:26.341]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:26.341]             }
[17:42:26.341]             {
[17:42:26.341]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:26.341]                   0L) {
[17:42:26.341]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:26.341]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:26.341]                   base::options(opts)
[17:42:26.341]                 }
[17:42:26.341]                 {
[17:42:26.341]                   {
[17:42:26.341]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:26.341]                     NULL
[17:42:26.341]                   }
[17:42:26.341]                   options(future.plan = NULL)
[17:42:26.341]                   if (is.na(NA_character_)) 
[17:42:26.341]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:26.341]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:26.341]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:26.341]                     envir = parent.frame()) 
[17:42:26.341]                   {
[17:42:26.341]                     default_workers <- missing(workers)
[17:42:26.341]                     if (is.function(workers)) 
[17:42:26.341]                       workers <- workers()
[17:42:26.341]                     workers <- structure(as.integer(workers), 
[17:42:26.341]                       class = class(workers))
[17:42:26.341]                     stop_if_not(is.finite(workers), workers >= 
[17:42:26.341]                       1L)
[17:42:26.341]                     if ((workers == 1L && !inherits(workers, 
[17:42:26.341]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:26.341]                       if (default_workers) 
[17:42:26.341]                         supportsMulticore(warn = TRUE)
[17:42:26.341]                       return(sequential(..., envir = envir))
[17:42:26.341]                     }
[17:42:26.341]                     oopts <- options(mc.cores = workers)
[17:42:26.341]                     on.exit(options(oopts))
[17:42:26.341]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:26.341]                       envir = envir)
[17:42:26.341]                     if (!future$lazy) 
[17:42:26.341]                       future <- run(future)
[17:42:26.341]                     invisible(future)
[17:42:26.341]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:26.341]                 }
[17:42:26.341]             }
[17:42:26.341]         }
[17:42:26.341]     })
[17:42:26.341]     if (TRUE) {
[17:42:26.341]         base::sink(type = "output", split = FALSE)
[17:42:26.341]         if (TRUE) {
[17:42:26.341]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:26.341]         }
[17:42:26.341]         else {
[17:42:26.341]             ...future.result["stdout"] <- base::list(NULL)
[17:42:26.341]         }
[17:42:26.341]         base::close(...future.stdout)
[17:42:26.341]         ...future.stdout <- NULL
[17:42:26.341]     }
[17:42:26.341]     ...future.result$conditions <- ...future.conditions
[17:42:26.341]     ...future.result$finished <- base::Sys.time()
[17:42:26.341]     ...future.result
[17:42:26.341] }
[17:42:26.344] assign_globals() ...
[17:42:26.344] List of 1
[17:42:26.344]  $ x: num [1:5] 1 1 2 2 2
[17:42:26.344]  - attr(*, "where")=List of 1
[17:42:26.344]   ..$ x:<environment: R_EmptyEnv> 
[17:42:26.344]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:26.344]  - attr(*, "resolved")= logi FALSE
[17:42:26.344]  - attr(*, "total_size")= num 96
[17:42:26.344]  - attr(*, "already-done")= logi TRUE
[17:42:26.350] - copied ‘x’ to environment
[17:42:26.350] assign_globals() ... done
[17:42:26.350] requestCore(): workers = 2
[17:42:26.353] MulticoreFuture started
[17:42:26.353] - Launch lazy future ... done
[17:42:26.353] run() for ‘MulticoreFuture’ ... done
[17:42:26.354] plan(): Setting new future strategy stack:
[17:42:26.354] List of future strategies:
[17:42:26.354] 1. sequential:
[17:42:26.354]    - args: function (..., envir = parent.frame())
[17:42:26.354]    - tweaked: FALSE
[17:42:26.354]    - call: NULL
[17:42:26.355] plan(): nbrOfWorkers() = 1
[17:42:26.358] plan(): Setting new future strategy stack:
[17:42:26.358] List of future strategies:
[17:42:26.358] 1. multicore:
[17:42:26.358]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:26.358]    - tweaked: FALSE
[17:42:26.358]    - call: plan(strategy)
[17:42:26.365] plan(): nbrOfWorkers() = 2
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[17:42:26.368] getGlobalsAndPackages() ...
[17:42:26.368] Searching for globals...
[17:42:26.371] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[17:42:26.371] Searching for globals ... DONE
[17:42:26.371] Resolving globals: FALSE
[17:42:26.372] 
[17:42:26.372] - packages: [2] ‘stats’, ‘datasets’
[17:42:26.372] getGlobalsAndPackages() ... DONE
[17:42:26.373] run() for ‘Future’ ...
[17:42:26.373] - state: ‘created’
[17:42:26.373] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:26.377] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:26.377] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:26.378]   - Field: ‘label’
[17:42:26.378]   - Field: ‘local’
[17:42:26.378]   - Field: ‘owner’
[17:42:26.378]   - Field: ‘envir’
[17:42:26.378]   - Field: ‘workers’
[17:42:26.378]   - Field: ‘packages’
[17:42:26.378]   - Field: ‘gc’
[17:42:26.378]   - Field: ‘job’
[17:42:26.378]   - Field: ‘conditions’
[17:42:26.379]   - Field: ‘expr’
[17:42:26.379]   - Field: ‘uuid’
[17:42:26.379]   - Field: ‘seed’
[17:42:26.379]   - Field: ‘version’
[17:42:26.379]   - Field: ‘result’
[17:42:26.379]   - Field: ‘asynchronous’
[17:42:26.379]   - Field: ‘calls’
[17:42:26.379]   - Field: ‘globals’
[17:42:26.380]   - Field: ‘stdout’
[17:42:26.380]   - Field: ‘earlySignal’
[17:42:26.380]   - Field: ‘lazy’
[17:42:26.380]   - Field: ‘state’
[17:42:26.380] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:26.380] - Launch lazy future ...
[17:42:26.381] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:42:26.381] Packages needed by future strategies (n = 0): <none>
[17:42:26.381] {
[17:42:26.381]     {
[17:42:26.381]         {
[17:42:26.381]             ...future.startTime <- base::Sys.time()
[17:42:26.381]             {
[17:42:26.381]                 {
[17:42:26.381]                   {
[17:42:26.381]                     {
[17:42:26.381]                       {
[17:42:26.381]                         base::local({
[17:42:26.381]                           has_future <- base::requireNamespace("future", 
[17:42:26.381]                             quietly = TRUE)
[17:42:26.381]                           if (has_future) {
[17:42:26.381]                             ns <- base::getNamespace("future")
[17:42:26.381]                             version <- ns[[".package"]][["version"]]
[17:42:26.381]                             if (is.null(version)) 
[17:42:26.381]                               version <- utils::packageVersion("future")
[17:42:26.381]                           }
[17:42:26.381]                           else {
[17:42:26.381]                             version <- NULL
[17:42:26.381]                           }
[17:42:26.381]                           if (!has_future || version < "1.8.0") {
[17:42:26.381]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:26.381]                               "", base::R.version$version.string), 
[17:42:26.381]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:26.381]                                 base::R.version$platform, 8 * 
[17:42:26.381]                                   base::.Machine$sizeof.pointer), 
[17:42:26.381]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:26.381]                                 "release", "version")], collapse = " "), 
[17:42:26.381]                               hostname = base::Sys.info()[["nodename"]])
[17:42:26.381]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:26.381]                               info)
[17:42:26.381]                             info <- base::paste(info, collapse = "; ")
[17:42:26.381]                             if (!has_future) {
[17:42:26.381]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:26.381]                                 info)
[17:42:26.381]                             }
[17:42:26.381]                             else {
[17:42:26.381]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:26.381]                                 info, version)
[17:42:26.381]                             }
[17:42:26.381]                             base::stop(msg)
[17:42:26.381]                           }
[17:42:26.381]                         })
[17:42:26.381]                       }
[17:42:26.381]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:26.381]                       base::options(mc.cores = 1L)
[17:42:26.381]                     }
[17:42:26.381]                     base::local({
[17:42:26.381]                       for (pkg in c("stats", "datasets")) {
[17:42:26.381]                         base::loadNamespace(pkg)
[17:42:26.381]                         base::library(pkg, character.only = TRUE)
[17:42:26.381]                       }
[17:42:26.381]                     })
[17:42:26.381]                   }
[17:42:26.381]                   options(future.plan = NULL)
[17:42:26.381]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:26.381]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:26.381]                 }
[17:42:26.381]                 ...future.workdir <- getwd()
[17:42:26.381]             }
[17:42:26.381]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:26.381]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:26.381]         }
[17:42:26.381]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:26.381]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:26.381]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:26.381]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:26.381]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:26.381]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:26.381]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:26.381]             base::names(...future.oldOptions))
[17:42:26.381]     }
[17:42:26.381]     if (FALSE) {
[17:42:26.381]     }
[17:42:26.381]     else {
[17:42:26.381]         if (TRUE) {
[17:42:26.381]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:26.381]                 open = "w")
[17:42:26.381]         }
[17:42:26.381]         else {
[17:42:26.381]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:26.381]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:26.381]         }
[17:42:26.381]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:26.381]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:26.381]             base::sink(type = "output", split = FALSE)
[17:42:26.381]             base::close(...future.stdout)
[17:42:26.381]         }, add = TRUE)
[17:42:26.381]     }
[17:42:26.381]     ...future.frame <- base::sys.nframe()
[17:42:26.381]     ...future.conditions <- base::list()
[17:42:26.381]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:26.381]     if (FALSE) {
[17:42:26.381]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:26.381]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:26.381]     }
[17:42:26.381]     ...future.result <- base::tryCatch({
[17:42:26.381]         base::withCallingHandlers({
[17:42:26.381]             ...future.value <- base::withVisible(base::local({
[17:42:26.381]                 withCallingHandlers({
[17:42:26.381]                   {
[17:42:26.381]                     lm(dist ~ . - 1, data = cars)
[17:42:26.381]                   }
[17:42:26.381]                 }, immediateCondition = function(cond) {
[17:42:26.381]                   save_rds <- function (object, pathname, ...) 
[17:42:26.381]                   {
[17:42:26.381]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:26.381]                     if (file_test("-f", pathname_tmp)) {
[17:42:26.381]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.381]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:26.381]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.381]                         fi_tmp[["mtime"]])
[17:42:26.381]                     }
[17:42:26.381]                     tryCatch({
[17:42:26.381]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:26.381]                     }, error = function(ex) {
[17:42:26.381]                       msg <- conditionMessage(ex)
[17:42:26.381]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.381]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:26.381]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.381]                         fi_tmp[["mtime"]], msg)
[17:42:26.381]                       ex$message <- msg
[17:42:26.381]                       stop(ex)
[17:42:26.381]                     })
[17:42:26.381]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:26.381]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:26.381]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:26.381]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.381]                       fi <- file.info(pathname)
[17:42:26.381]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:26.381]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.381]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:26.381]                         fi[["size"]], fi[["mtime"]])
[17:42:26.381]                       stop(msg)
[17:42:26.381]                     }
[17:42:26.381]                     invisible(pathname)
[17:42:26.381]                   }
[17:42:26.381]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:26.381]                     rootPath = tempdir()) 
[17:42:26.381]                   {
[17:42:26.381]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:26.381]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:26.381]                       tmpdir = path, fileext = ".rds")
[17:42:26.381]                     save_rds(obj, file)
[17:42:26.381]                   }
[17:42:26.381]                   saveImmediateCondition(cond, path = "/tmp/RtmpNwFxwa/.future/immediateConditions")
[17:42:26.381]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.381]                   {
[17:42:26.381]                     inherits <- base::inherits
[17:42:26.381]                     invokeRestart <- base::invokeRestart
[17:42:26.381]                     is.null <- base::is.null
[17:42:26.381]                     muffled <- FALSE
[17:42:26.381]                     if (inherits(cond, "message")) {
[17:42:26.381]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:26.381]                       if (muffled) 
[17:42:26.381]                         invokeRestart("muffleMessage")
[17:42:26.381]                     }
[17:42:26.381]                     else if (inherits(cond, "warning")) {
[17:42:26.381]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:26.381]                       if (muffled) 
[17:42:26.381]                         invokeRestart("muffleWarning")
[17:42:26.381]                     }
[17:42:26.381]                     else if (inherits(cond, "condition")) {
[17:42:26.381]                       if (!is.null(pattern)) {
[17:42:26.381]                         computeRestarts <- base::computeRestarts
[17:42:26.381]                         grepl <- base::grepl
[17:42:26.381]                         restarts <- computeRestarts(cond)
[17:42:26.381]                         for (restart in restarts) {
[17:42:26.381]                           name <- restart$name
[17:42:26.381]                           if (is.null(name)) 
[17:42:26.381]                             next
[17:42:26.381]                           if (!grepl(pattern, name)) 
[17:42:26.381]                             next
[17:42:26.381]                           invokeRestart(restart)
[17:42:26.381]                           muffled <- TRUE
[17:42:26.381]                           break
[17:42:26.381]                         }
[17:42:26.381]                       }
[17:42:26.381]                     }
[17:42:26.381]                     invisible(muffled)
[17:42:26.381]                   }
[17:42:26.381]                   muffleCondition(cond)
[17:42:26.381]                 })
[17:42:26.381]             }))
[17:42:26.381]             future::FutureResult(value = ...future.value$value, 
[17:42:26.381]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:26.381]                   ...future.rng), globalenv = if (FALSE) 
[17:42:26.381]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:26.381]                     ...future.globalenv.names))
[17:42:26.381]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:26.381]         }, condition = base::local({
[17:42:26.381]             c <- base::c
[17:42:26.381]             inherits <- base::inherits
[17:42:26.381]             invokeRestart <- base::invokeRestart
[17:42:26.381]             length <- base::length
[17:42:26.381]             list <- base::list
[17:42:26.381]             seq.int <- base::seq.int
[17:42:26.381]             signalCondition <- base::signalCondition
[17:42:26.381]             sys.calls <- base::sys.calls
[17:42:26.381]             `[[` <- base::`[[`
[17:42:26.381]             `+` <- base::`+`
[17:42:26.381]             `<<-` <- base::`<<-`
[17:42:26.381]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:26.381]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:26.381]                   3L)]
[17:42:26.381]             }
[17:42:26.381]             function(cond) {
[17:42:26.381]                 is_error <- inherits(cond, "error")
[17:42:26.381]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:26.381]                   NULL)
[17:42:26.381]                 if (is_error) {
[17:42:26.381]                   sessionInformation <- function() {
[17:42:26.381]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:26.381]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:26.381]                       search = base::search(), system = base::Sys.info())
[17:42:26.381]                   }
[17:42:26.381]                   ...future.conditions[[length(...future.conditions) + 
[17:42:26.381]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:26.381]                     cond$call), session = sessionInformation(), 
[17:42:26.381]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:26.381]                   signalCondition(cond)
[17:42:26.381]                 }
[17:42:26.381]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:26.381]                 "immediateCondition"))) {
[17:42:26.381]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:26.381]                   ...future.conditions[[length(...future.conditions) + 
[17:42:26.381]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:26.381]                   if (TRUE && !signal) {
[17:42:26.381]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.381]                     {
[17:42:26.381]                       inherits <- base::inherits
[17:42:26.381]                       invokeRestart <- base::invokeRestart
[17:42:26.381]                       is.null <- base::is.null
[17:42:26.381]                       muffled <- FALSE
[17:42:26.381]                       if (inherits(cond, "message")) {
[17:42:26.381]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:26.381]                         if (muffled) 
[17:42:26.381]                           invokeRestart("muffleMessage")
[17:42:26.381]                       }
[17:42:26.381]                       else if (inherits(cond, "warning")) {
[17:42:26.381]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:26.381]                         if (muffled) 
[17:42:26.381]                           invokeRestart("muffleWarning")
[17:42:26.381]                       }
[17:42:26.381]                       else if (inherits(cond, "condition")) {
[17:42:26.381]                         if (!is.null(pattern)) {
[17:42:26.381]                           computeRestarts <- base::computeRestarts
[17:42:26.381]                           grepl <- base::grepl
[17:42:26.381]                           restarts <- computeRestarts(cond)
[17:42:26.381]                           for (restart in restarts) {
[17:42:26.381]                             name <- restart$name
[17:42:26.381]                             if (is.null(name)) 
[17:42:26.381]                               next
[17:42:26.381]                             if (!grepl(pattern, name)) 
[17:42:26.381]                               next
[17:42:26.381]                             invokeRestart(restart)
[17:42:26.381]                             muffled <- TRUE
[17:42:26.381]                             break
[17:42:26.381]                           }
[17:42:26.381]                         }
[17:42:26.381]                       }
[17:42:26.381]                       invisible(muffled)
[17:42:26.381]                     }
[17:42:26.381]                     muffleCondition(cond, pattern = "^muffle")
[17:42:26.381]                   }
[17:42:26.381]                 }
[17:42:26.381]                 else {
[17:42:26.381]                   if (TRUE) {
[17:42:26.381]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.381]                     {
[17:42:26.381]                       inherits <- base::inherits
[17:42:26.381]                       invokeRestart <- base::invokeRestart
[17:42:26.381]                       is.null <- base::is.null
[17:42:26.381]                       muffled <- FALSE
[17:42:26.381]                       if (inherits(cond, "message")) {
[17:42:26.381]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:26.381]                         if (muffled) 
[17:42:26.381]                           invokeRestart("muffleMessage")
[17:42:26.381]                       }
[17:42:26.381]                       else if (inherits(cond, "warning")) {
[17:42:26.381]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:26.381]                         if (muffled) 
[17:42:26.381]                           invokeRestart("muffleWarning")
[17:42:26.381]                       }
[17:42:26.381]                       else if (inherits(cond, "condition")) {
[17:42:26.381]                         if (!is.null(pattern)) {
[17:42:26.381]                           computeRestarts <- base::computeRestarts
[17:42:26.381]                           grepl <- base::grepl
[17:42:26.381]                           restarts <- computeRestarts(cond)
[17:42:26.381]                           for (restart in restarts) {
[17:42:26.381]                             name <- restart$name
[17:42:26.381]                             if (is.null(name)) 
[17:42:26.381]                               next
[17:42:26.381]                             if (!grepl(pattern, name)) 
[17:42:26.381]                               next
[17:42:26.381]                             invokeRestart(restart)
[17:42:26.381]                             muffled <- TRUE
[17:42:26.381]                             break
[17:42:26.381]                           }
[17:42:26.381]                         }
[17:42:26.381]                       }
[17:42:26.381]                       invisible(muffled)
[17:42:26.381]                     }
[17:42:26.381]                     muffleCondition(cond, pattern = "^muffle")
[17:42:26.381]                   }
[17:42:26.381]                 }
[17:42:26.381]             }
[17:42:26.381]         }))
[17:42:26.381]     }, error = function(ex) {
[17:42:26.381]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:26.381]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:26.381]                 ...future.rng), started = ...future.startTime, 
[17:42:26.381]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:26.381]             version = "1.8"), class = "FutureResult")
[17:42:26.381]     }, finally = {
[17:42:26.381]         if (!identical(...future.workdir, getwd())) 
[17:42:26.381]             setwd(...future.workdir)
[17:42:26.381]         {
[17:42:26.381]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:26.381]                 ...future.oldOptions$nwarnings <- NULL
[17:42:26.381]             }
[17:42:26.381]             base::options(...future.oldOptions)
[17:42:26.381]             if (.Platform$OS.type == "windows") {
[17:42:26.381]                 old_names <- names(...future.oldEnvVars)
[17:42:26.381]                 envs <- base::Sys.getenv()
[17:42:26.381]                 names <- names(envs)
[17:42:26.381]                 common <- intersect(names, old_names)
[17:42:26.381]                 added <- setdiff(names, old_names)
[17:42:26.381]                 removed <- setdiff(old_names, names)
[17:42:26.381]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:26.381]                   envs[common]]
[17:42:26.381]                 NAMES <- toupper(changed)
[17:42:26.381]                 args <- list()
[17:42:26.381]                 for (kk in seq_along(NAMES)) {
[17:42:26.381]                   name <- changed[[kk]]
[17:42:26.381]                   NAME <- NAMES[[kk]]
[17:42:26.381]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.381]                     next
[17:42:26.381]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:26.381]                 }
[17:42:26.381]                 NAMES <- toupper(added)
[17:42:26.381]                 for (kk in seq_along(NAMES)) {
[17:42:26.381]                   name <- added[[kk]]
[17:42:26.381]                   NAME <- NAMES[[kk]]
[17:42:26.381]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.381]                     next
[17:42:26.381]                   args[[name]] <- ""
[17:42:26.381]                 }
[17:42:26.381]                 NAMES <- toupper(removed)
[17:42:26.381]                 for (kk in seq_along(NAMES)) {
[17:42:26.381]                   name <- removed[[kk]]
[17:42:26.381]                   NAME <- NAMES[[kk]]
[17:42:26.381]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.381]                     next
[17:42:26.381]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:26.381]                 }
[17:42:26.381]                 if (length(args) > 0) 
[17:42:26.381]                   base::do.call(base::Sys.setenv, args = args)
[17:42:26.381]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:26.381]             }
[17:42:26.381]             else {
[17:42:26.381]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:26.381]             }
[17:42:26.381]             {
[17:42:26.381]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:26.381]                   0L) {
[17:42:26.381]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:26.381]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:26.381]                   base::options(opts)
[17:42:26.381]                 }
[17:42:26.381]                 {
[17:42:26.381]                   {
[17:42:26.381]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:26.381]                     NULL
[17:42:26.381]                   }
[17:42:26.381]                   options(future.plan = NULL)
[17:42:26.381]                   if (is.na(NA_character_)) 
[17:42:26.381]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:26.381]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:26.381]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:26.381]                     envir = parent.frame()) 
[17:42:26.381]                   {
[17:42:26.381]                     default_workers <- missing(workers)
[17:42:26.381]                     if (is.function(workers)) 
[17:42:26.381]                       workers <- workers()
[17:42:26.381]                     workers <- structure(as.integer(workers), 
[17:42:26.381]                       class = class(workers))
[17:42:26.381]                     stop_if_not(is.finite(workers), workers >= 
[17:42:26.381]                       1L)
[17:42:26.381]                     if ((workers == 1L && !inherits(workers, 
[17:42:26.381]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:26.381]                       if (default_workers) 
[17:42:26.381]                         supportsMulticore(warn = TRUE)
[17:42:26.381]                       return(sequential(..., envir = envir))
[17:42:26.381]                     }
[17:42:26.381]                     oopts <- options(mc.cores = workers)
[17:42:26.381]                     on.exit(options(oopts))
[17:42:26.381]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:26.381]                       envir = envir)
[17:42:26.381]                     if (!future$lazy) 
[17:42:26.381]                       future <- run(future)
[17:42:26.381]                     invisible(future)
[17:42:26.381]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:26.381]                 }
[17:42:26.381]             }
[17:42:26.381]         }
[17:42:26.381]     })
[17:42:26.381]     if (TRUE) {
[17:42:26.381]         base::sink(type = "output", split = FALSE)
[17:42:26.381]         if (TRUE) {
[17:42:26.381]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:26.381]         }
[17:42:26.381]         else {
[17:42:26.381]             ...future.result["stdout"] <- base::list(NULL)
[17:42:26.381]         }
[17:42:26.381]         base::close(...future.stdout)
[17:42:26.381]         ...future.stdout <- NULL
[17:42:26.381]     }
[17:42:26.381]     ...future.result$conditions <- ...future.conditions
[17:42:26.381]     ...future.result$finished <- base::Sys.time()
[17:42:26.381]     ...future.result
[17:42:26.381] }
[17:42:26.384] requestCore(): workers = 2
[17:42:26.386] MulticoreFuture started
[17:42:26.387] - Launch lazy future ... done
[17:42:26.387] run() for ‘MulticoreFuture’ ... done
[17:42:26.388] plan(): Setting new future strategy stack:
[17:42:26.388] List of future strategies:
[17:42:26.388] 1. sequential:
[17:42:26.388]    - args: function (..., envir = parent.frame())
[17:42:26.388]    - tweaked: FALSE
[17:42:26.388]    - call: NULL
[17:42:26.389] plan(): nbrOfWorkers() = 1
[17:42:26.392] plan(): Setting new future strategy stack:
[17:42:26.392] List of future strategies:
[17:42:26.392] 1. multicore:
[17:42:26.392]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:26.392]    - tweaked: FALSE
[17:42:26.392]    - call: plan(strategy)
[17:42:26.397] plan(): nbrOfWorkers() = 2

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[17:42:26.402] getGlobalsAndPackages() ...
[17:42:26.403] Searching for globals...
[17:42:26.405] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[17:42:26.405] Searching for globals ... DONE
[17:42:26.405] Resolving globals: FALSE
[17:42:26.406] 
[17:42:26.406] - packages: [2] ‘stats’, ‘datasets’
[17:42:26.406] getGlobalsAndPackages() ... DONE
[17:42:26.406] run() for ‘Future’ ...
[17:42:26.407] - state: ‘created’
[17:42:26.407] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:26.445] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:26.445] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:26.445]   - Field: ‘label’
[17:42:26.445]   - Field: ‘local’
[17:42:26.445]   - Field: ‘owner’
[17:42:26.445]   - Field: ‘envir’
[17:42:26.445]   - Field: ‘workers’
[17:42:26.446]   - Field: ‘packages’
[17:42:26.446]   - Field: ‘gc’
[17:42:26.446]   - Field: ‘job’
[17:42:26.446]   - Field: ‘conditions’
[17:42:26.446]   - Field: ‘expr’
[17:42:26.446]   - Field: ‘uuid’
[17:42:26.446]   - Field: ‘seed’
[17:42:26.446]   - Field: ‘version’
[17:42:26.446]   - Field: ‘result’
[17:42:26.447]   - Field: ‘asynchronous’
[17:42:26.447]   - Field: ‘calls’
[17:42:26.447]   - Field: ‘globals’
[17:42:26.447]   - Field: ‘stdout’
[17:42:26.447]   - Field: ‘earlySignal’
[17:42:26.447]   - Field: ‘lazy’
[17:42:26.447]   - Field: ‘state’
[17:42:26.447] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:26.447] - Launch lazy future ...
[17:42:26.448] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:42:26.448] Packages needed by future strategies (n = 0): <none>
[17:42:26.448] {
[17:42:26.448]     {
[17:42:26.448]         {
[17:42:26.448]             ...future.startTime <- base::Sys.time()
[17:42:26.448]             {
[17:42:26.448]                 {
[17:42:26.448]                   {
[17:42:26.448]                     {
[17:42:26.448]                       {
[17:42:26.448]                         base::local({
[17:42:26.448]                           has_future <- base::requireNamespace("future", 
[17:42:26.448]                             quietly = TRUE)
[17:42:26.448]                           if (has_future) {
[17:42:26.448]                             ns <- base::getNamespace("future")
[17:42:26.448]                             version <- ns[[".package"]][["version"]]
[17:42:26.448]                             if (is.null(version)) 
[17:42:26.448]                               version <- utils::packageVersion("future")
[17:42:26.448]                           }
[17:42:26.448]                           else {
[17:42:26.448]                             version <- NULL
[17:42:26.448]                           }
[17:42:26.448]                           if (!has_future || version < "1.8.0") {
[17:42:26.448]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:26.448]                               "", base::R.version$version.string), 
[17:42:26.448]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:26.448]                                 base::R.version$platform, 8 * 
[17:42:26.448]                                   base::.Machine$sizeof.pointer), 
[17:42:26.448]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:26.448]                                 "release", "version")], collapse = " "), 
[17:42:26.448]                               hostname = base::Sys.info()[["nodename"]])
[17:42:26.448]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:26.448]                               info)
[17:42:26.448]                             info <- base::paste(info, collapse = "; ")
[17:42:26.448]                             if (!has_future) {
[17:42:26.448]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:26.448]                                 info)
[17:42:26.448]                             }
[17:42:26.448]                             else {
[17:42:26.448]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:26.448]                                 info, version)
[17:42:26.448]                             }
[17:42:26.448]                             base::stop(msg)
[17:42:26.448]                           }
[17:42:26.448]                         })
[17:42:26.448]                       }
[17:42:26.448]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:26.448]                       base::options(mc.cores = 1L)
[17:42:26.448]                     }
[17:42:26.448]                     base::local({
[17:42:26.448]                       for (pkg in c("stats", "datasets")) {
[17:42:26.448]                         base::loadNamespace(pkg)
[17:42:26.448]                         base::library(pkg, character.only = TRUE)
[17:42:26.448]                       }
[17:42:26.448]                     })
[17:42:26.448]                   }
[17:42:26.448]                   options(future.plan = NULL)
[17:42:26.448]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:26.448]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:26.448]                 }
[17:42:26.448]                 ...future.workdir <- getwd()
[17:42:26.448]             }
[17:42:26.448]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:26.448]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:26.448]         }
[17:42:26.448]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:26.448]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:26.448]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:26.448]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:26.448]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:26.448]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:26.448]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:26.448]             base::names(...future.oldOptions))
[17:42:26.448]     }
[17:42:26.448]     if (FALSE) {
[17:42:26.448]     }
[17:42:26.448]     else {
[17:42:26.448]         if (TRUE) {
[17:42:26.448]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:26.448]                 open = "w")
[17:42:26.448]         }
[17:42:26.448]         else {
[17:42:26.448]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:26.448]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:26.448]         }
[17:42:26.448]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:26.448]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:26.448]             base::sink(type = "output", split = FALSE)
[17:42:26.448]             base::close(...future.stdout)
[17:42:26.448]         }, add = TRUE)
[17:42:26.448]     }
[17:42:26.448]     ...future.frame <- base::sys.nframe()
[17:42:26.448]     ...future.conditions <- base::list()
[17:42:26.448]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:26.448]     if (FALSE) {
[17:42:26.448]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:26.448]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:26.448]     }
[17:42:26.448]     ...future.result <- base::tryCatch({
[17:42:26.448]         base::withCallingHandlers({
[17:42:26.448]             ...future.value <- base::withVisible(base::local({
[17:42:26.448]                 withCallingHandlers({
[17:42:26.448]                   {
[17:42:26.448]                     lm(dist ~ . + 0, data = cars)
[17:42:26.448]                   }
[17:42:26.448]                 }, immediateCondition = function(cond) {
[17:42:26.448]                   save_rds <- function (object, pathname, ...) 
[17:42:26.448]                   {
[17:42:26.448]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:26.448]                     if (file_test("-f", pathname_tmp)) {
[17:42:26.448]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.448]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:26.448]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.448]                         fi_tmp[["mtime"]])
[17:42:26.448]                     }
[17:42:26.448]                     tryCatch({
[17:42:26.448]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:26.448]                     }, error = function(ex) {
[17:42:26.448]                       msg <- conditionMessage(ex)
[17:42:26.448]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.448]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:26.448]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.448]                         fi_tmp[["mtime"]], msg)
[17:42:26.448]                       ex$message <- msg
[17:42:26.448]                       stop(ex)
[17:42:26.448]                     })
[17:42:26.448]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:26.448]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:26.448]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:26.448]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.448]                       fi <- file.info(pathname)
[17:42:26.448]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:26.448]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.448]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:26.448]                         fi[["size"]], fi[["mtime"]])
[17:42:26.448]                       stop(msg)
[17:42:26.448]                     }
[17:42:26.448]                     invisible(pathname)
[17:42:26.448]                   }
[17:42:26.448]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:26.448]                     rootPath = tempdir()) 
[17:42:26.448]                   {
[17:42:26.448]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:26.448]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:26.448]                       tmpdir = path, fileext = ".rds")
[17:42:26.448]                     save_rds(obj, file)
[17:42:26.448]                   }
[17:42:26.448]                   saveImmediateCondition(cond, path = "/tmp/RtmpNwFxwa/.future/immediateConditions")
[17:42:26.448]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.448]                   {
[17:42:26.448]                     inherits <- base::inherits
[17:42:26.448]                     invokeRestart <- base::invokeRestart
[17:42:26.448]                     is.null <- base::is.null
[17:42:26.448]                     muffled <- FALSE
[17:42:26.448]                     if (inherits(cond, "message")) {
[17:42:26.448]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:26.448]                       if (muffled) 
[17:42:26.448]                         invokeRestart("muffleMessage")
[17:42:26.448]                     }
[17:42:26.448]                     else if (inherits(cond, "warning")) {
[17:42:26.448]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:26.448]                       if (muffled) 
[17:42:26.448]                         invokeRestart("muffleWarning")
[17:42:26.448]                     }
[17:42:26.448]                     else if (inherits(cond, "condition")) {
[17:42:26.448]                       if (!is.null(pattern)) {
[17:42:26.448]                         computeRestarts <- base::computeRestarts
[17:42:26.448]                         grepl <- base::grepl
[17:42:26.448]                         restarts <- computeRestarts(cond)
[17:42:26.448]                         for (restart in restarts) {
[17:42:26.448]                           name <- restart$name
[17:42:26.448]                           if (is.null(name)) 
[17:42:26.448]                             next
[17:42:26.448]                           if (!grepl(pattern, name)) 
[17:42:26.448]                             next
[17:42:26.448]                           invokeRestart(restart)
[17:42:26.448]                           muffled <- TRUE
[17:42:26.448]                           break
[17:42:26.448]                         }
[17:42:26.448]                       }
[17:42:26.448]                     }
[17:42:26.448]                     invisible(muffled)
[17:42:26.448]                   }
[17:42:26.448]                   muffleCondition(cond)
[17:42:26.448]                 })
[17:42:26.448]             }))
[17:42:26.448]             future::FutureResult(value = ...future.value$value, 
[17:42:26.448]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:26.448]                   ...future.rng), globalenv = if (FALSE) 
[17:42:26.448]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:26.448]                     ...future.globalenv.names))
[17:42:26.448]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:26.448]         }, condition = base::local({
[17:42:26.448]             c <- base::c
[17:42:26.448]             inherits <- base::inherits
[17:42:26.448]             invokeRestart <- base::invokeRestart
[17:42:26.448]             length <- base::length
[17:42:26.448]             list <- base::list
[17:42:26.448]             seq.int <- base::seq.int
[17:42:26.448]             signalCondition <- base::signalCondition
[17:42:26.448]             sys.calls <- base::sys.calls
[17:42:26.448]             `[[` <- base::`[[`
[17:42:26.448]             `+` <- base::`+`
[17:42:26.448]             `<<-` <- base::`<<-`
[17:42:26.448]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:26.448]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:26.448]                   3L)]
[17:42:26.448]             }
[17:42:26.448]             function(cond) {
[17:42:26.448]                 is_error <- inherits(cond, "error")
[17:42:26.448]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:26.448]                   NULL)
[17:42:26.448]                 if (is_error) {
[17:42:26.448]                   sessionInformation <- function() {
[17:42:26.448]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:26.448]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:26.448]                       search = base::search(), system = base::Sys.info())
[17:42:26.448]                   }
[17:42:26.448]                   ...future.conditions[[length(...future.conditions) + 
[17:42:26.448]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:26.448]                     cond$call), session = sessionInformation(), 
[17:42:26.448]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:26.448]                   signalCondition(cond)
[17:42:26.448]                 }
[17:42:26.448]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:26.448]                 "immediateCondition"))) {
[17:42:26.448]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:26.448]                   ...future.conditions[[length(...future.conditions) + 
[17:42:26.448]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:26.448]                   if (TRUE && !signal) {
[17:42:26.448]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.448]                     {
[17:42:26.448]                       inherits <- base::inherits
[17:42:26.448]                       invokeRestart <- base::invokeRestart
[17:42:26.448]                       is.null <- base::is.null
[17:42:26.448]                       muffled <- FALSE
[17:42:26.448]                       if (inherits(cond, "message")) {
[17:42:26.448]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:26.448]                         if (muffled) 
[17:42:26.448]                           invokeRestart("muffleMessage")
[17:42:26.448]                       }
[17:42:26.448]                       else if (inherits(cond, "warning")) {
[17:42:26.448]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:26.448]                         if (muffled) 
[17:42:26.448]                           invokeRestart("muffleWarning")
[17:42:26.448]                       }
[17:42:26.448]                       else if (inherits(cond, "condition")) {
[17:42:26.448]                         if (!is.null(pattern)) {
[17:42:26.448]                           computeRestarts <- base::computeRestarts
[17:42:26.448]                           grepl <- base::grepl
[17:42:26.448]                           restarts <- computeRestarts(cond)
[17:42:26.448]                           for (restart in restarts) {
[17:42:26.448]                             name <- restart$name
[17:42:26.448]                             if (is.null(name)) 
[17:42:26.448]                               next
[17:42:26.448]                             if (!grepl(pattern, name)) 
[17:42:26.448]                               next
[17:42:26.448]                             invokeRestart(restart)
[17:42:26.448]                             muffled <- TRUE
[17:42:26.448]                             break
[17:42:26.448]                           }
[17:42:26.448]                         }
[17:42:26.448]                       }
[17:42:26.448]                       invisible(muffled)
[17:42:26.448]                     }
[17:42:26.448]                     muffleCondition(cond, pattern = "^muffle")
[17:42:26.448]                   }
[17:42:26.448]                 }
[17:42:26.448]                 else {
[17:42:26.448]                   if (TRUE) {
[17:42:26.448]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.448]                     {
[17:42:26.448]                       inherits <- base::inherits
[17:42:26.448]                       invokeRestart <- base::invokeRestart
[17:42:26.448]                       is.null <- base::is.null
[17:42:26.448]                       muffled <- FALSE
[17:42:26.448]                       if (inherits(cond, "message")) {
[17:42:26.448]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:26.448]                         if (muffled) 
[17:42:26.448]                           invokeRestart("muffleMessage")
[17:42:26.448]                       }
[17:42:26.448]                       else if (inherits(cond, "warning")) {
[17:42:26.448]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:26.448]                         if (muffled) 
[17:42:26.448]                           invokeRestart("muffleWarning")
[17:42:26.448]                       }
[17:42:26.448]                       else if (inherits(cond, "condition")) {
[17:42:26.448]                         if (!is.null(pattern)) {
[17:42:26.448]                           computeRestarts <- base::computeRestarts
[17:42:26.448]                           grepl <- base::grepl
[17:42:26.448]                           restarts <- computeRestarts(cond)
[17:42:26.448]                           for (restart in restarts) {
[17:42:26.448]                             name <- restart$name
[17:42:26.448]                             if (is.null(name)) 
[17:42:26.448]                               next
[17:42:26.448]                             if (!grepl(pattern, name)) 
[17:42:26.448]                               next
[17:42:26.448]                             invokeRestart(restart)
[17:42:26.448]                             muffled <- TRUE
[17:42:26.448]                             break
[17:42:26.448]                           }
[17:42:26.448]                         }
[17:42:26.448]                       }
[17:42:26.448]                       invisible(muffled)
[17:42:26.448]                     }
[17:42:26.448]                     muffleCondition(cond, pattern = "^muffle")
[17:42:26.448]                   }
[17:42:26.448]                 }
[17:42:26.448]             }
[17:42:26.448]         }))
[17:42:26.448]     }, error = function(ex) {
[17:42:26.448]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:26.448]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:26.448]                 ...future.rng), started = ...future.startTime, 
[17:42:26.448]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:26.448]             version = "1.8"), class = "FutureResult")
[17:42:26.448]     }, finally = {
[17:42:26.448]         if (!identical(...future.workdir, getwd())) 
[17:42:26.448]             setwd(...future.workdir)
[17:42:26.448]         {
[17:42:26.448]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:26.448]                 ...future.oldOptions$nwarnings <- NULL
[17:42:26.448]             }
[17:42:26.448]             base::options(...future.oldOptions)
[17:42:26.448]             if (.Platform$OS.type == "windows") {
[17:42:26.448]                 old_names <- names(...future.oldEnvVars)
[17:42:26.448]                 envs <- base::Sys.getenv()
[17:42:26.448]                 names <- names(envs)
[17:42:26.448]                 common <- intersect(names, old_names)
[17:42:26.448]                 added <- setdiff(names, old_names)
[17:42:26.448]                 removed <- setdiff(old_names, names)
[17:42:26.448]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:26.448]                   envs[common]]
[17:42:26.448]                 NAMES <- toupper(changed)
[17:42:26.448]                 args <- list()
[17:42:26.448]                 for (kk in seq_along(NAMES)) {
[17:42:26.448]                   name <- changed[[kk]]
[17:42:26.448]                   NAME <- NAMES[[kk]]
[17:42:26.448]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.448]                     next
[17:42:26.448]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:26.448]                 }
[17:42:26.448]                 NAMES <- toupper(added)
[17:42:26.448]                 for (kk in seq_along(NAMES)) {
[17:42:26.448]                   name <- added[[kk]]
[17:42:26.448]                   NAME <- NAMES[[kk]]
[17:42:26.448]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.448]                     next
[17:42:26.448]                   args[[name]] <- ""
[17:42:26.448]                 }
[17:42:26.448]                 NAMES <- toupper(removed)
[17:42:26.448]                 for (kk in seq_along(NAMES)) {
[17:42:26.448]                   name <- removed[[kk]]
[17:42:26.448]                   NAME <- NAMES[[kk]]
[17:42:26.448]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.448]                     next
[17:42:26.448]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:26.448]                 }
[17:42:26.448]                 if (length(args) > 0) 
[17:42:26.448]                   base::do.call(base::Sys.setenv, args = args)
[17:42:26.448]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:26.448]             }
[17:42:26.448]             else {
[17:42:26.448]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:26.448]             }
[17:42:26.448]             {
[17:42:26.448]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:26.448]                   0L) {
[17:42:26.448]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:26.448]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:26.448]                   base::options(opts)
[17:42:26.448]                 }
[17:42:26.448]                 {
[17:42:26.448]                   {
[17:42:26.448]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:26.448]                     NULL
[17:42:26.448]                   }
[17:42:26.448]                   options(future.plan = NULL)
[17:42:26.448]                   if (is.na(NA_character_)) 
[17:42:26.448]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:26.448]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:26.448]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:26.448]                     envir = parent.frame()) 
[17:42:26.448]                   {
[17:42:26.448]                     default_workers <- missing(workers)
[17:42:26.448]                     if (is.function(workers)) 
[17:42:26.448]                       workers <- workers()
[17:42:26.448]                     workers <- structure(as.integer(workers), 
[17:42:26.448]                       class = class(workers))
[17:42:26.448]                     stop_if_not(is.finite(workers), workers >= 
[17:42:26.448]                       1L)
[17:42:26.448]                     if ((workers == 1L && !inherits(workers, 
[17:42:26.448]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:26.448]                       if (default_workers) 
[17:42:26.448]                         supportsMulticore(warn = TRUE)
[17:42:26.448]                       return(sequential(..., envir = envir))
[17:42:26.448]                     }
[17:42:26.448]                     oopts <- options(mc.cores = workers)
[17:42:26.448]                     on.exit(options(oopts))
[17:42:26.448]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:26.448]                       envir = envir)
[17:42:26.448]                     if (!future$lazy) 
[17:42:26.448]                       future <- run(future)
[17:42:26.448]                     invisible(future)
[17:42:26.448]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:26.448]                 }
[17:42:26.448]             }
[17:42:26.448]         }
[17:42:26.448]     })
[17:42:26.448]     if (TRUE) {
[17:42:26.448]         base::sink(type = "output", split = FALSE)
[17:42:26.448]         if (TRUE) {
[17:42:26.448]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:26.448]         }
[17:42:26.448]         else {
[17:42:26.448]             ...future.result["stdout"] <- base::list(NULL)
[17:42:26.448]         }
[17:42:26.448]         base::close(...future.stdout)
[17:42:26.448]         ...future.stdout <- NULL
[17:42:26.448]     }
[17:42:26.448]     ...future.result$conditions <- ...future.conditions
[17:42:26.448]     ...future.result$finished <- base::Sys.time()
[17:42:26.448]     ...future.result
[17:42:26.448] }
[17:42:26.451] requestCore(): workers = 2
[17:42:26.453] MulticoreFuture started
[17:42:26.453] - Launch lazy future ... done
[17:42:26.454] run() for ‘MulticoreFuture’ ... done
[17:42:26.455] plan(): Setting new future strategy stack:
[17:42:26.455] List of future strategies:
[17:42:26.455] 1. sequential:
[17:42:26.455]    - args: function (..., envir = parent.frame())
[17:42:26.455]    - tweaked: FALSE
[17:42:26.455]    - call: NULL
[17:42:26.456] plan(): nbrOfWorkers() = 1
[17:42:26.460] plan(): Setting new future strategy stack:
[17:42:26.460] List of future strategies:
[17:42:26.460] 1. multicore:
[17:42:26.460]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:26.460]    - tweaked: FALSE
[17:42:26.460]    - call: plan(strategy)
[17:42:26.466] plan(): nbrOfWorkers() = 2

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[17:42:26.473] getGlobalsAndPackages() ...
[17:42:26.473] Searching for globals...
[17:42:26.476] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[17:42:26.476] Searching for globals ... DONE
[17:42:26.476] Resolving globals: FALSE
[17:42:26.477] 
[17:42:26.477] - packages: [2] ‘stats’, ‘datasets’
[17:42:26.477] getGlobalsAndPackages() ... DONE
[17:42:26.477] run() for ‘Future’ ...
[17:42:26.477] - state: ‘created’
[17:42:26.478] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:26.482] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:26.482] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:26.482]   - Field: ‘label’
[17:42:26.482]   - Field: ‘local’
[17:42:26.482]   - Field: ‘owner’
[17:42:26.482]   - Field: ‘envir’
[17:42:26.482]   - Field: ‘workers’
[17:42:26.483]   - Field: ‘packages’
[17:42:26.483]   - Field: ‘gc’
[17:42:26.483]   - Field: ‘job’
[17:42:26.483]   - Field: ‘conditions’
[17:42:26.483]   - Field: ‘expr’
[17:42:26.483]   - Field: ‘uuid’
[17:42:26.483]   - Field: ‘seed’
[17:42:26.484]   - Field: ‘version’
[17:42:26.484]   - Field: ‘result’
[17:42:26.484]   - Field: ‘asynchronous’
[17:42:26.484]   - Field: ‘calls’
[17:42:26.484]   - Field: ‘globals’
[17:42:26.484]   - Field: ‘stdout’
[17:42:26.484]   - Field: ‘earlySignal’
[17:42:26.484]   - Field: ‘lazy’
[17:42:26.484]   - Field: ‘state’
[17:42:26.485] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:26.485] - Launch lazy future ...
[17:42:26.485] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:42:26.485] Packages needed by future strategies (n = 0): <none>
[17:42:26.486] {
[17:42:26.486]     {
[17:42:26.486]         {
[17:42:26.486]             ...future.startTime <- base::Sys.time()
[17:42:26.486]             {
[17:42:26.486]                 {
[17:42:26.486]                   {
[17:42:26.486]                     {
[17:42:26.486]                       {
[17:42:26.486]                         base::local({
[17:42:26.486]                           has_future <- base::requireNamespace("future", 
[17:42:26.486]                             quietly = TRUE)
[17:42:26.486]                           if (has_future) {
[17:42:26.486]                             ns <- base::getNamespace("future")
[17:42:26.486]                             version <- ns[[".package"]][["version"]]
[17:42:26.486]                             if (is.null(version)) 
[17:42:26.486]                               version <- utils::packageVersion("future")
[17:42:26.486]                           }
[17:42:26.486]                           else {
[17:42:26.486]                             version <- NULL
[17:42:26.486]                           }
[17:42:26.486]                           if (!has_future || version < "1.8.0") {
[17:42:26.486]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:26.486]                               "", base::R.version$version.string), 
[17:42:26.486]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:26.486]                                 base::R.version$platform, 8 * 
[17:42:26.486]                                   base::.Machine$sizeof.pointer), 
[17:42:26.486]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:26.486]                                 "release", "version")], collapse = " "), 
[17:42:26.486]                               hostname = base::Sys.info()[["nodename"]])
[17:42:26.486]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:26.486]                               info)
[17:42:26.486]                             info <- base::paste(info, collapse = "; ")
[17:42:26.486]                             if (!has_future) {
[17:42:26.486]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:26.486]                                 info)
[17:42:26.486]                             }
[17:42:26.486]                             else {
[17:42:26.486]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:26.486]                                 info, version)
[17:42:26.486]                             }
[17:42:26.486]                             base::stop(msg)
[17:42:26.486]                           }
[17:42:26.486]                         })
[17:42:26.486]                       }
[17:42:26.486]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:26.486]                       base::options(mc.cores = 1L)
[17:42:26.486]                     }
[17:42:26.486]                     base::local({
[17:42:26.486]                       for (pkg in c("stats", "datasets")) {
[17:42:26.486]                         base::loadNamespace(pkg)
[17:42:26.486]                         base::library(pkg, character.only = TRUE)
[17:42:26.486]                       }
[17:42:26.486]                     })
[17:42:26.486]                   }
[17:42:26.486]                   options(future.plan = NULL)
[17:42:26.486]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:26.486]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:26.486]                 }
[17:42:26.486]                 ...future.workdir <- getwd()
[17:42:26.486]             }
[17:42:26.486]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:26.486]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:26.486]         }
[17:42:26.486]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:26.486]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:26.486]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:26.486]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:26.486]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:26.486]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:26.486]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:26.486]             base::names(...future.oldOptions))
[17:42:26.486]     }
[17:42:26.486]     if (FALSE) {
[17:42:26.486]     }
[17:42:26.486]     else {
[17:42:26.486]         if (TRUE) {
[17:42:26.486]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:26.486]                 open = "w")
[17:42:26.486]         }
[17:42:26.486]         else {
[17:42:26.486]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:26.486]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:26.486]         }
[17:42:26.486]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:26.486]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:26.486]             base::sink(type = "output", split = FALSE)
[17:42:26.486]             base::close(...future.stdout)
[17:42:26.486]         }, add = TRUE)
[17:42:26.486]     }
[17:42:26.486]     ...future.frame <- base::sys.nframe()
[17:42:26.486]     ...future.conditions <- base::list()
[17:42:26.486]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:26.486]     if (FALSE) {
[17:42:26.486]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:26.486]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:26.486]     }
[17:42:26.486]     ...future.result <- base::tryCatch({
[17:42:26.486]         base::withCallingHandlers({
[17:42:26.486]             ...future.value <- base::withVisible(base::local({
[17:42:26.486]                 withCallingHandlers({
[17:42:26.486]                   {
[17:42:26.486]                     lm(dist ~ speed + speed^2, data = cars)
[17:42:26.486]                   }
[17:42:26.486]                 }, immediateCondition = function(cond) {
[17:42:26.486]                   save_rds <- function (object, pathname, ...) 
[17:42:26.486]                   {
[17:42:26.486]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:26.486]                     if (file_test("-f", pathname_tmp)) {
[17:42:26.486]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.486]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:26.486]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.486]                         fi_tmp[["mtime"]])
[17:42:26.486]                     }
[17:42:26.486]                     tryCatch({
[17:42:26.486]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:26.486]                     }, error = function(ex) {
[17:42:26.486]                       msg <- conditionMessage(ex)
[17:42:26.486]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.486]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:26.486]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.486]                         fi_tmp[["mtime"]], msg)
[17:42:26.486]                       ex$message <- msg
[17:42:26.486]                       stop(ex)
[17:42:26.486]                     })
[17:42:26.486]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:26.486]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:26.486]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:26.486]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.486]                       fi <- file.info(pathname)
[17:42:26.486]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:26.486]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.486]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:26.486]                         fi[["size"]], fi[["mtime"]])
[17:42:26.486]                       stop(msg)
[17:42:26.486]                     }
[17:42:26.486]                     invisible(pathname)
[17:42:26.486]                   }
[17:42:26.486]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:26.486]                     rootPath = tempdir()) 
[17:42:26.486]                   {
[17:42:26.486]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:26.486]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:26.486]                       tmpdir = path, fileext = ".rds")
[17:42:26.486]                     save_rds(obj, file)
[17:42:26.486]                   }
[17:42:26.486]                   saveImmediateCondition(cond, path = "/tmp/RtmpNwFxwa/.future/immediateConditions")
[17:42:26.486]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.486]                   {
[17:42:26.486]                     inherits <- base::inherits
[17:42:26.486]                     invokeRestart <- base::invokeRestart
[17:42:26.486]                     is.null <- base::is.null
[17:42:26.486]                     muffled <- FALSE
[17:42:26.486]                     if (inherits(cond, "message")) {
[17:42:26.486]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:26.486]                       if (muffled) 
[17:42:26.486]                         invokeRestart("muffleMessage")
[17:42:26.486]                     }
[17:42:26.486]                     else if (inherits(cond, "warning")) {
[17:42:26.486]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:26.486]                       if (muffled) 
[17:42:26.486]                         invokeRestart("muffleWarning")
[17:42:26.486]                     }
[17:42:26.486]                     else if (inherits(cond, "condition")) {
[17:42:26.486]                       if (!is.null(pattern)) {
[17:42:26.486]                         computeRestarts <- base::computeRestarts
[17:42:26.486]                         grepl <- base::grepl
[17:42:26.486]                         restarts <- computeRestarts(cond)
[17:42:26.486]                         for (restart in restarts) {
[17:42:26.486]                           name <- restart$name
[17:42:26.486]                           if (is.null(name)) 
[17:42:26.486]                             next
[17:42:26.486]                           if (!grepl(pattern, name)) 
[17:42:26.486]                             next
[17:42:26.486]                           invokeRestart(restart)
[17:42:26.486]                           muffled <- TRUE
[17:42:26.486]                           break
[17:42:26.486]                         }
[17:42:26.486]                       }
[17:42:26.486]                     }
[17:42:26.486]                     invisible(muffled)
[17:42:26.486]                   }
[17:42:26.486]                   muffleCondition(cond)
[17:42:26.486]                 })
[17:42:26.486]             }))
[17:42:26.486]             future::FutureResult(value = ...future.value$value, 
[17:42:26.486]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:26.486]                   ...future.rng), globalenv = if (FALSE) 
[17:42:26.486]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:26.486]                     ...future.globalenv.names))
[17:42:26.486]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:26.486]         }, condition = base::local({
[17:42:26.486]             c <- base::c
[17:42:26.486]             inherits <- base::inherits
[17:42:26.486]             invokeRestart <- base::invokeRestart
[17:42:26.486]             length <- base::length
[17:42:26.486]             list <- base::list
[17:42:26.486]             seq.int <- base::seq.int
[17:42:26.486]             signalCondition <- base::signalCondition
[17:42:26.486]             sys.calls <- base::sys.calls
[17:42:26.486]             `[[` <- base::`[[`
[17:42:26.486]             `+` <- base::`+`
[17:42:26.486]             `<<-` <- base::`<<-`
[17:42:26.486]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:26.486]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:26.486]                   3L)]
[17:42:26.486]             }
[17:42:26.486]             function(cond) {
[17:42:26.486]                 is_error <- inherits(cond, "error")
[17:42:26.486]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:26.486]                   NULL)
[17:42:26.486]                 if (is_error) {
[17:42:26.486]                   sessionInformation <- function() {
[17:42:26.486]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:26.486]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:26.486]                       search = base::search(), system = base::Sys.info())
[17:42:26.486]                   }
[17:42:26.486]                   ...future.conditions[[length(...future.conditions) + 
[17:42:26.486]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:26.486]                     cond$call), session = sessionInformation(), 
[17:42:26.486]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:26.486]                   signalCondition(cond)
[17:42:26.486]                 }
[17:42:26.486]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:26.486]                 "immediateCondition"))) {
[17:42:26.486]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:26.486]                   ...future.conditions[[length(...future.conditions) + 
[17:42:26.486]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:26.486]                   if (TRUE && !signal) {
[17:42:26.486]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.486]                     {
[17:42:26.486]                       inherits <- base::inherits
[17:42:26.486]                       invokeRestart <- base::invokeRestart
[17:42:26.486]                       is.null <- base::is.null
[17:42:26.486]                       muffled <- FALSE
[17:42:26.486]                       if (inherits(cond, "message")) {
[17:42:26.486]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:26.486]                         if (muffled) 
[17:42:26.486]                           invokeRestart("muffleMessage")
[17:42:26.486]                       }
[17:42:26.486]                       else if (inherits(cond, "warning")) {
[17:42:26.486]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:26.486]                         if (muffled) 
[17:42:26.486]                           invokeRestart("muffleWarning")
[17:42:26.486]                       }
[17:42:26.486]                       else if (inherits(cond, "condition")) {
[17:42:26.486]                         if (!is.null(pattern)) {
[17:42:26.486]                           computeRestarts <- base::computeRestarts
[17:42:26.486]                           grepl <- base::grepl
[17:42:26.486]                           restarts <- computeRestarts(cond)
[17:42:26.486]                           for (restart in restarts) {
[17:42:26.486]                             name <- restart$name
[17:42:26.486]                             if (is.null(name)) 
[17:42:26.486]                               next
[17:42:26.486]                             if (!grepl(pattern, name)) 
[17:42:26.486]                               next
[17:42:26.486]                             invokeRestart(restart)
[17:42:26.486]                             muffled <- TRUE
[17:42:26.486]                             break
[17:42:26.486]                           }
[17:42:26.486]                         }
[17:42:26.486]                       }
[17:42:26.486]                       invisible(muffled)
[17:42:26.486]                     }
[17:42:26.486]                     muffleCondition(cond, pattern = "^muffle")
[17:42:26.486]                   }
[17:42:26.486]                 }
[17:42:26.486]                 else {
[17:42:26.486]                   if (TRUE) {
[17:42:26.486]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.486]                     {
[17:42:26.486]                       inherits <- base::inherits
[17:42:26.486]                       invokeRestart <- base::invokeRestart
[17:42:26.486]                       is.null <- base::is.null
[17:42:26.486]                       muffled <- FALSE
[17:42:26.486]                       if (inherits(cond, "message")) {
[17:42:26.486]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:26.486]                         if (muffled) 
[17:42:26.486]                           invokeRestart("muffleMessage")
[17:42:26.486]                       }
[17:42:26.486]                       else if (inherits(cond, "warning")) {
[17:42:26.486]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:26.486]                         if (muffled) 
[17:42:26.486]                           invokeRestart("muffleWarning")
[17:42:26.486]                       }
[17:42:26.486]                       else if (inherits(cond, "condition")) {
[17:42:26.486]                         if (!is.null(pattern)) {
[17:42:26.486]                           computeRestarts <- base::computeRestarts
[17:42:26.486]                           grepl <- base::grepl
[17:42:26.486]                           restarts <- computeRestarts(cond)
[17:42:26.486]                           for (restart in restarts) {
[17:42:26.486]                             name <- restart$name
[17:42:26.486]                             if (is.null(name)) 
[17:42:26.486]                               next
[17:42:26.486]                             if (!grepl(pattern, name)) 
[17:42:26.486]                               next
[17:42:26.486]                             invokeRestart(restart)
[17:42:26.486]                             muffled <- TRUE
[17:42:26.486]                             break
[17:42:26.486]                           }
[17:42:26.486]                         }
[17:42:26.486]                       }
[17:42:26.486]                       invisible(muffled)
[17:42:26.486]                     }
[17:42:26.486]                     muffleCondition(cond, pattern = "^muffle")
[17:42:26.486]                   }
[17:42:26.486]                 }
[17:42:26.486]             }
[17:42:26.486]         }))
[17:42:26.486]     }, error = function(ex) {
[17:42:26.486]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:26.486]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:26.486]                 ...future.rng), started = ...future.startTime, 
[17:42:26.486]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:26.486]             version = "1.8"), class = "FutureResult")
[17:42:26.486]     }, finally = {
[17:42:26.486]         if (!identical(...future.workdir, getwd())) 
[17:42:26.486]             setwd(...future.workdir)
[17:42:26.486]         {
[17:42:26.486]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:26.486]                 ...future.oldOptions$nwarnings <- NULL
[17:42:26.486]             }
[17:42:26.486]             base::options(...future.oldOptions)
[17:42:26.486]             if (.Platform$OS.type == "windows") {
[17:42:26.486]                 old_names <- names(...future.oldEnvVars)
[17:42:26.486]                 envs <- base::Sys.getenv()
[17:42:26.486]                 names <- names(envs)
[17:42:26.486]                 common <- intersect(names, old_names)
[17:42:26.486]                 added <- setdiff(names, old_names)
[17:42:26.486]                 removed <- setdiff(old_names, names)
[17:42:26.486]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:26.486]                   envs[common]]
[17:42:26.486]                 NAMES <- toupper(changed)
[17:42:26.486]                 args <- list()
[17:42:26.486]                 for (kk in seq_along(NAMES)) {
[17:42:26.486]                   name <- changed[[kk]]
[17:42:26.486]                   NAME <- NAMES[[kk]]
[17:42:26.486]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.486]                     next
[17:42:26.486]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:26.486]                 }
[17:42:26.486]                 NAMES <- toupper(added)
[17:42:26.486]                 for (kk in seq_along(NAMES)) {
[17:42:26.486]                   name <- added[[kk]]
[17:42:26.486]                   NAME <- NAMES[[kk]]
[17:42:26.486]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.486]                     next
[17:42:26.486]                   args[[name]] <- ""
[17:42:26.486]                 }
[17:42:26.486]                 NAMES <- toupper(removed)
[17:42:26.486]                 for (kk in seq_along(NAMES)) {
[17:42:26.486]                   name <- removed[[kk]]
[17:42:26.486]                   NAME <- NAMES[[kk]]
[17:42:26.486]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.486]                     next
[17:42:26.486]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:26.486]                 }
[17:42:26.486]                 if (length(args) > 0) 
[17:42:26.486]                   base::do.call(base::Sys.setenv, args = args)
[17:42:26.486]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:26.486]             }
[17:42:26.486]             else {
[17:42:26.486]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:26.486]             }
[17:42:26.486]             {
[17:42:26.486]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:26.486]                   0L) {
[17:42:26.486]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:26.486]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:26.486]                   base::options(opts)
[17:42:26.486]                 }
[17:42:26.486]                 {
[17:42:26.486]                   {
[17:42:26.486]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:26.486]                     NULL
[17:42:26.486]                   }
[17:42:26.486]                   options(future.plan = NULL)
[17:42:26.486]                   if (is.na(NA_character_)) 
[17:42:26.486]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:26.486]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:26.486]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:26.486]                     envir = parent.frame()) 
[17:42:26.486]                   {
[17:42:26.486]                     default_workers <- missing(workers)
[17:42:26.486]                     if (is.function(workers)) 
[17:42:26.486]                       workers <- workers()
[17:42:26.486]                     workers <- structure(as.integer(workers), 
[17:42:26.486]                       class = class(workers))
[17:42:26.486]                     stop_if_not(is.finite(workers), workers >= 
[17:42:26.486]                       1L)
[17:42:26.486]                     if ((workers == 1L && !inherits(workers, 
[17:42:26.486]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:26.486]                       if (default_workers) 
[17:42:26.486]                         supportsMulticore(warn = TRUE)
[17:42:26.486]                       return(sequential(..., envir = envir))
[17:42:26.486]                     }
[17:42:26.486]                     oopts <- options(mc.cores = workers)
[17:42:26.486]                     on.exit(options(oopts))
[17:42:26.486]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:26.486]                       envir = envir)
[17:42:26.486]                     if (!future$lazy) 
[17:42:26.486]                       future <- run(future)
[17:42:26.486]                     invisible(future)
[17:42:26.486]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:26.486]                 }
[17:42:26.486]             }
[17:42:26.486]         }
[17:42:26.486]     })
[17:42:26.486]     if (TRUE) {
[17:42:26.486]         base::sink(type = "output", split = FALSE)
[17:42:26.486]         if (TRUE) {
[17:42:26.486]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:26.486]         }
[17:42:26.486]         else {
[17:42:26.486]             ...future.result["stdout"] <- base::list(NULL)
[17:42:26.486]         }
[17:42:26.486]         base::close(...future.stdout)
[17:42:26.486]         ...future.stdout <- NULL
[17:42:26.486]     }
[17:42:26.486]     ...future.result$conditions <- ...future.conditions
[17:42:26.486]     ...future.result$finished <- base::Sys.time()
[17:42:26.486]     ...future.result
[17:42:26.486] }
[17:42:26.489] requestCore(): workers = 2
[17:42:26.491] MulticoreFuture started
[17:42:26.491] - Launch lazy future ... done
[17:42:26.491] run() for ‘MulticoreFuture’ ... done
[17:42:26.492] plan(): Setting new future strategy stack:
[17:42:26.492] List of future strategies:
[17:42:26.492] 1. sequential:
[17:42:26.492]    - args: function (..., envir = parent.frame())
[17:42:26.492]    - tweaked: FALSE
[17:42:26.492]    - call: NULL
[17:42:26.493] plan(): nbrOfWorkers() = 1
[17:42:26.497] plan(): Setting new future strategy stack:
[17:42:26.497] List of future strategies:
[17:42:26.497] 1. multicore:
[17:42:26.497]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:26.497]    - tweaked: FALSE
[17:42:26.497]    - call: plan(strategy)
[17:42:26.503] plan(): nbrOfWorkers() = 2

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[17:42:26.509] getGlobalsAndPackages() ...
[17:42:26.510] Searching for globals...
[17:42:26.516] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[17:42:26.516] Searching for globals ... DONE
[17:42:26.516] Resolving globals: FALSE
[17:42:26.517] 
[17:42:26.517] - packages: [2] ‘stats’, ‘datasets’
[17:42:26.517] getGlobalsAndPackages() ... DONE
[17:42:26.517] run() for ‘Future’ ...
[17:42:26.518] - state: ‘created’
[17:42:26.518] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:26.522] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:26.522] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:26.523]   - Field: ‘label’
[17:42:26.523]   - Field: ‘local’
[17:42:26.523]   - Field: ‘owner’
[17:42:26.523]   - Field: ‘envir’
[17:42:26.523]   - Field: ‘workers’
[17:42:26.523]   - Field: ‘packages’
[17:42:26.523]   - Field: ‘gc’
[17:42:26.524]   - Field: ‘job’
[17:42:26.524]   - Field: ‘conditions’
[17:42:26.524]   - Field: ‘expr’
[17:42:26.524]   - Field: ‘uuid’
[17:42:26.524]   - Field: ‘seed’
[17:42:26.524]   - Field: ‘version’
[17:42:26.524]   - Field: ‘result’
[17:42:26.524]   - Field: ‘asynchronous’
[17:42:26.525]   - Field: ‘calls’
[17:42:26.525]   - Field: ‘globals’
[17:42:26.525]   - Field: ‘stdout’
[17:42:26.525]   - Field: ‘earlySignal’
[17:42:26.525]   - Field: ‘lazy’
[17:42:26.525]   - Field: ‘state’
[17:42:26.525] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:26.526] - Launch lazy future ...
[17:42:26.526] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:42:26.526] Packages needed by future strategies (n = 0): <none>
[17:42:26.527] {
[17:42:26.527]     {
[17:42:26.527]         {
[17:42:26.527]             ...future.startTime <- base::Sys.time()
[17:42:26.527]             {
[17:42:26.527]                 {
[17:42:26.527]                   {
[17:42:26.527]                     {
[17:42:26.527]                       {
[17:42:26.527]                         base::local({
[17:42:26.527]                           has_future <- base::requireNamespace("future", 
[17:42:26.527]                             quietly = TRUE)
[17:42:26.527]                           if (has_future) {
[17:42:26.527]                             ns <- base::getNamespace("future")
[17:42:26.527]                             version <- ns[[".package"]][["version"]]
[17:42:26.527]                             if (is.null(version)) 
[17:42:26.527]                               version <- utils::packageVersion("future")
[17:42:26.527]                           }
[17:42:26.527]                           else {
[17:42:26.527]                             version <- NULL
[17:42:26.527]                           }
[17:42:26.527]                           if (!has_future || version < "1.8.0") {
[17:42:26.527]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:26.527]                               "", base::R.version$version.string), 
[17:42:26.527]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:26.527]                                 base::R.version$platform, 8 * 
[17:42:26.527]                                   base::.Machine$sizeof.pointer), 
[17:42:26.527]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:26.527]                                 "release", "version")], collapse = " "), 
[17:42:26.527]                               hostname = base::Sys.info()[["nodename"]])
[17:42:26.527]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:26.527]                               info)
[17:42:26.527]                             info <- base::paste(info, collapse = "; ")
[17:42:26.527]                             if (!has_future) {
[17:42:26.527]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:26.527]                                 info)
[17:42:26.527]                             }
[17:42:26.527]                             else {
[17:42:26.527]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:26.527]                                 info, version)
[17:42:26.527]                             }
[17:42:26.527]                             base::stop(msg)
[17:42:26.527]                           }
[17:42:26.527]                         })
[17:42:26.527]                       }
[17:42:26.527]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:26.527]                       base::options(mc.cores = 1L)
[17:42:26.527]                     }
[17:42:26.527]                     base::local({
[17:42:26.527]                       for (pkg in c("stats", "datasets")) {
[17:42:26.527]                         base::loadNamespace(pkg)
[17:42:26.527]                         base::library(pkg, character.only = TRUE)
[17:42:26.527]                       }
[17:42:26.527]                     })
[17:42:26.527]                   }
[17:42:26.527]                   options(future.plan = NULL)
[17:42:26.527]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:26.527]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:26.527]                 }
[17:42:26.527]                 ...future.workdir <- getwd()
[17:42:26.527]             }
[17:42:26.527]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:26.527]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:26.527]         }
[17:42:26.527]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:26.527]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:26.527]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:26.527]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:26.527]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:26.527]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:26.527]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:26.527]             base::names(...future.oldOptions))
[17:42:26.527]     }
[17:42:26.527]     if (FALSE) {
[17:42:26.527]     }
[17:42:26.527]     else {
[17:42:26.527]         if (TRUE) {
[17:42:26.527]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:26.527]                 open = "w")
[17:42:26.527]         }
[17:42:26.527]         else {
[17:42:26.527]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:26.527]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:26.527]         }
[17:42:26.527]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:26.527]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:26.527]             base::sink(type = "output", split = FALSE)
[17:42:26.527]             base::close(...future.stdout)
[17:42:26.527]         }, add = TRUE)
[17:42:26.527]     }
[17:42:26.527]     ...future.frame <- base::sys.nframe()
[17:42:26.527]     ...future.conditions <- base::list()
[17:42:26.527]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:26.527]     if (FALSE) {
[17:42:26.527]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:26.527]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:26.527]     }
[17:42:26.527]     ...future.result <- base::tryCatch({
[17:42:26.527]         base::withCallingHandlers({
[17:42:26.527]             ...future.value <- base::withVisible(base::local({
[17:42:26.527]                 withCallingHandlers({
[17:42:26.527]                   {
[17:42:26.527]                     lm(dist ~ speed + I(speed^2), data = cars)
[17:42:26.527]                   }
[17:42:26.527]                 }, immediateCondition = function(cond) {
[17:42:26.527]                   save_rds <- function (object, pathname, ...) 
[17:42:26.527]                   {
[17:42:26.527]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:26.527]                     if (file_test("-f", pathname_tmp)) {
[17:42:26.527]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.527]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:26.527]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.527]                         fi_tmp[["mtime"]])
[17:42:26.527]                     }
[17:42:26.527]                     tryCatch({
[17:42:26.527]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:26.527]                     }, error = function(ex) {
[17:42:26.527]                       msg <- conditionMessage(ex)
[17:42:26.527]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.527]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:26.527]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.527]                         fi_tmp[["mtime"]], msg)
[17:42:26.527]                       ex$message <- msg
[17:42:26.527]                       stop(ex)
[17:42:26.527]                     })
[17:42:26.527]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:26.527]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:26.527]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:26.527]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.527]                       fi <- file.info(pathname)
[17:42:26.527]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:26.527]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.527]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:26.527]                         fi[["size"]], fi[["mtime"]])
[17:42:26.527]                       stop(msg)
[17:42:26.527]                     }
[17:42:26.527]                     invisible(pathname)
[17:42:26.527]                   }
[17:42:26.527]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:26.527]                     rootPath = tempdir()) 
[17:42:26.527]                   {
[17:42:26.527]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:26.527]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:26.527]                       tmpdir = path, fileext = ".rds")
[17:42:26.527]                     save_rds(obj, file)
[17:42:26.527]                   }
[17:42:26.527]                   saveImmediateCondition(cond, path = "/tmp/RtmpNwFxwa/.future/immediateConditions")
[17:42:26.527]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.527]                   {
[17:42:26.527]                     inherits <- base::inherits
[17:42:26.527]                     invokeRestart <- base::invokeRestart
[17:42:26.527]                     is.null <- base::is.null
[17:42:26.527]                     muffled <- FALSE
[17:42:26.527]                     if (inherits(cond, "message")) {
[17:42:26.527]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:26.527]                       if (muffled) 
[17:42:26.527]                         invokeRestart("muffleMessage")
[17:42:26.527]                     }
[17:42:26.527]                     else if (inherits(cond, "warning")) {
[17:42:26.527]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:26.527]                       if (muffled) 
[17:42:26.527]                         invokeRestart("muffleWarning")
[17:42:26.527]                     }
[17:42:26.527]                     else if (inherits(cond, "condition")) {
[17:42:26.527]                       if (!is.null(pattern)) {
[17:42:26.527]                         computeRestarts <- base::computeRestarts
[17:42:26.527]                         grepl <- base::grepl
[17:42:26.527]                         restarts <- computeRestarts(cond)
[17:42:26.527]                         for (restart in restarts) {
[17:42:26.527]                           name <- restart$name
[17:42:26.527]                           if (is.null(name)) 
[17:42:26.527]                             next
[17:42:26.527]                           if (!grepl(pattern, name)) 
[17:42:26.527]                             next
[17:42:26.527]                           invokeRestart(restart)
[17:42:26.527]                           muffled <- TRUE
[17:42:26.527]                           break
[17:42:26.527]                         }
[17:42:26.527]                       }
[17:42:26.527]                     }
[17:42:26.527]                     invisible(muffled)
[17:42:26.527]                   }
[17:42:26.527]                   muffleCondition(cond)
[17:42:26.527]                 })
[17:42:26.527]             }))
[17:42:26.527]             future::FutureResult(value = ...future.value$value, 
[17:42:26.527]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:26.527]                   ...future.rng), globalenv = if (FALSE) 
[17:42:26.527]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:26.527]                     ...future.globalenv.names))
[17:42:26.527]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:26.527]         }, condition = base::local({
[17:42:26.527]             c <- base::c
[17:42:26.527]             inherits <- base::inherits
[17:42:26.527]             invokeRestart <- base::invokeRestart
[17:42:26.527]             length <- base::length
[17:42:26.527]             list <- base::list
[17:42:26.527]             seq.int <- base::seq.int
[17:42:26.527]             signalCondition <- base::signalCondition
[17:42:26.527]             sys.calls <- base::sys.calls
[17:42:26.527]             `[[` <- base::`[[`
[17:42:26.527]             `+` <- base::`+`
[17:42:26.527]             `<<-` <- base::`<<-`
[17:42:26.527]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:26.527]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:26.527]                   3L)]
[17:42:26.527]             }
[17:42:26.527]             function(cond) {
[17:42:26.527]                 is_error <- inherits(cond, "error")
[17:42:26.527]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:26.527]                   NULL)
[17:42:26.527]                 if (is_error) {
[17:42:26.527]                   sessionInformation <- function() {
[17:42:26.527]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:26.527]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:26.527]                       search = base::search(), system = base::Sys.info())
[17:42:26.527]                   }
[17:42:26.527]                   ...future.conditions[[length(...future.conditions) + 
[17:42:26.527]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:26.527]                     cond$call), session = sessionInformation(), 
[17:42:26.527]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:26.527]                   signalCondition(cond)
[17:42:26.527]                 }
[17:42:26.527]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:26.527]                 "immediateCondition"))) {
[17:42:26.527]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:26.527]                   ...future.conditions[[length(...future.conditions) + 
[17:42:26.527]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:26.527]                   if (TRUE && !signal) {
[17:42:26.527]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.527]                     {
[17:42:26.527]                       inherits <- base::inherits
[17:42:26.527]                       invokeRestart <- base::invokeRestart
[17:42:26.527]                       is.null <- base::is.null
[17:42:26.527]                       muffled <- FALSE
[17:42:26.527]                       if (inherits(cond, "message")) {
[17:42:26.527]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:26.527]                         if (muffled) 
[17:42:26.527]                           invokeRestart("muffleMessage")
[17:42:26.527]                       }
[17:42:26.527]                       else if (inherits(cond, "warning")) {
[17:42:26.527]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:26.527]                         if (muffled) 
[17:42:26.527]                           invokeRestart("muffleWarning")
[17:42:26.527]                       }
[17:42:26.527]                       else if (inherits(cond, "condition")) {
[17:42:26.527]                         if (!is.null(pattern)) {
[17:42:26.527]                           computeRestarts <- base::computeRestarts
[17:42:26.527]                           grepl <- base::grepl
[17:42:26.527]                           restarts <- computeRestarts(cond)
[17:42:26.527]                           for (restart in restarts) {
[17:42:26.527]                             name <- restart$name
[17:42:26.527]                             if (is.null(name)) 
[17:42:26.527]                               next
[17:42:26.527]                             if (!grepl(pattern, name)) 
[17:42:26.527]                               next
[17:42:26.527]                             invokeRestart(restart)
[17:42:26.527]                             muffled <- TRUE
[17:42:26.527]                             break
[17:42:26.527]                           }
[17:42:26.527]                         }
[17:42:26.527]                       }
[17:42:26.527]                       invisible(muffled)
[17:42:26.527]                     }
[17:42:26.527]                     muffleCondition(cond, pattern = "^muffle")
[17:42:26.527]                   }
[17:42:26.527]                 }
[17:42:26.527]                 else {
[17:42:26.527]                   if (TRUE) {
[17:42:26.527]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.527]                     {
[17:42:26.527]                       inherits <- base::inherits
[17:42:26.527]                       invokeRestart <- base::invokeRestart
[17:42:26.527]                       is.null <- base::is.null
[17:42:26.527]                       muffled <- FALSE
[17:42:26.527]                       if (inherits(cond, "message")) {
[17:42:26.527]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:26.527]                         if (muffled) 
[17:42:26.527]                           invokeRestart("muffleMessage")
[17:42:26.527]                       }
[17:42:26.527]                       else if (inherits(cond, "warning")) {
[17:42:26.527]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:26.527]                         if (muffled) 
[17:42:26.527]                           invokeRestart("muffleWarning")
[17:42:26.527]                       }
[17:42:26.527]                       else if (inherits(cond, "condition")) {
[17:42:26.527]                         if (!is.null(pattern)) {
[17:42:26.527]                           computeRestarts <- base::computeRestarts
[17:42:26.527]                           grepl <- base::grepl
[17:42:26.527]                           restarts <- computeRestarts(cond)
[17:42:26.527]                           for (restart in restarts) {
[17:42:26.527]                             name <- restart$name
[17:42:26.527]                             if (is.null(name)) 
[17:42:26.527]                               next
[17:42:26.527]                             if (!grepl(pattern, name)) 
[17:42:26.527]                               next
[17:42:26.527]                             invokeRestart(restart)
[17:42:26.527]                             muffled <- TRUE
[17:42:26.527]                             break
[17:42:26.527]                           }
[17:42:26.527]                         }
[17:42:26.527]                       }
[17:42:26.527]                       invisible(muffled)
[17:42:26.527]                     }
[17:42:26.527]                     muffleCondition(cond, pattern = "^muffle")
[17:42:26.527]                   }
[17:42:26.527]                 }
[17:42:26.527]             }
[17:42:26.527]         }))
[17:42:26.527]     }, error = function(ex) {
[17:42:26.527]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:26.527]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:26.527]                 ...future.rng), started = ...future.startTime, 
[17:42:26.527]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:26.527]             version = "1.8"), class = "FutureResult")
[17:42:26.527]     }, finally = {
[17:42:26.527]         if (!identical(...future.workdir, getwd())) 
[17:42:26.527]             setwd(...future.workdir)
[17:42:26.527]         {
[17:42:26.527]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:26.527]                 ...future.oldOptions$nwarnings <- NULL
[17:42:26.527]             }
[17:42:26.527]             base::options(...future.oldOptions)
[17:42:26.527]             if (.Platform$OS.type == "windows") {
[17:42:26.527]                 old_names <- names(...future.oldEnvVars)
[17:42:26.527]                 envs <- base::Sys.getenv()
[17:42:26.527]                 names <- names(envs)
[17:42:26.527]                 common <- intersect(names, old_names)
[17:42:26.527]                 added <- setdiff(names, old_names)
[17:42:26.527]                 removed <- setdiff(old_names, names)
[17:42:26.527]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:26.527]                   envs[common]]
[17:42:26.527]                 NAMES <- toupper(changed)
[17:42:26.527]                 args <- list()
[17:42:26.527]                 for (kk in seq_along(NAMES)) {
[17:42:26.527]                   name <- changed[[kk]]
[17:42:26.527]                   NAME <- NAMES[[kk]]
[17:42:26.527]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.527]                     next
[17:42:26.527]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:26.527]                 }
[17:42:26.527]                 NAMES <- toupper(added)
[17:42:26.527]                 for (kk in seq_along(NAMES)) {
[17:42:26.527]                   name <- added[[kk]]
[17:42:26.527]                   NAME <- NAMES[[kk]]
[17:42:26.527]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.527]                     next
[17:42:26.527]                   args[[name]] <- ""
[17:42:26.527]                 }
[17:42:26.527]                 NAMES <- toupper(removed)
[17:42:26.527]                 for (kk in seq_along(NAMES)) {
[17:42:26.527]                   name <- removed[[kk]]
[17:42:26.527]                   NAME <- NAMES[[kk]]
[17:42:26.527]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.527]                     next
[17:42:26.527]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:26.527]                 }
[17:42:26.527]                 if (length(args) > 0) 
[17:42:26.527]                   base::do.call(base::Sys.setenv, args = args)
[17:42:26.527]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:26.527]             }
[17:42:26.527]             else {
[17:42:26.527]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:26.527]             }
[17:42:26.527]             {
[17:42:26.527]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:26.527]                   0L) {
[17:42:26.527]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:26.527]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:26.527]                   base::options(opts)
[17:42:26.527]                 }
[17:42:26.527]                 {
[17:42:26.527]                   {
[17:42:26.527]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:26.527]                     NULL
[17:42:26.527]                   }
[17:42:26.527]                   options(future.plan = NULL)
[17:42:26.527]                   if (is.na(NA_character_)) 
[17:42:26.527]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:26.527]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:26.527]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:26.527]                     envir = parent.frame()) 
[17:42:26.527]                   {
[17:42:26.527]                     default_workers <- missing(workers)
[17:42:26.527]                     if (is.function(workers)) 
[17:42:26.527]                       workers <- workers()
[17:42:26.527]                     workers <- structure(as.integer(workers), 
[17:42:26.527]                       class = class(workers))
[17:42:26.527]                     stop_if_not(is.finite(workers), workers >= 
[17:42:26.527]                       1L)
[17:42:26.527]                     if ((workers == 1L && !inherits(workers, 
[17:42:26.527]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:26.527]                       if (default_workers) 
[17:42:26.527]                         supportsMulticore(warn = TRUE)
[17:42:26.527]                       return(sequential(..., envir = envir))
[17:42:26.527]                     }
[17:42:26.527]                     oopts <- options(mc.cores = workers)
[17:42:26.527]                     on.exit(options(oopts))
[17:42:26.527]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:26.527]                       envir = envir)
[17:42:26.527]                     if (!future$lazy) 
[17:42:26.527]                       future <- run(future)
[17:42:26.527]                     invisible(future)
[17:42:26.527]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:26.527]                 }
[17:42:26.527]             }
[17:42:26.527]         }
[17:42:26.527]     })
[17:42:26.527]     if (TRUE) {
[17:42:26.527]         base::sink(type = "output", split = FALSE)
[17:42:26.527]         if (TRUE) {
[17:42:26.527]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:26.527]         }
[17:42:26.527]         else {
[17:42:26.527]             ...future.result["stdout"] <- base::list(NULL)
[17:42:26.527]         }
[17:42:26.527]         base::close(...future.stdout)
[17:42:26.527]         ...future.stdout <- NULL
[17:42:26.527]     }
[17:42:26.527]     ...future.result$conditions <- ...future.conditions
[17:42:26.527]     ...future.result$finished <- base::Sys.time()
[17:42:26.527]     ...future.result
[17:42:26.527] }
[17:42:26.529] requestCore(): workers = 2
[17:42:26.531] MulticoreFuture started
[17:42:26.532] - Launch lazy future ... done
[17:42:26.532] run() for ‘MulticoreFuture’ ... done
[17:42:26.533] plan(): Setting new future strategy stack:
[17:42:26.533] List of future strategies:
[17:42:26.533] 1. sequential:
[17:42:26.533]    - args: function (..., envir = parent.frame())
[17:42:26.533]    - tweaked: FALSE
[17:42:26.533]    - call: NULL
[17:42:26.534] plan(): nbrOfWorkers() = 1
[17:42:26.539] plan(): Setting new future strategy stack:
[17:42:26.539] List of future strategies:
[17:42:26.539] 1. multicore:
[17:42:26.539]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:26.539]    - tweaked: FALSE
[17:42:26.539]    - call: plan(strategy)
[17:42:26.544] plan(): nbrOfWorkers() = 2

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[17:42:26.551] getGlobalsAndPackages() ...
[17:42:26.551] Searching for globals...
[17:42:26.553] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[17:42:26.553] Searching for globals ... DONE
[17:42:26.553] Resolving globals: FALSE
[17:42:26.554] 
[17:42:26.554] - packages: [2] ‘stats’, ‘datasets’
[17:42:26.554] getGlobalsAndPackages() ... DONE
[17:42:26.555] run() for ‘Future’ ...
[17:42:26.555] - state: ‘created’
[17:42:26.555] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:26.559] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:26.559] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:26.559]   - Field: ‘label’
[17:42:26.559]   - Field: ‘local’
[17:42:26.559]   - Field: ‘owner’
[17:42:26.559]   - Field: ‘envir’
[17:42:26.560]   - Field: ‘workers’
[17:42:26.560]   - Field: ‘packages’
[17:42:26.560]   - Field: ‘gc’
[17:42:26.560]   - Field: ‘job’
[17:42:26.560]   - Field: ‘conditions’
[17:42:26.560]   - Field: ‘expr’
[17:42:26.560]   - Field: ‘uuid’
[17:42:26.560]   - Field: ‘seed’
[17:42:26.561]   - Field: ‘version’
[17:42:26.561]   - Field: ‘result’
[17:42:26.561]   - Field: ‘asynchronous’
[17:42:26.561]   - Field: ‘calls’
[17:42:26.561]   - Field: ‘globals’
[17:42:26.561]   - Field: ‘stdout’
[17:42:26.561]   - Field: ‘earlySignal’
[17:42:26.561]   - Field: ‘lazy’
[17:42:26.562]   - Field: ‘state’
[17:42:26.562] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:26.562] - Launch lazy future ...
[17:42:26.562] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:42:26.562] Packages needed by future strategies (n = 0): <none>
[17:42:26.563] {
[17:42:26.563]     {
[17:42:26.563]         {
[17:42:26.563]             ...future.startTime <- base::Sys.time()
[17:42:26.563]             {
[17:42:26.563]                 {
[17:42:26.563]                   {
[17:42:26.563]                     {
[17:42:26.563]                       {
[17:42:26.563]                         base::local({
[17:42:26.563]                           has_future <- base::requireNamespace("future", 
[17:42:26.563]                             quietly = TRUE)
[17:42:26.563]                           if (has_future) {
[17:42:26.563]                             ns <- base::getNamespace("future")
[17:42:26.563]                             version <- ns[[".package"]][["version"]]
[17:42:26.563]                             if (is.null(version)) 
[17:42:26.563]                               version <- utils::packageVersion("future")
[17:42:26.563]                           }
[17:42:26.563]                           else {
[17:42:26.563]                             version <- NULL
[17:42:26.563]                           }
[17:42:26.563]                           if (!has_future || version < "1.8.0") {
[17:42:26.563]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:26.563]                               "", base::R.version$version.string), 
[17:42:26.563]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:26.563]                                 base::R.version$platform, 8 * 
[17:42:26.563]                                   base::.Machine$sizeof.pointer), 
[17:42:26.563]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:26.563]                                 "release", "version")], collapse = " "), 
[17:42:26.563]                               hostname = base::Sys.info()[["nodename"]])
[17:42:26.563]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:26.563]                               info)
[17:42:26.563]                             info <- base::paste(info, collapse = "; ")
[17:42:26.563]                             if (!has_future) {
[17:42:26.563]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:26.563]                                 info)
[17:42:26.563]                             }
[17:42:26.563]                             else {
[17:42:26.563]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:26.563]                                 info, version)
[17:42:26.563]                             }
[17:42:26.563]                             base::stop(msg)
[17:42:26.563]                           }
[17:42:26.563]                         })
[17:42:26.563]                       }
[17:42:26.563]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:26.563]                       base::options(mc.cores = 1L)
[17:42:26.563]                     }
[17:42:26.563]                     base::local({
[17:42:26.563]                       for (pkg in c("stats", "datasets")) {
[17:42:26.563]                         base::loadNamespace(pkg)
[17:42:26.563]                         base::library(pkg, character.only = TRUE)
[17:42:26.563]                       }
[17:42:26.563]                     })
[17:42:26.563]                   }
[17:42:26.563]                   options(future.plan = NULL)
[17:42:26.563]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:26.563]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:26.563]                 }
[17:42:26.563]                 ...future.workdir <- getwd()
[17:42:26.563]             }
[17:42:26.563]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:26.563]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:26.563]         }
[17:42:26.563]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:26.563]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:26.563]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:26.563]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:26.563]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:26.563]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:26.563]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:26.563]             base::names(...future.oldOptions))
[17:42:26.563]     }
[17:42:26.563]     if (FALSE) {
[17:42:26.563]     }
[17:42:26.563]     else {
[17:42:26.563]         if (TRUE) {
[17:42:26.563]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:26.563]                 open = "w")
[17:42:26.563]         }
[17:42:26.563]         else {
[17:42:26.563]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:26.563]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:26.563]         }
[17:42:26.563]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:26.563]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:26.563]             base::sink(type = "output", split = FALSE)
[17:42:26.563]             base::close(...future.stdout)
[17:42:26.563]         }, add = TRUE)
[17:42:26.563]     }
[17:42:26.563]     ...future.frame <- base::sys.nframe()
[17:42:26.563]     ...future.conditions <- base::list()
[17:42:26.563]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:26.563]     if (FALSE) {
[17:42:26.563]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:26.563]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:26.563]     }
[17:42:26.563]     ...future.result <- base::tryCatch({
[17:42:26.563]         base::withCallingHandlers({
[17:42:26.563]             ...future.value <- base::withVisible(base::local({
[17:42:26.563]                 withCallingHandlers({
[17:42:26.563]                   {
[17:42:26.563]                     lm(dist ~ poly(speed, 2), data = cars)
[17:42:26.563]                   }
[17:42:26.563]                 }, immediateCondition = function(cond) {
[17:42:26.563]                   save_rds <- function (object, pathname, ...) 
[17:42:26.563]                   {
[17:42:26.563]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:26.563]                     if (file_test("-f", pathname_tmp)) {
[17:42:26.563]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.563]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:26.563]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.563]                         fi_tmp[["mtime"]])
[17:42:26.563]                     }
[17:42:26.563]                     tryCatch({
[17:42:26.563]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:26.563]                     }, error = function(ex) {
[17:42:26.563]                       msg <- conditionMessage(ex)
[17:42:26.563]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.563]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:26.563]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.563]                         fi_tmp[["mtime"]], msg)
[17:42:26.563]                       ex$message <- msg
[17:42:26.563]                       stop(ex)
[17:42:26.563]                     })
[17:42:26.563]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:26.563]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:26.563]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:26.563]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.563]                       fi <- file.info(pathname)
[17:42:26.563]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:26.563]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.563]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:26.563]                         fi[["size"]], fi[["mtime"]])
[17:42:26.563]                       stop(msg)
[17:42:26.563]                     }
[17:42:26.563]                     invisible(pathname)
[17:42:26.563]                   }
[17:42:26.563]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:26.563]                     rootPath = tempdir()) 
[17:42:26.563]                   {
[17:42:26.563]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:26.563]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:26.563]                       tmpdir = path, fileext = ".rds")
[17:42:26.563]                     save_rds(obj, file)
[17:42:26.563]                   }
[17:42:26.563]                   saveImmediateCondition(cond, path = "/tmp/RtmpNwFxwa/.future/immediateConditions")
[17:42:26.563]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.563]                   {
[17:42:26.563]                     inherits <- base::inherits
[17:42:26.563]                     invokeRestart <- base::invokeRestart
[17:42:26.563]                     is.null <- base::is.null
[17:42:26.563]                     muffled <- FALSE
[17:42:26.563]                     if (inherits(cond, "message")) {
[17:42:26.563]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:26.563]                       if (muffled) 
[17:42:26.563]                         invokeRestart("muffleMessage")
[17:42:26.563]                     }
[17:42:26.563]                     else if (inherits(cond, "warning")) {
[17:42:26.563]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:26.563]                       if (muffled) 
[17:42:26.563]                         invokeRestart("muffleWarning")
[17:42:26.563]                     }
[17:42:26.563]                     else if (inherits(cond, "condition")) {
[17:42:26.563]                       if (!is.null(pattern)) {
[17:42:26.563]                         computeRestarts <- base::computeRestarts
[17:42:26.563]                         grepl <- base::grepl
[17:42:26.563]                         restarts <- computeRestarts(cond)
[17:42:26.563]                         for (restart in restarts) {
[17:42:26.563]                           name <- restart$name
[17:42:26.563]                           if (is.null(name)) 
[17:42:26.563]                             next
[17:42:26.563]                           if (!grepl(pattern, name)) 
[17:42:26.563]                             next
[17:42:26.563]                           invokeRestart(restart)
[17:42:26.563]                           muffled <- TRUE
[17:42:26.563]                           break
[17:42:26.563]                         }
[17:42:26.563]                       }
[17:42:26.563]                     }
[17:42:26.563]                     invisible(muffled)
[17:42:26.563]                   }
[17:42:26.563]                   muffleCondition(cond)
[17:42:26.563]                 })
[17:42:26.563]             }))
[17:42:26.563]             future::FutureResult(value = ...future.value$value, 
[17:42:26.563]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:26.563]                   ...future.rng), globalenv = if (FALSE) 
[17:42:26.563]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:26.563]                     ...future.globalenv.names))
[17:42:26.563]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:26.563]         }, condition = base::local({
[17:42:26.563]             c <- base::c
[17:42:26.563]             inherits <- base::inherits
[17:42:26.563]             invokeRestart <- base::invokeRestart
[17:42:26.563]             length <- base::length
[17:42:26.563]             list <- base::list
[17:42:26.563]             seq.int <- base::seq.int
[17:42:26.563]             signalCondition <- base::signalCondition
[17:42:26.563]             sys.calls <- base::sys.calls
[17:42:26.563]             `[[` <- base::`[[`
[17:42:26.563]             `+` <- base::`+`
[17:42:26.563]             `<<-` <- base::`<<-`
[17:42:26.563]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:26.563]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:26.563]                   3L)]
[17:42:26.563]             }
[17:42:26.563]             function(cond) {
[17:42:26.563]                 is_error <- inherits(cond, "error")
[17:42:26.563]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:26.563]                   NULL)
[17:42:26.563]                 if (is_error) {
[17:42:26.563]                   sessionInformation <- function() {
[17:42:26.563]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:26.563]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:26.563]                       search = base::search(), system = base::Sys.info())
[17:42:26.563]                   }
[17:42:26.563]                   ...future.conditions[[length(...future.conditions) + 
[17:42:26.563]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:26.563]                     cond$call), session = sessionInformation(), 
[17:42:26.563]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:26.563]                   signalCondition(cond)
[17:42:26.563]                 }
[17:42:26.563]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:26.563]                 "immediateCondition"))) {
[17:42:26.563]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:26.563]                   ...future.conditions[[length(...future.conditions) + 
[17:42:26.563]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:26.563]                   if (TRUE && !signal) {
[17:42:26.563]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.563]                     {
[17:42:26.563]                       inherits <- base::inherits
[17:42:26.563]                       invokeRestart <- base::invokeRestart
[17:42:26.563]                       is.null <- base::is.null
[17:42:26.563]                       muffled <- FALSE
[17:42:26.563]                       if (inherits(cond, "message")) {
[17:42:26.563]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:26.563]                         if (muffled) 
[17:42:26.563]                           invokeRestart("muffleMessage")
[17:42:26.563]                       }
[17:42:26.563]                       else if (inherits(cond, "warning")) {
[17:42:26.563]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:26.563]                         if (muffled) 
[17:42:26.563]                           invokeRestart("muffleWarning")
[17:42:26.563]                       }
[17:42:26.563]                       else if (inherits(cond, "condition")) {
[17:42:26.563]                         if (!is.null(pattern)) {
[17:42:26.563]                           computeRestarts <- base::computeRestarts
[17:42:26.563]                           grepl <- base::grepl
[17:42:26.563]                           restarts <- computeRestarts(cond)
[17:42:26.563]                           for (restart in restarts) {
[17:42:26.563]                             name <- restart$name
[17:42:26.563]                             if (is.null(name)) 
[17:42:26.563]                               next
[17:42:26.563]                             if (!grepl(pattern, name)) 
[17:42:26.563]                               next
[17:42:26.563]                             invokeRestart(restart)
[17:42:26.563]                             muffled <- TRUE
[17:42:26.563]                             break
[17:42:26.563]                           }
[17:42:26.563]                         }
[17:42:26.563]                       }
[17:42:26.563]                       invisible(muffled)
[17:42:26.563]                     }
[17:42:26.563]                     muffleCondition(cond, pattern = "^muffle")
[17:42:26.563]                   }
[17:42:26.563]                 }
[17:42:26.563]                 else {
[17:42:26.563]                   if (TRUE) {
[17:42:26.563]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.563]                     {
[17:42:26.563]                       inherits <- base::inherits
[17:42:26.563]                       invokeRestart <- base::invokeRestart
[17:42:26.563]                       is.null <- base::is.null
[17:42:26.563]                       muffled <- FALSE
[17:42:26.563]                       if (inherits(cond, "message")) {
[17:42:26.563]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:26.563]                         if (muffled) 
[17:42:26.563]                           invokeRestart("muffleMessage")
[17:42:26.563]                       }
[17:42:26.563]                       else if (inherits(cond, "warning")) {
[17:42:26.563]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:26.563]                         if (muffled) 
[17:42:26.563]                           invokeRestart("muffleWarning")
[17:42:26.563]                       }
[17:42:26.563]                       else if (inherits(cond, "condition")) {
[17:42:26.563]                         if (!is.null(pattern)) {
[17:42:26.563]                           computeRestarts <- base::computeRestarts
[17:42:26.563]                           grepl <- base::grepl
[17:42:26.563]                           restarts <- computeRestarts(cond)
[17:42:26.563]                           for (restart in restarts) {
[17:42:26.563]                             name <- restart$name
[17:42:26.563]                             if (is.null(name)) 
[17:42:26.563]                               next
[17:42:26.563]                             if (!grepl(pattern, name)) 
[17:42:26.563]                               next
[17:42:26.563]                             invokeRestart(restart)
[17:42:26.563]                             muffled <- TRUE
[17:42:26.563]                             break
[17:42:26.563]                           }
[17:42:26.563]                         }
[17:42:26.563]                       }
[17:42:26.563]                       invisible(muffled)
[17:42:26.563]                     }
[17:42:26.563]                     muffleCondition(cond, pattern = "^muffle")
[17:42:26.563]                   }
[17:42:26.563]                 }
[17:42:26.563]             }
[17:42:26.563]         }))
[17:42:26.563]     }, error = function(ex) {
[17:42:26.563]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:26.563]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:26.563]                 ...future.rng), started = ...future.startTime, 
[17:42:26.563]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:26.563]             version = "1.8"), class = "FutureResult")
[17:42:26.563]     }, finally = {
[17:42:26.563]         if (!identical(...future.workdir, getwd())) 
[17:42:26.563]             setwd(...future.workdir)
[17:42:26.563]         {
[17:42:26.563]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:26.563]                 ...future.oldOptions$nwarnings <- NULL
[17:42:26.563]             }
[17:42:26.563]             base::options(...future.oldOptions)
[17:42:26.563]             if (.Platform$OS.type == "windows") {
[17:42:26.563]                 old_names <- names(...future.oldEnvVars)
[17:42:26.563]                 envs <- base::Sys.getenv()
[17:42:26.563]                 names <- names(envs)
[17:42:26.563]                 common <- intersect(names, old_names)
[17:42:26.563]                 added <- setdiff(names, old_names)
[17:42:26.563]                 removed <- setdiff(old_names, names)
[17:42:26.563]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:26.563]                   envs[common]]
[17:42:26.563]                 NAMES <- toupper(changed)
[17:42:26.563]                 args <- list()
[17:42:26.563]                 for (kk in seq_along(NAMES)) {
[17:42:26.563]                   name <- changed[[kk]]
[17:42:26.563]                   NAME <- NAMES[[kk]]
[17:42:26.563]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.563]                     next
[17:42:26.563]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:26.563]                 }
[17:42:26.563]                 NAMES <- toupper(added)
[17:42:26.563]                 for (kk in seq_along(NAMES)) {
[17:42:26.563]                   name <- added[[kk]]
[17:42:26.563]                   NAME <- NAMES[[kk]]
[17:42:26.563]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.563]                     next
[17:42:26.563]                   args[[name]] <- ""
[17:42:26.563]                 }
[17:42:26.563]                 NAMES <- toupper(removed)
[17:42:26.563]                 for (kk in seq_along(NAMES)) {
[17:42:26.563]                   name <- removed[[kk]]
[17:42:26.563]                   NAME <- NAMES[[kk]]
[17:42:26.563]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.563]                     next
[17:42:26.563]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:26.563]                 }
[17:42:26.563]                 if (length(args) > 0) 
[17:42:26.563]                   base::do.call(base::Sys.setenv, args = args)
[17:42:26.563]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:26.563]             }
[17:42:26.563]             else {
[17:42:26.563]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:26.563]             }
[17:42:26.563]             {
[17:42:26.563]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:26.563]                   0L) {
[17:42:26.563]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:26.563]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:26.563]                   base::options(opts)
[17:42:26.563]                 }
[17:42:26.563]                 {
[17:42:26.563]                   {
[17:42:26.563]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:26.563]                     NULL
[17:42:26.563]                   }
[17:42:26.563]                   options(future.plan = NULL)
[17:42:26.563]                   if (is.na(NA_character_)) 
[17:42:26.563]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:26.563]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:26.563]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:26.563]                     envir = parent.frame()) 
[17:42:26.563]                   {
[17:42:26.563]                     default_workers <- missing(workers)
[17:42:26.563]                     if (is.function(workers)) 
[17:42:26.563]                       workers <- workers()
[17:42:26.563]                     workers <- structure(as.integer(workers), 
[17:42:26.563]                       class = class(workers))
[17:42:26.563]                     stop_if_not(is.finite(workers), workers >= 
[17:42:26.563]                       1L)
[17:42:26.563]                     if ((workers == 1L && !inherits(workers, 
[17:42:26.563]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:26.563]                       if (default_workers) 
[17:42:26.563]                         supportsMulticore(warn = TRUE)
[17:42:26.563]                       return(sequential(..., envir = envir))
[17:42:26.563]                     }
[17:42:26.563]                     oopts <- options(mc.cores = workers)
[17:42:26.563]                     on.exit(options(oopts))
[17:42:26.563]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:26.563]                       envir = envir)
[17:42:26.563]                     if (!future$lazy) 
[17:42:26.563]                       future <- run(future)
[17:42:26.563]                     invisible(future)
[17:42:26.563]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:26.563]                 }
[17:42:26.563]             }
[17:42:26.563]         }
[17:42:26.563]     })
[17:42:26.563]     if (TRUE) {
[17:42:26.563]         base::sink(type = "output", split = FALSE)
[17:42:26.563]         if (TRUE) {
[17:42:26.563]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:26.563]         }
[17:42:26.563]         else {
[17:42:26.563]             ...future.result["stdout"] <- base::list(NULL)
[17:42:26.563]         }
[17:42:26.563]         base::close(...future.stdout)
[17:42:26.563]         ...future.stdout <- NULL
[17:42:26.563]     }
[17:42:26.563]     ...future.result$conditions <- ...future.conditions
[17:42:26.563]     ...future.result$finished <- base::Sys.time()
[17:42:26.563]     ...future.result
[17:42:26.563] }
[17:42:26.566] requestCore(): workers = 2
[17:42:26.568] MulticoreFuture started
[17:42:26.568] - Launch lazy future ... done
[17:42:26.569] run() for ‘MulticoreFuture’ ... done
[17:42:26.570] plan(): Setting new future strategy stack:
[17:42:26.570] List of future strategies:
[17:42:26.570] 1. sequential:
[17:42:26.570]    - args: function (..., envir = parent.frame())
[17:42:26.570]    - tweaked: FALSE
[17:42:26.570]    - call: NULL
[17:42:26.571] plan(): nbrOfWorkers() = 1
[17:42:26.580] plan(): Setting new future strategy stack:
[17:42:26.581] List of future strategies:
[17:42:26.581] 1. multicore:
[17:42:26.581]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:26.581]    - tweaked: FALSE
[17:42:26.581]    - call: plan(strategy)
[17:42:26.587] plan(): nbrOfWorkers() = 2

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[17:42:26.596] getGlobalsAndPackages() ...
[17:42:26.596] Searching for globals...
[17:42:26.602] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[17:42:26.603] Searching for globals ... DONE
[17:42:26.603] Resolving globals: FALSE
[17:42:26.604] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[17:42:26.604] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[17:42:26.604] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[17:42:26.605] 
[17:42:26.605] getGlobalsAndPackages() ... DONE
[17:42:26.605] run() for ‘Future’ ...
[17:42:26.605] - state: ‘created’
[17:42:26.605] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:26.609] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:26.609] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:26.610]   - Field: ‘label’
[17:42:26.610]   - Field: ‘local’
[17:42:26.610]   - Field: ‘owner’
[17:42:26.610]   - Field: ‘envir’
[17:42:26.610]   - Field: ‘workers’
[17:42:26.610]   - Field: ‘packages’
[17:42:26.610]   - Field: ‘gc’
[17:42:26.610]   - Field: ‘job’
[17:42:26.611]   - Field: ‘conditions’
[17:42:26.611]   - Field: ‘expr’
[17:42:26.611]   - Field: ‘uuid’
[17:42:26.611]   - Field: ‘seed’
[17:42:26.611]   - Field: ‘version’
[17:42:26.611]   - Field: ‘result’
[17:42:26.611]   - Field: ‘asynchronous’
[17:42:26.611]   - Field: ‘calls’
[17:42:26.611]   - Field: ‘globals’
[17:42:26.612]   - Field: ‘stdout’
[17:42:26.612]   - Field: ‘earlySignal’
[17:42:26.612]   - Field: ‘lazy’
[17:42:26.612]   - Field: ‘state’
[17:42:26.612] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:26.612] - Launch lazy future ...
[17:42:26.612] Packages needed by the future expression (n = 0): <none>
[17:42:26.613] Packages needed by future strategies (n = 0): <none>
[17:42:26.613] {
[17:42:26.613]     {
[17:42:26.613]         {
[17:42:26.613]             ...future.startTime <- base::Sys.time()
[17:42:26.613]             {
[17:42:26.613]                 {
[17:42:26.613]                   {
[17:42:26.613]                     {
[17:42:26.613]                       base::local({
[17:42:26.613]                         has_future <- base::requireNamespace("future", 
[17:42:26.613]                           quietly = TRUE)
[17:42:26.613]                         if (has_future) {
[17:42:26.613]                           ns <- base::getNamespace("future")
[17:42:26.613]                           version <- ns[[".package"]][["version"]]
[17:42:26.613]                           if (is.null(version)) 
[17:42:26.613]                             version <- utils::packageVersion("future")
[17:42:26.613]                         }
[17:42:26.613]                         else {
[17:42:26.613]                           version <- NULL
[17:42:26.613]                         }
[17:42:26.613]                         if (!has_future || version < "1.8.0") {
[17:42:26.613]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:26.613]                             "", base::R.version$version.string), 
[17:42:26.613]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:26.613]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:26.613]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:26.613]                               "release", "version")], collapse = " "), 
[17:42:26.613]                             hostname = base::Sys.info()[["nodename"]])
[17:42:26.613]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:26.613]                             info)
[17:42:26.613]                           info <- base::paste(info, collapse = "; ")
[17:42:26.613]                           if (!has_future) {
[17:42:26.613]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:26.613]                               info)
[17:42:26.613]                           }
[17:42:26.613]                           else {
[17:42:26.613]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:26.613]                               info, version)
[17:42:26.613]                           }
[17:42:26.613]                           base::stop(msg)
[17:42:26.613]                         }
[17:42:26.613]                       })
[17:42:26.613]                     }
[17:42:26.613]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:26.613]                     base::options(mc.cores = 1L)
[17:42:26.613]                   }
[17:42:26.613]                   options(future.plan = NULL)
[17:42:26.613]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:26.613]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:26.613]                 }
[17:42:26.613]                 ...future.workdir <- getwd()
[17:42:26.613]             }
[17:42:26.613]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:26.613]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:26.613]         }
[17:42:26.613]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:26.613]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:26.613]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:26.613]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:26.613]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:26.613]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:26.613]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:26.613]             base::names(...future.oldOptions))
[17:42:26.613]     }
[17:42:26.613]     if (FALSE) {
[17:42:26.613]     }
[17:42:26.613]     else {
[17:42:26.613]         if (TRUE) {
[17:42:26.613]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:26.613]                 open = "w")
[17:42:26.613]         }
[17:42:26.613]         else {
[17:42:26.613]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:26.613]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:26.613]         }
[17:42:26.613]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:26.613]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:26.613]             base::sink(type = "output", split = FALSE)
[17:42:26.613]             base::close(...future.stdout)
[17:42:26.613]         }, add = TRUE)
[17:42:26.613]     }
[17:42:26.613]     ...future.frame <- base::sys.nframe()
[17:42:26.613]     ...future.conditions <- base::list()
[17:42:26.613]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:26.613]     if (FALSE) {
[17:42:26.613]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:26.613]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:26.613]     }
[17:42:26.613]     ...future.result <- base::tryCatch({
[17:42:26.613]         base::withCallingHandlers({
[17:42:26.613]             ...future.value <- base::withVisible(base::local({
[17:42:26.613]                 withCallingHandlers({
[17:42:26.613]                   {
[17:42:26.613]                     outer_function(1L)
[17:42:26.613]                   }
[17:42:26.613]                 }, immediateCondition = function(cond) {
[17:42:26.613]                   save_rds <- function (object, pathname, ...) 
[17:42:26.613]                   {
[17:42:26.613]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:26.613]                     if (file_test("-f", pathname_tmp)) {
[17:42:26.613]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.613]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:26.613]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.613]                         fi_tmp[["mtime"]])
[17:42:26.613]                     }
[17:42:26.613]                     tryCatch({
[17:42:26.613]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:26.613]                     }, error = function(ex) {
[17:42:26.613]                       msg <- conditionMessage(ex)
[17:42:26.613]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.613]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:26.613]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.613]                         fi_tmp[["mtime"]], msg)
[17:42:26.613]                       ex$message <- msg
[17:42:26.613]                       stop(ex)
[17:42:26.613]                     })
[17:42:26.613]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:26.613]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:26.613]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:26.613]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.613]                       fi <- file.info(pathname)
[17:42:26.613]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:26.613]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.613]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:26.613]                         fi[["size"]], fi[["mtime"]])
[17:42:26.613]                       stop(msg)
[17:42:26.613]                     }
[17:42:26.613]                     invisible(pathname)
[17:42:26.613]                   }
[17:42:26.613]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:26.613]                     rootPath = tempdir()) 
[17:42:26.613]                   {
[17:42:26.613]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:26.613]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:26.613]                       tmpdir = path, fileext = ".rds")
[17:42:26.613]                     save_rds(obj, file)
[17:42:26.613]                   }
[17:42:26.613]                   saveImmediateCondition(cond, path = "/tmp/RtmpNwFxwa/.future/immediateConditions")
[17:42:26.613]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.613]                   {
[17:42:26.613]                     inherits <- base::inherits
[17:42:26.613]                     invokeRestart <- base::invokeRestart
[17:42:26.613]                     is.null <- base::is.null
[17:42:26.613]                     muffled <- FALSE
[17:42:26.613]                     if (inherits(cond, "message")) {
[17:42:26.613]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:26.613]                       if (muffled) 
[17:42:26.613]                         invokeRestart("muffleMessage")
[17:42:26.613]                     }
[17:42:26.613]                     else if (inherits(cond, "warning")) {
[17:42:26.613]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:26.613]                       if (muffled) 
[17:42:26.613]                         invokeRestart("muffleWarning")
[17:42:26.613]                     }
[17:42:26.613]                     else if (inherits(cond, "condition")) {
[17:42:26.613]                       if (!is.null(pattern)) {
[17:42:26.613]                         computeRestarts <- base::computeRestarts
[17:42:26.613]                         grepl <- base::grepl
[17:42:26.613]                         restarts <- computeRestarts(cond)
[17:42:26.613]                         for (restart in restarts) {
[17:42:26.613]                           name <- restart$name
[17:42:26.613]                           if (is.null(name)) 
[17:42:26.613]                             next
[17:42:26.613]                           if (!grepl(pattern, name)) 
[17:42:26.613]                             next
[17:42:26.613]                           invokeRestart(restart)
[17:42:26.613]                           muffled <- TRUE
[17:42:26.613]                           break
[17:42:26.613]                         }
[17:42:26.613]                       }
[17:42:26.613]                     }
[17:42:26.613]                     invisible(muffled)
[17:42:26.613]                   }
[17:42:26.613]                   muffleCondition(cond)
[17:42:26.613]                 })
[17:42:26.613]             }))
[17:42:26.613]             future::FutureResult(value = ...future.value$value, 
[17:42:26.613]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:26.613]                   ...future.rng), globalenv = if (FALSE) 
[17:42:26.613]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:26.613]                     ...future.globalenv.names))
[17:42:26.613]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:26.613]         }, condition = base::local({
[17:42:26.613]             c <- base::c
[17:42:26.613]             inherits <- base::inherits
[17:42:26.613]             invokeRestart <- base::invokeRestart
[17:42:26.613]             length <- base::length
[17:42:26.613]             list <- base::list
[17:42:26.613]             seq.int <- base::seq.int
[17:42:26.613]             signalCondition <- base::signalCondition
[17:42:26.613]             sys.calls <- base::sys.calls
[17:42:26.613]             `[[` <- base::`[[`
[17:42:26.613]             `+` <- base::`+`
[17:42:26.613]             `<<-` <- base::`<<-`
[17:42:26.613]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:26.613]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:26.613]                   3L)]
[17:42:26.613]             }
[17:42:26.613]             function(cond) {
[17:42:26.613]                 is_error <- inherits(cond, "error")
[17:42:26.613]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:26.613]                   NULL)
[17:42:26.613]                 if (is_error) {
[17:42:26.613]                   sessionInformation <- function() {
[17:42:26.613]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:26.613]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:26.613]                       search = base::search(), system = base::Sys.info())
[17:42:26.613]                   }
[17:42:26.613]                   ...future.conditions[[length(...future.conditions) + 
[17:42:26.613]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:26.613]                     cond$call), session = sessionInformation(), 
[17:42:26.613]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:26.613]                   signalCondition(cond)
[17:42:26.613]                 }
[17:42:26.613]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:26.613]                 "immediateCondition"))) {
[17:42:26.613]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:26.613]                   ...future.conditions[[length(...future.conditions) + 
[17:42:26.613]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:26.613]                   if (TRUE && !signal) {
[17:42:26.613]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.613]                     {
[17:42:26.613]                       inherits <- base::inherits
[17:42:26.613]                       invokeRestart <- base::invokeRestart
[17:42:26.613]                       is.null <- base::is.null
[17:42:26.613]                       muffled <- FALSE
[17:42:26.613]                       if (inherits(cond, "message")) {
[17:42:26.613]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:26.613]                         if (muffled) 
[17:42:26.613]                           invokeRestart("muffleMessage")
[17:42:26.613]                       }
[17:42:26.613]                       else if (inherits(cond, "warning")) {
[17:42:26.613]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:26.613]                         if (muffled) 
[17:42:26.613]                           invokeRestart("muffleWarning")
[17:42:26.613]                       }
[17:42:26.613]                       else if (inherits(cond, "condition")) {
[17:42:26.613]                         if (!is.null(pattern)) {
[17:42:26.613]                           computeRestarts <- base::computeRestarts
[17:42:26.613]                           grepl <- base::grepl
[17:42:26.613]                           restarts <- computeRestarts(cond)
[17:42:26.613]                           for (restart in restarts) {
[17:42:26.613]                             name <- restart$name
[17:42:26.613]                             if (is.null(name)) 
[17:42:26.613]                               next
[17:42:26.613]                             if (!grepl(pattern, name)) 
[17:42:26.613]                               next
[17:42:26.613]                             invokeRestart(restart)
[17:42:26.613]                             muffled <- TRUE
[17:42:26.613]                             break
[17:42:26.613]                           }
[17:42:26.613]                         }
[17:42:26.613]                       }
[17:42:26.613]                       invisible(muffled)
[17:42:26.613]                     }
[17:42:26.613]                     muffleCondition(cond, pattern = "^muffle")
[17:42:26.613]                   }
[17:42:26.613]                 }
[17:42:26.613]                 else {
[17:42:26.613]                   if (TRUE) {
[17:42:26.613]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.613]                     {
[17:42:26.613]                       inherits <- base::inherits
[17:42:26.613]                       invokeRestart <- base::invokeRestart
[17:42:26.613]                       is.null <- base::is.null
[17:42:26.613]                       muffled <- FALSE
[17:42:26.613]                       if (inherits(cond, "message")) {
[17:42:26.613]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:26.613]                         if (muffled) 
[17:42:26.613]                           invokeRestart("muffleMessage")
[17:42:26.613]                       }
[17:42:26.613]                       else if (inherits(cond, "warning")) {
[17:42:26.613]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:26.613]                         if (muffled) 
[17:42:26.613]                           invokeRestart("muffleWarning")
[17:42:26.613]                       }
[17:42:26.613]                       else if (inherits(cond, "condition")) {
[17:42:26.613]                         if (!is.null(pattern)) {
[17:42:26.613]                           computeRestarts <- base::computeRestarts
[17:42:26.613]                           grepl <- base::grepl
[17:42:26.613]                           restarts <- computeRestarts(cond)
[17:42:26.613]                           for (restart in restarts) {
[17:42:26.613]                             name <- restart$name
[17:42:26.613]                             if (is.null(name)) 
[17:42:26.613]                               next
[17:42:26.613]                             if (!grepl(pattern, name)) 
[17:42:26.613]                               next
[17:42:26.613]                             invokeRestart(restart)
[17:42:26.613]                             muffled <- TRUE
[17:42:26.613]                             break
[17:42:26.613]                           }
[17:42:26.613]                         }
[17:42:26.613]                       }
[17:42:26.613]                       invisible(muffled)
[17:42:26.613]                     }
[17:42:26.613]                     muffleCondition(cond, pattern = "^muffle")
[17:42:26.613]                   }
[17:42:26.613]                 }
[17:42:26.613]             }
[17:42:26.613]         }))
[17:42:26.613]     }, error = function(ex) {
[17:42:26.613]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:26.613]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:26.613]                 ...future.rng), started = ...future.startTime, 
[17:42:26.613]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:26.613]             version = "1.8"), class = "FutureResult")
[17:42:26.613]     }, finally = {
[17:42:26.613]         if (!identical(...future.workdir, getwd())) 
[17:42:26.613]             setwd(...future.workdir)
[17:42:26.613]         {
[17:42:26.613]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:26.613]                 ...future.oldOptions$nwarnings <- NULL
[17:42:26.613]             }
[17:42:26.613]             base::options(...future.oldOptions)
[17:42:26.613]             if (.Platform$OS.type == "windows") {
[17:42:26.613]                 old_names <- names(...future.oldEnvVars)
[17:42:26.613]                 envs <- base::Sys.getenv()
[17:42:26.613]                 names <- names(envs)
[17:42:26.613]                 common <- intersect(names, old_names)
[17:42:26.613]                 added <- setdiff(names, old_names)
[17:42:26.613]                 removed <- setdiff(old_names, names)
[17:42:26.613]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:26.613]                   envs[common]]
[17:42:26.613]                 NAMES <- toupper(changed)
[17:42:26.613]                 args <- list()
[17:42:26.613]                 for (kk in seq_along(NAMES)) {
[17:42:26.613]                   name <- changed[[kk]]
[17:42:26.613]                   NAME <- NAMES[[kk]]
[17:42:26.613]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.613]                     next
[17:42:26.613]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:26.613]                 }
[17:42:26.613]                 NAMES <- toupper(added)
[17:42:26.613]                 for (kk in seq_along(NAMES)) {
[17:42:26.613]                   name <- added[[kk]]
[17:42:26.613]                   NAME <- NAMES[[kk]]
[17:42:26.613]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.613]                     next
[17:42:26.613]                   args[[name]] <- ""
[17:42:26.613]                 }
[17:42:26.613]                 NAMES <- toupper(removed)
[17:42:26.613]                 for (kk in seq_along(NAMES)) {
[17:42:26.613]                   name <- removed[[kk]]
[17:42:26.613]                   NAME <- NAMES[[kk]]
[17:42:26.613]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.613]                     next
[17:42:26.613]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:26.613]                 }
[17:42:26.613]                 if (length(args) > 0) 
[17:42:26.613]                   base::do.call(base::Sys.setenv, args = args)
[17:42:26.613]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:26.613]             }
[17:42:26.613]             else {
[17:42:26.613]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:26.613]             }
[17:42:26.613]             {
[17:42:26.613]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:26.613]                   0L) {
[17:42:26.613]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:26.613]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:26.613]                   base::options(opts)
[17:42:26.613]                 }
[17:42:26.613]                 {
[17:42:26.613]                   {
[17:42:26.613]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:26.613]                     NULL
[17:42:26.613]                   }
[17:42:26.613]                   options(future.plan = NULL)
[17:42:26.613]                   if (is.na(NA_character_)) 
[17:42:26.613]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:26.613]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:26.613]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:26.613]                     envir = parent.frame()) 
[17:42:26.613]                   {
[17:42:26.613]                     default_workers <- missing(workers)
[17:42:26.613]                     if (is.function(workers)) 
[17:42:26.613]                       workers <- workers()
[17:42:26.613]                     workers <- structure(as.integer(workers), 
[17:42:26.613]                       class = class(workers))
[17:42:26.613]                     stop_if_not(is.finite(workers), workers >= 
[17:42:26.613]                       1L)
[17:42:26.613]                     if ((workers == 1L && !inherits(workers, 
[17:42:26.613]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:26.613]                       if (default_workers) 
[17:42:26.613]                         supportsMulticore(warn = TRUE)
[17:42:26.613]                       return(sequential(..., envir = envir))
[17:42:26.613]                     }
[17:42:26.613]                     oopts <- options(mc.cores = workers)
[17:42:26.613]                     on.exit(options(oopts))
[17:42:26.613]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:26.613]                       envir = envir)
[17:42:26.613]                     if (!future$lazy) 
[17:42:26.613]                       future <- run(future)
[17:42:26.613]                     invisible(future)
[17:42:26.613]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:26.613]                 }
[17:42:26.613]             }
[17:42:26.613]         }
[17:42:26.613]     })
[17:42:26.613]     if (TRUE) {
[17:42:26.613]         base::sink(type = "output", split = FALSE)
[17:42:26.613]         if (TRUE) {
[17:42:26.613]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:26.613]         }
[17:42:26.613]         else {
[17:42:26.613]             ...future.result["stdout"] <- base::list(NULL)
[17:42:26.613]         }
[17:42:26.613]         base::close(...future.stdout)
[17:42:26.613]         ...future.stdout <- NULL
[17:42:26.613]     }
[17:42:26.613]     ...future.result$conditions <- ...future.conditions
[17:42:26.613]     ...future.result$finished <- base::Sys.time()
[17:42:26.613]     ...future.result
[17:42:26.613] }
[17:42:26.615] assign_globals() ...
[17:42:26.616] List of 3
[17:42:26.616]  $ outer_function:function (x)  
[17:42:26.616]  $ map           :function (.x, .f, ...)  
[17:42:26.616]  $ inner_function:function (x)  
[17:42:26.616]  - attr(*, "where")=List of 3
[17:42:26.616]   ..$ outer_function:<environment: R_EmptyEnv> 
[17:42:26.616]   ..$ map           :<environment: R_EmptyEnv> 
[17:42:26.616]   ..$ inner_function:<environment: R_EmptyEnv> 
[17:42:26.616]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:26.616]  - attr(*, "resolved")= logi FALSE
[17:42:26.616]  - attr(*, "total_size")= num 7704
[17:42:26.616]  - attr(*, "already-done")= logi TRUE
[17:42:26.619] - reassign environment for ‘outer_function’
[17:42:26.619] - copied ‘outer_function’ to environment
[17:42:26.620] - reassign environment for ‘map’
[17:42:26.620] - copied ‘map’ to environment
[17:42:26.620] - reassign environment for ‘inner_function’
[17:42:26.620] - copied ‘inner_function’ to environment
[17:42:26.620] assign_globals() ... done
[17:42:26.620] requestCore(): workers = 2
[17:42:26.622] MulticoreFuture started
[17:42:26.623] - Launch lazy future ... done
[17:42:26.623] run() for ‘MulticoreFuture’ ... done
[17:42:26.623] plan(): Setting new future strategy stack:
[17:42:26.624] List of future strategies:
[17:42:26.624] 1. sequential:
[17:42:26.624]    - args: function (..., envir = parent.frame())
[17:42:26.624]    - tweaked: FALSE
[17:42:26.624]    - call: NULL
[17:42:26.625] plan(): nbrOfWorkers() = 1
[17:42:26.627] plan(): Setting new future strategy stack:
[17:42:26.627] List of future strategies:
[17:42:26.627] 1. multicore:
[17:42:26.627]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:26.627]    - tweaked: FALSE
[17:42:26.627]    - call: plan(strategy)
[17:42:26.632] plan(): nbrOfWorkers() = 2
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[17:42:26.639] getGlobalsAndPackages() ...
[17:42:26.639] Searching for globals...
[17:42:26.648] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[17:42:26.648] Searching for globals ... DONE
[17:42:26.648] Resolving globals: FALSE
[17:42:26.649] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[17:42:26.649] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[17:42:26.649] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[17:42:26.650] 
[17:42:26.650] getGlobalsAndPackages() ... DONE
[17:42:26.650] run() for ‘Future’ ...
[17:42:26.650] - state: ‘created’
[17:42:26.650] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:26.655] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:26.655] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:26.656]   - Field: ‘label’
[17:42:26.656]   - Field: ‘local’
[17:42:26.656]   - Field: ‘owner’
[17:42:26.656]   - Field: ‘envir’
[17:42:26.656]   - Field: ‘workers’
[17:42:26.656]   - Field: ‘packages’
[17:42:26.656]   - Field: ‘gc’
[17:42:26.656]   - Field: ‘job’
[17:42:26.657]   - Field: ‘conditions’
[17:42:26.657]   - Field: ‘expr’
[17:42:26.657]   - Field: ‘uuid’
[17:42:26.657]   - Field: ‘seed’
[17:42:26.657]   - Field: ‘version’
[17:42:26.657]   - Field: ‘result’
[17:42:26.657]   - Field: ‘asynchronous’
[17:42:26.657]   - Field: ‘calls’
[17:42:26.658]   - Field: ‘globals’
[17:42:26.658]   - Field: ‘stdout’
[17:42:26.658]   - Field: ‘earlySignal’
[17:42:26.658]   - Field: ‘lazy’
[17:42:26.658]   - Field: ‘state’
[17:42:26.658] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:26.658] - Launch lazy future ...
[17:42:26.659] Packages needed by the future expression (n = 0): <none>
[17:42:26.659] Packages needed by future strategies (n = 0): <none>
[17:42:26.659] {
[17:42:26.659]     {
[17:42:26.659]         {
[17:42:26.659]             ...future.startTime <- base::Sys.time()
[17:42:26.659]             {
[17:42:26.659]                 {
[17:42:26.659]                   {
[17:42:26.659]                     {
[17:42:26.659]                       base::local({
[17:42:26.659]                         has_future <- base::requireNamespace("future", 
[17:42:26.659]                           quietly = TRUE)
[17:42:26.659]                         if (has_future) {
[17:42:26.659]                           ns <- base::getNamespace("future")
[17:42:26.659]                           version <- ns[[".package"]][["version"]]
[17:42:26.659]                           if (is.null(version)) 
[17:42:26.659]                             version <- utils::packageVersion("future")
[17:42:26.659]                         }
[17:42:26.659]                         else {
[17:42:26.659]                           version <- NULL
[17:42:26.659]                         }
[17:42:26.659]                         if (!has_future || version < "1.8.0") {
[17:42:26.659]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:26.659]                             "", base::R.version$version.string), 
[17:42:26.659]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:26.659]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:26.659]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:26.659]                               "release", "version")], collapse = " "), 
[17:42:26.659]                             hostname = base::Sys.info()[["nodename"]])
[17:42:26.659]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:26.659]                             info)
[17:42:26.659]                           info <- base::paste(info, collapse = "; ")
[17:42:26.659]                           if (!has_future) {
[17:42:26.659]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:26.659]                               info)
[17:42:26.659]                           }
[17:42:26.659]                           else {
[17:42:26.659]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:26.659]                               info, version)
[17:42:26.659]                           }
[17:42:26.659]                           base::stop(msg)
[17:42:26.659]                         }
[17:42:26.659]                       })
[17:42:26.659]                     }
[17:42:26.659]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:26.659]                     base::options(mc.cores = 1L)
[17:42:26.659]                   }
[17:42:26.659]                   options(future.plan = NULL)
[17:42:26.659]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:26.659]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:26.659]                 }
[17:42:26.659]                 ...future.workdir <- getwd()
[17:42:26.659]             }
[17:42:26.659]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:26.659]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:26.659]         }
[17:42:26.659]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:26.659]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:26.659]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:26.659]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:26.659]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:26.659]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:26.659]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:26.659]             base::names(...future.oldOptions))
[17:42:26.659]     }
[17:42:26.659]     if (FALSE) {
[17:42:26.659]     }
[17:42:26.659]     else {
[17:42:26.659]         if (TRUE) {
[17:42:26.659]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:26.659]                 open = "w")
[17:42:26.659]         }
[17:42:26.659]         else {
[17:42:26.659]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:26.659]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:26.659]         }
[17:42:26.659]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:26.659]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:26.659]             base::sink(type = "output", split = FALSE)
[17:42:26.659]             base::close(...future.stdout)
[17:42:26.659]         }, add = TRUE)
[17:42:26.659]     }
[17:42:26.659]     ...future.frame <- base::sys.nframe()
[17:42:26.659]     ...future.conditions <- base::list()
[17:42:26.659]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:26.659]     if (FALSE) {
[17:42:26.659]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:26.659]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:26.659]     }
[17:42:26.659]     ...future.result <- base::tryCatch({
[17:42:26.659]         base::withCallingHandlers({
[17:42:26.659]             ...future.value <- base::withVisible(base::local({
[17:42:26.659]                 withCallingHandlers({
[17:42:26.659]                   {
[17:42:26.659]                     outer_function(1L)
[17:42:26.659]                   }
[17:42:26.659]                 }, immediateCondition = function(cond) {
[17:42:26.659]                   save_rds <- function (object, pathname, ...) 
[17:42:26.659]                   {
[17:42:26.659]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:26.659]                     if (file_test("-f", pathname_tmp)) {
[17:42:26.659]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.659]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:26.659]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.659]                         fi_tmp[["mtime"]])
[17:42:26.659]                     }
[17:42:26.659]                     tryCatch({
[17:42:26.659]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:26.659]                     }, error = function(ex) {
[17:42:26.659]                       msg <- conditionMessage(ex)
[17:42:26.659]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.659]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:26.659]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.659]                         fi_tmp[["mtime"]], msg)
[17:42:26.659]                       ex$message <- msg
[17:42:26.659]                       stop(ex)
[17:42:26.659]                     })
[17:42:26.659]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:26.659]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:26.659]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:26.659]                       fi_tmp <- file.info(pathname_tmp)
[17:42:26.659]                       fi <- file.info(pathname)
[17:42:26.659]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:26.659]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:26.659]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:26.659]                         fi[["size"]], fi[["mtime"]])
[17:42:26.659]                       stop(msg)
[17:42:26.659]                     }
[17:42:26.659]                     invisible(pathname)
[17:42:26.659]                   }
[17:42:26.659]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:26.659]                     rootPath = tempdir()) 
[17:42:26.659]                   {
[17:42:26.659]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:26.659]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:26.659]                       tmpdir = path, fileext = ".rds")
[17:42:26.659]                     save_rds(obj, file)
[17:42:26.659]                   }
[17:42:26.659]                   saveImmediateCondition(cond, path = "/tmp/RtmpNwFxwa/.future/immediateConditions")
[17:42:26.659]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.659]                   {
[17:42:26.659]                     inherits <- base::inherits
[17:42:26.659]                     invokeRestart <- base::invokeRestart
[17:42:26.659]                     is.null <- base::is.null
[17:42:26.659]                     muffled <- FALSE
[17:42:26.659]                     if (inherits(cond, "message")) {
[17:42:26.659]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:26.659]                       if (muffled) 
[17:42:26.659]                         invokeRestart("muffleMessage")
[17:42:26.659]                     }
[17:42:26.659]                     else if (inherits(cond, "warning")) {
[17:42:26.659]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:26.659]                       if (muffled) 
[17:42:26.659]                         invokeRestart("muffleWarning")
[17:42:26.659]                     }
[17:42:26.659]                     else if (inherits(cond, "condition")) {
[17:42:26.659]                       if (!is.null(pattern)) {
[17:42:26.659]                         computeRestarts <- base::computeRestarts
[17:42:26.659]                         grepl <- base::grepl
[17:42:26.659]                         restarts <- computeRestarts(cond)
[17:42:26.659]                         for (restart in restarts) {
[17:42:26.659]                           name <- restart$name
[17:42:26.659]                           if (is.null(name)) 
[17:42:26.659]                             next
[17:42:26.659]                           if (!grepl(pattern, name)) 
[17:42:26.659]                             next
[17:42:26.659]                           invokeRestart(restart)
[17:42:26.659]                           muffled <- TRUE
[17:42:26.659]                           break
[17:42:26.659]                         }
[17:42:26.659]                       }
[17:42:26.659]                     }
[17:42:26.659]                     invisible(muffled)
[17:42:26.659]                   }
[17:42:26.659]                   muffleCondition(cond)
[17:42:26.659]                 })
[17:42:26.659]             }))
[17:42:26.659]             future::FutureResult(value = ...future.value$value, 
[17:42:26.659]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:26.659]                   ...future.rng), globalenv = if (FALSE) 
[17:42:26.659]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:26.659]                     ...future.globalenv.names))
[17:42:26.659]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:26.659]         }, condition = base::local({
[17:42:26.659]             c <- base::c
[17:42:26.659]             inherits <- base::inherits
[17:42:26.659]             invokeRestart <- base::invokeRestart
[17:42:26.659]             length <- base::length
[17:42:26.659]             list <- base::list
[17:42:26.659]             seq.int <- base::seq.int
[17:42:26.659]             signalCondition <- base::signalCondition
[17:42:26.659]             sys.calls <- base::sys.calls
[17:42:26.659]             `[[` <- base::`[[`
[17:42:26.659]             `+` <- base::`+`
[17:42:26.659]             `<<-` <- base::`<<-`
[17:42:26.659]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:26.659]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:26.659]                   3L)]
[17:42:26.659]             }
[17:42:26.659]             function(cond) {
[17:42:26.659]                 is_error <- inherits(cond, "error")
[17:42:26.659]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:26.659]                   NULL)
[17:42:26.659]                 if (is_error) {
[17:42:26.659]                   sessionInformation <- function() {
[17:42:26.659]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:26.659]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:26.659]                       search = base::search(), system = base::Sys.info())
[17:42:26.659]                   }
[17:42:26.659]                   ...future.conditions[[length(...future.conditions) + 
[17:42:26.659]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:26.659]                     cond$call), session = sessionInformation(), 
[17:42:26.659]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:26.659]                   signalCondition(cond)
[17:42:26.659]                 }
[17:42:26.659]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:26.659]                 "immediateCondition"))) {
[17:42:26.659]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:26.659]                   ...future.conditions[[length(...future.conditions) + 
[17:42:26.659]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:26.659]                   if (TRUE && !signal) {
[17:42:26.659]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.659]                     {
[17:42:26.659]                       inherits <- base::inherits
[17:42:26.659]                       invokeRestart <- base::invokeRestart
[17:42:26.659]                       is.null <- base::is.null
[17:42:26.659]                       muffled <- FALSE
[17:42:26.659]                       if (inherits(cond, "message")) {
[17:42:26.659]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:26.659]                         if (muffled) 
[17:42:26.659]                           invokeRestart("muffleMessage")
[17:42:26.659]                       }
[17:42:26.659]                       else if (inherits(cond, "warning")) {
[17:42:26.659]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:26.659]                         if (muffled) 
[17:42:26.659]                           invokeRestart("muffleWarning")
[17:42:26.659]                       }
[17:42:26.659]                       else if (inherits(cond, "condition")) {
[17:42:26.659]                         if (!is.null(pattern)) {
[17:42:26.659]                           computeRestarts <- base::computeRestarts
[17:42:26.659]                           grepl <- base::grepl
[17:42:26.659]                           restarts <- computeRestarts(cond)
[17:42:26.659]                           for (restart in restarts) {
[17:42:26.659]                             name <- restart$name
[17:42:26.659]                             if (is.null(name)) 
[17:42:26.659]                               next
[17:42:26.659]                             if (!grepl(pattern, name)) 
[17:42:26.659]                               next
[17:42:26.659]                             invokeRestart(restart)
[17:42:26.659]                             muffled <- TRUE
[17:42:26.659]                             break
[17:42:26.659]                           }
[17:42:26.659]                         }
[17:42:26.659]                       }
[17:42:26.659]                       invisible(muffled)
[17:42:26.659]                     }
[17:42:26.659]                     muffleCondition(cond, pattern = "^muffle")
[17:42:26.659]                   }
[17:42:26.659]                 }
[17:42:26.659]                 else {
[17:42:26.659]                   if (TRUE) {
[17:42:26.659]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:26.659]                     {
[17:42:26.659]                       inherits <- base::inherits
[17:42:26.659]                       invokeRestart <- base::invokeRestart
[17:42:26.659]                       is.null <- base::is.null
[17:42:26.659]                       muffled <- FALSE
[17:42:26.659]                       if (inherits(cond, "message")) {
[17:42:26.659]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:26.659]                         if (muffled) 
[17:42:26.659]                           invokeRestart("muffleMessage")
[17:42:26.659]                       }
[17:42:26.659]                       else if (inherits(cond, "warning")) {
[17:42:26.659]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:26.659]                         if (muffled) 
[17:42:26.659]                           invokeRestart("muffleWarning")
[17:42:26.659]                       }
[17:42:26.659]                       else if (inherits(cond, "condition")) {
[17:42:26.659]                         if (!is.null(pattern)) {
[17:42:26.659]                           computeRestarts <- base::computeRestarts
[17:42:26.659]                           grepl <- base::grepl
[17:42:26.659]                           restarts <- computeRestarts(cond)
[17:42:26.659]                           for (restart in restarts) {
[17:42:26.659]                             name <- restart$name
[17:42:26.659]                             if (is.null(name)) 
[17:42:26.659]                               next
[17:42:26.659]                             if (!grepl(pattern, name)) 
[17:42:26.659]                               next
[17:42:26.659]                             invokeRestart(restart)
[17:42:26.659]                             muffled <- TRUE
[17:42:26.659]                             break
[17:42:26.659]                           }
[17:42:26.659]                         }
[17:42:26.659]                       }
[17:42:26.659]                       invisible(muffled)
[17:42:26.659]                     }
[17:42:26.659]                     muffleCondition(cond, pattern = "^muffle")
[17:42:26.659]                   }
[17:42:26.659]                 }
[17:42:26.659]             }
[17:42:26.659]         }))
[17:42:26.659]     }, error = function(ex) {
[17:42:26.659]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:26.659]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:26.659]                 ...future.rng), started = ...future.startTime, 
[17:42:26.659]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:26.659]             version = "1.8"), class = "FutureResult")
[17:42:26.659]     }, finally = {
[17:42:26.659]         if (!identical(...future.workdir, getwd())) 
[17:42:26.659]             setwd(...future.workdir)
[17:42:26.659]         {
[17:42:26.659]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:26.659]                 ...future.oldOptions$nwarnings <- NULL
[17:42:26.659]             }
[17:42:26.659]             base::options(...future.oldOptions)
[17:42:26.659]             if (.Platform$OS.type == "windows") {
[17:42:26.659]                 old_names <- names(...future.oldEnvVars)
[17:42:26.659]                 envs <- base::Sys.getenv()
[17:42:26.659]                 names <- names(envs)
[17:42:26.659]                 common <- intersect(names, old_names)
[17:42:26.659]                 added <- setdiff(names, old_names)
[17:42:26.659]                 removed <- setdiff(old_names, names)
[17:42:26.659]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:26.659]                   envs[common]]
[17:42:26.659]                 NAMES <- toupper(changed)
[17:42:26.659]                 args <- list()
[17:42:26.659]                 for (kk in seq_along(NAMES)) {
[17:42:26.659]                   name <- changed[[kk]]
[17:42:26.659]                   NAME <- NAMES[[kk]]
[17:42:26.659]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.659]                     next
[17:42:26.659]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:26.659]                 }
[17:42:26.659]                 NAMES <- toupper(added)
[17:42:26.659]                 for (kk in seq_along(NAMES)) {
[17:42:26.659]                   name <- added[[kk]]
[17:42:26.659]                   NAME <- NAMES[[kk]]
[17:42:26.659]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.659]                     next
[17:42:26.659]                   args[[name]] <- ""
[17:42:26.659]                 }
[17:42:26.659]                 NAMES <- toupper(removed)
[17:42:26.659]                 for (kk in seq_along(NAMES)) {
[17:42:26.659]                   name <- removed[[kk]]
[17:42:26.659]                   NAME <- NAMES[[kk]]
[17:42:26.659]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:26.659]                     next
[17:42:26.659]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:26.659]                 }
[17:42:26.659]                 if (length(args) > 0) 
[17:42:26.659]                   base::do.call(base::Sys.setenv, args = args)
[17:42:26.659]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:26.659]             }
[17:42:26.659]             else {
[17:42:26.659]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:26.659]             }
[17:42:26.659]             {
[17:42:26.659]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:26.659]                   0L) {
[17:42:26.659]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:26.659]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:26.659]                   base::options(opts)
[17:42:26.659]                 }
[17:42:26.659]                 {
[17:42:26.659]                   {
[17:42:26.659]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:26.659]                     NULL
[17:42:26.659]                   }
[17:42:26.659]                   options(future.plan = NULL)
[17:42:26.659]                   if (is.na(NA_character_)) 
[17:42:26.659]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:26.659]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:26.659]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:26.659]                     envir = parent.frame()) 
[17:42:26.659]                   {
[17:42:26.659]                     default_workers <- missing(workers)
[17:42:26.659]                     if (is.function(workers)) 
[17:42:26.659]                       workers <- workers()
[17:42:26.659]                     workers <- structure(as.integer(workers), 
[17:42:26.659]                       class = class(workers))
[17:42:26.659]                     stop_if_not(is.finite(workers), workers >= 
[17:42:26.659]                       1L)
[17:42:26.659]                     if ((workers == 1L && !inherits(workers, 
[17:42:26.659]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:26.659]                       if (default_workers) 
[17:42:26.659]                         supportsMulticore(warn = TRUE)
[17:42:26.659]                       return(sequential(..., envir = envir))
[17:42:26.659]                     }
[17:42:26.659]                     oopts <- options(mc.cores = workers)
[17:42:26.659]                     on.exit(options(oopts))
[17:42:26.659]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:26.659]                       envir = envir)
[17:42:26.659]                     if (!future$lazy) 
[17:42:26.659]                       future <- run(future)
[17:42:26.659]                     invisible(future)
[17:42:26.659]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:26.659]                 }
[17:42:26.659]             }
[17:42:26.659]         }
[17:42:26.659]     })
[17:42:26.659]     if (TRUE) {
[17:42:26.659]         base::sink(type = "output", split = FALSE)
[17:42:26.659]         if (TRUE) {
[17:42:26.659]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:26.659]         }
[17:42:26.659]         else {
[17:42:26.659]             ...future.result["stdout"] <- base::list(NULL)
[17:42:26.659]         }
[17:42:26.659]         base::close(...future.stdout)
[17:42:26.659]         ...future.stdout <- NULL
[17:42:26.659]     }
[17:42:26.659]     ...future.result$conditions <- ...future.conditions
[17:42:26.659]     ...future.result$finished <- base::Sys.time()
[17:42:26.659]     ...future.result
[17:42:26.659] }
[17:42:26.662] assign_globals() ...
[17:42:26.662] List of 3
[17:42:26.662]  $ outer_function:function (x)  
[17:42:26.662]  $ map           :function (.x, .f, ...)  
[17:42:26.662]  $ inner_function:function (x)  
[17:42:26.662]  - attr(*, "where")=List of 3
[17:42:26.662]   ..$ outer_function:<environment: R_EmptyEnv> 
[17:42:26.662]   ..$ map           :<environment: R_EmptyEnv> 
[17:42:26.662]   ..$ inner_function:<environment: R_EmptyEnv> 
[17:42:26.662]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:26.662]  - attr(*, "resolved")= logi FALSE
[17:42:26.662]  - attr(*, "total_size")= num 7704
[17:42:26.662]  - attr(*, "already-done")= logi TRUE
[17:42:26.666] - reassign environment for ‘outer_function’
[17:42:26.666] - copied ‘outer_function’ to environment
[17:42:26.666] - reassign environment for ‘map’
[17:42:26.666] - copied ‘map’ to environment
[17:42:26.666] - reassign environment for ‘inner_function’
[17:42:26.666] - copied ‘inner_function’ to environment
[17:42:26.666] assign_globals() ... done
[17:42:26.666] requestCore(): workers = 2
[17:42:26.669] MulticoreFuture started
[17:42:26.669] - Launch lazy future ... done
[17:42:26.669] run() for ‘MulticoreFuture’ ... done
[17:42:26.670] plan(): Setting new future strategy stack:
[17:42:26.670] List of future strategies:
[17:42:26.670] 1. sequential:
[17:42:26.670]    - args: function (..., envir = parent.frame())
[17:42:26.670]    - tweaked: FALSE
[17:42:26.670]    - call: NULL
[17:42:26.671] plan(): nbrOfWorkers() = 1
[17:42:26.673] plan(): Setting new future strategy stack:
[17:42:26.674] List of future strategies:
[17:42:26.674] 1. multicore:
[17:42:26.674]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:26.674]    - tweaked: FALSE
[17:42:26.674]    - call: plan(strategy)
[17:42:26.679] plan(): nbrOfWorkers() = 2
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
- plan('multisession') ...
[17:42:26.682] plan(): Setting new future strategy stack:
[17:42:26.682] List of future strategies:
[17:42:26.682] 1. multisession:
[17:42:26.682]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:42:26.682]    - tweaked: FALSE
[17:42:26.682]    - call: plan(strategy)
[17:42:26.683] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:42:26.683] multisession:
[17:42:26.683] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:42:26.683] - tweaked: FALSE
[17:42:26.683] - call: plan(strategy)
[17:42:26.690] getGlobalsAndPackages() ...
[17:42:26.690] Not searching for globals
[17:42:26.693] - globals: [0] <none>
[17:42:26.693] getGlobalsAndPackages() ... DONE
[17:42:26.694] [local output] makeClusterPSOCK() ...
[17:42:26.734] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:42:26.740] [local output] Base port: 11095
[17:42:26.740] [local output] Getting setup options for 2 cluster nodes ...
[17:42:26.740] [local output]  - Node 1 of 2 ...
[17:42:26.741] [local output] localMachine=TRUE => revtunnel=FALSE

[17:42:26.741] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpNwFxwa/worker.rank=1.parallelly.parent=45498.b1ba58897b0a.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpNwFxwa/worker.rank=1.parallelly.parent=45498.b1ba58897b0a.pid")'’
[17:42:26.933] - Possible to infer worker's PID: TRUE
[17:42:26.933] [local output] Rscript port: 11095

[17:42:26.934] [local output]  - Node 2 of 2 ...
[17:42:26.934] [local output] localMachine=TRUE => revtunnel=FALSE

[17:42:26.935] [local output] Rscript port: 11095

[17:42:26.935] [local output] Getting setup options for 2 cluster nodes ... done
[17:42:26.935] [local output]  - Parallel setup requested for some PSOCK nodes
[17:42:26.936] [local output] Setting up PSOCK nodes in parallel
[17:42:26.936] List of 36
[17:42:26.936]  $ worker          : chr "localhost"
[17:42:26.936]   ..- attr(*, "localhost")= logi TRUE
[17:42:26.936]  $ master          : chr "localhost"
[17:42:26.936]  $ port            : int 11095
[17:42:26.936]  $ connectTimeout  : num 120
[17:42:26.936]  $ timeout         : num 2592000
[17:42:26.936]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:42:26.936]  $ homogeneous     : logi TRUE
[17:42:26.936]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:42:26.936]  $ rscript_envs    : NULL
[17:42:26.936]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:42:26.936]  $ rscript_startup : NULL
[17:42:26.936]  $ rscript_sh      : chr "sh"
[17:42:26.936]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:42:26.936]  $ methods         : logi TRUE
[17:42:26.936]  $ socketOptions   : chr "no-delay"
[17:42:26.936]  $ useXDR          : logi FALSE
[17:42:26.936]  $ outfile         : chr "/dev/null"
[17:42:26.936]  $ renice          : int NA
[17:42:26.936]  $ rshcmd          : NULL
[17:42:26.936]  $ user            : chr(0) 
[17:42:26.936]  $ revtunnel       : logi FALSE
[17:42:26.936]  $ rshlogfile      : NULL
[17:42:26.936]  $ rshopts         : chr(0) 
[17:42:26.936]  $ rank            : int 1
[17:42:26.936]  $ manual          : logi FALSE
[17:42:26.936]  $ dryrun          : logi FALSE
[17:42:26.936]  $ quiet           : logi FALSE
[17:42:26.936]  $ setup_strategy  : chr "parallel"
[17:42:26.936]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:42:26.936]  $ pidfile         : chr "/tmp/RtmpNwFxwa/worker.rank=1.parallelly.parent=45498.b1ba58897b0a.pid"
[17:42:26.936]  $ rshcmd_label    : NULL
[17:42:26.936]  $ rsh_call        : NULL
[17:42:26.936]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:42:26.936]  $ localMachine    : logi TRUE
[17:42:26.936]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:42:26.936]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:42:26.936]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:42:26.936]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:42:26.936]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:42:26.936]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:42:26.936]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:42:26.936]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:42:26.936]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:42:26.936]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:42:26.936]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:42:26.936]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:42:26.936]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:42:26.936]  $ arguments       :List of 28
[17:42:26.936]   ..$ worker          : chr "localhost"
[17:42:26.936]   ..$ master          : NULL
[17:42:26.936]   ..$ port            : int 11095
[17:42:26.936]   ..$ connectTimeout  : num 120
[17:42:26.936]   ..$ timeout         : num 2592000
[17:42:26.936]   ..$ rscript         : NULL
[17:42:26.936]   ..$ homogeneous     : NULL
[17:42:26.936]   ..$ rscript_args    : NULL
[17:42:26.936]   ..$ rscript_envs    : NULL
[17:42:26.936]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:42:26.936]   ..$ rscript_startup : NULL
[17:42:26.936]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:42:26.936]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:42:26.936]   ..$ methods         : logi TRUE
[17:42:26.936]   ..$ socketOptions   : chr "no-delay"
[17:42:26.936]   ..$ useXDR          : logi FALSE
[17:42:26.936]   ..$ outfile         : chr "/dev/null"
[17:42:26.936]   ..$ renice          : int NA
[17:42:26.936]   ..$ rshcmd          : NULL
[17:42:26.936]   ..$ user            : NULL
[17:42:26.936]   ..$ revtunnel       : logi NA
[17:42:26.936]   ..$ rshlogfile      : NULL
[17:42:26.936]   ..$ rshopts         : NULL
[17:42:26.936]   ..$ rank            : int 1
[17:42:26.936]   ..$ manual          : logi FALSE
[17:42:26.936]   ..$ dryrun          : logi FALSE
[17:42:26.936]   ..$ quiet           : logi FALSE
[17:42:26.936]   ..$ setup_strategy  : chr "parallel"
[17:42:26.936]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:42:26.953] [local output] System call to launch all workers:
[17:42:26.953] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpNwFxwa/worker.rank=1.parallelly.parent=45498.b1ba58897b0a.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11095 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:42:26.953] [local output] Starting PSOCK main server
[17:42:26.955] [local output] Workers launched
[17:42:26.955] [local output] Waiting for workers to connect back
[17:42:26.955]  - [local output] 0 workers out of 2 ready
[17:42:27.199]  - [local output] 0 workers out of 2 ready
[17:42:27.200]  - [local output] 1 workers out of 2 ready
[17:42:27.200]  - [local output] 2 workers out of 2 ready
[17:42:27.200] [local output] Launching of workers completed
[17:42:27.200] [local output] Collecting session information from workers
[17:42:27.201] [local output]  - Worker #1 of 2
[17:42:27.202] [local output]  - Worker #2 of 2
[17:42:27.202] [local output] makeClusterPSOCK() ... done
[17:42:27.214] Packages needed by the future expression (n = 0): <none>
[17:42:27.214] Packages needed by future strategies (n = 0): <none>
[17:42:27.215] {
[17:42:27.215]     {
[17:42:27.215]         {
[17:42:27.215]             ...future.startTime <- base::Sys.time()
[17:42:27.215]             {
[17:42:27.215]                 {
[17:42:27.215]                   {
[17:42:27.215]                     {
[17:42:27.215]                       base::local({
[17:42:27.215]                         has_future <- base::requireNamespace("future", 
[17:42:27.215]                           quietly = TRUE)
[17:42:27.215]                         if (has_future) {
[17:42:27.215]                           ns <- base::getNamespace("future")
[17:42:27.215]                           version <- ns[[".package"]][["version"]]
[17:42:27.215]                           if (is.null(version)) 
[17:42:27.215]                             version <- utils::packageVersion("future")
[17:42:27.215]                         }
[17:42:27.215]                         else {
[17:42:27.215]                           version <- NULL
[17:42:27.215]                         }
[17:42:27.215]                         if (!has_future || version < "1.8.0") {
[17:42:27.215]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:27.215]                             "", base::R.version$version.string), 
[17:42:27.215]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:27.215]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:27.215]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:27.215]                               "release", "version")], collapse = " "), 
[17:42:27.215]                             hostname = base::Sys.info()[["nodename"]])
[17:42:27.215]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:27.215]                             info)
[17:42:27.215]                           info <- base::paste(info, collapse = "; ")
[17:42:27.215]                           if (!has_future) {
[17:42:27.215]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:27.215]                               info)
[17:42:27.215]                           }
[17:42:27.215]                           else {
[17:42:27.215]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:27.215]                               info, version)
[17:42:27.215]                           }
[17:42:27.215]                           base::stop(msg)
[17:42:27.215]                         }
[17:42:27.215]                       })
[17:42:27.215]                     }
[17:42:27.215]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:27.215]                     base::options(mc.cores = 1L)
[17:42:27.215]                   }
[17:42:27.215]                   options(future.plan = NULL)
[17:42:27.215]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:27.215]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:27.215]                 }
[17:42:27.215]                 ...future.workdir <- getwd()
[17:42:27.215]             }
[17:42:27.215]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:27.215]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:27.215]         }
[17:42:27.215]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:27.215]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:27.215]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:27.215]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:27.215]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:27.215]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:27.215]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:27.215]             base::names(...future.oldOptions))
[17:42:27.215]     }
[17:42:27.215]     if (FALSE) {
[17:42:27.215]     }
[17:42:27.215]     else {
[17:42:27.215]         if (TRUE) {
[17:42:27.215]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:27.215]                 open = "w")
[17:42:27.215]         }
[17:42:27.215]         else {
[17:42:27.215]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:27.215]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:27.215]         }
[17:42:27.215]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:27.215]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:27.215]             base::sink(type = "output", split = FALSE)
[17:42:27.215]             base::close(...future.stdout)
[17:42:27.215]         }, add = TRUE)
[17:42:27.215]     }
[17:42:27.215]     ...future.frame <- base::sys.nframe()
[17:42:27.215]     ...future.conditions <- base::list()
[17:42:27.215]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:27.215]     if (FALSE) {
[17:42:27.215]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:27.215]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:27.215]     }
[17:42:27.215]     ...future.result <- base::tryCatch({
[17:42:27.215]         base::withCallingHandlers({
[17:42:27.215]             ...future.value <- base::withVisible(base::local({
[17:42:27.215]                 ...future.makeSendCondition <- local({
[17:42:27.215]                   sendCondition <- NULL
[17:42:27.215]                   function(frame = 1L) {
[17:42:27.215]                     if (is.function(sendCondition)) 
[17:42:27.215]                       return(sendCondition)
[17:42:27.215]                     ns <- getNamespace("parallel")
[17:42:27.215]                     if (exists("sendData", mode = "function", 
[17:42:27.215]                       envir = ns)) {
[17:42:27.215]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:27.215]                         envir = ns)
[17:42:27.215]                       envir <- sys.frame(frame)
[17:42:27.215]                       master <- NULL
[17:42:27.215]                       while (!identical(envir, .GlobalEnv) && 
[17:42:27.215]                         !identical(envir, emptyenv())) {
[17:42:27.215]                         if (exists("master", mode = "list", envir = envir, 
[17:42:27.215]                           inherits = FALSE)) {
[17:42:27.215]                           master <- get("master", mode = "list", 
[17:42:27.215]                             envir = envir, inherits = FALSE)
[17:42:27.215]                           if (inherits(master, c("SOCKnode", 
[17:42:27.215]                             "SOCK0node"))) {
[17:42:27.215]                             sendCondition <<- function(cond) {
[17:42:27.215]                               data <- list(type = "VALUE", value = cond, 
[17:42:27.215]                                 success = TRUE)
[17:42:27.215]                               parallel_sendData(master, data)
[17:42:27.215]                             }
[17:42:27.215]                             return(sendCondition)
[17:42:27.215]                           }
[17:42:27.215]                         }
[17:42:27.215]                         frame <- frame + 1L
[17:42:27.215]                         envir <- sys.frame(frame)
[17:42:27.215]                       }
[17:42:27.215]                     }
[17:42:27.215]                     sendCondition <<- function(cond) NULL
[17:42:27.215]                   }
[17:42:27.215]                 })
[17:42:27.215]                 withCallingHandlers({
[17:42:27.215]                   NA
[17:42:27.215]                 }, immediateCondition = function(cond) {
[17:42:27.215]                   sendCondition <- ...future.makeSendCondition()
[17:42:27.215]                   sendCondition(cond)
[17:42:27.215]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:27.215]                   {
[17:42:27.215]                     inherits <- base::inherits
[17:42:27.215]                     invokeRestart <- base::invokeRestart
[17:42:27.215]                     is.null <- base::is.null
[17:42:27.215]                     muffled <- FALSE
[17:42:27.215]                     if (inherits(cond, "message")) {
[17:42:27.215]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:27.215]                       if (muffled) 
[17:42:27.215]                         invokeRestart("muffleMessage")
[17:42:27.215]                     }
[17:42:27.215]                     else if (inherits(cond, "warning")) {
[17:42:27.215]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:27.215]                       if (muffled) 
[17:42:27.215]                         invokeRestart("muffleWarning")
[17:42:27.215]                     }
[17:42:27.215]                     else if (inherits(cond, "condition")) {
[17:42:27.215]                       if (!is.null(pattern)) {
[17:42:27.215]                         computeRestarts <- base::computeRestarts
[17:42:27.215]                         grepl <- base::grepl
[17:42:27.215]                         restarts <- computeRestarts(cond)
[17:42:27.215]                         for (restart in restarts) {
[17:42:27.215]                           name <- restart$name
[17:42:27.215]                           if (is.null(name)) 
[17:42:27.215]                             next
[17:42:27.215]                           if (!grepl(pattern, name)) 
[17:42:27.215]                             next
[17:42:27.215]                           invokeRestart(restart)
[17:42:27.215]                           muffled <- TRUE
[17:42:27.215]                           break
[17:42:27.215]                         }
[17:42:27.215]                       }
[17:42:27.215]                     }
[17:42:27.215]                     invisible(muffled)
[17:42:27.215]                   }
[17:42:27.215]                   muffleCondition(cond)
[17:42:27.215]                 })
[17:42:27.215]             }))
[17:42:27.215]             future::FutureResult(value = ...future.value$value, 
[17:42:27.215]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:27.215]                   ...future.rng), globalenv = if (FALSE) 
[17:42:27.215]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:27.215]                     ...future.globalenv.names))
[17:42:27.215]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:27.215]         }, condition = base::local({
[17:42:27.215]             c <- base::c
[17:42:27.215]             inherits <- base::inherits
[17:42:27.215]             invokeRestart <- base::invokeRestart
[17:42:27.215]             length <- base::length
[17:42:27.215]             list <- base::list
[17:42:27.215]             seq.int <- base::seq.int
[17:42:27.215]             signalCondition <- base::signalCondition
[17:42:27.215]             sys.calls <- base::sys.calls
[17:42:27.215]             `[[` <- base::`[[`
[17:42:27.215]             `+` <- base::`+`
[17:42:27.215]             `<<-` <- base::`<<-`
[17:42:27.215]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:27.215]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:27.215]                   3L)]
[17:42:27.215]             }
[17:42:27.215]             function(cond) {
[17:42:27.215]                 is_error <- inherits(cond, "error")
[17:42:27.215]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:27.215]                   NULL)
[17:42:27.215]                 if (is_error) {
[17:42:27.215]                   sessionInformation <- function() {
[17:42:27.215]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:27.215]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:27.215]                       search = base::search(), system = base::Sys.info())
[17:42:27.215]                   }
[17:42:27.215]                   ...future.conditions[[length(...future.conditions) + 
[17:42:27.215]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:27.215]                     cond$call), session = sessionInformation(), 
[17:42:27.215]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:27.215]                   signalCondition(cond)
[17:42:27.215]                 }
[17:42:27.215]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:27.215]                 "immediateCondition"))) {
[17:42:27.215]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:27.215]                   ...future.conditions[[length(...future.conditions) + 
[17:42:27.215]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:27.215]                   if (TRUE && !signal) {
[17:42:27.215]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:27.215]                     {
[17:42:27.215]                       inherits <- base::inherits
[17:42:27.215]                       invokeRestart <- base::invokeRestart
[17:42:27.215]                       is.null <- base::is.null
[17:42:27.215]                       muffled <- FALSE
[17:42:27.215]                       if (inherits(cond, "message")) {
[17:42:27.215]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:27.215]                         if (muffled) 
[17:42:27.215]                           invokeRestart("muffleMessage")
[17:42:27.215]                       }
[17:42:27.215]                       else if (inherits(cond, "warning")) {
[17:42:27.215]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:27.215]                         if (muffled) 
[17:42:27.215]                           invokeRestart("muffleWarning")
[17:42:27.215]                       }
[17:42:27.215]                       else if (inherits(cond, "condition")) {
[17:42:27.215]                         if (!is.null(pattern)) {
[17:42:27.215]                           computeRestarts <- base::computeRestarts
[17:42:27.215]                           grepl <- base::grepl
[17:42:27.215]                           restarts <- computeRestarts(cond)
[17:42:27.215]                           for (restart in restarts) {
[17:42:27.215]                             name <- restart$name
[17:42:27.215]                             if (is.null(name)) 
[17:42:27.215]                               next
[17:42:27.215]                             if (!grepl(pattern, name)) 
[17:42:27.215]                               next
[17:42:27.215]                             invokeRestart(restart)
[17:42:27.215]                             muffled <- TRUE
[17:42:27.215]                             break
[17:42:27.215]                           }
[17:42:27.215]                         }
[17:42:27.215]                       }
[17:42:27.215]                       invisible(muffled)
[17:42:27.215]                     }
[17:42:27.215]                     muffleCondition(cond, pattern = "^muffle")
[17:42:27.215]                   }
[17:42:27.215]                 }
[17:42:27.215]                 else {
[17:42:27.215]                   if (TRUE) {
[17:42:27.215]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:27.215]                     {
[17:42:27.215]                       inherits <- base::inherits
[17:42:27.215]                       invokeRestart <- base::invokeRestart
[17:42:27.215]                       is.null <- base::is.null
[17:42:27.215]                       muffled <- FALSE
[17:42:27.215]                       if (inherits(cond, "message")) {
[17:42:27.215]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:27.215]                         if (muffled) 
[17:42:27.215]                           invokeRestart("muffleMessage")
[17:42:27.215]                       }
[17:42:27.215]                       else if (inherits(cond, "warning")) {
[17:42:27.215]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:27.215]                         if (muffled) 
[17:42:27.215]                           invokeRestart("muffleWarning")
[17:42:27.215]                       }
[17:42:27.215]                       else if (inherits(cond, "condition")) {
[17:42:27.215]                         if (!is.null(pattern)) {
[17:42:27.215]                           computeRestarts <- base::computeRestarts
[17:42:27.215]                           grepl <- base::grepl
[17:42:27.215]                           restarts <- computeRestarts(cond)
[17:42:27.215]                           for (restart in restarts) {
[17:42:27.215]                             name <- restart$name
[17:42:27.215]                             if (is.null(name)) 
[17:42:27.215]                               next
[17:42:27.215]                             if (!grepl(pattern, name)) 
[17:42:27.215]                               next
[17:42:27.215]                             invokeRestart(restart)
[17:42:27.215]                             muffled <- TRUE
[17:42:27.215]                             break
[17:42:27.215]                           }
[17:42:27.215]                         }
[17:42:27.215]                       }
[17:42:27.215]                       invisible(muffled)
[17:42:27.215]                     }
[17:42:27.215]                     muffleCondition(cond, pattern = "^muffle")
[17:42:27.215]                   }
[17:42:27.215]                 }
[17:42:27.215]             }
[17:42:27.215]         }))
[17:42:27.215]     }, error = function(ex) {
[17:42:27.215]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:27.215]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:27.215]                 ...future.rng), started = ...future.startTime, 
[17:42:27.215]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:27.215]             version = "1.8"), class = "FutureResult")
[17:42:27.215]     }, finally = {
[17:42:27.215]         if (!identical(...future.workdir, getwd())) 
[17:42:27.215]             setwd(...future.workdir)
[17:42:27.215]         {
[17:42:27.215]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:27.215]                 ...future.oldOptions$nwarnings <- NULL
[17:42:27.215]             }
[17:42:27.215]             base::options(...future.oldOptions)
[17:42:27.215]             if (.Platform$OS.type == "windows") {
[17:42:27.215]                 old_names <- names(...future.oldEnvVars)
[17:42:27.215]                 envs <- base::Sys.getenv()
[17:42:27.215]                 names <- names(envs)
[17:42:27.215]                 common <- intersect(names, old_names)
[17:42:27.215]                 added <- setdiff(names, old_names)
[17:42:27.215]                 removed <- setdiff(old_names, names)
[17:42:27.215]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:27.215]                   envs[common]]
[17:42:27.215]                 NAMES <- toupper(changed)
[17:42:27.215]                 args <- list()
[17:42:27.215]                 for (kk in seq_along(NAMES)) {
[17:42:27.215]                   name <- changed[[kk]]
[17:42:27.215]                   NAME <- NAMES[[kk]]
[17:42:27.215]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:27.215]                     next
[17:42:27.215]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:27.215]                 }
[17:42:27.215]                 NAMES <- toupper(added)
[17:42:27.215]                 for (kk in seq_along(NAMES)) {
[17:42:27.215]                   name <- added[[kk]]
[17:42:27.215]                   NAME <- NAMES[[kk]]
[17:42:27.215]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:27.215]                     next
[17:42:27.215]                   args[[name]] <- ""
[17:42:27.215]                 }
[17:42:27.215]                 NAMES <- toupper(removed)
[17:42:27.215]                 for (kk in seq_along(NAMES)) {
[17:42:27.215]                   name <- removed[[kk]]
[17:42:27.215]                   NAME <- NAMES[[kk]]
[17:42:27.215]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:27.215]                     next
[17:42:27.215]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:27.215]                 }
[17:42:27.215]                 if (length(args) > 0) 
[17:42:27.215]                   base::do.call(base::Sys.setenv, args = args)
[17:42:27.215]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:27.215]             }
[17:42:27.215]             else {
[17:42:27.215]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:27.215]             }
[17:42:27.215]             {
[17:42:27.215]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:27.215]                   0L) {
[17:42:27.215]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:27.215]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:27.215]                   base::options(opts)
[17:42:27.215]                 }
[17:42:27.215]                 {
[17:42:27.215]                   {
[17:42:27.215]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:27.215]                     NULL
[17:42:27.215]                   }
[17:42:27.215]                   options(future.plan = NULL)
[17:42:27.215]                   if (is.na(NA_character_)) 
[17:42:27.215]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:27.215]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:27.215]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:27.215]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:27.215]                     envir = parent.frame()) 
[17:42:27.215]                   {
[17:42:27.215]                     if (is.function(workers)) 
[17:42:27.215]                       workers <- workers()
[17:42:27.215]                     workers <- structure(as.integer(workers), 
[17:42:27.215]                       class = class(workers))
[17:42:27.215]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:27.215]                       workers >= 1)
[17:42:27.215]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:27.215]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:27.215]                     }
[17:42:27.215]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:27.215]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:27.215]                       envir = envir)
[17:42:27.215]                     if (!future$lazy) 
[17:42:27.215]                       future <- run(future)
[17:42:27.215]                     invisible(future)
[17:42:27.215]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:27.215]                 }
[17:42:27.215]             }
[17:42:27.215]         }
[17:42:27.215]     })
[17:42:27.215]     if (TRUE) {
[17:42:27.215]         base::sink(type = "output", split = FALSE)
[17:42:27.215]         if (TRUE) {
[17:42:27.215]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:27.215]         }
[17:42:27.215]         else {
[17:42:27.215]             ...future.result["stdout"] <- base::list(NULL)
[17:42:27.215]         }
[17:42:27.215]         base::close(...future.stdout)
[17:42:27.215]         ...future.stdout <- NULL
[17:42:27.215]     }
[17:42:27.215]     ...future.result$conditions <- ...future.conditions
[17:42:27.215]     ...future.result$finished <- base::Sys.time()
[17:42:27.215]     ...future.result
[17:42:27.215] }
[17:42:27.287] MultisessionFuture started
[17:42:27.288] result() for ClusterFuture ...
[17:42:27.288] receiveMessageFromWorker() for ClusterFuture ...
[17:42:27.289] - Validating connection of MultisessionFuture
[17:42:27.320] - received message: FutureResult
[17:42:27.320] - Received FutureResult
[17:42:27.321] - Erased future from FutureRegistry
[17:42:27.321] result() for ClusterFuture ...
[17:42:27.321] - result already collected: FutureResult
[17:42:27.321] result() for ClusterFuture ... done
[17:42:27.321] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:27.321] result() for ClusterFuture ... done
[17:42:27.321] result() for ClusterFuture ...
[17:42:27.321] - result already collected: FutureResult
[17:42:27.321] result() for ClusterFuture ... done
[17:42:27.322] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:42:27.325] plan(): nbrOfWorkers() = 2
- lm(<formula>) ...
[17:42:27.326] getGlobalsAndPackages() ...
[17:42:27.326] Searching for globals...
[17:42:27.328] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:42:27.328] Searching for globals ... DONE
[17:42:27.328] Resolving globals: FALSE
[17:42:27.329] The total size of the 2 globals is 896 bytes (896 bytes)
[17:42:27.329] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:42:27.330] - globals: [2] ‘weight’, ‘group’
[17:42:27.330] - packages: [1] ‘stats’
[17:42:27.330] getGlobalsAndPackages() ... DONE
[17:42:27.330] run() for ‘Future’ ...
[17:42:27.330] - state: ‘created’
[17:42:27.330] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:27.346] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:27.346] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:27.346]   - Field: ‘node’
[17:42:27.346]   - Field: ‘label’
[17:42:27.346]   - Field: ‘local’
[17:42:27.346]   - Field: ‘owner’
[17:42:27.346]   - Field: ‘envir’
[17:42:27.346]   - Field: ‘workers’
[17:42:27.347]   - Field: ‘packages’
[17:42:27.347]   - Field: ‘gc’
[17:42:27.347]   - Field: ‘conditions’
[17:42:27.347]   - Field: ‘persistent’
[17:42:27.347]   - Field: ‘expr’
[17:42:27.347]   - Field: ‘uuid’
[17:42:27.347]   - Field: ‘seed’
[17:42:27.347]   - Field: ‘version’
[17:42:27.348]   - Field: ‘result’
[17:42:27.348]   - Field: ‘asynchronous’
[17:42:27.348]   - Field: ‘calls’
[17:42:27.348]   - Field: ‘globals’
[17:42:27.348]   - Field: ‘stdout’
[17:42:27.348]   - Field: ‘earlySignal’
[17:42:27.348]   - Field: ‘lazy’
[17:42:27.348]   - Field: ‘state’
[17:42:27.348] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:27.349] - Launch lazy future ...
[17:42:27.349] Packages needed by the future expression (n = 1): ‘stats’
[17:42:27.349] Packages needed by future strategies (n = 0): <none>
[17:42:27.350] {
[17:42:27.350]     {
[17:42:27.350]         {
[17:42:27.350]             ...future.startTime <- base::Sys.time()
[17:42:27.350]             {
[17:42:27.350]                 {
[17:42:27.350]                   {
[17:42:27.350]                     {
[17:42:27.350]                       {
[17:42:27.350]                         base::local({
[17:42:27.350]                           has_future <- base::requireNamespace("future", 
[17:42:27.350]                             quietly = TRUE)
[17:42:27.350]                           if (has_future) {
[17:42:27.350]                             ns <- base::getNamespace("future")
[17:42:27.350]                             version <- ns[[".package"]][["version"]]
[17:42:27.350]                             if (is.null(version)) 
[17:42:27.350]                               version <- utils::packageVersion("future")
[17:42:27.350]                           }
[17:42:27.350]                           else {
[17:42:27.350]                             version <- NULL
[17:42:27.350]                           }
[17:42:27.350]                           if (!has_future || version < "1.8.0") {
[17:42:27.350]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:27.350]                               "", base::R.version$version.string), 
[17:42:27.350]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:27.350]                                 base::R.version$platform, 8 * 
[17:42:27.350]                                   base::.Machine$sizeof.pointer), 
[17:42:27.350]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:27.350]                                 "release", "version")], collapse = " "), 
[17:42:27.350]                               hostname = base::Sys.info()[["nodename"]])
[17:42:27.350]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:27.350]                               info)
[17:42:27.350]                             info <- base::paste(info, collapse = "; ")
[17:42:27.350]                             if (!has_future) {
[17:42:27.350]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:27.350]                                 info)
[17:42:27.350]                             }
[17:42:27.350]                             else {
[17:42:27.350]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:27.350]                                 info, version)
[17:42:27.350]                             }
[17:42:27.350]                             base::stop(msg)
[17:42:27.350]                           }
[17:42:27.350]                         })
[17:42:27.350]                       }
[17:42:27.350]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:27.350]                       base::options(mc.cores = 1L)
[17:42:27.350]                     }
[17:42:27.350]                     base::local({
[17:42:27.350]                       for (pkg in "stats") {
[17:42:27.350]                         base::loadNamespace(pkg)
[17:42:27.350]                         base::library(pkg, character.only = TRUE)
[17:42:27.350]                       }
[17:42:27.350]                     })
[17:42:27.350]                   }
[17:42:27.350]                   options(future.plan = NULL)
[17:42:27.350]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:27.350]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:27.350]                 }
[17:42:27.350]                 ...future.workdir <- getwd()
[17:42:27.350]             }
[17:42:27.350]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:27.350]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:27.350]         }
[17:42:27.350]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:27.350]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:27.350]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:27.350]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:27.350]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:27.350]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:27.350]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:27.350]             base::names(...future.oldOptions))
[17:42:27.350]     }
[17:42:27.350]     if (FALSE) {
[17:42:27.350]     }
[17:42:27.350]     else {
[17:42:27.350]         if (TRUE) {
[17:42:27.350]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:27.350]                 open = "w")
[17:42:27.350]         }
[17:42:27.350]         else {
[17:42:27.350]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:27.350]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:27.350]         }
[17:42:27.350]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:27.350]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:27.350]             base::sink(type = "output", split = FALSE)
[17:42:27.350]             base::close(...future.stdout)
[17:42:27.350]         }, add = TRUE)
[17:42:27.350]     }
[17:42:27.350]     ...future.frame <- base::sys.nframe()
[17:42:27.350]     ...future.conditions <- base::list()
[17:42:27.350]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:27.350]     if (FALSE) {
[17:42:27.350]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:27.350]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:27.350]     }
[17:42:27.350]     ...future.result <- base::tryCatch({
[17:42:27.350]         base::withCallingHandlers({
[17:42:27.350]             ...future.value <- base::withVisible(base::local({
[17:42:27.350]                 ...future.makeSendCondition <- local({
[17:42:27.350]                   sendCondition <- NULL
[17:42:27.350]                   function(frame = 1L) {
[17:42:27.350]                     if (is.function(sendCondition)) 
[17:42:27.350]                       return(sendCondition)
[17:42:27.350]                     ns <- getNamespace("parallel")
[17:42:27.350]                     if (exists("sendData", mode = "function", 
[17:42:27.350]                       envir = ns)) {
[17:42:27.350]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:27.350]                         envir = ns)
[17:42:27.350]                       envir <- sys.frame(frame)
[17:42:27.350]                       master <- NULL
[17:42:27.350]                       while (!identical(envir, .GlobalEnv) && 
[17:42:27.350]                         !identical(envir, emptyenv())) {
[17:42:27.350]                         if (exists("master", mode = "list", envir = envir, 
[17:42:27.350]                           inherits = FALSE)) {
[17:42:27.350]                           master <- get("master", mode = "list", 
[17:42:27.350]                             envir = envir, inherits = FALSE)
[17:42:27.350]                           if (inherits(master, c("SOCKnode", 
[17:42:27.350]                             "SOCK0node"))) {
[17:42:27.350]                             sendCondition <<- function(cond) {
[17:42:27.350]                               data <- list(type = "VALUE", value = cond, 
[17:42:27.350]                                 success = TRUE)
[17:42:27.350]                               parallel_sendData(master, data)
[17:42:27.350]                             }
[17:42:27.350]                             return(sendCondition)
[17:42:27.350]                           }
[17:42:27.350]                         }
[17:42:27.350]                         frame <- frame + 1L
[17:42:27.350]                         envir <- sys.frame(frame)
[17:42:27.350]                       }
[17:42:27.350]                     }
[17:42:27.350]                     sendCondition <<- function(cond) NULL
[17:42:27.350]                   }
[17:42:27.350]                 })
[17:42:27.350]                 withCallingHandlers({
[17:42:27.350]                   {
[17:42:27.350]                     lm(weight ~ group - 1)
[17:42:27.350]                   }
[17:42:27.350]                 }, immediateCondition = function(cond) {
[17:42:27.350]                   sendCondition <- ...future.makeSendCondition()
[17:42:27.350]                   sendCondition(cond)
[17:42:27.350]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:27.350]                   {
[17:42:27.350]                     inherits <- base::inherits
[17:42:27.350]                     invokeRestart <- base::invokeRestart
[17:42:27.350]                     is.null <- base::is.null
[17:42:27.350]                     muffled <- FALSE
[17:42:27.350]                     if (inherits(cond, "message")) {
[17:42:27.350]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:27.350]                       if (muffled) 
[17:42:27.350]                         invokeRestart("muffleMessage")
[17:42:27.350]                     }
[17:42:27.350]                     else if (inherits(cond, "warning")) {
[17:42:27.350]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:27.350]                       if (muffled) 
[17:42:27.350]                         invokeRestart("muffleWarning")
[17:42:27.350]                     }
[17:42:27.350]                     else if (inherits(cond, "condition")) {
[17:42:27.350]                       if (!is.null(pattern)) {
[17:42:27.350]                         computeRestarts <- base::computeRestarts
[17:42:27.350]                         grepl <- base::grepl
[17:42:27.350]                         restarts <- computeRestarts(cond)
[17:42:27.350]                         for (restart in restarts) {
[17:42:27.350]                           name <- restart$name
[17:42:27.350]                           if (is.null(name)) 
[17:42:27.350]                             next
[17:42:27.350]                           if (!grepl(pattern, name)) 
[17:42:27.350]                             next
[17:42:27.350]                           invokeRestart(restart)
[17:42:27.350]                           muffled <- TRUE
[17:42:27.350]                           break
[17:42:27.350]                         }
[17:42:27.350]                       }
[17:42:27.350]                     }
[17:42:27.350]                     invisible(muffled)
[17:42:27.350]                   }
[17:42:27.350]                   muffleCondition(cond)
[17:42:27.350]                 })
[17:42:27.350]             }))
[17:42:27.350]             future::FutureResult(value = ...future.value$value, 
[17:42:27.350]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:27.350]                   ...future.rng), globalenv = if (FALSE) 
[17:42:27.350]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:27.350]                     ...future.globalenv.names))
[17:42:27.350]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:27.350]         }, condition = base::local({
[17:42:27.350]             c <- base::c
[17:42:27.350]             inherits <- base::inherits
[17:42:27.350]             invokeRestart <- base::invokeRestart
[17:42:27.350]             length <- base::length
[17:42:27.350]             list <- base::list
[17:42:27.350]             seq.int <- base::seq.int
[17:42:27.350]             signalCondition <- base::signalCondition
[17:42:27.350]             sys.calls <- base::sys.calls
[17:42:27.350]             `[[` <- base::`[[`
[17:42:27.350]             `+` <- base::`+`
[17:42:27.350]             `<<-` <- base::`<<-`
[17:42:27.350]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:27.350]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:27.350]                   3L)]
[17:42:27.350]             }
[17:42:27.350]             function(cond) {
[17:42:27.350]                 is_error <- inherits(cond, "error")
[17:42:27.350]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:27.350]                   NULL)
[17:42:27.350]                 if (is_error) {
[17:42:27.350]                   sessionInformation <- function() {
[17:42:27.350]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:27.350]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:27.350]                       search = base::search(), system = base::Sys.info())
[17:42:27.350]                   }
[17:42:27.350]                   ...future.conditions[[length(...future.conditions) + 
[17:42:27.350]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:27.350]                     cond$call), session = sessionInformation(), 
[17:42:27.350]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:27.350]                   signalCondition(cond)
[17:42:27.350]                 }
[17:42:27.350]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:27.350]                 "immediateCondition"))) {
[17:42:27.350]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:27.350]                   ...future.conditions[[length(...future.conditions) + 
[17:42:27.350]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:27.350]                   if (TRUE && !signal) {
[17:42:27.350]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:27.350]                     {
[17:42:27.350]                       inherits <- base::inherits
[17:42:27.350]                       invokeRestart <- base::invokeRestart
[17:42:27.350]                       is.null <- base::is.null
[17:42:27.350]                       muffled <- FALSE
[17:42:27.350]                       if (inherits(cond, "message")) {
[17:42:27.350]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:27.350]                         if (muffled) 
[17:42:27.350]                           invokeRestart("muffleMessage")
[17:42:27.350]                       }
[17:42:27.350]                       else if (inherits(cond, "warning")) {
[17:42:27.350]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:27.350]                         if (muffled) 
[17:42:27.350]                           invokeRestart("muffleWarning")
[17:42:27.350]                       }
[17:42:27.350]                       else if (inherits(cond, "condition")) {
[17:42:27.350]                         if (!is.null(pattern)) {
[17:42:27.350]                           computeRestarts <- base::computeRestarts
[17:42:27.350]                           grepl <- base::grepl
[17:42:27.350]                           restarts <- computeRestarts(cond)
[17:42:27.350]                           for (restart in restarts) {
[17:42:27.350]                             name <- restart$name
[17:42:27.350]                             if (is.null(name)) 
[17:42:27.350]                               next
[17:42:27.350]                             if (!grepl(pattern, name)) 
[17:42:27.350]                               next
[17:42:27.350]                             invokeRestart(restart)
[17:42:27.350]                             muffled <- TRUE
[17:42:27.350]                             break
[17:42:27.350]                           }
[17:42:27.350]                         }
[17:42:27.350]                       }
[17:42:27.350]                       invisible(muffled)
[17:42:27.350]                     }
[17:42:27.350]                     muffleCondition(cond, pattern = "^muffle")
[17:42:27.350]                   }
[17:42:27.350]                 }
[17:42:27.350]                 else {
[17:42:27.350]                   if (TRUE) {
[17:42:27.350]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:27.350]                     {
[17:42:27.350]                       inherits <- base::inherits
[17:42:27.350]                       invokeRestart <- base::invokeRestart
[17:42:27.350]                       is.null <- base::is.null
[17:42:27.350]                       muffled <- FALSE
[17:42:27.350]                       if (inherits(cond, "message")) {
[17:42:27.350]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:27.350]                         if (muffled) 
[17:42:27.350]                           invokeRestart("muffleMessage")
[17:42:27.350]                       }
[17:42:27.350]                       else if (inherits(cond, "warning")) {
[17:42:27.350]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:27.350]                         if (muffled) 
[17:42:27.350]                           invokeRestart("muffleWarning")
[17:42:27.350]                       }
[17:42:27.350]                       else if (inherits(cond, "condition")) {
[17:42:27.350]                         if (!is.null(pattern)) {
[17:42:27.350]                           computeRestarts <- base::computeRestarts
[17:42:27.350]                           grepl <- base::grepl
[17:42:27.350]                           restarts <- computeRestarts(cond)
[17:42:27.350]                           for (restart in restarts) {
[17:42:27.350]                             name <- restart$name
[17:42:27.350]                             if (is.null(name)) 
[17:42:27.350]                               next
[17:42:27.350]                             if (!grepl(pattern, name)) 
[17:42:27.350]                               next
[17:42:27.350]                             invokeRestart(restart)
[17:42:27.350]                             muffled <- TRUE
[17:42:27.350]                             break
[17:42:27.350]                           }
[17:42:27.350]                         }
[17:42:27.350]                       }
[17:42:27.350]                       invisible(muffled)
[17:42:27.350]                     }
[17:42:27.350]                     muffleCondition(cond, pattern = "^muffle")
[17:42:27.350]                   }
[17:42:27.350]                 }
[17:42:27.350]             }
[17:42:27.350]         }))
[17:42:27.350]     }, error = function(ex) {
[17:42:27.350]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:27.350]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:27.350]                 ...future.rng), started = ...future.startTime, 
[17:42:27.350]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:27.350]             version = "1.8"), class = "FutureResult")
[17:42:27.350]     }, finally = {
[17:42:27.350]         if (!identical(...future.workdir, getwd())) 
[17:42:27.350]             setwd(...future.workdir)
[17:42:27.350]         {
[17:42:27.350]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:27.350]                 ...future.oldOptions$nwarnings <- NULL
[17:42:27.350]             }
[17:42:27.350]             base::options(...future.oldOptions)
[17:42:27.350]             if (.Platform$OS.type == "windows") {
[17:42:27.350]                 old_names <- names(...future.oldEnvVars)
[17:42:27.350]                 envs <- base::Sys.getenv()
[17:42:27.350]                 names <- names(envs)
[17:42:27.350]                 common <- intersect(names, old_names)
[17:42:27.350]                 added <- setdiff(names, old_names)
[17:42:27.350]                 removed <- setdiff(old_names, names)
[17:42:27.350]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:27.350]                   envs[common]]
[17:42:27.350]                 NAMES <- toupper(changed)
[17:42:27.350]                 args <- list()
[17:42:27.350]                 for (kk in seq_along(NAMES)) {
[17:42:27.350]                   name <- changed[[kk]]
[17:42:27.350]                   NAME <- NAMES[[kk]]
[17:42:27.350]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:27.350]                     next
[17:42:27.350]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:27.350]                 }
[17:42:27.350]                 NAMES <- toupper(added)
[17:42:27.350]                 for (kk in seq_along(NAMES)) {
[17:42:27.350]                   name <- added[[kk]]
[17:42:27.350]                   NAME <- NAMES[[kk]]
[17:42:27.350]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:27.350]                     next
[17:42:27.350]                   args[[name]] <- ""
[17:42:27.350]                 }
[17:42:27.350]                 NAMES <- toupper(removed)
[17:42:27.350]                 for (kk in seq_along(NAMES)) {
[17:42:27.350]                   name <- removed[[kk]]
[17:42:27.350]                   NAME <- NAMES[[kk]]
[17:42:27.350]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:27.350]                     next
[17:42:27.350]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:27.350]                 }
[17:42:27.350]                 if (length(args) > 0) 
[17:42:27.350]                   base::do.call(base::Sys.setenv, args = args)
[17:42:27.350]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:27.350]             }
[17:42:27.350]             else {
[17:42:27.350]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:27.350]             }
[17:42:27.350]             {
[17:42:27.350]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:27.350]                   0L) {
[17:42:27.350]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:27.350]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:27.350]                   base::options(opts)
[17:42:27.350]                 }
[17:42:27.350]                 {
[17:42:27.350]                   {
[17:42:27.350]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:27.350]                     NULL
[17:42:27.350]                   }
[17:42:27.350]                   options(future.plan = NULL)
[17:42:27.350]                   if (is.na(NA_character_)) 
[17:42:27.350]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:27.350]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:27.350]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:27.350]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:27.350]                     envir = parent.frame()) 
[17:42:27.350]                   {
[17:42:27.350]                     if (is.function(workers)) 
[17:42:27.350]                       workers <- workers()
[17:42:27.350]                     workers <- structure(as.integer(workers), 
[17:42:27.350]                       class = class(workers))
[17:42:27.350]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:27.350]                       workers >= 1)
[17:42:27.350]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:27.350]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:27.350]                     }
[17:42:27.350]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:27.350]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:27.350]                       envir = envir)
[17:42:27.350]                     if (!future$lazy) 
[17:42:27.350]                       future <- run(future)
[17:42:27.350]                     invisible(future)
[17:42:27.350]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:27.350]                 }
[17:42:27.350]             }
[17:42:27.350]         }
[17:42:27.350]     })
[17:42:27.350]     if (TRUE) {
[17:42:27.350]         base::sink(type = "output", split = FALSE)
[17:42:27.350]         if (TRUE) {
[17:42:27.350]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:27.350]         }
[17:42:27.350]         else {
[17:42:27.350]             ...future.result["stdout"] <- base::list(NULL)
[17:42:27.350]         }
[17:42:27.350]         base::close(...future.stdout)
[17:42:27.350]         ...future.stdout <- NULL
[17:42:27.350]     }
[17:42:27.350]     ...future.result$conditions <- ...future.conditions
[17:42:27.350]     ...future.result$finished <- base::Sys.time()
[17:42:27.350]     ...future.result
[17:42:27.350] }
[17:42:27.353] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[17:42:27.353] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[17:42:27.354] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[17:42:27.354] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[17:42:27.354] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[17:42:27.354] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[17:42:27.355] MultisessionFuture started
[17:42:27.355] - Launch lazy future ... done
[17:42:27.355] run() for ‘MultisessionFuture’ ... done
[17:42:27.356] result() for ClusterFuture ...
[17:42:27.356] receiveMessageFromWorker() for ClusterFuture ...
[17:42:27.356] - Validating connection of MultisessionFuture
[17:42:27.408] - received message: FutureResult
[17:42:27.408] - Received FutureResult
[17:42:27.408] - Erased future from FutureRegistry
[17:42:27.408] result() for ClusterFuture ...
[17:42:27.408] - result already collected: FutureResult
[17:42:27.409] result() for ClusterFuture ... done
[17:42:27.409] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:27.409] result() for ClusterFuture ... done
[17:42:27.409] result() for ClusterFuture ...
[17:42:27.409] - result already collected: FutureResult
[17:42:27.409] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[17:42:27.411] getGlobalsAndPackages() ...
[17:42:27.412] Searching for globals...
[17:42:27.414] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:42:27.414] Searching for globals ... DONE
[17:42:27.414] Resolving globals: FALSE
[17:42:27.414] The total size of the 2 globals is 896 bytes (896 bytes)
[17:42:27.415] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:42:27.415] - globals: [2] ‘weight’, ‘group’
[17:42:27.415] - packages: [1] ‘stats’
[17:42:27.415] getGlobalsAndPackages() ... DONE
[17:42:27.416] run() for ‘Future’ ...
[17:42:27.416] - state: ‘created’
[17:42:27.416] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:27.431] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:27.431] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:27.432]   - Field: ‘node’
[17:42:27.432]   - Field: ‘label’
[17:42:27.432]   - Field: ‘local’
[17:42:27.432]   - Field: ‘owner’
[17:42:27.432]   - Field: ‘envir’
[17:42:27.432]   - Field: ‘workers’
[17:42:27.432]   - Field: ‘packages’
[17:42:27.432]   - Field: ‘gc’
[17:42:27.432]   - Field: ‘conditions’
[17:42:27.433]   - Field: ‘persistent’
[17:42:27.433]   - Field: ‘expr’
[17:42:27.433]   - Field: ‘uuid’
[17:42:27.433]   - Field: ‘seed’
[17:42:27.433]   - Field: ‘version’
[17:42:27.433]   - Field: ‘result’
[17:42:27.433]   - Field: ‘asynchronous’
[17:42:27.433]   - Field: ‘calls’
[17:42:27.433]   - Field: ‘globals’
[17:42:27.434]   - Field: ‘stdout’
[17:42:27.434]   - Field: ‘earlySignal’
[17:42:27.434]   - Field: ‘lazy’
[17:42:27.434]   - Field: ‘state’
[17:42:27.434] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:27.434] - Launch lazy future ...
[17:42:27.435] Packages needed by the future expression (n = 1): ‘stats’
[17:42:27.435] Packages needed by future strategies (n = 0): <none>
[17:42:27.435] {
[17:42:27.435]     {
[17:42:27.435]         {
[17:42:27.435]             ...future.startTime <- base::Sys.time()
[17:42:27.435]             {
[17:42:27.435]                 {
[17:42:27.435]                   {
[17:42:27.435]                     {
[17:42:27.435]                       {
[17:42:27.435]                         base::local({
[17:42:27.435]                           has_future <- base::requireNamespace("future", 
[17:42:27.435]                             quietly = TRUE)
[17:42:27.435]                           if (has_future) {
[17:42:27.435]                             ns <- base::getNamespace("future")
[17:42:27.435]                             version <- ns[[".package"]][["version"]]
[17:42:27.435]                             if (is.null(version)) 
[17:42:27.435]                               version <- utils::packageVersion("future")
[17:42:27.435]                           }
[17:42:27.435]                           else {
[17:42:27.435]                             version <- NULL
[17:42:27.435]                           }
[17:42:27.435]                           if (!has_future || version < "1.8.0") {
[17:42:27.435]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:27.435]                               "", base::R.version$version.string), 
[17:42:27.435]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:27.435]                                 base::R.version$platform, 8 * 
[17:42:27.435]                                   base::.Machine$sizeof.pointer), 
[17:42:27.435]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:27.435]                                 "release", "version")], collapse = " "), 
[17:42:27.435]                               hostname = base::Sys.info()[["nodename"]])
[17:42:27.435]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:27.435]                               info)
[17:42:27.435]                             info <- base::paste(info, collapse = "; ")
[17:42:27.435]                             if (!has_future) {
[17:42:27.435]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:27.435]                                 info)
[17:42:27.435]                             }
[17:42:27.435]                             else {
[17:42:27.435]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:27.435]                                 info, version)
[17:42:27.435]                             }
[17:42:27.435]                             base::stop(msg)
[17:42:27.435]                           }
[17:42:27.435]                         })
[17:42:27.435]                       }
[17:42:27.435]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:27.435]                       base::options(mc.cores = 1L)
[17:42:27.435]                     }
[17:42:27.435]                     base::local({
[17:42:27.435]                       for (pkg in "stats") {
[17:42:27.435]                         base::loadNamespace(pkg)
[17:42:27.435]                         base::library(pkg, character.only = TRUE)
[17:42:27.435]                       }
[17:42:27.435]                     })
[17:42:27.435]                   }
[17:42:27.435]                   options(future.plan = NULL)
[17:42:27.435]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:27.435]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:27.435]                 }
[17:42:27.435]                 ...future.workdir <- getwd()
[17:42:27.435]             }
[17:42:27.435]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:27.435]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:27.435]         }
[17:42:27.435]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:27.435]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:27.435]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:27.435]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:27.435]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:27.435]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:27.435]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:27.435]             base::names(...future.oldOptions))
[17:42:27.435]     }
[17:42:27.435]     if (FALSE) {
[17:42:27.435]     }
[17:42:27.435]     else {
[17:42:27.435]         if (TRUE) {
[17:42:27.435]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:27.435]                 open = "w")
[17:42:27.435]         }
[17:42:27.435]         else {
[17:42:27.435]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:27.435]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:27.435]         }
[17:42:27.435]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:27.435]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:27.435]             base::sink(type = "output", split = FALSE)
[17:42:27.435]             base::close(...future.stdout)
[17:42:27.435]         }, add = TRUE)
[17:42:27.435]     }
[17:42:27.435]     ...future.frame <- base::sys.nframe()
[17:42:27.435]     ...future.conditions <- base::list()
[17:42:27.435]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:27.435]     if (FALSE) {
[17:42:27.435]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:27.435]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:27.435]     }
[17:42:27.435]     ...future.result <- base::tryCatch({
[17:42:27.435]         base::withCallingHandlers({
[17:42:27.435]             ...future.value <- base::withVisible(base::local({
[17:42:27.435]                 ...future.makeSendCondition <- local({
[17:42:27.435]                   sendCondition <- NULL
[17:42:27.435]                   function(frame = 1L) {
[17:42:27.435]                     if (is.function(sendCondition)) 
[17:42:27.435]                       return(sendCondition)
[17:42:27.435]                     ns <- getNamespace("parallel")
[17:42:27.435]                     if (exists("sendData", mode = "function", 
[17:42:27.435]                       envir = ns)) {
[17:42:27.435]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:27.435]                         envir = ns)
[17:42:27.435]                       envir <- sys.frame(frame)
[17:42:27.435]                       master <- NULL
[17:42:27.435]                       while (!identical(envir, .GlobalEnv) && 
[17:42:27.435]                         !identical(envir, emptyenv())) {
[17:42:27.435]                         if (exists("master", mode = "list", envir = envir, 
[17:42:27.435]                           inherits = FALSE)) {
[17:42:27.435]                           master <- get("master", mode = "list", 
[17:42:27.435]                             envir = envir, inherits = FALSE)
[17:42:27.435]                           if (inherits(master, c("SOCKnode", 
[17:42:27.435]                             "SOCK0node"))) {
[17:42:27.435]                             sendCondition <<- function(cond) {
[17:42:27.435]                               data <- list(type = "VALUE", value = cond, 
[17:42:27.435]                                 success = TRUE)
[17:42:27.435]                               parallel_sendData(master, data)
[17:42:27.435]                             }
[17:42:27.435]                             return(sendCondition)
[17:42:27.435]                           }
[17:42:27.435]                         }
[17:42:27.435]                         frame <- frame + 1L
[17:42:27.435]                         envir <- sys.frame(frame)
[17:42:27.435]                       }
[17:42:27.435]                     }
[17:42:27.435]                     sendCondition <<- function(cond) NULL
[17:42:27.435]                   }
[17:42:27.435]                 })
[17:42:27.435]                 withCallingHandlers({
[17:42:27.435]                   {
[17:42:27.435]                     lm(weight ~ group - 1)
[17:42:27.435]                   }
[17:42:27.435]                 }, immediateCondition = function(cond) {
[17:42:27.435]                   sendCondition <- ...future.makeSendCondition()
[17:42:27.435]                   sendCondition(cond)
[17:42:27.435]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:27.435]                   {
[17:42:27.435]                     inherits <- base::inherits
[17:42:27.435]                     invokeRestart <- base::invokeRestart
[17:42:27.435]                     is.null <- base::is.null
[17:42:27.435]                     muffled <- FALSE
[17:42:27.435]                     if (inherits(cond, "message")) {
[17:42:27.435]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:27.435]                       if (muffled) 
[17:42:27.435]                         invokeRestart("muffleMessage")
[17:42:27.435]                     }
[17:42:27.435]                     else if (inherits(cond, "warning")) {
[17:42:27.435]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:27.435]                       if (muffled) 
[17:42:27.435]                         invokeRestart("muffleWarning")
[17:42:27.435]                     }
[17:42:27.435]                     else if (inherits(cond, "condition")) {
[17:42:27.435]                       if (!is.null(pattern)) {
[17:42:27.435]                         computeRestarts <- base::computeRestarts
[17:42:27.435]                         grepl <- base::grepl
[17:42:27.435]                         restarts <- computeRestarts(cond)
[17:42:27.435]                         for (restart in restarts) {
[17:42:27.435]                           name <- restart$name
[17:42:27.435]                           if (is.null(name)) 
[17:42:27.435]                             next
[17:42:27.435]                           if (!grepl(pattern, name)) 
[17:42:27.435]                             next
[17:42:27.435]                           invokeRestart(restart)
[17:42:27.435]                           muffled <- TRUE
[17:42:27.435]                           break
[17:42:27.435]                         }
[17:42:27.435]                       }
[17:42:27.435]                     }
[17:42:27.435]                     invisible(muffled)
[17:42:27.435]                   }
[17:42:27.435]                   muffleCondition(cond)
[17:42:27.435]                 })
[17:42:27.435]             }))
[17:42:27.435]             future::FutureResult(value = ...future.value$value, 
[17:42:27.435]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:27.435]                   ...future.rng), globalenv = if (FALSE) 
[17:42:27.435]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:27.435]                     ...future.globalenv.names))
[17:42:27.435]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:27.435]         }, condition = base::local({
[17:42:27.435]             c <- base::c
[17:42:27.435]             inherits <- base::inherits
[17:42:27.435]             invokeRestart <- base::invokeRestart
[17:42:27.435]             length <- base::length
[17:42:27.435]             list <- base::list
[17:42:27.435]             seq.int <- base::seq.int
[17:42:27.435]             signalCondition <- base::signalCondition
[17:42:27.435]             sys.calls <- base::sys.calls
[17:42:27.435]             `[[` <- base::`[[`
[17:42:27.435]             `+` <- base::`+`
[17:42:27.435]             `<<-` <- base::`<<-`
[17:42:27.435]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:27.435]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:27.435]                   3L)]
[17:42:27.435]             }
[17:42:27.435]             function(cond) {
[17:42:27.435]                 is_error <- inherits(cond, "error")
[17:42:27.435]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:27.435]                   NULL)
[17:42:27.435]                 if (is_error) {
[17:42:27.435]                   sessionInformation <- function() {
[17:42:27.435]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:27.435]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:27.435]                       search = base::search(), system = base::Sys.info())
[17:42:27.435]                   }
[17:42:27.435]                   ...future.conditions[[length(...future.conditions) + 
[17:42:27.435]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:27.435]                     cond$call), session = sessionInformation(), 
[17:42:27.435]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:27.435]                   signalCondition(cond)
[17:42:27.435]                 }
[17:42:27.435]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:27.435]                 "immediateCondition"))) {
[17:42:27.435]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:27.435]                   ...future.conditions[[length(...future.conditions) + 
[17:42:27.435]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:27.435]                   if (TRUE && !signal) {
[17:42:27.435]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:27.435]                     {
[17:42:27.435]                       inherits <- base::inherits
[17:42:27.435]                       invokeRestart <- base::invokeRestart
[17:42:27.435]                       is.null <- base::is.null
[17:42:27.435]                       muffled <- FALSE
[17:42:27.435]                       if (inherits(cond, "message")) {
[17:42:27.435]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:27.435]                         if (muffled) 
[17:42:27.435]                           invokeRestart("muffleMessage")
[17:42:27.435]                       }
[17:42:27.435]                       else if (inherits(cond, "warning")) {
[17:42:27.435]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:27.435]                         if (muffled) 
[17:42:27.435]                           invokeRestart("muffleWarning")
[17:42:27.435]                       }
[17:42:27.435]                       else if (inherits(cond, "condition")) {
[17:42:27.435]                         if (!is.null(pattern)) {
[17:42:27.435]                           computeRestarts <- base::computeRestarts
[17:42:27.435]                           grepl <- base::grepl
[17:42:27.435]                           restarts <- computeRestarts(cond)
[17:42:27.435]                           for (restart in restarts) {
[17:42:27.435]                             name <- restart$name
[17:42:27.435]                             if (is.null(name)) 
[17:42:27.435]                               next
[17:42:27.435]                             if (!grepl(pattern, name)) 
[17:42:27.435]                               next
[17:42:27.435]                             invokeRestart(restart)
[17:42:27.435]                             muffled <- TRUE
[17:42:27.435]                             break
[17:42:27.435]                           }
[17:42:27.435]                         }
[17:42:27.435]                       }
[17:42:27.435]                       invisible(muffled)
[17:42:27.435]                     }
[17:42:27.435]                     muffleCondition(cond, pattern = "^muffle")
[17:42:27.435]                   }
[17:42:27.435]                 }
[17:42:27.435]                 else {
[17:42:27.435]                   if (TRUE) {
[17:42:27.435]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:27.435]                     {
[17:42:27.435]                       inherits <- base::inherits
[17:42:27.435]                       invokeRestart <- base::invokeRestart
[17:42:27.435]                       is.null <- base::is.null
[17:42:27.435]                       muffled <- FALSE
[17:42:27.435]                       if (inherits(cond, "message")) {
[17:42:27.435]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:27.435]                         if (muffled) 
[17:42:27.435]                           invokeRestart("muffleMessage")
[17:42:27.435]                       }
[17:42:27.435]                       else if (inherits(cond, "warning")) {
[17:42:27.435]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:27.435]                         if (muffled) 
[17:42:27.435]                           invokeRestart("muffleWarning")
[17:42:27.435]                       }
[17:42:27.435]                       else if (inherits(cond, "condition")) {
[17:42:27.435]                         if (!is.null(pattern)) {
[17:42:27.435]                           computeRestarts <- base::computeRestarts
[17:42:27.435]                           grepl <- base::grepl
[17:42:27.435]                           restarts <- computeRestarts(cond)
[17:42:27.435]                           for (restart in restarts) {
[17:42:27.435]                             name <- restart$name
[17:42:27.435]                             if (is.null(name)) 
[17:42:27.435]                               next
[17:42:27.435]                             if (!grepl(pattern, name)) 
[17:42:27.435]                               next
[17:42:27.435]                             invokeRestart(restart)
[17:42:27.435]                             muffled <- TRUE
[17:42:27.435]                             break
[17:42:27.435]                           }
[17:42:27.435]                         }
[17:42:27.435]                       }
[17:42:27.435]                       invisible(muffled)
[17:42:27.435]                     }
[17:42:27.435]                     muffleCondition(cond, pattern = "^muffle")
[17:42:27.435]                   }
[17:42:27.435]                 }
[17:42:27.435]             }
[17:42:27.435]         }))
[17:42:27.435]     }, error = function(ex) {
[17:42:27.435]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:27.435]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:27.435]                 ...future.rng), started = ...future.startTime, 
[17:42:27.435]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:27.435]             version = "1.8"), class = "FutureResult")
[17:42:27.435]     }, finally = {
[17:42:27.435]         if (!identical(...future.workdir, getwd())) 
[17:42:27.435]             setwd(...future.workdir)
[17:42:27.435]         {
[17:42:27.435]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:27.435]                 ...future.oldOptions$nwarnings <- NULL
[17:42:27.435]             }
[17:42:27.435]             base::options(...future.oldOptions)
[17:42:27.435]             if (.Platform$OS.type == "windows") {
[17:42:27.435]                 old_names <- names(...future.oldEnvVars)
[17:42:27.435]                 envs <- base::Sys.getenv()
[17:42:27.435]                 names <- names(envs)
[17:42:27.435]                 common <- intersect(names, old_names)
[17:42:27.435]                 added <- setdiff(names, old_names)
[17:42:27.435]                 removed <- setdiff(old_names, names)
[17:42:27.435]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:27.435]                   envs[common]]
[17:42:27.435]                 NAMES <- toupper(changed)
[17:42:27.435]                 args <- list()
[17:42:27.435]                 for (kk in seq_along(NAMES)) {
[17:42:27.435]                   name <- changed[[kk]]
[17:42:27.435]                   NAME <- NAMES[[kk]]
[17:42:27.435]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:27.435]                     next
[17:42:27.435]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:27.435]                 }
[17:42:27.435]                 NAMES <- toupper(added)
[17:42:27.435]                 for (kk in seq_along(NAMES)) {
[17:42:27.435]                   name <- added[[kk]]
[17:42:27.435]                   NAME <- NAMES[[kk]]
[17:42:27.435]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:27.435]                     next
[17:42:27.435]                   args[[name]] <- ""
[17:42:27.435]                 }
[17:42:27.435]                 NAMES <- toupper(removed)
[17:42:27.435]                 for (kk in seq_along(NAMES)) {
[17:42:27.435]                   name <- removed[[kk]]
[17:42:27.435]                   NAME <- NAMES[[kk]]
[17:42:27.435]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:27.435]                     next
[17:42:27.435]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:27.435]                 }
[17:42:27.435]                 if (length(args) > 0) 
[17:42:27.435]                   base::do.call(base::Sys.setenv, args = args)
[17:42:27.435]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:27.435]             }
[17:42:27.435]             else {
[17:42:27.435]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:27.435]             }
[17:42:27.435]             {
[17:42:27.435]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:27.435]                   0L) {
[17:42:27.435]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:27.435]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:27.435]                   base::options(opts)
[17:42:27.435]                 }
[17:42:27.435]                 {
[17:42:27.435]                   {
[17:42:27.435]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:27.435]                     NULL
[17:42:27.435]                   }
[17:42:27.435]                   options(future.plan = NULL)
[17:42:27.435]                   if (is.na(NA_character_)) 
[17:42:27.435]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:27.435]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:27.435]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:27.435]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:27.435]                     envir = parent.frame()) 
[17:42:27.435]                   {
[17:42:27.435]                     if (is.function(workers)) 
[17:42:27.435]                       workers <- workers()
[17:42:27.435]                     workers <- structure(as.integer(workers), 
[17:42:27.435]                       class = class(workers))
[17:42:27.435]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:27.435]                       workers >= 1)
[17:42:27.435]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:27.435]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:27.435]                     }
[17:42:27.435]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:27.435]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:27.435]                       envir = envir)
[17:42:27.435]                     if (!future$lazy) 
[17:42:27.435]                       future <- run(future)
[17:42:27.435]                     invisible(future)
[17:42:27.435]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:27.435]                 }
[17:42:27.435]             }
[17:42:27.435]         }
[17:42:27.435]     })
[17:42:27.435]     if (TRUE) {
[17:42:27.435]         base::sink(type = "output", split = FALSE)
[17:42:27.435]         if (TRUE) {
[17:42:27.435]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:27.435]         }
[17:42:27.435]         else {
[17:42:27.435]             ...future.result["stdout"] <- base::list(NULL)
[17:42:27.435]         }
[17:42:27.435]         base::close(...future.stdout)
[17:42:27.435]         ...future.stdout <- NULL
[17:42:27.435]     }
[17:42:27.435]     ...future.result$conditions <- ...future.conditions
[17:42:27.435]     ...future.result$finished <- base::Sys.time()
[17:42:27.435]     ...future.result
[17:42:27.435] }
[17:42:27.439] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[17:42:27.439] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[17:42:27.439] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[17:42:27.440] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[17:42:27.440] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[17:42:27.440] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[17:42:27.441] MultisessionFuture started
[17:42:27.441] - Launch lazy future ... done
[17:42:27.441] run() for ‘MultisessionFuture’ ... done
[17:42:27.441] result() for ClusterFuture ...
[17:42:27.441] receiveMessageFromWorker() for ClusterFuture ...
[17:42:27.442] - Validating connection of MultisessionFuture
[17:42:27.489] - received message: FutureResult
[17:42:27.489] - Received FutureResult
[17:42:27.489] - Erased future from FutureRegistry
[17:42:27.489] result() for ClusterFuture ...
[17:42:27.489] - result already collected: FutureResult
[17:42:27.490] result() for ClusterFuture ... done
[17:42:27.490] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:27.490] result() for ClusterFuture ... done
[17:42:27.490] result() for ClusterFuture ...
[17:42:27.490] - result already collected: FutureResult
[17:42:27.490] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[17:42:27.493] getGlobalsAndPackages() ...
[17:42:27.493] Searching for globals...
[17:42:27.495] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:42:27.495] Searching for globals ... DONE
[17:42:27.495] Resolving globals: FALSE
[17:42:27.495] The total size of the 2 globals is 896 bytes (896 bytes)
[17:42:27.496] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:42:27.496] - globals: [2] ‘weight’, ‘group’
[17:42:27.496] - packages: [1] ‘stats’
[17:42:27.496] getGlobalsAndPackages() ... DONE
[17:42:27.497] run() for ‘Future’ ...
[17:42:27.497] - state: ‘created’
[17:42:27.497] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:27.512] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:27.512] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:27.512]   - Field: ‘node’
[17:42:27.513]   - Field: ‘label’
[17:42:27.513]   - Field: ‘local’
[17:42:27.513]   - Field: ‘owner’
[17:42:27.513]   - Field: ‘envir’
[17:42:27.513]   - Field: ‘workers’
[17:42:27.513]   - Field: ‘packages’
[17:42:27.513]   - Field: ‘gc’
[17:42:27.513]   - Field: ‘conditions’
[17:42:27.513]   - Field: ‘persistent’
[17:42:27.513]   - Field: ‘expr’
[17:42:27.514]   - Field: ‘uuid’
[17:42:27.514]   - Field: ‘seed’
[17:42:27.514]   - Field: ‘version’
[17:42:27.514]   - Field: ‘result’
[17:42:27.514]   - Field: ‘asynchronous’
[17:42:27.514]   - Field: ‘calls’
[17:42:27.514]   - Field: ‘globals’
[17:42:27.515]   - Field: ‘stdout’
[17:42:27.515]   - Field: ‘earlySignal’
[17:42:27.515]   - Field: ‘lazy’
[17:42:27.515]   - Field: ‘state’
[17:42:27.515] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:27.515] - Launch lazy future ...
[17:42:27.516] Packages needed by the future expression (n = 1): ‘stats’
[17:42:27.516] Packages needed by future strategies (n = 0): <none>
[17:42:27.516] {
[17:42:27.516]     {
[17:42:27.516]         {
[17:42:27.516]             ...future.startTime <- base::Sys.time()
[17:42:27.516]             {
[17:42:27.516]                 {
[17:42:27.516]                   {
[17:42:27.516]                     {
[17:42:27.516]                       {
[17:42:27.516]                         base::local({
[17:42:27.516]                           has_future <- base::requireNamespace("future", 
[17:42:27.516]                             quietly = TRUE)
[17:42:27.516]                           if (has_future) {
[17:42:27.516]                             ns <- base::getNamespace("future")
[17:42:27.516]                             version <- ns[[".package"]][["version"]]
[17:42:27.516]                             if (is.null(version)) 
[17:42:27.516]                               version <- utils::packageVersion("future")
[17:42:27.516]                           }
[17:42:27.516]                           else {
[17:42:27.516]                             version <- NULL
[17:42:27.516]                           }
[17:42:27.516]                           if (!has_future || version < "1.8.0") {
[17:42:27.516]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:27.516]                               "", base::R.version$version.string), 
[17:42:27.516]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:27.516]                                 base::R.version$platform, 8 * 
[17:42:27.516]                                   base::.Machine$sizeof.pointer), 
[17:42:27.516]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:27.516]                                 "release", "version")], collapse = " "), 
[17:42:27.516]                               hostname = base::Sys.info()[["nodename"]])
[17:42:27.516]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:27.516]                               info)
[17:42:27.516]                             info <- base::paste(info, collapse = "; ")
[17:42:27.516]                             if (!has_future) {
[17:42:27.516]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:27.516]                                 info)
[17:42:27.516]                             }
[17:42:27.516]                             else {
[17:42:27.516]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:27.516]                                 info, version)
[17:42:27.516]                             }
[17:42:27.516]                             base::stop(msg)
[17:42:27.516]                           }
[17:42:27.516]                         })
[17:42:27.516]                       }
[17:42:27.516]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:27.516]                       base::options(mc.cores = 1L)
[17:42:27.516]                     }
[17:42:27.516]                     base::local({
[17:42:27.516]                       for (pkg in "stats") {
[17:42:27.516]                         base::loadNamespace(pkg)
[17:42:27.516]                         base::library(pkg, character.only = TRUE)
[17:42:27.516]                       }
[17:42:27.516]                     })
[17:42:27.516]                   }
[17:42:27.516]                   options(future.plan = NULL)
[17:42:27.516]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:27.516]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:27.516]                 }
[17:42:27.516]                 ...future.workdir <- getwd()
[17:42:27.516]             }
[17:42:27.516]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:27.516]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:27.516]         }
[17:42:27.516]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:27.516]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:27.516]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:27.516]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:27.516]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:27.516]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:27.516]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:27.516]             base::names(...future.oldOptions))
[17:42:27.516]     }
[17:42:27.516]     if (FALSE) {
[17:42:27.516]     }
[17:42:27.516]     else {
[17:42:27.516]         if (TRUE) {
[17:42:27.516]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:27.516]                 open = "w")
[17:42:27.516]         }
[17:42:27.516]         else {
[17:42:27.516]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:27.516]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:27.516]         }
[17:42:27.516]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:27.516]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:27.516]             base::sink(type = "output", split = FALSE)
[17:42:27.516]             base::close(...future.stdout)
[17:42:27.516]         }, add = TRUE)
[17:42:27.516]     }
[17:42:27.516]     ...future.frame <- base::sys.nframe()
[17:42:27.516]     ...future.conditions <- base::list()
[17:42:27.516]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:27.516]     if (FALSE) {
[17:42:27.516]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:27.516]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:27.516]     }
[17:42:27.516]     ...future.result <- base::tryCatch({
[17:42:27.516]         base::withCallingHandlers({
[17:42:27.516]             ...future.value <- base::withVisible(base::local({
[17:42:27.516]                 ...future.makeSendCondition <- local({
[17:42:27.516]                   sendCondition <- NULL
[17:42:27.516]                   function(frame = 1L) {
[17:42:27.516]                     if (is.function(sendCondition)) 
[17:42:27.516]                       return(sendCondition)
[17:42:27.516]                     ns <- getNamespace("parallel")
[17:42:27.516]                     if (exists("sendData", mode = "function", 
[17:42:27.516]                       envir = ns)) {
[17:42:27.516]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:27.516]                         envir = ns)
[17:42:27.516]                       envir <- sys.frame(frame)
[17:42:27.516]                       master <- NULL
[17:42:27.516]                       while (!identical(envir, .GlobalEnv) && 
[17:42:27.516]                         !identical(envir, emptyenv())) {
[17:42:27.516]                         if (exists("master", mode = "list", envir = envir, 
[17:42:27.516]                           inherits = FALSE)) {
[17:42:27.516]                           master <- get("master", mode = "list", 
[17:42:27.516]                             envir = envir, inherits = FALSE)
[17:42:27.516]                           if (inherits(master, c("SOCKnode", 
[17:42:27.516]                             "SOCK0node"))) {
[17:42:27.516]                             sendCondition <<- function(cond) {
[17:42:27.516]                               data <- list(type = "VALUE", value = cond, 
[17:42:27.516]                                 success = TRUE)
[17:42:27.516]                               parallel_sendData(master, data)
[17:42:27.516]                             }
[17:42:27.516]                             return(sendCondition)
[17:42:27.516]                           }
[17:42:27.516]                         }
[17:42:27.516]                         frame <- frame + 1L
[17:42:27.516]                         envir <- sys.frame(frame)
[17:42:27.516]                       }
[17:42:27.516]                     }
[17:42:27.516]                     sendCondition <<- function(cond) NULL
[17:42:27.516]                   }
[17:42:27.516]                 })
[17:42:27.516]                 withCallingHandlers({
[17:42:27.516]                   {
[17:42:27.516]                     lm(weight ~ group - 1)
[17:42:27.516]                   }
[17:42:27.516]                 }, immediateCondition = function(cond) {
[17:42:27.516]                   sendCondition <- ...future.makeSendCondition()
[17:42:27.516]                   sendCondition(cond)
[17:42:27.516]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:27.516]                   {
[17:42:27.516]                     inherits <- base::inherits
[17:42:27.516]                     invokeRestart <- base::invokeRestart
[17:42:27.516]                     is.null <- base::is.null
[17:42:27.516]                     muffled <- FALSE
[17:42:27.516]                     if (inherits(cond, "message")) {
[17:42:27.516]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:27.516]                       if (muffled) 
[17:42:27.516]                         invokeRestart("muffleMessage")
[17:42:27.516]                     }
[17:42:27.516]                     else if (inherits(cond, "warning")) {
[17:42:27.516]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:27.516]                       if (muffled) 
[17:42:27.516]                         invokeRestart("muffleWarning")
[17:42:27.516]                     }
[17:42:27.516]                     else if (inherits(cond, "condition")) {
[17:42:27.516]                       if (!is.null(pattern)) {
[17:42:27.516]                         computeRestarts <- base::computeRestarts
[17:42:27.516]                         grepl <- base::grepl
[17:42:27.516]                         restarts <- computeRestarts(cond)
[17:42:27.516]                         for (restart in restarts) {
[17:42:27.516]                           name <- restart$name
[17:42:27.516]                           if (is.null(name)) 
[17:42:27.516]                             next
[17:42:27.516]                           if (!grepl(pattern, name)) 
[17:42:27.516]                             next
[17:42:27.516]                           invokeRestart(restart)
[17:42:27.516]                           muffled <- TRUE
[17:42:27.516]                           break
[17:42:27.516]                         }
[17:42:27.516]                       }
[17:42:27.516]                     }
[17:42:27.516]                     invisible(muffled)
[17:42:27.516]                   }
[17:42:27.516]                   muffleCondition(cond)
[17:42:27.516]                 })
[17:42:27.516]             }))
[17:42:27.516]             future::FutureResult(value = ...future.value$value, 
[17:42:27.516]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:27.516]                   ...future.rng), globalenv = if (FALSE) 
[17:42:27.516]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:27.516]                     ...future.globalenv.names))
[17:42:27.516]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:27.516]         }, condition = base::local({
[17:42:27.516]             c <- base::c
[17:42:27.516]             inherits <- base::inherits
[17:42:27.516]             invokeRestart <- base::invokeRestart
[17:42:27.516]             length <- base::length
[17:42:27.516]             list <- base::list
[17:42:27.516]             seq.int <- base::seq.int
[17:42:27.516]             signalCondition <- base::signalCondition
[17:42:27.516]             sys.calls <- base::sys.calls
[17:42:27.516]             `[[` <- base::`[[`
[17:42:27.516]             `+` <- base::`+`
[17:42:27.516]             `<<-` <- base::`<<-`
[17:42:27.516]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:27.516]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:27.516]                   3L)]
[17:42:27.516]             }
[17:42:27.516]             function(cond) {
[17:42:27.516]                 is_error <- inherits(cond, "error")
[17:42:27.516]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:27.516]                   NULL)
[17:42:27.516]                 if (is_error) {
[17:42:27.516]                   sessionInformation <- function() {
[17:42:27.516]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:27.516]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:27.516]                       search = base::search(), system = base::Sys.info())
[17:42:27.516]                   }
[17:42:27.516]                   ...future.conditions[[length(...future.conditions) + 
[17:42:27.516]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:27.516]                     cond$call), session = sessionInformation(), 
[17:42:27.516]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:27.516]                   signalCondition(cond)
[17:42:27.516]                 }
[17:42:27.516]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:27.516]                 "immediateCondition"))) {
[17:42:27.516]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:27.516]                   ...future.conditions[[length(...future.conditions) + 
[17:42:27.516]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:27.516]                   if (TRUE && !signal) {
[17:42:27.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:27.516]                     {
[17:42:27.516]                       inherits <- base::inherits
[17:42:27.516]                       invokeRestart <- base::invokeRestart
[17:42:27.516]                       is.null <- base::is.null
[17:42:27.516]                       muffled <- FALSE
[17:42:27.516]                       if (inherits(cond, "message")) {
[17:42:27.516]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:27.516]                         if (muffled) 
[17:42:27.516]                           invokeRestart("muffleMessage")
[17:42:27.516]                       }
[17:42:27.516]                       else if (inherits(cond, "warning")) {
[17:42:27.516]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:27.516]                         if (muffled) 
[17:42:27.516]                           invokeRestart("muffleWarning")
[17:42:27.516]                       }
[17:42:27.516]                       else if (inherits(cond, "condition")) {
[17:42:27.516]                         if (!is.null(pattern)) {
[17:42:27.516]                           computeRestarts <- base::computeRestarts
[17:42:27.516]                           grepl <- base::grepl
[17:42:27.516]                           restarts <- computeRestarts(cond)
[17:42:27.516]                           for (restart in restarts) {
[17:42:27.516]                             name <- restart$name
[17:42:27.516]                             if (is.null(name)) 
[17:42:27.516]                               next
[17:42:27.516]                             if (!grepl(pattern, name)) 
[17:42:27.516]                               next
[17:42:27.516]                             invokeRestart(restart)
[17:42:27.516]                             muffled <- TRUE
[17:42:27.516]                             break
[17:42:27.516]                           }
[17:42:27.516]                         }
[17:42:27.516]                       }
[17:42:27.516]                       invisible(muffled)
[17:42:27.516]                     }
[17:42:27.516]                     muffleCondition(cond, pattern = "^muffle")
[17:42:27.516]                   }
[17:42:27.516]                 }
[17:42:27.516]                 else {
[17:42:27.516]                   if (TRUE) {
[17:42:27.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:27.516]                     {
[17:42:27.516]                       inherits <- base::inherits
[17:42:27.516]                       invokeRestart <- base::invokeRestart
[17:42:27.516]                       is.null <- base::is.null
[17:42:27.516]                       muffled <- FALSE
[17:42:27.516]                       if (inherits(cond, "message")) {
[17:42:27.516]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:27.516]                         if (muffled) 
[17:42:27.516]                           invokeRestart("muffleMessage")
[17:42:27.516]                       }
[17:42:27.516]                       else if (inherits(cond, "warning")) {
[17:42:27.516]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:27.516]                         if (muffled) 
[17:42:27.516]                           invokeRestart("muffleWarning")
[17:42:27.516]                       }
[17:42:27.516]                       else if (inherits(cond, "condition")) {
[17:42:27.516]                         if (!is.null(pattern)) {
[17:42:27.516]                           computeRestarts <- base::computeRestarts
[17:42:27.516]                           grepl <- base::grepl
[17:42:27.516]                           restarts <- computeRestarts(cond)
[17:42:27.516]                           for (restart in restarts) {
[17:42:27.516]                             name <- restart$name
[17:42:27.516]                             if (is.null(name)) 
[17:42:27.516]                               next
[17:42:27.516]                             if (!grepl(pattern, name)) 
[17:42:27.516]                               next
[17:42:27.516]                             invokeRestart(restart)
[17:42:27.516]                             muffled <- TRUE
[17:42:27.516]                             break
[17:42:27.516]                           }
[17:42:27.516]                         }
[17:42:27.516]                       }
[17:42:27.516]                       invisible(muffled)
[17:42:27.516]                     }
[17:42:27.516]                     muffleCondition(cond, pattern = "^muffle")
[17:42:27.516]                   }
[17:42:27.516]                 }
[17:42:27.516]             }
[17:42:27.516]         }))
[17:42:27.516]     }, error = function(ex) {
[17:42:27.516]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:27.516]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:27.516]                 ...future.rng), started = ...future.startTime, 
[17:42:27.516]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:27.516]             version = "1.8"), class = "FutureResult")
[17:42:27.516]     }, finally = {
[17:42:27.516]         if (!identical(...future.workdir, getwd())) 
[17:42:27.516]             setwd(...future.workdir)
[17:42:27.516]         {
[17:42:27.516]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:27.516]                 ...future.oldOptions$nwarnings <- NULL
[17:42:27.516]             }
[17:42:27.516]             base::options(...future.oldOptions)
[17:42:27.516]             if (.Platform$OS.type == "windows") {
[17:42:27.516]                 old_names <- names(...future.oldEnvVars)
[17:42:27.516]                 envs <- base::Sys.getenv()
[17:42:27.516]                 names <- names(envs)
[17:42:27.516]                 common <- intersect(names, old_names)
[17:42:27.516]                 added <- setdiff(names, old_names)
[17:42:27.516]                 removed <- setdiff(old_names, names)
[17:42:27.516]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:27.516]                   envs[common]]
[17:42:27.516]                 NAMES <- toupper(changed)
[17:42:27.516]                 args <- list()
[17:42:27.516]                 for (kk in seq_along(NAMES)) {
[17:42:27.516]                   name <- changed[[kk]]
[17:42:27.516]                   NAME <- NAMES[[kk]]
[17:42:27.516]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:27.516]                     next
[17:42:27.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:27.516]                 }
[17:42:27.516]                 NAMES <- toupper(added)
[17:42:27.516]                 for (kk in seq_along(NAMES)) {
[17:42:27.516]                   name <- added[[kk]]
[17:42:27.516]                   NAME <- NAMES[[kk]]
[17:42:27.516]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:27.516]                     next
[17:42:27.516]                   args[[name]] <- ""
[17:42:27.516]                 }
[17:42:27.516]                 NAMES <- toupper(removed)
[17:42:27.516]                 for (kk in seq_along(NAMES)) {
[17:42:27.516]                   name <- removed[[kk]]
[17:42:27.516]                   NAME <- NAMES[[kk]]
[17:42:27.516]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:27.516]                     next
[17:42:27.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:27.516]                 }
[17:42:27.516]                 if (length(args) > 0) 
[17:42:27.516]                   base::do.call(base::Sys.setenv, args = args)
[17:42:27.516]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:27.516]             }
[17:42:27.516]             else {
[17:42:27.516]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:27.516]             }
[17:42:27.516]             {
[17:42:27.516]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:27.516]                   0L) {
[17:42:27.516]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:27.516]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:27.516]                   base::options(opts)
[17:42:27.516]                 }
[17:42:27.516]                 {
[17:42:27.516]                   {
[17:42:27.516]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:27.516]                     NULL
[17:42:27.516]                   }
[17:42:27.516]                   options(future.plan = NULL)
[17:42:27.516]                   if (is.na(NA_character_)) 
[17:42:27.516]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:27.516]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:27.516]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:27.516]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:27.516]                     envir = parent.frame()) 
[17:42:27.516]                   {
[17:42:27.516]                     if (is.function(workers)) 
[17:42:27.516]                       workers <- workers()
[17:42:27.516]                     workers <- structure(as.integer(workers), 
[17:42:27.516]                       class = class(workers))
[17:42:27.516]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:27.516]                       workers >= 1)
[17:42:27.516]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:27.516]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:27.516]                     }
[17:42:27.516]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:27.516]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:27.516]                       envir = envir)
[17:42:27.516]                     if (!future$lazy) 
[17:42:27.516]                       future <- run(future)
[17:42:27.516]                     invisible(future)
[17:42:27.516]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:27.516]                 }
[17:42:27.516]             }
[17:42:27.516]         }
[17:42:27.516]     })
[17:42:27.516]     if (TRUE) {
[17:42:27.516]         base::sink(type = "output", split = FALSE)
[17:42:27.516]         if (TRUE) {
[17:42:27.516]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:27.516]         }
[17:42:27.516]         else {
[17:42:27.516]             ...future.result["stdout"] <- base::list(NULL)
[17:42:27.516]         }
[17:42:27.516]         base::close(...future.stdout)
[17:42:27.516]         ...future.stdout <- NULL
[17:42:27.516]     }
[17:42:27.516]     ...future.result$conditions <- ...future.conditions
[17:42:27.516]     ...future.result$finished <- base::Sys.time()
[17:42:27.516]     ...future.result
[17:42:27.516] }
[17:42:27.520] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[17:42:27.520] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[17:42:27.520] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[17:42:27.520] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[17:42:27.523] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[17:42:27.523] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[17:42:27.524] MultisessionFuture started
[17:42:27.524] - Launch lazy future ... done
[17:42:27.524] run() for ‘MultisessionFuture’ ... done
[17:42:27.524] result() for ClusterFuture ...
[17:42:27.524] receiveMessageFromWorker() for ClusterFuture ...
[17:42:27.524] - Validating connection of MultisessionFuture
[17:42:27.573] - received message: FutureResult
[17:42:27.573] - Received FutureResult
[17:42:27.574] - Erased future from FutureRegistry
[17:42:27.574] result() for ClusterFuture ...
[17:42:27.574] - result already collected: FutureResult
[17:42:27.574] result() for ClusterFuture ... done
[17:42:27.574] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:27.574] result() for ClusterFuture ... done
[17:42:27.574] result() for ClusterFuture ...
[17:42:27.574] - result already collected: FutureResult
[17:42:27.574] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[17:42:27.576] getGlobalsAndPackages() ...
[17:42:27.576] Searching for globals...
[17:42:27.578] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:42:27.578] Searching for globals ... DONE
[17:42:27.578] Resolving globals: FALSE
[17:42:27.579] The total size of the 2 globals is 896 bytes (896 bytes)
[17:42:27.579] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:42:27.579] - globals: [2] ‘weight’, ‘group’
[17:42:27.579] - packages: [1] ‘stats’
[17:42:27.579] getGlobalsAndPackages() ... DONE
[17:42:27.580] run() for ‘Future’ ...
[17:42:27.580] - state: ‘created’
[17:42:27.580] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:27.594] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:27.594] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:27.594]   - Field: ‘node’
[17:42:27.594]   - Field: ‘label’
[17:42:27.595]   - Field: ‘local’
[17:42:27.595]   - Field: ‘owner’
[17:42:27.595]   - Field: ‘envir’
[17:42:27.595]   - Field: ‘workers’
[17:42:27.595]   - Field: ‘packages’
[17:42:27.595]   - Field: ‘gc’
[17:42:27.595]   - Field: ‘conditions’
[17:42:27.595]   - Field: ‘persistent’
[17:42:27.595]   - Field: ‘expr’
[17:42:27.595]   - Field: ‘uuid’
[17:42:27.596]   - Field: ‘seed’
[17:42:27.596]   - Field: ‘version’
[17:42:27.596]   - Field: ‘result’
[17:42:27.596]   - Field: ‘asynchronous’
[17:42:27.596]   - Field: ‘calls’
[17:42:27.596]   - Field: ‘globals’
[17:42:27.596]   - Field: ‘stdout’
[17:42:27.596]   - Field: ‘earlySignal’
[17:42:27.596]   - Field: ‘lazy’
[17:42:27.596]   - Field: ‘state’
[17:42:27.596] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:27.597] - Launch lazy future ...
[17:42:27.597] Packages needed by the future expression (n = 1): ‘stats’
[17:42:27.597] Packages needed by future strategies (n = 0): <none>
[17:42:27.597] {
[17:42:27.597]     {
[17:42:27.597]         {
[17:42:27.597]             ...future.startTime <- base::Sys.time()
[17:42:27.597]             {
[17:42:27.597]                 {
[17:42:27.597]                   {
[17:42:27.597]                     {
[17:42:27.597]                       {
[17:42:27.597]                         base::local({
[17:42:27.597]                           has_future <- base::requireNamespace("future", 
[17:42:27.597]                             quietly = TRUE)
[17:42:27.597]                           if (has_future) {
[17:42:27.597]                             ns <- base::getNamespace("future")
[17:42:27.597]                             version <- ns[[".package"]][["version"]]
[17:42:27.597]                             if (is.null(version)) 
[17:42:27.597]                               version <- utils::packageVersion("future")
[17:42:27.597]                           }
[17:42:27.597]                           else {
[17:42:27.597]                             version <- NULL
[17:42:27.597]                           }
[17:42:27.597]                           if (!has_future || version < "1.8.0") {
[17:42:27.597]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:27.597]                               "", base::R.version$version.string), 
[17:42:27.597]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:27.597]                                 base::R.version$platform, 8 * 
[17:42:27.597]                                   base::.Machine$sizeof.pointer), 
[17:42:27.597]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:27.597]                                 "release", "version")], collapse = " "), 
[17:42:27.597]                               hostname = base::Sys.info()[["nodename"]])
[17:42:27.597]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:27.597]                               info)
[17:42:27.597]                             info <- base::paste(info, collapse = "; ")
[17:42:27.597]                             if (!has_future) {
[17:42:27.597]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:27.597]                                 info)
[17:42:27.597]                             }
[17:42:27.597]                             else {
[17:42:27.597]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:27.597]                                 info, version)
[17:42:27.597]                             }
[17:42:27.597]                             base::stop(msg)
[17:42:27.597]                           }
[17:42:27.597]                         })
[17:42:27.597]                       }
[17:42:27.597]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:27.597]                       base::options(mc.cores = 1L)
[17:42:27.597]                     }
[17:42:27.597]                     base::local({
[17:42:27.597]                       for (pkg in "stats") {
[17:42:27.597]                         base::loadNamespace(pkg)
[17:42:27.597]                         base::library(pkg, character.only = TRUE)
[17:42:27.597]                       }
[17:42:27.597]                     })
[17:42:27.597]                   }
[17:42:27.597]                   options(future.plan = NULL)
[17:42:27.597]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:27.597]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:27.597]                 }
[17:42:27.597]                 ...future.workdir <- getwd()
[17:42:27.597]             }
[17:42:27.597]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:27.597]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:27.597]         }
[17:42:27.597]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:27.597]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:27.597]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:27.597]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:27.597]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:27.597]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:27.597]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:27.597]             base::names(...future.oldOptions))
[17:42:27.597]     }
[17:42:27.597]     if (FALSE) {
[17:42:27.597]     }
[17:42:27.597]     else {
[17:42:27.597]         if (TRUE) {
[17:42:27.597]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:27.597]                 open = "w")
[17:42:27.597]         }
[17:42:27.597]         else {
[17:42:27.597]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:27.597]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:27.597]         }
[17:42:27.597]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:27.597]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:27.597]             base::sink(type = "output", split = FALSE)
[17:42:27.597]             base::close(...future.stdout)
[17:42:27.597]         }, add = TRUE)
[17:42:27.597]     }
[17:42:27.597]     ...future.frame <- base::sys.nframe()
[17:42:27.597]     ...future.conditions <- base::list()
[17:42:27.597]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:27.597]     if (FALSE) {
[17:42:27.597]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:27.597]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:27.597]     }
[17:42:27.597]     ...future.result <- base::tryCatch({
[17:42:27.597]         base::withCallingHandlers({
[17:42:27.597]             ...future.value <- base::withVisible(base::local({
[17:42:27.597]                 ...future.makeSendCondition <- local({
[17:42:27.597]                   sendCondition <- NULL
[17:42:27.597]                   function(frame = 1L) {
[17:42:27.597]                     if (is.function(sendCondition)) 
[17:42:27.597]                       return(sendCondition)
[17:42:27.597]                     ns <- getNamespace("parallel")
[17:42:27.597]                     if (exists("sendData", mode = "function", 
[17:42:27.597]                       envir = ns)) {
[17:42:27.597]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:27.597]                         envir = ns)
[17:42:27.597]                       envir <- sys.frame(frame)
[17:42:27.597]                       master <- NULL
[17:42:27.597]                       while (!identical(envir, .GlobalEnv) && 
[17:42:27.597]                         !identical(envir, emptyenv())) {
[17:42:27.597]                         if (exists("master", mode = "list", envir = envir, 
[17:42:27.597]                           inherits = FALSE)) {
[17:42:27.597]                           master <- get("master", mode = "list", 
[17:42:27.597]                             envir = envir, inherits = FALSE)
[17:42:27.597]                           if (inherits(master, c("SOCKnode", 
[17:42:27.597]                             "SOCK0node"))) {
[17:42:27.597]                             sendCondition <<- function(cond) {
[17:42:27.597]                               data <- list(type = "VALUE", value = cond, 
[17:42:27.597]                                 success = TRUE)
[17:42:27.597]                               parallel_sendData(master, data)
[17:42:27.597]                             }
[17:42:27.597]                             return(sendCondition)
[17:42:27.597]                           }
[17:42:27.597]                         }
[17:42:27.597]                         frame <- frame + 1L
[17:42:27.597]                         envir <- sys.frame(frame)
[17:42:27.597]                       }
[17:42:27.597]                     }
[17:42:27.597]                     sendCondition <<- function(cond) NULL
[17:42:27.597]                   }
[17:42:27.597]                 })
[17:42:27.597]                 withCallingHandlers({
[17:42:27.597]                   {
[17:42:27.597]                     lm(weight ~ group - 1)
[17:42:27.597]                   }
[17:42:27.597]                 }, immediateCondition = function(cond) {
[17:42:27.597]                   sendCondition <- ...future.makeSendCondition()
[17:42:27.597]                   sendCondition(cond)
[17:42:27.597]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:27.597]                   {
[17:42:27.597]                     inherits <- base::inherits
[17:42:27.597]                     invokeRestart <- base::invokeRestart
[17:42:27.597]                     is.null <- base::is.null
[17:42:27.597]                     muffled <- FALSE
[17:42:27.597]                     if (inherits(cond, "message")) {
[17:42:27.597]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:27.597]                       if (muffled) 
[17:42:27.597]                         invokeRestart("muffleMessage")
[17:42:27.597]                     }
[17:42:27.597]                     else if (inherits(cond, "warning")) {
[17:42:27.597]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:27.597]                       if (muffled) 
[17:42:27.597]                         invokeRestart("muffleWarning")
[17:42:27.597]                     }
[17:42:27.597]                     else if (inherits(cond, "condition")) {
[17:42:27.597]                       if (!is.null(pattern)) {
[17:42:27.597]                         computeRestarts <- base::computeRestarts
[17:42:27.597]                         grepl <- base::grepl
[17:42:27.597]                         restarts <- computeRestarts(cond)
[17:42:27.597]                         for (restart in restarts) {
[17:42:27.597]                           name <- restart$name
[17:42:27.597]                           if (is.null(name)) 
[17:42:27.597]                             next
[17:42:27.597]                           if (!grepl(pattern, name)) 
[17:42:27.597]                             next
[17:42:27.597]                           invokeRestart(restart)
[17:42:27.597]                           muffled <- TRUE
[17:42:27.597]                           break
[17:42:27.597]                         }
[17:42:27.597]                       }
[17:42:27.597]                     }
[17:42:27.597]                     invisible(muffled)
[17:42:27.597]                   }
[17:42:27.597]                   muffleCondition(cond)
[17:42:27.597]                 })
[17:42:27.597]             }))
[17:42:27.597]             future::FutureResult(value = ...future.value$value, 
[17:42:27.597]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:27.597]                   ...future.rng), globalenv = if (FALSE) 
[17:42:27.597]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:27.597]                     ...future.globalenv.names))
[17:42:27.597]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:27.597]         }, condition = base::local({
[17:42:27.597]             c <- base::c
[17:42:27.597]             inherits <- base::inherits
[17:42:27.597]             invokeRestart <- base::invokeRestart
[17:42:27.597]             length <- base::length
[17:42:27.597]             list <- base::list
[17:42:27.597]             seq.int <- base::seq.int
[17:42:27.597]             signalCondition <- base::signalCondition
[17:42:27.597]             sys.calls <- base::sys.calls
[17:42:27.597]             `[[` <- base::`[[`
[17:42:27.597]             `+` <- base::`+`
[17:42:27.597]             `<<-` <- base::`<<-`
[17:42:27.597]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:27.597]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:27.597]                   3L)]
[17:42:27.597]             }
[17:42:27.597]             function(cond) {
[17:42:27.597]                 is_error <- inherits(cond, "error")
[17:42:27.597]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:27.597]                   NULL)
[17:42:27.597]                 if (is_error) {
[17:42:27.597]                   sessionInformation <- function() {
[17:42:27.597]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:27.597]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:27.597]                       search = base::search(), system = base::Sys.info())
[17:42:27.597]                   }
[17:42:27.597]                   ...future.conditions[[length(...future.conditions) + 
[17:42:27.597]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:27.597]                     cond$call), session = sessionInformation(), 
[17:42:27.597]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:27.597]                   signalCondition(cond)
[17:42:27.597]                 }
[17:42:27.597]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:27.597]                 "immediateCondition"))) {
[17:42:27.597]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:27.597]                   ...future.conditions[[length(...future.conditions) + 
[17:42:27.597]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:27.597]                   if (TRUE && !signal) {
[17:42:27.597]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:27.597]                     {
[17:42:27.597]                       inherits <- base::inherits
[17:42:27.597]                       invokeRestart <- base::invokeRestart
[17:42:27.597]                       is.null <- base::is.null
[17:42:27.597]                       muffled <- FALSE
[17:42:27.597]                       if (inherits(cond, "message")) {
[17:42:27.597]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:27.597]                         if (muffled) 
[17:42:27.597]                           invokeRestart("muffleMessage")
[17:42:27.597]                       }
[17:42:27.597]                       else if (inherits(cond, "warning")) {
[17:42:27.597]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:27.597]                         if (muffled) 
[17:42:27.597]                           invokeRestart("muffleWarning")
[17:42:27.597]                       }
[17:42:27.597]                       else if (inherits(cond, "condition")) {
[17:42:27.597]                         if (!is.null(pattern)) {
[17:42:27.597]                           computeRestarts <- base::computeRestarts
[17:42:27.597]                           grepl <- base::grepl
[17:42:27.597]                           restarts <- computeRestarts(cond)
[17:42:27.597]                           for (restart in restarts) {
[17:42:27.597]                             name <- restart$name
[17:42:27.597]                             if (is.null(name)) 
[17:42:27.597]                               next
[17:42:27.597]                             if (!grepl(pattern, name)) 
[17:42:27.597]                               next
[17:42:27.597]                             invokeRestart(restart)
[17:42:27.597]                             muffled <- TRUE
[17:42:27.597]                             break
[17:42:27.597]                           }
[17:42:27.597]                         }
[17:42:27.597]                       }
[17:42:27.597]                       invisible(muffled)
[17:42:27.597]                     }
[17:42:27.597]                     muffleCondition(cond, pattern = "^muffle")
[17:42:27.597]                   }
[17:42:27.597]                 }
[17:42:27.597]                 else {
[17:42:27.597]                   if (TRUE) {
[17:42:27.597]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:27.597]                     {
[17:42:27.597]                       inherits <- base::inherits
[17:42:27.597]                       invokeRestart <- base::invokeRestart
[17:42:27.597]                       is.null <- base::is.null
[17:42:27.597]                       muffled <- FALSE
[17:42:27.597]                       if (inherits(cond, "message")) {
[17:42:27.597]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:27.597]                         if (muffled) 
[17:42:27.597]                           invokeRestart("muffleMessage")
[17:42:27.597]                       }
[17:42:27.597]                       else if (inherits(cond, "warning")) {
[17:42:27.597]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:27.597]                         if (muffled) 
[17:42:27.597]                           invokeRestart("muffleWarning")
[17:42:27.597]                       }
[17:42:27.597]                       else if (inherits(cond, "condition")) {
[17:42:27.597]                         if (!is.null(pattern)) {
[17:42:27.597]                           computeRestarts <- base::computeRestarts
[17:42:27.597]                           grepl <- base::grepl
[17:42:27.597]                           restarts <- computeRestarts(cond)
[17:42:27.597]                           for (restart in restarts) {
[17:42:27.597]                             name <- restart$name
[17:42:27.597]                             if (is.null(name)) 
[17:42:27.597]                               next
[17:42:27.597]                             if (!grepl(pattern, name)) 
[17:42:27.597]                               next
[17:42:27.597]                             invokeRestart(restart)
[17:42:27.597]                             muffled <- TRUE
[17:42:27.597]                             break
[17:42:27.597]                           }
[17:42:27.597]                         }
[17:42:27.597]                       }
[17:42:27.597]                       invisible(muffled)
[17:42:27.597]                     }
[17:42:27.597]                     muffleCondition(cond, pattern = "^muffle")
[17:42:27.597]                   }
[17:42:27.597]                 }
[17:42:27.597]             }
[17:42:27.597]         }))
[17:42:27.597]     }, error = function(ex) {
[17:42:27.597]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:27.597]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:27.597]                 ...future.rng), started = ...future.startTime, 
[17:42:27.597]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:27.597]             version = "1.8"), class = "FutureResult")
[17:42:27.597]     }, finally = {
[17:42:27.597]         if (!identical(...future.workdir, getwd())) 
[17:42:27.597]             setwd(...future.workdir)
[17:42:27.597]         {
[17:42:27.597]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:27.597]                 ...future.oldOptions$nwarnings <- NULL
[17:42:27.597]             }
[17:42:27.597]             base::options(...future.oldOptions)
[17:42:27.597]             if (.Platform$OS.type == "windows") {
[17:42:27.597]                 old_names <- names(...future.oldEnvVars)
[17:42:27.597]                 envs <- base::Sys.getenv()
[17:42:27.597]                 names <- names(envs)
[17:42:27.597]                 common <- intersect(names, old_names)
[17:42:27.597]                 added <- setdiff(names, old_names)
[17:42:27.597]                 removed <- setdiff(old_names, names)
[17:42:27.597]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:27.597]                   envs[common]]
[17:42:27.597]                 NAMES <- toupper(changed)
[17:42:27.597]                 args <- list()
[17:42:27.597]                 for (kk in seq_along(NAMES)) {
[17:42:27.597]                   name <- changed[[kk]]
[17:42:27.597]                   NAME <- NAMES[[kk]]
[17:42:27.597]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:27.597]                     next
[17:42:27.597]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:27.597]                 }
[17:42:27.597]                 NAMES <- toupper(added)
[17:42:27.597]                 for (kk in seq_along(NAMES)) {
[17:42:27.597]                   name <- added[[kk]]
[17:42:27.597]                   NAME <- NAMES[[kk]]
[17:42:27.597]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:27.597]                     next
[17:42:27.597]                   args[[name]] <- ""
[17:42:27.597]                 }
[17:42:27.597]                 NAMES <- toupper(removed)
[17:42:27.597]                 for (kk in seq_along(NAMES)) {
[17:42:27.597]                   name <- removed[[kk]]
[17:42:27.597]                   NAME <- NAMES[[kk]]
[17:42:27.597]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:27.597]                     next
[17:42:27.597]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:27.597]                 }
[17:42:27.597]                 if (length(args) > 0) 
[17:42:27.597]                   base::do.call(base::Sys.setenv, args = args)
[17:42:27.597]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:27.597]             }
[17:42:27.597]             else {
[17:42:27.597]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:27.597]             }
[17:42:27.597]             {
[17:42:27.597]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:27.597]                   0L) {
[17:42:27.597]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:27.597]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:27.597]                   base::options(opts)
[17:42:27.597]                 }
[17:42:27.597]                 {
[17:42:27.597]                   {
[17:42:27.597]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:27.597]                     NULL
[17:42:27.597]                   }
[17:42:27.597]                   options(future.plan = NULL)
[17:42:27.597]                   if (is.na(NA_character_)) 
[17:42:27.597]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:27.597]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:27.597]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:27.597]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:27.597]                     envir = parent.frame()) 
[17:42:27.597]                   {
[17:42:27.597]                     if (is.function(workers)) 
[17:42:27.597]                       workers <- workers()
[17:42:27.597]                     workers <- structure(as.integer(workers), 
[17:42:27.597]                       class = class(workers))
[17:42:27.597]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:27.597]                       workers >= 1)
[17:42:27.597]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:27.597]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:27.597]                     }
[17:42:27.597]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:27.597]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:27.597]                       envir = envir)
[17:42:27.597]                     if (!future$lazy) 
[17:42:27.597]                       future <- run(future)
[17:42:27.597]                     invisible(future)
[17:42:27.597]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:27.597]                 }
[17:42:27.597]             }
[17:42:27.597]         }
[17:42:27.597]     })
[17:42:27.597]     if (TRUE) {
[17:42:27.597]         base::sink(type = "output", split = FALSE)
[17:42:27.597]         if (TRUE) {
[17:42:27.597]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:27.597]         }
[17:42:27.597]         else {
[17:42:27.597]             ...future.result["stdout"] <- base::list(NULL)
[17:42:27.597]         }
[17:42:27.597]         base::close(...future.stdout)
[17:42:27.597]         ...future.stdout <- NULL
[17:42:27.597]     }
[17:42:27.597]     ...future.result$conditions <- ...future.conditions
[17:42:27.597]     ...future.result$finished <- base::Sys.time()
[17:42:27.597]     ...future.result
[17:42:27.597] }
[17:42:27.600] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[17:42:27.600] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[17:42:27.601] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[17:42:27.601] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[17:42:27.601] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[17:42:27.601] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[17:42:27.602] MultisessionFuture started
[17:42:27.602] - Launch lazy future ... done
[17:42:27.602] run() for ‘MultisessionFuture’ ... done
[17:42:27.603] result() for ClusterFuture ...
[17:42:27.603] receiveMessageFromWorker() for ClusterFuture ...
[17:42:27.603] - Validating connection of MultisessionFuture
[17:42:27.649] - received message: FutureResult
[17:42:27.649] - Received FutureResult
[17:42:27.649] - Erased future from FutureRegistry
[17:42:27.650] result() for ClusterFuture ...
[17:42:27.650] - result already collected: FutureResult
[17:42:27.650] result() for ClusterFuture ... done
[17:42:27.650] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:27.650] result() for ClusterFuture ... done
[17:42:27.650] result() for ClusterFuture ...
[17:42:27.650] - result already collected: FutureResult
[17:42:27.650] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[17:42:27.652] getGlobalsAndPackages() ...
[17:42:27.652] Searching for globals...
[17:42:27.654] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:42:27.654] Searching for globals ... DONE
[17:42:27.654] Resolving globals: FALSE
[17:42:27.654] The total size of the 2 globals is 896 bytes (896 bytes)
[17:42:27.655] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:42:27.655] - globals: [2] ‘weight’, ‘group’
[17:42:27.655] - packages: [1] ‘stats’
[17:42:27.655] getGlobalsAndPackages() ... DONE
[17:42:27.656] run() for ‘Future’ ...
[17:42:27.656] - state: ‘created’
[17:42:27.656] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:27.672] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:27.672] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:27.673]   - Field: ‘node’
[17:42:27.673]   - Field: ‘label’
[17:42:27.673]   - Field: ‘local’
[17:42:27.673]   - Field: ‘owner’
[17:42:27.673]   - Field: ‘envir’
[17:42:27.673]   - Field: ‘workers’
[17:42:27.673]   - Field: ‘packages’
[17:42:27.673]   - Field: ‘gc’
[17:42:27.673]   - Field: ‘conditions’
[17:42:27.673]   - Field: ‘persistent’
[17:42:27.673]   - Field: ‘expr’
[17:42:27.674]   - Field: ‘uuid’
[17:42:27.674]   - Field: ‘seed’
[17:42:27.674]   - Field: ‘version’
[17:42:27.674]   - Field: ‘result’
[17:42:27.674]   - Field: ‘asynchronous’
[17:42:27.674]   - Field: ‘calls’
[17:42:27.674]   - Field: ‘globals’
[17:42:27.674]   - Field: ‘stdout’
[17:42:27.674]   - Field: ‘earlySignal’
[17:42:27.674]   - Field: ‘lazy’
[17:42:27.674]   - Field: ‘state’
[17:42:27.675] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:27.675] - Launch lazy future ...
[17:42:27.675] Packages needed by the future expression (n = 1): ‘stats’
[17:42:27.675] Packages needed by future strategies (n = 0): <none>
[17:42:27.676] {
[17:42:27.676]     {
[17:42:27.676]         {
[17:42:27.676]             ...future.startTime <- base::Sys.time()
[17:42:27.676]             {
[17:42:27.676]                 {
[17:42:27.676]                   {
[17:42:27.676]                     {
[17:42:27.676]                       {
[17:42:27.676]                         base::local({
[17:42:27.676]                           has_future <- base::requireNamespace("future", 
[17:42:27.676]                             quietly = TRUE)
[17:42:27.676]                           if (has_future) {
[17:42:27.676]                             ns <- base::getNamespace("future")
[17:42:27.676]                             version <- ns[[".package"]][["version"]]
[17:42:27.676]                             if (is.null(version)) 
[17:42:27.676]                               version <- utils::packageVersion("future")
[17:42:27.676]                           }
[17:42:27.676]                           else {
[17:42:27.676]                             version <- NULL
[17:42:27.676]                           }
[17:42:27.676]                           if (!has_future || version < "1.8.0") {
[17:42:27.676]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:27.676]                               "", base::R.version$version.string), 
[17:42:27.676]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:27.676]                                 base::R.version$platform, 8 * 
[17:42:27.676]                                   base::.Machine$sizeof.pointer), 
[17:42:27.676]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:27.676]                                 "release", "version")], collapse = " "), 
[17:42:27.676]                               hostname = base::Sys.info()[["nodename"]])
[17:42:27.676]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:27.676]                               info)
[17:42:27.676]                             info <- base::paste(info, collapse = "; ")
[17:42:27.676]                             if (!has_future) {
[17:42:27.676]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:27.676]                                 info)
[17:42:27.676]                             }
[17:42:27.676]                             else {
[17:42:27.676]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:27.676]                                 info, version)
[17:42:27.676]                             }
[17:42:27.676]                             base::stop(msg)
[17:42:27.676]                           }
[17:42:27.676]                         })
[17:42:27.676]                       }
[17:42:27.676]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:27.676]                       base::options(mc.cores = 1L)
[17:42:27.676]                     }
[17:42:27.676]                     base::local({
[17:42:27.676]                       for (pkg in "stats") {
[17:42:27.676]                         base::loadNamespace(pkg)
[17:42:27.676]                         base::library(pkg, character.only = TRUE)
[17:42:27.676]                       }
[17:42:27.676]                     })
[17:42:27.676]                   }
[17:42:27.676]                   options(future.plan = NULL)
[17:42:27.676]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:27.676]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:27.676]                 }
[17:42:27.676]                 ...future.workdir <- getwd()
[17:42:27.676]             }
[17:42:27.676]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:27.676]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:27.676]         }
[17:42:27.676]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:27.676]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:27.676]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:27.676]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:27.676]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:27.676]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:27.676]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:27.676]             base::names(...future.oldOptions))
[17:42:27.676]     }
[17:42:27.676]     if (FALSE) {
[17:42:27.676]     }
[17:42:27.676]     else {
[17:42:27.676]         if (TRUE) {
[17:42:27.676]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:27.676]                 open = "w")
[17:42:27.676]         }
[17:42:27.676]         else {
[17:42:27.676]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:27.676]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:27.676]         }
[17:42:27.676]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:27.676]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:27.676]             base::sink(type = "output", split = FALSE)
[17:42:27.676]             base::close(...future.stdout)
[17:42:27.676]         }, add = TRUE)
[17:42:27.676]     }
[17:42:27.676]     ...future.frame <- base::sys.nframe()
[17:42:27.676]     ...future.conditions <- base::list()
[17:42:27.676]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:27.676]     if (FALSE) {
[17:42:27.676]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:27.676]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:27.676]     }
[17:42:27.676]     ...future.result <- base::tryCatch({
[17:42:27.676]         base::withCallingHandlers({
[17:42:27.676]             ...future.value <- base::withVisible(base::local({
[17:42:27.676]                 ...future.makeSendCondition <- local({
[17:42:27.676]                   sendCondition <- NULL
[17:42:27.676]                   function(frame = 1L) {
[17:42:27.676]                     if (is.function(sendCondition)) 
[17:42:27.676]                       return(sendCondition)
[17:42:27.676]                     ns <- getNamespace("parallel")
[17:42:27.676]                     if (exists("sendData", mode = "function", 
[17:42:27.676]                       envir = ns)) {
[17:42:27.676]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:27.676]                         envir = ns)
[17:42:27.676]                       envir <- sys.frame(frame)
[17:42:27.676]                       master <- NULL
[17:42:27.676]                       while (!identical(envir, .GlobalEnv) && 
[17:42:27.676]                         !identical(envir, emptyenv())) {
[17:42:27.676]                         if (exists("master", mode = "list", envir = envir, 
[17:42:27.676]                           inherits = FALSE)) {
[17:42:27.676]                           master <- get("master", mode = "list", 
[17:42:27.676]                             envir = envir, inherits = FALSE)
[17:42:27.676]                           if (inherits(master, c("SOCKnode", 
[17:42:27.676]                             "SOCK0node"))) {
[17:42:27.676]                             sendCondition <<- function(cond) {
[17:42:27.676]                               data <- list(type = "VALUE", value = cond, 
[17:42:27.676]                                 success = TRUE)
[17:42:27.676]                               parallel_sendData(master, data)
[17:42:27.676]                             }
[17:42:27.676]                             return(sendCondition)
[17:42:27.676]                           }
[17:42:27.676]                         }
[17:42:27.676]                         frame <- frame + 1L
[17:42:27.676]                         envir <- sys.frame(frame)
[17:42:27.676]                       }
[17:42:27.676]                     }
[17:42:27.676]                     sendCondition <<- function(cond) NULL
[17:42:27.676]                   }
[17:42:27.676]                 })
[17:42:27.676]                 withCallingHandlers({
[17:42:27.676]                   {
[17:42:27.676]                     lm(weight ~ group - 1)
[17:42:27.676]                   }
[17:42:27.676]                 }, immediateCondition = function(cond) {
[17:42:27.676]                   sendCondition <- ...future.makeSendCondition()
[17:42:27.676]                   sendCondition(cond)
[17:42:27.676]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:27.676]                   {
[17:42:27.676]                     inherits <- base::inherits
[17:42:27.676]                     invokeRestart <- base::invokeRestart
[17:42:27.676]                     is.null <- base::is.null
[17:42:27.676]                     muffled <- FALSE
[17:42:27.676]                     if (inherits(cond, "message")) {
[17:42:27.676]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:27.676]                       if (muffled) 
[17:42:27.676]                         invokeRestart("muffleMessage")
[17:42:27.676]                     }
[17:42:27.676]                     else if (inherits(cond, "warning")) {
[17:42:27.676]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:27.676]                       if (muffled) 
[17:42:27.676]                         invokeRestart("muffleWarning")
[17:42:27.676]                     }
[17:42:27.676]                     else if (inherits(cond, "condition")) {
[17:42:27.676]                       if (!is.null(pattern)) {
[17:42:27.676]                         computeRestarts <- base::computeRestarts
[17:42:27.676]                         grepl <- base::grepl
[17:42:27.676]                         restarts <- computeRestarts(cond)
[17:42:27.676]                         for (restart in restarts) {
[17:42:27.676]                           name <- restart$name
[17:42:27.676]                           if (is.null(name)) 
[17:42:27.676]                             next
[17:42:27.676]                           if (!grepl(pattern, name)) 
[17:42:27.676]                             next
[17:42:27.676]                           invokeRestart(restart)
[17:42:27.676]                           muffled <- TRUE
[17:42:27.676]                           break
[17:42:27.676]                         }
[17:42:27.676]                       }
[17:42:27.676]                     }
[17:42:27.676]                     invisible(muffled)
[17:42:27.676]                   }
[17:42:27.676]                   muffleCondition(cond)
[17:42:27.676]                 })
[17:42:27.676]             }))
[17:42:27.676]             future::FutureResult(value = ...future.value$value, 
[17:42:27.676]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:27.676]                   ...future.rng), globalenv = if (FALSE) 
[17:42:27.676]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:27.676]                     ...future.globalenv.names))
[17:42:27.676]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:27.676]         }, condition = base::local({
[17:42:27.676]             c <- base::c
[17:42:27.676]             inherits <- base::inherits
[17:42:27.676]             invokeRestart <- base::invokeRestart
[17:42:27.676]             length <- base::length
[17:42:27.676]             list <- base::list
[17:42:27.676]             seq.int <- base::seq.int
[17:42:27.676]             signalCondition <- base::signalCondition
[17:42:27.676]             sys.calls <- base::sys.calls
[17:42:27.676]             `[[` <- base::`[[`
[17:42:27.676]             `+` <- base::`+`
[17:42:27.676]             `<<-` <- base::`<<-`
[17:42:27.676]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:27.676]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:27.676]                   3L)]
[17:42:27.676]             }
[17:42:27.676]             function(cond) {
[17:42:27.676]                 is_error <- inherits(cond, "error")
[17:42:27.676]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:27.676]                   NULL)
[17:42:27.676]                 if (is_error) {
[17:42:27.676]                   sessionInformation <- function() {
[17:42:27.676]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:27.676]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:27.676]                       search = base::search(), system = base::Sys.info())
[17:42:27.676]                   }
[17:42:27.676]                   ...future.conditions[[length(...future.conditions) + 
[17:42:27.676]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:27.676]                     cond$call), session = sessionInformation(), 
[17:42:27.676]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:27.676]                   signalCondition(cond)
[17:42:27.676]                 }
[17:42:27.676]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:27.676]                 "immediateCondition"))) {
[17:42:27.676]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:27.676]                   ...future.conditions[[length(...future.conditions) + 
[17:42:27.676]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:27.676]                   if (TRUE && !signal) {
[17:42:27.676]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:27.676]                     {
[17:42:27.676]                       inherits <- base::inherits
[17:42:27.676]                       invokeRestart <- base::invokeRestart
[17:42:27.676]                       is.null <- base::is.null
[17:42:27.676]                       muffled <- FALSE
[17:42:27.676]                       if (inherits(cond, "message")) {
[17:42:27.676]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:27.676]                         if (muffled) 
[17:42:27.676]                           invokeRestart("muffleMessage")
[17:42:27.676]                       }
[17:42:27.676]                       else if (inherits(cond, "warning")) {
[17:42:27.676]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:27.676]                         if (muffled) 
[17:42:27.676]                           invokeRestart("muffleWarning")
[17:42:27.676]                       }
[17:42:27.676]                       else if (inherits(cond, "condition")) {
[17:42:27.676]                         if (!is.null(pattern)) {
[17:42:27.676]                           computeRestarts <- base::computeRestarts
[17:42:27.676]                           grepl <- base::grepl
[17:42:27.676]                           restarts <- computeRestarts(cond)
[17:42:27.676]                           for (restart in restarts) {
[17:42:27.676]                             name <- restart$name
[17:42:27.676]                             if (is.null(name)) 
[17:42:27.676]                               next
[17:42:27.676]                             if (!grepl(pattern, name)) 
[17:42:27.676]                               next
[17:42:27.676]                             invokeRestart(restart)
[17:42:27.676]                             muffled <- TRUE
[17:42:27.676]                             break
[17:42:27.676]                           }
[17:42:27.676]                         }
[17:42:27.676]                       }
[17:42:27.676]                       invisible(muffled)
[17:42:27.676]                     }
[17:42:27.676]                     muffleCondition(cond, pattern = "^muffle")
[17:42:27.676]                   }
[17:42:27.676]                 }
[17:42:27.676]                 else {
[17:42:27.676]                   if (TRUE) {
[17:42:27.676]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:27.676]                     {
[17:42:27.676]                       inherits <- base::inherits
[17:42:27.676]                       invokeRestart <- base::invokeRestart
[17:42:27.676]                       is.null <- base::is.null
[17:42:27.676]                       muffled <- FALSE
[17:42:27.676]                       if (inherits(cond, "message")) {
[17:42:27.676]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:27.676]                         if (muffled) 
[17:42:27.676]                           invokeRestart("muffleMessage")
[17:42:27.676]                       }
[17:42:27.676]                       else if (inherits(cond, "warning")) {
[17:42:27.676]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:27.676]                         if (muffled) 
[17:42:27.676]                           invokeRestart("muffleWarning")
[17:42:27.676]                       }
[17:42:27.676]                       else if (inherits(cond, "condition")) {
[17:42:27.676]                         if (!is.null(pattern)) {
[17:42:27.676]                           computeRestarts <- base::computeRestarts
[17:42:27.676]                           grepl <- base::grepl
[17:42:27.676]                           restarts <- computeRestarts(cond)
[17:42:27.676]                           for (restart in restarts) {
[17:42:27.676]                             name <- restart$name
[17:42:27.676]                             if (is.null(name)) 
[17:42:27.676]                               next
[17:42:27.676]                             if (!grepl(pattern, name)) 
[17:42:27.676]                               next
[17:42:27.676]                             invokeRestart(restart)
[17:42:27.676]                             muffled <- TRUE
[17:42:27.676]                             break
[17:42:27.676]                           }
[17:42:27.676]                         }
[17:42:27.676]                       }
[17:42:27.676]                       invisible(muffled)
[17:42:27.676]                     }
[17:42:27.676]                     muffleCondition(cond, pattern = "^muffle")
[17:42:27.676]                   }
[17:42:27.676]                 }
[17:42:27.676]             }
[17:42:27.676]         }))
[17:42:27.676]     }, error = function(ex) {
[17:42:27.676]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:27.676]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:27.676]                 ...future.rng), started = ...future.startTime, 
[17:42:27.676]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:27.676]             version = "1.8"), class = "FutureResult")
[17:42:27.676]     }, finally = {
[17:42:27.676]         if (!identical(...future.workdir, getwd())) 
[17:42:27.676]             setwd(...future.workdir)
[17:42:27.676]         {
[17:42:27.676]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:27.676]                 ...future.oldOptions$nwarnings <- NULL
[17:42:27.676]             }
[17:42:27.676]             base::options(...future.oldOptions)
[17:42:27.676]             if (.Platform$OS.type == "windows") {
[17:42:27.676]                 old_names <- names(...future.oldEnvVars)
[17:42:27.676]                 envs <- base::Sys.getenv()
[17:42:27.676]                 names <- names(envs)
[17:42:27.676]                 common <- intersect(names, old_names)
[17:42:27.676]                 added <- setdiff(names, old_names)
[17:42:27.676]                 removed <- setdiff(old_names, names)
[17:42:27.676]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:27.676]                   envs[common]]
[17:42:27.676]                 NAMES <- toupper(changed)
[17:42:27.676]                 args <- list()
[17:42:27.676]                 for (kk in seq_along(NAMES)) {
[17:42:27.676]                   name <- changed[[kk]]
[17:42:27.676]                   NAME <- NAMES[[kk]]
[17:42:27.676]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:27.676]                     next
[17:42:27.676]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:27.676]                 }
[17:42:27.676]                 NAMES <- toupper(added)
[17:42:27.676]                 for (kk in seq_along(NAMES)) {
[17:42:27.676]                   name <- added[[kk]]
[17:42:27.676]                   NAME <- NAMES[[kk]]
[17:42:27.676]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:27.676]                     next
[17:42:27.676]                   args[[name]] <- ""
[17:42:27.676]                 }
[17:42:27.676]                 NAMES <- toupper(removed)
[17:42:27.676]                 for (kk in seq_along(NAMES)) {
[17:42:27.676]                   name <- removed[[kk]]
[17:42:27.676]                   NAME <- NAMES[[kk]]
[17:42:27.676]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:27.676]                     next
[17:42:27.676]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:27.676]                 }
[17:42:27.676]                 if (length(args) > 0) 
[17:42:27.676]                   base::do.call(base::Sys.setenv, args = args)
[17:42:27.676]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:27.676]             }
[17:42:27.676]             else {
[17:42:27.676]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:27.676]             }
[17:42:27.676]             {
[17:42:27.676]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:27.676]                   0L) {
[17:42:27.676]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:27.676]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:27.676]                   base::options(opts)
[17:42:27.676]                 }
[17:42:27.676]                 {
[17:42:27.676]                   {
[17:42:27.676]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:27.676]                     NULL
[17:42:27.676]                   }
[17:42:27.676]                   options(future.plan = NULL)
[17:42:27.676]                   if (is.na(NA_character_)) 
[17:42:27.676]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:27.676]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:27.676]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:27.676]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:27.676]                     envir = parent.frame()) 
[17:42:27.676]                   {
[17:42:27.676]                     if (is.function(workers)) 
[17:42:27.676]                       workers <- workers()
[17:42:27.676]                     workers <- structure(as.integer(workers), 
[17:42:27.676]                       class = class(workers))
[17:42:27.676]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:27.676]                       workers >= 1)
[17:42:27.676]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:27.676]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:27.676]                     }
[17:42:27.676]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:27.676]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:27.676]                       envir = envir)
[17:42:27.676]                     if (!future$lazy) 
[17:42:27.676]                       future <- run(future)
[17:42:27.676]                     invisible(future)
[17:42:27.676]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:27.676]                 }
[17:42:27.676]             }
[17:42:27.676]         }
[17:42:27.676]     })
[17:42:27.676]     if (TRUE) {
[17:42:27.676]         base::sink(type = "output", split = FALSE)
[17:42:27.676]         if (TRUE) {
[17:42:27.676]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:27.676]         }
[17:42:27.676]         else {
[17:42:27.676]             ...future.result["stdout"] <- base::list(NULL)
[17:42:27.676]         }
[17:42:27.676]         base::close(...future.stdout)
[17:42:27.676]         ...future.stdout <- NULL
[17:42:27.676]     }
[17:42:27.676]     ...future.result$conditions <- ...future.conditions
[17:42:27.676]     ...future.result$finished <- base::Sys.time()
[17:42:27.676]     ...future.result
[17:42:27.676] }
[17:42:27.679] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[17:42:27.679] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[17:42:27.679] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[17:42:27.679] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[17:42:27.680] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[17:42:27.680] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[17:42:27.680] MultisessionFuture started
[17:42:27.680] - Launch lazy future ... done
[17:42:27.681] run() for ‘MultisessionFuture’ ... done
[17:42:27.681] result() for ClusterFuture ...
[17:42:27.681] receiveMessageFromWorker() for ClusterFuture ...
[17:42:27.681] - Validating connection of MultisessionFuture
[17:42:27.730] - received message: FutureResult
[17:42:27.730] - Received FutureResult
[17:42:27.730] - Erased future from FutureRegistry
[17:42:27.730] result() for ClusterFuture ...
[17:42:27.730] - result already collected: FutureResult
[17:42:27.730] result() for ClusterFuture ... done
[17:42:27.730] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:27.730] result() for ClusterFuture ... done
[17:42:27.731] result() for ClusterFuture ...
[17:42:27.731] - result already collected: FutureResult
[17:42:27.731] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[17:42:27.733] getGlobalsAndPackages() ...
[17:42:27.733] Searching for globals...
[17:42:27.734] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[17:42:27.734] Searching for globals ... DONE
[17:42:27.734] Resolving globals: FALSE
[17:42:27.734] The total size of the 1 globals is 96 bytes (96 bytes)
[17:42:27.735] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[17:42:27.735] - globals: [1] ‘x’
[17:42:27.735] - packages: [1] ‘stats’
[17:42:27.735] getGlobalsAndPackages() ... DONE
[17:42:27.736] run() for ‘Future’ ...
[17:42:27.736] - state: ‘created’
[17:42:27.736] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:27.750] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:27.750] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:27.751]   - Field: ‘node’
[17:42:27.751]   - Field: ‘label’
[17:42:27.751]   - Field: ‘local’
[17:42:27.751]   - Field: ‘owner’
[17:42:27.751]   - Field: ‘envir’
[17:42:27.751]   - Field: ‘workers’
[17:42:27.751]   - Field: ‘packages’
[17:42:27.751]   - Field: ‘gc’
[17:42:27.751]   - Field: ‘conditions’
[17:42:27.751]   - Field: ‘persistent’
[17:42:27.752]   - Field: ‘expr’
[17:42:27.752]   - Field: ‘uuid’
[17:42:27.752]   - Field: ‘seed’
[17:42:27.752]   - Field: ‘version’
[17:42:27.752]   - Field: ‘result’
[17:42:27.752]   - Field: ‘asynchronous’
[17:42:27.752]   - Field: ‘calls’
[17:42:27.752]   - Field: ‘globals’
[17:42:27.752]   - Field: ‘stdout’
[17:42:27.752]   - Field: ‘earlySignal’
[17:42:27.752]   - Field: ‘lazy’
[17:42:27.753]   - Field: ‘state’
[17:42:27.753] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:27.753] - Launch lazy future ...
[17:42:27.753] Packages needed by the future expression (n = 1): ‘stats’
[17:42:27.753] Packages needed by future strategies (n = 0): <none>
[17:42:27.754] {
[17:42:27.754]     {
[17:42:27.754]         {
[17:42:27.754]             ...future.startTime <- base::Sys.time()
[17:42:27.754]             {
[17:42:27.754]                 {
[17:42:27.754]                   {
[17:42:27.754]                     {
[17:42:27.754]                       {
[17:42:27.754]                         base::local({
[17:42:27.754]                           has_future <- base::requireNamespace("future", 
[17:42:27.754]                             quietly = TRUE)
[17:42:27.754]                           if (has_future) {
[17:42:27.754]                             ns <- base::getNamespace("future")
[17:42:27.754]                             version <- ns[[".package"]][["version"]]
[17:42:27.754]                             if (is.null(version)) 
[17:42:27.754]                               version <- utils::packageVersion("future")
[17:42:27.754]                           }
[17:42:27.754]                           else {
[17:42:27.754]                             version <- NULL
[17:42:27.754]                           }
[17:42:27.754]                           if (!has_future || version < "1.8.0") {
[17:42:27.754]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:27.754]                               "", base::R.version$version.string), 
[17:42:27.754]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:27.754]                                 base::R.version$platform, 8 * 
[17:42:27.754]                                   base::.Machine$sizeof.pointer), 
[17:42:27.754]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:27.754]                                 "release", "version")], collapse = " "), 
[17:42:27.754]                               hostname = base::Sys.info()[["nodename"]])
[17:42:27.754]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:27.754]                               info)
[17:42:27.754]                             info <- base::paste(info, collapse = "; ")
[17:42:27.754]                             if (!has_future) {
[17:42:27.754]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:27.754]                                 info)
[17:42:27.754]                             }
[17:42:27.754]                             else {
[17:42:27.754]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:27.754]                                 info, version)
[17:42:27.754]                             }
[17:42:27.754]                             base::stop(msg)
[17:42:27.754]                           }
[17:42:27.754]                         })
[17:42:27.754]                       }
[17:42:27.754]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:27.754]                       base::options(mc.cores = 1L)
[17:42:27.754]                     }
[17:42:27.754]                     base::local({
[17:42:27.754]                       for (pkg in "stats") {
[17:42:27.754]                         base::loadNamespace(pkg)
[17:42:27.754]                         base::library(pkg, character.only = TRUE)
[17:42:27.754]                       }
[17:42:27.754]                     })
[17:42:27.754]                   }
[17:42:27.754]                   options(future.plan = NULL)
[17:42:27.754]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:27.754]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:27.754]                 }
[17:42:27.754]                 ...future.workdir <- getwd()
[17:42:27.754]             }
[17:42:27.754]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:27.754]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:27.754]         }
[17:42:27.754]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:27.754]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:27.754]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:27.754]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:27.754]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:27.754]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:27.754]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:27.754]             base::names(...future.oldOptions))
[17:42:27.754]     }
[17:42:27.754]     if (FALSE) {
[17:42:27.754]     }
[17:42:27.754]     else {
[17:42:27.754]         if (TRUE) {
[17:42:27.754]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:27.754]                 open = "w")
[17:42:27.754]         }
[17:42:27.754]         else {
[17:42:27.754]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:27.754]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:27.754]         }
[17:42:27.754]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:27.754]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:27.754]             base::sink(type = "output", split = FALSE)
[17:42:27.754]             base::close(...future.stdout)
[17:42:27.754]         }, add = TRUE)
[17:42:27.754]     }
[17:42:27.754]     ...future.frame <- base::sys.nframe()
[17:42:27.754]     ...future.conditions <- base::list()
[17:42:27.754]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:27.754]     if (FALSE) {
[17:42:27.754]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:27.754]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:27.754]     }
[17:42:27.754]     ...future.result <- base::tryCatch({
[17:42:27.754]         base::withCallingHandlers({
[17:42:27.754]             ...future.value <- base::withVisible(base::local({
[17:42:27.754]                 ...future.makeSendCondition <- local({
[17:42:27.754]                   sendCondition <- NULL
[17:42:27.754]                   function(frame = 1L) {
[17:42:27.754]                     if (is.function(sendCondition)) 
[17:42:27.754]                       return(sendCondition)
[17:42:27.754]                     ns <- getNamespace("parallel")
[17:42:27.754]                     if (exists("sendData", mode = "function", 
[17:42:27.754]                       envir = ns)) {
[17:42:27.754]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:27.754]                         envir = ns)
[17:42:27.754]                       envir <- sys.frame(frame)
[17:42:27.754]                       master <- NULL
[17:42:27.754]                       while (!identical(envir, .GlobalEnv) && 
[17:42:27.754]                         !identical(envir, emptyenv())) {
[17:42:27.754]                         if (exists("master", mode = "list", envir = envir, 
[17:42:27.754]                           inherits = FALSE)) {
[17:42:27.754]                           master <- get("master", mode = "list", 
[17:42:27.754]                             envir = envir, inherits = FALSE)
[17:42:27.754]                           if (inherits(master, c("SOCKnode", 
[17:42:27.754]                             "SOCK0node"))) {
[17:42:27.754]                             sendCondition <<- function(cond) {
[17:42:27.754]                               data <- list(type = "VALUE", value = cond, 
[17:42:27.754]                                 success = TRUE)
[17:42:27.754]                               parallel_sendData(master, data)
[17:42:27.754]                             }
[17:42:27.754]                             return(sendCondition)
[17:42:27.754]                           }
[17:42:27.754]                         }
[17:42:27.754]                         frame <- frame + 1L
[17:42:27.754]                         envir <- sys.frame(frame)
[17:42:27.754]                       }
[17:42:27.754]                     }
[17:42:27.754]                     sendCondition <<- function(cond) NULL
[17:42:27.754]                   }
[17:42:27.754]                 })
[17:42:27.754]                 withCallingHandlers({
[17:42:27.754]                   {
[17:42:27.754]                     xtabs(~x)
[17:42:27.754]                   }
[17:42:27.754]                 }, immediateCondition = function(cond) {
[17:42:27.754]                   sendCondition <- ...future.makeSendCondition()
[17:42:27.754]                   sendCondition(cond)
[17:42:27.754]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:27.754]                   {
[17:42:27.754]                     inherits <- base::inherits
[17:42:27.754]                     invokeRestart <- base::invokeRestart
[17:42:27.754]                     is.null <- base::is.null
[17:42:27.754]                     muffled <- FALSE
[17:42:27.754]                     if (inherits(cond, "message")) {
[17:42:27.754]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:27.754]                       if (muffled) 
[17:42:27.754]                         invokeRestart("muffleMessage")
[17:42:27.754]                     }
[17:42:27.754]                     else if (inherits(cond, "warning")) {
[17:42:27.754]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:27.754]                       if (muffled) 
[17:42:27.754]                         invokeRestart("muffleWarning")
[17:42:27.754]                     }
[17:42:27.754]                     else if (inherits(cond, "condition")) {
[17:42:27.754]                       if (!is.null(pattern)) {
[17:42:27.754]                         computeRestarts <- base::computeRestarts
[17:42:27.754]                         grepl <- base::grepl
[17:42:27.754]                         restarts <- computeRestarts(cond)
[17:42:27.754]                         for (restart in restarts) {
[17:42:27.754]                           name <- restart$name
[17:42:27.754]                           if (is.null(name)) 
[17:42:27.754]                             next
[17:42:27.754]                           if (!grepl(pattern, name)) 
[17:42:27.754]                             next
[17:42:27.754]                           invokeRestart(restart)
[17:42:27.754]                           muffled <- TRUE
[17:42:27.754]                           break
[17:42:27.754]                         }
[17:42:27.754]                       }
[17:42:27.754]                     }
[17:42:27.754]                     invisible(muffled)
[17:42:27.754]                   }
[17:42:27.754]                   muffleCondition(cond)
[17:42:27.754]                 })
[17:42:27.754]             }))
[17:42:27.754]             future::FutureResult(value = ...future.value$value, 
[17:42:27.754]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:27.754]                   ...future.rng), globalenv = if (FALSE) 
[17:42:27.754]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:27.754]                     ...future.globalenv.names))
[17:42:27.754]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:27.754]         }, condition = base::local({
[17:42:27.754]             c <- base::c
[17:42:27.754]             inherits <- base::inherits
[17:42:27.754]             invokeRestart <- base::invokeRestart
[17:42:27.754]             length <- base::length
[17:42:27.754]             list <- base::list
[17:42:27.754]             seq.int <- base::seq.int
[17:42:27.754]             signalCondition <- base::signalCondition
[17:42:27.754]             sys.calls <- base::sys.calls
[17:42:27.754]             `[[` <- base::`[[`
[17:42:27.754]             `+` <- base::`+`
[17:42:27.754]             `<<-` <- base::`<<-`
[17:42:27.754]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:27.754]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:27.754]                   3L)]
[17:42:27.754]             }
[17:42:27.754]             function(cond) {
[17:42:27.754]                 is_error <- inherits(cond, "error")
[17:42:27.754]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:27.754]                   NULL)
[17:42:27.754]                 if (is_error) {
[17:42:27.754]                   sessionInformation <- function() {
[17:42:27.754]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:27.754]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:27.754]                       search = base::search(), system = base::Sys.info())
[17:42:27.754]                   }
[17:42:27.754]                   ...future.conditions[[length(...future.conditions) + 
[17:42:27.754]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:27.754]                     cond$call), session = sessionInformation(), 
[17:42:27.754]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:27.754]                   signalCondition(cond)
[17:42:27.754]                 }
[17:42:27.754]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:27.754]                 "immediateCondition"))) {
[17:42:27.754]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:27.754]                   ...future.conditions[[length(...future.conditions) + 
[17:42:27.754]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:27.754]                   if (TRUE && !signal) {
[17:42:27.754]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:27.754]                     {
[17:42:27.754]                       inherits <- base::inherits
[17:42:27.754]                       invokeRestart <- base::invokeRestart
[17:42:27.754]                       is.null <- base::is.null
[17:42:27.754]                       muffled <- FALSE
[17:42:27.754]                       if (inherits(cond, "message")) {
[17:42:27.754]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:27.754]                         if (muffled) 
[17:42:27.754]                           invokeRestart("muffleMessage")
[17:42:27.754]                       }
[17:42:27.754]                       else if (inherits(cond, "warning")) {
[17:42:27.754]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:27.754]                         if (muffled) 
[17:42:27.754]                           invokeRestart("muffleWarning")
[17:42:27.754]                       }
[17:42:27.754]                       else if (inherits(cond, "condition")) {
[17:42:27.754]                         if (!is.null(pattern)) {
[17:42:27.754]                           computeRestarts <- base::computeRestarts
[17:42:27.754]                           grepl <- base::grepl
[17:42:27.754]                           restarts <- computeRestarts(cond)
[17:42:27.754]                           for (restart in restarts) {
[17:42:27.754]                             name <- restart$name
[17:42:27.754]                             if (is.null(name)) 
[17:42:27.754]                               next
[17:42:27.754]                             if (!grepl(pattern, name)) 
[17:42:27.754]                               next
[17:42:27.754]                             invokeRestart(restart)
[17:42:27.754]                             muffled <- TRUE
[17:42:27.754]                             break
[17:42:27.754]                           }
[17:42:27.754]                         }
[17:42:27.754]                       }
[17:42:27.754]                       invisible(muffled)
[17:42:27.754]                     }
[17:42:27.754]                     muffleCondition(cond, pattern = "^muffle")
[17:42:27.754]                   }
[17:42:27.754]                 }
[17:42:27.754]                 else {
[17:42:27.754]                   if (TRUE) {
[17:42:27.754]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:27.754]                     {
[17:42:27.754]                       inherits <- base::inherits
[17:42:27.754]                       invokeRestart <- base::invokeRestart
[17:42:27.754]                       is.null <- base::is.null
[17:42:27.754]                       muffled <- FALSE
[17:42:27.754]                       if (inherits(cond, "message")) {
[17:42:27.754]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:27.754]                         if (muffled) 
[17:42:27.754]                           invokeRestart("muffleMessage")
[17:42:27.754]                       }
[17:42:27.754]                       else if (inherits(cond, "warning")) {
[17:42:27.754]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:27.754]                         if (muffled) 
[17:42:27.754]                           invokeRestart("muffleWarning")
[17:42:27.754]                       }
[17:42:27.754]                       else if (inherits(cond, "condition")) {
[17:42:27.754]                         if (!is.null(pattern)) {
[17:42:27.754]                           computeRestarts <- base::computeRestarts
[17:42:27.754]                           grepl <- base::grepl
[17:42:27.754]                           restarts <- computeRestarts(cond)
[17:42:27.754]                           for (restart in restarts) {
[17:42:27.754]                             name <- restart$name
[17:42:27.754]                             if (is.null(name)) 
[17:42:27.754]                               next
[17:42:27.754]                             if (!grepl(pattern, name)) 
[17:42:27.754]                               next
[17:42:27.754]                             invokeRestart(restart)
[17:42:27.754]                             muffled <- TRUE
[17:42:27.754]                             break
[17:42:27.754]                           }
[17:42:27.754]                         }
[17:42:27.754]                       }
[17:42:27.754]                       invisible(muffled)
[17:42:27.754]                     }
[17:42:27.754]                     muffleCondition(cond, pattern = "^muffle")
[17:42:27.754]                   }
[17:42:27.754]                 }
[17:42:27.754]             }
[17:42:27.754]         }))
[17:42:27.754]     }, error = function(ex) {
[17:42:27.754]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:27.754]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:27.754]                 ...future.rng), started = ...future.startTime, 
[17:42:27.754]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:27.754]             version = "1.8"), class = "FutureResult")
[17:42:27.754]     }, finally = {
[17:42:27.754]         if (!identical(...future.workdir, getwd())) 
[17:42:27.754]             setwd(...future.workdir)
[17:42:27.754]         {
[17:42:27.754]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:27.754]                 ...future.oldOptions$nwarnings <- NULL
[17:42:27.754]             }
[17:42:27.754]             base::options(...future.oldOptions)
[17:42:27.754]             if (.Platform$OS.type == "windows") {
[17:42:27.754]                 old_names <- names(...future.oldEnvVars)
[17:42:27.754]                 envs <- base::Sys.getenv()
[17:42:27.754]                 names <- names(envs)
[17:42:27.754]                 common <- intersect(names, old_names)
[17:42:27.754]                 added <- setdiff(names, old_names)
[17:42:27.754]                 removed <- setdiff(old_names, names)
[17:42:27.754]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:27.754]                   envs[common]]
[17:42:27.754]                 NAMES <- toupper(changed)
[17:42:27.754]                 args <- list()
[17:42:27.754]                 for (kk in seq_along(NAMES)) {
[17:42:27.754]                   name <- changed[[kk]]
[17:42:27.754]                   NAME <- NAMES[[kk]]
[17:42:27.754]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:27.754]                     next
[17:42:27.754]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:27.754]                 }
[17:42:27.754]                 NAMES <- toupper(added)
[17:42:27.754]                 for (kk in seq_along(NAMES)) {
[17:42:27.754]                   name <- added[[kk]]
[17:42:27.754]                   NAME <- NAMES[[kk]]
[17:42:27.754]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:27.754]                     next
[17:42:27.754]                   args[[name]] <- ""
[17:42:27.754]                 }
[17:42:27.754]                 NAMES <- toupper(removed)
[17:42:27.754]                 for (kk in seq_along(NAMES)) {
[17:42:27.754]                   name <- removed[[kk]]
[17:42:27.754]                   NAME <- NAMES[[kk]]
[17:42:27.754]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:27.754]                     next
[17:42:27.754]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:27.754]                 }
[17:42:27.754]                 if (length(args) > 0) 
[17:42:27.754]                   base::do.call(base::Sys.setenv, args = args)
[17:42:27.754]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:27.754]             }
[17:42:27.754]             else {
[17:42:27.754]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:27.754]             }
[17:42:27.754]             {
[17:42:27.754]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:27.754]                   0L) {
[17:42:27.754]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:27.754]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:27.754]                   base::options(opts)
[17:42:27.754]                 }
[17:42:27.754]                 {
[17:42:27.754]                   {
[17:42:27.754]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:27.754]                     NULL
[17:42:27.754]                   }
[17:42:27.754]                   options(future.plan = NULL)
[17:42:27.754]                   if (is.na(NA_character_)) 
[17:42:27.754]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:27.754]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:27.754]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:27.754]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:27.754]                     envir = parent.frame()) 
[17:42:27.754]                   {
[17:42:27.754]                     if (is.function(workers)) 
[17:42:27.754]                       workers <- workers()
[17:42:27.754]                     workers <- structure(as.integer(workers), 
[17:42:27.754]                       class = class(workers))
[17:42:27.754]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:27.754]                       workers >= 1)
[17:42:27.754]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:27.754]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:27.754]                     }
[17:42:27.754]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:27.754]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:27.754]                       envir = envir)
[17:42:27.754]                     if (!future$lazy) 
[17:42:27.754]                       future <- run(future)
[17:42:27.754]                     invisible(future)
[17:42:27.754]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:27.754]                 }
[17:42:27.754]             }
[17:42:27.754]         }
[17:42:27.754]     })
[17:42:27.754]     if (TRUE) {
[17:42:27.754]         base::sink(type = "output", split = FALSE)
[17:42:27.754]         if (TRUE) {
[17:42:27.754]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:27.754]         }
[17:42:27.754]         else {
[17:42:27.754]             ...future.result["stdout"] <- base::list(NULL)
[17:42:27.754]         }
[17:42:27.754]         base::close(...future.stdout)
[17:42:27.754]         ...future.stdout <- NULL
[17:42:27.754]     }
[17:42:27.754]     ...future.result$conditions <- ...future.conditions
[17:42:27.754]     ...future.result$finished <- base::Sys.time()
[17:42:27.754]     ...future.result
[17:42:27.754] }
[17:42:27.757] Exporting 1 global objects (96 bytes) to cluster node #1 ...
[17:42:27.757] Exporting ‘x’ (96 bytes) to cluster node #1 ...
[17:42:27.757] Exporting ‘x’ (96 bytes) to cluster node #1 ... DONE
[17:42:27.757] Exporting 1 global objects (96 bytes) to cluster node #1 ... DONE
[17:42:27.758] MultisessionFuture started
[17:42:27.758] - Launch lazy future ... done
[17:42:27.758] run() for ‘MultisessionFuture’ ... done
[17:42:27.758] result() for ClusterFuture ...
[17:42:27.759] receiveMessageFromWorker() for ClusterFuture ...
[17:42:27.759] - Validating connection of MultisessionFuture
[17:42:27.805] - received message: FutureResult
[17:42:27.806] - Received FutureResult
[17:42:27.806] - Erased future from FutureRegistry
[17:42:27.806] result() for ClusterFuture ...
[17:42:27.806] - result already collected: FutureResult
[17:42:27.806] result() for ClusterFuture ... done
[17:42:27.806] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:27.806] result() for ClusterFuture ... done
[17:42:27.806] result() for ClusterFuture ...
[17:42:27.806] - result already collected: FutureResult
[17:42:27.807] result() for ClusterFuture ... done
x
1 2 
2 3 
[17:42:27.807] getGlobalsAndPackages() ...
[17:42:27.808] Searching for globals...
[17:42:27.809] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[17:42:27.809] Searching for globals ... DONE
[17:42:27.809] Resolving globals: FALSE
[17:42:27.809] The total size of the 1 globals is 96 bytes (96 bytes)
[17:42:27.810] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[17:42:27.810] - globals: [1] ‘x’
[17:42:27.810] - packages: [1] ‘stats’
[17:42:27.810] getGlobalsAndPackages() ... DONE
[17:42:27.810] run() for ‘Future’ ...
[17:42:27.810] - state: ‘created’
[17:42:27.811] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:27.825] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:27.825] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:27.825]   - Field: ‘node’
[17:42:27.825]   - Field: ‘label’
[17:42:27.825]   - Field: ‘local’
[17:42:27.825]   - Field: ‘owner’
[17:42:27.826]   - Field: ‘envir’
[17:42:27.826]   - Field: ‘workers’
[17:42:27.826]   - Field: ‘packages’
[17:42:27.826]   - Field: ‘gc’
[17:42:27.826]   - Field: ‘conditions’
[17:42:27.826]   - Field: ‘persistent’
[17:42:27.826]   - Field: ‘expr’
[17:42:27.826]   - Field: ‘uuid’
[17:42:27.826]   - Field: ‘seed’
[17:42:27.826]   - Field: ‘version’
[17:42:27.826]   - Field: ‘result’
[17:42:27.827]   - Field: ‘asynchronous’
[17:42:27.827]   - Field: ‘calls’
[17:42:27.827]   - Field: ‘globals’
[17:42:27.827]   - Field: ‘stdout’
[17:42:27.827]   - Field: ‘earlySignal’
[17:42:27.827]   - Field: ‘lazy’
[17:42:27.827]   - Field: ‘state’
[17:42:27.827] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:27.827] - Launch lazy future ...
[17:42:27.828] Packages needed by the future expression (n = 1): ‘stats’
[17:42:27.828] Packages needed by future strategies (n = 0): <none>
[17:42:27.828] {
[17:42:27.828]     {
[17:42:27.828]         {
[17:42:27.828]             ...future.startTime <- base::Sys.time()
[17:42:27.828]             {
[17:42:27.828]                 {
[17:42:27.828]                   {
[17:42:27.828]                     {
[17:42:27.828]                       {
[17:42:27.828]                         base::local({
[17:42:27.828]                           has_future <- base::requireNamespace("future", 
[17:42:27.828]                             quietly = TRUE)
[17:42:27.828]                           if (has_future) {
[17:42:27.828]                             ns <- base::getNamespace("future")
[17:42:27.828]                             version <- ns[[".package"]][["version"]]
[17:42:27.828]                             if (is.null(version)) 
[17:42:27.828]                               version <- utils::packageVersion("future")
[17:42:27.828]                           }
[17:42:27.828]                           else {
[17:42:27.828]                             version <- NULL
[17:42:27.828]                           }
[17:42:27.828]                           if (!has_future || version < "1.8.0") {
[17:42:27.828]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:27.828]                               "", base::R.version$version.string), 
[17:42:27.828]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:27.828]                                 base::R.version$platform, 8 * 
[17:42:27.828]                                   base::.Machine$sizeof.pointer), 
[17:42:27.828]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:27.828]                                 "release", "version")], collapse = " "), 
[17:42:27.828]                               hostname = base::Sys.info()[["nodename"]])
[17:42:27.828]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:27.828]                               info)
[17:42:27.828]                             info <- base::paste(info, collapse = "; ")
[17:42:27.828]                             if (!has_future) {
[17:42:27.828]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:27.828]                                 info)
[17:42:27.828]                             }
[17:42:27.828]                             else {
[17:42:27.828]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:27.828]                                 info, version)
[17:42:27.828]                             }
[17:42:27.828]                             base::stop(msg)
[17:42:27.828]                           }
[17:42:27.828]                         })
[17:42:27.828]                       }
[17:42:27.828]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:27.828]                       base::options(mc.cores = 1L)
[17:42:27.828]                     }
[17:42:27.828]                     base::local({
[17:42:27.828]                       for (pkg in "stats") {
[17:42:27.828]                         base::loadNamespace(pkg)
[17:42:27.828]                         base::library(pkg, character.only = TRUE)
[17:42:27.828]                       }
[17:42:27.828]                     })
[17:42:27.828]                   }
[17:42:27.828]                   options(future.plan = NULL)
[17:42:27.828]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:27.828]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:27.828]                 }
[17:42:27.828]                 ...future.workdir <- getwd()
[17:42:27.828]             }
[17:42:27.828]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:27.828]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:27.828]         }
[17:42:27.828]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:27.828]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:27.828]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:27.828]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:27.828]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:27.828]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:27.828]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:27.828]             base::names(...future.oldOptions))
[17:42:27.828]     }
[17:42:27.828]     if (FALSE) {
[17:42:27.828]     }
[17:42:27.828]     else {
[17:42:27.828]         if (TRUE) {
[17:42:27.828]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:27.828]                 open = "w")
[17:42:27.828]         }
[17:42:27.828]         else {
[17:42:27.828]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:27.828]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:27.828]         }
[17:42:27.828]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:27.828]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:27.828]             base::sink(type = "output", split = FALSE)
[17:42:27.828]             base::close(...future.stdout)
[17:42:27.828]         }, add = TRUE)
[17:42:27.828]     }
[17:42:27.828]     ...future.frame <- base::sys.nframe()
[17:42:27.828]     ...future.conditions <- base::list()
[17:42:27.828]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:27.828]     if (FALSE) {
[17:42:27.828]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:27.828]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:27.828]     }
[17:42:27.828]     ...future.result <- base::tryCatch({
[17:42:27.828]         base::withCallingHandlers({
[17:42:27.828]             ...future.value <- base::withVisible(base::local({
[17:42:27.828]                 ...future.makeSendCondition <- local({
[17:42:27.828]                   sendCondition <- NULL
[17:42:27.828]                   function(frame = 1L) {
[17:42:27.828]                     if (is.function(sendCondition)) 
[17:42:27.828]                       return(sendCondition)
[17:42:27.828]                     ns <- getNamespace("parallel")
[17:42:27.828]                     if (exists("sendData", mode = "function", 
[17:42:27.828]                       envir = ns)) {
[17:42:27.828]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:27.828]                         envir = ns)
[17:42:27.828]                       envir <- sys.frame(frame)
[17:42:27.828]                       master <- NULL
[17:42:27.828]                       while (!identical(envir, .GlobalEnv) && 
[17:42:27.828]                         !identical(envir, emptyenv())) {
[17:42:27.828]                         if (exists("master", mode = "list", envir = envir, 
[17:42:27.828]                           inherits = FALSE)) {
[17:42:27.828]                           master <- get("master", mode = "list", 
[17:42:27.828]                             envir = envir, inherits = FALSE)
[17:42:27.828]                           if (inherits(master, c("SOCKnode", 
[17:42:27.828]                             "SOCK0node"))) {
[17:42:27.828]                             sendCondition <<- function(cond) {
[17:42:27.828]                               data <- list(type = "VALUE", value = cond, 
[17:42:27.828]                                 success = TRUE)
[17:42:27.828]                               parallel_sendData(master, data)
[17:42:27.828]                             }
[17:42:27.828]                             return(sendCondition)
[17:42:27.828]                           }
[17:42:27.828]                         }
[17:42:27.828]                         frame <- frame + 1L
[17:42:27.828]                         envir <- sys.frame(frame)
[17:42:27.828]                       }
[17:42:27.828]                     }
[17:42:27.828]                     sendCondition <<- function(cond) NULL
[17:42:27.828]                   }
[17:42:27.828]                 })
[17:42:27.828]                 withCallingHandlers({
[17:42:27.828]                   {
[17:42:27.828]                     xtabs(~x)
[17:42:27.828]                   }
[17:42:27.828]                 }, immediateCondition = function(cond) {
[17:42:27.828]                   sendCondition <- ...future.makeSendCondition()
[17:42:27.828]                   sendCondition(cond)
[17:42:27.828]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:27.828]                   {
[17:42:27.828]                     inherits <- base::inherits
[17:42:27.828]                     invokeRestart <- base::invokeRestart
[17:42:27.828]                     is.null <- base::is.null
[17:42:27.828]                     muffled <- FALSE
[17:42:27.828]                     if (inherits(cond, "message")) {
[17:42:27.828]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:27.828]                       if (muffled) 
[17:42:27.828]                         invokeRestart("muffleMessage")
[17:42:27.828]                     }
[17:42:27.828]                     else if (inherits(cond, "warning")) {
[17:42:27.828]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:27.828]                       if (muffled) 
[17:42:27.828]                         invokeRestart("muffleWarning")
[17:42:27.828]                     }
[17:42:27.828]                     else if (inherits(cond, "condition")) {
[17:42:27.828]                       if (!is.null(pattern)) {
[17:42:27.828]                         computeRestarts <- base::computeRestarts
[17:42:27.828]                         grepl <- base::grepl
[17:42:27.828]                         restarts <- computeRestarts(cond)
[17:42:27.828]                         for (restart in restarts) {
[17:42:27.828]                           name <- restart$name
[17:42:27.828]                           if (is.null(name)) 
[17:42:27.828]                             next
[17:42:27.828]                           if (!grepl(pattern, name)) 
[17:42:27.828]                             next
[17:42:27.828]                           invokeRestart(restart)
[17:42:27.828]                           muffled <- TRUE
[17:42:27.828]                           break
[17:42:27.828]                         }
[17:42:27.828]                       }
[17:42:27.828]                     }
[17:42:27.828]                     invisible(muffled)
[17:42:27.828]                   }
[17:42:27.828]                   muffleCondition(cond)
[17:42:27.828]                 })
[17:42:27.828]             }))
[17:42:27.828]             future::FutureResult(value = ...future.value$value, 
[17:42:27.828]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:27.828]                   ...future.rng), globalenv = if (FALSE) 
[17:42:27.828]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:27.828]                     ...future.globalenv.names))
[17:42:27.828]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:27.828]         }, condition = base::local({
[17:42:27.828]             c <- base::c
[17:42:27.828]             inherits <- base::inherits
[17:42:27.828]             invokeRestart <- base::invokeRestart
[17:42:27.828]             length <- base::length
[17:42:27.828]             list <- base::list
[17:42:27.828]             seq.int <- base::seq.int
[17:42:27.828]             signalCondition <- base::signalCondition
[17:42:27.828]             sys.calls <- base::sys.calls
[17:42:27.828]             `[[` <- base::`[[`
[17:42:27.828]             `+` <- base::`+`
[17:42:27.828]             `<<-` <- base::`<<-`
[17:42:27.828]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:27.828]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:27.828]                   3L)]
[17:42:27.828]             }
[17:42:27.828]             function(cond) {
[17:42:27.828]                 is_error <- inherits(cond, "error")
[17:42:27.828]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:27.828]                   NULL)
[17:42:27.828]                 if (is_error) {
[17:42:27.828]                   sessionInformation <- function() {
[17:42:27.828]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:27.828]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:27.828]                       search = base::search(), system = base::Sys.info())
[17:42:27.828]                   }
[17:42:27.828]                   ...future.conditions[[length(...future.conditions) + 
[17:42:27.828]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:27.828]                     cond$call), session = sessionInformation(), 
[17:42:27.828]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:27.828]                   signalCondition(cond)
[17:42:27.828]                 }
[17:42:27.828]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:27.828]                 "immediateCondition"))) {
[17:42:27.828]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:27.828]                   ...future.conditions[[length(...future.conditions) + 
[17:42:27.828]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:27.828]                   if (TRUE && !signal) {
[17:42:27.828]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:27.828]                     {
[17:42:27.828]                       inherits <- base::inherits
[17:42:27.828]                       invokeRestart <- base::invokeRestart
[17:42:27.828]                       is.null <- base::is.null
[17:42:27.828]                       muffled <- FALSE
[17:42:27.828]                       if (inherits(cond, "message")) {
[17:42:27.828]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:27.828]                         if (muffled) 
[17:42:27.828]                           invokeRestart("muffleMessage")
[17:42:27.828]                       }
[17:42:27.828]                       else if (inherits(cond, "warning")) {
[17:42:27.828]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:27.828]                         if (muffled) 
[17:42:27.828]                           invokeRestart("muffleWarning")
[17:42:27.828]                       }
[17:42:27.828]                       else if (inherits(cond, "condition")) {
[17:42:27.828]                         if (!is.null(pattern)) {
[17:42:27.828]                           computeRestarts <- base::computeRestarts
[17:42:27.828]                           grepl <- base::grepl
[17:42:27.828]                           restarts <- computeRestarts(cond)
[17:42:27.828]                           for (restart in restarts) {
[17:42:27.828]                             name <- restart$name
[17:42:27.828]                             if (is.null(name)) 
[17:42:27.828]                               next
[17:42:27.828]                             if (!grepl(pattern, name)) 
[17:42:27.828]                               next
[17:42:27.828]                             invokeRestart(restart)
[17:42:27.828]                             muffled <- TRUE
[17:42:27.828]                             break
[17:42:27.828]                           }
[17:42:27.828]                         }
[17:42:27.828]                       }
[17:42:27.828]                       invisible(muffled)
[17:42:27.828]                     }
[17:42:27.828]                     muffleCondition(cond, pattern = "^muffle")
[17:42:27.828]                   }
[17:42:27.828]                 }
[17:42:27.828]                 else {
[17:42:27.828]                   if (TRUE) {
[17:42:27.828]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:27.828]                     {
[17:42:27.828]                       inherits <- base::inherits
[17:42:27.828]                       invokeRestart <- base::invokeRestart
[17:42:27.828]                       is.null <- base::is.null
[17:42:27.828]                       muffled <- FALSE
[17:42:27.828]                       if (inherits(cond, "message")) {
[17:42:27.828]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:27.828]                         if (muffled) 
[17:42:27.828]                           invokeRestart("muffleMessage")
[17:42:27.828]                       }
[17:42:27.828]                       else if (inherits(cond, "warning")) {
[17:42:27.828]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:27.828]                         if (muffled) 
[17:42:27.828]                           invokeRestart("muffleWarning")
[17:42:27.828]                       }
[17:42:27.828]                       else if (inherits(cond, "condition")) {
[17:42:27.828]                         if (!is.null(pattern)) {
[17:42:27.828]                           computeRestarts <- base::computeRestarts
[17:42:27.828]                           grepl <- base::grepl
[17:42:27.828]                           restarts <- computeRestarts(cond)
[17:42:27.828]                           for (restart in restarts) {
[17:42:27.828]                             name <- restart$name
[17:42:27.828]                             if (is.null(name)) 
[17:42:27.828]                               next
[17:42:27.828]                             if (!grepl(pattern, name)) 
[17:42:27.828]                               next
[17:42:27.828]                             invokeRestart(restart)
[17:42:27.828]                             muffled <- TRUE
[17:42:27.828]                             break
[17:42:27.828]                           }
[17:42:27.828]                         }
[17:42:27.828]                       }
[17:42:27.828]                       invisible(muffled)
[17:42:27.828]                     }
[17:42:27.828]                     muffleCondition(cond, pattern = "^muffle")
[17:42:27.828]                   }
[17:42:27.828]                 }
[17:42:27.828]             }
[17:42:27.828]         }))
[17:42:27.828]     }, error = function(ex) {
[17:42:27.828]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:27.828]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:27.828]                 ...future.rng), started = ...future.startTime, 
[17:42:27.828]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:27.828]             version = "1.8"), class = "FutureResult")
[17:42:27.828]     }, finally = {
[17:42:27.828]         if (!identical(...future.workdir, getwd())) 
[17:42:27.828]             setwd(...future.workdir)
[17:42:27.828]         {
[17:42:27.828]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:27.828]                 ...future.oldOptions$nwarnings <- NULL
[17:42:27.828]             }
[17:42:27.828]             base::options(...future.oldOptions)
[17:42:27.828]             if (.Platform$OS.type == "windows") {
[17:42:27.828]                 old_names <- names(...future.oldEnvVars)
[17:42:27.828]                 envs <- base::Sys.getenv()
[17:42:27.828]                 names <- names(envs)
[17:42:27.828]                 common <- intersect(names, old_names)
[17:42:27.828]                 added <- setdiff(names, old_names)
[17:42:27.828]                 removed <- setdiff(old_names, names)
[17:42:27.828]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:27.828]                   envs[common]]
[17:42:27.828]                 NAMES <- toupper(changed)
[17:42:27.828]                 args <- list()
[17:42:27.828]                 for (kk in seq_along(NAMES)) {
[17:42:27.828]                   name <- changed[[kk]]
[17:42:27.828]                   NAME <- NAMES[[kk]]
[17:42:27.828]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:27.828]                     next
[17:42:27.828]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:27.828]                 }
[17:42:27.828]                 NAMES <- toupper(added)
[17:42:27.828]                 for (kk in seq_along(NAMES)) {
[17:42:27.828]                   name <- added[[kk]]
[17:42:27.828]                   NAME <- NAMES[[kk]]
[17:42:27.828]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:27.828]                     next
[17:42:27.828]                   args[[name]] <- ""
[17:42:27.828]                 }
[17:42:27.828]                 NAMES <- toupper(removed)
[17:42:27.828]                 for (kk in seq_along(NAMES)) {
[17:42:27.828]                   name <- removed[[kk]]
[17:42:27.828]                   NAME <- NAMES[[kk]]
[17:42:27.828]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:27.828]                     next
[17:42:27.828]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:27.828]                 }
[17:42:27.828]                 if (length(args) > 0) 
[17:42:27.828]                   base::do.call(base::Sys.setenv, args = args)
[17:42:27.828]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:27.828]             }
[17:42:27.828]             else {
[17:42:27.828]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:27.828]             }
[17:42:27.828]             {
[17:42:27.828]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:27.828]                   0L) {
[17:42:27.828]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:27.828]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:27.828]                   base::options(opts)
[17:42:27.828]                 }
[17:42:27.828]                 {
[17:42:27.828]                   {
[17:42:27.828]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:27.828]                     NULL
[17:42:27.828]                   }
[17:42:27.828]                   options(future.plan = NULL)
[17:42:27.828]                   if (is.na(NA_character_)) 
[17:42:27.828]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:27.828]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:27.828]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:27.828]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:27.828]                     envir = parent.frame()) 
[17:42:27.828]                   {
[17:42:27.828]                     if (is.function(workers)) 
[17:42:27.828]                       workers <- workers()
[17:42:27.828]                     workers <- structure(as.integer(workers), 
[17:42:27.828]                       class = class(workers))
[17:42:27.828]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:27.828]                       workers >= 1)
[17:42:27.828]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:27.828]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:27.828]                     }
[17:42:27.828]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:27.828]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:27.828]                       envir = envir)
[17:42:27.828]                     if (!future$lazy) 
[17:42:27.828]                       future <- run(future)
[17:42:27.828]                     invisible(future)
[17:42:27.828]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:27.828]                 }
[17:42:27.828]             }
[17:42:27.828]         }
[17:42:27.828]     })
[17:42:27.828]     if (TRUE) {
[17:42:27.828]         base::sink(type = "output", split = FALSE)
[17:42:27.828]         if (TRUE) {
[17:42:27.828]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:27.828]         }
[17:42:27.828]         else {
[17:42:27.828]             ...future.result["stdout"] <- base::list(NULL)
[17:42:27.828]         }
[17:42:27.828]         base::close(...future.stdout)
[17:42:27.828]         ...future.stdout <- NULL
[17:42:27.828]     }
[17:42:27.828]     ...future.result$conditions <- ...future.conditions
[17:42:27.828]     ...future.result$finished <- base::Sys.time()
[17:42:27.828]     ...future.result
[17:42:27.828] }
[17:42:27.831] Exporting 1 global objects (96 bytes) to cluster node #1 ...
[17:42:27.831] Exporting ‘x’ (96 bytes) to cluster node #1 ...
[17:42:27.832] Exporting ‘x’ (96 bytes) to cluster node #1 ... DONE
[17:42:27.832] Exporting 1 global objects (96 bytes) to cluster node #1 ... DONE
[17:42:27.832] MultisessionFuture started
[17:42:27.832] - Launch lazy future ... done
[17:42:27.833] run() for ‘MultisessionFuture’ ... done
[17:42:27.833] result() for ClusterFuture ...
[17:42:27.833] receiveMessageFromWorker() for ClusterFuture ...
[17:42:27.833] - Validating connection of MultisessionFuture
[17:42:27.881] - received message: FutureResult
[17:42:27.881] - Received FutureResult
[17:42:27.881] - Erased future from FutureRegistry
[17:42:27.881] result() for ClusterFuture ...
[17:42:27.881] - result already collected: FutureResult
[17:42:27.881] result() for ClusterFuture ... done
[17:42:27.881] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:27.881] result() for ClusterFuture ... done
[17:42:27.882] result() for ClusterFuture ...
[17:42:27.882] - result already collected: FutureResult
[17:42:27.882] result() for ClusterFuture ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[17:42:27.883] getGlobalsAndPackages() ...
[17:42:27.884] Searching for globals...
[17:42:27.885] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[17:42:27.885] Searching for globals ... DONE
[17:42:27.885] Resolving globals: FALSE
[17:42:27.886] 
[17:42:27.886] - packages: [2] ‘stats’, ‘datasets’
[17:42:27.886] getGlobalsAndPackages() ... DONE
[17:42:27.886] run() for ‘Future’ ...
[17:42:27.886] - state: ‘created’
[17:42:27.887] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:27.901] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:27.901] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:27.901]   - Field: ‘node’
[17:42:27.901]   - Field: ‘label’
[17:42:27.902]   - Field: ‘local’
[17:42:27.902]   - Field: ‘owner’
[17:42:27.902]   - Field: ‘envir’
[17:42:27.902]   - Field: ‘workers’
[17:42:27.902]   - Field: ‘packages’
[17:42:27.902]   - Field: ‘gc’
[17:42:27.902]   - Field: ‘conditions’
[17:42:27.902]   - Field: ‘persistent’
[17:42:27.902]   - Field: ‘expr’
[17:42:27.902]   - Field: ‘uuid’
[17:42:27.902]   - Field: ‘seed’
[17:42:27.903]   - Field: ‘version’
[17:42:27.903]   - Field: ‘result’
[17:42:27.903]   - Field: ‘asynchronous’
[17:42:27.903]   - Field: ‘calls’
[17:42:27.903]   - Field: ‘globals’
[17:42:27.903]   - Field: ‘stdout’
[17:42:27.903]   - Field: ‘earlySignal’
[17:42:27.903]   - Field: ‘lazy’
[17:42:27.903]   - Field: ‘state’
[17:42:27.903] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:27.903] - Launch lazy future ...
[17:42:27.904] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:42:27.904] Packages needed by future strategies (n = 0): <none>
[17:42:27.904] {
[17:42:27.904]     {
[17:42:27.904]         {
[17:42:27.904]             ...future.startTime <- base::Sys.time()
[17:42:27.904]             {
[17:42:27.904]                 {
[17:42:27.904]                   {
[17:42:27.904]                     {
[17:42:27.904]                       {
[17:42:27.904]                         base::local({
[17:42:27.904]                           has_future <- base::requireNamespace("future", 
[17:42:27.904]                             quietly = TRUE)
[17:42:27.904]                           if (has_future) {
[17:42:27.904]                             ns <- base::getNamespace("future")
[17:42:27.904]                             version <- ns[[".package"]][["version"]]
[17:42:27.904]                             if (is.null(version)) 
[17:42:27.904]                               version <- utils::packageVersion("future")
[17:42:27.904]                           }
[17:42:27.904]                           else {
[17:42:27.904]                             version <- NULL
[17:42:27.904]                           }
[17:42:27.904]                           if (!has_future || version < "1.8.0") {
[17:42:27.904]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:27.904]                               "", base::R.version$version.string), 
[17:42:27.904]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:27.904]                                 base::R.version$platform, 8 * 
[17:42:27.904]                                   base::.Machine$sizeof.pointer), 
[17:42:27.904]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:27.904]                                 "release", "version")], collapse = " "), 
[17:42:27.904]                               hostname = base::Sys.info()[["nodename"]])
[17:42:27.904]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:27.904]                               info)
[17:42:27.904]                             info <- base::paste(info, collapse = "; ")
[17:42:27.904]                             if (!has_future) {
[17:42:27.904]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:27.904]                                 info)
[17:42:27.904]                             }
[17:42:27.904]                             else {
[17:42:27.904]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:27.904]                                 info, version)
[17:42:27.904]                             }
[17:42:27.904]                             base::stop(msg)
[17:42:27.904]                           }
[17:42:27.904]                         })
[17:42:27.904]                       }
[17:42:27.904]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:27.904]                       base::options(mc.cores = 1L)
[17:42:27.904]                     }
[17:42:27.904]                     base::local({
[17:42:27.904]                       for (pkg in c("stats", "datasets")) {
[17:42:27.904]                         base::loadNamespace(pkg)
[17:42:27.904]                         base::library(pkg, character.only = TRUE)
[17:42:27.904]                       }
[17:42:27.904]                     })
[17:42:27.904]                   }
[17:42:27.904]                   options(future.plan = NULL)
[17:42:27.904]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:27.904]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:27.904]                 }
[17:42:27.904]                 ...future.workdir <- getwd()
[17:42:27.904]             }
[17:42:27.904]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:27.904]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:27.904]         }
[17:42:27.904]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:27.904]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:27.904]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:27.904]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:27.904]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:27.904]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:27.904]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:27.904]             base::names(...future.oldOptions))
[17:42:27.904]     }
[17:42:27.904]     if (FALSE) {
[17:42:27.904]     }
[17:42:27.904]     else {
[17:42:27.904]         if (TRUE) {
[17:42:27.904]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:27.904]                 open = "w")
[17:42:27.904]         }
[17:42:27.904]         else {
[17:42:27.904]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:27.904]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:27.904]         }
[17:42:27.904]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:27.904]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:27.904]             base::sink(type = "output", split = FALSE)
[17:42:27.904]             base::close(...future.stdout)
[17:42:27.904]         }, add = TRUE)
[17:42:27.904]     }
[17:42:27.904]     ...future.frame <- base::sys.nframe()
[17:42:27.904]     ...future.conditions <- base::list()
[17:42:27.904]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:27.904]     if (FALSE) {
[17:42:27.904]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:27.904]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:27.904]     }
[17:42:27.904]     ...future.result <- base::tryCatch({
[17:42:27.904]         base::withCallingHandlers({
[17:42:27.904]             ...future.value <- base::withVisible(base::local({
[17:42:27.904]                 ...future.makeSendCondition <- local({
[17:42:27.904]                   sendCondition <- NULL
[17:42:27.904]                   function(frame = 1L) {
[17:42:27.904]                     if (is.function(sendCondition)) 
[17:42:27.904]                       return(sendCondition)
[17:42:27.904]                     ns <- getNamespace("parallel")
[17:42:27.904]                     if (exists("sendData", mode = "function", 
[17:42:27.904]                       envir = ns)) {
[17:42:27.904]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:27.904]                         envir = ns)
[17:42:27.904]                       envir <- sys.frame(frame)
[17:42:27.904]                       master <- NULL
[17:42:27.904]                       while (!identical(envir, .GlobalEnv) && 
[17:42:27.904]                         !identical(envir, emptyenv())) {
[17:42:27.904]                         if (exists("master", mode = "list", envir = envir, 
[17:42:27.904]                           inherits = FALSE)) {
[17:42:27.904]                           master <- get("master", mode = "list", 
[17:42:27.904]                             envir = envir, inherits = FALSE)
[17:42:27.904]                           if (inherits(master, c("SOCKnode", 
[17:42:27.904]                             "SOCK0node"))) {
[17:42:27.904]                             sendCondition <<- function(cond) {
[17:42:27.904]                               data <- list(type = "VALUE", value = cond, 
[17:42:27.904]                                 success = TRUE)
[17:42:27.904]                               parallel_sendData(master, data)
[17:42:27.904]                             }
[17:42:27.904]                             return(sendCondition)
[17:42:27.904]                           }
[17:42:27.904]                         }
[17:42:27.904]                         frame <- frame + 1L
[17:42:27.904]                         envir <- sys.frame(frame)
[17:42:27.904]                       }
[17:42:27.904]                     }
[17:42:27.904]                     sendCondition <<- function(cond) NULL
[17:42:27.904]                   }
[17:42:27.904]                 })
[17:42:27.904]                 withCallingHandlers({
[17:42:27.904]                   {
[17:42:27.904]                     lm(dist ~ . - 1, data = cars)
[17:42:27.904]                   }
[17:42:27.904]                 }, immediateCondition = function(cond) {
[17:42:27.904]                   sendCondition <- ...future.makeSendCondition()
[17:42:27.904]                   sendCondition(cond)
[17:42:27.904]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:27.904]                   {
[17:42:27.904]                     inherits <- base::inherits
[17:42:27.904]                     invokeRestart <- base::invokeRestart
[17:42:27.904]                     is.null <- base::is.null
[17:42:27.904]                     muffled <- FALSE
[17:42:27.904]                     if (inherits(cond, "message")) {
[17:42:27.904]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:27.904]                       if (muffled) 
[17:42:27.904]                         invokeRestart("muffleMessage")
[17:42:27.904]                     }
[17:42:27.904]                     else if (inherits(cond, "warning")) {
[17:42:27.904]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:27.904]                       if (muffled) 
[17:42:27.904]                         invokeRestart("muffleWarning")
[17:42:27.904]                     }
[17:42:27.904]                     else if (inherits(cond, "condition")) {
[17:42:27.904]                       if (!is.null(pattern)) {
[17:42:27.904]                         computeRestarts <- base::computeRestarts
[17:42:27.904]                         grepl <- base::grepl
[17:42:27.904]                         restarts <- computeRestarts(cond)
[17:42:27.904]                         for (restart in restarts) {
[17:42:27.904]                           name <- restart$name
[17:42:27.904]                           if (is.null(name)) 
[17:42:27.904]                             next
[17:42:27.904]                           if (!grepl(pattern, name)) 
[17:42:27.904]                             next
[17:42:27.904]                           invokeRestart(restart)
[17:42:27.904]                           muffled <- TRUE
[17:42:27.904]                           break
[17:42:27.904]                         }
[17:42:27.904]                       }
[17:42:27.904]                     }
[17:42:27.904]                     invisible(muffled)
[17:42:27.904]                   }
[17:42:27.904]                   muffleCondition(cond)
[17:42:27.904]                 })
[17:42:27.904]             }))
[17:42:27.904]             future::FutureResult(value = ...future.value$value, 
[17:42:27.904]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:27.904]                   ...future.rng), globalenv = if (FALSE) 
[17:42:27.904]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:27.904]                     ...future.globalenv.names))
[17:42:27.904]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:27.904]         }, condition = base::local({
[17:42:27.904]             c <- base::c
[17:42:27.904]             inherits <- base::inherits
[17:42:27.904]             invokeRestart <- base::invokeRestart
[17:42:27.904]             length <- base::length
[17:42:27.904]             list <- base::list
[17:42:27.904]             seq.int <- base::seq.int
[17:42:27.904]             signalCondition <- base::signalCondition
[17:42:27.904]             sys.calls <- base::sys.calls
[17:42:27.904]             `[[` <- base::`[[`
[17:42:27.904]             `+` <- base::`+`
[17:42:27.904]             `<<-` <- base::`<<-`
[17:42:27.904]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:27.904]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:27.904]                   3L)]
[17:42:27.904]             }
[17:42:27.904]             function(cond) {
[17:42:27.904]                 is_error <- inherits(cond, "error")
[17:42:27.904]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:27.904]                   NULL)
[17:42:27.904]                 if (is_error) {
[17:42:27.904]                   sessionInformation <- function() {
[17:42:27.904]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:27.904]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:27.904]                       search = base::search(), system = base::Sys.info())
[17:42:27.904]                   }
[17:42:27.904]                   ...future.conditions[[length(...future.conditions) + 
[17:42:27.904]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:27.904]                     cond$call), session = sessionInformation(), 
[17:42:27.904]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:27.904]                   signalCondition(cond)
[17:42:27.904]                 }
[17:42:27.904]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:27.904]                 "immediateCondition"))) {
[17:42:27.904]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:27.904]                   ...future.conditions[[length(...future.conditions) + 
[17:42:27.904]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:27.904]                   if (TRUE && !signal) {
[17:42:27.904]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:27.904]                     {
[17:42:27.904]                       inherits <- base::inherits
[17:42:27.904]                       invokeRestart <- base::invokeRestart
[17:42:27.904]                       is.null <- base::is.null
[17:42:27.904]                       muffled <- FALSE
[17:42:27.904]                       if (inherits(cond, "message")) {
[17:42:27.904]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:27.904]                         if (muffled) 
[17:42:27.904]                           invokeRestart("muffleMessage")
[17:42:27.904]                       }
[17:42:27.904]                       else if (inherits(cond, "warning")) {
[17:42:27.904]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:27.904]                         if (muffled) 
[17:42:27.904]                           invokeRestart("muffleWarning")
[17:42:27.904]                       }
[17:42:27.904]                       else if (inherits(cond, "condition")) {
[17:42:27.904]                         if (!is.null(pattern)) {
[17:42:27.904]                           computeRestarts <- base::computeRestarts
[17:42:27.904]                           grepl <- base::grepl
[17:42:27.904]                           restarts <- computeRestarts(cond)
[17:42:27.904]                           for (restart in restarts) {
[17:42:27.904]                             name <- restart$name
[17:42:27.904]                             if (is.null(name)) 
[17:42:27.904]                               next
[17:42:27.904]                             if (!grepl(pattern, name)) 
[17:42:27.904]                               next
[17:42:27.904]                             invokeRestart(restart)
[17:42:27.904]                             muffled <- TRUE
[17:42:27.904]                             break
[17:42:27.904]                           }
[17:42:27.904]                         }
[17:42:27.904]                       }
[17:42:27.904]                       invisible(muffled)
[17:42:27.904]                     }
[17:42:27.904]                     muffleCondition(cond, pattern = "^muffle")
[17:42:27.904]                   }
[17:42:27.904]                 }
[17:42:27.904]                 else {
[17:42:27.904]                   if (TRUE) {
[17:42:27.904]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:27.904]                     {
[17:42:27.904]                       inherits <- base::inherits
[17:42:27.904]                       invokeRestart <- base::invokeRestart
[17:42:27.904]                       is.null <- base::is.null
[17:42:27.904]                       muffled <- FALSE
[17:42:27.904]                       if (inherits(cond, "message")) {
[17:42:27.904]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:27.904]                         if (muffled) 
[17:42:27.904]                           invokeRestart("muffleMessage")
[17:42:27.904]                       }
[17:42:27.904]                       else if (inherits(cond, "warning")) {
[17:42:27.904]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:27.904]                         if (muffled) 
[17:42:27.904]                           invokeRestart("muffleWarning")
[17:42:27.904]                       }
[17:42:27.904]                       else if (inherits(cond, "condition")) {
[17:42:27.904]                         if (!is.null(pattern)) {
[17:42:27.904]                           computeRestarts <- base::computeRestarts
[17:42:27.904]                           grepl <- base::grepl
[17:42:27.904]                           restarts <- computeRestarts(cond)
[17:42:27.904]                           for (restart in restarts) {
[17:42:27.904]                             name <- restart$name
[17:42:27.904]                             if (is.null(name)) 
[17:42:27.904]                               next
[17:42:27.904]                             if (!grepl(pattern, name)) 
[17:42:27.904]                               next
[17:42:27.904]                             invokeRestart(restart)
[17:42:27.904]                             muffled <- TRUE
[17:42:27.904]                             break
[17:42:27.904]                           }
[17:42:27.904]                         }
[17:42:27.904]                       }
[17:42:27.904]                       invisible(muffled)
[17:42:27.904]                     }
[17:42:27.904]                     muffleCondition(cond, pattern = "^muffle")
[17:42:27.904]                   }
[17:42:27.904]                 }
[17:42:27.904]             }
[17:42:27.904]         }))
[17:42:27.904]     }, error = function(ex) {
[17:42:27.904]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:27.904]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:27.904]                 ...future.rng), started = ...future.startTime, 
[17:42:27.904]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:27.904]             version = "1.8"), class = "FutureResult")
[17:42:27.904]     }, finally = {
[17:42:27.904]         if (!identical(...future.workdir, getwd())) 
[17:42:27.904]             setwd(...future.workdir)
[17:42:27.904]         {
[17:42:27.904]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:27.904]                 ...future.oldOptions$nwarnings <- NULL
[17:42:27.904]             }
[17:42:27.904]             base::options(...future.oldOptions)
[17:42:27.904]             if (.Platform$OS.type == "windows") {
[17:42:27.904]                 old_names <- names(...future.oldEnvVars)
[17:42:27.904]                 envs <- base::Sys.getenv()
[17:42:27.904]                 names <- names(envs)
[17:42:27.904]                 common <- intersect(names, old_names)
[17:42:27.904]                 added <- setdiff(names, old_names)
[17:42:27.904]                 removed <- setdiff(old_names, names)
[17:42:27.904]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:27.904]                   envs[common]]
[17:42:27.904]                 NAMES <- toupper(changed)
[17:42:27.904]                 args <- list()
[17:42:27.904]                 for (kk in seq_along(NAMES)) {
[17:42:27.904]                   name <- changed[[kk]]
[17:42:27.904]                   NAME <- NAMES[[kk]]
[17:42:27.904]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:27.904]                     next
[17:42:27.904]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:27.904]                 }
[17:42:27.904]                 NAMES <- toupper(added)
[17:42:27.904]                 for (kk in seq_along(NAMES)) {
[17:42:27.904]                   name <- added[[kk]]
[17:42:27.904]                   NAME <- NAMES[[kk]]
[17:42:27.904]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:27.904]                     next
[17:42:27.904]                   args[[name]] <- ""
[17:42:27.904]                 }
[17:42:27.904]                 NAMES <- toupper(removed)
[17:42:27.904]                 for (kk in seq_along(NAMES)) {
[17:42:27.904]                   name <- removed[[kk]]
[17:42:27.904]                   NAME <- NAMES[[kk]]
[17:42:27.904]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:27.904]                     next
[17:42:27.904]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:27.904]                 }
[17:42:27.904]                 if (length(args) > 0) 
[17:42:27.904]                   base::do.call(base::Sys.setenv, args = args)
[17:42:27.904]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:27.904]             }
[17:42:27.904]             else {
[17:42:27.904]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:27.904]             }
[17:42:27.904]             {
[17:42:27.904]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:27.904]                   0L) {
[17:42:27.904]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:27.904]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:27.904]                   base::options(opts)
[17:42:27.904]                 }
[17:42:27.904]                 {
[17:42:27.904]                   {
[17:42:27.904]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:27.904]                     NULL
[17:42:27.904]                   }
[17:42:27.904]                   options(future.plan = NULL)
[17:42:27.904]                   if (is.na(NA_character_)) 
[17:42:27.904]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:27.904]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:27.904]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:27.904]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:27.904]                     envir = parent.frame()) 
[17:42:27.904]                   {
[17:42:27.904]                     if (is.function(workers)) 
[17:42:27.904]                       workers <- workers()
[17:42:27.904]                     workers <- structure(as.integer(workers), 
[17:42:27.904]                       class = class(workers))
[17:42:27.904]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:27.904]                       workers >= 1)
[17:42:27.904]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:27.904]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:27.904]                     }
[17:42:27.904]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:27.904]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:27.904]                       envir = envir)
[17:42:27.904]                     if (!future$lazy) 
[17:42:27.904]                       future <- run(future)
[17:42:27.904]                     invisible(future)
[17:42:27.904]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:27.904]                 }
[17:42:27.904]             }
[17:42:27.904]         }
[17:42:27.904]     })
[17:42:27.904]     if (TRUE) {
[17:42:27.904]         base::sink(type = "output", split = FALSE)
[17:42:27.904]         if (TRUE) {
[17:42:27.904]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:27.904]         }
[17:42:27.904]         else {
[17:42:27.904]             ...future.result["stdout"] <- base::list(NULL)
[17:42:27.904]         }
[17:42:27.904]         base::close(...future.stdout)
[17:42:27.904]         ...future.stdout <- NULL
[17:42:27.904]     }
[17:42:27.904]     ...future.result$conditions <- ...future.conditions
[17:42:27.904]     ...future.result$finished <- base::Sys.time()
[17:42:27.904]     ...future.result
[17:42:27.904] }
[17:42:27.908] MultisessionFuture started
[17:42:27.908] - Launch lazy future ... done
[17:42:27.908] run() for ‘MultisessionFuture’ ... done
[17:42:27.909] result() for ClusterFuture ...
[17:42:27.909] receiveMessageFromWorker() for ClusterFuture ...
[17:42:27.909] - Validating connection of MultisessionFuture
[17:42:27.959] - received message: FutureResult
[17:42:27.959] - Received FutureResult
[17:42:27.959] - Erased future from FutureRegistry
[17:42:27.959] result() for ClusterFuture ...
[17:42:27.959] - result already collected: FutureResult
[17:42:27.959] result() for ClusterFuture ... done
[17:42:27.960] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:27.960] result() for ClusterFuture ... done
[17:42:27.960] result() for ClusterFuture ...
[17:42:27.960] - result already collected: FutureResult
[17:42:27.960] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[17:42:27.964] getGlobalsAndPackages() ...
[17:42:27.964] Searching for globals...
[17:42:27.966] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[17:42:27.966] Searching for globals ... DONE
[17:42:27.966] Resolving globals: FALSE
[17:42:27.967] 
[17:42:27.967] - packages: [2] ‘stats’, ‘datasets’
[17:42:27.967] getGlobalsAndPackages() ... DONE
[17:42:27.967] run() for ‘Future’ ...
[17:42:27.967] - state: ‘created’
[17:42:27.968] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:27.982] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:27.982] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:27.983]   - Field: ‘node’
[17:42:27.983]   - Field: ‘label’
[17:42:27.983]   - Field: ‘local’
[17:42:27.983]   - Field: ‘owner’
[17:42:27.983]   - Field: ‘envir’
[17:42:27.983]   - Field: ‘workers’
[17:42:27.983]   - Field: ‘packages’
[17:42:27.983]   - Field: ‘gc’
[17:42:27.983]   - Field: ‘conditions’
[17:42:27.983]   - Field: ‘persistent’
[17:42:27.984]   - Field: ‘expr’
[17:42:27.984]   - Field: ‘uuid’
[17:42:27.984]   - Field: ‘seed’
[17:42:27.984]   - Field: ‘version’
[17:42:27.984]   - Field: ‘result’
[17:42:27.984]   - Field: ‘asynchronous’
[17:42:27.984]   - Field: ‘calls’
[17:42:27.984]   - Field: ‘globals’
[17:42:27.984]   - Field: ‘stdout’
[17:42:27.984]   - Field: ‘earlySignal’
[17:42:27.984]   - Field: ‘lazy’
[17:42:27.984]   - Field: ‘state’
[17:42:27.985] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:27.985] - Launch lazy future ...
[17:42:27.985] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:42:27.985] Packages needed by future strategies (n = 0): <none>
[17:42:27.986] {
[17:42:27.986]     {
[17:42:27.986]         {
[17:42:27.986]             ...future.startTime <- base::Sys.time()
[17:42:27.986]             {
[17:42:27.986]                 {
[17:42:27.986]                   {
[17:42:27.986]                     {
[17:42:27.986]                       {
[17:42:27.986]                         base::local({
[17:42:27.986]                           has_future <- base::requireNamespace("future", 
[17:42:27.986]                             quietly = TRUE)
[17:42:27.986]                           if (has_future) {
[17:42:27.986]                             ns <- base::getNamespace("future")
[17:42:27.986]                             version <- ns[[".package"]][["version"]]
[17:42:27.986]                             if (is.null(version)) 
[17:42:27.986]                               version <- utils::packageVersion("future")
[17:42:27.986]                           }
[17:42:27.986]                           else {
[17:42:27.986]                             version <- NULL
[17:42:27.986]                           }
[17:42:27.986]                           if (!has_future || version < "1.8.0") {
[17:42:27.986]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:27.986]                               "", base::R.version$version.string), 
[17:42:27.986]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:27.986]                                 base::R.version$platform, 8 * 
[17:42:27.986]                                   base::.Machine$sizeof.pointer), 
[17:42:27.986]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:27.986]                                 "release", "version")], collapse = " "), 
[17:42:27.986]                               hostname = base::Sys.info()[["nodename"]])
[17:42:27.986]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:27.986]                               info)
[17:42:27.986]                             info <- base::paste(info, collapse = "; ")
[17:42:27.986]                             if (!has_future) {
[17:42:27.986]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:27.986]                                 info)
[17:42:27.986]                             }
[17:42:27.986]                             else {
[17:42:27.986]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:27.986]                                 info, version)
[17:42:27.986]                             }
[17:42:27.986]                             base::stop(msg)
[17:42:27.986]                           }
[17:42:27.986]                         })
[17:42:27.986]                       }
[17:42:27.986]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:27.986]                       base::options(mc.cores = 1L)
[17:42:27.986]                     }
[17:42:27.986]                     base::local({
[17:42:27.986]                       for (pkg in c("stats", "datasets")) {
[17:42:27.986]                         base::loadNamespace(pkg)
[17:42:27.986]                         base::library(pkg, character.only = TRUE)
[17:42:27.986]                       }
[17:42:27.986]                     })
[17:42:27.986]                   }
[17:42:27.986]                   options(future.plan = NULL)
[17:42:27.986]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:27.986]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:27.986]                 }
[17:42:27.986]                 ...future.workdir <- getwd()
[17:42:27.986]             }
[17:42:27.986]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:27.986]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:27.986]         }
[17:42:27.986]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:27.986]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:27.986]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:27.986]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:27.986]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:27.986]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:27.986]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:27.986]             base::names(...future.oldOptions))
[17:42:27.986]     }
[17:42:27.986]     if (FALSE) {
[17:42:27.986]     }
[17:42:27.986]     else {
[17:42:27.986]         if (TRUE) {
[17:42:27.986]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:27.986]                 open = "w")
[17:42:27.986]         }
[17:42:27.986]         else {
[17:42:27.986]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:27.986]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:27.986]         }
[17:42:27.986]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:27.986]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:27.986]             base::sink(type = "output", split = FALSE)
[17:42:27.986]             base::close(...future.stdout)
[17:42:27.986]         }, add = TRUE)
[17:42:27.986]     }
[17:42:27.986]     ...future.frame <- base::sys.nframe()
[17:42:27.986]     ...future.conditions <- base::list()
[17:42:27.986]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:27.986]     if (FALSE) {
[17:42:27.986]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:27.986]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:27.986]     }
[17:42:27.986]     ...future.result <- base::tryCatch({
[17:42:27.986]         base::withCallingHandlers({
[17:42:27.986]             ...future.value <- base::withVisible(base::local({
[17:42:27.986]                 ...future.makeSendCondition <- local({
[17:42:27.986]                   sendCondition <- NULL
[17:42:27.986]                   function(frame = 1L) {
[17:42:27.986]                     if (is.function(sendCondition)) 
[17:42:27.986]                       return(sendCondition)
[17:42:27.986]                     ns <- getNamespace("parallel")
[17:42:27.986]                     if (exists("sendData", mode = "function", 
[17:42:27.986]                       envir = ns)) {
[17:42:27.986]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:27.986]                         envir = ns)
[17:42:27.986]                       envir <- sys.frame(frame)
[17:42:27.986]                       master <- NULL
[17:42:27.986]                       while (!identical(envir, .GlobalEnv) && 
[17:42:27.986]                         !identical(envir, emptyenv())) {
[17:42:27.986]                         if (exists("master", mode = "list", envir = envir, 
[17:42:27.986]                           inherits = FALSE)) {
[17:42:27.986]                           master <- get("master", mode = "list", 
[17:42:27.986]                             envir = envir, inherits = FALSE)
[17:42:27.986]                           if (inherits(master, c("SOCKnode", 
[17:42:27.986]                             "SOCK0node"))) {
[17:42:27.986]                             sendCondition <<- function(cond) {
[17:42:27.986]                               data <- list(type = "VALUE", value = cond, 
[17:42:27.986]                                 success = TRUE)
[17:42:27.986]                               parallel_sendData(master, data)
[17:42:27.986]                             }
[17:42:27.986]                             return(sendCondition)
[17:42:27.986]                           }
[17:42:27.986]                         }
[17:42:27.986]                         frame <- frame + 1L
[17:42:27.986]                         envir <- sys.frame(frame)
[17:42:27.986]                       }
[17:42:27.986]                     }
[17:42:27.986]                     sendCondition <<- function(cond) NULL
[17:42:27.986]                   }
[17:42:27.986]                 })
[17:42:27.986]                 withCallingHandlers({
[17:42:27.986]                   {
[17:42:27.986]                     lm(dist ~ . + 0, data = cars)
[17:42:27.986]                   }
[17:42:27.986]                 }, immediateCondition = function(cond) {
[17:42:27.986]                   sendCondition <- ...future.makeSendCondition()
[17:42:27.986]                   sendCondition(cond)
[17:42:27.986]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:27.986]                   {
[17:42:27.986]                     inherits <- base::inherits
[17:42:27.986]                     invokeRestart <- base::invokeRestart
[17:42:27.986]                     is.null <- base::is.null
[17:42:27.986]                     muffled <- FALSE
[17:42:27.986]                     if (inherits(cond, "message")) {
[17:42:27.986]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:27.986]                       if (muffled) 
[17:42:27.986]                         invokeRestart("muffleMessage")
[17:42:27.986]                     }
[17:42:27.986]                     else if (inherits(cond, "warning")) {
[17:42:27.986]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:27.986]                       if (muffled) 
[17:42:27.986]                         invokeRestart("muffleWarning")
[17:42:27.986]                     }
[17:42:27.986]                     else if (inherits(cond, "condition")) {
[17:42:27.986]                       if (!is.null(pattern)) {
[17:42:27.986]                         computeRestarts <- base::computeRestarts
[17:42:27.986]                         grepl <- base::grepl
[17:42:27.986]                         restarts <- computeRestarts(cond)
[17:42:27.986]                         for (restart in restarts) {
[17:42:27.986]                           name <- restart$name
[17:42:27.986]                           if (is.null(name)) 
[17:42:27.986]                             next
[17:42:27.986]                           if (!grepl(pattern, name)) 
[17:42:27.986]                             next
[17:42:27.986]                           invokeRestart(restart)
[17:42:27.986]                           muffled <- TRUE
[17:42:27.986]                           break
[17:42:27.986]                         }
[17:42:27.986]                       }
[17:42:27.986]                     }
[17:42:27.986]                     invisible(muffled)
[17:42:27.986]                   }
[17:42:27.986]                   muffleCondition(cond)
[17:42:27.986]                 })
[17:42:27.986]             }))
[17:42:27.986]             future::FutureResult(value = ...future.value$value, 
[17:42:27.986]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:27.986]                   ...future.rng), globalenv = if (FALSE) 
[17:42:27.986]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:27.986]                     ...future.globalenv.names))
[17:42:27.986]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:27.986]         }, condition = base::local({
[17:42:27.986]             c <- base::c
[17:42:27.986]             inherits <- base::inherits
[17:42:27.986]             invokeRestart <- base::invokeRestart
[17:42:27.986]             length <- base::length
[17:42:27.986]             list <- base::list
[17:42:27.986]             seq.int <- base::seq.int
[17:42:27.986]             signalCondition <- base::signalCondition
[17:42:27.986]             sys.calls <- base::sys.calls
[17:42:27.986]             `[[` <- base::`[[`
[17:42:27.986]             `+` <- base::`+`
[17:42:27.986]             `<<-` <- base::`<<-`
[17:42:27.986]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:27.986]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:27.986]                   3L)]
[17:42:27.986]             }
[17:42:27.986]             function(cond) {
[17:42:27.986]                 is_error <- inherits(cond, "error")
[17:42:27.986]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:27.986]                   NULL)
[17:42:27.986]                 if (is_error) {
[17:42:27.986]                   sessionInformation <- function() {
[17:42:27.986]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:27.986]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:27.986]                       search = base::search(), system = base::Sys.info())
[17:42:27.986]                   }
[17:42:27.986]                   ...future.conditions[[length(...future.conditions) + 
[17:42:27.986]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:27.986]                     cond$call), session = sessionInformation(), 
[17:42:27.986]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:27.986]                   signalCondition(cond)
[17:42:27.986]                 }
[17:42:27.986]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:27.986]                 "immediateCondition"))) {
[17:42:27.986]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:27.986]                   ...future.conditions[[length(...future.conditions) + 
[17:42:27.986]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:27.986]                   if (TRUE && !signal) {
[17:42:27.986]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:27.986]                     {
[17:42:27.986]                       inherits <- base::inherits
[17:42:27.986]                       invokeRestart <- base::invokeRestart
[17:42:27.986]                       is.null <- base::is.null
[17:42:27.986]                       muffled <- FALSE
[17:42:27.986]                       if (inherits(cond, "message")) {
[17:42:27.986]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:27.986]                         if (muffled) 
[17:42:27.986]                           invokeRestart("muffleMessage")
[17:42:27.986]                       }
[17:42:27.986]                       else if (inherits(cond, "warning")) {
[17:42:27.986]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:27.986]                         if (muffled) 
[17:42:27.986]                           invokeRestart("muffleWarning")
[17:42:27.986]                       }
[17:42:27.986]                       else if (inherits(cond, "condition")) {
[17:42:27.986]                         if (!is.null(pattern)) {
[17:42:27.986]                           computeRestarts <- base::computeRestarts
[17:42:27.986]                           grepl <- base::grepl
[17:42:27.986]                           restarts <- computeRestarts(cond)
[17:42:27.986]                           for (restart in restarts) {
[17:42:27.986]                             name <- restart$name
[17:42:27.986]                             if (is.null(name)) 
[17:42:27.986]                               next
[17:42:27.986]                             if (!grepl(pattern, name)) 
[17:42:27.986]                               next
[17:42:27.986]                             invokeRestart(restart)
[17:42:27.986]                             muffled <- TRUE
[17:42:27.986]                             break
[17:42:27.986]                           }
[17:42:27.986]                         }
[17:42:27.986]                       }
[17:42:27.986]                       invisible(muffled)
[17:42:27.986]                     }
[17:42:27.986]                     muffleCondition(cond, pattern = "^muffle")
[17:42:27.986]                   }
[17:42:27.986]                 }
[17:42:27.986]                 else {
[17:42:27.986]                   if (TRUE) {
[17:42:27.986]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:27.986]                     {
[17:42:27.986]                       inherits <- base::inherits
[17:42:27.986]                       invokeRestart <- base::invokeRestart
[17:42:27.986]                       is.null <- base::is.null
[17:42:27.986]                       muffled <- FALSE
[17:42:27.986]                       if (inherits(cond, "message")) {
[17:42:27.986]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:27.986]                         if (muffled) 
[17:42:27.986]                           invokeRestart("muffleMessage")
[17:42:27.986]                       }
[17:42:27.986]                       else if (inherits(cond, "warning")) {
[17:42:27.986]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:27.986]                         if (muffled) 
[17:42:27.986]                           invokeRestart("muffleWarning")
[17:42:27.986]                       }
[17:42:27.986]                       else if (inherits(cond, "condition")) {
[17:42:27.986]                         if (!is.null(pattern)) {
[17:42:27.986]                           computeRestarts <- base::computeRestarts
[17:42:27.986]                           grepl <- base::grepl
[17:42:27.986]                           restarts <- computeRestarts(cond)
[17:42:27.986]                           for (restart in restarts) {
[17:42:27.986]                             name <- restart$name
[17:42:27.986]                             if (is.null(name)) 
[17:42:27.986]                               next
[17:42:27.986]                             if (!grepl(pattern, name)) 
[17:42:27.986]                               next
[17:42:27.986]                             invokeRestart(restart)
[17:42:27.986]                             muffled <- TRUE
[17:42:27.986]                             break
[17:42:27.986]                           }
[17:42:27.986]                         }
[17:42:27.986]                       }
[17:42:27.986]                       invisible(muffled)
[17:42:27.986]                     }
[17:42:27.986]                     muffleCondition(cond, pattern = "^muffle")
[17:42:27.986]                   }
[17:42:27.986]                 }
[17:42:27.986]             }
[17:42:27.986]         }))
[17:42:27.986]     }, error = function(ex) {
[17:42:27.986]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:27.986]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:27.986]                 ...future.rng), started = ...future.startTime, 
[17:42:27.986]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:27.986]             version = "1.8"), class = "FutureResult")
[17:42:27.986]     }, finally = {
[17:42:27.986]         if (!identical(...future.workdir, getwd())) 
[17:42:27.986]             setwd(...future.workdir)
[17:42:27.986]         {
[17:42:27.986]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:27.986]                 ...future.oldOptions$nwarnings <- NULL
[17:42:27.986]             }
[17:42:27.986]             base::options(...future.oldOptions)
[17:42:27.986]             if (.Platform$OS.type == "windows") {
[17:42:27.986]                 old_names <- names(...future.oldEnvVars)
[17:42:27.986]                 envs <- base::Sys.getenv()
[17:42:27.986]                 names <- names(envs)
[17:42:27.986]                 common <- intersect(names, old_names)
[17:42:27.986]                 added <- setdiff(names, old_names)
[17:42:27.986]                 removed <- setdiff(old_names, names)
[17:42:27.986]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:27.986]                   envs[common]]
[17:42:27.986]                 NAMES <- toupper(changed)
[17:42:27.986]                 args <- list()
[17:42:27.986]                 for (kk in seq_along(NAMES)) {
[17:42:27.986]                   name <- changed[[kk]]
[17:42:27.986]                   NAME <- NAMES[[kk]]
[17:42:27.986]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:27.986]                     next
[17:42:27.986]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:27.986]                 }
[17:42:27.986]                 NAMES <- toupper(added)
[17:42:27.986]                 for (kk in seq_along(NAMES)) {
[17:42:27.986]                   name <- added[[kk]]
[17:42:27.986]                   NAME <- NAMES[[kk]]
[17:42:27.986]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:27.986]                     next
[17:42:27.986]                   args[[name]] <- ""
[17:42:27.986]                 }
[17:42:27.986]                 NAMES <- toupper(removed)
[17:42:27.986]                 for (kk in seq_along(NAMES)) {
[17:42:27.986]                   name <- removed[[kk]]
[17:42:27.986]                   NAME <- NAMES[[kk]]
[17:42:27.986]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:27.986]                     next
[17:42:27.986]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:27.986]                 }
[17:42:27.986]                 if (length(args) > 0) 
[17:42:27.986]                   base::do.call(base::Sys.setenv, args = args)
[17:42:27.986]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:27.986]             }
[17:42:27.986]             else {
[17:42:27.986]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:27.986]             }
[17:42:27.986]             {
[17:42:27.986]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:27.986]                   0L) {
[17:42:27.986]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:27.986]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:27.986]                   base::options(opts)
[17:42:27.986]                 }
[17:42:27.986]                 {
[17:42:27.986]                   {
[17:42:27.986]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:27.986]                     NULL
[17:42:27.986]                   }
[17:42:27.986]                   options(future.plan = NULL)
[17:42:27.986]                   if (is.na(NA_character_)) 
[17:42:27.986]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:27.986]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:27.986]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:27.986]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:27.986]                     envir = parent.frame()) 
[17:42:27.986]                   {
[17:42:27.986]                     if (is.function(workers)) 
[17:42:27.986]                       workers <- workers()
[17:42:27.986]                     workers <- structure(as.integer(workers), 
[17:42:27.986]                       class = class(workers))
[17:42:27.986]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:27.986]                       workers >= 1)
[17:42:27.986]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:27.986]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:27.986]                     }
[17:42:27.986]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:27.986]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:27.986]                       envir = envir)
[17:42:27.986]                     if (!future$lazy) 
[17:42:27.986]                       future <- run(future)
[17:42:27.986]                     invisible(future)
[17:42:27.986]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:27.986]                 }
[17:42:27.986]             }
[17:42:27.986]         }
[17:42:27.986]     })
[17:42:27.986]     if (TRUE) {
[17:42:27.986]         base::sink(type = "output", split = FALSE)
[17:42:27.986]         if (TRUE) {
[17:42:27.986]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:27.986]         }
[17:42:27.986]         else {
[17:42:27.986]             ...future.result["stdout"] <- base::list(NULL)
[17:42:27.986]         }
[17:42:27.986]         base::close(...future.stdout)
[17:42:27.986]         ...future.stdout <- NULL
[17:42:27.986]     }
[17:42:27.986]     ...future.result$conditions <- ...future.conditions
[17:42:27.986]     ...future.result$finished <- base::Sys.time()
[17:42:27.986]     ...future.result
[17:42:27.986] }
[17:42:27.989] MultisessionFuture started
[17:42:27.989] - Launch lazy future ... done
[17:42:27.989] run() for ‘MultisessionFuture’ ... done
[17:42:27.989] result() for ClusterFuture ...
[17:42:27.990] receiveMessageFromWorker() for ClusterFuture ...
[17:42:27.990] - Validating connection of MultisessionFuture
[17:42:28.038] - received message: FutureResult
[17:42:28.038] - Received FutureResult
[17:42:28.038] - Erased future from FutureRegistry
[17:42:28.038] result() for ClusterFuture ...
[17:42:28.038] - result already collected: FutureResult
[17:42:28.038] result() for ClusterFuture ... done
[17:42:28.038] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:28.038] result() for ClusterFuture ... done
[17:42:28.039] result() for ClusterFuture ...
[17:42:28.039] - result already collected: FutureResult
[17:42:28.039] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[17:42:28.041] getGlobalsAndPackages() ...
[17:42:28.041] Searching for globals...
[17:42:28.043] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[17:42:28.043] Searching for globals ... DONE
[17:42:28.043] Resolving globals: FALSE
[17:42:28.044] 
[17:42:28.044] - packages: [2] ‘stats’, ‘datasets’
[17:42:28.044] getGlobalsAndPackages() ... DONE
[17:42:28.044] run() for ‘Future’ ...
[17:42:28.045] - state: ‘created’
[17:42:28.045] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:28.060] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:28.061] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:28.061]   - Field: ‘node’
[17:42:28.061]   - Field: ‘label’
[17:42:28.061]   - Field: ‘local’
[17:42:28.061]   - Field: ‘owner’
[17:42:28.061]   - Field: ‘envir’
[17:42:28.061]   - Field: ‘workers’
[17:42:28.061]   - Field: ‘packages’
[17:42:28.061]   - Field: ‘gc’
[17:42:28.061]   - Field: ‘conditions’
[17:42:28.062]   - Field: ‘persistent’
[17:42:28.062]   - Field: ‘expr’
[17:42:28.062]   - Field: ‘uuid’
[17:42:28.062]   - Field: ‘seed’
[17:42:28.062]   - Field: ‘version’
[17:42:28.062]   - Field: ‘result’
[17:42:28.062]   - Field: ‘asynchronous’
[17:42:28.062]   - Field: ‘calls’
[17:42:28.062]   - Field: ‘globals’
[17:42:28.062]   - Field: ‘stdout’
[17:42:28.062]   - Field: ‘earlySignal’
[17:42:28.063]   - Field: ‘lazy’
[17:42:28.063]   - Field: ‘state’
[17:42:28.063] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:28.063] - Launch lazy future ...
[17:42:28.064] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:42:28.064] Packages needed by future strategies (n = 0): <none>
[17:42:28.064] {
[17:42:28.064]     {
[17:42:28.064]         {
[17:42:28.064]             ...future.startTime <- base::Sys.time()
[17:42:28.064]             {
[17:42:28.064]                 {
[17:42:28.064]                   {
[17:42:28.064]                     {
[17:42:28.064]                       {
[17:42:28.064]                         base::local({
[17:42:28.064]                           has_future <- base::requireNamespace("future", 
[17:42:28.064]                             quietly = TRUE)
[17:42:28.064]                           if (has_future) {
[17:42:28.064]                             ns <- base::getNamespace("future")
[17:42:28.064]                             version <- ns[[".package"]][["version"]]
[17:42:28.064]                             if (is.null(version)) 
[17:42:28.064]                               version <- utils::packageVersion("future")
[17:42:28.064]                           }
[17:42:28.064]                           else {
[17:42:28.064]                             version <- NULL
[17:42:28.064]                           }
[17:42:28.064]                           if (!has_future || version < "1.8.0") {
[17:42:28.064]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:28.064]                               "", base::R.version$version.string), 
[17:42:28.064]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:28.064]                                 base::R.version$platform, 8 * 
[17:42:28.064]                                   base::.Machine$sizeof.pointer), 
[17:42:28.064]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:28.064]                                 "release", "version")], collapse = " "), 
[17:42:28.064]                               hostname = base::Sys.info()[["nodename"]])
[17:42:28.064]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:28.064]                               info)
[17:42:28.064]                             info <- base::paste(info, collapse = "; ")
[17:42:28.064]                             if (!has_future) {
[17:42:28.064]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:28.064]                                 info)
[17:42:28.064]                             }
[17:42:28.064]                             else {
[17:42:28.064]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:28.064]                                 info, version)
[17:42:28.064]                             }
[17:42:28.064]                             base::stop(msg)
[17:42:28.064]                           }
[17:42:28.064]                         })
[17:42:28.064]                       }
[17:42:28.064]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:28.064]                       base::options(mc.cores = 1L)
[17:42:28.064]                     }
[17:42:28.064]                     base::local({
[17:42:28.064]                       for (pkg in c("stats", "datasets")) {
[17:42:28.064]                         base::loadNamespace(pkg)
[17:42:28.064]                         base::library(pkg, character.only = TRUE)
[17:42:28.064]                       }
[17:42:28.064]                     })
[17:42:28.064]                   }
[17:42:28.064]                   options(future.plan = NULL)
[17:42:28.064]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:28.064]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:28.064]                 }
[17:42:28.064]                 ...future.workdir <- getwd()
[17:42:28.064]             }
[17:42:28.064]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:28.064]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:28.064]         }
[17:42:28.064]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:28.064]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:28.064]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:28.064]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:28.064]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:28.064]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:28.064]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:28.064]             base::names(...future.oldOptions))
[17:42:28.064]     }
[17:42:28.064]     if (FALSE) {
[17:42:28.064]     }
[17:42:28.064]     else {
[17:42:28.064]         if (TRUE) {
[17:42:28.064]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:28.064]                 open = "w")
[17:42:28.064]         }
[17:42:28.064]         else {
[17:42:28.064]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:28.064]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:28.064]         }
[17:42:28.064]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:28.064]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:28.064]             base::sink(type = "output", split = FALSE)
[17:42:28.064]             base::close(...future.stdout)
[17:42:28.064]         }, add = TRUE)
[17:42:28.064]     }
[17:42:28.064]     ...future.frame <- base::sys.nframe()
[17:42:28.064]     ...future.conditions <- base::list()
[17:42:28.064]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:28.064]     if (FALSE) {
[17:42:28.064]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:28.064]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:28.064]     }
[17:42:28.064]     ...future.result <- base::tryCatch({
[17:42:28.064]         base::withCallingHandlers({
[17:42:28.064]             ...future.value <- base::withVisible(base::local({
[17:42:28.064]                 ...future.makeSendCondition <- local({
[17:42:28.064]                   sendCondition <- NULL
[17:42:28.064]                   function(frame = 1L) {
[17:42:28.064]                     if (is.function(sendCondition)) 
[17:42:28.064]                       return(sendCondition)
[17:42:28.064]                     ns <- getNamespace("parallel")
[17:42:28.064]                     if (exists("sendData", mode = "function", 
[17:42:28.064]                       envir = ns)) {
[17:42:28.064]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:28.064]                         envir = ns)
[17:42:28.064]                       envir <- sys.frame(frame)
[17:42:28.064]                       master <- NULL
[17:42:28.064]                       while (!identical(envir, .GlobalEnv) && 
[17:42:28.064]                         !identical(envir, emptyenv())) {
[17:42:28.064]                         if (exists("master", mode = "list", envir = envir, 
[17:42:28.064]                           inherits = FALSE)) {
[17:42:28.064]                           master <- get("master", mode = "list", 
[17:42:28.064]                             envir = envir, inherits = FALSE)
[17:42:28.064]                           if (inherits(master, c("SOCKnode", 
[17:42:28.064]                             "SOCK0node"))) {
[17:42:28.064]                             sendCondition <<- function(cond) {
[17:42:28.064]                               data <- list(type = "VALUE", value = cond, 
[17:42:28.064]                                 success = TRUE)
[17:42:28.064]                               parallel_sendData(master, data)
[17:42:28.064]                             }
[17:42:28.064]                             return(sendCondition)
[17:42:28.064]                           }
[17:42:28.064]                         }
[17:42:28.064]                         frame <- frame + 1L
[17:42:28.064]                         envir <- sys.frame(frame)
[17:42:28.064]                       }
[17:42:28.064]                     }
[17:42:28.064]                     sendCondition <<- function(cond) NULL
[17:42:28.064]                   }
[17:42:28.064]                 })
[17:42:28.064]                 withCallingHandlers({
[17:42:28.064]                   {
[17:42:28.064]                     lm(dist ~ speed + speed^2, data = cars)
[17:42:28.064]                   }
[17:42:28.064]                 }, immediateCondition = function(cond) {
[17:42:28.064]                   sendCondition <- ...future.makeSendCondition()
[17:42:28.064]                   sendCondition(cond)
[17:42:28.064]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:28.064]                   {
[17:42:28.064]                     inherits <- base::inherits
[17:42:28.064]                     invokeRestart <- base::invokeRestart
[17:42:28.064]                     is.null <- base::is.null
[17:42:28.064]                     muffled <- FALSE
[17:42:28.064]                     if (inherits(cond, "message")) {
[17:42:28.064]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:28.064]                       if (muffled) 
[17:42:28.064]                         invokeRestart("muffleMessage")
[17:42:28.064]                     }
[17:42:28.064]                     else if (inherits(cond, "warning")) {
[17:42:28.064]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:28.064]                       if (muffled) 
[17:42:28.064]                         invokeRestart("muffleWarning")
[17:42:28.064]                     }
[17:42:28.064]                     else if (inherits(cond, "condition")) {
[17:42:28.064]                       if (!is.null(pattern)) {
[17:42:28.064]                         computeRestarts <- base::computeRestarts
[17:42:28.064]                         grepl <- base::grepl
[17:42:28.064]                         restarts <- computeRestarts(cond)
[17:42:28.064]                         for (restart in restarts) {
[17:42:28.064]                           name <- restart$name
[17:42:28.064]                           if (is.null(name)) 
[17:42:28.064]                             next
[17:42:28.064]                           if (!grepl(pattern, name)) 
[17:42:28.064]                             next
[17:42:28.064]                           invokeRestart(restart)
[17:42:28.064]                           muffled <- TRUE
[17:42:28.064]                           break
[17:42:28.064]                         }
[17:42:28.064]                       }
[17:42:28.064]                     }
[17:42:28.064]                     invisible(muffled)
[17:42:28.064]                   }
[17:42:28.064]                   muffleCondition(cond)
[17:42:28.064]                 })
[17:42:28.064]             }))
[17:42:28.064]             future::FutureResult(value = ...future.value$value, 
[17:42:28.064]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:28.064]                   ...future.rng), globalenv = if (FALSE) 
[17:42:28.064]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:28.064]                     ...future.globalenv.names))
[17:42:28.064]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:28.064]         }, condition = base::local({
[17:42:28.064]             c <- base::c
[17:42:28.064]             inherits <- base::inherits
[17:42:28.064]             invokeRestart <- base::invokeRestart
[17:42:28.064]             length <- base::length
[17:42:28.064]             list <- base::list
[17:42:28.064]             seq.int <- base::seq.int
[17:42:28.064]             signalCondition <- base::signalCondition
[17:42:28.064]             sys.calls <- base::sys.calls
[17:42:28.064]             `[[` <- base::`[[`
[17:42:28.064]             `+` <- base::`+`
[17:42:28.064]             `<<-` <- base::`<<-`
[17:42:28.064]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:28.064]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:28.064]                   3L)]
[17:42:28.064]             }
[17:42:28.064]             function(cond) {
[17:42:28.064]                 is_error <- inherits(cond, "error")
[17:42:28.064]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:28.064]                   NULL)
[17:42:28.064]                 if (is_error) {
[17:42:28.064]                   sessionInformation <- function() {
[17:42:28.064]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:28.064]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:28.064]                       search = base::search(), system = base::Sys.info())
[17:42:28.064]                   }
[17:42:28.064]                   ...future.conditions[[length(...future.conditions) + 
[17:42:28.064]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:28.064]                     cond$call), session = sessionInformation(), 
[17:42:28.064]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:28.064]                   signalCondition(cond)
[17:42:28.064]                 }
[17:42:28.064]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:28.064]                 "immediateCondition"))) {
[17:42:28.064]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:28.064]                   ...future.conditions[[length(...future.conditions) + 
[17:42:28.064]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:28.064]                   if (TRUE && !signal) {
[17:42:28.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:28.064]                     {
[17:42:28.064]                       inherits <- base::inherits
[17:42:28.064]                       invokeRestart <- base::invokeRestart
[17:42:28.064]                       is.null <- base::is.null
[17:42:28.064]                       muffled <- FALSE
[17:42:28.064]                       if (inherits(cond, "message")) {
[17:42:28.064]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:28.064]                         if (muffled) 
[17:42:28.064]                           invokeRestart("muffleMessage")
[17:42:28.064]                       }
[17:42:28.064]                       else if (inherits(cond, "warning")) {
[17:42:28.064]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:28.064]                         if (muffled) 
[17:42:28.064]                           invokeRestart("muffleWarning")
[17:42:28.064]                       }
[17:42:28.064]                       else if (inherits(cond, "condition")) {
[17:42:28.064]                         if (!is.null(pattern)) {
[17:42:28.064]                           computeRestarts <- base::computeRestarts
[17:42:28.064]                           grepl <- base::grepl
[17:42:28.064]                           restarts <- computeRestarts(cond)
[17:42:28.064]                           for (restart in restarts) {
[17:42:28.064]                             name <- restart$name
[17:42:28.064]                             if (is.null(name)) 
[17:42:28.064]                               next
[17:42:28.064]                             if (!grepl(pattern, name)) 
[17:42:28.064]                               next
[17:42:28.064]                             invokeRestart(restart)
[17:42:28.064]                             muffled <- TRUE
[17:42:28.064]                             break
[17:42:28.064]                           }
[17:42:28.064]                         }
[17:42:28.064]                       }
[17:42:28.064]                       invisible(muffled)
[17:42:28.064]                     }
[17:42:28.064]                     muffleCondition(cond, pattern = "^muffle")
[17:42:28.064]                   }
[17:42:28.064]                 }
[17:42:28.064]                 else {
[17:42:28.064]                   if (TRUE) {
[17:42:28.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:28.064]                     {
[17:42:28.064]                       inherits <- base::inherits
[17:42:28.064]                       invokeRestart <- base::invokeRestart
[17:42:28.064]                       is.null <- base::is.null
[17:42:28.064]                       muffled <- FALSE
[17:42:28.064]                       if (inherits(cond, "message")) {
[17:42:28.064]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:28.064]                         if (muffled) 
[17:42:28.064]                           invokeRestart("muffleMessage")
[17:42:28.064]                       }
[17:42:28.064]                       else if (inherits(cond, "warning")) {
[17:42:28.064]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:28.064]                         if (muffled) 
[17:42:28.064]                           invokeRestart("muffleWarning")
[17:42:28.064]                       }
[17:42:28.064]                       else if (inherits(cond, "condition")) {
[17:42:28.064]                         if (!is.null(pattern)) {
[17:42:28.064]                           computeRestarts <- base::computeRestarts
[17:42:28.064]                           grepl <- base::grepl
[17:42:28.064]                           restarts <- computeRestarts(cond)
[17:42:28.064]                           for (restart in restarts) {
[17:42:28.064]                             name <- restart$name
[17:42:28.064]                             if (is.null(name)) 
[17:42:28.064]                               next
[17:42:28.064]                             if (!grepl(pattern, name)) 
[17:42:28.064]                               next
[17:42:28.064]                             invokeRestart(restart)
[17:42:28.064]                             muffled <- TRUE
[17:42:28.064]                             break
[17:42:28.064]                           }
[17:42:28.064]                         }
[17:42:28.064]                       }
[17:42:28.064]                       invisible(muffled)
[17:42:28.064]                     }
[17:42:28.064]                     muffleCondition(cond, pattern = "^muffle")
[17:42:28.064]                   }
[17:42:28.064]                 }
[17:42:28.064]             }
[17:42:28.064]         }))
[17:42:28.064]     }, error = function(ex) {
[17:42:28.064]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:28.064]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:28.064]                 ...future.rng), started = ...future.startTime, 
[17:42:28.064]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:28.064]             version = "1.8"), class = "FutureResult")
[17:42:28.064]     }, finally = {
[17:42:28.064]         if (!identical(...future.workdir, getwd())) 
[17:42:28.064]             setwd(...future.workdir)
[17:42:28.064]         {
[17:42:28.064]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:28.064]                 ...future.oldOptions$nwarnings <- NULL
[17:42:28.064]             }
[17:42:28.064]             base::options(...future.oldOptions)
[17:42:28.064]             if (.Platform$OS.type == "windows") {
[17:42:28.064]                 old_names <- names(...future.oldEnvVars)
[17:42:28.064]                 envs <- base::Sys.getenv()
[17:42:28.064]                 names <- names(envs)
[17:42:28.064]                 common <- intersect(names, old_names)
[17:42:28.064]                 added <- setdiff(names, old_names)
[17:42:28.064]                 removed <- setdiff(old_names, names)
[17:42:28.064]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:28.064]                   envs[common]]
[17:42:28.064]                 NAMES <- toupper(changed)
[17:42:28.064]                 args <- list()
[17:42:28.064]                 for (kk in seq_along(NAMES)) {
[17:42:28.064]                   name <- changed[[kk]]
[17:42:28.064]                   NAME <- NAMES[[kk]]
[17:42:28.064]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:28.064]                     next
[17:42:28.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:28.064]                 }
[17:42:28.064]                 NAMES <- toupper(added)
[17:42:28.064]                 for (kk in seq_along(NAMES)) {
[17:42:28.064]                   name <- added[[kk]]
[17:42:28.064]                   NAME <- NAMES[[kk]]
[17:42:28.064]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:28.064]                     next
[17:42:28.064]                   args[[name]] <- ""
[17:42:28.064]                 }
[17:42:28.064]                 NAMES <- toupper(removed)
[17:42:28.064]                 for (kk in seq_along(NAMES)) {
[17:42:28.064]                   name <- removed[[kk]]
[17:42:28.064]                   NAME <- NAMES[[kk]]
[17:42:28.064]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:28.064]                     next
[17:42:28.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:28.064]                 }
[17:42:28.064]                 if (length(args) > 0) 
[17:42:28.064]                   base::do.call(base::Sys.setenv, args = args)
[17:42:28.064]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:28.064]             }
[17:42:28.064]             else {
[17:42:28.064]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:28.064]             }
[17:42:28.064]             {
[17:42:28.064]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:28.064]                   0L) {
[17:42:28.064]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:28.064]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:28.064]                   base::options(opts)
[17:42:28.064]                 }
[17:42:28.064]                 {
[17:42:28.064]                   {
[17:42:28.064]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:28.064]                     NULL
[17:42:28.064]                   }
[17:42:28.064]                   options(future.plan = NULL)
[17:42:28.064]                   if (is.na(NA_character_)) 
[17:42:28.064]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:28.064]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:28.064]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:28.064]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:28.064]                     envir = parent.frame()) 
[17:42:28.064]                   {
[17:42:28.064]                     if (is.function(workers)) 
[17:42:28.064]                       workers <- workers()
[17:42:28.064]                     workers <- structure(as.integer(workers), 
[17:42:28.064]                       class = class(workers))
[17:42:28.064]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:28.064]                       workers >= 1)
[17:42:28.064]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:28.064]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:28.064]                     }
[17:42:28.064]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:28.064]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:28.064]                       envir = envir)
[17:42:28.064]                     if (!future$lazy) 
[17:42:28.064]                       future <- run(future)
[17:42:28.064]                     invisible(future)
[17:42:28.064]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:28.064]                 }
[17:42:28.064]             }
[17:42:28.064]         }
[17:42:28.064]     })
[17:42:28.064]     if (TRUE) {
[17:42:28.064]         base::sink(type = "output", split = FALSE)
[17:42:28.064]         if (TRUE) {
[17:42:28.064]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:28.064]         }
[17:42:28.064]         else {
[17:42:28.064]             ...future.result["stdout"] <- base::list(NULL)
[17:42:28.064]         }
[17:42:28.064]         base::close(...future.stdout)
[17:42:28.064]         ...future.stdout <- NULL
[17:42:28.064]     }
[17:42:28.064]     ...future.result$conditions <- ...future.conditions
[17:42:28.064]     ...future.result$finished <- base::Sys.time()
[17:42:28.064]     ...future.result
[17:42:28.064] }
[17:42:28.068] MultisessionFuture started
[17:42:28.068] - Launch lazy future ... done
[17:42:28.068] run() for ‘MultisessionFuture’ ... done
[17:42:28.068] result() for ClusterFuture ...
[17:42:28.068] receiveMessageFromWorker() for ClusterFuture ...
[17:42:28.068] - Validating connection of MultisessionFuture
[17:42:28.117] - received message: FutureResult
[17:42:28.117] - Received FutureResult
[17:42:28.117] - Erased future from FutureRegistry
[17:42:28.117] result() for ClusterFuture ...
[17:42:28.117] - result already collected: FutureResult
[17:42:28.118] result() for ClusterFuture ... done
[17:42:28.118] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:28.118] result() for ClusterFuture ... done
[17:42:28.118] result() for ClusterFuture ...
[17:42:28.118] - result already collected: FutureResult
[17:42:28.118] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[17:42:28.121] getGlobalsAndPackages() ...
[17:42:28.121] Searching for globals...
[17:42:28.123] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[17:42:28.123] Searching for globals ... DONE
[17:42:28.123] Resolving globals: FALSE
[17:42:28.124] 
[17:42:28.124] - packages: [2] ‘stats’, ‘datasets’
[17:42:28.124] getGlobalsAndPackages() ... DONE
[17:42:28.124] run() for ‘Future’ ...
[17:42:28.124] - state: ‘created’
[17:42:28.124] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:28.139] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:28.139] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:28.139]   - Field: ‘node’
[17:42:28.139]   - Field: ‘label’
[17:42:28.139]   - Field: ‘local’
[17:42:28.139]   - Field: ‘owner’
[17:42:28.139]   - Field: ‘envir’
[17:42:28.139]   - Field: ‘workers’
[17:42:28.139]   - Field: ‘packages’
[17:42:28.140]   - Field: ‘gc’
[17:42:28.140]   - Field: ‘conditions’
[17:42:28.140]   - Field: ‘persistent’
[17:42:28.140]   - Field: ‘expr’
[17:42:28.140]   - Field: ‘uuid’
[17:42:28.140]   - Field: ‘seed’
[17:42:28.140]   - Field: ‘version’
[17:42:28.140]   - Field: ‘result’
[17:42:28.140]   - Field: ‘asynchronous’
[17:42:28.140]   - Field: ‘calls’
[17:42:28.140]   - Field: ‘globals’
[17:42:28.141]   - Field: ‘stdout’
[17:42:28.141]   - Field: ‘earlySignal’
[17:42:28.141]   - Field: ‘lazy’
[17:42:28.141]   - Field: ‘state’
[17:42:28.141] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:28.141] - Launch lazy future ...
[17:42:28.141] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:42:28.141] Packages needed by future strategies (n = 0): <none>
[17:42:28.142] {
[17:42:28.142]     {
[17:42:28.142]         {
[17:42:28.142]             ...future.startTime <- base::Sys.time()
[17:42:28.142]             {
[17:42:28.142]                 {
[17:42:28.142]                   {
[17:42:28.142]                     {
[17:42:28.142]                       {
[17:42:28.142]                         base::local({
[17:42:28.142]                           has_future <- base::requireNamespace("future", 
[17:42:28.142]                             quietly = TRUE)
[17:42:28.142]                           if (has_future) {
[17:42:28.142]                             ns <- base::getNamespace("future")
[17:42:28.142]                             version <- ns[[".package"]][["version"]]
[17:42:28.142]                             if (is.null(version)) 
[17:42:28.142]                               version <- utils::packageVersion("future")
[17:42:28.142]                           }
[17:42:28.142]                           else {
[17:42:28.142]                             version <- NULL
[17:42:28.142]                           }
[17:42:28.142]                           if (!has_future || version < "1.8.0") {
[17:42:28.142]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:28.142]                               "", base::R.version$version.string), 
[17:42:28.142]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:28.142]                                 base::R.version$platform, 8 * 
[17:42:28.142]                                   base::.Machine$sizeof.pointer), 
[17:42:28.142]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:28.142]                                 "release", "version")], collapse = " "), 
[17:42:28.142]                               hostname = base::Sys.info()[["nodename"]])
[17:42:28.142]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:28.142]                               info)
[17:42:28.142]                             info <- base::paste(info, collapse = "; ")
[17:42:28.142]                             if (!has_future) {
[17:42:28.142]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:28.142]                                 info)
[17:42:28.142]                             }
[17:42:28.142]                             else {
[17:42:28.142]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:28.142]                                 info, version)
[17:42:28.142]                             }
[17:42:28.142]                             base::stop(msg)
[17:42:28.142]                           }
[17:42:28.142]                         })
[17:42:28.142]                       }
[17:42:28.142]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:28.142]                       base::options(mc.cores = 1L)
[17:42:28.142]                     }
[17:42:28.142]                     base::local({
[17:42:28.142]                       for (pkg in c("stats", "datasets")) {
[17:42:28.142]                         base::loadNamespace(pkg)
[17:42:28.142]                         base::library(pkg, character.only = TRUE)
[17:42:28.142]                       }
[17:42:28.142]                     })
[17:42:28.142]                   }
[17:42:28.142]                   options(future.plan = NULL)
[17:42:28.142]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:28.142]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:28.142]                 }
[17:42:28.142]                 ...future.workdir <- getwd()
[17:42:28.142]             }
[17:42:28.142]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:28.142]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:28.142]         }
[17:42:28.142]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:28.142]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:28.142]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:28.142]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:28.142]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:28.142]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:28.142]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:28.142]             base::names(...future.oldOptions))
[17:42:28.142]     }
[17:42:28.142]     if (FALSE) {
[17:42:28.142]     }
[17:42:28.142]     else {
[17:42:28.142]         if (TRUE) {
[17:42:28.142]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:28.142]                 open = "w")
[17:42:28.142]         }
[17:42:28.142]         else {
[17:42:28.142]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:28.142]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:28.142]         }
[17:42:28.142]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:28.142]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:28.142]             base::sink(type = "output", split = FALSE)
[17:42:28.142]             base::close(...future.stdout)
[17:42:28.142]         }, add = TRUE)
[17:42:28.142]     }
[17:42:28.142]     ...future.frame <- base::sys.nframe()
[17:42:28.142]     ...future.conditions <- base::list()
[17:42:28.142]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:28.142]     if (FALSE) {
[17:42:28.142]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:28.142]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:28.142]     }
[17:42:28.142]     ...future.result <- base::tryCatch({
[17:42:28.142]         base::withCallingHandlers({
[17:42:28.142]             ...future.value <- base::withVisible(base::local({
[17:42:28.142]                 ...future.makeSendCondition <- local({
[17:42:28.142]                   sendCondition <- NULL
[17:42:28.142]                   function(frame = 1L) {
[17:42:28.142]                     if (is.function(sendCondition)) 
[17:42:28.142]                       return(sendCondition)
[17:42:28.142]                     ns <- getNamespace("parallel")
[17:42:28.142]                     if (exists("sendData", mode = "function", 
[17:42:28.142]                       envir = ns)) {
[17:42:28.142]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:28.142]                         envir = ns)
[17:42:28.142]                       envir <- sys.frame(frame)
[17:42:28.142]                       master <- NULL
[17:42:28.142]                       while (!identical(envir, .GlobalEnv) && 
[17:42:28.142]                         !identical(envir, emptyenv())) {
[17:42:28.142]                         if (exists("master", mode = "list", envir = envir, 
[17:42:28.142]                           inherits = FALSE)) {
[17:42:28.142]                           master <- get("master", mode = "list", 
[17:42:28.142]                             envir = envir, inherits = FALSE)
[17:42:28.142]                           if (inherits(master, c("SOCKnode", 
[17:42:28.142]                             "SOCK0node"))) {
[17:42:28.142]                             sendCondition <<- function(cond) {
[17:42:28.142]                               data <- list(type = "VALUE", value = cond, 
[17:42:28.142]                                 success = TRUE)
[17:42:28.142]                               parallel_sendData(master, data)
[17:42:28.142]                             }
[17:42:28.142]                             return(sendCondition)
[17:42:28.142]                           }
[17:42:28.142]                         }
[17:42:28.142]                         frame <- frame + 1L
[17:42:28.142]                         envir <- sys.frame(frame)
[17:42:28.142]                       }
[17:42:28.142]                     }
[17:42:28.142]                     sendCondition <<- function(cond) NULL
[17:42:28.142]                   }
[17:42:28.142]                 })
[17:42:28.142]                 withCallingHandlers({
[17:42:28.142]                   {
[17:42:28.142]                     lm(dist ~ speed + I(speed^2), data = cars)
[17:42:28.142]                   }
[17:42:28.142]                 }, immediateCondition = function(cond) {
[17:42:28.142]                   sendCondition <- ...future.makeSendCondition()
[17:42:28.142]                   sendCondition(cond)
[17:42:28.142]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:28.142]                   {
[17:42:28.142]                     inherits <- base::inherits
[17:42:28.142]                     invokeRestart <- base::invokeRestart
[17:42:28.142]                     is.null <- base::is.null
[17:42:28.142]                     muffled <- FALSE
[17:42:28.142]                     if (inherits(cond, "message")) {
[17:42:28.142]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:28.142]                       if (muffled) 
[17:42:28.142]                         invokeRestart("muffleMessage")
[17:42:28.142]                     }
[17:42:28.142]                     else if (inherits(cond, "warning")) {
[17:42:28.142]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:28.142]                       if (muffled) 
[17:42:28.142]                         invokeRestart("muffleWarning")
[17:42:28.142]                     }
[17:42:28.142]                     else if (inherits(cond, "condition")) {
[17:42:28.142]                       if (!is.null(pattern)) {
[17:42:28.142]                         computeRestarts <- base::computeRestarts
[17:42:28.142]                         grepl <- base::grepl
[17:42:28.142]                         restarts <- computeRestarts(cond)
[17:42:28.142]                         for (restart in restarts) {
[17:42:28.142]                           name <- restart$name
[17:42:28.142]                           if (is.null(name)) 
[17:42:28.142]                             next
[17:42:28.142]                           if (!grepl(pattern, name)) 
[17:42:28.142]                             next
[17:42:28.142]                           invokeRestart(restart)
[17:42:28.142]                           muffled <- TRUE
[17:42:28.142]                           break
[17:42:28.142]                         }
[17:42:28.142]                       }
[17:42:28.142]                     }
[17:42:28.142]                     invisible(muffled)
[17:42:28.142]                   }
[17:42:28.142]                   muffleCondition(cond)
[17:42:28.142]                 })
[17:42:28.142]             }))
[17:42:28.142]             future::FutureResult(value = ...future.value$value, 
[17:42:28.142]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:28.142]                   ...future.rng), globalenv = if (FALSE) 
[17:42:28.142]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:28.142]                     ...future.globalenv.names))
[17:42:28.142]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:28.142]         }, condition = base::local({
[17:42:28.142]             c <- base::c
[17:42:28.142]             inherits <- base::inherits
[17:42:28.142]             invokeRestart <- base::invokeRestart
[17:42:28.142]             length <- base::length
[17:42:28.142]             list <- base::list
[17:42:28.142]             seq.int <- base::seq.int
[17:42:28.142]             signalCondition <- base::signalCondition
[17:42:28.142]             sys.calls <- base::sys.calls
[17:42:28.142]             `[[` <- base::`[[`
[17:42:28.142]             `+` <- base::`+`
[17:42:28.142]             `<<-` <- base::`<<-`
[17:42:28.142]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:28.142]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:28.142]                   3L)]
[17:42:28.142]             }
[17:42:28.142]             function(cond) {
[17:42:28.142]                 is_error <- inherits(cond, "error")
[17:42:28.142]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:28.142]                   NULL)
[17:42:28.142]                 if (is_error) {
[17:42:28.142]                   sessionInformation <- function() {
[17:42:28.142]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:28.142]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:28.142]                       search = base::search(), system = base::Sys.info())
[17:42:28.142]                   }
[17:42:28.142]                   ...future.conditions[[length(...future.conditions) + 
[17:42:28.142]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:28.142]                     cond$call), session = sessionInformation(), 
[17:42:28.142]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:28.142]                   signalCondition(cond)
[17:42:28.142]                 }
[17:42:28.142]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:28.142]                 "immediateCondition"))) {
[17:42:28.142]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:28.142]                   ...future.conditions[[length(...future.conditions) + 
[17:42:28.142]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:28.142]                   if (TRUE && !signal) {
[17:42:28.142]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:28.142]                     {
[17:42:28.142]                       inherits <- base::inherits
[17:42:28.142]                       invokeRestart <- base::invokeRestart
[17:42:28.142]                       is.null <- base::is.null
[17:42:28.142]                       muffled <- FALSE
[17:42:28.142]                       if (inherits(cond, "message")) {
[17:42:28.142]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:28.142]                         if (muffled) 
[17:42:28.142]                           invokeRestart("muffleMessage")
[17:42:28.142]                       }
[17:42:28.142]                       else if (inherits(cond, "warning")) {
[17:42:28.142]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:28.142]                         if (muffled) 
[17:42:28.142]                           invokeRestart("muffleWarning")
[17:42:28.142]                       }
[17:42:28.142]                       else if (inherits(cond, "condition")) {
[17:42:28.142]                         if (!is.null(pattern)) {
[17:42:28.142]                           computeRestarts <- base::computeRestarts
[17:42:28.142]                           grepl <- base::grepl
[17:42:28.142]                           restarts <- computeRestarts(cond)
[17:42:28.142]                           for (restart in restarts) {
[17:42:28.142]                             name <- restart$name
[17:42:28.142]                             if (is.null(name)) 
[17:42:28.142]                               next
[17:42:28.142]                             if (!grepl(pattern, name)) 
[17:42:28.142]                               next
[17:42:28.142]                             invokeRestart(restart)
[17:42:28.142]                             muffled <- TRUE
[17:42:28.142]                             break
[17:42:28.142]                           }
[17:42:28.142]                         }
[17:42:28.142]                       }
[17:42:28.142]                       invisible(muffled)
[17:42:28.142]                     }
[17:42:28.142]                     muffleCondition(cond, pattern = "^muffle")
[17:42:28.142]                   }
[17:42:28.142]                 }
[17:42:28.142]                 else {
[17:42:28.142]                   if (TRUE) {
[17:42:28.142]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:28.142]                     {
[17:42:28.142]                       inherits <- base::inherits
[17:42:28.142]                       invokeRestart <- base::invokeRestart
[17:42:28.142]                       is.null <- base::is.null
[17:42:28.142]                       muffled <- FALSE
[17:42:28.142]                       if (inherits(cond, "message")) {
[17:42:28.142]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:28.142]                         if (muffled) 
[17:42:28.142]                           invokeRestart("muffleMessage")
[17:42:28.142]                       }
[17:42:28.142]                       else if (inherits(cond, "warning")) {
[17:42:28.142]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:28.142]                         if (muffled) 
[17:42:28.142]                           invokeRestart("muffleWarning")
[17:42:28.142]                       }
[17:42:28.142]                       else if (inherits(cond, "condition")) {
[17:42:28.142]                         if (!is.null(pattern)) {
[17:42:28.142]                           computeRestarts <- base::computeRestarts
[17:42:28.142]                           grepl <- base::grepl
[17:42:28.142]                           restarts <- computeRestarts(cond)
[17:42:28.142]                           for (restart in restarts) {
[17:42:28.142]                             name <- restart$name
[17:42:28.142]                             if (is.null(name)) 
[17:42:28.142]                               next
[17:42:28.142]                             if (!grepl(pattern, name)) 
[17:42:28.142]                               next
[17:42:28.142]                             invokeRestart(restart)
[17:42:28.142]                             muffled <- TRUE
[17:42:28.142]                             break
[17:42:28.142]                           }
[17:42:28.142]                         }
[17:42:28.142]                       }
[17:42:28.142]                       invisible(muffled)
[17:42:28.142]                     }
[17:42:28.142]                     muffleCondition(cond, pattern = "^muffle")
[17:42:28.142]                   }
[17:42:28.142]                 }
[17:42:28.142]             }
[17:42:28.142]         }))
[17:42:28.142]     }, error = function(ex) {
[17:42:28.142]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:28.142]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:28.142]                 ...future.rng), started = ...future.startTime, 
[17:42:28.142]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:28.142]             version = "1.8"), class = "FutureResult")
[17:42:28.142]     }, finally = {
[17:42:28.142]         if (!identical(...future.workdir, getwd())) 
[17:42:28.142]             setwd(...future.workdir)
[17:42:28.142]         {
[17:42:28.142]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:28.142]                 ...future.oldOptions$nwarnings <- NULL
[17:42:28.142]             }
[17:42:28.142]             base::options(...future.oldOptions)
[17:42:28.142]             if (.Platform$OS.type == "windows") {
[17:42:28.142]                 old_names <- names(...future.oldEnvVars)
[17:42:28.142]                 envs <- base::Sys.getenv()
[17:42:28.142]                 names <- names(envs)
[17:42:28.142]                 common <- intersect(names, old_names)
[17:42:28.142]                 added <- setdiff(names, old_names)
[17:42:28.142]                 removed <- setdiff(old_names, names)
[17:42:28.142]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:28.142]                   envs[common]]
[17:42:28.142]                 NAMES <- toupper(changed)
[17:42:28.142]                 args <- list()
[17:42:28.142]                 for (kk in seq_along(NAMES)) {
[17:42:28.142]                   name <- changed[[kk]]
[17:42:28.142]                   NAME <- NAMES[[kk]]
[17:42:28.142]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:28.142]                     next
[17:42:28.142]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:28.142]                 }
[17:42:28.142]                 NAMES <- toupper(added)
[17:42:28.142]                 for (kk in seq_along(NAMES)) {
[17:42:28.142]                   name <- added[[kk]]
[17:42:28.142]                   NAME <- NAMES[[kk]]
[17:42:28.142]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:28.142]                     next
[17:42:28.142]                   args[[name]] <- ""
[17:42:28.142]                 }
[17:42:28.142]                 NAMES <- toupper(removed)
[17:42:28.142]                 for (kk in seq_along(NAMES)) {
[17:42:28.142]                   name <- removed[[kk]]
[17:42:28.142]                   NAME <- NAMES[[kk]]
[17:42:28.142]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:28.142]                     next
[17:42:28.142]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:28.142]                 }
[17:42:28.142]                 if (length(args) > 0) 
[17:42:28.142]                   base::do.call(base::Sys.setenv, args = args)
[17:42:28.142]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:28.142]             }
[17:42:28.142]             else {
[17:42:28.142]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:28.142]             }
[17:42:28.142]             {
[17:42:28.142]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:28.142]                   0L) {
[17:42:28.142]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:28.142]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:28.142]                   base::options(opts)
[17:42:28.142]                 }
[17:42:28.142]                 {
[17:42:28.142]                   {
[17:42:28.142]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:28.142]                     NULL
[17:42:28.142]                   }
[17:42:28.142]                   options(future.plan = NULL)
[17:42:28.142]                   if (is.na(NA_character_)) 
[17:42:28.142]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:28.142]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:28.142]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:28.142]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:28.142]                     envir = parent.frame()) 
[17:42:28.142]                   {
[17:42:28.142]                     if (is.function(workers)) 
[17:42:28.142]                       workers <- workers()
[17:42:28.142]                     workers <- structure(as.integer(workers), 
[17:42:28.142]                       class = class(workers))
[17:42:28.142]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:28.142]                       workers >= 1)
[17:42:28.142]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:28.142]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:28.142]                     }
[17:42:28.142]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:28.142]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:28.142]                       envir = envir)
[17:42:28.142]                     if (!future$lazy) 
[17:42:28.142]                       future <- run(future)
[17:42:28.142]                     invisible(future)
[17:42:28.142]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:28.142]                 }
[17:42:28.142]             }
[17:42:28.142]         }
[17:42:28.142]     })
[17:42:28.142]     if (TRUE) {
[17:42:28.142]         base::sink(type = "output", split = FALSE)
[17:42:28.142]         if (TRUE) {
[17:42:28.142]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:28.142]         }
[17:42:28.142]         else {
[17:42:28.142]             ...future.result["stdout"] <- base::list(NULL)
[17:42:28.142]         }
[17:42:28.142]         base::close(...future.stdout)
[17:42:28.142]         ...future.stdout <- NULL
[17:42:28.142]     }
[17:42:28.142]     ...future.result$conditions <- ...future.conditions
[17:42:28.142]     ...future.result$finished <- base::Sys.time()
[17:42:28.142]     ...future.result
[17:42:28.142] }
[17:42:28.145] MultisessionFuture started
[17:42:28.145] - Launch lazy future ... done
[17:42:28.145] run() for ‘MultisessionFuture’ ... done
[17:42:28.146] result() for ClusterFuture ...
[17:42:28.146] receiveMessageFromWorker() for ClusterFuture ...
[17:42:28.146] - Validating connection of MultisessionFuture
[17:42:28.193] - received message: FutureResult
[17:42:28.193] - Received FutureResult
[17:42:28.193] - Erased future from FutureRegistry
[17:42:28.193] result() for ClusterFuture ...
[17:42:28.193] - result already collected: FutureResult
[17:42:28.193] result() for ClusterFuture ... done
[17:42:28.193] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:28.193] result() for ClusterFuture ... done
[17:42:28.193] result() for ClusterFuture ...
[17:42:28.194] - result already collected: FutureResult
[17:42:28.194] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[17:42:28.196] getGlobalsAndPackages() ...
[17:42:28.196] Searching for globals...
[17:42:28.198] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[17:42:28.198] Searching for globals ... DONE
[17:42:28.198] Resolving globals: FALSE
[17:42:28.199] 
[17:42:28.199] - packages: [2] ‘stats’, ‘datasets’
[17:42:28.199] getGlobalsAndPackages() ... DONE
[17:42:28.199] run() for ‘Future’ ...
[17:42:28.199] - state: ‘created’
[17:42:28.199] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:28.213] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:28.213] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:28.214]   - Field: ‘node’
[17:42:28.214]   - Field: ‘label’
[17:42:28.214]   - Field: ‘local’
[17:42:28.214]   - Field: ‘owner’
[17:42:28.214]   - Field: ‘envir’
[17:42:28.214]   - Field: ‘workers’
[17:42:28.214]   - Field: ‘packages’
[17:42:28.214]   - Field: ‘gc’
[17:42:28.214]   - Field: ‘conditions’
[17:42:28.214]   - Field: ‘persistent’
[17:42:28.215]   - Field: ‘expr’
[17:42:28.215]   - Field: ‘uuid’
[17:42:28.215]   - Field: ‘seed’
[17:42:28.215]   - Field: ‘version’
[17:42:28.215]   - Field: ‘result’
[17:42:28.215]   - Field: ‘asynchronous’
[17:42:28.215]   - Field: ‘calls’
[17:42:28.215]   - Field: ‘globals’
[17:42:28.215]   - Field: ‘stdout’
[17:42:28.215]   - Field: ‘earlySignal’
[17:42:28.216]   - Field: ‘lazy’
[17:42:28.216]   - Field: ‘state’
[17:42:28.216] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:28.216] - Launch lazy future ...
[17:42:28.216] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:42:28.216] Packages needed by future strategies (n = 0): <none>
[17:42:28.217] {
[17:42:28.217]     {
[17:42:28.217]         {
[17:42:28.217]             ...future.startTime <- base::Sys.time()
[17:42:28.217]             {
[17:42:28.217]                 {
[17:42:28.217]                   {
[17:42:28.217]                     {
[17:42:28.217]                       {
[17:42:28.217]                         base::local({
[17:42:28.217]                           has_future <- base::requireNamespace("future", 
[17:42:28.217]                             quietly = TRUE)
[17:42:28.217]                           if (has_future) {
[17:42:28.217]                             ns <- base::getNamespace("future")
[17:42:28.217]                             version <- ns[[".package"]][["version"]]
[17:42:28.217]                             if (is.null(version)) 
[17:42:28.217]                               version <- utils::packageVersion("future")
[17:42:28.217]                           }
[17:42:28.217]                           else {
[17:42:28.217]                             version <- NULL
[17:42:28.217]                           }
[17:42:28.217]                           if (!has_future || version < "1.8.0") {
[17:42:28.217]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:28.217]                               "", base::R.version$version.string), 
[17:42:28.217]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:28.217]                                 base::R.version$platform, 8 * 
[17:42:28.217]                                   base::.Machine$sizeof.pointer), 
[17:42:28.217]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:28.217]                                 "release", "version")], collapse = " "), 
[17:42:28.217]                               hostname = base::Sys.info()[["nodename"]])
[17:42:28.217]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:28.217]                               info)
[17:42:28.217]                             info <- base::paste(info, collapse = "; ")
[17:42:28.217]                             if (!has_future) {
[17:42:28.217]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:28.217]                                 info)
[17:42:28.217]                             }
[17:42:28.217]                             else {
[17:42:28.217]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:28.217]                                 info, version)
[17:42:28.217]                             }
[17:42:28.217]                             base::stop(msg)
[17:42:28.217]                           }
[17:42:28.217]                         })
[17:42:28.217]                       }
[17:42:28.217]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:28.217]                       base::options(mc.cores = 1L)
[17:42:28.217]                     }
[17:42:28.217]                     base::local({
[17:42:28.217]                       for (pkg in c("stats", "datasets")) {
[17:42:28.217]                         base::loadNamespace(pkg)
[17:42:28.217]                         base::library(pkg, character.only = TRUE)
[17:42:28.217]                       }
[17:42:28.217]                     })
[17:42:28.217]                   }
[17:42:28.217]                   options(future.plan = NULL)
[17:42:28.217]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:28.217]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:28.217]                 }
[17:42:28.217]                 ...future.workdir <- getwd()
[17:42:28.217]             }
[17:42:28.217]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:28.217]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:28.217]         }
[17:42:28.217]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:28.217]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:28.217]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:28.217]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:28.217]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:28.217]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:28.217]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:28.217]             base::names(...future.oldOptions))
[17:42:28.217]     }
[17:42:28.217]     if (FALSE) {
[17:42:28.217]     }
[17:42:28.217]     else {
[17:42:28.217]         if (TRUE) {
[17:42:28.217]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:28.217]                 open = "w")
[17:42:28.217]         }
[17:42:28.217]         else {
[17:42:28.217]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:28.217]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:28.217]         }
[17:42:28.217]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:28.217]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:28.217]             base::sink(type = "output", split = FALSE)
[17:42:28.217]             base::close(...future.stdout)
[17:42:28.217]         }, add = TRUE)
[17:42:28.217]     }
[17:42:28.217]     ...future.frame <- base::sys.nframe()
[17:42:28.217]     ...future.conditions <- base::list()
[17:42:28.217]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:28.217]     if (FALSE) {
[17:42:28.217]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:28.217]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:28.217]     }
[17:42:28.217]     ...future.result <- base::tryCatch({
[17:42:28.217]         base::withCallingHandlers({
[17:42:28.217]             ...future.value <- base::withVisible(base::local({
[17:42:28.217]                 ...future.makeSendCondition <- local({
[17:42:28.217]                   sendCondition <- NULL
[17:42:28.217]                   function(frame = 1L) {
[17:42:28.217]                     if (is.function(sendCondition)) 
[17:42:28.217]                       return(sendCondition)
[17:42:28.217]                     ns <- getNamespace("parallel")
[17:42:28.217]                     if (exists("sendData", mode = "function", 
[17:42:28.217]                       envir = ns)) {
[17:42:28.217]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:28.217]                         envir = ns)
[17:42:28.217]                       envir <- sys.frame(frame)
[17:42:28.217]                       master <- NULL
[17:42:28.217]                       while (!identical(envir, .GlobalEnv) && 
[17:42:28.217]                         !identical(envir, emptyenv())) {
[17:42:28.217]                         if (exists("master", mode = "list", envir = envir, 
[17:42:28.217]                           inherits = FALSE)) {
[17:42:28.217]                           master <- get("master", mode = "list", 
[17:42:28.217]                             envir = envir, inherits = FALSE)
[17:42:28.217]                           if (inherits(master, c("SOCKnode", 
[17:42:28.217]                             "SOCK0node"))) {
[17:42:28.217]                             sendCondition <<- function(cond) {
[17:42:28.217]                               data <- list(type = "VALUE", value = cond, 
[17:42:28.217]                                 success = TRUE)
[17:42:28.217]                               parallel_sendData(master, data)
[17:42:28.217]                             }
[17:42:28.217]                             return(sendCondition)
[17:42:28.217]                           }
[17:42:28.217]                         }
[17:42:28.217]                         frame <- frame + 1L
[17:42:28.217]                         envir <- sys.frame(frame)
[17:42:28.217]                       }
[17:42:28.217]                     }
[17:42:28.217]                     sendCondition <<- function(cond) NULL
[17:42:28.217]                   }
[17:42:28.217]                 })
[17:42:28.217]                 withCallingHandlers({
[17:42:28.217]                   {
[17:42:28.217]                     lm(dist ~ poly(speed, 2), data = cars)
[17:42:28.217]                   }
[17:42:28.217]                 }, immediateCondition = function(cond) {
[17:42:28.217]                   sendCondition <- ...future.makeSendCondition()
[17:42:28.217]                   sendCondition(cond)
[17:42:28.217]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:28.217]                   {
[17:42:28.217]                     inherits <- base::inherits
[17:42:28.217]                     invokeRestart <- base::invokeRestart
[17:42:28.217]                     is.null <- base::is.null
[17:42:28.217]                     muffled <- FALSE
[17:42:28.217]                     if (inherits(cond, "message")) {
[17:42:28.217]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:28.217]                       if (muffled) 
[17:42:28.217]                         invokeRestart("muffleMessage")
[17:42:28.217]                     }
[17:42:28.217]                     else if (inherits(cond, "warning")) {
[17:42:28.217]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:28.217]                       if (muffled) 
[17:42:28.217]                         invokeRestart("muffleWarning")
[17:42:28.217]                     }
[17:42:28.217]                     else if (inherits(cond, "condition")) {
[17:42:28.217]                       if (!is.null(pattern)) {
[17:42:28.217]                         computeRestarts <- base::computeRestarts
[17:42:28.217]                         grepl <- base::grepl
[17:42:28.217]                         restarts <- computeRestarts(cond)
[17:42:28.217]                         for (restart in restarts) {
[17:42:28.217]                           name <- restart$name
[17:42:28.217]                           if (is.null(name)) 
[17:42:28.217]                             next
[17:42:28.217]                           if (!grepl(pattern, name)) 
[17:42:28.217]                             next
[17:42:28.217]                           invokeRestart(restart)
[17:42:28.217]                           muffled <- TRUE
[17:42:28.217]                           break
[17:42:28.217]                         }
[17:42:28.217]                       }
[17:42:28.217]                     }
[17:42:28.217]                     invisible(muffled)
[17:42:28.217]                   }
[17:42:28.217]                   muffleCondition(cond)
[17:42:28.217]                 })
[17:42:28.217]             }))
[17:42:28.217]             future::FutureResult(value = ...future.value$value, 
[17:42:28.217]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:28.217]                   ...future.rng), globalenv = if (FALSE) 
[17:42:28.217]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:28.217]                     ...future.globalenv.names))
[17:42:28.217]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:28.217]         }, condition = base::local({
[17:42:28.217]             c <- base::c
[17:42:28.217]             inherits <- base::inherits
[17:42:28.217]             invokeRestart <- base::invokeRestart
[17:42:28.217]             length <- base::length
[17:42:28.217]             list <- base::list
[17:42:28.217]             seq.int <- base::seq.int
[17:42:28.217]             signalCondition <- base::signalCondition
[17:42:28.217]             sys.calls <- base::sys.calls
[17:42:28.217]             `[[` <- base::`[[`
[17:42:28.217]             `+` <- base::`+`
[17:42:28.217]             `<<-` <- base::`<<-`
[17:42:28.217]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:28.217]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:28.217]                   3L)]
[17:42:28.217]             }
[17:42:28.217]             function(cond) {
[17:42:28.217]                 is_error <- inherits(cond, "error")
[17:42:28.217]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:28.217]                   NULL)
[17:42:28.217]                 if (is_error) {
[17:42:28.217]                   sessionInformation <- function() {
[17:42:28.217]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:28.217]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:28.217]                       search = base::search(), system = base::Sys.info())
[17:42:28.217]                   }
[17:42:28.217]                   ...future.conditions[[length(...future.conditions) + 
[17:42:28.217]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:28.217]                     cond$call), session = sessionInformation(), 
[17:42:28.217]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:28.217]                   signalCondition(cond)
[17:42:28.217]                 }
[17:42:28.217]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:28.217]                 "immediateCondition"))) {
[17:42:28.217]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:28.217]                   ...future.conditions[[length(...future.conditions) + 
[17:42:28.217]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:28.217]                   if (TRUE && !signal) {
[17:42:28.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:28.217]                     {
[17:42:28.217]                       inherits <- base::inherits
[17:42:28.217]                       invokeRestart <- base::invokeRestart
[17:42:28.217]                       is.null <- base::is.null
[17:42:28.217]                       muffled <- FALSE
[17:42:28.217]                       if (inherits(cond, "message")) {
[17:42:28.217]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:28.217]                         if (muffled) 
[17:42:28.217]                           invokeRestart("muffleMessage")
[17:42:28.217]                       }
[17:42:28.217]                       else if (inherits(cond, "warning")) {
[17:42:28.217]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:28.217]                         if (muffled) 
[17:42:28.217]                           invokeRestart("muffleWarning")
[17:42:28.217]                       }
[17:42:28.217]                       else if (inherits(cond, "condition")) {
[17:42:28.217]                         if (!is.null(pattern)) {
[17:42:28.217]                           computeRestarts <- base::computeRestarts
[17:42:28.217]                           grepl <- base::grepl
[17:42:28.217]                           restarts <- computeRestarts(cond)
[17:42:28.217]                           for (restart in restarts) {
[17:42:28.217]                             name <- restart$name
[17:42:28.217]                             if (is.null(name)) 
[17:42:28.217]                               next
[17:42:28.217]                             if (!grepl(pattern, name)) 
[17:42:28.217]                               next
[17:42:28.217]                             invokeRestart(restart)
[17:42:28.217]                             muffled <- TRUE
[17:42:28.217]                             break
[17:42:28.217]                           }
[17:42:28.217]                         }
[17:42:28.217]                       }
[17:42:28.217]                       invisible(muffled)
[17:42:28.217]                     }
[17:42:28.217]                     muffleCondition(cond, pattern = "^muffle")
[17:42:28.217]                   }
[17:42:28.217]                 }
[17:42:28.217]                 else {
[17:42:28.217]                   if (TRUE) {
[17:42:28.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:28.217]                     {
[17:42:28.217]                       inherits <- base::inherits
[17:42:28.217]                       invokeRestart <- base::invokeRestart
[17:42:28.217]                       is.null <- base::is.null
[17:42:28.217]                       muffled <- FALSE
[17:42:28.217]                       if (inherits(cond, "message")) {
[17:42:28.217]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:28.217]                         if (muffled) 
[17:42:28.217]                           invokeRestart("muffleMessage")
[17:42:28.217]                       }
[17:42:28.217]                       else if (inherits(cond, "warning")) {
[17:42:28.217]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:28.217]                         if (muffled) 
[17:42:28.217]                           invokeRestart("muffleWarning")
[17:42:28.217]                       }
[17:42:28.217]                       else if (inherits(cond, "condition")) {
[17:42:28.217]                         if (!is.null(pattern)) {
[17:42:28.217]                           computeRestarts <- base::computeRestarts
[17:42:28.217]                           grepl <- base::grepl
[17:42:28.217]                           restarts <- computeRestarts(cond)
[17:42:28.217]                           for (restart in restarts) {
[17:42:28.217]                             name <- restart$name
[17:42:28.217]                             if (is.null(name)) 
[17:42:28.217]                               next
[17:42:28.217]                             if (!grepl(pattern, name)) 
[17:42:28.217]                               next
[17:42:28.217]                             invokeRestart(restart)
[17:42:28.217]                             muffled <- TRUE
[17:42:28.217]                             break
[17:42:28.217]                           }
[17:42:28.217]                         }
[17:42:28.217]                       }
[17:42:28.217]                       invisible(muffled)
[17:42:28.217]                     }
[17:42:28.217]                     muffleCondition(cond, pattern = "^muffle")
[17:42:28.217]                   }
[17:42:28.217]                 }
[17:42:28.217]             }
[17:42:28.217]         }))
[17:42:28.217]     }, error = function(ex) {
[17:42:28.217]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:28.217]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:28.217]                 ...future.rng), started = ...future.startTime, 
[17:42:28.217]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:28.217]             version = "1.8"), class = "FutureResult")
[17:42:28.217]     }, finally = {
[17:42:28.217]         if (!identical(...future.workdir, getwd())) 
[17:42:28.217]             setwd(...future.workdir)
[17:42:28.217]         {
[17:42:28.217]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:28.217]                 ...future.oldOptions$nwarnings <- NULL
[17:42:28.217]             }
[17:42:28.217]             base::options(...future.oldOptions)
[17:42:28.217]             if (.Platform$OS.type == "windows") {
[17:42:28.217]                 old_names <- names(...future.oldEnvVars)
[17:42:28.217]                 envs <- base::Sys.getenv()
[17:42:28.217]                 names <- names(envs)
[17:42:28.217]                 common <- intersect(names, old_names)
[17:42:28.217]                 added <- setdiff(names, old_names)
[17:42:28.217]                 removed <- setdiff(old_names, names)
[17:42:28.217]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:28.217]                   envs[common]]
[17:42:28.217]                 NAMES <- toupper(changed)
[17:42:28.217]                 args <- list()
[17:42:28.217]                 for (kk in seq_along(NAMES)) {
[17:42:28.217]                   name <- changed[[kk]]
[17:42:28.217]                   NAME <- NAMES[[kk]]
[17:42:28.217]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:28.217]                     next
[17:42:28.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:28.217]                 }
[17:42:28.217]                 NAMES <- toupper(added)
[17:42:28.217]                 for (kk in seq_along(NAMES)) {
[17:42:28.217]                   name <- added[[kk]]
[17:42:28.217]                   NAME <- NAMES[[kk]]
[17:42:28.217]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:28.217]                     next
[17:42:28.217]                   args[[name]] <- ""
[17:42:28.217]                 }
[17:42:28.217]                 NAMES <- toupper(removed)
[17:42:28.217]                 for (kk in seq_along(NAMES)) {
[17:42:28.217]                   name <- removed[[kk]]
[17:42:28.217]                   NAME <- NAMES[[kk]]
[17:42:28.217]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:28.217]                     next
[17:42:28.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:28.217]                 }
[17:42:28.217]                 if (length(args) > 0) 
[17:42:28.217]                   base::do.call(base::Sys.setenv, args = args)
[17:42:28.217]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:28.217]             }
[17:42:28.217]             else {
[17:42:28.217]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:28.217]             }
[17:42:28.217]             {
[17:42:28.217]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:28.217]                   0L) {
[17:42:28.217]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:28.217]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:28.217]                   base::options(opts)
[17:42:28.217]                 }
[17:42:28.217]                 {
[17:42:28.217]                   {
[17:42:28.217]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:28.217]                     NULL
[17:42:28.217]                   }
[17:42:28.217]                   options(future.plan = NULL)
[17:42:28.217]                   if (is.na(NA_character_)) 
[17:42:28.217]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:28.217]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:28.217]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:28.217]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:28.217]                     envir = parent.frame()) 
[17:42:28.217]                   {
[17:42:28.217]                     if (is.function(workers)) 
[17:42:28.217]                       workers <- workers()
[17:42:28.217]                     workers <- structure(as.integer(workers), 
[17:42:28.217]                       class = class(workers))
[17:42:28.217]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:28.217]                       workers >= 1)
[17:42:28.217]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:28.217]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:28.217]                     }
[17:42:28.217]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:28.217]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:28.217]                       envir = envir)
[17:42:28.217]                     if (!future$lazy) 
[17:42:28.217]                       future <- run(future)
[17:42:28.217]                     invisible(future)
[17:42:28.217]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:28.217]                 }
[17:42:28.217]             }
[17:42:28.217]         }
[17:42:28.217]     })
[17:42:28.217]     if (TRUE) {
[17:42:28.217]         base::sink(type = "output", split = FALSE)
[17:42:28.217]         if (TRUE) {
[17:42:28.217]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:28.217]         }
[17:42:28.217]         else {
[17:42:28.217]             ...future.result["stdout"] <- base::list(NULL)
[17:42:28.217]         }
[17:42:28.217]         base::close(...future.stdout)
[17:42:28.217]         ...future.stdout <- NULL
[17:42:28.217]     }
[17:42:28.217]     ...future.result$conditions <- ...future.conditions
[17:42:28.217]     ...future.result$finished <- base::Sys.time()
[17:42:28.217]     ...future.result
[17:42:28.217] }
[17:42:28.220] MultisessionFuture started
[17:42:28.220] - Launch lazy future ... done
[17:42:28.220] run() for ‘MultisessionFuture’ ... done
[17:42:28.220] result() for ClusterFuture ...
[17:42:28.221] receiveMessageFromWorker() for ClusterFuture ...
[17:42:28.221] - Validating connection of MultisessionFuture
[17:42:28.270] - received message: FutureResult
[17:42:28.271] - Received FutureResult
[17:42:28.271] - Erased future from FutureRegistry
[17:42:28.271] result() for ClusterFuture ...
[17:42:28.271] - result already collected: FutureResult
[17:42:28.271] result() for ClusterFuture ... done
[17:42:28.271] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:28.271] result() for ClusterFuture ... done
[17:42:28.271] result() for ClusterFuture ...
[17:42:28.272] - result already collected: FutureResult
[17:42:28.272] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[17:42:28.273] getGlobalsAndPackages() ...
[17:42:28.274] Searching for globals...
[17:42:28.278] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[17:42:28.278] Searching for globals ... DONE
[17:42:28.278] Resolving globals: FALSE
[17:42:28.279] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[17:42:28.279] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[17:42:28.279] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[17:42:28.279] 
[17:42:28.279] getGlobalsAndPackages() ... DONE
[17:42:28.280] run() for ‘Future’ ...
[17:42:28.280] - state: ‘created’
[17:42:28.280] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:28.294] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:28.294] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:28.294]   - Field: ‘node’
[17:42:28.295]   - Field: ‘label’
[17:42:28.295]   - Field: ‘local’
[17:42:28.295]   - Field: ‘owner’
[17:42:28.295]   - Field: ‘envir’
[17:42:28.295]   - Field: ‘workers’
[17:42:28.295]   - Field: ‘packages’
[17:42:28.297]   - Field: ‘gc’
[17:42:28.297]   - Field: ‘conditions’
[17:42:28.297]   - Field: ‘persistent’
[17:42:28.297]   - Field: ‘expr’
[17:42:28.297]   - Field: ‘uuid’
[17:42:28.298]   - Field: ‘seed’
[17:42:28.298]   - Field: ‘version’
[17:42:28.298]   - Field: ‘result’
[17:42:28.298]   - Field: ‘asynchronous’
[17:42:28.298]   - Field: ‘calls’
[17:42:28.298]   - Field: ‘globals’
[17:42:28.298]   - Field: ‘stdout’
[17:42:28.298]   - Field: ‘earlySignal’
[17:42:28.298]   - Field: ‘lazy’
[17:42:28.298]   - Field: ‘state’
[17:42:28.298] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:28.299] - Launch lazy future ...
[17:42:28.299] Packages needed by the future expression (n = 0): <none>
[17:42:28.299] Packages needed by future strategies (n = 0): <none>
[17:42:28.299] {
[17:42:28.299]     {
[17:42:28.299]         {
[17:42:28.299]             ...future.startTime <- base::Sys.time()
[17:42:28.299]             {
[17:42:28.299]                 {
[17:42:28.299]                   {
[17:42:28.299]                     {
[17:42:28.299]                       base::local({
[17:42:28.299]                         has_future <- base::requireNamespace("future", 
[17:42:28.299]                           quietly = TRUE)
[17:42:28.299]                         if (has_future) {
[17:42:28.299]                           ns <- base::getNamespace("future")
[17:42:28.299]                           version <- ns[[".package"]][["version"]]
[17:42:28.299]                           if (is.null(version)) 
[17:42:28.299]                             version <- utils::packageVersion("future")
[17:42:28.299]                         }
[17:42:28.299]                         else {
[17:42:28.299]                           version <- NULL
[17:42:28.299]                         }
[17:42:28.299]                         if (!has_future || version < "1.8.0") {
[17:42:28.299]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:28.299]                             "", base::R.version$version.string), 
[17:42:28.299]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:28.299]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:28.299]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:28.299]                               "release", "version")], collapse = " "), 
[17:42:28.299]                             hostname = base::Sys.info()[["nodename"]])
[17:42:28.299]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:28.299]                             info)
[17:42:28.299]                           info <- base::paste(info, collapse = "; ")
[17:42:28.299]                           if (!has_future) {
[17:42:28.299]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:28.299]                               info)
[17:42:28.299]                           }
[17:42:28.299]                           else {
[17:42:28.299]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:28.299]                               info, version)
[17:42:28.299]                           }
[17:42:28.299]                           base::stop(msg)
[17:42:28.299]                         }
[17:42:28.299]                       })
[17:42:28.299]                     }
[17:42:28.299]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:28.299]                     base::options(mc.cores = 1L)
[17:42:28.299]                   }
[17:42:28.299]                   options(future.plan = NULL)
[17:42:28.299]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:28.299]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:28.299]                 }
[17:42:28.299]                 ...future.workdir <- getwd()
[17:42:28.299]             }
[17:42:28.299]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:28.299]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:28.299]         }
[17:42:28.299]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:28.299]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:28.299]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:28.299]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:28.299]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:28.299]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:28.299]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:28.299]             base::names(...future.oldOptions))
[17:42:28.299]     }
[17:42:28.299]     if (FALSE) {
[17:42:28.299]     }
[17:42:28.299]     else {
[17:42:28.299]         if (TRUE) {
[17:42:28.299]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:28.299]                 open = "w")
[17:42:28.299]         }
[17:42:28.299]         else {
[17:42:28.299]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:28.299]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:28.299]         }
[17:42:28.299]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:28.299]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:28.299]             base::sink(type = "output", split = FALSE)
[17:42:28.299]             base::close(...future.stdout)
[17:42:28.299]         }, add = TRUE)
[17:42:28.299]     }
[17:42:28.299]     ...future.frame <- base::sys.nframe()
[17:42:28.299]     ...future.conditions <- base::list()
[17:42:28.299]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:28.299]     if (FALSE) {
[17:42:28.299]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:28.299]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:28.299]     }
[17:42:28.299]     ...future.result <- base::tryCatch({
[17:42:28.299]         base::withCallingHandlers({
[17:42:28.299]             ...future.value <- base::withVisible(base::local({
[17:42:28.299]                 ...future.makeSendCondition <- local({
[17:42:28.299]                   sendCondition <- NULL
[17:42:28.299]                   function(frame = 1L) {
[17:42:28.299]                     if (is.function(sendCondition)) 
[17:42:28.299]                       return(sendCondition)
[17:42:28.299]                     ns <- getNamespace("parallel")
[17:42:28.299]                     if (exists("sendData", mode = "function", 
[17:42:28.299]                       envir = ns)) {
[17:42:28.299]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:28.299]                         envir = ns)
[17:42:28.299]                       envir <- sys.frame(frame)
[17:42:28.299]                       master <- NULL
[17:42:28.299]                       while (!identical(envir, .GlobalEnv) && 
[17:42:28.299]                         !identical(envir, emptyenv())) {
[17:42:28.299]                         if (exists("master", mode = "list", envir = envir, 
[17:42:28.299]                           inherits = FALSE)) {
[17:42:28.299]                           master <- get("master", mode = "list", 
[17:42:28.299]                             envir = envir, inherits = FALSE)
[17:42:28.299]                           if (inherits(master, c("SOCKnode", 
[17:42:28.299]                             "SOCK0node"))) {
[17:42:28.299]                             sendCondition <<- function(cond) {
[17:42:28.299]                               data <- list(type = "VALUE", value = cond, 
[17:42:28.299]                                 success = TRUE)
[17:42:28.299]                               parallel_sendData(master, data)
[17:42:28.299]                             }
[17:42:28.299]                             return(sendCondition)
[17:42:28.299]                           }
[17:42:28.299]                         }
[17:42:28.299]                         frame <- frame + 1L
[17:42:28.299]                         envir <- sys.frame(frame)
[17:42:28.299]                       }
[17:42:28.299]                     }
[17:42:28.299]                     sendCondition <<- function(cond) NULL
[17:42:28.299]                   }
[17:42:28.299]                 })
[17:42:28.299]                 withCallingHandlers({
[17:42:28.299]                   {
[17:42:28.299]                     outer_function(1L)
[17:42:28.299]                   }
[17:42:28.299]                 }, immediateCondition = function(cond) {
[17:42:28.299]                   sendCondition <- ...future.makeSendCondition()
[17:42:28.299]                   sendCondition(cond)
[17:42:28.299]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:28.299]                   {
[17:42:28.299]                     inherits <- base::inherits
[17:42:28.299]                     invokeRestart <- base::invokeRestart
[17:42:28.299]                     is.null <- base::is.null
[17:42:28.299]                     muffled <- FALSE
[17:42:28.299]                     if (inherits(cond, "message")) {
[17:42:28.299]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:28.299]                       if (muffled) 
[17:42:28.299]                         invokeRestart("muffleMessage")
[17:42:28.299]                     }
[17:42:28.299]                     else if (inherits(cond, "warning")) {
[17:42:28.299]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:28.299]                       if (muffled) 
[17:42:28.299]                         invokeRestart("muffleWarning")
[17:42:28.299]                     }
[17:42:28.299]                     else if (inherits(cond, "condition")) {
[17:42:28.299]                       if (!is.null(pattern)) {
[17:42:28.299]                         computeRestarts <- base::computeRestarts
[17:42:28.299]                         grepl <- base::grepl
[17:42:28.299]                         restarts <- computeRestarts(cond)
[17:42:28.299]                         for (restart in restarts) {
[17:42:28.299]                           name <- restart$name
[17:42:28.299]                           if (is.null(name)) 
[17:42:28.299]                             next
[17:42:28.299]                           if (!grepl(pattern, name)) 
[17:42:28.299]                             next
[17:42:28.299]                           invokeRestart(restart)
[17:42:28.299]                           muffled <- TRUE
[17:42:28.299]                           break
[17:42:28.299]                         }
[17:42:28.299]                       }
[17:42:28.299]                     }
[17:42:28.299]                     invisible(muffled)
[17:42:28.299]                   }
[17:42:28.299]                   muffleCondition(cond)
[17:42:28.299]                 })
[17:42:28.299]             }))
[17:42:28.299]             future::FutureResult(value = ...future.value$value, 
[17:42:28.299]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:28.299]                   ...future.rng), globalenv = if (FALSE) 
[17:42:28.299]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:28.299]                     ...future.globalenv.names))
[17:42:28.299]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:28.299]         }, condition = base::local({
[17:42:28.299]             c <- base::c
[17:42:28.299]             inherits <- base::inherits
[17:42:28.299]             invokeRestart <- base::invokeRestart
[17:42:28.299]             length <- base::length
[17:42:28.299]             list <- base::list
[17:42:28.299]             seq.int <- base::seq.int
[17:42:28.299]             signalCondition <- base::signalCondition
[17:42:28.299]             sys.calls <- base::sys.calls
[17:42:28.299]             `[[` <- base::`[[`
[17:42:28.299]             `+` <- base::`+`
[17:42:28.299]             `<<-` <- base::`<<-`
[17:42:28.299]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:28.299]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:28.299]                   3L)]
[17:42:28.299]             }
[17:42:28.299]             function(cond) {
[17:42:28.299]                 is_error <- inherits(cond, "error")
[17:42:28.299]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:28.299]                   NULL)
[17:42:28.299]                 if (is_error) {
[17:42:28.299]                   sessionInformation <- function() {
[17:42:28.299]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:28.299]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:28.299]                       search = base::search(), system = base::Sys.info())
[17:42:28.299]                   }
[17:42:28.299]                   ...future.conditions[[length(...future.conditions) + 
[17:42:28.299]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:28.299]                     cond$call), session = sessionInformation(), 
[17:42:28.299]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:28.299]                   signalCondition(cond)
[17:42:28.299]                 }
[17:42:28.299]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:28.299]                 "immediateCondition"))) {
[17:42:28.299]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:28.299]                   ...future.conditions[[length(...future.conditions) + 
[17:42:28.299]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:28.299]                   if (TRUE && !signal) {
[17:42:28.299]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:28.299]                     {
[17:42:28.299]                       inherits <- base::inherits
[17:42:28.299]                       invokeRestart <- base::invokeRestart
[17:42:28.299]                       is.null <- base::is.null
[17:42:28.299]                       muffled <- FALSE
[17:42:28.299]                       if (inherits(cond, "message")) {
[17:42:28.299]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:28.299]                         if (muffled) 
[17:42:28.299]                           invokeRestart("muffleMessage")
[17:42:28.299]                       }
[17:42:28.299]                       else if (inherits(cond, "warning")) {
[17:42:28.299]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:28.299]                         if (muffled) 
[17:42:28.299]                           invokeRestart("muffleWarning")
[17:42:28.299]                       }
[17:42:28.299]                       else if (inherits(cond, "condition")) {
[17:42:28.299]                         if (!is.null(pattern)) {
[17:42:28.299]                           computeRestarts <- base::computeRestarts
[17:42:28.299]                           grepl <- base::grepl
[17:42:28.299]                           restarts <- computeRestarts(cond)
[17:42:28.299]                           for (restart in restarts) {
[17:42:28.299]                             name <- restart$name
[17:42:28.299]                             if (is.null(name)) 
[17:42:28.299]                               next
[17:42:28.299]                             if (!grepl(pattern, name)) 
[17:42:28.299]                               next
[17:42:28.299]                             invokeRestart(restart)
[17:42:28.299]                             muffled <- TRUE
[17:42:28.299]                             break
[17:42:28.299]                           }
[17:42:28.299]                         }
[17:42:28.299]                       }
[17:42:28.299]                       invisible(muffled)
[17:42:28.299]                     }
[17:42:28.299]                     muffleCondition(cond, pattern = "^muffle")
[17:42:28.299]                   }
[17:42:28.299]                 }
[17:42:28.299]                 else {
[17:42:28.299]                   if (TRUE) {
[17:42:28.299]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:28.299]                     {
[17:42:28.299]                       inherits <- base::inherits
[17:42:28.299]                       invokeRestart <- base::invokeRestart
[17:42:28.299]                       is.null <- base::is.null
[17:42:28.299]                       muffled <- FALSE
[17:42:28.299]                       if (inherits(cond, "message")) {
[17:42:28.299]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:28.299]                         if (muffled) 
[17:42:28.299]                           invokeRestart("muffleMessage")
[17:42:28.299]                       }
[17:42:28.299]                       else if (inherits(cond, "warning")) {
[17:42:28.299]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:28.299]                         if (muffled) 
[17:42:28.299]                           invokeRestart("muffleWarning")
[17:42:28.299]                       }
[17:42:28.299]                       else if (inherits(cond, "condition")) {
[17:42:28.299]                         if (!is.null(pattern)) {
[17:42:28.299]                           computeRestarts <- base::computeRestarts
[17:42:28.299]                           grepl <- base::grepl
[17:42:28.299]                           restarts <- computeRestarts(cond)
[17:42:28.299]                           for (restart in restarts) {
[17:42:28.299]                             name <- restart$name
[17:42:28.299]                             if (is.null(name)) 
[17:42:28.299]                               next
[17:42:28.299]                             if (!grepl(pattern, name)) 
[17:42:28.299]                               next
[17:42:28.299]                             invokeRestart(restart)
[17:42:28.299]                             muffled <- TRUE
[17:42:28.299]                             break
[17:42:28.299]                           }
[17:42:28.299]                         }
[17:42:28.299]                       }
[17:42:28.299]                       invisible(muffled)
[17:42:28.299]                     }
[17:42:28.299]                     muffleCondition(cond, pattern = "^muffle")
[17:42:28.299]                   }
[17:42:28.299]                 }
[17:42:28.299]             }
[17:42:28.299]         }))
[17:42:28.299]     }, error = function(ex) {
[17:42:28.299]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:28.299]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:28.299]                 ...future.rng), started = ...future.startTime, 
[17:42:28.299]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:28.299]             version = "1.8"), class = "FutureResult")
[17:42:28.299]     }, finally = {
[17:42:28.299]         if (!identical(...future.workdir, getwd())) 
[17:42:28.299]             setwd(...future.workdir)
[17:42:28.299]         {
[17:42:28.299]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:28.299]                 ...future.oldOptions$nwarnings <- NULL
[17:42:28.299]             }
[17:42:28.299]             base::options(...future.oldOptions)
[17:42:28.299]             if (.Platform$OS.type == "windows") {
[17:42:28.299]                 old_names <- names(...future.oldEnvVars)
[17:42:28.299]                 envs <- base::Sys.getenv()
[17:42:28.299]                 names <- names(envs)
[17:42:28.299]                 common <- intersect(names, old_names)
[17:42:28.299]                 added <- setdiff(names, old_names)
[17:42:28.299]                 removed <- setdiff(old_names, names)
[17:42:28.299]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:28.299]                   envs[common]]
[17:42:28.299]                 NAMES <- toupper(changed)
[17:42:28.299]                 args <- list()
[17:42:28.299]                 for (kk in seq_along(NAMES)) {
[17:42:28.299]                   name <- changed[[kk]]
[17:42:28.299]                   NAME <- NAMES[[kk]]
[17:42:28.299]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:28.299]                     next
[17:42:28.299]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:28.299]                 }
[17:42:28.299]                 NAMES <- toupper(added)
[17:42:28.299]                 for (kk in seq_along(NAMES)) {
[17:42:28.299]                   name <- added[[kk]]
[17:42:28.299]                   NAME <- NAMES[[kk]]
[17:42:28.299]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:28.299]                     next
[17:42:28.299]                   args[[name]] <- ""
[17:42:28.299]                 }
[17:42:28.299]                 NAMES <- toupper(removed)
[17:42:28.299]                 for (kk in seq_along(NAMES)) {
[17:42:28.299]                   name <- removed[[kk]]
[17:42:28.299]                   NAME <- NAMES[[kk]]
[17:42:28.299]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:28.299]                     next
[17:42:28.299]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:28.299]                 }
[17:42:28.299]                 if (length(args) > 0) 
[17:42:28.299]                   base::do.call(base::Sys.setenv, args = args)
[17:42:28.299]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:28.299]             }
[17:42:28.299]             else {
[17:42:28.299]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:28.299]             }
[17:42:28.299]             {
[17:42:28.299]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:28.299]                   0L) {
[17:42:28.299]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:28.299]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:28.299]                   base::options(opts)
[17:42:28.299]                 }
[17:42:28.299]                 {
[17:42:28.299]                   {
[17:42:28.299]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:28.299]                     NULL
[17:42:28.299]                   }
[17:42:28.299]                   options(future.plan = NULL)
[17:42:28.299]                   if (is.na(NA_character_)) 
[17:42:28.299]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:28.299]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:28.299]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:28.299]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:28.299]                     envir = parent.frame()) 
[17:42:28.299]                   {
[17:42:28.299]                     if (is.function(workers)) 
[17:42:28.299]                       workers <- workers()
[17:42:28.299]                     workers <- structure(as.integer(workers), 
[17:42:28.299]                       class = class(workers))
[17:42:28.299]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:28.299]                       workers >= 1)
[17:42:28.299]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:28.299]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:28.299]                     }
[17:42:28.299]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:28.299]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:28.299]                       envir = envir)
[17:42:28.299]                     if (!future$lazy) 
[17:42:28.299]                       future <- run(future)
[17:42:28.299]                     invisible(future)
[17:42:28.299]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:28.299]                 }
[17:42:28.299]             }
[17:42:28.299]         }
[17:42:28.299]     })
[17:42:28.299]     if (TRUE) {
[17:42:28.299]         base::sink(type = "output", split = FALSE)
[17:42:28.299]         if (TRUE) {
[17:42:28.299]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:28.299]         }
[17:42:28.299]         else {
[17:42:28.299]             ...future.result["stdout"] <- base::list(NULL)
[17:42:28.299]         }
[17:42:28.299]         base::close(...future.stdout)
[17:42:28.299]         ...future.stdout <- NULL
[17:42:28.299]     }
[17:42:28.299]     ...future.result$conditions <- ...future.conditions
[17:42:28.299]     ...future.result$finished <- base::Sys.time()
[17:42:28.299]     ...future.result
[17:42:28.299] }
[17:42:28.302] Exporting 3 global objects (7.52 KiB) to cluster node #1 ...
[17:42:28.302] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ...
[17:42:28.303] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ... DONE
[17:42:28.303] Exporting ‘map’ (4.43 KiB) to cluster node #1 ...
[17:42:28.303] Exporting ‘map’ (4.43 KiB) to cluster node #1 ... DONE
[17:42:28.303] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ...
[17:42:28.304] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ... DONE
[17:42:28.304] Exporting 3 global objects (7.52 KiB) to cluster node #1 ... DONE
[17:42:28.304] MultisessionFuture started
[17:42:28.304] - Launch lazy future ... done
[17:42:28.305] run() for ‘MultisessionFuture’ ... done
[17:42:28.305] result() for ClusterFuture ...
[17:42:28.305] receiveMessageFromWorker() for ClusterFuture ...
[17:42:28.305] - Validating connection of MultisessionFuture
[17:42:28.356] - received message: FutureResult
[17:42:28.357] - Received FutureResult
[17:42:28.357] - Erased future from FutureRegistry
[17:42:28.357] result() for ClusterFuture ...
[17:42:28.357] - result already collected: FutureResult
[17:42:28.357] result() for ClusterFuture ... done
[17:42:28.357] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:28.357] result() for ClusterFuture ... done
[17:42:28.357] result() for ClusterFuture ...
[17:42:28.358] - result already collected: FutureResult
[17:42:28.358] result() for ClusterFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[17:42:28.359] getGlobalsAndPackages() ...
[17:42:28.359] Searching for globals...
[17:42:28.363] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[17:42:28.363] Searching for globals ... DONE
[17:42:28.364] Resolving globals: FALSE
[17:42:28.364] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[17:42:28.365] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[17:42:28.365] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[17:42:28.365] 
[17:42:28.365] getGlobalsAndPackages() ... DONE
[17:42:28.365] run() for ‘Future’ ...
[17:42:28.365] - state: ‘created’
[17:42:28.366] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:28.380] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:28.380] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:28.381]   - Field: ‘node’
[17:42:28.381]   - Field: ‘label’
[17:42:28.381]   - Field: ‘local’
[17:42:28.381]   - Field: ‘owner’
[17:42:28.381]   - Field: ‘envir’
[17:42:28.381]   - Field: ‘workers’
[17:42:28.381]   - Field: ‘packages’
[17:42:28.381]   - Field: ‘gc’
[17:42:28.381]   - Field: ‘conditions’
[17:42:28.382]   - Field: ‘persistent’
[17:42:28.382]   - Field: ‘expr’
[17:42:28.382]   - Field: ‘uuid’
[17:42:28.382]   - Field: ‘seed’
[17:42:28.382]   - Field: ‘version’
[17:42:28.382]   - Field: ‘result’
[17:42:28.382]   - Field: ‘asynchronous’
[17:42:28.382]   - Field: ‘calls’
[17:42:28.382]   - Field: ‘globals’
[17:42:28.382]   - Field: ‘stdout’
[17:42:28.382]   - Field: ‘earlySignal’
[17:42:28.383]   - Field: ‘lazy’
[17:42:28.383]   - Field: ‘state’
[17:42:28.383] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:28.383] - Launch lazy future ...
[17:42:28.383] Packages needed by the future expression (n = 0): <none>
[17:42:28.383] Packages needed by future strategies (n = 0): <none>
[17:42:28.384] {
[17:42:28.384]     {
[17:42:28.384]         {
[17:42:28.384]             ...future.startTime <- base::Sys.time()
[17:42:28.384]             {
[17:42:28.384]                 {
[17:42:28.384]                   {
[17:42:28.384]                     {
[17:42:28.384]                       base::local({
[17:42:28.384]                         has_future <- base::requireNamespace("future", 
[17:42:28.384]                           quietly = TRUE)
[17:42:28.384]                         if (has_future) {
[17:42:28.384]                           ns <- base::getNamespace("future")
[17:42:28.384]                           version <- ns[[".package"]][["version"]]
[17:42:28.384]                           if (is.null(version)) 
[17:42:28.384]                             version <- utils::packageVersion("future")
[17:42:28.384]                         }
[17:42:28.384]                         else {
[17:42:28.384]                           version <- NULL
[17:42:28.384]                         }
[17:42:28.384]                         if (!has_future || version < "1.8.0") {
[17:42:28.384]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:28.384]                             "", base::R.version$version.string), 
[17:42:28.384]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:28.384]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:28.384]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:28.384]                               "release", "version")], collapse = " "), 
[17:42:28.384]                             hostname = base::Sys.info()[["nodename"]])
[17:42:28.384]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:28.384]                             info)
[17:42:28.384]                           info <- base::paste(info, collapse = "; ")
[17:42:28.384]                           if (!has_future) {
[17:42:28.384]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:28.384]                               info)
[17:42:28.384]                           }
[17:42:28.384]                           else {
[17:42:28.384]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:28.384]                               info, version)
[17:42:28.384]                           }
[17:42:28.384]                           base::stop(msg)
[17:42:28.384]                         }
[17:42:28.384]                       })
[17:42:28.384]                     }
[17:42:28.384]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:28.384]                     base::options(mc.cores = 1L)
[17:42:28.384]                   }
[17:42:28.384]                   options(future.plan = NULL)
[17:42:28.384]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:28.384]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:28.384]                 }
[17:42:28.384]                 ...future.workdir <- getwd()
[17:42:28.384]             }
[17:42:28.384]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:28.384]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:28.384]         }
[17:42:28.384]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:28.384]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:28.384]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:28.384]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:28.384]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:28.384]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:28.384]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:28.384]             base::names(...future.oldOptions))
[17:42:28.384]     }
[17:42:28.384]     if (FALSE) {
[17:42:28.384]     }
[17:42:28.384]     else {
[17:42:28.384]         if (TRUE) {
[17:42:28.384]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:28.384]                 open = "w")
[17:42:28.384]         }
[17:42:28.384]         else {
[17:42:28.384]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:28.384]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:28.384]         }
[17:42:28.384]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:28.384]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:28.384]             base::sink(type = "output", split = FALSE)
[17:42:28.384]             base::close(...future.stdout)
[17:42:28.384]         }, add = TRUE)
[17:42:28.384]     }
[17:42:28.384]     ...future.frame <- base::sys.nframe()
[17:42:28.384]     ...future.conditions <- base::list()
[17:42:28.384]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:28.384]     if (FALSE) {
[17:42:28.384]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:28.384]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:28.384]     }
[17:42:28.384]     ...future.result <- base::tryCatch({
[17:42:28.384]         base::withCallingHandlers({
[17:42:28.384]             ...future.value <- base::withVisible(base::local({
[17:42:28.384]                 ...future.makeSendCondition <- local({
[17:42:28.384]                   sendCondition <- NULL
[17:42:28.384]                   function(frame = 1L) {
[17:42:28.384]                     if (is.function(sendCondition)) 
[17:42:28.384]                       return(sendCondition)
[17:42:28.384]                     ns <- getNamespace("parallel")
[17:42:28.384]                     if (exists("sendData", mode = "function", 
[17:42:28.384]                       envir = ns)) {
[17:42:28.384]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:28.384]                         envir = ns)
[17:42:28.384]                       envir <- sys.frame(frame)
[17:42:28.384]                       master <- NULL
[17:42:28.384]                       while (!identical(envir, .GlobalEnv) && 
[17:42:28.384]                         !identical(envir, emptyenv())) {
[17:42:28.384]                         if (exists("master", mode = "list", envir = envir, 
[17:42:28.384]                           inherits = FALSE)) {
[17:42:28.384]                           master <- get("master", mode = "list", 
[17:42:28.384]                             envir = envir, inherits = FALSE)
[17:42:28.384]                           if (inherits(master, c("SOCKnode", 
[17:42:28.384]                             "SOCK0node"))) {
[17:42:28.384]                             sendCondition <<- function(cond) {
[17:42:28.384]                               data <- list(type = "VALUE", value = cond, 
[17:42:28.384]                                 success = TRUE)
[17:42:28.384]                               parallel_sendData(master, data)
[17:42:28.384]                             }
[17:42:28.384]                             return(sendCondition)
[17:42:28.384]                           }
[17:42:28.384]                         }
[17:42:28.384]                         frame <- frame + 1L
[17:42:28.384]                         envir <- sys.frame(frame)
[17:42:28.384]                       }
[17:42:28.384]                     }
[17:42:28.384]                     sendCondition <<- function(cond) NULL
[17:42:28.384]                   }
[17:42:28.384]                 })
[17:42:28.384]                 withCallingHandlers({
[17:42:28.384]                   {
[17:42:28.384]                     outer_function(1L)
[17:42:28.384]                   }
[17:42:28.384]                 }, immediateCondition = function(cond) {
[17:42:28.384]                   sendCondition <- ...future.makeSendCondition()
[17:42:28.384]                   sendCondition(cond)
[17:42:28.384]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:28.384]                   {
[17:42:28.384]                     inherits <- base::inherits
[17:42:28.384]                     invokeRestart <- base::invokeRestart
[17:42:28.384]                     is.null <- base::is.null
[17:42:28.384]                     muffled <- FALSE
[17:42:28.384]                     if (inherits(cond, "message")) {
[17:42:28.384]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:28.384]                       if (muffled) 
[17:42:28.384]                         invokeRestart("muffleMessage")
[17:42:28.384]                     }
[17:42:28.384]                     else if (inherits(cond, "warning")) {
[17:42:28.384]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:28.384]                       if (muffled) 
[17:42:28.384]                         invokeRestart("muffleWarning")
[17:42:28.384]                     }
[17:42:28.384]                     else if (inherits(cond, "condition")) {
[17:42:28.384]                       if (!is.null(pattern)) {
[17:42:28.384]                         computeRestarts <- base::computeRestarts
[17:42:28.384]                         grepl <- base::grepl
[17:42:28.384]                         restarts <- computeRestarts(cond)
[17:42:28.384]                         for (restart in restarts) {
[17:42:28.384]                           name <- restart$name
[17:42:28.384]                           if (is.null(name)) 
[17:42:28.384]                             next
[17:42:28.384]                           if (!grepl(pattern, name)) 
[17:42:28.384]                             next
[17:42:28.384]                           invokeRestart(restart)
[17:42:28.384]                           muffled <- TRUE
[17:42:28.384]                           break
[17:42:28.384]                         }
[17:42:28.384]                       }
[17:42:28.384]                     }
[17:42:28.384]                     invisible(muffled)
[17:42:28.384]                   }
[17:42:28.384]                   muffleCondition(cond)
[17:42:28.384]                 })
[17:42:28.384]             }))
[17:42:28.384]             future::FutureResult(value = ...future.value$value, 
[17:42:28.384]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:28.384]                   ...future.rng), globalenv = if (FALSE) 
[17:42:28.384]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:28.384]                     ...future.globalenv.names))
[17:42:28.384]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:28.384]         }, condition = base::local({
[17:42:28.384]             c <- base::c
[17:42:28.384]             inherits <- base::inherits
[17:42:28.384]             invokeRestart <- base::invokeRestart
[17:42:28.384]             length <- base::length
[17:42:28.384]             list <- base::list
[17:42:28.384]             seq.int <- base::seq.int
[17:42:28.384]             signalCondition <- base::signalCondition
[17:42:28.384]             sys.calls <- base::sys.calls
[17:42:28.384]             `[[` <- base::`[[`
[17:42:28.384]             `+` <- base::`+`
[17:42:28.384]             `<<-` <- base::`<<-`
[17:42:28.384]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:28.384]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:28.384]                   3L)]
[17:42:28.384]             }
[17:42:28.384]             function(cond) {
[17:42:28.384]                 is_error <- inherits(cond, "error")
[17:42:28.384]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:28.384]                   NULL)
[17:42:28.384]                 if (is_error) {
[17:42:28.384]                   sessionInformation <- function() {
[17:42:28.384]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:28.384]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:28.384]                       search = base::search(), system = base::Sys.info())
[17:42:28.384]                   }
[17:42:28.384]                   ...future.conditions[[length(...future.conditions) + 
[17:42:28.384]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:28.384]                     cond$call), session = sessionInformation(), 
[17:42:28.384]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:28.384]                   signalCondition(cond)
[17:42:28.384]                 }
[17:42:28.384]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:28.384]                 "immediateCondition"))) {
[17:42:28.384]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:28.384]                   ...future.conditions[[length(...future.conditions) + 
[17:42:28.384]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:28.384]                   if (TRUE && !signal) {
[17:42:28.384]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:28.384]                     {
[17:42:28.384]                       inherits <- base::inherits
[17:42:28.384]                       invokeRestart <- base::invokeRestart
[17:42:28.384]                       is.null <- base::is.null
[17:42:28.384]                       muffled <- FALSE
[17:42:28.384]                       if (inherits(cond, "message")) {
[17:42:28.384]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:28.384]                         if (muffled) 
[17:42:28.384]                           invokeRestart("muffleMessage")
[17:42:28.384]                       }
[17:42:28.384]                       else if (inherits(cond, "warning")) {
[17:42:28.384]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:28.384]                         if (muffled) 
[17:42:28.384]                           invokeRestart("muffleWarning")
[17:42:28.384]                       }
[17:42:28.384]                       else if (inherits(cond, "condition")) {
[17:42:28.384]                         if (!is.null(pattern)) {
[17:42:28.384]                           computeRestarts <- base::computeRestarts
[17:42:28.384]                           grepl <- base::grepl
[17:42:28.384]                           restarts <- computeRestarts(cond)
[17:42:28.384]                           for (restart in restarts) {
[17:42:28.384]                             name <- restart$name
[17:42:28.384]                             if (is.null(name)) 
[17:42:28.384]                               next
[17:42:28.384]                             if (!grepl(pattern, name)) 
[17:42:28.384]                               next
[17:42:28.384]                             invokeRestart(restart)
[17:42:28.384]                             muffled <- TRUE
[17:42:28.384]                             break
[17:42:28.384]                           }
[17:42:28.384]                         }
[17:42:28.384]                       }
[17:42:28.384]                       invisible(muffled)
[17:42:28.384]                     }
[17:42:28.384]                     muffleCondition(cond, pattern = "^muffle")
[17:42:28.384]                   }
[17:42:28.384]                 }
[17:42:28.384]                 else {
[17:42:28.384]                   if (TRUE) {
[17:42:28.384]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:28.384]                     {
[17:42:28.384]                       inherits <- base::inherits
[17:42:28.384]                       invokeRestart <- base::invokeRestart
[17:42:28.384]                       is.null <- base::is.null
[17:42:28.384]                       muffled <- FALSE
[17:42:28.384]                       if (inherits(cond, "message")) {
[17:42:28.384]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:28.384]                         if (muffled) 
[17:42:28.384]                           invokeRestart("muffleMessage")
[17:42:28.384]                       }
[17:42:28.384]                       else if (inherits(cond, "warning")) {
[17:42:28.384]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:28.384]                         if (muffled) 
[17:42:28.384]                           invokeRestart("muffleWarning")
[17:42:28.384]                       }
[17:42:28.384]                       else if (inherits(cond, "condition")) {
[17:42:28.384]                         if (!is.null(pattern)) {
[17:42:28.384]                           computeRestarts <- base::computeRestarts
[17:42:28.384]                           grepl <- base::grepl
[17:42:28.384]                           restarts <- computeRestarts(cond)
[17:42:28.384]                           for (restart in restarts) {
[17:42:28.384]                             name <- restart$name
[17:42:28.384]                             if (is.null(name)) 
[17:42:28.384]                               next
[17:42:28.384]                             if (!grepl(pattern, name)) 
[17:42:28.384]                               next
[17:42:28.384]                             invokeRestart(restart)
[17:42:28.384]                             muffled <- TRUE
[17:42:28.384]                             break
[17:42:28.384]                           }
[17:42:28.384]                         }
[17:42:28.384]                       }
[17:42:28.384]                       invisible(muffled)
[17:42:28.384]                     }
[17:42:28.384]                     muffleCondition(cond, pattern = "^muffle")
[17:42:28.384]                   }
[17:42:28.384]                 }
[17:42:28.384]             }
[17:42:28.384]         }))
[17:42:28.384]     }, error = function(ex) {
[17:42:28.384]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:28.384]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:28.384]                 ...future.rng), started = ...future.startTime, 
[17:42:28.384]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:28.384]             version = "1.8"), class = "FutureResult")
[17:42:28.384]     }, finally = {
[17:42:28.384]         if (!identical(...future.workdir, getwd())) 
[17:42:28.384]             setwd(...future.workdir)
[17:42:28.384]         {
[17:42:28.384]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:28.384]                 ...future.oldOptions$nwarnings <- NULL
[17:42:28.384]             }
[17:42:28.384]             base::options(...future.oldOptions)
[17:42:28.384]             if (.Platform$OS.type == "windows") {
[17:42:28.384]                 old_names <- names(...future.oldEnvVars)
[17:42:28.384]                 envs <- base::Sys.getenv()
[17:42:28.384]                 names <- names(envs)
[17:42:28.384]                 common <- intersect(names, old_names)
[17:42:28.384]                 added <- setdiff(names, old_names)
[17:42:28.384]                 removed <- setdiff(old_names, names)
[17:42:28.384]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:28.384]                   envs[common]]
[17:42:28.384]                 NAMES <- toupper(changed)
[17:42:28.384]                 args <- list()
[17:42:28.384]                 for (kk in seq_along(NAMES)) {
[17:42:28.384]                   name <- changed[[kk]]
[17:42:28.384]                   NAME <- NAMES[[kk]]
[17:42:28.384]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:28.384]                     next
[17:42:28.384]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:28.384]                 }
[17:42:28.384]                 NAMES <- toupper(added)
[17:42:28.384]                 for (kk in seq_along(NAMES)) {
[17:42:28.384]                   name <- added[[kk]]
[17:42:28.384]                   NAME <- NAMES[[kk]]
[17:42:28.384]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:28.384]                     next
[17:42:28.384]                   args[[name]] <- ""
[17:42:28.384]                 }
[17:42:28.384]                 NAMES <- toupper(removed)
[17:42:28.384]                 for (kk in seq_along(NAMES)) {
[17:42:28.384]                   name <- removed[[kk]]
[17:42:28.384]                   NAME <- NAMES[[kk]]
[17:42:28.384]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:28.384]                     next
[17:42:28.384]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:28.384]                 }
[17:42:28.384]                 if (length(args) > 0) 
[17:42:28.384]                   base::do.call(base::Sys.setenv, args = args)
[17:42:28.384]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:28.384]             }
[17:42:28.384]             else {
[17:42:28.384]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:28.384]             }
[17:42:28.384]             {
[17:42:28.384]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:28.384]                   0L) {
[17:42:28.384]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:28.384]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:28.384]                   base::options(opts)
[17:42:28.384]                 }
[17:42:28.384]                 {
[17:42:28.384]                   {
[17:42:28.384]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:28.384]                     NULL
[17:42:28.384]                   }
[17:42:28.384]                   options(future.plan = NULL)
[17:42:28.384]                   if (is.na(NA_character_)) 
[17:42:28.384]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:28.384]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:28.384]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:28.384]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:28.384]                     envir = parent.frame()) 
[17:42:28.384]                   {
[17:42:28.384]                     if (is.function(workers)) 
[17:42:28.384]                       workers <- workers()
[17:42:28.384]                     workers <- structure(as.integer(workers), 
[17:42:28.384]                       class = class(workers))
[17:42:28.384]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:28.384]                       workers >= 1)
[17:42:28.384]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:28.384]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:28.384]                     }
[17:42:28.384]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:28.384]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:28.384]                       envir = envir)
[17:42:28.384]                     if (!future$lazy) 
[17:42:28.384]                       future <- run(future)
[17:42:28.384]                     invisible(future)
[17:42:28.384]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:28.384]                 }
[17:42:28.384]             }
[17:42:28.384]         }
[17:42:28.384]     })
[17:42:28.384]     if (TRUE) {
[17:42:28.384]         base::sink(type = "output", split = FALSE)
[17:42:28.384]         if (TRUE) {
[17:42:28.384]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:28.384]         }
[17:42:28.384]         else {
[17:42:28.384]             ...future.result["stdout"] <- base::list(NULL)
[17:42:28.384]         }
[17:42:28.384]         base::close(...future.stdout)
[17:42:28.384]         ...future.stdout <- NULL
[17:42:28.384]     }
[17:42:28.384]     ...future.result$conditions <- ...future.conditions
[17:42:28.384]     ...future.result$finished <- base::Sys.time()
[17:42:28.384]     ...future.result
[17:42:28.384] }
[17:42:28.387] Exporting 3 global objects (7.52 KiB) to cluster node #1 ...
[17:42:28.387] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ...
[17:42:28.387] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ... DONE
[17:42:28.387] Exporting ‘map’ (4.43 KiB) to cluster node #1 ...
[17:42:28.388] Exporting ‘map’ (4.43 KiB) to cluster node #1 ... DONE
[17:42:28.388] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ...
[17:42:28.388] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ... DONE
[17:42:28.388] Exporting 3 global objects (7.52 KiB) to cluster node #1 ... DONE
[17:42:28.389] MultisessionFuture started
[17:42:28.389] - Launch lazy future ... done
[17:42:28.389] run() for ‘MultisessionFuture’ ... done
[17:42:28.390] result() for ClusterFuture ...
[17:42:28.390] receiveMessageFromWorker() for ClusterFuture ...
[17:42:28.390] - Validating connection of MultisessionFuture
[17:42:28.436] - received message: FutureResult
[17:42:28.436] - Received FutureResult
[17:42:28.437] - Erased future from FutureRegistry
[17:42:28.437] result() for ClusterFuture ...
[17:42:28.437] - result already collected: FutureResult
[17:42:28.437] result() for ClusterFuture ... done
[17:42:28.437] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:28.437] result() for ClusterFuture ... done
[17:42:28.437] result() for ClusterFuture ...
[17:42:28.437] - result already collected: FutureResult
[17:42:28.437] result() for ClusterFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
Testing with 2 cores ... DONE
> 
> message("*** Globals - formulas ... DONE")
*** Globals - formulas ... DONE
> 
> source("incl/end.R")
[17:42:28.439] plan(): Setting new future strategy stack:
[17:42:28.439] List of future strategies:
[17:42:28.439] 1. FutureStrategy:
[17:42:28.439]    - args: function (..., envir = parent.frame())
[17:42:28.439]    - tweaked: FALSE
[17:42:28.439]    - call: future::plan(oplan)
[17:42:28.440] plan(): nbrOfWorkers() = 1
> 
