
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[16:12:32.771] plan(): Setting new future strategy stack:
[16:12:32.771] List of future strategies:
[16:12:32.771] 1. sequential:
[16:12:32.771]    - args: function (..., envir = parent.frame())
[16:12:32.771]    - tweaked: FALSE
[16:12:32.771]    - call: future::plan("sequential")
[16:12:32.784] plan(): nbrOfWorkers() = 1
> 
> library("datasets") ## cars data set
> library("stats")    ## lm(), poly(), xtabs()
> 
> message("*** Globals - formulas ...")
*** Globals - formulas ...
> 
> ## (i) lm(<formula>):
> ## From example("lm", package = "stats")
> ctl <- c(4.17, 5.58, 5.18, 6.11, 4.50, 4.61, 5.17, 4.53, 5.33, 5.14)
> trt <- c(4.81, 4.17, 4.41, 3.59, 5.87, 3.83, 6.03, 4.89, 4.32, 4.69)
> group <- gl(2, 10, 20, labels = c("Ctl", "Trt"))
> weight <- c(ctl, trt)
> ctl <- trt <- NULL
> ## Truth:
> fit_i <- lm(weight ~ group - 1)
> print(fit_i)

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

> 
> ## (ii) xtabs(~ x):
> x <- c(1, 1, 2, 2, 2)
> ## Truth:
> tbl_ii <- xtabs(~ x)
> print(tbl_ii)
x
1 2 
2 3 
> 
> ## (iii) lm(<formula>, data = cars):
> exprs <- list(
+   # "remove-intercept-term" form of no-intercept
+   a = substitute({ lm(dist ~ . -1, data = cars) }),
+   # "make-intercept-zero" form of no-intercept
+   b = substitute({ lm(dist ~ . +0, data = cars) }),
+   # doesn't do what we want here
+   c = substitute({ lm(dist ~ speed + speed ^ 2, data = cars) }),
+   # gets us a quadratic term
+   d = substitute({ lm(dist ~ speed + I(speed ^ 2), data = cars) }),
+   # avoid potential multicollinearity
+   e = substitute({ lm(dist ~ poly(speed, 2), data = cars) })
+ )
> 
> ## (iv) Globals - map(x, ~ expr):
> ## A fake purrr::map() function with limited functionality
> map <- function(.x, .f, ...) {
+   if (inherits(.f, "formula")) {
+     expr <- .f[[-1]]
+     .f <- eval(bquote(function(...) {
+       .(expr)
+     }))
+   }
+   eval(lapply(.x, FUN = .f, ...))
+ }
> 
> inner_function <- function(x) { x + 1 }
> 
> outer_function <- function(x) {
+   map(1:2, ~ inner_function(.x))
+ }
> 
> y_iv <- outer_function(1L)
> str(y_iv)
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
> 
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     message("- lm(<formula>) ...")
+     
+     ## Explicit future
+     f <- future({ lm(weight ~ group - 1) })
+     fit <- value(f)
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Explicit future (lazy)
+     f <- future({ lm(weight ~ group - 1) }, lazy = TRUE)
+     fit <- value(f)
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment
+     fit %<-% { lm(weight ~ group - 1) }
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment (non-lazy)
+     fit %<-% { lm(weight ~ group - 1) } %lazy% FALSE
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment (lazy)
+     fit %<-% { lm(weight ~ group - 1) } %lazy% TRUE
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     message("- Globals - one-side formulas, e.g. xtabs(~ x) ...")
+     ## Explicit future
+     f <- future({ xtabs(~ x) })
+     tbl <- value(f)
+     print(tbl)
+     stopifnot(all.equal(tbl, tbl_ii))
+ 
+     ## Future assignment
+     tbl %<-% { xtabs(~ x) }
+     print(tbl)
+     stopifnot(all.equal(tbl, tbl_ii))
+ 
+     message("- Globals - lm(<formula>, data = cars) ...")
+     for (kk in seq_along(exprs)) {
+       expr <- exprs[[kk]]
+       name <- names(exprs)[kk]
+       message(sprintf("- Globals - lm(<formula #%d (%s)>, data = cars) ...",
+                       kk, sQuote(name)))
+     
+       fit_iii <- eval(expr)
+       print(fit_iii)
+     
+       f <- future(expr, substitute = FALSE)
+       fit <- value(f)
+       print(fit)
+     
+       stopifnot(all.equal(fit, fit_iii))
+     } ## for (kk ...)
+ 
+     message("- Globals - map(x, ~ expr) ...")
+     f <- future({ outer_function(1L) })
+     y <- value(f)
+     str(y)
+     stopifnot(all.equal(y, y_iv))
+ 
+     y %<-% { outer_function(1L) }
+     str(y)
+     stopifnot(all.equal(y, y_iv))
+   } ## for (strategy ...)
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- plan('sequential') ...
[16:12:32.839] plan(): Setting new future strategy stack:
[16:12:32.840] List of future strategies:
[16:12:32.840] 1. sequential:
[16:12:32.840]    - args: function (..., envir = parent.frame())
[16:12:32.840]    - tweaked: FALSE
[16:12:32.840]    - call: plan(strategy)
[16:12:32.851] plan(): nbrOfWorkers() = 1
- lm(<formula>) ...
[16:12:32.852] getGlobalsAndPackages() ...
[16:12:32.852] Searching for globals...
[16:12:32.859] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:12:32.859] Searching for globals ... DONE
[16:12:32.859] Resolving globals: FALSE
[16:12:32.860] The total size of the 2 globals is 896 bytes (896 bytes)
[16:12:32.861] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:12:32.861] - globals: [2] ‘weight’, ‘group’
[16:12:32.861] - packages: [1] ‘stats’
[16:12:32.861] getGlobalsAndPackages() ... DONE
[16:12:32.862] run() for ‘Future’ ...
[16:12:32.862] - state: ‘created’
[16:12:32.862] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:32.862] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:32.862] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:32.862]   - Field: ‘label’
[16:12:32.863]   - Field: ‘local’
[16:12:32.863]   - Field: ‘owner’
[16:12:32.863]   - Field: ‘envir’
[16:12:32.863]   - Field: ‘packages’
[16:12:32.863]   - Field: ‘gc’
[16:12:32.863]   - Field: ‘conditions’
[16:12:32.863]   - Field: ‘expr’
[16:12:32.863]   - Field: ‘uuid’
[16:12:32.863]   - Field: ‘seed’
[16:12:32.863]   - Field: ‘version’
[16:12:32.863]   - Field: ‘result’
[16:12:32.864]   - Field: ‘asynchronous’
[16:12:32.864]   - Field: ‘calls’
[16:12:32.864]   - Field: ‘globals’
[16:12:32.864]   - Field: ‘stdout’
[16:12:32.864]   - Field: ‘earlySignal’
[16:12:32.864]   - Field: ‘lazy’
[16:12:32.864]   - Field: ‘state’
[16:12:32.864] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:32.864] - Launch lazy future ...
[16:12:32.865] Packages needed by the future expression (n = 1): ‘stats’
[16:12:32.865] Packages needed by future strategies (n = 0): <none>
[16:12:32.866] {
[16:12:32.866]     {
[16:12:32.866]         {
[16:12:32.866]             ...future.startTime <- base::Sys.time()
[16:12:32.866]             {
[16:12:32.866]                 {
[16:12:32.866]                   {
[16:12:32.866]                     {
[16:12:32.866]                       base::local({
[16:12:32.866]                         has_future <- base::requireNamespace("future", 
[16:12:32.866]                           quietly = TRUE)
[16:12:32.866]                         if (has_future) {
[16:12:32.866]                           ns <- base::getNamespace("future")
[16:12:32.866]                           version <- ns[[".package"]][["version"]]
[16:12:32.866]                           if (is.null(version)) 
[16:12:32.866]                             version <- utils::packageVersion("future")
[16:12:32.866]                         }
[16:12:32.866]                         else {
[16:12:32.866]                           version <- NULL
[16:12:32.866]                         }
[16:12:32.866]                         if (!has_future || version < "1.8.0") {
[16:12:32.866]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:32.866]                             "", base::R.version$version.string), 
[16:12:32.866]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:32.866]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:32.866]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:32.866]                               "release", "version")], collapse = " "), 
[16:12:32.866]                             hostname = base::Sys.info()[["nodename"]])
[16:12:32.866]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:32.866]                             info)
[16:12:32.866]                           info <- base::paste(info, collapse = "; ")
[16:12:32.866]                           if (!has_future) {
[16:12:32.866]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:32.866]                               info)
[16:12:32.866]                           }
[16:12:32.866]                           else {
[16:12:32.866]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:32.866]                               info, version)
[16:12:32.866]                           }
[16:12:32.866]                           base::stop(msg)
[16:12:32.866]                         }
[16:12:32.866]                       })
[16:12:32.866]                     }
[16:12:32.866]                     base::local({
[16:12:32.866]                       for (pkg in "stats") {
[16:12:32.866]                         base::loadNamespace(pkg)
[16:12:32.866]                         base::library(pkg, character.only = TRUE)
[16:12:32.866]                       }
[16:12:32.866]                     })
[16:12:32.866]                   }
[16:12:32.866]                   options(future.plan = NULL)
[16:12:32.866]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:32.866]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:32.866]                 }
[16:12:32.866]                 ...future.workdir <- getwd()
[16:12:32.866]             }
[16:12:32.866]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:32.866]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:32.866]         }
[16:12:32.866]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:32.866]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:32.866]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:32.866]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:32.866]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:32.866]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:32.866]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:32.866]             base::names(...future.oldOptions))
[16:12:32.866]     }
[16:12:32.866]     if (FALSE) {
[16:12:32.866]     }
[16:12:32.866]     else {
[16:12:32.866]         if (TRUE) {
[16:12:32.866]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:32.866]                 open = "w")
[16:12:32.866]         }
[16:12:32.866]         else {
[16:12:32.866]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:32.866]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:32.866]         }
[16:12:32.866]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:32.866]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:32.866]             base::sink(type = "output", split = FALSE)
[16:12:32.866]             base::close(...future.stdout)
[16:12:32.866]         }, add = TRUE)
[16:12:32.866]     }
[16:12:32.866]     ...future.frame <- base::sys.nframe()
[16:12:32.866]     ...future.conditions <- base::list()
[16:12:32.866]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:32.866]     if (FALSE) {
[16:12:32.866]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:32.866]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:32.866]     }
[16:12:32.866]     ...future.result <- base::tryCatch({
[16:12:32.866]         base::withCallingHandlers({
[16:12:32.866]             ...future.value <- base::withVisible(base::local({
[16:12:32.866]                 lm(weight ~ group - 1)
[16:12:32.866]             }))
[16:12:32.866]             future::FutureResult(value = ...future.value$value, 
[16:12:32.866]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:32.866]                   ...future.rng), globalenv = if (FALSE) 
[16:12:32.866]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:32.866]                     ...future.globalenv.names))
[16:12:32.866]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:32.866]         }, condition = base::local({
[16:12:32.866]             c <- base::c
[16:12:32.866]             inherits <- base::inherits
[16:12:32.866]             invokeRestart <- base::invokeRestart
[16:12:32.866]             length <- base::length
[16:12:32.866]             list <- base::list
[16:12:32.866]             seq.int <- base::seq.int
[16:12:32.866]             signalCondition <- base::signalCondition
[16:12:32.866]             sys.calls <- base::sys.calls
[16:12:32.866]             `[[` <- base::`[[`
[16:12:32.866]             `+` <- base::`+`
[16:12:32.866]             `<<-` <- base::`<<-`
[16:12:32.866]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:32.866]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:32.866]                   3L)]
[16:12:32.866]             }
[16:12:32.866]             function(cond) {
[16:12:32.866]                 is_error <- inherits(cond, "error")
[16:12:32.866]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:32.866]                   NULL)
[16:12:32.866]                 if (is_error) {
[16:12:32.866]                   sessionInformation <- function() {
[16:12:32.866]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:32.866]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:32.866]                       search = base::search(), system = base::Sys.info())
[16:12:32.866]                   }
[16:12:32.866]                   ...future.conditions[[length(...future.conditions) + 
[16:12:32.866]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:32.866]                     cond$call), session = sessionInformation(), 
[16:12:32.866]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:32.866]                   signalCondition(cond)
[16:12:32.866]                 }
[16:12:32.866]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:32.866]                 "immediateCondition"))) {
[16:12:32.866]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:32.866]                   ...future.conditions[[length(...future.conditions) + 
[16:12:32.866]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:32.866]                   if (TRUE && !signal) {
[16:12:32.866]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:32.866]                     {
[16:12:32.866]                       inherits <- base::inherits
[16:12:32.866]                       invokeRestart <- base::invokeRestart
[16:12:32.866]                       is.null <- base::is.null
[16:12:32.866]                       muffled <- FALSE
[16:12:32.866]                       if (inherits(cond, "message")) {
[16:12:32.866]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:32.866]                         if (muffled) 
[16:12:32.866]                           invokeRestart("muffleMessage")
[16:12:32.866]                       }
[16:12:32.866]                       else if (inherits(cond, "warning")) {
[16:12:32.866]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:32.866]                         if (muffled) 
[16:12:32.866]                           invokeRestart("muffleWarning")
[16:12:32.866]                       }
[16:12:32.866]                       else if (inherits(cond, "condition")) {
[16:12:32.866]                         if (!is.null(pattern)) {
[16:12:32.866]                           computeRestarts <- base::computeRestarts
[16:12:32.866]                           grepl <- base::grepl
[16:12:32.866]                           restarts <- computeRestarts(cond)
[16:12:32.866]                           for (restart in restarts) {
[16:12:32.866]                             name <- restart$name
[16:12:32.866]                             if (is.null(name)) 
[16:12:32.866]                               next
[16:12:32.866]                             if (!grepl(pattern, name)) 
[16:12:32.866]                               next
[16:12:32.866]                             invokeRestart(restart)
[16:12:32.866]                             muffled <- TRUE
[16:12:32.866]                             break
[16:12:32.866]                           }
[16:12:32.866]                         }
[16:12:32.866]                       }
[16:12:32.866]                       invisible(muffled)
[16:12:32.866]                     }
[16:12:32.866]                     muffleCondition(cond, pattern = "^muffle")
[16:12:32.866]                   }
[16:12:32.866]                 }
[16:12:32.866]                 else {
[16:12:32.866]                   if (TRUE) {
[16:12:32.866]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:32.866]                     {
[16:12:32.866]                       inherits <- base::inherits
[16:12:32.866]                       invokeRestart <- base::invokeRestart
[16:12:32.866]                       is.null <- base::is.null
[16:12:32.866]                       muffled <- FALSE
[16:12:32.866]                       if (inherits(cond, "message")) {
[16:12:32.866]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:32.866]                         if (muffled) 
[16:12:32.866]                           invokeRestart("muffleMessage")
[16:12:32.866]                       }
[16:12:32.866]                       else if (inherits(cond, "warning")) {
[16:12:32.866]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:32.866]                         if (muffled) 
[16:12:32.866]                           invokeRestart("muffleWarning")
[16:12:32.866]                       }
[16:12:32.866]                       else if (inherits(cond, "condition")) {
[16:12:32.866]                         if (!is.null(pattern)) {
[16:12:32.866]                           computeRestarts <- base::computeRestarts
[16:12:32.866]                           grepl <- base::grepl
[16:12:32.866]                           restarts <- computeRestarts(cond)
[16:12:32.866]                           for (restart in restarts) {
[16:12:32.866]                             name <- restart$name
[16:12:32.866]                             if (is.null(name)) 
[16:12:32.866]                               next
[16:12:32.866]                             if (!grepl(pattern, name)) 
[16:12:32.866]                               next
[16:12:32.866]                             invokeRestart(restart)
[16:12:32.866]                             muffled <- TRUE
[16:12:32.866]                             break
[16:12:32.866]                           }
[16:12:32.866]                         }
[16:12:32.866]                       }
[16:12:32.866]                       invisible(muffled)
[16:12:32.866]                     }
[16:12:32.866]                     muffleCondition(cond, pattern = "^muffle")
[16:12:32.866]                   }
[16:12:32.866]                 }
[16:12:32.866]             }
[16:12:32.866]         }))
[16:12:32.866]     }, error = function(ex) {
[16:12:32.866]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:32.866]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:32.866]                 ...future.rng), started = ...future.startTime, 
[16:12:32.866]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:32.866]             version = "1.8"), class = "FutureResult")
[16:12:32.866]     }, finally = {
[16:12:32.866]         if (!identical(...future.workdir, getwd())) 
[16:12:32.866]             setwd(...future.workdir)
[16:12:32.866]         {
[16:12:32.866]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:32.866]                 ...future.oldOptions$nwarnings <- NULL
[16:12:32.866]             }
[16:12:32.866]             base::options(...future.oldOptions)
[16:12:32.866]             if (.Platform$OS.type == "windows") {
[16:12:32.866]                 old_names <- names(...future.oldEnvVars)
[16:12:32.866]                 envs <- base::Sys.getenv()
[16:12:32.866]                 names <- names(envs)
[16:12:32.866]                 common <- intersect(names, old_names)
[16:12:32.866]                 added <- setdiff(names, old_names)
[16:12:32.866]                 removed <- setdiff(old_names, names)
[16:12:32.866]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:32.866]                   envs[common]]
[16:12:32.866]                 NAMES <- toupper(changed)
[16:12:32.866]                 args <- list()
[16:12:32.866]                 for (kk in seq_along(NAMES)) {
[16:12:32.866]                   name <- changed[[kk]]
[16:12:32.866]                   NAME <- NAMES[[kk]]
[16:12:32.866]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:32.866]                     next
[16:12:32.866]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:32.866]                 }
[16:12:32.866]                 NAMES <- toupper(added)
[16:12:32.866]                 for (kk in seq_along(NAMES)) {
[16:12:32.866]                   name <- added[[kk]]
[16:12:32.866]                   NAME <- NAMES[[kk]]
[16:12:32.866]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:32.866]                     next
[16:12:32.866]                   args[[name]] <- ""
[16:12:32.866]                 }
[16:12:32.866]                 NAMES <- toupper(removed)
[16:12:32.866]                 for (kk in seq_along(NAMES)) {
[16:12:32.866]                   name <- removed[[kk]]
[16:12:32.866]                   NAME <- NAMES[[kk]]
[16:12:32.866]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:32.866]                     next
[16:12:32.866]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:32.866]                 }
[16:12:32.866]                 if (length(args) > 0) 
[16:12:32.866]                   base::do.call(base::Sys.setenv, args = args)
[16:12:32.866]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:32.866]             }
[16:12:32.866]             else {
[16:12:32.866]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:32.866]             }
[16:12:32.866]             {
[16:12:32.866]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:32.866]                   0L) {
[16:12:32.866]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:32.866]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:32.866]                   base::options(opts)
[16:12:32.866]                 }
[16:12:32.866]                 {
[16:12:32.866]                   {
[16:12:32.866]                     NULL
[16:12:32.866]                     RNGkind("Mersenne-Twister")
[16:12:32.866]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:32.866]                       inherits = FALSE)
[16:12:32.866]                   }
[16:12:32.866]                   options(future.plan = NULL)
[16:12:32.866]                   if (is.na(NA_character_)) 
[16:12:32.866]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:32.866]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:32.866]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:32.866]                   {
[16:12:32.866]                     future <- SequentialFuture(..., envir = envir)
[16:12:32.866]                     if (!future$lazy) 
[16:12:32.866]                       future <- run(future)
[16:12:32.866]                     invisible(future)
[16:12:32.866]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:32.866]                 }
[16:12:32.866]             }
[16:12:32.866]         }
[16:12:32.866]     })
[16:12:32.866]     if (TRUE) {
[16:12:32.866]         base::sink(type = "output", split = FALSE)
[16:12:32.866]         if (TRUE) {
[16:12:32.866]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:32.866]         }
[16:12:32.866]         else {
[16:12:32.866]             ...future.result["stdout"] <- base::list(NULL)
[16:12:32.866]         }
[16:12:32.866]         base::close(...future.stdout)
[16:12:32.866]         ...future.stdout <- NULL
[16:12:32.866]     }
[16:12:32.866]     ...future.result$conditions <- ...future.conditions
[16:12:32.866]     ...future.result$finished <- base::Sys.time()
[16:12:32.866]     ...future.result
[16:12:32.866] }
[16:12:32.868] assign_globals() ...
[16:12:32.868] List of 2
[16:12:32.868]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[16:12:32.868]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[16:12:32.868]  - attr(*, "where")=List of 2
[16:12:32.868]   ..$ weight:<environment: R_EmptyEnv> 
[16:12:32.868]   ..$ group :<environment: R_EmptyEnv> 
[16:12:32.868]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:32.868]  - attr(*, "resolved")= logi FALSE
[16:12:32.868]  - attr(*, "total_size")= num 896
[16:12:32.868]  - attr(*, "already-done")= logi TRUE
[16:12:32.873] - copied ‘weight’ to environment
[16:12:32.873] - copied ‘group’ to environment
[16:12:32.873] assign_globals() ... done
[16:12:32.874] plan(): Setting new future strategy stack:
[16:12:32.874] List of future strategies:
[16:12:32.874] 1. sequential:
[16:12:32.874]    - args: function (..., envir = parent.frame())
[16:12:32.874]    - tweaked: FALSE
[16:12:32.874]    - call: NULL
[16:12:32.874] plan(): nbrOfWorkers() = 1
[16:12:32.876] plan(): Setting new future strategy stack:
[16:12:32.876] List of future strategies:
[16:12:32.876] 1. sequential:
[16:12:32.876]    - args: function (..., envir = parent.frame())
[16:12:32.876]    - tweaked: FALSE
[16:12:32.876]    - call: plan(strategy)
[16:12:32.876] plan(): nbrOfWorkers() = 1
[16:12:32.877] SequentialFuture started (and completed)
[16:12:32.877] - Launch lazy future ... done
[16:12:32.877] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[16:12:32.880] getGlobalsAndPackages() ...
[16:12:32.880] Searching for globals...
[16:12:32.881] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:12:32.882] Searching for globals ... DONE
[16:12:32.882] Resolving globals: FALSE
[16:12:32.882] The total size of the 2 globals is 896 bytes (896 bytes)
[16:12:32.882] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:12:32.883] - globals: [2] ‘weight’, ‘group’
[16:12:32.883] - packages: [1] ‘stats’
[16:12:32.883] getGlobalsAndPackages() ... DONE
[16:12:32.883] run() for ‘Future’ ...
[16:12:32.883] - state: ‘created’
[16:12:32.883] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:32.884] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:32.884] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:32.884]   - Field: ‘label’
[16:12:32.884]   - Field: ‘local’
[16:12:32.884]   - Field: ‘owner’
[16:12:32.884]   - Field: ‘envir’
[16:12:32.884]   - Field: ‘packages’
[16:12:32.884]   - Field: ‘gc’
[16:12:32.884]   - Field: ‘conditions’
[16:12:32.884]   - Field: ‘expr’
[16:12:32.884]   - Field: ‘uuid’
[16:12:32.885]   - Field: ‘seed’
[16:12:32.885]   - Field: ‘version’
[16:12:32.885]   - Field: ‘result’
[16:12:32.885]   - Field: ‘asynchronous’
[16:12:32.885]   - Field: ‘calls’
[16:12:32.885]   - Field: ‘globals’
[16:12:32.885]   - Field: ‘stdout’
[16:12:32.885]   - Field: ‘earlySignal’
[16:12:32.885]   - Field: ‘lazy’
[16:12:32.885]   - Field: ‘state’
[16:12:32.885] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:32.886] - Launch lazy future ...
[16:12:32.886] Packages needed by the future expression (n = 1): ‘stats’
[16:12:32.886] Packages needed by future strategies (n = 0): <none>
[16:12:32.886] {
[16:12:32.886]     {
[16:12:32.886]         {
[16:12:32.886]             ...future.startTime <- base::Sys.time()
[16:12:32.886]             {
[16:12:32.886]                 {
[16:12:32.886]                   {
[16:12:32.886]                     {
[16:12:32.886]                       base::local({
[16:12:32.886]                         has_future <- base::requireNamespace("future", 
[16:12:32.886]                           quietly = TRUE)
[16:12:32.886]                         if (has_future) {
[16:12:32.886]                           ns <- base::getNamespace("future")
[16:12:32.886]                           version <- ns[[".package"]][["version"]]
[16:12:32.886]                           if (is.null(version)) 
[16:12:32.886]                             version <- utils::packageVersion("future")
[16:12:32.886]                         }
[16:12:32.886]                         else {
[16:12:32.886]                           version <- NULL
[16:12:32.886]                         }
[16:12:32.886]                         if (!has_future || version < "1.8.0") {
[16:12:32.886]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:32.886]                             "", base::R.version$version.string), 
[16:12:32.886]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:32.886]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:32.886]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:32.886]                               "release", "version")], collapse = " "), 
[16:12:32.886]                             hostname = base::Sys.info()[["nodename"]])
[16:12:32.886]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:32.886]                             info)
[16:12:32.886]                           info <- base::paste(info, collapse = "; ")
[16:12:32.886]                           if (!has_future) {
[16:12:32.886]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:32.886]                               info)
[16:12:32.886]                           }
[16:12:32.886]                           else {
[16:12:32.886]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:32.886]                               info, version)
[16:12:32.886]                           }
[16:12:32.886]                           base::stop(msg)
[16:12:32.886]                         }
[16:12:32.886]                       })
[16:12:32.886]                     }
[16:12:32.886]                     base::local({
[16:12:32.886]                       for (pkg in "stats") {
[16:12:32.886]                         base::loadNamespace(pkg)
[16:12:32.886]                         base::library(pkg, character.only = TRUE)
[16:12:32.886]                       }
[16:12:32.886]                     })
[16:12:32.886]                   }
[16:12:32.886]                   options(future.plan = NULL)
[16:12:32.886]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:32.886]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:32.886]                 }
[16:12:32.886]                 ...future.workdir <- getwd()
[16:12:32.886]             }
[16:12:32.886]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:32.886]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:32.886]         }
[16:12:32.886]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:32.886]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:32.886]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:32.886]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:32.886]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:32.886]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:32.886]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:32.886]             base::names(...future.oldOptions))
[16:12:32.886]     }
[16:12:32.886]     if (FALSE) {
[16:12:32.886]     }
[16:12:32.886]     else {
[16:12:32.886]         if (TRUE) {
[16:12:32.886]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:32.886]                 open = "w")
[16:12:32.886]         }
[16:12:32.886]         else {
[16:12:32.886]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:32.886]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:32.886]         }
[16:12:32.886]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:32.886]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:32.886]             base::sink(type = "output", split = FALSE)
[16:12:32.886]             base::close(...future.stdout)
[16:12:32.886]         }, add = TRUE)
[16:12:32.886]     }
[16:12:32.886]     ...future.frame <- base::sys.nframe()
[16:12:32.886]     ...future.conditions <- base::list()
[16:12:32.886]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:32.886]     if (FALSE) {
[16:12:32.886]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:32.886]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:32.886]     }
[16:12:32.886]     ...future.result <- base::tryCatch({
[16:12:32.886]         base::withCallingHandlers({
[16:12:32.886]             ...future.value <- base::withVisible(base::local({
[16:12:32.886]                 lm(weight ~ group - 1)
[16:12:32.886]             }))
[16:12:32.886]             future::FutureResult(value = ...future.value$value, 
[16:12:32.886]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:32.886]                   ...future.rng), globalenv = if (FALSE) 
[16:12:32.886]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:32.886]                     ...future.globalenv.names))
[16:12:32.886]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:32.886]         }, condition = base::local({
[16:12:32.886]             c <- base::c
[16:12:32.886]             inherits <- base::inherits
[16:12:32.886]             invokeRestart <- base::invokeRestart
[16:12:32.886]             length <- base::length
[16:12:32.886]             list <- base::list
[16:12:32.886]             seq.int <- base::seq.int
[16:12:32.886]             signalCondition <- base::signalCondition
[16:12:32.886]             sys.calls <- base::sys.calls
[16:12:32.886]             `[[` <- base::`[[`
[16:12:32.886]             `+` <- base::`+`
[16:12:32.886]             `<<-` <- base::`<<-`
[16:12:32.886]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:32.886]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:32.886]                   3L)]
[16:12:32.886]             }
[16:12:32.886]             function(cond) {
[16:12:32.886]                 is_error <- inherits(cond, "error")
[16:12:32.886]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:32.886]                   NULL)
[16:12:32.886]                 if (is_error) {
[16:12:32.886]                   sessionInformation <- function() {
[16:12:32.886]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:32.886]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:32.886]                       search = base::search(), system = base::Sys.info())
[16:12:32.886]                   }
[16:12:32.886]                   ...future.conditions[[length(...future.conditions) + 
[16:12:32.886]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:32.886]                     cond$call), session = sessionInformation(), 
[16:12:32.886]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:32.886]                   signalCondition(cond)
[16:12:32.886]                 }
[16:12:32.886]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:32.886]                 "immediateCondition"))) {
[16:12:32.886]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:32.886]                   ...future.conditions[[length(...future.conditions) + 
[16:12:32.886]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:32.886]                   if (TRUE && !signal) {
[16:12:32.886]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:32.886]                     {
[16:12:32.886]                       inherits <- base::inherits
[16:12:32.886]                       invokeRestart <- base::invokeRestart
[16:12:32.886]                       is.null <- base::is.null
[16:12:32.886]                       muffled <- FALSE
[16:12:32.886]                       if (inherits(cond, "message")) {
[16:12:32.886]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:32.886]                         if (muffled) 
[16:12:32.886]                           invokeRestart("muffleMessage")
[16:12:32.886]                       }
[16:12:32.886]                       else if (inherits(cond, "warning")) {
[16:12:32.886]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:32.886]                         if (muffled) 
[16:12:32.886]                           invokeRestart("muffleWarning")
[16:12:32.886]                       }
[16:12:32.886]                       else if (inherits(cond, "condition")) {
[16:12:32.886]                         if (!is.null(pattern)) {
[16:12:32.886]                           computeRestarts <- base::computeRestarts
[16:12:32.886]                           grepl <- base::grepl
[16:12:32.886]                           restarts <- computeRestarts(cond)
[16:12:32.886]                           for (restart in restarts) {
[16:12:32.886]                             name <- restart$name
[16:12:32.886]                             if (is.null(name)) 
[16:12:32.886]                               next
[16:12:32.886]                             if (!grepl(pattern, name)) 
[16:12:32.886]                               next
[16:12:32.886]                             invokeRestart(restart)
[16:12:32.886]                             muffled <- TRUE
[16:12:32.886]                             break
[16:12:32.886]                           }
[16:12:32.886]                         }
[16:12:32.886]                       }
[16:12:32.886]                       invisible(muffled)
[16:12:32.886]                     }
[16:12:32.886]                     muffleCondition(cond, pattern = "^muffle")
[16:12:32.886]                   }
[16:12:32.886]                 }
[16:12:32.886]                 else {
[16:12:32.886]                   if (TRUE) {
[16:12:32.886]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:32.886]                     {
[16:12:32.886]                       inherits <- base::inherits
[16:12:32.886]                       invokeRestart <- base::invokeRestart
[16:12:32.886]                       is.null <- base::is.null
[16:12:32.886]                       muffled <- FALSE
[16:12:32.886]                       if (inherits(cond, "message")) {
[16:12:32.886]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:32.886]                         if (muffled) 
[16:12:32.886]                           invokeRestart("muffleMessage")
[16:12:32.886]                       }
[16:12:32.886]                       else if (inherits(cond, "warning")) {
[16:12:32.886]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:32.886]                         if (muffled) 
[16:12:32.886]                           invokeRestart("muffleWarning")
[16:12:32.886]                       }
[16:12:32.886]                       else if (inherits(cond, "condition")) {
[16:12:32.886]                         if (!is.null(pattern)) {
[16:12:32.886]                           computeRestarts <- base::computeRestarts
[16:12:32.886]                           grepl <- base::grepl
[16:12:32.886]                           restarts <- computeRestarts(cond)
[16:12:32.886]                           for (restart in restarts) {
[16:12:32.886]                             name <- restart$name
[16:12:32.886]                             if (is.null(name)) 
[16:12:32.886]                               next
[16:12:32.886]                             if (!grepl(pattern, name)) 
[16:12:32.886]                               next
[16:12:32.886]                             invokeRestart(restart)
[16:12:32.886]                             muffled <- TRUE
[16:12:32.886]                             break
[16:12:32.886]                           }
[16:12:32.886]                         }
[16:12:32.886]                       }
[16:12:32.886]                       invisible(muffled)
[16:12:32.886]                     }
[16:12:32.886]                     muffleCondition(cond, pattern = "^muffle")
[16:12:32.886]                   }
[16:12:32.886]                 }
[16:12:32.886]             }
[16:12:32.886]         }))
[16:12:32.886]     }, error = function(ex) {
[16:12:32.886]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:32.886]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:32.886]                 ...future.rng), started = ...future.startTime, 
[16:12:32.886]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:32.886]             version = "1.8"), class = "FutureResult")
[16:12:32.886]     }, finally = {
[16:12:32.886]         if (!identical(...future.workdir, getwd())) 
[16:12:32.886]             setwd(...future.workdir)
[16:12:32.886]         {
[16:12:32.886]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:32.886]                 ...future.oldOptions$nwarnings <- NULL
[16:12:32.886]             }
[16:12:32.886]             base::options(...future.oldOptions)
[16:12:32.886]             if (.Platform$OS.type == "windows") {
[16:12:32.886]                 old_names <- names(...future.oldEnvVars)
[16:12:32.886]                 envs <- base::Sys.getenv()
[16:12:32.886]                 names <- names(envs)
[16:12:32.886]                 common <- intersect(names, old_names)
[16:12:32.886]                 added <- setdiff(names, old_names)
[16:12:32.886]                 removed <- setdiff(old_names, names)
[16:12:32.886]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:32.886]                   envs[common]]
[16:12:32.886]                 NAMES <- toupper(changed)
[16:12:32.886]                 args <- list()
[16:12:32.886]                 for (kk in seq_along(NAMES)) {
[16:12:32.886]                   name <- changed[[kk]]
[16:12:32.886]                   NAME <- NAMES[[kk]]
[16:12:32.886]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:32.886]                     next
[16:12:32.886]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:32.886]                 }
[16:12:32.886]                 NAMES <- toupper(added)
[16:12:32.886]                 for (kk in seq_along(NAMES)) {
[16:12:32.886]                   name <- added[[kk]]
[16:12:32.886]                   NAME <- NAMES[[kk]]
[16:12:32.886]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:32.886]                     next
[16:12:32.886]                   args[[name]] <- ""
[16:12:32.886]                 }
[16:12:32.886]                 NAMES <- toupper(removed)
[16:12:32.886]                 for (kk in seq_along(NAMES)) {
[16:12:32.886]                   name <- removed[[kk]]
[16:12:32.886]                   NAME <- NAMES[[kk]]
[16:12:32.886]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:32.886]                     next
[16:12:32.886]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:32.886]                 }
[16:12:32.886]                 if (length(args) > 0) 
[16:12:32.886]                   base::do.call(base::Sys.setenv, args = args)
[16:12:32.886]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:32.886]             }
[16:12:32.886]             else {
[16:12:32.886]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:32.886]             }
[16:12:32.886]             {
[16:12:32.886]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:32.886]                   0L) {
[16:12:32.886]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:32.886]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:32.886]                   base::options(opts)
[16:12:32.886]                 }
[16:12:32.886]                 {
[16:12:32.886]                   {
[16:12:32.886]                     NULL
[16:12:32.886]                     RNGkind("Mersenne-Twister")
[16:12:32.886]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:32.886]                       inherits = FALSE)
[16:12:32.886]                   }
[16:12:32.886]                   options(future.plan = NULL)
[16:12:32.886]                   if (is.na(NA_character_)) 
[16:12:32.886]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:32.886]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:32.886]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:32.886]                   {
[16:12:32.886]                     future <- SequentialFuture(..., envir = envir)
[16:12:32.886]                     if (!future$lazy) 
[16:12:32.886]                       future <- run(future)
[16:12:32.886]                     invisible(future)
[16:12:32.886]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:32.886]                 }
[16:12:32.886]             }
[16:12:32.886]         }
[16:12:32.886]     })
[16:12:32.886]     if (TRUE) {
[16:12:32.886]         base::sink(type = "output", split = FALSE)
[16:12:32.886]         if (TRUE) {
[16:12:32.886]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:32.886]         }
[16:12:32.886]         else {
[16:12:32.886]             ...future.result["stdout"] <- base::list(NULL)
[16:12:32.886]         }
[16:12:32.886]         base::close(...future.stdout)
[16:12:32.886]         ...future.stdout <- NULL
[16:12:32.886]     }
[16:12:32.886]     ...future.result$conditions <- ...future.conditions
[16:12:32.886]     ...future.result$finished <- base::Sys.time()
[16:12:32.886]     ...future.result
[16:12:32.886] }
[16:12:32.888] assign_globals() ...
[16:12:32.888] List of 2
[16:12:32.888]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[16:12:32.888]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[16:12:32.888]  - attr(*, "where")=List of 2
[16:12:32.888]   ..$ weight:<environment: R_EmptyEnv> 
[16:12:32.888]   ..$ group :<environment: R_EmptyEnv> 
[16:12:32.888]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:32.888]  - attr(*, "resolved")= logi FALSE
[16:12:32.888]  - attr(*, "total_size")= num 896
[16:12:32.888]  - attr(*, "already-done")= logi TRUE
[16:12:32.891] - copied ‘weight’ to environment
[16:12:32.891] - copied ‘group’ to environment
[16:12:32.891] assign_globals() ... done
[16:12:32.892] plan(): Setting new future strategy stack:
[16:12:32.892] List of future strategies:
[16:12:32.892] 1. sequential:
[16:12:32.892]    - args: function (..., envir = parent.frame())
[16:12:32.892]    - tweaked: FALSE
[16:12:32.892]    - call: NULL
[16:12:32.892] plan(): nbrOfWorkers() = 1
[16:12:32.893] plan(): Setting new future strategy stack:
[16:12:32.893] List of future strategies:
[16:12:32.893] 1. sequential:
[16:12:32.893]    - args: function (..., envir = parent.frame())
[16:12:32.893]    - tweaked: FALSE
[16:12:32.893]    - call: plan(strategy)
[16:12:32.894] plan(): nbrOfWorkers() = 1
[16:12:32.894] SequentialFuture started (and completed)
[16:12:32.894] - Launch lazy future ... done
[16:12:32.894] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[16:12:32.898] getGlobalsAndPackages() ...
[16:12:32.898] Searching for globals...
[16:12:32.900] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:12:32.900] Searching for globals ... DONE
[16:12:32.900] Resolving globals: FALSE
[16:12:32.901] The total size of the 2 globals is 896 bytes (896 bytes)
[16:12:32.901] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:12:32.901] - globals: [2] ‘weight’, ‘group’
[16:12:32.901] - packages: [1] ‘stats’
[16:12:32.901] getGlobalsAndPackages() ... DONE
[16:12:32.901] run() for ‘Future’ ...
[16:12:32.902] - state: ‘created’
[16:12:32.902] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:32.902] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:32.902] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:32.902]   - Field: ‘label’
[16:12:32.902]   - Field: ‘local’
[16:12:32.902]   - Field: ‘owner’
[16:12:32.902]   - Field: ‘envir’
[16:12:32.903]   - Field: ‘packages’
[16:12:32.903]   - Field: ‘gc’
[16:12:32.903]   - Field: ‘conditions’
[16:12:32.903]   - Field: ‘expr’
[16:12:32.903]   - Field: ‘uuid’
[16:12:32.903]   - Field: ‘seed’
[16:12:32.903]   - Field: ‘version’
[16:12:32.903]   - Field: ‘result’
[16:12:32.903]   - Field: ‘asynchronous’
[16:12:32.903]   - Field: ‘calls’
[16:12:32.903]   - Field: ‘globals’
[16:12:32.904]   - Field: ‘stdout’
[16:12:32.904]   - Field: ‘earlySignal’
[16:12:32.904]   - Field: ‘lazy’
[16:12:32.904]   - Field: ‘state’
[16:12:32.904] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:32.904] - Launch lazy future ...
[16:12:32.904] Packages needed by the future expression (n = 1): ‘stats’
[16:12:32.904] Packages needed by future strategies (n = 0): <none>
[16:12:32.905] {
[16:12:32.905]     {
[16:12:32.905]         {
[16:12:32.905]             ...future.startTime <- base::Sys.time()
[16:12:32.905]             {
[16:12:32.905]                 {
[16:12:32.905]                   {
[16:12:32.905]                     {
[16:12:32.905]                       base::local({
[16:12:32.905]                         has_future <- base::requireNamespace("future", 
[16:12:32.905]                           quietly = TRUE)
[16:12:32.905]                         if (has_future) {
[16:12:32.905]                           ns <- base::getNamespace("future")
[16:12:32.905]                           version <- ns[[".package"]][["version"]]
[16:12:32.905]                           if (is.null(version)) 
[16:12:32.905]                             version <- utils::packageVersion("future")
[16:12:32.905]                         }
[16:12:32.905]                         else {
[16:12:32.905]                           version <- NULL
[16:12:32.905]                         }
[16:12:32.905]                         if (!has_future || version < "1.8.0") {
[16:12:32.905]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:32.905]                             "", base::R.version$version.string), 
[16:12:32.905]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:32.905]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:32.905]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:32.905]                               "release", "version")], collapse = " "), 
[16:12:32.905]                             hostname = base::Sys.info()[["nodename"]])
[16:12:32.905]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:32.905]                             info)
[16:12:32.905]                           info <- base::paste(info, collapse = "; ")
[16:12:32.905]                           if (!has_future) {
[16:12:32.905]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:32.905]                               info)
[16:12:32.905]                           }
[16:12:32.905]                           else {
[16:12:32.905]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:32.905]                               info, version)
[16:12:32.905]                           }
[16:12:32.905]                           base::stop(msg)
[16:12:32.905]                         }
[16:12:32.905]                       })
[16:12:32.905]                     }
[16:12:32.905]                     base::local({
[16:12:32.905]                       for (pkg in "stats") {
[16:12:32.905]                         base::loadNamespace(pkg)
[16:12:32.905]                         base::library(pkg, character.only = TRUE)
[16:12:32.905]                       }
[16:12:32.905]                     })
[16:12:32.905]                   }
[16:12:32.905]                   options(future.plan = NULL)
[16:12:32.905]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:32.905]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:32.905]                 }
[16:12:32.905]                 ...future.workdir <- getwd()
[16:12:32.905]             }
[16:12:32.905]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:32.905]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:32.905]         }
[16:12:32.905]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:32.905]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:32.905]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:32.905]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:32.905]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:32.905]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:32.905]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:32.905]             base::names(...future.oldOptions))
[16:12:32.905]     }
[16:12:32.905]     if (FALSE) {
[16:12:32.905]     }
[16:12:32.905]     else {
[16:12:32.905]         if (TRUE) {
[16:12:32.905]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:32.905]                 open = "w")
[16:12:32.905]         }
[16:12:32.905]         else {
[16:12:32.905]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:32.905]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:32.905]         }
[16:12:32.905]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:32.905]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:32.905]             base::sink(type = "output", split = FALSE)
[16:12:32.905]             base::close(...future.stdout)
[16:12:32.905]         }, add = TRUE)
[16:12:32.905]     }
[16:12:32.905]     ...future.frame <- base::sys.nframe()
[16:12:32.905]     ...future.conditions <- base::list()
[16:12:32.905]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:32.905]     if (FALSE) {
[16:12:32.905]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:32.905]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:32.905]     }
[16:12:32.905]     ...future.result <- base::tryCatch({
[16:12:32.905]         base::withCallingHandlers({
[16:12:32.905]             ...future.value <- base::withVisible(base::local({
[16:12:32.905]                 lm(weight ~ group - 1)
[16:12:32.905]             }))
[16:12:32.905]             future::FutureResult(value = ...future.value$value, 
[16:12:32.905]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:32.905]                   ...future.rng), globalenv = if (FALSE) 
[16:12:32.905]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:32.905]                     ...future.globalenv.names))
[16:12:32.905]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:32.905]         }, condition = base::local({
[16:12:32.905]             c <- base::c
[16:12:32.905]             inherits <- base::inherits
[16:12:32.905]             invokeRestart <- base::invokeRestart
[16:12:32.905]             length <- base::length
[16:12:32.905]             list <- base::list
[16:12:32.905]             seq.int <- base::seq.int
[16:12:32.905]             signalCondition <- base::signalCondition
[16:12:32.905]             sys.calls <- base::sys.calls
[16:12:32.905]             `[[` <- base::`[[`
[16:12:32.905]             `+` <- base::`+`
[16:12:32.905]             `<<-` <- base::`<<-`
[16:12:32.905]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:32.905]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:32.905]                   3L)]
[16:12:32.905]             }
[16:12:32.905]             function(cond) {
[16:12:32.905]                 is_error <- inherits(cond, "error")
[16:12:32.905]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:32.905]                   NULL)
[16:12:32.905]                 if (is_error) {
[16:12:32.905]                   sessionInformation <- function() {
[16:12:32.905]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:32.905]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:32.905]                       search = base::search(), system = base::Sys.info())
[16:12:32.905]                   }
[16:12:32.905]                   ...future.conditions[[length(...future.conditions) + 
[16:12:32.905]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:32.905]                     cond$call), session = sessionInformation(), 
[16:12:32.905]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:32.905]                   signalCondition(cond)
[16:12:32.905]                 }
[16:12:32.905]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:32.905]                 "immediateCondition"))) {
[16:12:32.905]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:32.905]                   ...future.conditions[[length(...future.conditions) + 
[16:12:32.905]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:32.905]                   if (TRUE && !signal) {
[16:12:32.905]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:32.905]                     {
[16:12:32.905]                       inherits <- base::inherits
[16:12:32.905]                       invokeRestart <- base::invokeRestart
[16:12:32.905]                       is.null <- base::is.null
[16:12:32.905]                       muffled <- FALSE
[16:12:32.905]                       if (inherits(cond, "message")) {
[16:12:32.905]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:32.905]                         if (muffled) 
[16:12:32.905]                           invokeRestart("muffleMessage")
[16:12:32.905]                       }
[16:12:32.905]                       else if (inherits(cond, "warning")) {
[16:12:32.905]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:32.905]                         if (muffled) 
[16:12:32.905]                           invokeRestart("muffleWarning")
[16:12:32.905]                       }
[16:12:32.905]                       else if (inherits(cond, "condition")) {
[16:12:32.905]                         if (!is.null(pattern)) {
[16:12:32.905]                           computeRestarts <- base::computeRestarts
[16:12:32.905]                           grepl <- base::grepl
[16:12:32.905]                           restarts <- computeRestarts(cond)
[16:12:32.905]                           for (restart in restarts) {
[16:12:32.905]                             name <- restart$name
[16:12:32.905]                             if (is.null(name)) 
[16:12:32.905]                               next
[16:12:32.905]                             if (!grepl(pattern, name)) 
[16:12:32.905]                               next
[16:12:32.905]                             invokeRestart(restart)
[16:12:32.905]                             muffled <- TRUE
[16:12:32.905]                             break
[16:12:32.905]                           }
[16:12:32.905]                         }
[16:12:32.905]                       }
[16:12:32.905]                       invisible(muffled)
[16:12:32.905]                     }
[16:12:32.905]                     muffleCondition(cond, pattern = "^muffle")
[16:12:32.905]                   }
[16:12:32.905]                 }
[16:12:32.905]                 else {
[16:12:32.905]                   if (TRUE) {
[16:12:32.905]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:32.905]                     {
[16:12:32.905]                       inherits <- base::inherits
[16:12:32.905]                       invokeRestart <- base::invokeRestart
[16:12:32.905]                       is.null <- base::is.null
[16:12:32.905]                       muffled <- FALSE
[16:12:32.905]                       if (inherits(cond, "message")) {
[16:12:32.905]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:32.905]                         if (muffled) 
[16:12:32.905]                           invokeRestart("muffleMessage")
[16:12:32.905]                       }
[16:12:32.905]                       else if (inherits(cond, "warning")) {
[16:12:32.905]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:32.905]                         if (muffled) 
[16:12:32.905]                           invokeRestart("muffleWarning")
[16:12:32.905]                       }
[16:12:32.905]                       else if (inherits(cond, "condition")) {
[16:12:32.905]                         if (!is.null(pattern)) {
[16:12:32.905]                           computeRestarts <- base::computeRestarts
[16:12:32.905]                           grepl <- base::grepl
[16:12:32.905]                           restarts <- computeRestarts(cond)
[16:12:32.905]                           for (restart in restarts) {
[16:12:32.905]                             name <- restart$name
[16:12:32.905]                             if (is.null(name)) 
[16:12:32.905]                               next
[16:12:32.905]                             if (!grepl(pattern, name)) 
[16:12:32.905]                               next
[16:12:32.905]                             invokeRestart(restart)
[16:12:32.905]                             muffled <- TRUE
[16:12:32.905]                             break
[16:12:32.905]                           }
[16:12:32.905]                         }
[16:12:32.905]                       }
[16:12:32.905]                       invisible(muffled)
[16:12:32.905]                     }
[16:12:32.905]                     muffleCondition(cond, pattern = "^muffle")
[16:12:32.905]                   }
[16:12:32.905]                 }
[16:12:32.905]             }
[16:12:32.905]         }))
[16:12:32.905]     }, error = function(ex) {
[16:12:32.905]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:32.905]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:32.905]                 ...future.rng), started = ...future.startTime, 
[16:12:32.905]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:32.905]             version = "1.8"), class = "FutureResult")
[16:12:32.905]     }, finally = {
[16:12:32.905]         if (!identical(...future.workdir, getwd())) 
[16:12:32.905]             setwd(...future.workdir)
[16:12:32.905]         {
[16:12:32.905]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:32.905]                 ...future.oldOptions$nwarnings <- NULL
[16:12:32.905]             }
[16:12:32.905]             base::options(...future.oldOptions)
[16:12:32.905]             if (.Platform$OS.type == "windows") {
[16:12:32.905]                 old_names <- names(...future.oldEnvVars)
[16:12:32.905]                 envs <- base::Sys.getenv()
[16:12:32.905]                 names <- names(envs)
[16:12:32.905]                 common <- intersect(names, old_names)
[16:12:32.905]                 added <- setdiff(names, old_names)
[16:12:32.905]                 removed <- setdiff(old_names, names)
[16:12:32.905]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:32.905]                   envs[common]]
[16:12:32.905]                 NAMES <- toupper(changed)
[16:12:32.905]                 args <- list()
[16:12:32.905]                 for (kk in seq_along(NAMES)) {
[16:12:32.905]                   name <- changed[[kk]]
[16:12:32.905]                   NAME <- NAMES[[kk]]
[16:12:32.905]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:32.905]                     next
[16:12:32.905]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:32.905]                 }
[16:12:32.905]                 NAMES <- toupper(added)
[16:12:32.905]                 for (kk in seq_along(NAMES)) {
[16:12:32.905]                   name <- added[[kk]]
[16:12:32.905]                   NAME <- NAMES[[kk]]
[16:12:32.905]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:32.905]                     next
[16:12:32.905]                   args[[name]] <- ""
[16:12:32.905]                 }
[16:12:32.905]                 NAMES <- toupper(removed)
[16:12:32.905]                 for (kk in seq_along(NAMES)) {
[16:12:32.905]                   name <- removed[[kk]]
[16:12:32.905]                   NAME <- NAMES[[kk]]
[16:12:32.905]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:32.905]                     next
[16:12:32.905]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:32.905]                 }
[16:12:32.905]                 if (length(args) > 0) 
[16:12:32.905]                   base::do.call(base::Sys.setenv, args = args)
[16:12:32.905]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:32.905]             }
[16:12:32.905]             else {
[16:12:32.905]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:32.905]             }
[16:12:32.905]             {
[16:12:32.905]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:32.905]                   0L) {
[16:12:32.905]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:32.905]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:32.905]                   base::options(opts)
[16:12:32.905]                 }
[16:12:32.905]                 {
[16:12:32.905]                   {
[16:12:32.905]                     NULL
[16:12:32.905]                     RNGkind("Mersenne-Twister")
[16:12:32.905]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:32.905]                       inherits = FALSE)
[16:12:32.905]                   }
[16:12:32.905]                   options(future.plan = NULL)
[16:12:32.905]                   if (is.na(NA_character_)) 
[16:12:32.905]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:32.905]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:32.905]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:32.905]                   {
[16:12:32.905]                     future <- SequentialFuture(..., envir = envir)
[16:12:32.905]                     if (!future$lazy) 
[16:12:32.905]                       future <- run(future)
[16:12:32.905]                     invisible(future)
[16:12:32.905]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:32.905]                 }
[16:12:32.905]             }
[16:12:32.905]         }
[16:12:32.905]     })
[16:12:32.905]     if (TRUE) {
[16:12:32.905]         base::sink(type = "output", split = FALSE)
[16:12:32.905]         if (TRUE) {
[16:12:32.905]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:32.905]         }
[16:12:32.905]         else {
[16:12:32.905]             ...future.result["stdout"] <- base::list(NULL)
[16:12:32.905]         }
[16:12:32.905]         base::close(...future.stdout)
[16:12:32.905]         ...future.stdout <- NULL
[16:12:32.905]     }
[16:12:32.905]     ...future.result$conditions <- ...future.conditions
[16:12:32.905]     ...future.result$finished <- base::Sys.time()
[16:12:32.905]     ...future.result
[16:12:32.905] }
[16:12:32.906] assign_globals() ...
[16:12:32.907] List of 2
[16:12:32.907]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[16:12:32.907]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[16:12:32.907]  - attr(*, "where")=List of 2
[16:12:32.907]   ..$ weight:<environment: R_EmptyEnv> 
[16:12:32.907]   ..$ group :<environment: R_EmptyEnv> 
[16:12:32.907]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:32.907]  - attr(*, "resolved")= logi FALSE
[16:12:32.907]  - attr(*, "total_size")= num 896
[16:12:32.907]  - attr(*, "already-done")= logi TRUE
[16:12:32.909] - copied ‘weight’ to environment
[16:12:32.910] - copied ‘group’ to environment
[16:12:32.910] assign_globals() ... done
[16:12:32.910] plan(): Setting new future strategy stack:
[16:12:32.910] List of future strategies:
[16:12:32.910] 1. sequential:
[16:12:32.910]    - args: function (..., envir = parent.frame())
[16:12:32.910]    - tweaked: FALSE
[16:12:32.910]    - call: NULL
[16:12:32.911] plan(): nbrOfWorkers() = 1
[16:12:32.912] plan(): Setting new future strategy stack:
[16:12:32.912] List of future strategies:
[16:12:32.912] 1. sequential:
[16:12:32.912]    - args: function (..., envir = parent.frame())
[16:12:32.912]    - tweaked: FALSE
[16:12:32.912]    - call: plan(strategy)
[16:12:32.912] plan(): nbrOfWorkers() = 1
[16:12:32.913] SequentialFuture started (and completed)
[16:12:32.913] - Launch lazy future ... done
[16:12:32.913] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[16:12:32.915] getGlobalsAndPackages() ...
[16:12:32.915] Searching for globals...
[16:12:32.916] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:12:32.916] Searching for globals ... DONE
[16:12:32.916] Resolving globals: FALSE
[16:12:32.917] The total size of the 2 globals is 896 bytes (896 bytes)
[16:12:32.917] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:12:32.917] - globals: [2] ‘weight’, ‘group’
[16:12:32.917] - packages: [1] ‘stats’
[16:12:32.917] getGlobalsAndPackages() ... DONE
[16:12:32.918] run() for ‘Future’ ...
[16:12:32.918] - state: ‘created’
[16:12:32.918] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:32.918] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:32.918] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:32.918]   - Field: ‘label’
[16:12:32.918]   - Field: ‘local’
[16:12:32.918]   - Field: ‘owner’
[16:12:32.919]   - Field: ‘envir’
[16:12:32.919]   - Field: ‘packages’
[16:12:32.919]   - Field: ‘gc’
[16:12:32.919]   - Field: ‘conditions’
[16:12:32.919]   - Field: ‘expr’
[16:12:32.919]   - Field: ‘uuid’
[16:12:32.919]   - Field: ‘seed’
[16:12:32.919]   - Field: ‘version’
[16:12:32.919]   - Field: ‘result’
[16:12:32.919]   - Field: ‘asynchronous’
[16:12:32.919]   - Field: ‘calls’
[16:12:32.919]   - Field: ‘globals’
[16:12:32.920]   - Field: ‘stdout’
[16:12:32.920]   - Field: ‘earlySignal’
[16:12:32.920]   - Field: ‘lazy’
[16:12:32.920]   - Field: ‘state’
[16:12:32.920] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:32.920] - Launch lazy future ...
[16:12:32.920] Packages needed by the future expression (n = 1): ‘stats’
[16:12:32.922] Packages needed by future strategies (n = 0): <none>
[16:12:32.922] {
[16:12:32.922]     {
[16:12:32.922]         {
[16:12:32.922]             ...future.startTime <- base::Sys.time()
[16:12:32.922]             {
[16:12:32.922]                 {
[16:12:32.922]                   {
[16:12:32.922]                     {
[16:12:32.922]                       base::local({
[16:12:32.922]                         has_future <- base::requireNamespace("future", 
[16:12:32.922]                           quietly = TRUE)
[16:12:32.922]                         if (has_future) {
[16:12:32.922]                           ns <- base::getNamespace("future")
[16:12:32.922]                           version <- ns[[".package"]][["version"]]
[16:12:32.922]                           if (is.null(version)) 
[16:12:32.922]                             version <- utils::packageVersion("future")
[16:12:32.922]                         }
[16:12:32.922]                         else {
[16:12:32.922]                           version <- NULL
[16:12:32.922]                         }
[16:12:32.922]                         if (!has_future || version < "1.8.0") {
[16:12:32.922]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:32.922]                             "", base::R.version$version.string), 
[16:12:32.922]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:32.922]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:32.922]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:32.922]                               "release", "version")], collapse = " "), 
[16:12:32.922]                             hostname = base::Sys.info()[["nodename"]])
[16:12:32.922]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:32.922]                             info)
[16:12:32.922]                           info <- base::paste(info, collapse = "; ")
[16:12:32.922]                           if (!has_future) {
[16:12:32.922]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:32.922]                               info)
[16:12:32.922]                           }
[16:12:32.922]                           else {
[16:12:32.922]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:32.922]                               info, version)
[16:12:32.922]                           }
[16:12:32.922]                           base::stop(msg)
[16:12:32.922]                         }
[16:12:32.922]                       })
[16:12:32.922]                     }
[16:12:32.922]                     base::local({
[16:12:32.922]                       for (pkg in "stats") {
[16:12:32.922]                         base::loadNamespace(pkg)
[16:12:32.922]                         base::library(pkg, character.only = TRUE)
[16:12:32.922]                       }
[16:12:32.922]                     })
[16:12:32.922]                   }
[16:12:32.922]                   options(future.plan = NULL)
[16:12:32.922]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:32.922]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:32.922]                 }
[16:12:32.922]                 ...future.workdir <- getwd()
[16:12:32.922]             }
[16:12:32.922]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:32.922]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:32.922]         }
[16:12:32.922]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:32.922]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:32.922]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:32.922]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:32.922]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:32.922]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:32.922]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:32.922]             base::names(...future.oldOptions))
[16:12:32.922]     }
[16:12:32.922]     if (FALSE) {
[16:12:32.922]     }
[16:12:32.922]     else {
[16:12:32.922]         if (TRUE) {
[16:12:32.922]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:32.922]                 open = "w")
[16:12:32.922]         }
[16:12:32.922]         else {
[16:12:32.922]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:32.922]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:32.922]         }
[16:12:32.922]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:32.922]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:32.922]             base::sink(type = "output", split = FALSE)
[16:12:32.922]             base::close(...future.stdout)
[16:12:32.922]         }, add = TRUE)
[16:12:32.922]     }
[16:12:32.922]     ...future.frame <- base::sys.nframe()
[16:12:32.922]     ...future.conditions <- base::list()
[16:12:32.922]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:32.922]     if (FALSE) {
[16:12:32.922]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:32.922]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:32.922]     }
[16:12:32.922]     ...future.result <- base::tryCatch({
[16:12:32.922]         base::withCallingHandlers({
[16:12:32.922]             ...future.value <- base::withVisible(base::local({
[16:12:32.922]                 lm(weight ~ group - 1)
[16:12:32.922]             }))
[16:12:32.922]             future::FutureResult(value = ...future.value$value, 
[16:12:32.922]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:32.922]                   ...future.rng), globalenv = if (FALSE) 
[16:12:32.922]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:32.922]                     ...future.globalenv.names))
[16:12:32.922]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:32.922]         }, condition = base::local({
[16:12:32.922]             c <- base::c
[16:12:32.922]             inherits <- base::inherits
[16:12:32.922]             invokeRestart <- base::invokeRestart
[16:12:32.922]             length <- base::length
[16:12:32.922]             list <- base::list
[16:12:32.922]             seq.int <- base::seq.int
[16:12:32.922]             signalCondition <- base::signalCondition
[16:12:32.922]             sys.calls <- base::sys.calls
[16:12:32.922]             `[[` <- base::`[[`
[16:12:32.922]             `+` <- base::`+`
[16:12:32.922]             `<<-` <- base::`<<-`
[16:12:32.922]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:32.922]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:32.922]                   3L)]
[16:12:32.922]             }
[16:12:32.922]             function(cond) {
[16:12:32.922]                 is_error <- inherits(cond, "error")
[16:12:32.922]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:32.922]                   NULL)
[16:12:32.922]                 if (is_error) {
[16:12:32.922]                   sessionInformation <- function() {
[16:12:32.922]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:32.922]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:32.922]                       search = base::search(), system = base::Sys.info())
[16:12:32.922]                   }
[16:12:32.922]                   ...future.conditions[[length(...future.conditions) + 
[16:12:32.922]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:32.922]                     cond$call), session = sessionInformation(), 
[16:12:32.922]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:32.922]                   signalCondition(cond)
[16:12:32.922]                 }
[16:12:32.922]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:32.922]                 "immediateCondition"))) {
[16:12:32.922]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:32.922]                   ...future.conditions[[length(...future.conditions) + 
[16:12:32.922]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:32.922]                   if (TRUE && !signal) {
[16:12:32.922]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:32.922]                     {
[16:12:32.922]                       inherits <- base::inherits
[16:12:32.922]                       invokeRestart <- base::invokeRestart
[16:12:32.922]                       is.null <- base::is.null
[16:12:32.922]                       muffled <- FALSE
[16:12:32.922]                       if (inherits(cond, "message")) {
[16:12:32.922]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:32.922]                         if (muffled) 
[16:12:32.922]                           invokeRestart("muffleMessage")
[16:12:32.922]                       }
[16:12:32.922]                       else if (inherits(cond, "warning")) {
[16:12:32.922]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:32.922]                         if (muffled) 
[16:12:32.922]                           invokeRestart("muffleWarning")
[16:12:32.922]                       }
[16:12:32.922]                       else if (inherits(cond, "condition")) {
[16:12:32.922]                         if (!is.null(pattern)) {
[16:12:32.922]                           computeRestarts <- base::computeRestarts
[16:12:32.922]                           grepl <- base::grepl
[16:12:32.922]                           restarts <- computeRestarts(cond)
[16:12:32.922]                           for (restart in restarts) {
[16:12:32.922]                             name <- restart$name
[16:12:32.922]                             if (is.null(name)) 
[16:12:32.922]                               next
[16:12:32.922]                             if (!grepl(pattern, name)) 
[16:12:32.922]                               next
[16:12:32.922]                             invokeRestart(restart)
[16:12:32.922]                             muffled <- TRUE
[16:12:32.922]                             break
[16:12:32.922]                           }
[16:12:32.922]                         }
[16:12:32.922]                       }
[16:12:32.922]                       invisible(muffled)
[16:12:32.922]                     }
[16:12:32.922]                     muffleCondition(cond, pattern = "^muffle")
[16:12:32.922]                   }
[16:12:32.922]                 }
[16:12:32.922]                 else {
[16:12:32.922]                   if (TRUE) {
[16:12:32.922]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:32.922]                     {
[16:12:32.922]                       inherits <- base::inherits
[16:12:32.922]                       invokeRestart <- base::invokeRestart
[16:12:32.922]                       is.null <- base::is.null
[16:12:32.922]                       muffled <- FALSE
[16:12:32.922]                       if (inherits(cond, "message")) {
[16:12:32.922]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:32.922]                         if (muffled) 
[16:12:32.922]                           invokeRestart("muffleMessage")
[16:12:32.922]                       }
[16:12:32.922]                       else if (inherits(cond, "warning")) {
[16:12:32.922]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:32.922]                         if (muffled) 
[16:12:32.922]                           invokeRestart("muffleWarning")
[16:12:32.922]                       }
[16:12:32.922]                       else if (inherits(cond, "condition")) {
[16:12:32.922]                         if (!is.null(pattern)) {
[16:12:32.922]                           computeRestarts <- base::computeRestarts
[16:12:32.922]                           grepl <- base::grepl
[16:12:32.922]                           restarts <- computeRestarts(cond)
[16:12:32.922]                           for (restart in restarts) {
[16:12:32.922]                             name <- restart$name
[16:12:32.922]                             if (is.null(name)) 
[16:12:32.922]                               next
[16:12:32.922]                             if (!grepl(pattern, name)) 
[16:12:32.922]                               next
[16:12:32.922]                             invokeRestart(restart)
[16:12:32.922]                             muffled <- TRUE
[16:12:32.922]                             break
[16:12:32.922]                           }
[16:12:32.922]                         }
[16:12:32.922]                       }
[16:12:32.922]                       invisible(muffled)
[16:12:32.922]                     }
[16:12:32.922]                     muffleCondition(cond, pattern = "^muffle")
[16:12:32.922]                   }
[16:12:32.922]                 }
[16:12:32.922]             }
[16:12:32.922]         }))
[16:12:32.922]     }, error = function(ex) {
[16:12:32.922]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:32.922]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:32.922]                 ...future.rng), started = ...future.startTime, 
[16:12:32.922]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:32.922]             version = "1.8"), class = "FutureResult")
[16:12:32.922]     }, finally = {
[16:12:32.922]         if (!identical(...future.workdir, getwd())) 
[16:12:32.922]             setwd(...future.workdir)
[16:12:32.922]         {
[16:12:32.922]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:32.922]                 ...future.oldOptions$nwarnings <- NULL
[16:12:32.922]             }
[16:12:32.922]             base::options(...future.oldOptions)
[16:12:32.922]             if (.Platform$OS.type == "windows") {
[16:12:32.922]                 old_names <- names(...future.oldEnvVars)
[16:12:32.922]                 envs <- base::Sys.getenv()
[16:12:32.922]                 names <- names(envs)
[16:12:32.922]                 common <- intersect(names, old_names)
[16:12:32.922]                 added <- setdiff(names, old_names)
[16:12:32.922]                 removed <- setdiff(old_names, names)
[16:12:32.922]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:32.922]                   envs[common]]
[16:12:32.922]                 NAMES <- toupper(changed)
[16:12:32.922]                 args <- list()
[16:12:32.922]                 for (kk in seq_along(NAMES)) {
[16:12:32.922]                   name <- changed[[kk]]
[16:12:32.922]                   NAME <- NAMES[[kk]]
[16:12:32.922]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:32.922]                     next
[16:12:32.922]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:32.922]                 }
[16:12:32.922]                 NAMES <- toupper(added)
[16:12:32.922]                 for (kk in seq_along(NAMES)) {
[16:12:32.922]                   name <- added[[kk]]
[16:12:32.922]                   NAME <- NAMES[[kk]]
[16:12:32.922]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:32.922]                     next
[16:12:32.922]                   args[[name]] <- ""
[16:12:32.922]                 }
[16:12:32.922]                 NAMES <- toupper(removed)
[16:12:32.922]                 for (kk in seq_along(NAMES)) {
[16:12:32.922]                   name <- removed[[kk]]
[16:12:32.922]                   NAME <- NAMES[[kk]]
[16:12:32.922]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:32.922]                     next
[16:12:32.922]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:32.922]                 }
[16:12:32.922]                 if (length(args) > 0) 
[16:12:32.922]                   base::do.call(base::Sys.setenv, args = args)
[16:12:32.922]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:32.922]             }
[16:12:32.922]             else {
[16:12:32.922]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:32.922]             }
[16:12:32.922]             {
[16:12:32.922]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:32.922]                   0L) {
[16:12:32.922]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:32.922]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:32.922]                   base::options(opts)
[16:12:32.922]                 }
[16:12:32.922]                 {
[16:12:32.922]                   {
[16:12:32.922]                     NULL
[16:12:32.922]                     RNGkind("Mersenne-Twister")
[16:12:32.922]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:32.922]                       inherits = FALSE)
[16:12:32.922]                   }
[16:12:32.922]                   options(future.plan = NULL)
[16:12:32.922]                   if (is.na(NA_character_)) 
[16:12:32.922]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:32.922]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:32.922]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:32.922]                   {
[16:12:32.922]                     future <- SequentialFuture(..., envir = envir)
[16:12:32.922]                     if (!future$lazy) 
[16:12:32.922]                       future <- run(future)
[16:12:32.922]                     invisible(future)
[16:12:32.922]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:32.922]                 }
[16:12:32.922]             }
[16:12:32.922]         }
[16:12:32.922]     })
[16:12:32.922]     if (TRUE) {
[16:12:32.922]         base::sink(type = "output", split = FALSE)
[16:12:32.922]         if (TRUE) {
[16:12:32.922]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:32.922]         }
[16:12:32.922]         else {
[16:12:32.922]             ...future.result["stdout"] <- base::list(NULL)
[16:12:32.922]         }
[16:12:32.922]         base::close(...future.stdout)
[16:12:32.922]         ...future.stdout <- NULL
[16:12:32.922]     }
[16:12:32.922]     ...future.result$conditions <- ...future.conditions
[16:12:32.922]     ...future.result$finished <- base::Sys.time()
[16:12:32.922]     ...future.result
[16:12:32.922] }
[16:12:32.924] assign_globals() ...
[16:12:32.924] List of 2
[16:12:32.924]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[16:12:32.924]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[16:12:32.924]  - attr(*, "where")=List of 2
[16:12:32.924]   ..$ weight:<environment: R_EmptyEnv> 
[16:12:32.924]   ..$ group :<environment: R_EmptyEnv> 
[16:12:32.924]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:32.924]  - attr(*, "resolved")= logi FALSE
[16:12:32.924]  - attr(*, "total_size")= num 896
[16:12:32.924]  - attr(*, "already-done")= logi TRUE
[16:12:32.927] - copied ‘weight’ to environment
[16:12:32.927] - copied ‘group’ to environment
[16:12:32.927] assign_globals() ... done
[16:12:32.928] plan(): Setting new future strategy stack:
[16:12:32.928] List of future strategies:
[16:12:32.928] 1. sequential:
[16:12:32.928]    - args: function (..., envir = parent.frame())
[16:12:32.928]    - tweaked: FALSE
[16:12:32.928]    - call: NULL
[16:12:32.928] plan(): nbrOfWorkers() = 1
[16:12:32.929] plan(): Setting new future strategy stack:
[16:12:32.929] List of future strategies:
[16:12:32.929] 1. sequential:
[16:12:32.929]    - args: function (..., envir = parent.frame())
[16:12:32.929]    - tweaked: FALSE
[16:12:32.929]    - call: plan(strategy)
[16:12:32.930] plan(): nbrOfWorkers() = 1
[16:12:32.930] SequentialFuture started (and completed)
[16:12:32.930] - Launch lazy future ... done
[16:12:32.930] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[16:12:32.932] getGlobalsAndPackages() ...
[16:12:32.932] Searching for globals...
[16:12:32.933] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:12:32.934] Searching for globals ... DONE
[16:12:32.934] Resolving globals: FALSE
[16:12:32.934] The total size of the 2 globals is 896 bytes (896 bytes)
[16:12:32.934] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:12:32.935] - globals: [2] ‘weight’, ‘group’
[16:12:32.935] - packages: [1] ‘stats’
[16:12:32.935] getGlobalsAndPackages() ... DONE
[16:12:32.935] run() for ‘Future’ ...
[16:12:32.935] - state: ‘created’
[16:12:32.935] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:32.936] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:32.936] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:32.936]   - Field: ‘label’
[16:12:32.936]   - Field: ‘local’
[16:12:32.936]   - Field: ‘owner’
[16:12:32.936]   - Field: ‘envir’
[16:12:32.936]   - Field: ‘packages’
[16:12:32.936]   - Field: ‘gc’
[16:12:32.936]   - Field: ‘conditions’
[16:12:32.936]   - Field: ‘expr’
[16:12:32.937]   - Field: ‘uuid’
[16:12:32.937]   - Field: ‘seed’
[16:12:32.937]   - Field: ‘version’
[16:12:32.937]   - Field: ‘result’
[16:12:32.937]   - Field: ‘asynchronous’
[16:12:32.937]   - Field: ‘calls’
[16:12:32.937]   - Field: ‘globals’
[16:12:32.937]   - Field: ‘stdout’
[16:12:32.937]   - Field: ‘earlySignal’
[16:12:32.937]   - Field: ‘lazy’
[16:12:32.937]   - Field: ‘state’
[16:12:32.937] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:32.938] - Launch lazy future ...
[16:12:32.938] Packages needed by the future expression (n = 1): ‘stats’
[16:12:32.938] Packages needed by future strategies (n = 0): <none>
[16:12:32.938] {
[16:12:32.938]     {
[16:12:32.938]         {
[16:12:32.938]             ...future.startTime <- base::Sys.time()
[16:12:32.938]             {
[16:12:32.938]                 {
[16:12:32.938]                   {
[16:12:32.938]                     {
[16:12:32.938]                       base::local({
[16:12:32.938]                         has_future <- base::requireNamespace("future", 
[16:12:32.938]                           quietly = TRUE)
[16:12:32.938]                         if (has_future) {
[16:12:32.938]                           ns <- base::getNamespace("future")
[16:12:32.938]                           version <- ns[[".package"]][["version"]]
[16:12:32.938]                           if (is.null(version)) 
[16:12:32.938]                             version <- utils::packageVersion("future")
[16:12:32.938]                         }
[16:12:32.938]                         else {
[16:12:32.938]                           version <- NULL
[16:12:32.938]                         }
[16:12:32.938]                         if (!has_future || version < "1.8.0") {
[16:12:32.938]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:32.938]                             "", base::R.version$version.string), 
[16:12:32.938]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:32.938]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:32.938]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:32.938]                               "release", "version")], collapse = " "), 
[16:12:32.938]                             hostname = base::Sys.info()[["nodename"]])
[16:12:32.938]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:32.938]                             info)
[16:12:32.938]                           info <- base::paste(info, collapse = "; ")
[16:12:32.938]                           if (!has_future) {
[16:12:32.938]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:32.938]                               info)
[16:12:32.938]                           }
[16:12:32.938]                           else {
[16:12:32.938]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:32.938]                               info, version)
[16:12:32.938]                           }
[16:12:32.938]                           base::stop(msg)
[16:12:32.938]                         }
[16:12:32.938]                       })
[16:12:32.938]                     }
[16:12:32.938]                     base::local({
[16:12:32.938]                       for (pkg in "stats") {
[16:12:32.938]                         base::loadNamespace(pkg)
[16:12:32.938]                         base::library(pkg, character.only = TRUE)
[16:12:32.938]                       }
[16:12:32.938]                     })
[16:12:32.938]                   }
[16:12:32.938]                   options(future.plan = NULL)
[16:12:32.938]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:32.938]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:32.938]                 }
[16:12:32.938]                 ...future.workdir <- getwd()
[16:12:32.938]             }
[16:12:32.938]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:32.938]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:32.938]         }
[16:12:32.938]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:32.938]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:32.938]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:32.938]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:32.938]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:32.938]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:32.938]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:32.938]             base::names(...future.oldOptions))
[16:12:32.938]     }
[16:12:32.938]     if (FALSE) {
[16:12:32.938]     }
[16:12:32.938]     else {
[16:12:32.938]         if (TRUE) {
[16:12:32.938]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:32.938]                 open = "w")
[16:12:32.938]         }
[16:12:32.938]         else {
[16:12:32.938]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:32.938]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:32.938]         }
[16:12:32.938]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:32.938]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:32.938]             base::sink(type = "output", split = FALSE)
[16:12:32.938]             base::close(...future.stdout)
[16:12:32.938]         }, add = TRUE)
[16:12:32.938]     }
[16:12:32.938]     ...future.frame <- base::sys.nframe()
[16:12:32.938]     ...future.conditions <- base::list()
[16:12:32.938]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:32.938]     if (FALSE) {
[16:12:32.938]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:32.938]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:32.938]     }
[16:12:32.938]     ...future.result <- base::tryCatch({
[16:12:32.938]         base::withCallingHandlers({
[16:12:32.938]             ...future.value <- base::withVisible(base::local({
[16:12:32.938]                 lm(weight ~ group - 1)
[16:12:32.938]             }))
[16:12:32.938]             future::FutureResult(value = ...future.value$value, 
[16:12:32.938]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:32.938]                   ...future.rng), globalenv = if (FALSE) 
[16:12:32.938]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:32.938]                     ...future.globalenv.names))
[16:12:32.938]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:32.938]         }, condition = base::local({
[16:12:32.938]             c <- base::c
[16:12:32.938]             inherits <- base::inherits
[16:12:32.938]             invokeRestart <- base::invokeRestart
[16:12:32.938]             length <- base::length
[16:12:32.938]             list <- base::list
[16:12:32.938]             seq.int <- base::seq.int
[16:12:32.938]             signalCondition <- base::signalCondition
[16:12:32.938]             sys.calls <- base::sys.calls
[16:12:32.938]             `[[` <- base::`[[`
[16:12:32.938]             `+` <- base::`+`
[16:12:32.938]             `<<-` <- base::`<<-`
[16:12:32.938]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:32.938]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:32.938]                   3L)]
[16:12:32.938]             }
[16:12:32.938]             function(cond) {
[16:12:32.938]                 is_error <- inherits(cond, "error")
[16:12:32.938]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:32.938]                   NULL)
[16:12:32.938]                 if (is_error) {
[16:12:32.938]                   sessionInformation <- function() {
[16:12:32.938]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:32.938]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:32.938]                       search = base::search(), system = base::Sys.info())
[16:12:32.938]                   }
[16:12:32.938]                   ...future.conditions[[length(...future.conditions) + 
[16:12:32.938]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:32.938]                     cond$call), session = sessionInformation(), 
[16:12:32.938]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:32.938]                   signalCondition(cond)
[16:12:32.938]                 }
[16:12:32.938]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:32.938]                 "immediateCondition"))) {
[16:12:32.938]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:32.938]                   ...future.conditions[[length(...future.conditions) + 
[16:12:32.938]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:32.938]                   if (TRUE && !signal) {
[16:12:32.938]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:32.938]                     {
[16:12:32.938]                       inherits <- base::inherits
[16:12:32.938]                       invokeRestart <- base::invokeRestart
[16:12:32.938]                       is.null <- base::is.null
[16:12:32.938]                       muffled <- FALSE
[16:12:32.938]                       if (inherits(cond, "message")) {
[16:12:32.938]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:32.938]                         if (muffled) 
[16:12:32.938]                           invokeRestart("muffleMessage")
[16:12:32.938]                       }
[16:12:32.938]                       else if (inherits(cond, "warning")) {
[16:12:32.938]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:32.938]                         if (muffled) 
[16:12:32.938]                           invokeRestart("muffleWarning")
[16:12:32.938]                       }
[16:12:32.938]                       else if (inherits(cond, "condition")) {
[16:12:32.938]                         if (!is.null(pattern)) {
[16:12:32.938]                           computeRestarts <- base::computeRestarts
[16:12:32.938]                           grepl <- base::grepl
[16:12:32.938]                           restarts <- computeRestarts(cond)
[16:12:32.938]                           for (restart in restarts) {
[16:12:32.938]                             name <- restart$name
[16:12:32.938]                             if (is.null(name)) 
[16:12:32.938]                               next
[16:12:32.938]                             if (!grepl(pattern, name)) 
[16:12:32.938]                               next
[16:12:32.938]                             invokeRestart(restart)
[16:12:32.938]                             muffled <- TRUE
[16:12:32.938]                             break
[16:12:32.938]                           }
[16:12:32.938]                         }
[16:12:32.938]                       }
[16:12:32.938]                       invisible(muffled)
[16:12:32.938]                     }
[16:12:32.938]                     muffleCondition(cond, pattern = "^muffle")
[16:12:32.938]                   }
[16:12:32.938]                 }
[16:12:32.938]                 else {
[16:12:32.938]                   if (TRUE) {
[16:12:32.938]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:32.938]                     {
[16:12:32.938]                       inherits <- base::inherits
[16:12:32.938]                       invokeRestart <- base::invokeRestart
[16:12:32.938]                       is.null <- base::is.null
[16:12:32.938]                       muffled <- FALSE
[16:12:32.938]                       if (inherits(cond, "message")) {
[16:12:32.938]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:32.938]                         if (muffled) 
[16:12:32.938]                           invokeRestart("muffleMessage")
[16:12:32.938]                       }
[16:12:32.938]                       else if (inherits(cond, "warning")) {
[16:12:32.938]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:32.938]                         if (muffled) 
[16:12:32.938]                           invokeRestart("muffleWarning")
[16:12:32.938]                       }
[16:12:32.938]                       else if (inherits(cond, "condition")) {
[16:12:32.938]                         if (!is.null(pattern)) {
[16:12:32.938]                           computeRestarts <- base::computeRestarts
[16:12:32.938]                           grepl <- base::grepl
[16:12:32.938]                           restarts <- computeRestarts(cond)
[16:12:32.938]                           for (restart in restarts) {
[16:12:32.938]                             name <- restart$name
[16:12:32.938]                             if (is.null(name)) 
[16:12:32.938]                               next
[16:12:32.938]                             if (!grepl(pattern, name)) 
[16:12:32.938]                               next
[16:12:32.938]                             invokeRestart(restart)
[16:12:32.938]                             muffled <- TRUE
[16:12:32.938]                             break
[16:12:32.938]                           }
[16:12:32.938]                         }
[16:12:32.938]                       }
[16:12:32.938]                       invisible(muffled)
[16:12:32.938]                     }
[16:12:32.938]                     muffleCondition(cond, pattern = "^muffle")
[16:12:32.938]                   }
[16:12:32.938]                 }
[16:12:32.938]             }
[16:12:32.938]         }))
[16:12:32.938]     }, error = function(ex) {
[16:12:32.938]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:32.938]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:32.938]                 ...future.rng), started = ...future.startTime, 
[16:12:32.938]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:32.938]             version = "1.8"), class = "FutureResult")
[16:12:32.938]     }, finally = {
[16:12:32.938]         if (!identical(...future.workdir, getwd())) 
[16:12:32.938]             setwd(...future.workdir)
[16:12:32.938]         {
[16:12:32.938]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:32.938]                 ...future.oldOptions$nwarnings <- NULL
[16:12:32.938]             }
[16:12:32.938]             base::options(...future.oldOptions)
[16:12:32.938]             if (.Platform$OS.type == "windows") {
[16:12:32.938]                 old_names <- names(...future.oldEnvVars)
[16:12:32.938]                 envs <- base::Sys.getenv()
[16:12:32.938]                 names <- names(envs)
[16:12:32.938]                 common <- intersect(names, old_names)
[16:12:32.938]                 added <- setdiff(names, old_names)
[16:12:32.938]                 removed <- setdiff(old_names, names)
[16:12:32.938]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:32.938]                   envs[common]]
[16:12:32.938]                 NAMES <- toupper(changed)
[16:12:32.938]                 args <- list()
[16:12:32.938]                 for (kk in seq_along(NAMES)) {
[16:12:32.938]                   name <- changed[[kk]]
[16:12:32.938]                   NAME <- NAMES[[kk]]
[16:12:32.938]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:32.938]                     next
[16:12:32.938]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:32.938]                 }
[16:12:32.938]                 NAMES <- toupper(added)
[16:12:32.938]                 for (kk in seq_along(NAMES)) {
[16:12:32.938]                   name <- added[[kk]]
[16:12:32.938]                   NAME <- NAMES[[kk]]
[16:12:32.938]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:32.938]                     next
[16:12:32.938]                   args[[name]] <- ""
[16:12:32.938]                 }
[16:12:32.938]                 NAMES <- toupper(removed)
[16:12:32.938]                 for (kk in seq_along(NAMES)) {
[16:12:32.938]                   name <- removed[[kk]]
[16:12:32.938]                   NAME <- NAMES[[kk]]
[16:12:32.938]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:32.938]                     next
[16:12:32.938]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:32.938]                 }
[16:12:32.938]                 if (length(args) > 0) 
[16:12:32.938]                   base::do.call(base::Sys.setenv, args = args)
[16:12:32.938]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:32.938]             }
[16:12:32.938]             else {
[16:12:32.938]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:32.938]             }
[16:12:32.938]             {
[16:12:32.938]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:32.938]                   0L) {
[16:12:32.938]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:32.938]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:32.938]                   base::options(opts)
[16:12:32.938]                 }
[16:12:32.938]                 {
[16:12:32.938]                   {
[16:12:32.938]                     NULL
[16:12:32.938]                     RNGkind("Mersenne-Twister")
[16:12:32.938]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:32.938]                       inherits = FALSE)
[16:12:32.938]                   }
[16:12:32.938]                   options(future.plan = NULL)
[16:12:32.938]                   if (is.na(NA_character_)) 
[16:12:32.938]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:32.938]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:32.938]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:32.938]                   {
[16:12:32.938]                     future <- SequentialFuture(..., envir = envir)
[16:12:32.938]                     if (!future$lazy) 
[16:12:32.938]                       future <- run(future)
[16:12:32.938]                     invisible(future)
[16:12:32.938]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:32.938]                 }
[16:12:32.938]             }
[16:12:32.938]         }
[16:12:32.938]     })
[16:12:32.938]     if (TRUE) {
[16:12:32.938]         base::sink(type = "output", split = FALSE)
[16:12:32.938]         if (TRUE) {
[16:12:32.938]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:32.938]         }
[16:12:32.938]         else {
[16:12:32.938]             ...future.result["stdout"] <- base::list(NULL)
[16:12:32.938]         }
[16:12:32.938]         base::close(...future.stdout)
[16:12:32.938]         ...future.stdout <- NULL
[16:12:32.938]     }
[16:12:32.938]     ...future.result$conditions <- ...future.conditions
[16:12:32.938]     ...future.result$finished <- base::Sys.time()
[16:12:32.938]     ...future.result
[16:12:32.938] }
[16:12:32.940] assign_globals() ...
[16:12:32.940] List of 2
[16:12:32.940]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[16:12:32.940]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[16:12:32.940]  - attr(*, "where")=List of 2
[16:12:32.940]   ..$ weight:<environment: R_EmptyEnv> 
[16:12:32.940]   ..$ group :<environment: R_EmptyEnv> 
[16:12:32.940]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:32.940]  - attr(*, "resolved")= logi FALSE
[16:12:32.940]  - attr(*, "total_size")= num 896
[16:12:32.940]  - attr(*, "already-done")= logi TRUE
[16:12:32.943] - copied ‘weight’ to environment
[16:12:32.943] - copied ‘group’ to environment
[16:12:32.943] assign_globals() ... done
[16:12:32.943] plan(): Setting new future strategy stack:
[16:12:32.944] List of future strategies:
[16:12:32.944] 1. sequential:
[16:12:32.944]    - args: function (..., envir = parent.frame())
[16:12:32.944]    - tweaked: FALSE
[16:12:32.944]    - call: NULL
[16:12:32.944] plan(): nbrOfWorkers() = 1
[16:12:32.945] plan(): Setting new future strategy stack:
[16:12:32.945] List of future strategies:
[16:12:32.945] 1. sequential:
[16:12:32.945]    - args: function (..., envir = parent.frame())
[16:12:32.945]    - tweaked: FALSE
[16:12:32.945]    - call: plan(strategy)
[16:12:32.946] plan(): nbrOfWorkers() = 1
[16:12:32.947] SequentialFuture started (and completed)
[16:12:32.947] - Launch lazy future ... done
[16:12:32.947] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[16:12:32.949] getGlobalsAndPackages() ...
[16:12:32.949] Searching for globals...
[16:12:32.950] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[16:12:32.950] Searching for globals ... DONE
[16:12:32.950] Resolving globals: FALSE
[16:12:32.951] The total size of the 1 globals is 96 bytes (96 bytes)
[16:12:32.951] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[16:12:32.951] - globals: [1] ‘x’
[16:12:32.951] - packages: [1] ‘stats’
[16:12:32.951] getGlobalsAndPackages() ... DONE
[16:12:32.952] run() for ‘Future’ ...
[16:12:32.952] - state: ‘created’
[16:12:32.952] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:32.952] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:32.952] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:32.952]   - Field: ‘label’
[16:12:32.952]   - Field: ‘local’
[16:12:32.952]   - Field: ‘owner’
[16:12:32.953]   - Field: ‘envir’
[16:12:32.953]   - Field: ‘packages’
[16:12:32.953]   - Field: ‘gc’
[16:12:32.953]   - Field: ‘conditions’
[16:12:32.953]   - Field: ‘expr’
[16:12:32.953]   - Field: ‘uuid’
[16:12:32.953]   - Field: ‘seed’
[16:12:32.953]   - Field: ‘version’
[16:12:32.953]   - Field: ‘result’
[16:12:32.953]   - Field: ‘asynchronous’
[16:12:32.953]   - Field: ‘calls’
[16:12:32.953]   - Field: ‘globals’
[16:12:32.954]   - Field: ‘stdout’
[16:12:32.954]   - Field: ‘earlySignal’
[16:12:32.954]   - Field: ‘lazy’
[16:12:32.954]   - Field: ‘state’
[16:12:32.954] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:32.954] - Launch lazy future ...
[16:12:32.954] Packages needed by the future expression (n = 1): ‘stats’
[16:12:32.954] Packages needed by future strategies (n = 0): <none>
[16:12:32.955] {
[16:12:32.955]     {
[16:12:32.955]         {
[16:12:32.955]             ...future.startTime <- base::Sys.time()
[16:12:32.955]             {
[16:12:32.955]                 {
[16:12:32.955]                   {
[16:12:32.955]                     {
[16:12:32.955]                       base::local({
[16:12:32.955]                         has_future <- base::requireNamespace("future", 
[16:12:32.955]                           quietly = TRUE)
[16:12:32.955]                         if (has_future) {
[16:12:32.955]                           ns <- base::getNamespace("future")
[16:12:32.955]                           version <- ns[[".package"]][["version"]]
[16:12:32.955]                           if (is.null(version)) 
[16:12:32.955]                             version <- utils::packageVersion("future")
[16:12:32.955]                         }
[16:12:32.955]                         else {
[16:12:32.955]                           version <- NULL
[16:12:32.955]                         }
[16:12:32.955]                         if (!has_future || version < "1.8.0") {
[16:12:32.955]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:32.955]                             "", base::R.version$version.string), 
[16:12:32.955]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:32.955]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:32.955]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:32.955]                               "release", "version")], collapse = " "), 
[16:12:32.955]                             hostname = base::Sys.info()[["nodename"]])
[16:12:32.955]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:32.955]                             info)
[16:12:32.955]                           info <- base::paste(info, collapse = "; ")
[16:12:32.955]                           if (!has_future) {
[16:12:32.955]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:32.955]                               info)
[16:12:32.955]                           }
[16:12:32.955]                           else {
[16:12:32.955]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:32.955]                               info, version)
[16:12:32.955]                           }
[16:12:32.955]                           base::stop(msg)
[16:12:32.955]                         }
[16:12:32.955]                       })
[16:12:32.955]                     }
[16:12:32.955]                     base::local({
[16:12:32.955]                       for (pkg in "stats") {
[16:12:32.955]                         base::loadNamespace(pkg)
[16:12:32.955]                         base::library(pkg, character.only = TRUE)
[16:12:32.955]                       }
[16:12:32.955]                     })
[16:12:32.955]                   }
[16:12:32.955]                   options(future.plan = NULL)
[16:12:32.955]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:32.955]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:32.955]                 }
[16:12:32.955]                 ...future.workdir <- getwd()
[16:12:32.955]             }
[16:12:32.955]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:32.955]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:32.955]         }
[16:12:32.955]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:32.955]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:32.955]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:32.955]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:32.955]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:32.955]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:32.955]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:32.955]             base::names(...future.oldOptions))
[16:12:32.955]     }
[16:12:32.955]     if (FALSE) {
[16:12:32.955]     }
[16:12:32.955]     else {
[16:12:32.955]         if (TRUE) {
[16:12:32.955]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:32.955]                 open = "w")
[16:12:32.955]         }
[16:12:32.955]         else {
[16:12:32.955]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:32.955]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:32.955]         }
[16:12:32.955]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:32.955]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:32.955]             base::sink(type = "output", split = FALSE)
[16:12:32.955]             base::close(...future.stdout)
[16:12:32.955]         }, add = TRUE)
[16:12:32.955]     }
[16:12:32.955]     ...future.frame <- base::sys.nframe()
[16:12:32.955]     ...future.conditions <- base::list()
[16:12:32.955]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:32.955]     if (FALSE) {
[16:12:32.955]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:32.955]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:32.955]     }
[16:12:32.955]     ...future.result <- base::tryCatch({
[16:12:32.955]         base::withCallingHandlers({
[16:12:32.955]             ...future.value <- base::withVisible(base::local({
[16:12:32.955]                 xtabs(~x)
[16:12:32.955]             }))
[16:12:32.955]             future::FutureResult(value = ...future.value$value, 
[16:12:32.955]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:32.955]                   ...future.rng), globalenv = if (FALSE) 
[16:12:32.955]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:32.955]                     ...future.globalenv.names))
[16:12:32.955]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:32.955]         }, condition = base::local({
[16:12:32.955]             c <- base::c
[16:12:32.955]             inherits <- base::inherits
[16:12:32.955]             invokeRestart <- base::invokeRestart
[16:12:32.955]             length <- base::length
[16:12:32.955]             list <- base::list
[16:12:32.955]             seq.int <- base::seq.int
[16:12:32.955]             signalCondition <- base::signalCondition
[16:12:32.955]             sys.calls <- base::sys.calls
[16:12:32.955]             `[[` <- base::`[[`
[16:12:32.955]             `+` <- base::`+`
[16:12:32.955]             `<<-` <- base::`<<-`
[16:12:32.955]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:32.955]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:32.955]                   3L)]
[16:12:32.955]             }
[16:12:32.955]             function(cond) {
[16:12:32.955]                 is_error <- inherits(cond, "error")
[16:12:32.955]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:32.955]                   NULL)
[16:12:32.955]                 if (is_error) {
[16:12:32.955]                   sessionInformation <- function() {
[16:12:32.955]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:32.955]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:32.955]                       search = base::search(), system = base::Sys.info())
[16:12:32.955]                   }
[16:12:32.955]                   ...future.conditions[[length(...future.conditions) + 
[16:12:32.955]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:32.955]                     cond$call), session = sessionInformation(), 
[16:12:32.955]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:32.955]                   signalCondition(cond)
[16:12:32.955]                 }
[16:12:32.955]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:32.955]                 "immediateCondition"))) {
[16:12:32.955]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:32.955]                   ...future.conditions[[length(...future.conditions) + 
[16:12:32.955]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:32.955]                   if (TRUE && !signal) {
[16:12:32.955]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:32.955]                     {
[16:12:32.955]                       inherits <- base::inherits
[16:12:32.955]                       invokeRestart <- base::invokeRestart
[16:12:32.955]                       is.null <- base::is.null
[16:12:32.955]                       muffled <- FALSE
[16:12:32.955]                       if (inherits(cond, "message")) {
[16:12:32.955]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:32.955]                         if (muffled) 
[16:12:32.955]                           invokeRestart("muffleMessage")
[16:12:32.955]                       }
[16:12:32.955]                       else if (inherits(cond, "warning")) {
[16:12:32.955]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:32.955]                         if (muffled) 
[16:12:32.955]                           invokeRestart("muffleWarning")
[16:12:32.955]                       }
[16:12:32.955]                       else if (inherits(cond, "condition")) {
[16:12:32.955]                         if (!is.null(pattern)) {
[16:12:32.955]                           computeRestarts <- base::computeRestarts
[16:12:32.955]                           grepl <- base::grepl
[16:12:32.955]                           restarts <- computeRestarts(cond)
[16:12:32.955]                           for (restart in restarts) {
[16:12:32.955]                             name <- restart$name
[16:12:32.955]                             if (is.null(name)) 
[16:12:32.955]                               next
[16:12:32.955]                             if (!grepl(pattern, name)) 
[16:12:32.955]                               next
[16:12:32.955]                             invokeRestart(restart)
[16:12:32.955]                             muffled <- TRUE
[16:12:32.955]                             break
[16:12:32.955]                           }
[16:12:32.955]                         }
[16:12:32.955]                       }
[16:12:32.955]                       invisible(muffled)
[16:12:32.955]                     }
[16:12:32.955]                     muffleCondition(cond, pattern = "^muffle")
[16:12:32.955]                   }
[16:12:32.955]                 }
[16:12:32.955]                 else {
[16:12:32.955]                   if (TRUE) {
[16:12:32.955]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:32.955]                     {
[16:12:32.955]                       inherits <- base::inherits
[16:12:32.955]                       invokeRestart <- base::invokeRestart
[16:12:32.955]                       is.null <- base::is.null
[16:12:32.955]                       muffled <- FALSE
[16:12:32.955]                       if (inherits(cond, "message")) {
[16:12:32.955]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:32.955]                         if (muffled) 
[16:12:32.955]                           invokeRestart("muffleMessage")
[16:12:32.955]                       }
[16:12:32.955]                       else if (inherits(cond, "warning")) {
[16:12:32.955]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:32.955]                         if (muffled) 
[16:12:32.955]                           invokeRestart("muffleWarning")
[16:12:32.955]                       }
[16:12:32.955]                       else if (inherits(cond, "condition")) {
[16:12:32.955]                         if (!is.null(pattern)) {
[16:12:32.955]                           computeRestarts <- base::computeRestarts
[16:12:32.955]                           grepl <- base::grepl
[16:12:32.955]                           restarts <- computeRestarts(cond)
[16:12:32.955]                           for (restart in restarts) {
[16:12:32.955]                             name <- restart$name
[16:12:32.955]                             if (is.null(name)) 
[16:12:32.955]                               next
[16:12:32.955]                             if (!grepl(pattern, name)) 
[16:12:32.955]                               next
[16:12:32.955]                             invokeRestart(restart)
[16:12:32.955]                             muffled <- TRUE
[16:12:32.955]                             break
[16:12:32.955]                           }
[16:12:32.955]                         }
[16:12:32.955]                       }
[16:12:32.955]                       invisible(muffled)
[16:12:32.955]                     }
[16:12:32.955]                     muffleCondition(cond, pattern = "^muffle")
[16:12:32.955]                   }
[16:12:32.955]                 }
[16:12:32.955]             }
[16:12:32.955]         }))
[16:12:32.955]     }, error = function(ex) {
[16:12:32.955]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:32.955]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:32.955]                 ...future.rng), started = ...future.startTime, 
[16:12:32.955]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:32.955]             version = "1.8"), class = "FutureResult")
[16:12:32.955]     }, finally = {
[16:12:32.955]         if (!identical(...future.workdir, getwd())) 
[16:12:32.955]             setwd(...future.workdir)
[16:12:32.955]         {
[16:12:32.955]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:32.955]                 ...future.oldOptions$nwarnings <- NULL
[16:12:32.955]             }
[16:12:32.955]             base::options(...future.oldOptions)
[16:12:32.955]             if (.Platform$OS.type == "windows") {
[16:12:32.955]                 old_names <- names(...future.oldEnvVars)
[16:12:32.955]                 envs <- base::Sys.getenv()
[16:12:32.955]                 names <- names(envs)
[16:12:32.955]                 common <- intersect(names, old_names)
[16:12:32.955]                 added <- setdiff(names, old_names)
[16:12:32.955]                 removed <- setdiff(old_names, names)
[16:12:32.955]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:32.955]                   envs[common]]
[16:12:32.955]                 NAMES <- toupper(changed)
[16:12:32.955]                 args <- list()
[16:12:32.955]                 for (kk in seq_along(NAMES)) {
[16:12:32.955]                   name <- changed[[kk]]
[16:12:32.955]                   NAME <- NAMES[[kk]]
[16:12:32.955]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:32.955]                     next
[16:12:32.955]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:32.955]                 }
[16:12:32.955]                 NAMES <- toupper(added)
[16:12:32.955]                 for (kk in seq_along(NAMES)) {
[16:12:32.955]                   name <- added[[kk]]
[16:12:32.955]                   NAME <- NAMES[[kk]]
[16:12:32.955]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:32.955]                     next
[16:12:32.955]                   args[[name]] <- ""
[16:12:32.955]                 }
[16:12:32.955]                 NAMES <- toupper(removed)
[16:12:32.955]                 for (kk in seq_along(NAMES)) {
[16:12:32.955]                   name <- removed[[kk]]
[16:12:32.955]                   NAME <- NAMES[[kk]]
[16:12:32.955]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:32.955]                     next
[16:12:32.955]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:32.955]                 }
[16:12:32.955]                 if (length(args) > 0) 
[16:12:32.955]                   base::do.call(base::Sys.setenv, args = args)
[16:12:32.955]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:32.955]             }
[16:12:32.955]             else {
[16:12:32.955]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:32.955]             }
[16:12:32.955]             {
[16:12:32.955]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:32.955]                   0L) {
[16:12:32.955]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:32.955]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:32.955]                   base::options(opts)
[16:12:32.955]                 }
[16:12:32.955]                 {
[16:12:32.955]                   {
[16:12:32.955]                     NULL
[16:12:32.955]                     RNGkind("Mersenne-Twister")
[16:12:32.955]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:32.955]                       inherits = FALSE)
[16:12:32.955]                   }
[16:12:32.955]                   options(future.plan = NULL)
[16:12:32.955]                   if (is.na(NA_character_)) 
[16:12:32.955]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:32.955]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:32.955]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:32.955]                   {
[16:12:32.955]                     future <- SequentialFuture(..., envir = envir)
[16:12:32.955]                     if (!future$lazy) 
[16:12:32.955]                       future <- run(future)
[16:12:32.955]                     invisible(future)
[16:12:32.955]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:32.955]                 }
[16:12:32.955]             }
[16:12:32.955]         }
[16:12:32.955]     })
[16:12:32.955]     if (TRUE) {
[16:12:32.955]         base::sink(type = "output", split = FALSE)
[16:12:32.955]         if (TRUE) {
[16:12:32.955]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:32.955]         }
[16:12:32.955]         else {
[16:12:32.955]             ...future.result["stdout"] <- base::list(NULL)
[16:12:32.955]         }
[16:12:32.955]         base::close(...future.stdout)
[16:12:32.955]         ...future.stdout <- NULL
[16:12:32.955]     }
[16:12:32.955]     ...future.result$conditions <- ...future.conditions
[16:12:32.955]     ...future.result$finished <- base::Sys.time()
[16:12:32.955]     ...future.result
[16:12:32.955] }
[16:12:32.956] assign_globals() ...
[16:12:32.956] List of 1
[16:12:32.956]  $ x: num [1:5] 1 1 2 2 2
[16:12:32.956]  - attr(*, "where")=List of 1
[16:12:32.956]   ..$ x:<environment: R_EmptyEnv> 
[16:12:32.956]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:32.956]  - attr(*, "resolved")= logi FALSE
[16:12:32.956]  - attr(*, "total_size")= num 96
[16:12:32.956]  - attr(*, "already-done")= logi TRUE
[16:12:32.959] - copied ‘x’ to environment
[16:12:32.959] assign_globals() ... done
[16:12:32.959] plan(): Setting new future strategy stack:
[16:12:32.959] List of future strategies:
[16:12:32.959] 1. sequential:
[16:12:32.959]    - args: function (..., envir = parent.frame())
[16:12:32.959]    - tweaked: FALSE
[16:12:32.959]    - call: NULL
[16:12:32.960] plan(): nbrOfWorkers() = 1
[16:12:32.961] plan(): Setting new future strategy stack:
[16:12:32.961] List of future strategies:
[16:12:32.961] 1. sequential:
[16:12:32.961]    - args: function (..., envir = parent.frame())
[16:12:32.961]    - tweaked: FALSE
[16:12:32.961]    - call: plan(strategy)
[16:12:32.961] plan(): nbrOfWorkers() = 1
[16:12:32.961] SequentialFuture started (and completed)
[16:12:32.961] - Launch lazy future ... done
[16:12:32.961] run() for ‘SequentialFuture’ ... done
x
1 2 
2 3 
[16:12:32.962] getGlobalsAndPackages() ...
[16:12:32.962] Searching for globals...
[16:12:32.963] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[16:12:32.963] Searching for globals ... DONE
[16:12:32.963] Resolving globals: FALSE
[16:12:32.964] The total size of the 1 globals is 96 bytes (96 bytes)
[16:12:32.964] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[16:12:32.964] - globals: [1] ‘x’
[16:12:32.964] - packages: [1] ‘stats’
[16:12:32.964] getGlobalsAndPackages() ... DONE
[16:12:32.965] run() for ‘Future’ ...
[16:12:32.965] - state: ‘created’
[16:12:32.965] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:32.965] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:32.965] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:32.965]   - Field: ‘label’
[16:12:32.965]   - Field: ‘local’
[16:12:32.966]   - Field: ‘owner’
[16:12:32.966]   - Field: ‘envir’
[16:12:32.966]   - Field: ‘packages’
[16:12:32.966]   - Field: ‘gc’
[16:12:32.966]   - Field: ‘conditions’
[16:12:32.966]   - Field: ‘expr’
[16:12:32.966]   - Field: ‘uuid’
[16:12:32.966]   - Field: ‘seed’
[16:12:32.967]   - Field: ‘version’
[16:12:32.967]   - Field: ‘result’
[16:12:32.967]   - Field: ‘asynchronous’
[16:12:32.967]   - Field: ‘calls’
[16:12:32.967]   - Field: ‘globals’
[16:12:32.967]   - Field: ‘stdout’
[16:12:32.967]   - Field: ‘earlySignal’
[16:12:32.967]   - Field: ‘lazy’
[16:12:32.968]   - Field: ‘state’
[16:12:32.968] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:32.968] - Launch lazy future ...
[16:12:32.968] Packages needed by the future expression (n = 1): ‘stats’
[16:12:32.968] Packages needed by future strategies (n = 0): <none>
[16:12:32.969] {
[16:12:32.969]     {
[16:12:32.969]         {
[16:12:32.969]             ...future.startTime <- base::Sys.time()
[16:12:32.969]             {
[16:12:32.969]                 {
[16:12:32.969]                   {
[16:12:32.969]                     {
[16:12:32.969]                       base::local({
[16:12:32.969]                         has_future <- base::requireNamespace("future", 
[16:12:32.969]                           quietly = TRUE)
[16:12:32.969]                         if (has_future) {
[16:12:32.969]                           ns <- base::getNamespace("future")
[16:12:32.969]                           version <- ns[[".package"]][["version"]]
[16:12:32.969]                           if (is.null(version)) 
[16:12:32.969]                             version <- utils::packageVersion("future")
[16:12:32.969]                         }
[16:12:32.969]                         else {
[16:12:32.969]                           version <- NULL
[16:12:32.969]                         }
[16:12:32.969]                         if (!has_future || version < "1.8.0") {
[16:12:32.969]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:32.969]                             "", base::R.version$version.string), 
[16:12:32.969]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:32.969]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:32.969]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:32.969]                               "release", "version")], collapse = " "), 
[16:12:32.969]                             hostname = base::Sys.info()[["nodename"]])
[16:12:32.969]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:32.969]                             info)
[16:12:32.969]                           info <- base::paste(info, collapse = "; ")
[16:12:32.969]                           if (!has_future) {
[16:12:32.969]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:32.969]                               info)
[16:12:32.969]                           }
[16:12:32.969]                           else {
[16:12:32.969]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:32.969]                               info, version)
[16:12:32.969]                           }
[16:12:32.969]                           base::stop(msg)
[16:12:32.969]                         }
[16:12:32.969]                       })
[16:12:32.969]                     }
[16:12:32.969]                     base::local({
[16:12:32.969]                       for (pkg in "stats") {
[16:12:32.969]                         base::loadNamespace(pkg)
[16:12:32.969]                         base::library(pkg, character.only = TRUE)
[16:12:32.969]                       }
[16:12:32.969]                     })
[16:12:32.969]                   }
[16:12:32.969]                   options(future.plan = NULL)
[16:12:32.969]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:32.969]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:32.969]                 }
[16:12:32.969]                 ...future.workdir <- getwd()
[16:12:32.969]             }
[16:12:32.969]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:32.969]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:32.969]         }
[16:12:32.969]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:32.969]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:32.969]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:32.969]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:32.969]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:32.969]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:32.969]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:32.969]             base::names(...future.oldOptions))
[16:12:32.969]     }
[16:12:32.969]     if (FALSE) {
[16:12:32.969]     }
[16:12:32.969]     else {
[16:12:32.969]         if (TRUE) {
[16:12:32.969]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:32.969]                 open = "w")
[16:12:32.969]         }
[16:12:32.969]         else {
[16:12:32.969]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:32.969]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:32.969]         }
[16:12:32.969]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:32.969]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:32.969]             base::sink(type = "output", split = FALSE)
[16:12:32.969]             base::close(...future.stdout)
[16:12:32.969]         }, add = TRUE)
[16:12:32.969]     }
[16:12:32.969]     ...future.frame <- base::sys.nframe()
[16:12:32.969]     ...future.conditions <- base::list()
[16:12:32.969]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:32.969]     if (FALSE) {
[16:12:32.969]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:32.969]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:32.969]     }
[16:12:32.969]     ...future.result <- base::tryCatch({
[16:12:32.969]         base::withCallingHandlers({
[16:12:32.969]             ...future.value <- base::withVisible(base::local({
[16:12:32.969]                 xtabs(~x)
[16:12:32.969]             }))
[16:12:32.969]             future::FutureResult(value = ...future.value$value, 
[16:12:32.969]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:32.969]                   ...future.rng), globalenv = if (FALSE) 
[16:12:32.969]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:32.969]                     ...future.globalenv.names))
[16:12:32.969]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:32.969]         }, condition = base::local({
[16:12:32.969]             c <- base::c
[16:12:32.969]             inherits <- base::inherits
[16:12:32.969]             invokeRestart <- base::invokeRestart
[16:12:32.969]             length <- base::length
[16:12:32.969]             list <- base::list
[16:12:32.969]             seq.int <- base::seq.int
[16:12:32.969]             signalCondition <- base::signalCondition
[16:12:32.969]             sys.calls <- base::sys.calls
[16:12:32.969]             `[[` <- base::`[[`
[16:12:32.969]             `+` <- base::`+`
[16:12:32.969]             `<<-` <- base::`<<-`
[16:12:32.969]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:32.969]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:32.969]                   3L)]
[16:12:32.969]             }
[16:12:32.969]             function(cond) {
[16:12:32.969]                 is_error <- inherits(cond, "error")
[16:12:32.969]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:32.969]                   NULL)
[16:12:32.969]                 if (is_error) {
[16:12:32.969]                   sessionInformation <- function() {
[16:12:32.969]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:32.969]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:32.969]                       search = base::search(), system = base::Sys.info())
[16:12:32.969]                   }
[16:12:32.969]                   ...future.conditions[[length(...future.conditions) + 
[16:12:32.969]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:32.969]                     cond$call), session = sessionInformation(), 
[16:12:32.969]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:32.969]                   signalCondition(cond)
[16:12:32.969]                 }
[16:12:32.969]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:32.969]                 "immediateCondition"))) {
[16:12:32.969]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:32.969]                   ...future.conditions[[length(...future.conditions) + 
[16:12:32.969]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:32.969]                   if (TRUE && !signal) {
[16:12:32.969]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:32.969]                     {
[16:12:32.969]                       inherits <- base::inherits
[16:12:32.969]                       invokeRestart <- base::invokeRestart
[16:12:32.969]                       is.null <- base::is.null
[16:12:32.969]                       muffled <- FALSE
[16:12:32.969]                       if (inherits(cond, "message")) {
[16:12:32.969]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:32.969]                         if (muffled) 
[16:12:32.969]                           invokeRestart("muffleMessage")
[16:12:32.969]                       }
[16:12:32.969]                       else if (inherits(cond, "warning")) {
[16:12:32.969]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:32.969]                         if (muffled) 
[16:12:32.969]                           invokeRestart("muffleWarning")
[16:12:32.969]                       }
[16:12:32.969]                       else if (inherits(cond, "condition")) {
[16:12:32.969]                         if (!is.null(pattern)) {
[16:12:32.969]                           computeRestarts <- base::computeRestarts
[16:12:32.969]                           grepl <- base::grepl
[16:12:32.969]                           restarts <- computeRestarts(cond)
[16:12:32.969]                           for (restart in restarts) {
[16:12:32.969]                             name <- restart$name
[16:12:32.969]                             if (is.null(name)) 
[16:12:32.969]                               next
[16:12:32.969]                             if (!grepl(pattern, name)) 
[16:12:32.969]                               next
[16:12:32.969]                             invokeRestart(restart)
[16:12:32.969]                             muffled <- TRUE
[16:12:32.969]                             break
[16:12:32.969]                           }
[16:12:32.969]                         }
[16:12:32.969]                       }
[16:12:32.969]                       invisible(muffled)
[16:12:32.969]                     }
[16:12:32.969]                     muffleCondition(cond, pattern = "^muffle")
[16:12:32.969]                   }
[16:12:32.969]                 }
[16:12:32.969]                 else {
[16:12:32.969]                   if (TRUE) {
[16:12:32.969]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:32.969]                     {
[16:12:32.969]                       inherits <- base::inherits
[16:12:32.969]                       invokeRestart <- base::invokeRestart
[16:12:32.969]                       is.null <- base::is.null
[16:12:32.969]                       muffled <- FALSE
[16:12:32.969]                       if (inherits(cond, "message")) {
[16:12:32.969]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:32.969]                         if (muffled) 
[16:12:32.969]                           invokeRestart("muffleMessage")
[16:12:32.969]                       }
[16:12:32.969]                       else if (inherits(cond, "warning")) {
[16:12:32.969]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:32.969]                         if (muffled) 
[16:12:32.969]                           invokeRestart("muffleWarning")
[16:12:32.969]                       }
[16:12:32.969]                       else if (inherits(cond, "condition")) {
[16:12:32.969]                         if (!is.null(pattern)) {
[16:12:32.969]                           computeRestarts <- base::computeRestarts
[16:12:32.969]                           grepl <- base::grepl
[16:12:32.969]                           restarts <- computeRestarts(cond)
[16:12:32.969]                           for (restart in restarts) {
[16:12:32.969]                             name <- restart$name
[16:12:32.969]                             if (is.null(name)) 
[16:12:32.969]                               next
[16:12:32.969]                             if (!grepl(pattern, name)) 
[16:12:32.969]                               next
[16:12:32.969]                             invokeRestart(restart)
[16:12:32.969]                             muffled <- TRUE
[16:12:32.969]                             break
[16:12:32.969]                           }
[16:12:32.969]                         }
[16:12:32.969]                       }
[16:12:32.969]                       invisible(muffled)
[16:12:32.969]                     }
[16:12:32.969]                     muffleCondition(cond, pattern = "^muffle")
[16:12:32.969]                   }
[16:12:32.969]                 }
[16:12:32.969]             }
[16:12:32.969]         }))
[16:12:32.969]     }, error = function(ex) {
[16:12:32.969]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:32.969]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:32.969]                 ...future.rng), started = ...future.startTime, 
[16:12:32.969]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:32.969]             version = "1.8"), class = "FutureResult")
[16:12:32.969]     }, finally = {
[16:12:32.969]         if (!identical(...future.workdir, getwd())) 
[16:12:32.969]             setwd(...future.workdir)
[16:12:32.969]         {
[16:12:32.969]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:32.969]                 ...future.oldOptions$nwarnings <- NULL
[16:12:32.969]             }
[16:12:32.969]             base::options(...future.oldOptions)
[16:12:32.969]             if (.Platform$OS.type == "windows") {
[16:12:32.969]                 old_names <- names(...future.oldEnvVars)
[16:12:32.969]                 envs <- base::Sys.getenv()
[16:12:32.969]                 names <- names(envs)
[16:12:32.969]                 common <- intersect(names, old_names)
[16:12:32.969]                 added <- setdiff(names, old_names)
[16:12:32.969]                 removed <- setdiff(old_names, names)
[16:12:32.969]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:32.969]                   envs[common]]
[16:12:32.969]                 NAMES <- toupper(changed)
[16:12:32.969]                 args <- list()
[16:12:32.969]                 for (kk in seq_along(NAMES)) {
[16:12:32.969]                   name <- changed[[kk]]
[16:12:32.969]                   NAME <- NAMES[[kk]]
[16:12:32.969]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:32.969]                     next
[16:12:32.969]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:32.969]                 }
[16:12:32.969]                 NAMES <- toupper(added)
[16:12:32.969]                 for (kk in seq_along(NAMES)) {
[16:12:32.969]                   name <- added[[kk]]
[16:12:32.969]                   NAME <- NAMES[[kk]]
[16:12:32.969]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:32.969]                     next
[16:12:32.969]                   args[[name]] <- ""
[16:12:32.969]                 }
[16:12:32.969]                 NAMES <- toupper(removed)
[16:12:32.969]                 for (kk in seq_along(NAMES)) {
[16:12:32.969]                   name <- removed[[kk]]
[16:12:32.969]                   NAME <- NAMES[[kk]]
[16:12:32.969]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:32.969]                     next
[16:12:32.969]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:32.969]                 }
[16:12:32.969]                 if (length(args) > 0) 
[16:12:32.969]                   base::do.call(base::Sys.setenv, args = args)
[16:12:32.969]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:32.969]             }
[16:12:32.969]             else {
[16:12:32.969]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:32.969]             }
[16:12:32.969]             {
[16:12:32.969]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:32.969]                   0L) {
[16:12:32.969]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:32.969]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:32.969]                   base::options(opts)
[16:12:32.969]                 }
[16:12:32.969]                 {
[16:12:32.969]                   {
[16:12:32.969]                     NULL
[16:12:32.969]                     RNGkind("Mersenne-Twister")
[16:12:32.969]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:32.969]                       inherits = FALSE)
[16:12:32.969]                   }
[16:12:32.969]                   options(future.plan = NULL)
[16:12:32.969]                   if (is.na(NA_character_)) 
[16:12:32.969]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:32.969]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:32.969]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:32.969]                   {
[16:12:32.969]                     future <- SequentialFuture(..., envir = envir)
[16:12:32.969]                     if (!future$lazy) 
[16:12:32.969]                       future <- run(future)
[16:12:32.969]                     invisible(future)
[16:12:32.969]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:32.969]                 }
[16:12:32.969]             }
[16:12:32.969]         }
[16:12:32.969]     })
[16:12:32.969]     if (TRUE) {
[16:12:32.969]         base::sink(type = "output", split = FALSE)
[16:12:32.969]         if (TRUE) {
[16:12:32.969]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:32.969]         }
[16:12:32.969]         else {
[16:12:32.969]             ...future.result["stdout"] <- base::list(NULL)
[16:12:32.969]         }
[16:12:32.969]         base::close(...future.stdout)
[16:12:32.969]         ...future.stdout <- NULL
[16:12:32.969]     }
[16:12:32.969]     ...future.result$conditions <- ...future.conditions
[16:12:32.969]     ...future.result$finished <- base::Sys.time()
[16:12:32.969]     ...future.result
[16:12:32.969] }
[16:12:32.970] assign_globals() ...
[16:12:32.970] List of 1
[16:12:32.970]  $ x: num [1:5] 1 1 2 2 2
[16:12:32.970]  - attr(*, "where")=List of 1
[16:12:32.970]   ..$ x:<environment: R_EmptyEnv> 
[16:12:32.970]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:32.970]  - attr(*, "resolved")= logi FALSE
[16:12:32.970]  - attr(*, "total_size")= num 96
[16:12:32.970]  - attr(*, "already-done")= logi TRUE
[16:12:32.974] - copied ‘x’ to environment
[16:12:32.974] assign_globals() ... done
[16:12:32.974] plan(): Setting new future strategy stack:
[16:12:32.975] List of future strategies:
[16:12:32.975] 1. sequential:
[16:12:32.975]    - args: function (..., envir = parent.frame())
[16:12:32.975]    - tweaked: FALSE
[16:12:32.975]    - call: NULL
[16:12:32.975] plan(): nbrOfWorkers() = 1
[16:12:32.976] plan(): Setting new future strategy stack:
[16:12:32.976] List of future strategies:
[16:12:32.976] 1. sequential:
[16:12:32.976]    - args: function (..., envir = parent.frame())
[16:12:32.976]    - tweaked: FALSE
[16:12:32.976]    - call: plan(strategy)
[16:12:32.976] plan(): nbrOfWorkers() = 1
[16:12:32.977] SequentialFuture started (and completed)
[16:12:32.977] - Launch lazy future ... done
[16:12:32.977] run() for ‘SequentialFuture’ ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[16:12:32.979] getGlobalsAndPackages() ...
[16:12:32.979] Searching for globals...
[16:12:32.980] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[16:12:32.980] Searching for globals ... DONE
[16:12:32.981] Resolving globals: FALSE
[16:12:32.981] 
[16:12:32.981] - packages: [2] ‘stats’, ‘datasets’
[16:12:32.981] getGlobalsAndPackages() ... DONE
[16:12:32.981] run() for ‘Future’ ...
[16:12:32.981] - state: ‘created’
[16:12:32.982] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:32.982] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:32.982] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:32.982]   - Field: ‘label’
[16:12:32.982]   - Field: ‘local’
[16:12:32.982]   - Field: ‘owner’
[16:12:32.982]   - Field: ‘envir’
[16:12:32.982]   - Field: ‘packages’
[16:12:32.982]   - Field: ‘gc’
[16:12:32.983]   - Field: ‘conditions’
[16:12:32.983]   - Field: ‘expr’
[16:12:32.983]   - Field: ‘uuid’
[16:12:32.983]   - Field: ‘seed’
[16:12:32.983]   - Field: ‘version’
[16:12:32.983]   - Field: ‘result’
[16:12:32.983]   - Field: ‘asynchronous’
[16:12:32.983]   - Field: ‘calls’
[16:12:32.983]   - Field: ‘globals’
[16:12:32.983]   - Field: ‘stdout’
[16:12:32.983]   - Field: ‘earlySignal’
[16:12:32.984]   - Field: ‘lazy’
[16:12:32.984]   - Field: ‘state’
[16:12:32.984] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:32.984] - Launch lazy future ...
[16:12:32.984] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:12:32.984] Packages needed by future strategies (n = 0): <none>
[16:12:32.985] {
[16:12:32.985]     {
[16:12:32.985]         {
[16:12:32.985]             ...future.startTime <- base::Sys.time()
[16:12:32.985]             {
[16:12:32.985]                 {
[16:12:32.985]                   {
[16:12:32.985]                     {
[16:12:32.985]                       base::local({
[16:12:32.985]                         has_future <- base::requireNamespace("future", 
[16:12:32.985]                           quietly = TRUE)
[16:12:32.985]                         if (has_future) {
[16:12:32.985]                           ns <- base::getNamespace("future")
[16:12:32.985]                           version <- ns[[".package"]][["version"]]
[16:12:32.985]                           if (is.null(version)) 
[16:12:32.985]                             version <- utils::packageVersion("future")
[16:12:32.985]                         }
[16:12:32.985]                         else {
[16:12:32.985]                           version <- NULL
[16:12:32.985]                         }
[16:12:32.985]                         if (!has_future || version < "1.8.0") {
[16:12:32.985]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:32.985]                             "", base::R.version$version.string), 
[16:12:32.985]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:32.985]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:32.985]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:32.985]                               "release", "version")], collapse = " "), 
[16:12:32.985]                             hostname = base::Sys.info()[["nodename"]])
[16:12:32.985]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:32.985]                             info)
[16:12:32.985]                           info <- base::paste(info, collapse = "; ")
[16:12:32.985]                           if (!has_future) {
[16:12:32.985]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:32.985]                               info)
[16:12:32.985]                           }
[16:12:32.985]                           else {
[16:12:32.985]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:32.985]                               info, version)
[16:12:32.985]                           }
[16:12:32.985]                           base::stop(msg)
[16:12:32.985]                         }
[16:12:32.985]                       })
[16:12:32.985]                     }
[16:12:32.985]                     base::local({
[16:12:32.985]                       for (pkg in c("stats", "datasets")) {
[16:12:32.985]                         base::loadNamespace(pkg)
[16:12:32.985]                         base::library(pkg, character.only = TRUE)
[16:12:32.985]                       }
[16:12:32.985]                     })
[16:12:32.985]                   }
[16:12:32.985]                   options(future.plan = NULL)
[16:12:32.985]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:32.985]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:32.985]                 }
[16:12:32.985]                 ...future.workdir <- getwd()
[16:12:32.985]             }
[16:12:32.985]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:32.985]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:32.985]         }
[16:12:32.985]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:32.985]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:32.985]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:32.985]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:32.985]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:32.985]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:32.985]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:32.985]             base::names(...future.oldOptions))
[16:12:32.985]     }
[16:12:32.985]     if (FALSE) {
[16:12:32.985]     }
[16:12:32.985]     else {
[16:12:32.985]         if (TRUE) {
[16:12:32.985]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:32.985]                 open = "w")
[16:12:32.985]         }
[16:12:32.985]         else {
[16:12:32.985]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:32.985]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:32.985]         }
[16:12:32.985]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:32.985]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:32.985]             base::sink(type = "output", split = FALSE)
[16:12:32.985]             base::close(...future.stdout)
[16:12:32.985]         }, add = TRUE)
[16:12:32.985]     }
[16:12:32.985]     ...future.frame <- base::sys.nframe()
[16:12:32.985]     ...future.conditions <- base::list()
[16:12:32.985]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:32.985]     if (FALSE) {
[16:12:32.985]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:32.985]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:32.985]     }
[16:12:32.985]     ...future.result <- base::tryCatch({
[16:12:32.985]         base::withCallingHandlers({
[16:12:32.985]             ...future.value <- base::withVisible(base::local({
[16:12:32.985]                 lm(dist ~ . - 1, data = cars)
[16:12:32.985]             }))
[16:12:32.985]             future::FutureResult(value = ...future.value$value, 
[16:12:32.985]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:32.985]                   ...future.rng), globalenv = if (FALSE) 
[16:12:32.985]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:32.985]                     ...future.globalenv.names))
[16:12:32.985]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:32.985]         }, condition = base::local({
[16:12:32.985]             c <- base::c
[16:12:32.985]             inherits <- base::inherits
[16:12:32.985]             invokeRestart <- base::invokeRestart
[16:12:32.985]             length <- base::length
[16:12:32.985]             list <- base::list
[16:12:32.985]             seq.int <- base::seq.int
[16:12:32.985]             signalCondition <- base::signalCondition
[16:12:32.985]             sys.calls <- base::sys.calls
[16:12:32.985]             `[[` <- base::`[[`
[16:12:32.985]             `+` <- base::`+`
[16:12:32.985]             `<<-` <- base::`<<-`
[16:12:32.985]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:32.985]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:32.985]                   3L)]
[16:12:32.985]             }
[16:12:32.985]             function(cond) {
[16:12:32.985]                 is_error <- inherits(cond, "error")
[16:12:32.985]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:32.985]                   NULL)
[16:12:32.985]                 if (is_error) {
[16:12:32.985]                   sessionInformation <- function() {
[16:12:32.985]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:32.985]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:32.985]                       search = base::search(), system = base::Sys.info())
[16:12:32.985]                   }
[16:12:32.985]                   ...future.conditions[[length(...future.conditions) + 
[16:12:32.985]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:32.985]                     cond$call), session = sessionInformation(), 
[16:12:32.985]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:32.985]                   signalCondition(cond)
[16:12:32.985]                 }
[16:12:32.985]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:32.985]                 "immediateCondition"))) {
[16:12:32.985]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:32.985]                   ...future.conditions[[length(...future.conditions) + 
[16:12:32.985]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:32.985]                   if (TRUE && !signal) {
[16:12:32.985]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:32.985]                     {
[16:12:32.985]                       inherits <- base::inherits
[16:12:32.985]                       invokeRestart <- base::invokeRestart
[16:12:32.985]                       is.null <- base::is.null
[16:12:32.985]                       muffled <- FALSE
[16:12:32.985]                       if (inherits(cond, "message")) {
[16:12:32.985]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:32.985]                         if (muffled) 
[16:12:32.985]                           invokeRestart("muffleMessage")
[16:12:32.985]                       }
[16:12:32.985]                       else if (inherits(cond, "warning")) {
[16:12:32.985]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:32.985]                         if (muffled) 
[16:12:32.985]                           invokeRestart("muffleWarning")
[16:12:32.985]                       }
[16:12:32.985]                       else if (inherits(cond, "condition")) {
[16:12:32.985]                         if (!is.null(pattern)) {
[16:12:32.985]                           computeRestarts <- base::computeRestarts
[16:12:32.985]                           grepl <- base::grepl
[16:12:32.985]                           restarts <- computeRestarts(cond)
[16:12:32.985]                           for (restart in restarts) {
[16:12:32.985]                             name <- restart$name
[16:12:32.985]                             if (is.null(name)) 
[16:12:32.985]                               next
[16:12:32.985]                             if (!grepl(pattern, name)) 
[16:12:32.985]                               next
[16:12:32.985]                             invokeRestart(restart)
[16:12:32.985]                             muffled <- TRUE
[16:12:32.985]                             break
[16:12:32.985]                           }
[16:12:32.985]                         }
[16:12:32.985]                       }
[16:12:32.985]                       invisible(muffled)
[16:12:32.985]                     }
[16:12:32.985]                     muffleCondition(cond, pattern = "^muffle")
[16:12:32.985]                   }
[16:12:32.985]                 }
[16:12:32.985]                 else {
[16:12:32.985]                   if (TRUE) {
[16:12:32.985]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:32.985]                     {
[16:12:32.985]                       inherits <- base::inherits
[16:12:32.985]                       invokeRestart <- base::invokeRestart
[16:12:32.985]                       is.null <- base::is.null
[16:12:32.985]                       muffled <- FALSE
[16:12:32.985]                       if (inherits(cond, "message")) {
[16:12:32.985]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:32.985]                         if (muffled) 
[16:12:32.985]                           invokeRestart("muffleMessage")
[16:12:32.985]                       }
[16:12:32.985]                       else if (inherits(cond, "warning")) {
[16:12:32.985]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:32.985]                         if (muffled) 
[16:12:32.985]                           invokeRestart("muffleWarning")
[16:12:32.985]                       }
[16:12:32.985]                       else if (inherits(cond, "condition")) {
[16:12:32.985]                         if (!is.null(pattern)) {
[16:12:32.985]                           computeRestarts <- base::computeRestarts
[16:12:32.985]                           grepl <- base::grepl
[16:12:32.985]                           restarts <- computeRestarts(cond)
[16:12:32.985]                           for (restart in restarts) {
[16:12:32.985]                             name <- restart$name
[16:12:32.985]                             if (is.null(name)) 
[16:12:32.985]                               next
[16:12:32.985]                             if (!grepl(pattern, name)) 
[16:12:32.985]                               next
[16:12:32.985]                             invokeRestart(restart)
[16:12:32.985]                             muffled <- TRUE
[16:12:32.985]                             break
[16:12:32.985]                           }
[16:12:32.985]                         }
[16:12:32.985]                       }
[16:12:32.985]                       invisible(muffled)
[16:12:32.985]                     }
[16:12:32.985]                     muffleCondition(cond, pattern = "^muffle")
[16:12:32.985]                   }
[16:12:32.985]                 }
[16:12:32.985]             }
[16:12:32.985]         }))
[16:12:32.985]     }, error = function(ex) {
[16:12:32.985]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:32.985]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:32.985]                 ...future.rng), started = ...future.startTime, 
[16:12:32.985]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:32.985]             version = "1.8"), class = "FutureResult")
[16:12:32.985]     }, finally = {
[16:12:32.985]         if (!identical(...future.workdir, getwd())) 
[16:12:32.985]             setwd(...future.workdir)
[16:12:32.985]         {
[16:12:32.985]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:32.985]                 ...future.oldOptions$nwarnings <- NULL
[16:12:32.985]             }
[16:12:32.985]             base::options(...future.oldOptions)
[16:12:32.985]             if (.Platform$OS.type == "windows") {
[16:12:32.985]                 old_names <- names(...future.oldEnvVars)
[16:12:32.985]                 envs <- base::Sys.getenv()
[16:12:32.985]                 names <- names(envs)
[16:12:32.985]                 common <- intersect(names, old_names)
[16:12:32.985]                 added <- setdiff(names, old_names)
[16:12:32.985]                 removed <- setdiff(old_names, names)
[16:12:32.985]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:32.985]                   envs[common]]
[16:12:32.985]                 NAMES <- toupper(changed)
[16:12:32.985]                 args <- list()
[16:12:32.985]                 for (kk in seq_along(NAMES)) {
[16:12:32.985]                   name <- changed[[kk]]
[16:12:32.985]                   NAME <- NAMES[[kk]]
[16:12:32.985]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:32.985]                     next
[16:12:32.985]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:32.985]                 }
[16:12:32.985]                 NAMES <- toupper(added)
[16:12:32.985]                 for (kk in seq_along(NAMES)) {
[16:12:32.985]                   name <- added[[kk]]
[16:12:32.985]                   NAME <- NAMES[[kk]]
[16:12:32.985]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:32.985]                     next
[16:12:32.985]                   args[[name]] <- ""
[16:12:32.985]                 }
[16:12:32.985]                 NAMES <- toupper(removed)
[16:12:32.985]                 for (kk in seq_along(NAMES)) {
[16:12:32.985]                   name <- removed[[kk]]
[16:12:32.985]                   NAME <- NAMES[[kk]]
[16:12:32.985]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:32.985]                     next
[16:12:32.985]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:32.985]                 }
[16:12:32.985]                 if (length(args) > 0) 
[16:12:32.985]                   base::do.call(base::Sys.setenv, args = args)
[16:12:32.985]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:32.985]             }
[16:12:32.985]             else {
[16:12:32.985]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:32.985]             }
[16:12:32.985]             {
[16:12:32.985]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:32.985]                   0L) {
[16:12:32.985]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:32.985]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:32.985]                   base::options(opts)
[16:12:32.985]                 }
[16:12:32.985]                 {
[16:12:32.985]                   {
[16:12:32.985]                     NULL
[16:12:32.985]                     RNGkind("Mersenne-Twister")
[16:12:32.985]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:32.985]                       inherits = FALSE)
[16:12:32.985]                   }
[16:12:32.985]                   options(future.plan = NULL)
[16:12:32.985]                   if (is.na(NA_character_)) 
[16:12:32.985]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:32.985]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:32.985]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:32.985]                   {
[16:12:32.985]                     future <- SequentialFuture(..., envir = envir)
[16:12:32.985]                     if (!future$lazy) 
[16:12:32.985]                       future <- run(future)
[16:12:32.985]                     invisible(future)
[16:12:32.985]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:32.985]                 }
[16:12:32.985]             }
[16:12:32.985]         }
[16:12:32.985]     })
[16:12:32.985]     if (TRUE) {
[16:12:32.985]         base::sink(type = "output", split = FALSE)
[16:12:32.985]         if (TRUE) {
[16:12:32.985]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:32.985]         }
[16:12:32.985]         else {
[16:12:32.985]             ...future.result["stdout"] <- base::list(NULL)
[16:12:32.985]         }
[16:12:32.985]         base::close(...future.stdout)
[16:12:32.985]         ...future.stdout <- NULL
[16:12:32.985]     }
[16:12:32.985]     ...future.result$conditions <- ...future.conditions
[16:12:32.985]     ...future.result$finished <- base::Sys.time()
[16:12:32.985]     ...future.result
[16:12:32.985] }
[16:12:32.986] plan(): Setting new future strategy stack:
[16:12:32.987] List of future strategies:
[16:12:32.987] 1. sequential:
[16:12:32.987]    - args: function (..., envir = parent.frame())
[16:12:32.987]    - tweaked: FALSE
[16:12:32.987]    - call: NULL
[16:12:32.987] plan(): nbrOfWorkers() = 1
[16:12:32.988] plan(): Setting new future strategy stack:
[16:12:32.988] List of future strategies:
[16:12:32.988] 1. sequential:
[16:12:32.988]    - args: function (..., envir = parent.frame())
[16:12:32.988]    - tweaked: FALSE
[16:12:32.988]    - call: plan(strategy)
[16:12:32.989] plan(): nbrOfWorkers() = 1
[16:12:32.989] SequentialFuture started (and completed)
[16:12:32.989] - Launch lazy future ... done
[16:12:32.989] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[16:12:32.991] getGlobalsAndPackages() ...
[16:12:32.991] Searching for globals...
[16:12:32.993] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[16:12:32.993] Searching for globals ... DONE
[16:12:32.993] Resolving globals: FALSE
[16:12:32.993] 
[16:12:32.993] - packages: [2] ‘stats’, ‘datasets’
[16:12:32.993] getGlobalsAndPackages() ... DONE
[16:12:32.994] run() for ‘Future’ ...
[16:12:32.994] - state: ‘created’
[16:12:32.994] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:32.994] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:32.994] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:32.994]   - Field: ‘label’
[16:12:32.994]   - Field: ‘local’
[16:12:32.995]   - Field: ‘owner’
[16:12:32.995]   - Field: ‘envir’
[16:12:32.995]   - Field: ‘packages’
[16:12:32.996]   - Field: ‘gc’
[16:12:32.996]   - Field: ‘conditions’
[16:12:32.996]   - Field: ‘expr’
[16:12:32.996]   - Field: ‘uuid’
[16:12:32.996]   - Field: ‘seed’
[16:12:32.996]   - Field: ‘version’
[16:12:32.997]   - Field: ‘result’
[16:12:32.997]   - Field: ‘asynchronous’
[16:12:32.997]   - Field: ‘calls’
[16:12:32.997]   - Field: ‘globals’
[16:12:32.997]   - Field: ‘stdout’
[16:12:32.997]   - Field: ‘earlySignal’
[16:12:32.997]   - Field: ‘lazy’
[16:12:32.997]   - Field: ‘state’
[16:12:32.997] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:32.997] - Launch lazy future ...
[16:12:32.998] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:12:32.998] Packages needed by future strategies (n = 0): <none>
[16:12:32.998] {
[16:12:32.998]     {
[16:12:32.998]         {
[16:12:32.998]             ...future.startTime <- base::Sys.time()
[16:12:32.998]             {
[16:12:32.998]                 {
[16:12:32.998]                   {
[16:12:32.998]                     {
[16:12:32.998]                       base::local({
[16:12:32.998]                         has_future <- base::requireNamespace("future", 
[16:12:32.998]                           quietly = TRUE)
[16:12:32.998]                         if (has_future) {
[16:12:32.998]                           ns <- base::getNamespace("future")
[16:12:32.998]                           version <- ns[[".package"]][["version"]]
[16:12:32.998]                           if (is.null(version)) 
[16:12:32.998]                             version <- utils::packageVersion("future")
[16:12:32.998]                         }
[16:12:32.998]                         else {
[16:12:32.998]                           version <- NULL
[16:12:32.998]                         }
[16:12:32.998]                         if (!has_future || version < "1.8.0") {
[16:12:32.998]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:32.998]                             "", base::R.version$version.string), 
[16:12:32.998]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:32.998]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:32.998]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:32.998]                               "release", "version")], collapse = " "), 
[16:12:32.998]                             hostname = base::Sys.info()[["nodename"]])
[16:12:32.998]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:32.998]                             info)
[16:12:32.998]                           info <- base::paste(info, collapse = "; ")
[16:12:32.998]                           if (!has_future) {
[16:12:32.998]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:32.998]                               info)
[16:12:32.998]                           }
[16:12:32.998]                           else {
[16:12:32.998]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:32.998]                               info, version)
[16:12:32.998]                           }
[16:12:32.998]                           base::stop(msg)
[16:12:32.998]                         }
[16:12:32.998]                       })
[16:12:32.998]                     }
[16:12:32.998]                     base::local({
[16:12:32.998]                       for (pkg in c("stats", "datasets")) {
[16:12:32.998]                         base::loadNamespace(pkg)
[16:12:32.998]                         base::library(pkg, character.only = TRUE)
[16:12:32.998]                       }
[16:12:32.998]                     })
[16:12:32.998]                   }
[16:12:32.998]                   options(future.plan = NULL)
[16:12:32.998]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:32.998]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:32.998]                 }
[16:12:32.998]                 ...future.workdir <- getwd()
[16:12:32.998]             }
[16:12:32.998]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:32.998]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:32.998]         }
[16:12:32.998]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:32.998]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:32.998]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:32.998]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:32.998]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:32.998]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:32.998]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:32.998]             base::names(...future.oldOptions))
[16:12:32.998]     }
[16:12:32.998]     if (FALSE) {
[16:12:32.998]     }
[16:12:32.998]     else {
[16:12:32.998]         if (TRUE) {
[16:12:32.998]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:32.998]                 open = "w")
[16:12:32.998]         }
[16:12:32.998]         else {
[16:12:32.998]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:32.998]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:32.998]         }
[16:12:32.998]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:32.998]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:32.998]             base::sink(type = "output", split = FALSE)
[16:12:32.998]             base::close(...future.stdout)
[16:12:32.998]         }, add = TRUE)
[16:12:32.998]     }
[16:12:32.998]     ...future.frame <- base::sys.nframe()
[16:12:32.998]     ...future.conditions <- base::list()
[16:12:32.998]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:32.998]     if (FALSE) {
[16:12:32.998]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:32.998]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:32.998]     }
[16:12:32.998]     ...future.result <- base::tryCatch({
[16:12:32.998]         base::withCallingHandlers({
[16:12:32.998]             ...future.value <- base::withVisible(base::local({
[16:12:32.998]                 lm(dist ~ . + 0, data = cars)
[16:12:32.998]             }))
[16:12:32.998]             future::FutureResult(value = ...future.value$value, 
[16:12:32.998]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:32.998]                   ...future.rng), globalenv = if (FALSE) 
[16:12:32.998]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:32.998]                     ...future.globalenv.names))
[16:12:32.998]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:32.998]         }, condition = base::local({
[16:12:32.998]             c <- base::c
[16:12:32.998]             inherits <- base::inherits
[16:12:32.998]             invokeRestart <- base::invokeRestart
[16:12:32.998]             length <- base::length
[16:12:32.998]             list <- base::list
[16:12:32.998]             seq.int <- base::seq.int
[16:12:32.998]             signalCondition <- base::signalCondition
[16:12:32.998]             sys.calls <- base::sys.calls
[16:12:32.998]             `[[` <- base::`[[`
[16:12:32.998]             `+` <- base::`+`
[16:12:32.998]             `<<-` <- base::`<<-`
[16:12:32.998]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:32.998]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:32.998]                   3L)]
[16:12:32.998]             }
[16:12:32.998]             function(cond) {
[16:12:32.998]                 is_error <- inherits(cond, "error")
[16:12:32.998]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:32.998]                   NULL)
[16:12:32.998]                 if (is_error) {
[16:12:32.998]                   sessionInformation <- function() {
[16:12:32.998]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:32.998]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:32.998]                       search = base::search(), system = base::Sys.info())
[16:12:32.998]                   }
[16:12:32.998]                   ...future.conditions[[length(...future.conditions) + 
[16:12:32.998]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:32.998]                     cond$call), session = sessionInformation(), 
[16:12:32.998]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:32.998]                   signalCondition(cond)
[16:12:32.998]                 }
[16:12:32.998]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:32.998]                 "immediateCondition"))) {
[16:12:32.998]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:32.998]                   ...future.conditions[[length(...future.conditions) + 
[16:12:32.998]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:32.998]                   if (TRUE && !signal) {
[16:12:32.998]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:32.998]                     {
[16:12:32.998]                       inherits <- base::inherits
[16:12:32.998]                       invokeRestart <- base::invokeRestart
[16:12:32.998]                       is.null <- base::is.null
[16:12:32.998]                       muffled <- FALSE
[16:12:32.998]                       if (inherits(cond, "message")) {
[16:12:32.998]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:32.998]                         if (muffled) 
[16:12:32.998]                           invokeRestart("muffleMessage")
[16:12:32.998]                       }
[16:12:32.998]                       else if (inherits(cond, "warning")) {
[16:12:32.998]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:32.998]                         if (muffled) 
[16:12:32.998]                           invokeRestart("muffleWarning")
[16:12:32.998]                       }
[16:12:32.998]                       else if (inherits(cond, "condition")) {
[16:12:32.998]                         if (!is.null(pattern)) {
[16:12:32.998]                           computeRestarts <- base::computeRestarts
[16:12:32.998]                           grepl <- base::grepl
[16:12:32.998]                           restarts <- computeRestarts(cond)
[16:12:32.998]                           for (restart in restarts) {
[16:12:32.998]                             name <- restart$name
[16:12:32.998]                             if (is.null(name)) 
[16:12:32.998]                               next
[16:12:32.998]                             if (!grepl(pattern, name)) 
[16:12:32.998]                               next
[16:12:32.998]                             invokeRestart(restart)
[16:12:32.998]                             muffled <- TRUE
[16:12:32.998]                             break
[16:12:32.998]                           }
[16:12:32.998]                         }
[16:12:32.998]                       }
[16:12:32.998]                       invisible(muffled)
[16:12:32.998]                     }
[16:12:32.998]                     muffleCondition(cond, pattern = "^muffle")
[16:12:32.998]                   }
[16:12:32.998]                 }
[16:12:32.998]                 else {
[16:12:32.998]                   if (TRUE) {
[16:12:32.998]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:32.998]                     {
[16:12:32.998]                       inherits <- base::inherits
[16:12:32.998]                       invokeRestart <- base::invokeRestart
[16:12:32.998]                       is.null <- base::is.null
[16:12:32.998]                       muffled <- FALSE
[16:12:32.998]                       if (inherits(cond, "message")) {
[16:12:32.998]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:32.998]                         if (muffled) 
[16:12:32.998]                           invokeRestart("muffleMessage")
[16:12:32.998]                       }
[16:12:32.998]                       else if (inherits(cond, "warning")) {
[16:12:32.998]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:32.998]                         if (muffled) 
[16:12:32.998]                           invokeRestart("muffleWarning")
[16:12:32.998]                       }
[16:12:32.998]                       else if (inherits(cond, "condition")) {
[16:12:32.998]                         if (!is.null(pattern)) {
[16:12:32.998]                           computeRestarts <- base::computeRestarts
[16:12:32.998]                           grepl <- base::grepl
[16:12:32.998]                           restarts <- computeRestarts(cond)
[16:12:32.998]                           for (restart in restarts) {
[16:12:32.998]                             name <- restart$name
[16:12:32.998]                             if (is.null(name)) 
[16:12:32.998]                               next
[16:12:32.998]                             if (!grepl(pattern, name)) 
[16:12:32.998]                               next
[16:12:32.998]                             invokeRestart(restart)
[16:12:32.998]                             muffled <- TRUE
[16:12:32.998]                             break
[16:12:32.998]                           }
[16:12:32.998]                         }
[16:12:32.998]                       }
[16:12:32.998]                       invisible(muffled)
[16:12:32.998]                     }
[16:12:32.998]                     muffleCondition(cond, pattern = "^muffle")
[16:12:32.998]                   }
[16:12:32.998]                 }
[16:12:32.998]             }
[16:12:32.998]         }))
[16:12:32.998]     }, error = function(ex) {
[16:12:32.998]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:32.998]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:32.998]                 ...future.rng), started = ...future.startTime, 
[16:12:32.998]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:32.998]             version = "1.8"), class = "FutureResult")
[16:12:32.998]     }, finally = {
[16:12:32.998]         if (!identical(...future.workdir, getwd())) 
[16:12:32.998]             setwd(...future.workdir)
[16:12:32.998]         {
[16:12:32.998]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:32.998]                 ...future.oldOptions$nwarnings <- NULL
[16:12:32.998]             }
[16:12:32.998]             base::options(...future.oldOptions)
[16:12:32.998]             if (.Platform$OS.type == "windows") {
[16:12:32.998]                 old_names <- names(...future.oldEnvVars)
[16:12:32.998]                 envs <- base::Sys.getenv()
[16:12:32.998]                 names <- names(envs)
[16:12:32.998]                 common <- intersect(names, old_names)
[16:12:32.998]                 added <- setdiff(names, old_names)
[16:12:32.998]                 removed <- setdiff(old_names, names)
[16:12:32.998]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:32.998]                   envs[common]]
[16:12:32.998]                 NAMES <- toupper(changed)
[16:12:32.998]                 args <- list()
[16:12:32.998]                 for (kk in seq_along(NAMES)) {
[16:12:32.998]                   name <- changed[[kk]]
[16:12:32.998]                   NAME <- NAMES[[kk]]
[16:12:32.998]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:32.998]                     next
[16:12:32.998]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:32.998]                 }
[16:12:32.998]                 NAMES <- toupper(added)
[16:12:32.998]                 for (kk in seq_along(NAMES)) {
[16:12:32.998]                   name <- added[[kk]]
[16:12:32.998]                   NAME <- NAMES[[kk]]
[16:12:32.998]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:32.998]                     next
[16:12:32.998]                   args[[name]] <- ""
[16:12:32.998]                 }
[16:12:32.998]                 NAMES <- toupper(removed)
[16:12:32.998]                 for (kk in seq_along(NAMES)) {
[16:12:32.998]                   name <- removed[[kk]]
[16:12:32.998]                   NAME <- NAMES[[kk]]
[16:12:32.998]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:32.998]                     next
[16:12:32.998]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:32.998]                 }
[16:12:32.998]                 if (length(args) > 0) 
[16:12:32.998]                   base::do.call(base::Sys.setenv, args = args)
[16:12:32.998]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:32.998]             }
[16:12:32.998]             else {
[16:12:32.998]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:32.998]             }
[16:12:32.998]             {
[16:12:32.998]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:32.998]                   0L) {
[16:12:32.998]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:32.998]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:32.998]                   base::options(opts)
[16:12:32.998]                 }
[16:12:32.998]                 {
[16:12:32.998]                   {
[16:12:32.998]                     NULL
[16:12:32.998]                     RNGkind("Mersenne-Twister")
[16:12:32.998]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:32.998]                       inherits = FALSE)
[16:12:32.998]                   }
[16:12:32.998]                   options(future.plan = NULL)
[16:12:32.998]                   if (is.na(NA_character_)) 
[16:12:32.998]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:32.998]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:32.998]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:32.998]                   {
[16:12:32.998]                     future <- SequentialFuture(..., envir = envir)
[16:12:32.998]                     if (!future$lazy) 
[16:12:32.998]                       future <- run(future)
[16:12:32.998]                     invisible(future)
[16:12:32.998]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:32.998]                 }
[16:12:32.998]             }
[16:12:32.998]         }
[16:12:32.998]     })
[16:12:32.998]     if (TRUE) {
[16:12:32.998]         base::sink(type = "output", split = FALSE)
[16:12:32.998]         if (TRUE) {
[16:12:32.998]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:32.998]         }
[16:12:32.998]         else {
[16:12:32.998]             ...future.result["stdout"] <- base::list(NULL)
[16:12:32.998]         }
[16:12:32.998]         base::close(...future.stdout)
[16:12:32.998]         ...future.stdout <- NULL
[16:12:32.998]     }
[16:12:32.998]     ...future.result$conditions <- ...future.conditions
[16:12:32.998]     ...future.result$finished <- base::Sys.time()
[16:12:32.998]     ...future.result
[16:12:32.998] }
[16:12:33.000] plan(): Setting new future strategy stack:
[16:12:33.000] List of future strategies:
[16:12:33.000] 1. sequential:
[16:12:33.000]    - args: function (..., envir = parent.frame())
[16:12:33.000]    - tweaked: FALSE
[16:12:33.000]    - call: NULL
[16:12:33.000] plan(): nbrOfWorkers() = 1
[16:12:33.002] plan(): Setting new future strategy stack:
[16:12:33.002] List of future strategies:
[16:12:33.002] 1. sequential:
[16:12:33.002]    - args: function (..., envir = parent.frame())
[16:12:33.002]    - tweaked: FALSE
[16:12:33.002]    - call: plan(strategy)
[16:12:33.002] plan(): nbrOfWorkers() = 1
[16:12:33.002] SequentialFuture started (and completed)
[16:12:33.002] - Launch lazy future ... done
[16:12:33.002] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[16:12:33.005] getGlobalsAndPackages() ...
[16:12:33.005] Searching for globals...
[16:12:33.006] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[16:12:33.006] Searching for globals ... DONE
[16:12:33.006] Resolving globals: FALSE
[16:12:33.007] 
[16:12:33.007] - packages: [2] ‘stats’, ‘datasets’
[16:12:33.007] getGlobalsAndPackages() ... DONE
[16:12:33.007] run() for ‘Future’ ...
[16:12:33.007] - state: ‘created’
[16:12:33.008] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:33.008] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:33.008] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:33.008]   - Field: ‘label’
[16:12:33.008]   - Field: ‘local’
[16:12:33.008]   - Field: ‘owner’
[16:12:33.008]   - Field: ‘envir’
[16:12:33.008]   - Field: ‘packages’
[16:12:33.008]   - Field: ‘gc’
[16:12:33.009]   - Field: ‘conditions’
[16:12:33.009]   - Field: ‘expr’
[16:12:33.009]   - Field: ‘uuid’
[16:12:33.009]   - Field: ‘seed’
[16:12:33.009]   - Field: ‘version’
[16:12:33.009]   - Field: ‘result’
[16:12:33.009]   - Field: ‘asynchronous’
[16:12:33.009]   - Field: ‘calls’
[16:12:33.009]   - Field: ‘globals’
[16:12:33.009]   - Field: ‘stdout’
[16:12:33.009]   - Field: ‘earlySignal’
[16:12:33.010]   - Field: ‘lazy’
[16:12:33.010]   - Field: ‘state’
[16:12:33.010] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:33.010] - Launch lazy future ...
[16:12:33.010] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:12:33.010] Packages needed by future strategies (n = 0): <none>
[16:12:33.011] {
[16:12:33.011]     {
[16:12:33.011]         {
[16:12:33.011]             ...future.startTime <- base::Sys.time()
[16:12:33.011]             {
[16:12:33.011]                 {
[16:12:33.011]                   {
[16:12:33.011]                     {
[16:12:33.011]                       base::local({
[16:12:33.011]                         has_future <- base::requireNamespace("future", 
[16:12:33.011]                           quietly = TRUE)
[16:12:33.011]                         if (has_future) {
[16:12:33.011]                           ns <- base::getNamespace("future")
[16:12:33.011]                           version <- ns[[".package"]][["version"]]
[16:12:33.011]                           if (is.null(version)) 
[16:12:33.011]                             version <- utils::packageVersion("future")
[16:12:33.011]                         }
[16:12:33.011]                         else {
[16:12:33.011]                           version <- NULL
[16:12:33.011]                         }
[16:12:33.011]                         if (!has_future || version < "1.8.0") {
[16:12:33.011]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:33.011]                             "", base::R.version$version.string), 
[16:12:33.011]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:33.011]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:33.011]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:33.011]                               "release", "version")], collapse = " "), 
[16:12:33.011]                             hostname = base::Sys.info()[["nodename"]])
[16:12:33.011]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:33.011]                             info)
[16:12:33.011]                           info <- base::paste(info, collapse = "; ")
[16:12:33.011]                           if (!has_future) {
[16:12:33.011]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:33.011]                               info)
[16:12:33.011]                           }
[16:12:33.011]                           else {
[16:12:33.011]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:33.011]                               info, version)
[16:12:33.011]                           }
[16:12:33.011]                           base::stop(msg)
[16:12:33.011]                         }
[16:12:33.011]                       })
[16:12:33.011]                     }
[16:12:33.011]                     base::local({
[16:12:33.011]                       for (pkg in c("stats", "datasets")) {
[16:12:33.011]                         base::loadNamespace(pkg)
[16:12:33.011]                         base::library(pkg, character.only = TRUE)
[16:12:33.011]                       }
[16:12:33.011]                     })
[16:12:33.011]                   }
[16:12:33.011]                   options(future.plan = NULL)
[16:12:33.011]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:33.011]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:33.011]                 }
[16:12:33.011]                 ...future.workdir <- getwd()
[16:12:33.011]             }
[16:12:33.011]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:33.011]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:33.011]         }
[16:12:33.011]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:33.011]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:33.011]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:33.011]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:33.011]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:33.011]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:33.011]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:33.011]             base::names(...future.oldOptions))
[16:12:33.011]     }
[16:12:33.011]     if (FALSE) {
[16:12:33.011]     }
[16:12:33.011]     else {
[16:12:33.011]         if (TRUE) {
[16:12:33.011]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:33.011]                 open = "w")
[16:12:33.011]         }
[16:12:33.011]         else {
[16:12:33.011]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:33.011]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:33.011]         }
[16:12:33.011]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:33.011]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:33.011]             base::sink(type = "output", split = FALSE)
[16:12:33.011]             base::close(...future.stdout)
[16:12:33.011]         }, add = TRUE)
[16:12:33.011]     }
[16:12:33.011]     ...future.frame <- base::sys.nframe()
[16:12:33.011]     ...future.conditions <- base::list()
[16:12:33.011]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:33.011]     if (FALSE) {
[16:12:33.011]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:33.011]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:33.011]     }
[16:12:33.011]     ...future.result <- base::tryCatch({
[16:12:33.011]         base::withCallingHandlers({
[16:12:33.011]             ...future.value <- base::withVisible(base::local({
[16:12:33.011]                 lm(dist ~ speed + speed^2, data = cars)
[16:12:33.011]             }))
[16:12:33.011]             future::FutureResult(value = ...future.value$value, 
[16:12:33.011]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:33.011]                   ...future.rng), globalenv = if (FALSE) 
[16:12:33.011]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:33.011]                     ...future.globalenv.names))
[16:12:33.011]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:33.011]         }, condition = base::local({
[16:12:33.011]             c <- base::c
[16:12:33.011]             inherits <- base::inherits
[16:12:33.011]             invokeRestart <- base::invokeRestart
[16:12:33.011]             length <- base::length
[16:12:33.011]             list <- base::list
[16:12:33.011]             seq.int <- base::seq.int
[16:12:33.011]             signalCondition <- base::signalCondition
[16:12:33.011]             sys.calls <- base::sys.calls
[16:12:33.011]             `[[` <- base::`[[`
[16:12:33.011]             `+` <- base::`+`
[16:12:33.011]             `<<-` <- base::`<<-`
[16:12:33.011]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:33.011]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:33.011]                   3L)]
[16:12:33.011]             }
[16:12:33.011]             function(cond) {
[16:12:33.011]                 is_error <- inherits(cond, "error")
[16:12:33.011]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:33.011]                   NULL)
[16:12:33.011]                 if (is_error) {
[16:12:33.011]                   sessionInformation <- function() {
[16:12:33.011]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:33.011]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:33.011]                       search = base::search(), system = base::Sys.info())
[16:12:33.011]                   }
[16:12:33.011]                   ...future.conditions[[length(...future.conditions) + 
[16:12:33.011]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:33.011]                     cond$call), session = sessionInformation(), 
[16:12:33.011]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:33.011]                   signalCondition(cond)
[16:12:33.011]                 }
[16:12:33.011]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:33.011]                 "immediateCondition"))) {
[16:12:33.011]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:33.011]                   ...future.conditions[[length(...future.conditions) + 
[16:12:33.011]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:33.011]                   if (TRUE && !signal) {
[16:12:33.011]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.011]                     {
[16:12:33.011]                       inherits <- base::inherits
[16:12:33.011]                       invokeRestart <- base::invokeRestart
[16:12:33.011]                       is.null <- base::is.null
[16:12:33.011]                       muffled <- FALSE
[16:12:33.011]                       if (inherits(cond, "message")) {
[16:12:33.011]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:33.011]                         if (muffled) 
[16:12:33.011]                           invokeRestart("muffleMessage")
[16:12:33.011]                       }
[16:12:33.011]                       else if (inherits(cond, "warning")) {
[16:12:33.011]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:33.011]                         if (muffled) 
[16:12:33.011]                           invokeRestart("muffleWarning")
[16:12:33.011]                       }
[16:12:33.011]                       else if (inherits(cond, "condition")) {
[16:12:33.011]                         if (!is.null(pattern)) {
[16:12:33.011]                           computeRestarts <- base::computeRestarts
[16:12:33.011]                           grepl <- base::grepl
[16:12:33.011]                           restarts <- computeRestarts(cond)
[16:12:33.011]                           for (restart in restarts) {
[16:12:33.011]                             name <- restart$name
[16:12:33.011]                             if (is.null(name)) 
[16:12:33.011]                               next
[16:12:33.011]                             if (!grepl(pattern, name)) 
[16:12:33.011]                               next
[16:12:33.011]                             invokeRestart(restart)
[16:12:33.011]                             muffled <- TRUE
[16:12:33.011]                             break
[16:12:33.011]                           }
[16:12:33.011]                         }
[16:12:33.011]                       }
[16:12:33.011]                       invisible(muffled)
[16:12:33.011]                     }
[16:12:33.011]                     muffleCondition(cond, pattern = "^muffle")
[16:12:33.011]                   }
[16:12:33.011]                 }
[16:12:33.011]                 else {
[16:12:33.011]                   if (TRUE) {
[16:12:33.011]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.011]                     {
[16:12:33.011]                       inherits <- base::inherits
[16:12:33.011]                       invokeRestart <- base::invokeRestart
[16:12:33.011]                       is.null <- base::is.null
[16:12:33.011]                       muffled <- FALSE
[16:12:33.011]                       if (inherits(cond, "message")) {
[16:12:33.011]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:33.011]                         if (muffled) 
[16:12:33.011]                           invokeRestart("muffleMessage")
[16:12:33.011]                       }
[16:12:33.011]                       else if (inherits(cond, "warning")) {
[16:12:33.011]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:33.011]                         if (muffled) 
[16:12:33.011]                           invokeRestart("muffleWarning")
[16:12:33.011]                       }
[16:12:33.011]                       else if (inherits(cond, "condition")) {
[16:12:33.011]                         if (!is.null(pattern)) {
[16:12:33.011]                           computeRestarts <- base::computeRestarts
[16:12:33.011]                           grepl <- base::grepl
[16:12:33.011]                           restarts <- computeRestarts(cond)
[16:12:33.011]                           for (restart in restarts) {
[16:12:33.011]                             name <- restart$name
[16:12:33.011]                             if (is.null(name)) 
[16:12:33.011]                               next
[16:12:33.011]                             if (!grepl(pattern, name)) 
[16:12:33.011]                               next
[16:12:33.011]                             invokeRestart(restart)
[16:12:33.011]                             muffled <- TRUE
[16:12:33.011]                             break
[16:12:33.011]                           }
[16:12:33.011]                         }
[16:12:33.011]                       }
[16:12:33.011]                       invisible(muffled)
[16:12:33.011]                     }
[16:12:33.011]                     muffleCondition(cond, pattern = "^muffle")
[16:12:33.011]                   }
[16:12:33.011]                 }
[16:12:33.011]             }
[16:12:33.011]         }))
[16:12:33.011]     }, error = function(ex) {
[16:12:33.011]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:33.011]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:33.011]                 ...future.rng), started = ...future.startTime, 
[16:12:33.011]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:33.011]             version = "1.8"), class = "FutureResult")
[16:12:33.011]     }, finally = {
[16:12:33.011]         if (!identical(...future.workdir, getwd())) 
[16:12:33.011]             setwd(...future.workdir)
[16:12:33.011]         {
[16:12:33.011]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:33.011]                 ...future.oldOptions$nwarnings <- NULL
[16:12:33.011]             }
[16:12:33.011]             base::options(...future.oldOptions)
[16:12:33.011]             if (.Platform$OS.type == "windows") {
[16:12:33.011]                 old_names <- names(...future.oldEnvVars)
[16:12:33.011]                 envs <- base::Sys.getenv()
[16:12:33.011]                 names <- names(envs)
[16:12:33.011]                 common <- intersect(names, old_names)
[16:12:33.011]                 added <- setdiff(names, old_names)
[16:12:33.011]                 removed <- setdiff(old_names, names)
[16:12:33.011]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:33.011]                   envs[common]]
[16:12:33.011]                 NAMES <- toupper(changed)
[16:12:33.011]                 args <- list()
[16:12:33.011]                 for (kk in seq_along(NAMES)) {
[16:12:33.011]                   name <- changed[[kk]]
[16:12:33.011]                   NAME <- NAMES[[kk]]
[16:12:33.011]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.011]                     next
[16:12:33.011]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:33.011]                 }
[16:12:33.011]                 NAMES <- toupper(added)
[16:12:33.011]                 for (kk in seq_along(NAMES)) {
[16:12:33.011]                   name <- added[[kk]]
[16:12:33.011]                   NAME <- NAMES[[kk]]
[16:12:33.011]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.011]                     next
[16:12:33.011]                   args[[name]] <- ""
[16:12:33.011]                 }
[16:12:33.011]                 NAMES <- toupper(removed)
[16:12:33.011]                 for (kk in seq_along(NAMES)) {
[16:12:33.011]                   name <- removed[[kk]]
[16:12:33.011]                   NAME <- NAMES[[kk]]
[16:12:33.011]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.011]                     next
[16:12:33.011]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:33.011]                 }
[16:12:33.011]                 if (length(args) > 0) 
[16:12:33.011]                   base::do.call(base::Sys.setenv, args = args)
[16:12:33.011]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:33.011]             }
[16:12:33.011]             else {
[16:12:33.011]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:33.011]             }
[16:12:33.011]             {
[16:12:33.011]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:33.011]                   0L) {
[16:12:33.011]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:33.011]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:33.011]                   base::options(opts)
[16:12:33.011]                 }
[16:12:33.011]                 {
[16:12:33.011]                   {
[16:12:33.011]                     NULL
[16:12:33.011]                     RNGkind("Mersenne-Twister")
[16:12:33.011]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:33.011]                       inherits = FALSE)
[16:12:33.011]                   }
[16:12:33.011]                   options(future.plan = NULL)
[16:12:33.011]                   if (is.na(NA_character_)) 
[16:12:33.011]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:33.011]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:33.011]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:33.011]                   {
[16:12:33.011]                     future <- SequentialFuture(..., envir = envir)
[16:12:33.011]                     if (!future$lazy) 
[16:12:33.011]                       future <- run(future)
[16:12:33.011]                     invisible(future)
[16:12:33.011]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:33.011]                 }
[16:12:33.011]             }
[16:12:33.011]         }
[16:12:33.011]     })
[16:12:33.011]     if (TRUE) {
[16:12:33.011]         base::sink(type = "output", split = FALSE)
[16:12:33.011]         if (TRUE) {
[16:12:33.011]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:33.011]         }
[16:12:33.011]         else {
[16:12:33.011]             ...future.result["stdout"] <- base::list(NULL)
[16:12:33.011]         }
[16:12:33.011]         base::close(...future.stdout)
[16:12:33.011]         ...future.stdout <- NULL
[16:12:33.011]     }
[16:12:33.011]     ...future.result$conditions <- ...future.conditions
[16:12:33.011]     ...future.result$finished <- base::Sys.time()
[16:12:33.011]     ...future.result
[16:12:33.011] }
[16:12:33.012] plan(): Setting new future strategy stack:
[16:12:33.013] List of future strategies:
[16:12:33.013] 1. sequential:
[16:12:33.013]    - args: function (..., envir = parent.frame())
[16:12:33.013]    - tweaked: FALSE
[16:12:33.013]    - call: NULL
[16:12:33.013] plan(): nbrOfWorkers() = 1
[16:12:33.014] plan(): Setting new future strategy stack:
[16:12:33.014] List of future strategies:
[16:12:33.014] 1. sequential:
[16:12:33.014]    - args: function (..., envir = parent.frame())
[16:12:33.014]    - tweaked: FALSE
[16:12:33.014]    - call: plan(strategy)
[16:12:33.014] plan(): nbrOfWorkers() = 1
[16:12:33.015] SequentialFuture started (and completed)
[16:12:33.015] - Launch lazy future ... done
[16:12:33.015] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[16:12:33.017] getGlobalsAndPackages() ...
[16:12:33.017] Searching for globals...
[16:12:33.020] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[16:12:33.020] Searching for globals ... DONE
[16:12:33.020] Resolving globals: FALSE
[16:12:33.021] 
[16:12:33.021] - packages: [2] ‘stats’, ‘datasets’
[16:12:33.021] getGlobalsAndPackages() ... DONE
[16:12:33.021] run() for ‘Future’ ...
[16:12:33.021] - state: ‘created’
[16:12:33.022] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:33.022] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:33.022] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:33.022]   - Field: ‘label’
[16:12:33.022]   - Field: ‘local’
[16:12:33.022]   - Field: ‘owner’
[16:12:33.022]   - Field: ‘envir’
[16:12:33.022]   - Field: ‘packages’
[16:12:33.023]   - Field: ‘gc’
[16:12:33.023]   - Field: ‘conditions’
[16:12:33.023]   - Field: ‘expr’
[16:12:33.023]   - Field: ‘uuid’
[16:12:33.023]   - Field: ‘seed’
[16:12:33.023]   - Field: ‘version’
[16:12:33.023]   - Field: ‘result’
[16:12:33.023]   - Field: ‘asynchronous’
[16:12:33.023]   - Field: ‘calls’
[16:12:33.023]   - Field: ‘globals’
[16:12:33.023]   - Field: ‘stdout’
[16:12:33.023]   - Field: ‘earlySignal’
[16:12:33.024]   - Field: ‘lazy’
[16:12:33.024]   - Field: ‘state’
[16:12:33.024] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:33.024] - Launch lazy future ...
[16:12:33.024] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:12:33.024] Packages needed by future strategies (n = 0): <none>
[16:12:33.025] {
[16:12:33.025]     {
[16:12:33.025]         {
[16:12:33.025]             ...future.startTime <- base::Sys.time()
[16:12:33.025]             {
[16:12:33.025]                 {
[16:12:33.025]                   {
[16:12:33.025]                     {
[16:12:33.025]                       base::local({
[16:12:33.025]                         has_future <- base::requireNamespace("future", 
[16:12:33.025]                           quietly = TRUE)
[16:12:33.025]                         if (has_future) {
[16:12:33.025]                           ns <- base::getNamespace("future")
[16:12:33.025]                           version <- ns[[".package"]][["version"]]
[16:12:33.025]                           if (is.null(version)) 
[16:12:33.025]                             version <- utils::packageVersion("future")
[16:12:33.025]                         }
[16:12:33.025]                         else {
[16:12:33.025]                           version <- NULL
[16:12:33.025]                         }
[16:12:33.025]                         if (!has_future || version < "1.8.0") {
[16:12:33.025]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:33.025]                             "", base::R.version$version.string), 
[16:12:33.025]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:33.025]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:33.025]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:33.025]                               "release", "version")], collapse = " "), 
[16:12:33.025]                             hostname = base::Sys.info()[["nodename"]])
[16:12:33.025]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:33.025]                             info)
[16:12:33.025]                           info <- base::paste(info, collapse = "; ")
[16:12:33.025]                           if (!has_future) {
[16:12:33.025]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:33.025]                               info)
[16:12:33.025]                           }
[16:12:33.025]                           else {
[16:12:33.025]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:33.025]                               info, version)
[16:12:33.025]                           }
[16:12:33.025]                           base::stop(msg)
[16:12:33.025]                         }
[16:12:33.025]                       })
[16:12:33.025]                     }
[16:12:33.025]                     base::local({
[16:12:33.025]                       for (pkg in c("stats", "datasets")) {
[16:12:33.025]                         base::loadNamespace(pkg)
[16:12:33.025]                         base::library(pkg, character.only = TRUE)
[16:12:33.025]                       }
[16:12:33.025]                     })
[16:12:33.025]                   }
[16:12:33.025]                   options(future.plan = NULL)
[16:12:33.025]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:33.025]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:33.025]                 }
[16:12:33.025]                 ...future.workdir <- getwd()
[16:12:33.025]             }
[16:12:33.025]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:33.025]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:33.025]         }
[16:12:33.025]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:33.025]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:33.025]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:33.025]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:33.025]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:33.025]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:33.025]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:33.025]             base::names(...future.oldOptions))
[16:12:33.025]     }
[16:12:33.025]     if (FALSE) {
[16:12:33.025]     }
[16:12:33.025]     else {
[16:12:33.025]         if (TRUE) {
[16:12:33.025]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:33.025]                 open = "w")
[16:12:33.025]         }
[16:12:33.025]         else {
[16:12:33.025]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:33.025]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:33.025]         }
[16:12:33.025]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:33.025]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:33.025]             base::sink(type = "output", split = FALSE)
[16:12:33.025]             base::close(...future.stdout)
[16:12:33.025]         }, add = TRUE)
[16:12:33.025]     }
[16:12:33.025]     ...future.frame <- base::sys.nframe()
[16:12:33.025]     ...future.conditions <- base::list()
[16:12:33.025]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:33.025]     if (FALSE) {
[16:12:33.025]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:33.025]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:33.025]     }
[16:12:33.025]     ...future.result <- base::tryCatch({
[16:12:33.025]         base::withCallingHandlers({
[16:12:33.025]             ...future.value <- base::withVisible(base::local({
[16:12:33.025]                 lm(dist ~ speed + I(speed^2), data = cars)
[16:12:33.025]             }))
[16:12:33.025]             future::FutureResult(value = ...future.value$value, 
[16:12:33.025]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:33.025]                   ...future.rng), globalenv = if (FALSE) 
[16:12:33.025]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:33.025]                     ...future.globalenv.names))
[16:12:33.025]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:33.025]         }, condition = base::local({
[16:12:33.025]             c <- base::c
[16:12:33.025]             inherits <- base::inherits
[16:12:33.025]             invokeRestart <- base::invokeRestart
[16:12:33.025]             length <- base::length
[16:12:33.025]             list <- base::list
[16:12:33.025]             seq.int <- base::seq.int
[16:12:33.025]             signalCondition <- base::signalCondition
[16:12:33.025]             sys.calls <- base::sys.calls
[16:12:33.025]             `[[` <- base::`[[`
[16:12:33.025]             `+` <- base::`+`
[16:12:33.025]             `<<-` <- base::`<<-`
[16:12:33.025]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:33.025]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:33.025]                   3L)]
[16:12:33.025]             }
[16:12:33.025]             function(cond) {
[16:12:33.025]                 is_error <- inherits(cond, "error")
[16:12:33.025]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:33.025]                   NULL)
[16:12:33.025]                 if (is_error) {
[16:12:33.025]                   sessionInformation <- function() {
[16:12:33.025]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:33.025]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:33.025]                       search = base::search(), system = base::Sys.info())
[16:12:33.025]                   }
[16:12:33.025]                   ...future.conditions[[length(...future.conditions) + 
[16:12:33.025]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:33.025]                     cond$call), session = sessionInformation(), 
[16:12:33.025]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:33.025]                   signalCondition(cond)
[16:12:33.025]                 }
[16:12:33.025]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:33.025]                 "immediateCondition"))) {
[16:12:33.025]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:33.025]                   ...future.conditions[[length(...future.conditions) + 
[16:12:33.025]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:33.025]                   if (TRUE && !signal) {
[16:12:33.025]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.025]                     {
[16:12:33.025]                       inherits <- base::inherits
[16:12:33.025]                       invokeRestart <- base::invokeRestart
[16:12:33.025]                       is.null <- base::is.null
[16:12:33.025]                       muffled <- FALSE
[16:12:33.025]                       if (inherits(cond, "message")) {
[16:12:33.025]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:33.025]                         if (muffled) 
[16:12:33.025]                           invokeRestart("muffleMessage")
[16:12:33.025]                       }
[16:12:33.025]                       else if (inherits(cond, "warning")) {
[16:12:33.025]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:33.025]                         if (muffled) 
[16:12:33.025]                           invokeRestart("muffleWarning")
[16:12:33.025]                       }
[16:12:33.025]                       else if (inherits(cond, "condition")) {
[16:12:33.025]                         if (!is.null(pattern)) {
[16:12:33.025]                           computeRestarts <- base::computeRestarts
[16:12:33.025]                           grepl <- base::grepl
[16:12:33.025]                           restarts <- computeRestarts(cond)
[16:12:33.025]                           for (restart in restarts) {
[16:12:33.025]                             name <- restart$name
[16:12:33.025]                             if (is.null(name)) 
[16:12:33.025]                               next
[16:12:33.025]                             if (!grepl(pattern, name)) 
[16:12:33.025]                               next
[16:12:33.025]                             invokeRestart(restart)
[16:12:33.025]                             muffled <- TRUE
[16:12:33.025]                             break
[16:12:33.025]                           }
[16:12:33.025]                         }
[16:12:33.025]                       }
[16:12:33.025]                       invisible(muffled)
[16:12:33.025]                     }
[16:12:33.025]                     muffleCondition(cond, pattern = "^muffle")
[16:12:33.025]                   }
[16:12:33.025]                 }
[16:12:33.025]                 else {
[16:12:33.025]                   if (TRUE) {
[16:12:33.025]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.025]                     {
[16:12:33.025]                       inherits <- base::inherits
[16:12:33.025]                       invokeRestart <- base::invokeRestart
[16:12:33.025]                       is.null <- base::is.null
[16:12:33.025]                       muffled <- FALSE
[16:12:33.025]                       if (inherits(cond, "message")) {
[16:12:33.025]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:33.025]                         if (muffled) 
[16:12:33.025]                           invokeRestart("muffleMessage")
[16:12:33.025]                       }
[16:12:33.025]                       else if (inherits(cond, "warning")) {
[16:12:33.025]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:33.025]                         if (muffled) 
[16:12:33.025]                           invokeRestart("muffleWarning")
[16:12:33.025]                       }
[16:12:33.025]                       else if (inherits(cond, "condition")) {
[16:12:33.025]                         if (!is.null(pattern)) {
[16:12:33.025]                           computeRestarts <- base::computeRestarts
[16:12:33.025]                           grepl <- base::grepl
[16:12:33.025]                           restarts <- computeRestarts(cond)
[16:12:33.025]                           for (restart in restarts) {
[16:12:33.025]                             name <- restart$name
[16:12:33.025]                             if (is.null(name)) 
[16:12:33.025]                               next
[16:12:33.025]                             if (!grepl(pattern, name)) 
[16:12:33.025]                               next
[16:12:33.025]                             invokeRestart(restart)
[16:12:33.025]                             muffled <- TRUE
[16:12:33.025]                             break
[16:12:33.025]                           }
[16:12:33.025]                         }
[16:12:33.025]                       }
[16:12:33.025]                       invisible(muffled)
[16:12:33.025]                     }
[16:12:33.025]                     muffleCondition(cond, pattern = "^muffle")
[16:12:33.025]                   }
[16:12:33.025]                 }
[16:12:33.025]             }
[16:12:33.025]         }))
[16:12:33.025]     }, error = function(ex) {
[16:12:33.025]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:33.025]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:33.025]                 ...future.rng), started = ...future.startTime, 
[16:12:33.025]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:33.025]             version = "1.8"), class = "FutureResult")
[16:12:33.025]     }, finally = {
[16:12:33.025]         if (!identical(...future.workdir, getwd())) 
[16:12:33.025]             setwd(...future.workdir)
[16:12:33.025]         {
[16:12:33.025]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:33.025]                 ...future.oldOptions$nwarnings <- NULL
[16:12:33.025]             }
[16:12:33.025]             base::options(...future.oldOptions)
[16:12:33.025]             if (.Platform$OS.type == "windows") {
[16:12:33.025]                 old_names <- names(...future.oldEnvVars)
[16:12:33.025]                 envs <- base::Sys.getenv()
[16:12:33.025]                 names <- names(envs)
[16:12:33.025]                 common <- intersect(names, old_names)
[16:12:33.025]                 added <- setdiff(names, old_names)
[16:12:33.025]                 removed <- setdiff(old_names, names)
[16:12:33.025]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:33.025]                   envs[common]]
[16:12:33.025]                 NAMES <- toupper(changed)
[16:12:33.025]                 args <- list()
[16:12:33.025]                 for (kk in seq_along(NAMES)) {
[16:12:33.025]                   name <- changed[[kk]]
[16:12:33.025]                   NAME <- NAMES[[kk]]
[16:12:33.025]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.025]                     next
[16:12:33.025]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:33.025]                 }
[16:12:33.025]                 NAMES <- toupper(added)
[16:12:33.025]                 for (kk in seq_along(NAMES)) {
[16:12:33.025]                   name <- added[[kk]]
[16:12:33.025]                   NAME <- NAMES[[kk]]
[16:12:33.025]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.025]                     next
[16:12:33.025]                   args[[name]] <- ""
[16:12:33.025]                 }
[16:12:33.025]                 NAMES <- toupper(removed)
[16:12:33.025]                 for (kk in seq_along(NAMES)) {
[16:12:33.025]                   name <- removed[[kk]]
[16:12:33.025]                   NAME <- NAMES[[kk]]
[16:12:33.025]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.025]                     next
[16:12:33.025]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:33.025]                 }
[16:12:33.025]                 if (length(args) > 0) 
[16:12:33.025]                   base::do.call(base::Sys.setenv, args = args)
[16:12:33.025]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:33.025]             }
[16:12:33.025]             else {
[16:12:33.025]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:33.025]             }
[16:12:33.025]             {
[16:12:33.025]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:33.025]                   0L) {
[16:12:33.025]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:33.025]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:33.025]                   base::options(opts)
[16:12:33.025]                 }
[16:12:33.025]                 {
[16:12:33.025]                   {
[16:12:33.025]                     NULL
[16:12:33.025]                     RNGkind("Mersenne-Twister")
[16:12:33.025]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:33.025]                       inherits = FALSE)
[16:12:33.025]                   }
[16:12:33.025]                   options(future.plan = NULL)
[16:12:33.025]                   if (is.na(NA_character_)) 
[16:12:33.025]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:33.025]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:33.025]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:33.025]                   {
[16:12:33.025]                     future <- SequentialFuture(..., envir = envir)
[16:12:33.025]                     if (!future$lazy) 
[16:12:33.025]                       future <- run(future)
[16:12:33.025]                     invisible(future)
[16:12:33.025]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:33.025]                 }
[16:12:33.025]             }
[16:12:33.025]         }
[16:12:33.025]     })
[16:12:33.025]     if (TRUE) {
[16:12:33.025]         base::sink(type = "output", split = FALSE)
[16:12:33.025]         if (TRUE) {
[16:12:33.025]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:33.025]         }
[16:12:33.025]         else {
[16:12:33.025]             ...future.result["stdout"] <- base::list(NULL)
[16:12:33.025]         }
[16:12:33.025]         base::close(...future.stdout)
[16:12:33.025]         ...future.stdout <- NULL
[16:12:33.025]     }
[16:12:33.025]     ...future.result$conditions <- ...future.conditions
[16:12:33.025]     ...future.result$finished <- base::Sys.time()
[16:12:33.025]     ...future.result
[16:12:33.025] }
[16:12:33.026] plan(): Setting new future strategy stack:
[16:12:33.027] List of future strategies:
[16:12:33.027] 1. sequential:
[16:12:33.027]    - args: function (..., envir = parent.frame())
[16:12:33.027]    - tweaked: FALSE
[16:12:33.027]    - call: NULL
[16:12:33.027] plan(): nbrOfWorkers() = 1
[16:12:33.028] plan(): Setting new future strategy stack:
[16:12:33.028] List of future strategies:
[16:12:33.028] 1. sequential:
[16:12:33.028]    - args: function (..., envir = parent.frame())
[16:12:33.028]    - tweaked: FALSE
[16:12:33.028]    - call: plan(strategy)
[16:12:33.029] plan(): nbrOfWorkers() = 1
[16:12:33.029] SequentialFuture started (and completed)
[16:12:33.029] - Launch lazy future ... done
[16:12:33.029] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[16:12:33.032] getGlobalsAndPackages() ...
[16:12:33.032] Searching for globals...
[16:12:33.034] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[16:12:33.034] Searching for globals ... DONE
[16:12:33.034] Resolving globals: FALSE
[16:12:33.034] 
[16:12:33.034] - packages: [2] ‘stats’, ‘datasets’
[16:12:33.035] getGlobalsAndPackages() ... DONE
[16:12:33.035] run() for ‘Future’ ...
[16:12:33.035] - state: ‘created’
[16:12:33.035] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:33.035] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:33.035] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:33.035]   - Field: ‘label’
[16:12:33.036]   - Field: ‘local’
[16:12:33.036]   - Field: ‘owner’
[16:12:33.036]   - Field: ‘envir’
[16:12:33.036]   - Field: ‘packages’
[16:12:33.036]   - Field: ‘gc’
[16:12:33.036]   - Field: ‘conditions’
[16:12:33.036]   - Field: ‘expr’
[16:12:33.036]   - Field: ‘uuid’
[16:12:33.036]   - Field: ‘seed’
[16:12:33.036]   - Field: ‘version’
[16:12:33.036]   - Field: ‘result’
[16:12:33.036]   - Field: ‘asynchronous’
[16:12:33.037]   - Field: ‘calls’
[16:12:33.037]   - Field: ‘globals’
[16:12:33.037]   - Field: ‘stdout’
[16:12:33.037]   - Field: ‘earlySignal’
[16:12:33.037]   - Field: ‘lazy’
[16:12:33.037]   - Field: ‘state’
[16:12:33.037] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:33.037] - Launch lazy future ...
[16:12:33.037] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:12:33.037] Packages needed by future strategies (n = 0): <none>
[16:12:33.038] {
[16:12:33.038]     {
[16:12:33.038]         {
[16:12:33.038]             ...future.startTime <- base::Sys.time()
[16:12:33.038]             {
[16:12:33.038]                 {
[16:12:33.038]                   {
[16:12:33.038]                     {
[16:12:33.038]                       base::local({
[16:12:33.038]                         has_future <- base::requireNamespace("future", 
[16:12:33.038]                           quietly = TRUE)
[16:12:33.038]                         if (has_future) {
[16:12:33.038]                           ns <- base::getNamespace("future")
[16:12:33.038]                           version <- ns[[".package"]][["version"]]
[16:12:33.038]                           if (is.null(version)) 
[16:12:33.038]                             version <- utils::packageVersion("future")
[16:12:33.038]                         }
[16:12:33.038]                         else {
[16:12:33.038]                           version <- NULL
[16:12:33.038]                         }
[16:12:33.038]                         if (!has_future || version < "1.8.0") {
[16:12:33.038]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:33.038]                             "", base::R.version$version.string), 
[16:12:33.038]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:33.038]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:33.038]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:33.038]                               "release", "version")], collapse = " "), 
[16:12:33.038]                             hostname = base::Sys.info()[["nodename"]])
[16:12:33.038]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:33.038]                             info)
[16:12:33.038]                           info <- base::paste(info, collapse = "; ")
[16:12:33.038]                           if (!has_future) {
[16:12:33.038]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:33.038]                               info)
[16:12:33.038]                           }
[16:12:33.038]                           else {
[16:12:33.038]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:33.038]                               info, version)
[16:12:33.038]                           }
[16:12:33.038]                           base::stop(msg)
[16:12:33.038]                         }
[16:12:33.038]                       })
[16:12:33.038]                     }
[16:12:33.038]                     base::local({
[16:12:33.038]                       for (pkg in c("stats", "datasets")) {
[16:12:33.038]                         base::loadNamespace(pkg)
[16:12:33.038]                         base::library(pkg, character.only = TRUE)
[16:12:33.038]                       }
[16:12:33.038]                     })
[16:12:33.038]                   }
[16:12:33.038]                   options(future.plan = NULL)
[16:12:33.038]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:33.038]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:33.038]                 }
[16:12:33.038]                 ...future.workdir <- getwd()
[16:12:33.038]             }
[16:12:33.038]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:33.038]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:33.038]         }
[16:12:33.038]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:33.038]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:33.038]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:33.038]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:33.038]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:33.038]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:33.038]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:33.038]             base::names(...future.oldOptions))
[16:12:33.038]     }
[16:12:33.038]     if (FALSE) {
[16:12:33.038]     }
[16:12:33.038]     else {
[16:12:33.038]         if (TRUE) {
[16:12:33.038]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:33.038]                 open = "w")
[16:12:33.038]         }
[16:12:33.038]         else {
[16:12:33.038]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:33.038]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:33.038]         }
[16:12:33.038]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:33.038]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:33.038]             base::sink(type = "output", split = FALSE)
[16:12:33.038]             base::close(...future.stdout)
[16:12:33.038]         }, add = TRUE)
[16:12:33.038]     }
[16:12:33.038]     ...future.frame <- base::sys.nframe()
[16:12:33.038]     ...future.conditions <- base::list()
[16:12:33.038]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:33.038]     if (FALSE) {
[16:12:33.038]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:33.038]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:33.038]     }
[16:12:33.038]     ...future.result <- base::tryCatch({
[16:12:33.038]         base::withCallingHandlers({
[16:12:33.038]             ...future.value <- base::withVisible(base::local({
[16:12:33.038]                 lm(dist ~ poly(speed, 2), data = cars)
[16:12:33.038]             }))
[16:12:33.038]             future::FutureResult(value = ...future.value$value, 
[16:12:33.038]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:33.038]                   ...future.rng), globalenv = if (FALSE) 
[16:12:33.038]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:33.038]                     ...future.globalenv.names))
[16:12:33.038]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:33.038]         }, condition = base::local({
[16:12:33.038]             c <- base::c
[16:12:33.038]             inherits <- base::inherits
[16:12:33.038]             invokeRestart <- base::invokeRestart
[16:12:33.038]             length <- base::length
[16:12:33.038]             list <- base::list
[16:12:33.038]             seq.int <- base::seq.int
[16:12:33.038]             signalCondition <- base::signalCondition
[16:12:33.038]             sys.calls <- base::sys.calls
[16:12:33.038]             `[[` <- base::`[[`
[16:12:33.038]             `+` <- base::`+`
[16:12:33.038]             `<<-` <- base::`<<-`
[16:12:33.038]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:33.038]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:33.038]                   3L)]
[16:12:33.038]             }
[16:12:33.038]             function(cond) {
[16:12:33.038]                 is_error <- inherits(cond, "error")
[16:12:33.038]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:33.038]                   NULL)
[16:12:33.038]                 if (is_error) {
[16:12:33.038]                   sessionInformation <- function() {
[16:12:33.038]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:33.038]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:33.038]                       search = base::search(), system = base::Sys.info())
[16:12:33.038]                   }
[16:12:33.038]                   ...future.conditions[[length(...future.conditions) + 
[16:12:33.038]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:33.038]                     cond$call), session = sessionInformation(), 
[16:12:33.038]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:33.038]                   signalCondition(cond)
[16:12:33.038]                 }
[16:12:33.038]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:33.038]                 "immediateCondition"))) {
[16:12:33.038]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:33.038]                   ...future.conditions[[length(...future.conditions) + 
[16:12:33.038]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:33.038]                   if (TRUE && !signal) {
[16:12:33.038]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.038]                     {
[16:12:33.038]                       inherits <- base::inherits
[16:12:33.038]                       invokeRestart <- base::invokeRestart
[16:12:33.038]                       is.null <- base::is.null
[16:12:33.038]                       muffled <- FALSE
[16:12:33.038]                       if (inherits(cond, "message")) {
[16:12:33.038]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:33.038]                         if (muffled) 
[16:12:33.038]                           invokeRestart("muffleMessage")
[16:12:33.038]                       }
[16:12:33.038]                       else if (inherits(cond, "warning")) {
[16:12:33.038]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:33.038]                         if (muffled) 
[16:12:33.038]                           invokeRestart("muffleWarning")
[16:12:33.038]                       }
[16:12:33.038]                       else if (inherits(cond, "condition")) {
[16:12:33.038]                         if (!is.null(pattern)) {
[16:12:33.038]                           computeRestarts <- base::computeRestarts
[16:12:33.038]                           grepl <- base::grepl
[16:12:33.038]                           restarts <- computeRestarts(cond)
[16:12:33.038]                           for (restart in restarts) {
[16:12:33.038]                             name <- restart$name
[16:12:33.038]                             if (is.null(name)) 
[16:12:33.038]                               next
[16:12:33.038]                             if (!grepl(pattern, name)) 
[16:12:33.038]                               next
[16:12:33.038]                             invokeRestart(restart)
[16:12:33.038]                             muffled <- TRUE
[16:12:33.038]                             break
[16:12:33.038]                           }
[16:12:33.038]                         }
[16:12:33.038]                       }
[16:12:33.038]                       invisible(muffled)
[16:12:33.038]                     }
[16:12:33.038]                     muffleCondition(cond, pattern = "^muffle")
[16:12:33.038]                   }
[16:12:33.038]                 }
[16:12:33.038]                 else {
[16:12:33.038]                   if (TRUE) {
[16:12:33.038]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.038]                     {
[16:12:33.038]                       inherits <- base::inherits
[16:12:33.038]                       invokeRestart <- base::invokeRestart
[16:12:33.038]                       is.null <- base::is.null
[16:12:33.038]                       muffled <- FALSE
[16:12:33.038]                       if (inherits(cond, "message")) {
[16:12:33.038]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:33.038]                         if (muffled) 
[16:12:33.038]                           invokeRestart("muffleMessage")
[16:12:33.038]                       }
[16:12:33.038]                       else if (inherits(cond, "warning")) {
[16:12:33.038]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:33.038]                         if (muffled) 
[16:12:33.038]                           invokeRestart("muffleWarning")
[16:12:33.038]                       }
[16:12:33.038]                       else if (inherits(cond, "condition")) {
[16:12:33.038]                         if (!is.null(pattern)) {
[16:12:33.038]                           computeRestarts <- base::computeRestarts
[16:12:33.038]                           grepl <- base::grepl
[16:12:33.038]                           restarts <- computeRestarts(cond)
[16:12:33.038]                           for (restart in restarts) {
[16:12:33.038]                             name <- restart$name
[16:12:33.038]                             if (is.null(name)) 
[16:12:33.038]                               next
[16:12:33.038]                             if (!grepl(pattern, name)) 
[16:12:33.038]                               next
[16:12:33.038]                             invokeRestart(restart)
[16:12:33.038]                             muffled <- TRUE
[16:12:33.038]                             break
[16:12:33.038]                           }
[16:12:33.038]                         }
[16:12:33.038]                       }
[16:12:33.038]                       invisible(muffled)
[16:12:33.038]                     }
[16:12:33.038]                     muffleCondition(cond, pattern = "^muffle")
[16:12:33.038]                   }
[16:12:33.038]                 }
[16:12:33.038]             }
[16:12:33.038]         }))
[16:12:33.038]     }, error = function(ex) {
[16:12:33.038]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:33.038]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:33.038]                 ...future.rng), started = ...future.startTime, 
[16:12:33.038]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:33.038]             version = "1.8"), class = "FutureResult")
[16:12:33.038]     }, finally = {
[16:12:33.038]         if (!identical(...future.workdir, getwd())) 
[16:12:33.038]             setwd(...future.workdir)
[16:12:33.038]         {
[16:12:33.038]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:33.038]                 ...future.oldOptions$nwarnings <- NULL
[16:12:33.038]             }
[16:12:33.038]             base::options(...future.oldOptions)
[16:12:33.038]             if (.Platform$OS.type == "windows") {
[16:12:33.038]                 old_names <- names(...future.oldEnvVars)
[16:12:33.038]                 envs <- base::Sys.getenv()
[16:12:33.038]                 names <- names(envs)
[16:12:33.038]                 common <- intersect(names, old_names)
[16:12:33.038]                 added <- setdiff(names, old_names)
[16:12:33.038]                 removed <- setdiff(old_names, names)
[16:12:33.038]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:33.038]                   envs[common]]
[16:12:33.038]                 NAMES <- toupper(changed)
[16:12:33.038]                 args <- list()
[16:12:33.038]                 for (kk in seq_along(NAMES)) {
[16:12:33.038]                   name <- changed[[kk]]
[16:12:33.038]                   NAME <- NAMES[[kk]]
[16:12:33.038]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.038]                     next
[16:12:33.038]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:33.038]                 }
[16:12:33.038]                 NAMES <- toupper(added)
[16:12:33.038]                 for (kk in seq_along(NAMES)) {
[16:12:33.038]                   name <- added[[kk]]
[16:12:33.038]                   NAME <- NAMES[[kk]]
[16:12:33.038]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.038]                     next
[16:12:33.038]                   args[[name]] <- ""
[16:12:33.038]                 }
[16:12:33.038]                 NAMES <- toupper(removed)
[16:12:33.038]                 for (kk in seq_along(NAMES)) {
[16:12:33.038]                   name <- removed[[kk]]
[16:12:33.038]                   NAME <- NAMES[[kk]]
[16:12:33.038]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.038]                     next
[16:12:33.038]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:33.038]                 }
[16:12:33.038]                 if (length(args) > 0) 
[16:12:33.038]                   base::do.call(base::Sys.setenv, args = args)
[16:12:33.038]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:33.038]             }
[16:12:33.038]             else {
[16:12:33.038]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:33.038]             }
[16:12:33.038]             {
[16:12:33.038]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:33.038]                   0L) {
[16:12:33.038]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:33.038]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:33.038]                   base::options(opts)
[16:12:33.038]                 }
[16:12:33.038]                 {
[16:12:33.038]                   {
[16:12:33.038]                     NULL
[16:12:33.038]                     RNGkind("Mersenne-Twister")
[16:12:33.038]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:33.038]                       inherits = FALSE)
[16:12:33.038]                   }
[16:12:33.038]                   options(future.plan = NULL)
[16:12:33.038]                   if (is.na(NA_character_)) 
[16:12:33.038]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:33.038]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:33.038]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:33.038]                   {
[16:12:33.038]                     future <- SequentialFuture(..., envir = envir)
[16:12:33.038]                     if (!future$lazy) 
[16:12:33.038]                       future <- run(future)
[16:12:33.038]                     invisible(future)
[16:12:33.038]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:33.038]                 }
[16:12:33.038]             }
[16:12:33.038]         }
[16:12:33.038]     })
[16:12:33.038]     if (TRUE) {
[16:12:33.038]         base::sink(type = "output", split = FALSE)
[16:12:33.038]         if (TRUE) {
[16:12:33.038]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:33.038]         }
[16:12:33.038]         else {
[16:12:33.038]             ...future.result["stdout"] <- base::list(NULL)
[16:12:33.038]         }
[16:12:33.038]         base::close(...future.stdout)
[16:12:33.038]         ...future.stdout <- NULL
[16:12:33.038]     }
[16:12:33.038]     ...future.result$conditions <- ...future.conditions
[16:12:33.038]     ...future.result$finished <- base::Sys.time()
[16:12:33.038]     ...future.result
[16:12:33.038] }
[16:12:33.040] plan(): Setting new future strategy stack:
[16:12:33.040] List of future strategies:
[16:12:33.040] 1. sequential:
[16:12:33.040]    - args: function (..., envir = parent.frame())
[16:12:33.040]    - tweaked: FALSE
[16:12:33.040]    - call: NULL
[16:12:33.040] plan(): nbrOfWorkers() = 1
[16:12:33.042] plan(): Setting new future strategy stack:
[16:12:33.042] List of future strategies:
[16:12:33.042] 1. sequential:
[16:12:33.042]    - args: function (..., envir = parent.frame())
[16:12:33.042]    - tweaked: FALSE
[16:12:33.042]    - call: plan(strategy)
[16:12:33.042] plan(): nbrOfWorkers() = 1
[16:12:33.043] SequentialFuture started (and completed)
[16:12:33.043] - Launch lazy future ... done
[16:12:33.044] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[16:12:33.045] getGlobalsAndPackages() ...
[16:12:33.045] Searching for globals...
[16:12:33.050] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[16:12:33.050] Searching for globals ... DONE
[16:12:33.050] Resolving globals: FALSE
[16:12:33.051] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[16:12:33.051] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[16:12:33.051] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[16:12:33.051] 
[16:12:33.052] getGlobalsAndPackages() ... DONE
[16:12:33.052] run() for ‘Future’ ...
[16:12:33.052] - state: ‘created’
[16:12:33.052] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:33.052] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:33.052] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:33.052]   - Field: ‘label’
[16:12:33.052]   - Field: ‘local’
[16:12:33.053]   - Field: ‘owner’
[16:12:33.053]   - Field: ‘envir’
[16:12:33.053]   - Field: ‘packages’
[16:12:33.053]   - Field: ‘gc’
[16:12:33.053]   - Field: ‘conditions’
[16:12:33.053]   - Field: ‘expr’
[16:12:33.053]   - Field: ‘uuid’
[16:12:33.053]   - Field: ‘seed’
[16:12:33.053]   - Field: ‘version’
[16:12:33.053]   - Field: ‘result’
[16:12:33.053]   - Field: ‘asynchronous’
[16:12:33.054]   - Field: ‘calls’
[16:12:33.054]   - Field: ‘globals’
[16:12:33.054]   - Field: ‘stdout’
[16:12:33.054]   - Field: ‘earlySignal’
[16:12:33.054]   - Field: ‘lazy’
[16:12:33.054]   - Field: ‘state’
[16:12:33.054] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:33.054] - Launch lazy future ...
[16:12:33.054] Packages needed by the future expression (n = 0): <none>
[16:12:33.054] Packages needed by future strategies (n = 0): <none>
[16:12:33.055] {
[16:12:33.055]     {
[16:12:33.055]         {
[16:12:33.055]             ...future.startTime <- base::Sys.time()
[16:12:33.055]             {
[16:12:33.055]                 {
[16:12:33.055]                   {
[16:12:33.055]                     base::local({
[16:12:33.055]                       has_future <- base::requireNamespace("future", 
[16:12:33.055]                         quietly = TRUE)
[16:12:33.055]                       if (has_future) {
[16:12:33.055]                         ns <- base::getNamespace("future")
[16:12:33.055]                         version <- ns[[".package"]][["version"]]
[16:12:33.055]                         if (is.null(version)) 
[16:12:33.055]                           version <- utils::packageVersion("future")
[16:12:33.055]                       }
[16:12:33.055]                       else {
[16:12:33.055]                         version <- NULL
[16:12:33.055]                       }
[16:12:33.055]                       if (!has_future || version < "1.8.0") {
[16:12:33.055]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:33.055]                           "", base::R.version$version.string), 
[16:12:33.055]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:33.055]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:33.055]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:33.055]                             "release", "version")], collapse = " "), 
[16:12:33.055]                           hostname = base::Sys.info()[["nodename"]])
[16:12:33.055]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:33.055]                           info)
[16:12:33.055]                         info <- base::paste(info, collapse = "; ")
[16:12:33.055]                         if (!has_future) {
[16:12:33.055]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:33.055]                             info)
[16:12:33.055]                         }
[16:12:33.055]                         else {
[16:12:33.055]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:33.055]                             info, version)
[16:12:33.055]                         }
[16:12:33.055]                         base::stop(msg)
[16:12:33.055]                       }
[16:12:33.055]                     })
[16:12:33.055]                   }
[16:12:33.055]                   options(future.plan = NULL)
[16:12:33.055]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:33.055]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:33.055]                 }
[16:12:33.055]                 ...future.workdir <- getwd()
[16:12:33.055]             }
[16:12:33.055]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:33.055]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:33.055]         }
[16:12:33.055]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:33.055]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:33.055]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:33.055]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:33.055]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:33.055]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:33.055]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:33.055]             base::names(...future.oldOptions))
[16:12:33.055]     }
[16:12:33.055]     if (FALSE) {
[16:12:33.055]     }
[16:12:33.055]     else {
[16:12:33.055]         if (TRUE) {
[16:12:33.055]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:33.055]                 open = "w")
[16:12:33.055]         }
[16:12:33.055]         else {
[16:12:33.055]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:33.055]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:33.055]         }
[16:12:33.055]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:33.055]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:33.055]             base::sink(type = "output", split = FALSE)
[16:12:33.055]             base::close(...future.stdout)
[16:12:33.055]         }, add = TRUE)
[16:12:33.055]     }
[16:12:33.055]     ...future.frame <- base::sys.nframe()
[16:12:33.055]     ...future.conditions <- base::list()
[16:12:33.055]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:33.055]     if (FALSE) {
[16:12:33.055]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:33.055]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:33.055]     }
[16:12:33.055]     ...future.result <- base::tryCatch({
[16:12:33.055]         base::withCallingHandlers({
[16:12:33.055]             ...future.value <- base::withVisible(base::local({
[16:12:33.055]                 outer_function(1L)
[16:12:33.055]             }))
[16:12:33.055]             future::FutureResult(value = ...future.value$value, 
[16:12:33.055]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:33.055]                   ...future.rng), globalenv = if (FALSE) 
[16:12:33.055]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:33.055]                     ...future.globalenv.names))
[16:12:33.055]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:33.055]         }, condition = base::local({
[16:12:33.055]             c <- base::c
[16:12:33.055]             inherits <- base::inherits
[16:12:33.055]             invokeRestart <- base::invokeRestart
[16:12:33.055]             length <- base::length
[16:12:33.055]             list <- base::list
[16:12:33.055]             seq.int <- base::seq.int
[16:12:33.055]             signalCondition <- base::signalCondition
[16:12:33.055]             sys.calls <- base::sys.calls
[16:12:33.055]             `[[` <- base::`[[`
[16:12:33.055]             `+` <- base::`+`
[16:12:33.055]             `<<-` <- base::`<<-`
[16:12:33.055]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:33.055]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:33.055]                   3L)]
[16:12:33.055]             }
[16:12:33.055]             function(cond) {
[16:12:33.055]                 is_error <- inherits(cond, "error")
[16:12:33.055]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:33.055]                   NULL)
[16:12:33.055]                 if (is_error) {
[16:12:33.055]                   sessionInformation <- function() {
[16:12:33.055]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:33.055]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:33.055]                       search = base::search(), system = base::Sys.info())
[16:12:33.055]                   }
[16:12:33.055]                   ...future.conditions[[length(...future.conditions) + 
[16:12:33.055]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:33.055]                     cond$call), session = sessionInformation(), 
[16:12:33.055]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:33.055]                   signalCondition(cond)
[16:12:33.055]                 }
[16:12:33.055]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:33.055]                 "immediateCondition"))) {
[16:12:33.055]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:33.055]                   ...future.conditions[[length(...future.conditions) + 
[16:12:33.055]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:33.055]                   if (TRUE && !signal) {
[16:12:33.055]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.055]                     {
[16:12:33.055]                       inherits <- base::inherits
[16:12:33.055]                       invokeRestart <- base::invokeRestart
[16:12:33.055]                       is.null <- base::is.null
[16:12:33.055]                       muffled <- FALSE
[16:12:33.055]                       if (inherits(cond, "message")) {
[16:12:33.055]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:33.055]                         if (muffled) 
[16:12:33.055]                           invokeRestart("muffleMessage")
[16:12:33.055]                       }
[16:12:33.055]                       else if (inherits(cond, "warning")) {
[16:12:33.055]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:33.055]                         if (muffled) 
[16:12:33.055]                           invokeRestart("muffleWarning")
[16:12:33.055]                       }
[16:12:33.055]                       else if (inherits(cond, "condition")) {
[16:12:33.055]                         if (!is.null(pattern)) {
[16:12:33.055]                           computeRestarts <- base::computeRestarts
[16:12:33.055]                           grepl <- base::grepl
[16:12:33.055]                           restarts <- computeRestarts(cond)
[16:12:33.055]                           for (restart in restarts) {
[16:12:33.055]                             name <- restart$name
[16:12:33.055]                             if (is.null(name)) 
[16:12:33.055]                               next
[16:12:33.055]                             if (!grepl(pattern, name)) 
[16:12:33.055]                               next
[16:12:33.055]                             invokeRestart(restart)
[16:12:33.055]                             muffled <- TRUE
[16:12:33.055]                             break
[16:12:33.055]                           }
[16:12:33.055]                         }
[16:12:33.055]                       }
[16:12:33.055]                       invisible(muffled)
[16:12:33.055]                     }
[16:12:33.055]                     muffleCondition(cond, pattern = "^muffle")
[16:12:33.055]                   }
[16:12:33.055]                 }
[16:12:33.055]                 else {
[16:12:33.055]                   if (TRUE) {
[16:12:33.055]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.055]                     {
[16:12:33.055]                       inherits <- base::inherits
[16:12:33.055]                       invokeRestart <- base::invokeRestart
[16:12:33.055]                       is.null <- base::is.null
[16:12:33.055]                       muffled <- FALSE
[16:12:33.055]                       if (inherits(cond, "message")) {
[16:12:33.055]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:33.055]                         if (muffled) 
[16:12:33.055]                           invokeRestart("muffleMessage")
[16:12:33.055]                       }
[16:12:33.055]                       else if (inherits(cond, "warning")) {
[16:12:33.055]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:33.055]                         if (muffled) 
[16:12:33.055]                           invokeRestart("muffleWarning")
[16:12:33.055]                       }
[16:12:33.055]                       else if (inherits(cond, "condition")) {
[16:12:33.055]                         if (!is.null(pattern)) {
[16:12:33.055]                           computeRestarts <- base::computeRestarts
[16:12:33.055]                           grepl <- base::grepl
[16:12:33.055]                           restarts <- computeRestarts(cond)
[16:12:33.055]                           for (restart in restarts) {
[16:12:33.055]                             name <- restart$name
[16:12:33.055]                             if (is.null(name)) 
[16:12:33.055]                               next
[16:12:33.055]                             if (!grepl(pattern, name)) 
[16:12:33.055]                               next
[16:12:33.055]                             invokeRestart(restart)
[16:12:33.055]                             muffled <- TRUE
[16:12:33.055]                             break
[16:12:33.055]                           }
[16:12:33.055]                         }
[16:12:33.055]                       }
[16:12:33.055]                       invisible(muffled)
[16:12:33.055]                     }
[16:12:33.055]                     muffleCondition(cond, pattern = "^muffle")
[16:12:33.055]                   }
[16:12:33.055]                 }
[16:12:33.055]             }
[16:12:33.055]         }))
[16:12:33.055]     }, error = function(ex) {
[16:12:33.055]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:33.055]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:33.055]                 ...future.rng), started = ...future.startTime, 
[16:12:33.055]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:33.055]             version = "1.8"), class = "FutureResult")
[16:12:33.055]     }, finally = {
[16:12:33.055]         if (!identical(...future.workdir, getwd())) 
[16:12:33.055]             setwd(...future.workdir)
[16:12:33.055]         {
[16:12:33.055]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:33.055]                 ...future.oldOptions$nwarnings <- NULL
[16:12:33.055]             }
[16:12:33.055]             base::options(...future.oldOptions)
[16:12:33.055]             if (.Platform$OS.type == "windows") {
[16:12:33.055]                 old_names <- names(...future.oldEnvVars)
[16:12:33.055]                 envs <- base::Sys.getenv()
[16:12:33.055]                 names <- names(envs)
[16:12:33.055]                 common <- intersect(names, old_names)
[16:12:33.055]                 added <- setdiff(names, old_names)
[16:12:33.055]                 removed <- setdiff(old_names, names)
[16:12:33.055]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:33.055]                   envs[common]]
[16:12:33.055]                 NAMES <- toupper(changed)
[16:12:33.055]                 args <- list()
[16:12:33.055]                 for (kk in seq_along(NAMES)) {
[16:12:33.055]                   name <- changed[[kk]]
[16:12:33.055]                   NAME <- NAMES[[kk]]
[16:12:33.055]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.055]                     next
[16:12:33.055]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:33.055]                 }
[16:12:33.055]                 NAMES <- toupper(added)
[16:12:33.055]                 for (kk in seq_along(NAMES)) {
[16:12:33.055]                   name <- added[[kk]]
[16:12:33.055]                   NAME <- NAMES[[kk]]
[16:12:33.055]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.055]                     next
[16:12:33.055]                   args[[name]] <- ""
[16:12:33.055]                 }
[16:12:33.055]                 NAMES <- toupper(removed)
[16:12:33.055]                 for (kk in seq_along(NAMES)) {
[16:12:33.055]                   name <- removed[[kk]]
[16:12:33.055]                   NAME <- NAMES[[kk]]
[16:12:33.055]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.055]                     next
[16:12:33.055]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:33.055]                 }
[16:12:33.055]                 if (length(args) > 0) 
[16:12:33.055]                   base::do.call(base::Sys.setenv, args = args)
[16:12:33.055]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:33.055]             }
[16:12:33.055]             else {
[16:12:33.055]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:33.055]             }
[16:12:33.055]             {
[16:12:33.055]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:33.055]                   0L) {
[16:12:33.055]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:33.055]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:33.055]                   base::options(opts)
[16:12:33.055]                 }
[16:12:33.055]                 {
[16:12:33.055]                   {
[16:12:33.055]                     NULL
[16:12:33.055]                     RNGkind("Mersenne-Twister")
[16:12:33.055]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:33.055]                       inherits = FALSE)
[16:12:33.055]                   }
[16:12:33.055]                   options(future.plan = NULL)
[16:12:33.055]                   if (is.na(NA_character_)) 
[16:12:33.055]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:33.055]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:33.055]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:33.055]                   {
[16:12:33.055]                     future <- SequentialFuture(..., envir = envir)
[16:12:33.055]                     if (!future$lazy) 
[16:12:33.055]                       future <- run(future)
[16:12:33.055]                     invisible(future)
[16:12:33.055]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:33.055]                 }
[16:12:33.055]             }
[16:12:33.055]         }
[16:12:33.055]     })
[16:12:33.055]     if (TRUE) {
[16:12:33.055]         base::sink(type = "output", split = FALSE)
[16:12:33.055]         if (TRUE) {
[16:12:33.055]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:33.055]         }
[16:12:33.055]         else {
[16:12:33.055]             ...future.result["stdout"] <- base::list(NULL)
[16:12:33.055]         }
[16:12:33.055]         base::close(...future.stdout)
[16:12:33.055]         ...future.stdout <- NULL
[16:12:33.055]     }
[16:12:33.055]     ...future.result$conditions <- ...future.conditions
[16:12:33.055]     ...future.result$finished <- base::Sys.time()
[16:12:33.055]     ...future.result
[16:12:33.055] }
[16:12:33.056] assign_globals() ...
[16:12:33.057] List of 3
[16:12:33.057]  $ outer_function:function (x)  
[16:12:33.057]  $ map           :function (.x, .f, ...)  
[16:12:33.057]  $ inner_function:function (x)  
[16:12:33.057]  - attr(*, "where")=List of 3
[16:12:33.057]   ..$ outer_function:<environment: R_EmptyEnv> 
[16:12:33.057]   ..$ map           :<environment: R_EmptyEnv> 
[16:12:33.057]   ..$ inner_function:<environment: R_EmptyEnv> 
[16:12:33.057]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:33.057]  - attr(*, "resolved")= logi FALSE
[16:12:33.057]  - attr(*, "total_size")= num 7704
[16:12:33.057]  - attr(*, "already-done")= logi TRUE
[16:12:33.060] - reassign environment for ‘outer_function’
[16:12:33.060] - copied ‘outer_function’ to environment
[16:12:33.060] - reassign environment for ‘map’
[16:12:33.060] - copied ‘map’ to environment
[16:12:33.060] - reassign environment for ‘inner_function’
[16:12:33.060] - copied ‘inner_function’ to environment
[16:12:33.060] assign_globals() ... done
[16:12:33.060] plan(): Setting new future strategy stack:
[16:12:33.060] List of future strategies:
[16:12:33.060] 1. sequential:
[16:12:33.060]    - args: function (..., envir = parent.frame())
[16:12:33.060]    - tweaked: FALSE
[16:12:33.060]    - call: NULL
[16:12:33.061] plan(): nbrOfWorkers() = 1
[16:12:33.067] plan(): Setting new future strategy stack:
[16:12:33.067] List of future strategies:
[16:12:33.067] 1. sequential:
[16:12:33.067]    - args: function (..., envir = parent.frame())
[16:12:33.067]    - tweaked: FALSE
[16:12:33.067]    - call: plan(strategy)
[16:12:33.067] plan(): nbrOfWorkers() = 1
[16:12:33.067] SequentialFuture started (and completed)
[16:12:33.067] - Launch lazy future ... done
[16:12:33.067] run() for ‘SequentialFuture’ ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[16:12:33.069] getGlobalsAndPackages() ...
[16:12:33.069] Searching for globals...
[16:12:33.072] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[16:12:33.072] Searching for globals ... DONE
[16:12:33.073] Resolving globals: FALSE
[16:12:33.073] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[16:12:33.074] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[16:12:33.074] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[16:12:33.074] 
[16:12:33.074] getGlobalsAndPackages() ... DONE
[16:12:33.074] run() for ‘Future’ ...
[16:12:33.074] - state: ‘created’
[16:12:33.074] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:33.075] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:33.075] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:33.075]   - Field: ‘label’
[16:12:33.075]   - Field: ‘local’
[16:12:33.075]   - Field: ‘owner’
[16:12:33.075]   - Field: ‘envir’
[16:12:33.075]   - Field: ‘packages’
[16:12:33.075]   - Field: ‘gc’
[16:12:33.075]   - Field: ‘conditions’
[16:12:33.075]   - Field: ‘expr’
[16:12:33.075]   - Field: ‘uuid’
[16:12:33.075]   - Field: ‘seed’
[16:12:33.076]   - Field: ‘version’
[16:12:33.076]   - Field: ‘result’
[16:12:33.076]   - Field: ‘asynchronous’
[16:12:33.076]   - Field: ‘calls’
[16:12:33.076]   - Field: ‘globals’
[16:12:33.076]   - Field: ‘stdout’
[16:12:33.076]   - Field: ‘earlySignal’
[16:12:33.076]   - Field: ‘lazy’
[16:12:33.076]   - Field: ‘state’
[16:12:33.076] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:33.076] - Launch lazy future ...
[16:12:33.077] Packages needed by the future expression (n = 0): <none>
[16:12:33.077] Packages needed by future strategies (n = 0): <none>
[16:12:33.077] {
[16:12:33.077]     {
[16:12:33.077]         {
[16:12:33.077]             ...future.startTime <- base::Sys.time()
[16:12:33.077]             {
[16:12:33.077]                 {
[16:12:33.077]                   {
[16:12:33.077]                     base::local({
[16:12:33.077]                       has_future <- base::requireNamespace("future", 
[16:12:33.077]                         quietly = TRUE)
[16:12:33.077]                       if (has_future) {
[16:12:33.077]                         ns <- base::getNamespace("future")
[16:12:33.077]                         version <- ns[[".package"]][["version"]]
[16:12:33.077]                         if (is.null(version)) 
[16:12:33.077]                           version <- utils::packageVersion("future")
[16:12:33.077]                       }
[16:12:33.077]                       else {
[16:12:33.077]                         version <- NULL
[16:12:33.077]                       }
[16:12:33.077]                       if (!has_future || version < "1.8.0") {
[16:12:33.077]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:33.077]                           "", base::R.version$version.string), 
[16:12:33.077]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:33.077]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:33.077]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:33.077]                             "release", "version")], collapse = " "), 
[16:12:33.077]                           hostname = base::Sys.info()[["nodename"]])
[16:12:33.077]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:33.077]                           info)
[16:12:33.077]                         info <- base::paste(info, collapse = "; ")
[16:12:33.077]                         if (!has_future) {
[16:12:33.077]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:33.077]                             info)
[16:12:33.077]                         }
[16:12:33.077]                         else {
[16:12:33.077]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:33.077]                             info, version)
[16:12:33.077]                         }
[16:12:33.077]                         base::stop(msg)
[16:12:33.077]                       }
[16:12:33.077]                     })
[16:12:33.077]                   }
[16:12:33.077]                   options(future.plan = NULL)
[16:12:33.077]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:33.077]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:33.077]                 }
[16:12:33.077]                 ...future.workdir <- getwd()
[16:12:33.077]             }
[16:12:33.077]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:33.077]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:33.077]         }
[16:12:33.077]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:33.077]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:33.077]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:33.077]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:33.077]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:33.077]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:33.077]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:33.077]             base::names(...future.oldOptions))
[16:12:33.077]     }
[16:12:33.077]     if (FALSE) {
[16:12:33.077]     }
[16:12:33.077]     else {
[16:12:33.077]         if (TRUE) {
[16:12:33.077]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:33.077]                 open = "w")
[16:12:33.077]         }
[16:12:33.077]         else {
[16:12:33.077]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:33.077]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:33.077]         }
[16:12:33.077]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:33.077]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:33.077]             base::sink(type = "output", split = FALSE)
[16:12:33.077]             base::close(...future.stdout)
[16:12:33.077]         }, add = TRUE)
[16:12:33.077]     }
[16:12:33.077]     ...future.frame <- base::sys.nframe()
[16:12:33.077]     ...future.conditions <- base::list()
[16:12:33.077]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:33.077]     if (FALSE) {
[16:12:33.077]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:33.077]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:33.077]     }
[16:12:33.077]     ...future.result <- base::tryCatch({
[16:12:33.077]         base::withCallingHandlers({
[16:12:33.077]             ...future.value <- base::withVisible(base::local({
[16:12:33.077]                 outer_function(1L)
[16:12:33.077]             }))
[16:12:33.077]             future::FutureResult(value = ...future.value$value, 
[16:12:33.077]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:33.077]                   ...future.rng), globalenv = if (FALSE) 
[16:12:33.077]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:33.077]                     ...future.globalenv.names))
[16:12:33.077]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:33.077]         }, condition = base::local({
[16:12:33.077]             c <- base::c
[16:12:33.077]             inherits <- base::inherits
[16:12:33.077]             invokeRestart <- base::invokeRestart
[16:12:33.077]             length <- base::length
[16:12:33.077]             list <- base::list
[16:12:33.077]             seq.int <- base::seq.int
[16:12:33.077]             signalCondition <- base::signalCondition
[16:12:33.077]             sys.calls <- base::sys.calls
[16:12:33.077]             `[[` <- base::`[[`
[16:12:33.077]             `+` <- base::`+`
[16:12:33.077]             `<<-` <- base::`<<-`
[16:12:33.077]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:33.077]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:33.077]                   3L)]
[16:12:33.077]             }
[16:12:33.077]             function(cond) {
[16:12:33.077]                 is_error <- inherits(cond, "error")
[16:12:33.077]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:33.077]                   NULL)
[16:12:33.077]                 if (is_error) {
[16:12:33.077]                   sessionInformation <- function() {
[16:12:33.077]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:33.077]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:33.077]                       search = base::search(), system = base::Sys.info())
[16:12:33.077]                   }
[16:12:33.077]                   ...future.conditions[[length(...future.conditions) + 
[16:12:33.077]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:33.077]                     cond$call), session = sessionInformation(), 
[16:12:33.077]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:33.077]                   signalCondition(cond)
[16:12:33.077]                 }
[16:12:33.077]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:33.077]                 "immediateCondition"))) {
[16:12:33.077]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:33.077]                   ...future.conditions[[length(...future.conditions) + 
[16:12:33.077]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:33.077]                   if (TRUE && !signal) {
[16:12:33.077]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.077]                     {
[16:12:33.077]                       inherits <- base::inherits
[16:12:33.077]                       invokeRestart <- base::invokeRestart
[16:12:33.077]                       is.null <- base::is.null
[16:12:33.077]                       muffled <- FALSE
[16:12:33.077]                       if (inherits(cond, "message")) {
[16:12:33.077]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:33.077]                         if (muffled) 
[16:12:33.077]                           invokeRestart("muffleMessage")
[16:12:33.077]                       }
[16:12:33.077]                       else if (inherits(cond, "warning")) {
[16:12:33.077]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:33.077]                         if (muffled) 
[16:12:33.077]                           invokeRestart("muffleWarning")
[16:12:33.077]                       }
[16:12:33.077]                       else if (inherits(cond, "condition")) {
[16:12:33.077]                         if (!is.null(pattern)) {
[16:12:33.077]                           computeRestarts <- base::computeRestarts
[16:12:33.077]                           grepl <- base::grepl
[16:12:33.077]                           restarts <- computeRestarts(cond)
[16:12:33.077]                           for (restart in restarts) {
[16:12:33.077]                             name <- restart$name
[16:12:33.077]                             if (is.null(name)) 
[16:12:33.077]                               next
[16:12:33.077]                             if (!grepl(pattern, name)) 
[16:12:33.077]                               next
[16:12:33.077]                             invokeRestart(restart)
[16:12:33.077]                             muffled <- TRUE
[16:12:33.077]                             break
[16:12:33.077]                           }
[16:12:33.077]                         }
[16:12:33.077]                       }
[16:12:33.077]                       invisible(muffled)
[16:12:33.077]                     }
[16:12:33.077]                     muffleCondition(cond, pattern = "^muffle")
[16:12:33.077]                   }
[16:12:33.077]                 }
[16:12:33.077]                 else {
[16:12:33.077]                   if (TRUE) {
[16:12:33.077]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.077]                     {
[16:12:33.077]                       inherits <- base::inherits
[16:12:33.077]                       invokeRestart <- base::invokeRestart
[16:12:33.077]                       is.null <- base::is.null
[16:12:33.077]                       muffled <- FALSE
[16:12:33.077]                       if (inherits(cond, "message")) {
[16:12:33.077]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:33.077]                         if (muffled) 
[16:12:33.077]                           invokeRestart("muffleMessage")
[16:12:33.077]                       }
[16:12:33.077]                       else if (inherits(cond, "warning")) {
[16:12:33.077]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:33.077]                         if (muffled) 
[16:12:33.077]                           invokeRestart("muffleWarning")
[16:12:33.077]                       }
[16:12:33.077]                       else if (inherits(cond, "condition")) {
[16:12:33.077]                         if (!is.null(pattern)) {
[16:12:33.077]                           computeRestarts <- base::computeRestarts
[16:12:33.077]                           grepl <- base::grepl
[16:12:33.077]                           restarts <- computeRestarts(cond)
[16:12:33.077]                           for (restart in restarts) {
[16:12:33.077]                             name <- restart$name
[16:12:33.077]                             if (is.null(name)) 
[16:12:33.077]                               next
[16:12:33.077]                             if (!grepl(pattern, name)) 
[16:12:33.077]                               next
[16:12:33.077]                             invokeRestart(restart)
[16:12:33.077]                             muffled <- TRUE
[16:12:33.077]                             break
[16:12:33.077]                           }
[16:12:33.077]                         }
[16:12:33.077]                       }
[16:12:33.077]                       invisible(muffled)
[16:12:33.077]                     }
[16:12:33.077]                     muffleCondition(cond, pattern = "^muffle")
[16:12:33.077]                   }
[16:12:33.077]                 }
[16:12:33.077]             }
[16:12:33.077]         }))
[16:12:33.077]     }, error = function(ex) {
[16:12:33.077]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:33.077]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:33.077]                 ...future.rng), started = ...future.startTime, 
[16:12:33.077]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:33.077]             version = "1.8"), class = "FutureResult")
[16:12:33.077]     }, finally = {
[16:12:33.077]         if (!identical(...future.workdir, getwd())) 
[16:12:33.077]             setwd(...future.workdir)
[16:12:33.077]         {
[16:12:33.077]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:33.077]                 ...future.oldOptions$nwarnings <- NULL
[16:12:33.077]             }
[16:12:33.077]             base::options(...future.oldOptions)
[16:12:33.077]             if (.Platform$OS.type == "windows") {
[16:12:33.077]                 old_names <- names(...future.oldEnvVars)
[16:12:33.077]                 envs <- base::Sys.getenv()
[16:12:33.077]                 names <- names(envs)
[16:12:33.077]                 common <- intersect(names, old_names)
[16:12:33.077]                 added <- setdiff(names, old_names)
[16:12:33.077]                 removed <- setdiff(old_names, names)
[16:12:33.077]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:33.077]                   envs[common]]
[16:12:33.077]                 NAMES <- toupper(changed)
[16:12:33.077]                 args <- list()
[16:12:33.077]                 for (kk in seq_along(NAMES)) {
[16:12:33.077]                   name <- changed[[kk]]
[16:12:33.077]                   NAME <- NAMES[[kk]]
[16:12:33.077]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.077]                     next
[16:12:33.077]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:33.077]                 }
[16:12:33.077]                 NAMES <- toupper(added)
[16:12:33.077]                 for (kk in seq_along(NAMES)) {
[16:12:33.077]                   name <- added[[kk]]
[16:12:33.077]                   NAME <- NAMES[[kk]]
[16:12:33.077]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.077]                     next
[16:12:33.077]                   args[[name]] <- ""
[16:12:33.077]                 }
[16:12:33.077]                 NAMES <- toupper(removed)
[16:12:33.077]                 for (kk in seq_along(NAMES)) {
[16:12:33.077]                   name <- removed[[kk]]
[16:12:33.077]                   NAME <- NAMES[[kk]]
[16:12:33.077]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.077]                     next
[16:12:33.077]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:33.077]                 }
[16:12:33.077]                 if (length(args) > 0) 
[16:12:33.077]                   base::do.call(base::Sys.setenv, args = args)
[16:12:33.077]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:33.077]             }
[16:12:33.077]             else {
[16:12:33.077]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:33.077]             }
[16:12:33.077]             {
[16:12:33.077]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:33.077]                   0L) {
[16:12:33.077]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:33.077]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:33.077]                   base::options(opts)
[16:12:33.077]                 }
[16:12:33.077]                 {
[16:12:33.077]                   {
[16:12:33.077]                     NULL
[16:12:33.077]                     RNGkind("Mersenne-Twister")
[16:12:33.077]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:33.077]                       inherits = FALSE)
[16:12:33.077]                   }
[16:12:33.077]                   options(future.plan = NULL)
[16:12:33.077]                   if (is.na(NA_character_)) 
[16:12:33.077]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:33.077]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:33.077]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:33.077]                   {
[16:12:33.077]                     future <- SequentialFuture(..., envir = envir)
[16:12:33.077]                     if (!future$lazy) 
[16:12:33.077]                       future <- run(future)
[16:12:33.077]                     invisible(future)
[16:12:33.077]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:33.077]                 }
[16:12:33.077]             }
[16:12:33.077]         }
[16:12:33.077]     })
[16:12:33.077]     if (TRUE) {
[16:12:33.077]         base::sink(type = "output", split = FALSE)
[16:12:33.077]         if (TRUE) {
[16:12:33.077]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:33.077]         }
[16:12:33.077]         else {
[16:12:33.077]             ...future.result["stdout"] <- base::list(NULL)
[16:12:33.077]         }
[16:12:33.077]         base::close(...future.stdout)
[16:12:33.077]         ...future.stdout <- NULL
[16:12:33.077]     }
[16:12:33.077]     ...future.result$conditions <- ...future.conditions
[16:12:33.077]     ...future.result$finished <- base::Sys.time()
[16:12:33.077]     ...future.result
[16:12:33.077] }
[16:12:33.079] assign_globals() ...
[16:12:33.079] List of 3
[16:12:33.079]  $ outer_function:function (x)  
[16:12:33.079]  $ map           :function (.x, .f, ...)  
[16:12:33.079]  $ inner_function:function (x)  
[16:12:33.079]  - attr(*, "where")=List of 3
[16:12:33.079]   ..$ outer_function:<environment: R_EmptyEnv> 
[16:12:33.079]   ..$ map           :<environment: R_EmptyEnv> 
[16:12:33.079]   ..$ inner_function:<environment: R_EmptyEnv> 
[16:12:33.079]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:33.079]  - attr(*, "resolved")= logi FALSE
[16:12:33.079]  - attr(*, "total_size")= num 7704
[16:12:33.079]  - attr(*, "already-done")= logi TRUE
[16:12:33.082] - reassign environment for ‘outer_function’
[16:12:33.082] - copied ‘outer_function’ to environment
[16:12:33.082] - reassign environment for ‘map’
[16:12:33.083] - copied ‘map’ to environment
[16:12:33.083] - reassign environment for ‘inner_function’
[16:12:33.083] - copied ‘inner_function’ to environment
[16:12:33.083] assign_globals() ... done
[16:12:33.083] plan(): Setting new future strategy stack:
[16:12:33.084] List of future strategies:
[16:12:33.084] 1. sequential:
[16:12:33.084]    - args: function (..., envir = parent.frame())
[16:12:33.084]    - tweaked: FALSE
[16:12:33.084]    - call: NULL
[16:12:33.084] plan(): nbrOfWorkers() = 1
[16:12:33.085] plan(): Setting new future strategy stack:
[16:12:33.085] List of future strategies:
[16:12:33.085] 1. sequential:
[16:12:33.085]    - args: function (..., envir = parent.frame())
[16:12:33.085]    - tweaked: FALSE
[16:12:33.085]    - call: plan(strategy)
[16:12:33.085] plan(): nbrOfWorkers() = 1
[16:12:33.085] SequentialFuture started (and completed)
[16:12:33.085] - Launch lazy future ... done
[16:12:33.086] run() for ‘SequentialFuture’ ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- plan('multicore') ...
[16:12:33.095] plan(): Setting new future strategy stack:
[16:12:33.095] List of future strategies:
[16:12:33.095] 1. multicore:
[16:12:33.095]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:33.095]    - tweaked: FALSE
[16:12:33.095]    - call: plan(strategy)
[16:12:33.099] plan(): nbrOfWorkers() = 2
- lm(<formula>) ...
[16:12:33.099] getGlobalsAndPackages() ...
[16:12:33.099] Searching for globals...
[16:12:33.100] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:12:33.100] Searching for globals ... DONE
[16:12:33.101] Resolving globals: FALSE
[16:12:33.101] The total size of the 2 globals is 896 bytes (896 bytes)
[16:12:33.101] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:12:33.101] - globals: [2] ‘weight’, ‘group’
[16:12:33.102] - packages: [1] ‘stats’
[16:12:33.102] getGlobalsAndPackages() ... DONE
[16:12:33.102] run() for ‘Future’ ...
[16:12:33.102] - state: ‘created’
[16:12:33.102] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:33.105] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:33.106] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:33.106]   - Field: ‘label’
[16:12:33.106]   - Field: ‘local’
[16:12:33.106]   - Field: ‘owner’
[16:12:33.106]   - Field: ‘envir’
[16:12:33.106]   - Field: ‘workers’
[16:12:33.106]   - Field: ‘packages’
[16:12:33.106]   - Field: ‘gc’
[16:12:33.106]   - Field: ‘job’
[16:12:33.106]   - Field: ‘conditions’
[16:12:33.106]   - Field: ‘expr’
[16:12:33.107]   - Field: ‘uuid’
[16:12:33.107]   - Field: ‘seed’
[16:12:33.107]   - Field: ‘version’
[16:12:33.107]   - Field: ‘result’
[16:12:33.107]   - Field: ‘asynchronous’
[16:12:33.107]   - Field: ‘calls’
[16:12:33.107]   - Field: ‘globals’
[16:12:33.107]   - Field: ‘stdout’
[16:12:33.107]   - Field: ‘earlySignal’
[16:12:33.107]   - Field: ‘lazy’
[16:12:33.109]   - Field: ‘state’
[16:12:33.109] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:33.109] - Launch lazy future ...
[16:12:33.110] Packages needed by the future expression (n = 1): ‘stats’
[16:12:33.110] Packages needed by future strategies (n = 0): <none>
[16:12:33.110] {
[16:12:33.110]     {
[16:12:33.110]         {
[16:12:33.110]             ...future.startTime <- base::Sys.time()
[16:12:33.110]             {
[16:12:33.110]                 {
[16:12:33.110]                   {
[16:12:33.110]                     {
[16:12:33.110]                       {
[16:12:33.110]                         base::local({
[16:12:33.110]                           has_future <- base::requireNamespace("future", 
[16:12:33.110]                             quietly = TRUE)
[16:12:33.110]                           if (has_future) {
[16:12:33.110]                             ns <- base::getNamespace("future")
[16:12:33.110]                             version <- ns[[".package"]][["version"]]
[16:12:33.110]                             if (is.null(version)) 
[16:12:33.110]                               version <- utils::packageVersion("future")
[16:12:33.110]                           }
[16:12:33.110]                           else {
[16:12:33.110]                             version <- NULL
[16:12:33.110]                           }
[16:12:33.110]                           if (!has_future || version < "1.8.0") {
[16:12:33.110]                             info <- base::c(r_version = base::gsub("R version ", 
[16:12:33.110]                               "", base::R.version$version.string), 
[16:12:33.110]                               platform = base::sprintf("%s (%s-bit)", 
[16:12:33.110]                                 base::R.version$platform, 8 * 
[16:12:33.110]                                   base::.Machine$sizeof.pointer), 
[16:12:33.110]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:33.110]                                 "release", "version")], collapse = " "), 
[16:12:33.110]                               hostname = base::Sys.info()[["nodename"]])
[16:12:33.110]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:12:33.110]                               info)
[16:12:33.110]                             info <- base::paste(info, collapse = "; ")
[16:12:33.110]                             if (!has_future) {
[16:12:33.110]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:33.110]                                 info)
[16:12:33.110]                             }
[16:12:33.110]                             else {
[16:12:33.110]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:33.110]                                 info, version)
[16:12:33.110]                             }
[16:12:33.110]                             base::stop(msg)
[16:12:33.110]                           }
[16:12:33.110]                         })
[16:12:33.110]                       }
[16:12:33.110]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:33.110]                       base::options(mc.cores = 1L)
[16:12:33.110]                     }
[16:12:33.110]                     base::local({
[16:12:33.110]                       for (pkg in "stats") {
[16:12:33.110]                         base::loadNamespace(pkg)
[16:12:33.110]                         base::library(pkg, character.only = TRUE)
[16:12:33.110]                       }
[16:12:33.110]                     })
[16:12:33.110]                   }
[16:12:33.110]                   options(future.plan = NULL)
[16:12:33.110]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:33.110]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:33.110]                 }
[16:12:33.110]                 ...future.workdir <- getwd()
[16:12:33.110]             }
[16:12:33.110]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:33.110]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:33.110]         }
[16:12:33.110]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:33.110]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:33.110]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:33.110]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:33.110]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:33.110]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:33.110]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:33.110]             base::names(...future.oldOptions))
[16:12:33.110]     }
[16:12:33.110]     if (FALSE) {
[16:12:33.110]     }
[16:12:33.110]     else {
[16:12:33.110]         if (TRUE) {
[16:12:33.110]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:33.110]                 open = "w")
[16:12:33.110]         }
[16:12:33.110]         else {
[16:12:33.110]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:33.110]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:33.110]         }
[16:12:33.110]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:33.110]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:33.110]             base::sink(type = "output", split = FALSE)
[16:12:33.110]             base::close(...future.stdout)
[16:12:33.110]         }, add = TRUE)
[16:12:33.110]     }
[16:12:33.110]     ...future.frame <- base::sys.nframe()
[16:12:33.110]     ...future.conditions <- base::list()
[16:12:33.110]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:33.110]     if (FALSE) {
[16:12:33.110]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:33.110]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:33.110]     }
[16:12:33.110]     ...future.result <- base::tryCatch({
[16:12:33.110]         base::withCallingHandlers({
[16:12:33.110]             ...future.value <- base::withVisible(base::local({
[16:12:33.110]                 withCallingHandlers({
[16:12:33.110]                   {
[16:12:33.110]                     lm(weight ~ group - 1)
[16:12:33.110]                   }
[16:12:33.110]                 }, immediateCondition = function(cond) {
[16:12:33.110]                   save_rds <- function (object, pathname, ...) 
[16:12:33.110]                   {
[16:12:33.110]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:33.110]                     if (file_test("-f", pathname_tmp)) {
[16:12:33.110]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.110]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:33.110]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.110]                         fi_tmp[["mtime"]])
[16:12:33.110]                     }
[16:12:33.110]                     tryCatch({
[16:12:33.110]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:33.110]                     }, error = function(ex) {
[16:12:33.110]                       msg <- conditionMessage(ex)
[16:12:33.110]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.110]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:33.110]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.110]                         fi_tmp[["mtime"]], msg)
[16:12:33.110]                       ex$message <- msg
[16:12:33.110]                       stop(ex)
[16:12:33.110]                     })
[16:12:33.110]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:33.110]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:33.110]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:33.110]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.110]                       fi <- file.info(pathname)
[16:12:33.110]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:33.110]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.110]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:33.110]                         fi[["size"]], fi[["mtime"]])
[16:12:33.110]                       stop(msg)
[16:12:33.110]                     }
[16:12:33.110]                     invisible(pathname)
[16:12:33.110]                   }
[16:12:33.110]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:33.110]                     rootPath = tempdir()) 
[16:12:33.110]                   {
[16:12:33.110]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:33.110]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:33.110]                       tmpdir = path, fileext = ".rds")
[16:12:33.110]                     save_rds(obj, file)
[16:12:33.110]                   }
[16:12:33.110]                   saveImmediateCondition(cond, path = "/tmp/RtmpjVCO6F/.future/immediateConditions")
[16:12:33.110]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.110]                   {
[16:12:33.110]                     inherits <- base::inherits
[16:12:33.110]                     invokeRestart <- base::invokeRestart
[16:12:33.110]                     is.null <- base::is.null
[16:12:33.110]                     muffled <- FALSE
[16:12:33.110]                     if (inherits(cond, "message")) {
[16:12:33.110]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:33.110]                       if (muffled) 
[16:12:33.110]                         invokeRestart("muffleMessage")
[16:12:33.110]                     }
[16:12:33.110]                     else if (inherits(cond, "warning")) {
[16:12:33.110]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:33.110]                       if (muffled) 
[16:12:33.110]                         invokeRestart("muffleWarning")
[16:12:33.110]                     }
[16:12:33.110]                     else if (inherits(cond, "condition")) {
[16:12:33.110]                       if (!is.null(pattern)) {
[16:12:33.110]                         computeRestarts <- base::computeRestarts
[16:12:33.110]                         grepl <- base::grepl
[16:12:33.110]                         restarts <- computeRestarts(cond)
[16:12:33.110]                         for (restart in restarts) {
[16:12:33.110]                           name <- restart$name
[16:12:33.110]                           if (is.null(name)) 
[16:12:33.110]                             next
[16:12:33.110]                           if (!grepl(pattern, name)) 
[16:12:33.110]                             next
[16:12:33.110]                           invokeRestart(restart)
[16:12:33.110]                           muffled <- TRUE
[16:12:33.110]                           break
[16:12:33.110]                         }
[16:12:33.110]                       }
[16:12:33.110]                     }
[16:12:33.110]                     invisible(muffled)
[16:12:33.110]                   }
[16:12:33.110]                   muffleCondition(cond)
[16:12:33.110]                 })
[16:12:33.110]             }))
[16:12:33.110]             future::FutureResult(value = ...future.value$value, 
[16:12:33.110]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:33.110]                   ...future.rng), globalenv = if (FALSE) 
[16:12:33.110]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:33.110]                     ...future.globalenv.names))
[16:12:33.110]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:33.110]         }, condition = base::local({
[16:12:33.110]             c <- base::c
[16:12:33.110]             inherits <- base::inherits
[16:12:33.110]             invokeRestart <- base::invokeRestart
[16:12:33.110]             length <- base::length
[16:12:33.110]             list <- base::list
[16:12:33.110]             seq.int <- base::seq.int
[16:12:33.110]             signalCondition <- base::signalCondition
[16:12:33.110]             sys.calls <- base::sys.calls
[16:12:33.110]             `[[` <- base::`[[`
[16:12:33.110]             `+` <- base::`+`
[16:12:33.110]             `<<-` <- base::`<<-`
[16:12:33.110]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:33.110]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:33.110]                   3L)]
[16:12:33.110]             }
[16:12:33.110]             function(cond) {
[16:12:33.110]                 is_error <- inherits(cond, "error")
[16:12:33.110]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:33.110]                   NULL)
[16:12:33.110]                 if (is_error) {
[16:12:33.110]                   sessionInformation <- function() {
[16:12:33.110]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:33.110]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:33.110]                       search = base::search(), system = base::Sys.info())
[16:12:33.110]                   }
[16:12:33.110]                   ...future.conditions[[length(...future.conditions) + 
[16:12:33.110]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:33.110]                     cond$call), session = sessionInformation(), 
[16:12:33.110]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:33.110]                   signalCondition(cond)
[16:12:33.110]                 }
[16:12:33.110]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:33.110]                 "immediateCondition"))) {
[16:12:33.110]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:33.110]                   ...future.conditions[[length(...future.conditions) + 
[16:12:33.110]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:33.110]                   if (TRUE && !signal) {
[16:12:33.110]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.110]                     {
[16:12:33.110]                       inherits <- base::inherits
[16:12:33.110]                       invokeRestart <- base::invokeRestart
[16:12:33.110]                       is.null <- base::is.null
[16:12:33.110]                       muffled <- FALSE
[16:12:33.110]                       if (inherits(cond, "message")) {
[16:12:33.110]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:33.110]                         if (muffled) 
[16:12:33.110]                           invokeRestart("muffleMessage")
[16:12:33.110]                       }
[16:12:33.110]                       else if (inherits(cond, "warning")) {
[16:12:33.110]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:33.110]                         if (muffled) 
[16:12:33.110]                           invokeRestart("muffleWarning")
[16:12:33.110]                       }
[16:12:33.110]                       else if (inherits(cond, "condition")) {
[16:12:33.110]                         if (!is.null(pattern)) {
[16:12:33.110]                           computeRestarts <- base::computeRestarts
[16:12:33.110]                           grepl <- base::grepl
[16:12:33.110]                           restarts <- computeRestarts(cond)
[16:12:33.110]                           for (restart in restarts) {
[16:12:33.110]                             name <- restart$name
[16:12:33.110]                             if (is.null(name)) 
[16:12:33.110]                               next
[16:12:33.110]                             if (!grepl(pattern, name)) 
[16:12:33.110]                               next
[16:12:33.110]                             invokeRestart(restart)
[16:12:33.110]                             muffled <- TRUE
[16:12:33.110]                             break
[16:12:33.110]                           }
[16:12:33.110]                         }
[16:12:33.110]                       }
[16:12:33.110]                       invisible(muffled)
[16:12:33.110]                     }
[16:12:33.110]                     muffleCondition(cond, pattern = "^muffle")
[16:12:33.110]                   }
[16:12:33.110]                 }
[16:12:33.110]                 else {
[16:12:33.110]                   if (TRUE) {
[16:12:33.110]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.110]                     {
[16:12:33.110]                       inherits <- base::inherits
[16:12:33.110]                       invokeRestart <- base::invokeRestart
[16:12:33.110]                       is.null <- base::is.null
[16:12:33.110]                       muffled <- FALSE
[16:12:33.110]                       if (inherits(cond, "message")) {
[16:12:33.110]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:33.110]                         if (muffled) 
[16:12:33.110]                           invokeRestart("muffleMessage")
[16:12:33.110]                       }
[16:12:33.110]                       else if (inherits(cond, "warning")) {
[16:12:33.110]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:33.110]                         if (muffled) 
[16:12:33.110]                           invokeRestart("muffleWarning")
[16:12:33.110]                       }
[16:12:33.110]                       else if (inherits(cond, "condition")) {
[16:12:33.110]                         if (!is.null(pattern)) {
[16:12:33.110]                           computeRestarts <- base::computeRestarts
[16:12:33.110]                           grepl <- base::grepl
[16:12:33.110]                           restarts <- computeRestarts(cond)
[16:12:33.110]                           for (restart in restarts) {
[16:12:33.110]                             name <- restart$name
[16:12:33.110]                             if (is.null(name)) 
[16:12:33.110]                               next
[16:12:33.110]                             if (!grepl(pattern, name)) 
[16:12:33.110]                               next
[16:12:33.110]                             invokeRestart(restart)
[16:12:33.110]                             muffled <- TRUE
[16:12:33.110]                             break
[16:12:33.110]                           }
[16:12:33.110]                         }
[16:12:33.110]                       }
[16:12:33.110]                       invisible(muffled)
[16:12:33.110]                     }
[16:12:33.110]                     muffleCondition(cond, pattern = "^muffle")
[16:12:33.110]                   }
[16:12:33.110]                 }
[16:12:33.110]             }
[16:12:33.110]         }))
[16:12:33.110]     }, error = function(ex) {
[16:12:33.110]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:33.110]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:33.110]                 ...future.rng), started = ...future.startTime, 
[16:12:33.110]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:33.110]             version = "1.8"), class = "FutureResult")
[16:12:33.110]     }, finally = {
[16:12:33.110]         if (!identical(...future.workdir, getwd())) 
[16:12:33.110]             setwd(...future.workdir)
[16:12:33.110]         {
[16:12:33.110]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:33.110]                 ...future.oldOptions$nwarnings <- NULL
[16:12:33.110]             }
[16:12:33.110]             base::options(...future.oldOptions)
[16:12:33.110]             if (.Platform$OS.type == "windows") {
[16:12:33.110]                 old_names <- names(...future.oldEnvVars)
[16:12:33.110]                 envs <- base::Sys.getenv()
[16:12:33.110]                 names <- names(envs)
[16:12:33.110]                 common <- intersect(names, old_names)
[16:12:33.110]                 added <- setdiff(names, old_names)
[16:12:33.110]                 removed <- setdiff(old_names, names)
[16:12:33.110]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:33.110]                   envs[common]]
[16:12:33.110]                 NAMES <- toupper(changed)
[16:12:33.110]                 args <- list()
[16:12:33.110]                 for (kk in seq_along(NAMES)) {
[16:12:33.110]                   name <- changed[[kk]]
[16:12:33.110]                   NAME <- NAMES[[kk]]
[16:12:33.110]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.110]                     next
[16:12:33.110]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:33.110]                 }
[16:12:33.110]                 NAMES <- toupper(added)
[16:12:33.110]                 for (kk in seq_along(NAMES)) {
[16:12:33.110]                   name <- added[[kk]]
[16:12:33.110]                   NAME <- NAMES[[kk]]
[16:12:33.110]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.110]                     next
[16:12:33.110]                   args[[name]] <- ""
[16:12:33.110]                 }
[16:12:33.110]                 NAMES <- toupper(removed)
[16:12:33.110]                 for (kk in seq_along(NAMES)) {
[16:12:33.110]                   name <- removed[[kk]]
[16:12:33.110]                   NAME <- NAMES[[kk]]
[16:12:33.110]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.110]                     next
[16:12:33.110]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:33.110]                 }
[16:12:33.110]                 if (length(args) > 0) 
[16:12:33.110]                   base::do.call(base::Sys.setenv, args = args)
[16:12:33.110]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:33.110]             }
[16:12:33.110]             else {
[16:12:33.110]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:33.110]             }
[16:12:33.110]             {
[16:12:33.110]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:33.110]                   0L) {
[16:12:33.110]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:33.110]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:33.110]                   base::options(opts)
[16:12:33.110]                 }
[16:12:33.110]                 {
[16:12:33.110]                   {
[16:12:33.110]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:33.110]                     NULL
[16:12:33.110]                   }
[16:12:33.110]                   options(future.plan = NULL)
[16:12:33.110]                   if (is.na(NA_character_)) 
[16:12:33.110]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:33.110]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:33.110]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:33.110]                     envir = parent.frame()) 
[16:12:33.110]                   {
[16:12:33.110]                     default_workers <- missing(workers)
[16:12:33.110]                     if (is.function(workers)) 
[16:12:33.110]                       workers <- workers()
[16:12:33.110]                     workers <- structure(as.integer(workers), 
[16:12:33.110]                       class = class(workers))
[16:12:33.110]                     stop_if_not(is.finite(workers), workers >= 
[16:12:33.110]                       1L)
[16:12:33.110]                     if ((workers == 1L && !inherits(workers, 
[16:12:33.110]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:33.110]                       if (default_workers) 
[16:12:33.110]                         supportsMulticore(warn = TRUE)
[16:12:33.110]                       return(sequential(..., envir = envir))
[16:12:33.110]                     }
[16:12:33.110]                     oopts <- options(mc.cores = workers)
[16:12:33.110]                     on.exit(options(oopts))
[16:12:33.110]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:33.110]                       envir = envir)
[16:12:33.110]                     if (!future$lazy) 
[16:12:33.110]                       future <- run(future)
[16:12:33.110]                     invisible(future)
[16:12:33.110]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:33.110]                 }
[16:12:33.110]             }
[16:12:33.110]         }
[16:12:33.110]     })
[16:12:33.110]     if (TRUE) {
[16:12:33.110]         base::sink(type = "output", split = FALSE)
[16:12:33.110]         if (TRUE) {
[16:12:33.110]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:33.110]         }
[16:12:33.110]         else {
[16:12:33.110]             ...future.result["stdout"] <- base::list(NULL)
[16:12:33.110]         }
[16:12:33.110]         base::close(...future.stdout)
[16:12:33.110]         ...future.stdout <- NULL
[16:12:33.110]     }
[16:12:33.110]     ...future.result$conditions <- ...future.conditions
[16:12:33.110]     ...future.result$finished <- base::Sys.time()
[16:12:33.110]     ...future.result
[16:12:33.110] }
[16:12:33.113] assign_globals() ...
[16:12:33.113] List of 2
[16:12:33.113]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[16:12:33.113]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[16:12:33.113]  - attr(*, "where")=List of 2
[16:12:33.113]   ..$ weight:<environment: R_EmptyEnv> 
[16:12:33.113]   ..$ group :<environment: R_EmptyEnv> 
[16:12:33.113]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:33.113]  - attr(*, "resolved")= logi FALSE
[16:12:33.113]  - attr(*, "total_size")= num 896
[16:12:33.113]  - attr(*, "already-done")= logi TRUE
[16:12:33.116] - copied ‘weight’ to environment
[16:12:33.116] - copied ‘group’ to environment
[16:12:33.116] assign_globals() ... done
[16:12:33.116] requestCore(): workers = 2
[16:12:33.119] MulticoreFuture started
[16:12:33.119] - Launch lazy future ... done
[16:12:33.119] run() for ‘MulticoreFuture’ ... done
[16:12:33.120] plan(): Setting new future strategy stack:
[16:12:33.120] List of future strategies:
[16:12:33.120] 1. sequential:
[16:12:33.120]    - args: function (..., envir = parent.frame())
[16:12:33.120]    - tweaked: FALSE
[16:12:33.120]    - call: NULL
[16:12:33.121] plan(): nbrOfWorkers() = 1
[16:12:33.124] plan(): Setting new future strategy stack:
[16:12:33.124] List of future strategies:
[16:12:33.124] 1. multicore:
[16:12:33.124]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:33.124]    - tweaked: FALSE
[16:12:33.124]    - call: plan(strategy)
[16:12:33.129] plan(): nbrOfWorkers() = 2

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[16:12:33.137] getGlobalsAndPackages() ...
[16:12:33.137] Searching for globals...
[16:12:33.139] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:12:33.139] Searching for globals ... DONE
[16:12:33.140] Resolving globals: FALSE
[16:12:33.140] The total size of the 2 globals is 896 bytes (896 bytes)
[16:12:33.141] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:12:33.141] - globals: [2] ‘weight’, ‘group’
[16:12:33.141] - packages: [1] ‘stats’
[16:12:33.141] getGlobalsAndPackages() ... DONE
[16:12:33.141] run() for ‘Future’ ...
[16:12:33.142] - state: ‘created’
[16:12:33.142] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:33.146] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:33.146] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:33.146]   - Field: ‘label’
[16:12:33.146]   - Field: ‘local’
[16:12:33.146]   - Field: ‘owner’
[16:12:33.146]   - Field: ‘envir’
[16:12:33.146]   - Field: ‘workers’
[16:12:33.146]   - Field: ‘packages’
[16:12:33.147]   - Field: ‘gc’
[16:12:33.147]   - Field: ‘job’
[16:12:33.147]   - Field: ‘conditions’
[16:12:33.147]   - Field: ‘expr’
[16:12:33.147]   - Field: ‘uuid’
[16:12:33.147]   - Field: ‘seed’
[16:12:33.147]   - Field: ‘version’
[16:12:33.147]   - Field: ‘result’
[16:12:33.147]   - Field: ‘asynchronous’
[16:12:33.148]   - Field: ‘calls’
[16:12:33.148]   - Field: ‘globals’
[16:12:33.148]   - Field: ‘stdout’
[16:12:33.148]   - Field: ‘earlySignal’
[16:12:33.148]   - Field: ‘lazy’
[16:12:33.148]   - Field: ‘state’
[16:12:33.148] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:33.148] - Launch lazy future ...
[16:12:33.149] Packages needed by the future expression (n = 1): ‘stats’
[16:12:33.149] Packages needed by future strategies (n = 0): <none>
[16:12:33.149] {
[16:12:33.149]     {
[16:12:33.149]         {
[16:12:33.149]             ...future.startTime <- base::Sys.time()
[16:12:33.149]             {
[16:12:33.149]                 {
[16:12:33.149]                   {
[16:12:33.149]                     {
[16:12:33.149]                       {
[16:12:33.149]                         base::local({
[16:12:33.149]                           has_future <- base::requireNamespace("future", 
[16:12:33.149]                             quietly = TRUE)
[16:12:33.149]                           if (has_future) {
[16:12:33.149]                             ns <- base::getNamespace("future")
[16:12:33.149]                             version <- ns[[".package"]][["version"]]
[16:12:33.149]                             if (is.null(version)) 
[16:12:33.149]                               version <- utils::packageVersion("future")
[16:12:33.149]                           }
[16:12:33.149]                           else {
[16:12:33.149]                             version <- NULL
[16:12:33.149]                           }
[16:12:33.149]                           if (!has_future || version < "1.8.0") {
[16:12:33.149]                             info <- base::c(r_version = base::gsub("R version ", 
[16:12:33.149]                               "", base::R.version$version.string), 
[16:12:33.149]                               platform = base::sprintf("%s (%s-bit)", 
[16:12:33.149]                                 base::R.version$platform, 8 * 
[16:12:33.149]                                   base::.Machine$sizeof.pointer), 
[16:12:33.149]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:33.149]                                 "release", "version")], collapse = " "), 
[16:12:33.149]                               hostname = base::Sys.info()[["nodename"]])
[16:12:33.149]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:12:33.149]                               info)
[16:12:33.149]                             info <- base::paste(info, collapse = "; ")
[16:12:33.149]                             if (!has_future) {
[16:12:33.149]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:33.149]                                 info)
[16:12:33.149]                             }
[16:12:33.149]                             else {
[16:12:33.149]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:33.149]                                 info, version)
[16:12:33.149]                             }
[16:12:33.149]                             base::stop(msg)
[16:12:33.149]                           }
[16:12:33.149]                         })
[16:12:33.149]                       }
[16:12:33.149]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:33.149]                       base::options(mc.cores = 1L)
[16:12:33.149]                     }
[16:12:33.149]                     base::local({
[16:12:33.149]                       for (pkg in "stats") {
[16:12:33.149]                         base::loadNamespace(pkg)
[16:12:33.149]                         base::library(pkg, character.only = TRUE)
[16:12:33.149]                       }
[16:12:33.149]                     })
[16:12:33.149]                   }
[16:12:33.149]                   options(future.plan = NULL)
[16:12:33.149]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:33.149]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:33.149]                 }
[16:12:33.149]                 ...future.workdir <- getwd()
[16:12:33.149]             }
[16:12:33.149]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:33.149]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:33.149]         }
[16:12:33.149]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:33.149]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:33.149]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:33.149]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:33.149]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:33.149]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:33.149]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:33.149]             base::names(...future.oldOptions))
[16:12:33.149]     }
[16:12:33.149]     if (FALSE) {
[16:12:33.149]     }
[16:12:33.149]     else {
[16:12:33.149]         if (TRUE) {
[16:12:33.149]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:33.149]                 open = "w")
[16:12:33.149]         }
[16:12:33.149]         else {
[16:12:33.149]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:33.149]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:33.149]         }
[16:12:33.149]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:33.149]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:33.149]             base::sink(type = "output", split = FALSE)
[16:12:33.149]             base::close(...future.stdout)
[16:12:33.149]         }, add = TRUE)
[16:12:33.149]     }
[16:12:33.149]     ...future.frame <- base::sys.nframe()
[16:12:33.149]     ...future.conditions <- base::list()
[16:12:33.149]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:33.149]     if (FALSE) {
[16:12:33.149]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:33.149]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:33.149]     }
[16:12:33.149]     ...future.result <- base::tryCatch({
[16:12:33.149]         base::withCallingHandlers({
[16:12:33.149]             ...future.value <- base::withVisible(base::local({
[16:12:33.149]                 withCallingHandlers({
[16:12:33.149]                   {
[16:12:33.149]                     lm(weight ~ group - 1)
[16:12:33.149]                   }
[16:12:33.149]                 }, immediateCondition = function(cond) {
[16:12:33.149]                   save_rds <- function (object, pathname, ...) 
[16:12:33.149]                   {
[16:12:33.149]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:33.149]                     if (file_test("-f", pathname_tmp)) {
[16:12:33.149]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.149]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:33.149]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.149]                         fi_tmp[["mtime"]])
[16:12:33.149]                     }
[16:12:33.149]                     tryCatch({
[16:12:33.149]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:33.149]                     }, error = function(ex) {
[16:12:33.149]                       msg <- conditionMessage(ex)
[16:12:33.149]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.149]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:33.149]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.149]                         fi_tmp[["mtime"]], msg)
[16:12:33.149]                       ex$message <- msg
[16:12:33.149]                       stop(ex)
[16:12:33.149]                     })
[16:12:33.149]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:33.149]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:33.149]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:33.149]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.149]                       fi <- file.info(pathname)
[16:12:33.149]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:33.149]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.149]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:33.149]                         fi[["size"]], fi[["mtime"]])
[16:12:33.149]                       stop(msg)
[16:12:33.149]                     }
[16:12:33.149]                     invisible(pathname)
[16:12:33.149]                   }
[16:12:33.149]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:33.149]                     rootPath = tempdir()) 
[16:12:33.149]                   {
[16:12:33.149]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:33.149]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:33.149]                       tmpdir = path, fileext = ".rds")
[16:12:33.149]                     save_rds(obj, file)
[16:12:33.149]                   }
[16:12:33.149]                   saveImmediateCondition(cond, path = "/tmp/RtmpjVCO6F/.future/immediateConditions")
[16:12:33.149]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.149]                   {
[16:12:33.149]                     inherits <- base::inherits
[16:12:33.149]                     invokeRestart <- base::invokeRestart
[16:12:33.149]                     is.null <- base::is.null
[16:12:33.149]                     muffled <- FALSE
[16:12:33.149]                     if (inherits(cond, "message")) {
[16:12:33.149]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:33.149]                       if (muffled) 
[16:12:33.149]                         invokeRestart("muffleMessage")
[16:12:33.149]                     }
[16:12:33.149]                     else if (inherits(cond, "warning")) {
[16:12:33.149]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:33.149]                       if (muffled) 
[16:12:33.149]                         invokeRestart("muffleWarning")
[16:12:33.149]                     }
[16:12:33.149]                     else if (inherits(cond, "condition")) {
[16:12:33.149]                       if (!is.null(pattern)) {
[16:12:33.149]                         computeRestarts <- base::computeRestarts
[16:12:33.149]                         grepl <- base::grepl
[16:12:33.149]                         restarts <- computeRestarts(cond)
[16:12:33.149]                         for (restart in restarts) {
[16:12:33.149]                           name <- restart$name
[16:12:33.149]                           if (is.null(name)) 
[16:12:33.149]                             next
[16:12:33.149]                           if (!grepl(pattern, name)) 
[16:12:33.149]                             next
[16:12:33.149]                           invokeRestart(restart)
[16:12:33.149]                           muffled <- TRUE
[16:12:33.149]                           break
[16:12:33.149]                         }
[16:12:33.149]                       }
[16:12:33.149]                     }
[16:12:33.149]                     invisible(muffled)
[16:12:33.149]                   }
[16:12:33.149]                   muffleCondition(cond)
[16:12:33.149]                 })
[16:12:33.149]             }))
[16:12:33.149]             future::FutureResult(value = ...future.value$value, 
[16:12:33.149]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:33.149]                   ...future.rng), globalenv = if (FALSE) 
[16:12:33.149]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:33.149]                     ...future.globalenv.names))
[16:12:33.149]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:33.149]         }, condition = base::local({
[16:12:33.149]             c <- base::c
[16:12:33.149]             inherits <- base::inherits
[16:12:33.149]             invokeRestart <- base::invokeRestart
[16:12:33.149]             length <- base::length
[16:12:33.149]             list <- base::list
[16:12:33.149]             seq.int <- base::seq.int
[16:12:33.149]             signalCondition <- base::signalCondition
[16:12:33.149]             sys.calls <- base::sys.calls
[16:12:33.149]             `[[` <- base::`[[`
[16:12:33.149]             `+` <- base::`+`
[16:12:33.149]             `<<-` <- base::`<<-`
[16:12:33.149]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:33.149]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:33.149]                   3L)]
[16:12:33.149]             }
[16:12:33.149]             function(cond) {
[16:12:33.149]                 is_error <- inherits(cond, "error")
[16:12:33.149]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:33.149]                   NULL)
[16:12:33.149]                 if (is_error) {
[16:12:33.149]                   sessionInformation <- function() {
[16:12:33.149]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:33.149]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:33.149]                       search = base::search(), system = base::Sys.info())
[16:12:33.149]                   }
[16:12:33.149]                   ...future.conditions[[length(...future.conditions) + 
[16:12:33.149]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:33.149]                     cond$call), session = sessionInformation(), 
[16:12:33.149]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:33.149]                   signalCondition(cond)
[16:12:33.149]                 }
[16:12:33.149]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:33.149]                 "immediateCondition"))) {
[16:12:33.149]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:33.149]                   ...future.conditions[[length(...future.conditions) + 
[16:12:33.149]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:33.149]                   if (TRUE && !signal) {
[16:12:33.149]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.149]                     {
[16:12:33.149]                       inherits <- base::inherits
[16:12:33.149]                       invokeRestart <- base::invokeRestart
[16:12:33.149]                       is.null <- base::is.null
[16:12:33.149]                       muffled <- FALSE
[16:12:33.149]                       if (inherits(cond, "message")) {
[16:12:33.149]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:33.149]                         if (muffled) 
[16:12:33.149]                           invokeRestart("muffleMessage")
[16:12:33.149]                       }
[16:12:33.149]                       else if (inherits(cond, "warning")) {
[16:12:33.149]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:33.149]                         if (muffled) 
[16:12:33.149]                           invokeRestart("muffleWarning")
[16:12:33.149]                       }
[16:12:33.149]                       else if (inherits(cond, "condition")) {
[16:12:33.149]                         if (!is.null(pattern)) {
[16:12:33.149]                           computeRestarts <- base::computeRestarts
[16:12:33.149]                           grepl <- base::grepl
[16:12:33.149]                           restarts <- computeRestarts(cond)
[16:12:33.149]                           for (restart in restarts) {
[16:12:33.149]                             name <- restart$name
[16:12:33.149]                             if (is.null(name)) 
[16:12:33.149]                               next
[16:12:33.149]                             if (!grepl(pattern, name)) 
[16:12:33.149]                               next
[16:12:33.149]                             invokeRestart(restart)
[16:12:33.149]                             muffled <- TRUE
[16:12:33.149]                             break
[16:12:33.149]                           }
[16:12:33.149]                         }
[16:12:33.149]                       }
[16:12:33.149]                       invisible(muffled)
[16:12:33.149]                     }
[16:12:33.149]                     muffleCondition(cond, pattern = "^muffle")
[16:12:33.149]                   }
[16:12:33.149]                 }
[16:12:33.149]                 else {
[16:12:33.149]                   if (TRUE) {
[16:12:33.149]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.149]                     {
[16:12:33.149]                       inherits <- base::inherits
[16:12:33.149]                       invokeRestart <- base::invokeRestart
[16:12:33.149]                       is.null <- base::is.null
[16:12:33.149]                       muffled <- FALSE
[16:12:33.149]                       if (inherits(cond, "message")) {
[16:12:33.149]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:33.149]                         if (muffled) 
[16:12:33.149]                           invokeRestart("muffleMessage")
[16:12:33.149]                       }
[16:12:33.149]                       else if (inherits(cond, "warning")) {
[16:12:33.149]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:33.149]                         if (muffled) 
[16:12:33.149]                           invokeRestart("muffleWarning")
[16:12:33.149]                       }
[16:12:33.149]                       else if (inherits(cond, "condition")) {
[16:12:33.149]                         if (!is.null(pattern)) {
[16:12:33.149]                           computeRestarts <- base::computeRestarts
[16:12:33.149]                           grepl <- base::grepl
[16:12:33.149]                           restarts <- computeRestarts(cond)
[16:12:33.149]                           for (restart in restarts) {
[16:12:33.149]                             name <- restart$name
[16:12:33.149]                             if (is.null(name)) 
[16:12:33.149]                               next
[16:12:33.149]                             if (!grepl(pattern, name)) 
[16:12:33.149]                               next
[16:12:33.149]                             invokeRestart(restart)
[16:12:33.149]                             muffled <- TRUE
[16:12:33.149]                             break
[16:12:33.149]                           }
[16:12:33.149]                         }
[16:12:33.149]                       }
[16:12:33.149]                       invisible(muffled)
[16:12:33.149]                     }
[16:12:33.149]                     muffleCondition(cond, pattern = "^muffle")
[16:12:33.149]                   }
[16:12:33.149]                 }
[16:12:33.149]             }
[16:12:33.149]         }))
[16:12:33.149]     }, error = function(ex) {
[16:12:33.149]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:33.149]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:33.149]                 ...future.rng), started = ...future.startTime, 
[16:12:33.149]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:33.149]             version = "1.8"), class = "FutureResult")
[16:12:33.149]     }, finally = {
[16:12:33.149]         if (!identical(...future.workdir, getwd())) 
[16:12:33.149]             setwd(...future.workdir)
[16:12:33.149]         {
[16:12:33.149]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:33.149]                 ...future.oldOptions$nwarnings <- NULL
[16:12:33.149]             }
[16:12:33.149]             base::options(...future.oldOptions)
[16:12:33.149]             if (.Platform$OS.type == "windows") {
[16:12:33.149]                 old_names <- names(...future.oldEnvVars)
[16:12:33.149]                 envs <- base::Sys.getenv()
[16:12:33.149]                 names <- names(envs)
[16:12:33.149]                 common <- intersect(names, old_names)
[16:12:33.149]                 added <- setdiff(names, old_names)
[16:12:33.149]                 removed <- setdiff(old_names, names)
[16:12:33.149]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:33.149]                   envs[common]]
[16:12:33.149]                 NAMES <- toupper(changed)
[16:12:33.149]                 args <- list()
[16:12:33.149]                 for (kk in seq_along(NAMES)) {
[16:12:33.149]                   name <- changed[[kk]]
[16:12:33.149]                   NAME <- NAMES[[kk]]
[16:12:33.149]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.149]                     next
[16:12:33.149]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:33.149]                 }
[16:12:33.149]                 NAMES <- toupper(added)
[16:12:33.149]                 for (kk in seq_along(NAMES)) {
[16:12:33.149]                   name <- added[[kk]]
[16:12:33.149]                   NAME <- NAMES[[kk]]
[16:12:33.149]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.149]                     next
[16:12:33.149]                   args[[name]] <- ""
[16:12:33.149]                 }
[16:12:33.149]                 NAMES <- toupper(removed)
[16:12:33.149]                 for (kk in seq_along(NAMES)) {
[16:12:33.149]                   name <- removed[[kk]]
[16:12:33.149]                   NAME <- NAMES[[kk]]
[16:12:33.149]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.149]                     next
[16:12:33.149]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:33.149]                 }
[16:12:33.149]                 if (length(args) > 0) 
[16:12:33.149]                   base::do.call(base::Sys.setenv, args = args)
[16:12:33.149]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:33.149]             }
[16:12:33.149]             else {
[16:12:33.149]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:33.149]             }
[16:12:33.149]             {
[16:12:33.149]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:33.149]                   0L) {
[16:12:33.149]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:33.149]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:33.149]                   base::options(opts)
[16:12:33.149]                 }
[16:12:33.149]                 {
[16:12:33.149]                   {
[16:12:33.149]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:33.149]                     NULL
[16:12:33.149]                   }
[16:12:33.149]                   options(future.plan = NULL)
[16:12:33.149]                   if (is.na(NA_character_)) 
[16:12:33.149]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:33.149]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:33.149]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:33.149]                     envir = parent.frame()) 
[16:12:33.149]                   {
[16:12:33.149]                     default_workers <- missing(workers)
[16:12:33.149]                     if (is.function(workers)) 
[16:12:33.149]                       workers <- workers()
[16:12:33.149]                     workers <- structure(as.integer(workers), 
[16:12:33.149]                       class = class(workers))
[16:12:33.149]                     stop_if_not(is.finite(workers), workers >= 
[16:12:33.149]                       1L)
[16:12:33.149]                     if ((workers == 1L && !inherits(workers, 
[16:12:33.149]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:33.149]                       if (default_workers) 
[16:12:33.149]                         supportsMulticore(warn = TRUE)
[16:12:33.149]                       return(sequential(..., envir = envir))
[16:12:33.149]                     }
[16:12:33.149]                     oopts <- options(mc.cores = workers)
[16:12:33.149]                     on.exit(options(oopts))
[16:12:33.149]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:33.149]                       envir = envir)
[16:12:33.149]                     if (!future$lazy) 
[16:12:33.149]                       future <- run(future)
[16:12:33.149]                     invisible(future)
[16:12:33.149]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:33.149]                 }
[16:12:33.149]             }
[16:12:33.149]         }
[16:12:33.149]     })
[16:12:33.149]     if (TRUE) {
[16:12:33.149]         base::sink(type = "output", split = FALSE)
[16:12:33.149]         if (TRUE) {
[16:12:33.149]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:33.149]         }
[16:12:33.149]         else {
[16:12:33.149]             ...future.result["stdout"] <- base::list(NULL)
[16:12:33.149]         }
[16:12:33.149]         base::close(...future.stdout)
[16:12:33.149]         ...future.stdout <- NULL
[16:12:33.149]     }
[16:12:33.149]     ...future.result$conditions <- ...future.conditions
[16:12:33.149]     ...future.result$finished <- base::Sys.time()
[16:12:33.149]     ...future.result
[16:12:33.149] }
[16:12:33.152] assign_globals() ...
[16:12:33.152] List of 2
[16:12:33.152]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[16:12:33.152]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[16:12:33.152]  - attr(*, "where")=List of 2
[16:12:33.152]   ..$ weight:<environment: R_EmptyEnv> 
[16:12:33.152]   ..$ group :<environment: R_EmptyEnv> 
[16:12:33.152]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:33.152]  - attr(*, "resolved")= logi FALSE
[16:12:33.152]  - attr(*, "total_size")= num 896
[16:12:33.152]  - attr(*, "already-done")= logi TRUE
[16:12:33.159] - copied ‘weight’ to environment
[16:12:33.159] - copied ‘group’ to environment
[16:12:33.159] assign_globals() ... done
[16:12:33.159] requestCore(): workers = 2
[16:12:33.161] MulticoreFuture started
[16:12:33.162] - Launch lazy future ... done
[16:12:33.162] run() for ‘MulticoreFuture’ ... done
[16:12:33.163] plan(): Setting new future strategy stack:
[16:12:33.163] List of future strategies:
[16:12:33.163] 1. sequential:
[16:12:33.163]    - args: function (..., envir = parent.frame())
[16:12:33.163]    - tweaked: FALSE
[16:12:33.163]    - call: NULL
[16:12:33.164] plan(): nbrOfWorkers() = 1
[16:12:33.167] plan(): Setting new future strategy stack:
[16:12:33.168] List of future strategies:
[16:12:33.168] 1. multicore:
[16:12:33.168]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:33.168]    - tweaked: FALSE
[16:12:33.168]    - call: plan(strategy)
[16:12:33.173] plan(): nbrOfWorkers() = 2

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[16:12:33.177] getGlobalsAndPackages() ...
[16:12:33.178] Searching for globals...
[16:12:33.180] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:12:33.180] Searching for globals ... DONE
[16:12:33.180] Resolving globals: FALSE
[16:12:33.181] The total size of the 2 globals is 896 bytes (896 bytes)
[16:12:33.181] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:12:33.181] - globals: [2] ‘weight’, ‘group’
[16:12:33.182] - packages: [1] ‘stats’
[16:12:33.182] getGlobalsAndPackages() ... DONE
[16:12:33.182] run() for ‘Future’ ...
[16:12:33.182] - state: ‘created’
[16:12:33.182] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:33.186] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:33.186] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:33.187]   - Field: ‘label’
[16:12:33.187]   - Field: ‘local’
[16:12:33.187]   - Field: ‘owner’
[16:12:33.187]   - Field: ‘envir’
[16:12:33.187]   - Field: ‘workers’
[16:12:33.187]   - Field: ‘packages’
[16:12:33.187]   - Field: ‘gc’
[16:12:33.187]   - Field: ‘job’
[16:12:33.187]   - Field: ‘conditions’
[16:12:33.188]   - Field: ‘expr’
[16:12:33.188]   - Field: ‘uuid’
[16:12:33.188]   - Field: ‘seed’
[16:12:33.188]   - Field: ‘version’
[16:12:33.188]   - Field: ‘result’
[16:12:33.188]   - Field: ‘asynchronous’
[16:12:33.188]   - Field: ‘calls’
[16:12:33.188]   - Field: ‘globals’
[16:12:33.189]   - Field: ‘stdout’
[16:12:33.189]   - Field: ‘earlySignal’
[16:12:33.189]   - Field: ‘lazy’
[16:12:33.189]   - Field: ‘state’
[16:12:33.189] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:33.189] - Launch lazy future ...
[16:12:33.189] Packages needed by the future expression (n = 1): ‘stats’
[16:12:33.190] Packages needed by future strategies (n = 0): <none>
[16:12:33.190] {
[16:12:33.190]     {
[16:12:33.190]         {
[16:12:33.190]             ...future.startTime <- base::Sys.time()
[16:12:33.190]             {
[16:12:33.190]                 {
[16:12:33.190]                   {
[16:12:33.190]                     {
[16:12:33.190]                       {
[16:12:33.190]                         base::local({
[16:12:33.190]                           has_future <- base::requireNamespace("future", 
[16:12:33.190]                             quietly = TRUE)
[16:12:33.190]                           if (has_future) {
[16:12:33.190]                             ns <- base::getNamespace("future")
[16:12:33.190]                             version <- ns[[".package"]][["version"]]
[16:12:33.190]                             if (is.null(version)) 
[16:12:33.190]                               version <- utils::packageVersion("future")
[16:12:33.190]                           }
[16:12:33.190]                           else {
[16:12:33.190]                             version <- NULL
[16:12:33.190]                           }
[16:12:33.190]                           if (!has_future || version < "1.8.0") {
[16:12:33.190]                             info <- base::c(r_version = base::gsub("R version ", 
[16:12:33.190]                               "", base::R.version$version.string), 
[16:12:33.190]                               platform = base::sprintf("%s (%s-bit)", 
[16:12:33.190]                                 base::R.version$platform, 8 * 
[16:12:33.190]                                   base::.Machine$sizeof.pointer), 
[16:12:33.190]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:33.190]                                 "release", "version")], collapse = " "), 
[16:12:33.190]                               hostname = base::Sys.info()[["nodename"]])
[16:12:33.190]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:12:33.190]                               info)
[16:12:33.190]                             info <- base::paste(info, collapse = "; ")
[16:12:33.190]                             if (!has_future) {
[16:12:33.190]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:33.190]                                 info)
[16:12:33.190]                             }
[16:12:33.190]                             else {
[16:12:33.190]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:33.190]                                 info, version)
[16:12:33.190]                             }
[16:12:33.190]                             base::stop(msg)
[16:12:33.190]                           }
[16:12:33.190]                         })
[16:12:33.190]                       }
[16:12:33.190]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:33.190]                       base::options(mc.cores = 1L)
[16:12:33.190]                     }
[16:12:33.190]                     base::local({
[16:12:33.190]                       for (pkg in "stats") {
[16:12:33.190]                         base::loadNamespace(pkg)
[16:12:33.190]                         base::library(pkg, character.only = TRUE)
[16:12:33.190]                       }
[16:12:33.190]                     })
[16:12:33.190]                   }
[16:12:33.190]                   options(future.plan = NULL)
[16:12:33.190]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:33.190]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:33.190]                 }
[16:12:33.190]                 ...future.workdir <- getwd()
[16:12:33.190]             }
[16:12:33.190]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:33.190]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:33.190]         }
[16:12:33.190]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:33.190]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:33.190]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:33.190]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:33.190]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:33.190]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:33.190]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:33.190]             base::names(...future.oldOptions))
[16:12:33.190]     }
[16:12:33.190]     if (FALSE) {
[16:12:33.190]     }
[16:12:33.190]     else {
[16:12:33.190]         if (TRUE) {
[16:12:33.190]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:33.190]                 open = "w")
[16:12:33.190]         }
[16:12:33.190]         else {
[16:12:33.190]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:33.190]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:33.190]         }
[16:12:33.190]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:33.190]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:33.190]             base::sink(type = "output", split = FALSE)
[16:12:33.190]             base::close(...future.stdout)
[16:12:33.190]         }, add = TRUE)
[16:12:33.190]     }
[16:12:33.190]     ...future.frame <- base::sys.nframe()
[16:12:33.190]     ...future.conditions <- base::list()
[16:12:33.190]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:33.190]     if (FALSE) {
[16:12:33.190]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:33.190]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:33.190]     }
[16:12:33.190]     ...future.result <- base::tryCatch({
[16:12:33.190]         base::withCallingHandlers({
[16:12:33.190]             ...future.value <- base::withVisible(base::local({
[16:12:33.190]                 withCallingHandlers({
[16:12:33.190]                   {
[16:12:33.190]                     lm(weight ~ group - 1)
[16:12:33.190]                   }
[16:12:33.190]                 }, immediateCondition = function(cond) {
[16:12:33.190]                   save_rds <- function (object, pathname, ...) 
[16:12:33.190]                   {
[16:12:33.190]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:33.190]                     if (file_test("-f", pathname_tmp)) {
[16:12:33.190]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.190]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:33.190]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.190]                         fi_tmp[["mtime"]])
[16:12:33.190]                     }
[16:12:33.190]                     tryCatch({
[16:12:33.190]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:33.190]                     }, error = function(ex) {
[16:12:33.190]                       msg <- conditionMessage(ex)
[16:12:33.190]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.190]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:33.190]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.190]                         fi_tmp[["mtime"]], msg)
[16:12:33.190]                       ex$message <- msg
[16:12:33.190]                       stop(ex)
[16:12:33.190]                     })
[16:12:33.190]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:33.190]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:33.190]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:33.190]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.190]                       fi <- file.info(pathname)
[16:12:33.190]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:33.190]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.190]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:33.190]                         fi[["size"]], fi[["mtime"]])
[16:12:33.190]                       stop(msg)
[16:12:33.190]                     }
[16:12:33.190]                     invisible(pathname)
[16:12:33.190]                   }
[16:12:33.190]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:33.190]                     rootPath = tempdir()) 
[16:12:33.190]                   {
[16:12:33.190]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:33.190]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:33.190]                       tmpdir = path, fileext = ".rds")
[16:12:33.190]                     save_rds(obj, file)
[16:12:33.190]                   }
[16:12:33.190]                   saveImmediateCondition(cond, path = "/tmp/RtmpjVCO6F/.future/immediateConditions")
[16:12:33.190]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.190]                   {
[16:12:33.190]                     inherits <- base::inherits
[16:12:33.190]                     invokeRestart <- base::invokeRestart
[16:12:33.190]                     is.null <- base::is.null
[16:12:33.190]                     muffled <- FALSE
[16:12:33.190]                     if (inherits(cond, "message")) {
[16:12:33.190]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:33.190]                       if (muffled) 
[16:12:33.190]                         invokeRestart("muffleMessage")
[16:12:33.190]                     }
[16:12:33.190]                     else if (inherits(cond, "warning")) {
[16:12:33.190]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:33.190]                       if (muffled) 
[16:12:33.190]                         invokeRestart("muffleWarning")
[16:12:33.190]                     }
[16:12:33.190]                     else if (inherits(cond, "condition")) {
[16:12:33.190]                       if (!is.null(pattern)) {
[16:12:33.190]                         computeRestarts <- base::computeRestarts
[16:12:33.190]                         grepl <- base::grepl
[16:12:33.190]                         restarts <- computeRestarts(cond)
[16:12:33.190]                         for (restart in restarts) {
[16:12:33.190]                           name <- restart$name
[16:12:33.190]                           if (is.null(name)) 
[16:12:33.190]                             next
[16:12:33.190]                           if (!grepl(pattern, name)) 
[16:12:33.190]                             next
[16:12:33.190]                           invokeRestart(restart)
[16:12:33.190]                           muffled <- TRUE
[16:12:33.190]                           break
[16:12:33.190]                         }
[16:12:33.190]                       }
[16:12:33.190]                     }
[16:12:33.190]                     invisible(muffled)
[16:12:33.190]                   }
[16:12:33.190]                   muffleCondition(cond)
[16:12:33.190]                 })
[16:12:33.190]             }))
[16:12:33.190]             future::FutureResult(value = ...future.value$value, 
[16:12:33.190]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:33.190]                   ...future.rng), globalenv = if (FALSE) 
[16:12:33.190]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:33.190]                     ...future.globalenv.names))
[16:12:33.190]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:33.190]         }, condition = base::local({
[16:12:33.190]             c <- base::c
[16:12:33.190]             inherits <- base::inherits
[16:12:33.190]             invokeRestart <- base::invokeRestart
[16:12:33.190]             length <- base::length
[16:12:33.190]             list <- base::list
[16:12:33.190]             seq.int <- base::seq.int
[16:12:33.190]             signalCondition <- base::signalCondition
[16:12:33.190]             sys.calls <- base::sys.calls
[16:12:33.190]             `[[` <- base::`[[`
[16:12:33.190]             `+` <- base::`+`
[16:12:33.190]             `<<-` <- base::`<<-`
[16:12:33.190]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:33.190]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:33.190]                   3L)]
[16:12:33.190]             }
[16:12:33.190]             function(cond) {
[16:12:33.190]                 is_error <- inherits(cond, "error")
[16:12:33.190]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:33.190]                   NULL)
[16:12:33.190]                 if (is_error) {
[16:12:33.190]                   sessionInformation <- function() {
[16:12:33.190]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:33.190]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:33.190]                       search = base::search(), system = base::Sys.info())
[16:12:33.190]                   }
[16:12:33.190]                   ...future.conditions[[length(...future.conditions) + 
[16:12:33.190]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:33.190]                     cond$call), session = sessionInformation(), 
[16:12:33.190]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:33.190]                   signalCondition(cond)
[16:12:33.190]                 }
[16:12:33.190]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:33.190]                 "immediateCondition"))) {
[16:12:33.190]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:33.190]                   ...future.conditions[[length(...future.conditions) + 
[16:12:33.190]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:33.190]                   if (TRUE && !signal) {
[16:12:33.190]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.190]                     {
[16:12:33.190]                       inherits <- base::inherits
[16:12:33.190]                       invokeRestart <- base::invokeRestart
[16:12:33.190]                       is.null <- base::is.null
[16:12:33.190]                       muffled <- FALSE
[16:12:33.190]                       if (inherits(cond, "message")) {
[16:12:33.190]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:33.190]                         if (muffled) 
[16:12:33.190]                           invokeRestart("muffleMessage")
[16:12:33.190]                       }
[16:12:33.190]                       else if (inherits(cond, "warning")) {
[16:12:33.190]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:33.190]                         if (muffled) 
[16:12:33.190]                           invokeRestart("muffleWarning")
[16:12:33.190]                       }
[16:12:33.190]                       else if (inherits(cond, "condition")) {
[16:12:33.190]                         if (!is.null(pattern)) {
[16:12:33.190]                           computeRestarts <- base::computeRestarts
[16:12:33.190]                           grepl <- base::grepl
[16:12:33.190]                           restarts <- computeRestarts(cond)
[16:12:33.190]                           for (restart in restarts) {
[16:12:33.190]                             name <- restart$name
[16:12:33.190]                             if (is.null(name)) 
[16:12:33.190]                               next
[16:12:33.190]                             if (!grepl(pattern, name)) 
[16:12:33.190]                               next
[16:12:33.190]                             invokeRestart(restart)
[16:12:33.190]                             muffled <- TRUE
[16:12:33.190]                             break
[16:12:33.190]                           }
[16:12:33.190]                         }
[16:12:33.190]                       }
[16:12:33.190]                       invisible(muffled)
[16:12:33.190]                     }
[16:12:33.190]                     muffleCondition(cond, pattern = "^muffle")
[16:12:33.190]                   }
[16:12:33.190]                 }
[16:12:33.190]                 else {
[16:12:33.190]                   if (TRUE) {
[16:12:33.190]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.190]                     {
[16:12:33.190]                       inherits <- base::inherits
[16:12:33.190]                       invokeRestart <- base::invokeRestart
[16:12:33.190]                       is.null <- base::is.null
[16:12:33.190]                       muffled <- FALSE
[16:12:33.190]                       if (inherits(cond, "message")) {
[16:12:33.190]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:33.190]                         if (muffled) 
[16:12:33.190]                           invokeRestart("muffleMessage")
[16:12:33.190]                       }
[16:12:33.190]                       else if (inherits(cond, "warning")) {
[16:12:33.190]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:33.190]                         if (muffled) 
[16:12:33.190]                           invokeRestart("muffleWarning")
[16:12:33.190]                       }
[16:12:33.190]                       else if (inherits(cond, "condition")) {
[16:12:33.190]                         if (!is.null(pattern)) {
[16:12:33.190]                           computeRestarts <- base::computeRestarts
[16:12:33.190]                           grepl <- base::grepl
[16:12:33.190]                           restarts <- computeRestarts(cond)
[16:12:33.190]                           for (restart in restarts) {
[16:12:33.190]                             name <- restart$name
[16:12:33.190]                             if (is.null(name)) 
[16:12:33.190]                               next
[16:12:33.190]                             if (!grepl(pattern, name)) 
[16:12:33.190]                               next
[16:12:33.190]                             invokeRestart(restart)
[16:12:33.190]                             muffled <- TRUE
[16:12:33.190]                             break
[16:12:33.190]                           }
[16:12:33.190]                         }
[16:12:33.190]                       }
[16:12:33.190]                       invisible(muffled)
[16:12:33.190]                     }
[16:12:33.190]                     muffleCondition(cond, pattern = "^muffle")
[16:12:33.190]                   }
[16:12:33.190]                 }
[16:12:33.190]             }
[16:12:33.190]         }))
[16:12:33.190]     }, error = function(ex) {
[16:12:33.190]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:33.190]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:33.190]                 ...future.rng), started = ...future.startTime, 
[16:12:33.190]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:33.190]             version = "1.8"), class = "FutureResult")
[16:12:33.190]     }, finally = {
[16:12:33.190]         if (!identical(...future.workdir, getwd())) 
[16:12:33.190]             setwd(...future.workdir)
[16:12:33.190]         {
[16:12:33.190]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:33.190]                 ...future.oldOptions$nwarnings <- NULL
[16:12:33.190]             }
[16:12:33.190]             base::options(...future.oldOptions)
[16:12:33.190]             if (.Platform$OS.type == "windows") {
[16:12:33.190]                 old_names <- names(...future.oldEnvVars)
[16:12:33.190]                 envs <- base::Sys.getenv()
[16:12:33.190]                 names <- names(envs)
[16:12:33.190]                 common <- intersect(names, old_names)
[16:12:33.190]                 added <- setdiff(names, old_names)
[16:12:33.190]                 removed <- setdiff(old_names, names)
[16:12:33.190]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:33.190]                   envs[common]]
[16:12:33.190]                 NAMES <- toupper(changed)
[16:12:33.190]                 args <- list()
[16:12:33.190]                 for (kk in seq_along(NAMES)) {
[16:12:33.190]                   name <- changed[[kk]]
[16:12:33.190]                   NAME <- NAMES[[kk]]
[16:12:33.190]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.190]                     next
[16:12:33.190]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:33.190]                 }
[16:12:33.190]                 NAMES <- toupper(added)
[16:12:33.190]                 for (kk in seq_along(NAMES)) {
[16:12:33.190]                   name <- added[[kk]]
[16:12:33.190]                   NAME <- NAMES[[kk]]
[16:12:33.190]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.190]                     next
[16:12:33.190]                   args[[name]] <- ""
[16:12:33.190]                 }
[16:12:33.190]                 NAMES <- toupper(removed)
[16:12:33.190]                 for (kk in seq_along(NAMES)) {
[16:12:33.190]                   name <- removed[[kk]]
[16:12:33.190]                   NAME <- NAMES[[kk]]
[16:12:33.190]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.190]                     next
[16:12:33.190]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:33.190]                 }
[16:12:33.190]                 if (length(args) > 0) 
[16:12:33.190]                   base::do.call(base::Sys.setenv, args = args)
[16:12:33.190]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:33.190]             }
[16:12:33.190]             else {
[16:12:33.190]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:33.190]             }
[16:12:33.190]             {
[16:12:33.190]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:33.190]                   0L) {
[16:12:33.190]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:33.190]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:33.190]                   base::options(opts)
[16:12:33.190]                 }
[16:12:33.190]                 {
[16:12:33.190]                   {
[16:12:33.190]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:33.190]                     NULL
[16:12:33.190]                   }
[16:12:33.190]                   options(future.plan = NULL)
[16:12:33.190]                   if (is.na(NA_character_)) 
[16:12:33.190]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:33.190]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:33.190]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:33.190]                     envir = parent.frame()) 
[16:12:33.190]                   {
[16:12:33.190]                     default_workers <- missing(workers)
[16:12:33.190]                     if (is.function(workers)) 
[16:12:33.190]                       workers <- workers()
[16:12:33.190]                     workers <- structure(as.integer(workers), 
[16:12:33.190]                       class = class(workers))
[16:12:33.190]                     stop_if_not(is.finite(workers), workers >= 
[16:12:33.190]                       1L)
[16:12:33.190]                     if ((workers == 1L && !inherits(workers, 
[16:12:33.190]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:33.190]                       if (default_workers) 
[16:12:33.190]                         supportsMulticore(warn = TRUE)
[16:12:33.190]                       return(sequential(..., envir = envir))
[16:12:33.190]                     }
[16:12:33.190]                     oopts <- options(mc.cores = workers)
[16:12:33.190]                     on.exit(options(oopts))
[16:12:33.190]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:33.190]                       envir = envir)
[16:12:33.190]                     if (!future$lazy) 
[16:12:33.190]                       future <- run(future)
[16:12:33.190]                     invisible(future)
[16:12:33.190]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:33.190]                 }
[16:12:33.190]             }
[16:12:33.190]         }
[16:12:33.190]     })
[16:12:33.190]     if (TRUE) {
[16:12:33.190]         base::sink(type = "output", split = FALSE)
[16:12:33.190]         if (TRUE) {
[16:12:33.190]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:33.190]         }
[16:12:33.190]         else {
[16:12:33.190]             ...future.result["stdout"] <- base::list(NULL)
[16:12:33.190]         }
[16:12:33.190]         base::close(...future.stdout)
[16:12:33.190]         ...future.stdout <- NULL
[16:12:33.190]     }
[16:12:33.190]     ...future.result$conditions <- ...future.conditions
[16:12:33.190]     ...future.result$finished <- base::Sys.time()
[16:12:33.190]     ...future.result
[16:12:33.190] }
[16:12:33.193] assign_globals() ...
[16:12:33.193] List of 2
[16:12:33.193]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[16:12:33.193]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[16:12:33.193]  - attr(*, "where")=List of 2
[16:12:33.193]   ..$ weight:<environment: R_EmptyEnv> 
[16:12:33.193]   ..$ group :<environment: R_EmptyEnv> 
[16:12:33.193]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:33.193]  - attr(*, "resolved")= logi FALSE
[16:12:33.193]  - attr(*, "total_size")= num 896
[16:12:33.193]  - attr(*, "already-done")= logi TRUE
[16:12:33.197] - copied ‘weight’ to environment
[16:12:33.197] - copied ‘group’ to environment
[16:12:33.197] assign_globals() ... done
[16:12:33.197] requestCore(): workers = 2
[16:12:33.199] MulticoreFuture started
[16:12:33.199] - Launch lazy future ... done
[16:12:33.199] run() for ‘MulticoreFuture’ ... done
[16:12:33.200] plan(): Setting new future strategy stack:
[16:12:33.200] List of future strategies:
[16:12:33.200] 1. sequential:
[16:12:33.200]    - args: function (..., envir = parent.frame())
[16:12:33.200]    - tweaked: FALSE
[16:12:33.200]    - call: NULL
[16:12:33.205] plan(): nbrOfWorkers() = 1
[16:12:33.209] plan(): Setting new future strategy stack:
[16:12:33.209] List of future strategies:
[16:12:33.209] 1. multicore:
[16:12:33.209]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:33.209]    - tweaked: FALSE
[16:12:33.209]    - call: plan(strategy)
[16:12:33.214] plan(): nbrOfWorkers() = 2

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[16:12:33.222] getGlobalsAndPackages() ...
[16:12:33.222] Searching for globals...
[16:12:33.224] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:12:33.224] Searching for globals ... DONE
[16:12:33.224] Resolving globals: FALSE
[16:12:33.225] The total size of the 2 globals is 896 bytes (896 bytes)
[16:12:33.225] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:12:33.226] - globals: [2] ‘weight’, ‘group’
[16:12:33.226] - packages: [1] ‘stats’
[16:12:33.226] getGlobalsAndPackages() ... DONE
[16:12:33.226] run() for ‘Future’ ...
[16:12:33.226] - state: ‘created’
[16:12:33.226] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:33.230] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:33.231] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:33.231]   - Field: ‘label’
[16:12:33.231]   - Field: ‘local’
[16:12:33.231]   - Field: ‘owner’
[16:12:33.231]   - Field: ‘envir’
[16:12:33.231]   - Field: ‘workers’
[16:12:33.231]   - Field: ‘packages’
[16:12:33.231]   - Field: ‘gc’
[16:12:33.232]   - Field: ‘job’
[16:12:33.232]   - Field: ‘conditions’
[16:12:33.232]   - Field: ‘expr’
[16:12:33.232]   - Field: ‘uuid’
[16:12:33.232]   - Field: ‘seed’
[16:12:33.232]   - Field: ‘version’
[16:12:33.232]   - Field: ‘result’
[16:12:33.232]   - Field: ‘asynchronous’
[16:12:33.232]   - Field: ‘calls’
[16:12:33.233]   - Field: ‘globals’
[16:12:33.233]   - Field: ‘stdout’
[16:12:33.233]   - Field: ‘earlySignal’
[16:12:33.233]   - Field: ‘lazy’
[16:12:33.233]   - Field: ‘state’
[16:12:33.233] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:33.233] - Launch lazy future ...
[16:12:33.234] Packages needed by the future expression (n = 1): ‘stats’
[16:12:33.234] Packages needed by future strategies (n = 0): <none>
[16:12:33.234] {
[16:12:33.234]     {
[16:12:33.234]         {
[16:12:33.234]             ...future.startTime <- base::Sys.time()
[16:12:33.234]             {
[16:12:33.234]                 {
[16:12:33.234]                   {
[16:12:33.234]                     {
[16:12:33.234]                       {
[16:12:33.234]                         base::local({
[16:12:33.234]                           has_future <- base::requireNamespace("future", 
[16:12:33.234]                             quietly = TRUE)
[16:12:33.234]                           if (has_future) {
[16:12:33.234]                             ns <- base::getNamespace("future")
[16:12:33.234]                             version <- ns[[".package"]][["version"]]
[16:12:33.234]                             if (is.null(version)) 
[16:12:33.234]                               version <- utils::packageVersion("future")
[16:12:33.234]                           }
[16:12:33.234]                           else {
[16:12:33.234]                             version <- NULL
[16:12:33.234]                           }
[16:12:33.234]                           if (!has_future || version < "1.8.0") {
[16:12:33.234]                             info <- base::c(r_version = base::gsub("R version ", 
[16:12:33.234]                               "", base::R.version$version.string), 
[16:12:33.234]                               platform = base::sprintf("%s (%s-bit)", 
[16:12:33.234]                                 base::R.version$platform, 8 * 
[16:12:33.234]                                   base::.Machine$sizeof.pointer), 
[16:12:33.234]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:33.234]                                 "release", "version")], collapse = " "), 
[16:12:33.234]                               hostname = base::Sys.info()[["nodename"]])
[16:12:33.234]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:12:33.234]                               info)
[16:12:33.234]                             info <- base::paste(info, collapse = "; ")
[16:12:33.234]                             if (!has_future) {
[16:12:33.234]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:33.234]                                 info)
[16:12:33.234]                             }
[16:12:33.234]                             else {
[16:12:33.234]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:33.234]                                 info, version)
[16:12:33.234]                             }
[16:12:33.234]                             base::stop(msg)
[16:12:33.234]                           }
[16:12:33.234]                         })
[16:12:33.234]                       }
[16:12:33.234]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:33.234]                       base::options(mc.cores = 1L)
[16:12:33.234]                     }
[16:12:33.234]                     base::local({
[16:12:33.234]                       for (pkg in "stats") {
[16:12:33.234]                         base::loadNamespace(pkg)
[16:12:33.234]                         base::library(pkg, character.only = TRUE)
[16:12:33.234]                       }
[16:12:33.234]                     })
[16:12:33.234]                   }
[16:12:33.234]                   options(future.plan = NULL)
[16:12:33.234]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:33.234]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:33.234]                 }
[16:12:33.234]                 ...future.workdir <- getwd()
[16:12:33.234]             }
[16:12:33.234]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:33.234]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:33.234]         }
[16:12:33.234]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:33.234]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:33.234]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:33.234]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:33.234]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:33.234]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:33.234]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:33.234]             base::names(...future.oldOptions))
[16:12:33.234]     }
[16:12:33.234]     if (FALSE) {
[16:12:33.234]     }
[16:12:33.234]     else {
[16:12:33.234]         if (TRUE) {
[16:12:33.234]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:33.234]                 open = "w")
[16:12:33.234]         }
[16:12:33.234]         else {
[16:12:33.234]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:33.234]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:33.234]         }
[16:12:33.234]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:33.234]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:33.234]             base::sink(type = "output", split = FALSE)
[16:12:33.234]             base::close(...future.stdout)
[16:12:33.234]         }, add = TRUE)
[16:12:33.234]     }
[16:12:33.234]     ...future.frame <- base::sys.nframe()
[16:12:33.234]     ...future.conditions <- base::list()
[16:12:33.234]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:33.234]     if (FALSE) {
[16:12:33.234]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:33.234]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:33.234]     }
[16:12:33.234]     ...future.result <- base::tryCatch({
[16:12:33.234]         base::withCallingHandlers({
[16:12:33.234]             ...future.value <- base::withVisible(base::local({
[16:12:33.234]                 withCallingHandlers({
[16:12:33.234]                   {
[16:12:33.234]                     lm(weight ~ group - 1)
[16:12:33.234]                   }
[16:12:33.234]                 }, immediateCondition = function(cond) {
[16:12:33.234]                   save_rds <- function (object, pathname, ...) 
[16:12:33.234]                   {
[16:12:33.234]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:33.234]                     if (file_test("-f", pathname_tmp)) {
[16:12:33.234]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.234]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:33.234]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.234]                         fi_tmp[["mtime"]])
[16:12:33.234]                     }
[16:12:33.234]                     tryCatch({
[16:12:33.234]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:33.234]                     }, error = function(ex) {
[16:12:33.234]                       msg <- conditionMessage(ex)
[16:12:33.234]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.234]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:33.234]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.234]                         fi_tmp[["mtime"]], msg)
[16:12:33.234]                       ex$message <- msg
[16:12:33.234]                       stop(ex)
[16:12:33.234]                     })
[16:12:33.234]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:33.234]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:33.234]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:33.234]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.234]                       fi <- file.info(pathname)
[16:12:33.234]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:33.234]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.234]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:33.234]                         fi[["size"]], fi[["mtime"]])
[16:12:33.234]                       stop(msg)
[16:12:33.234]                     }
[16:12:33.234]                     invisible(pathname)
[16:12:33.234]                   }
[16:12:33.234]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:33.234]                     rootPath = tempdir()) 
[16:12:33.234]                   {
[16:12:33.234]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:33.234]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:33.234]                       tmpdir = path, fileext = ".rds")
[16:12:33.234]                     save_rds(obj, file)
[16:12:33.234]                   }
[16:12:33.234]                   saveImmediateCondition(cond, path = "/tmp/RtmpjVCO6F/.future/immediateConditions")
[16:12:33.234]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.234]                   {
[16:12:33.234]                     inherits <- base::inherits
[16:12:33.234]                     invokeRestart <- base::invokeRestart
[16:12:33.234]                     is.null <- base::is.null
[16:12:33.234]                     muffled <- FALSE
[16:12:33.234]                     if (inherits(cond, "message")) {
[16:12:33.234]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:33.234]                       if (muffled) 
[16:12:33.234]                         invokeRestart("muffleMessage")
[16:12:33.234]                     }
[16:12:33.234]                     else if (inherits(cond, "warning")) {
[16:12:33.234]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:33.234]                       if (muffled) 
[16:12:33.234]                         invokeRestart("muffleWarning")
[16:12:33.234]                     }
[16:12:33.234]                     else if (inherits(cond, "condition")) {
[16:12:33.234]                       if (!is.null(pattern)) {
[16:12:33.234]                         computeRestarts <- base::computeRestarts
[16:12:33.234]                         grepl <- base::grepl
[16:12:33.234]                         restarts <- computeRestarts(cond)
[16:12:33.234]                         for (restart in restarts) {
[16:12:33.234]                           name <- restart$name
[16:12:33.234]                           if (is.null(name)) 
[16:12:33.234]                             next
[16:12:33.234]                           if (!grepl(pattern, name)) 
[16:12:33.234]                             next
[16:12:33.234]                           invokeRestart(restart)
[16:12:33.234]                           muffled <- TRUE
[16:12:33.234]                           break
[16:12:33.234]                         }
[16:12:33.234]                       }
[16:12:33.234]                     }
[16:12:33.234]                     invisible(muffled)
[16:12:33.234]                   }
[16:12:33.234]                   muffleCondition(cond)
[16:12:33.234]                 })
[16:12:33.234]             }))
[16:12:33.234]             future::FutureResult(value = ...future.value$value, 
[16:12:33.234]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:33.234]                   ...future.rng), globalenv = if (FALSE) 
[16:12:33.234]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:33.234]                     ...future.globalenv.names))
[16:12:33.234]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:33.234]         }, condition = base::local({
[16:12:33.234]             c <- base::c
[16:12:33.234]             inherits <- base::inherits
[16:12:33.234]             invokeRestart <- base::invokeRestart
[16:12:33.234]             length <- base::length
[16:12:33.234]             list <- base::list
[16:12:33.234]             seq.int <- base::seq.int
[16:12:33.234]             signalCondition <- base::signalCondition
[16:12:33.234]             sys.calls <- base::sys.calls
[16:12:33.234]             `[[` <- base::`[[`
[16:12:33.234]             `+` <- base::`+`
[16:12:33.234]             `<<-` <- base::`<<-`
[16:12:33.234]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:33.234]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:33.234]                   3L)]
[16:12:33.234]             }
[16:12:33.234]             function(cond) {
[16:12:33.234]                 is_error <- inherits(cond, "error")
[16:12:33.234]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:33.234]                   NULL)
[16:12:33.234]                 if (is_error) {
[16:12:33.234]                   sessionInformation <- function() {
[16:12:33.234]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:33.234]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:33.234]                       search = base::search(), system = base::Sys.info())
[16:12:33.234]                   }
[16:12:33.234]                   ...future.conditions[[length(...future.conditions) + 
[16:12:33.234]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:33.234]                     cond$call), session = sessionInformation(), 
[16:12:33.234]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:33.234]                   signalCondition(cond)
[16:12:33.234]                 }
[16:12:33.234]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:33.234]                 "immediateCondition"))) {
[16:12:33.234]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:33.234]                   ...future.conditions[[length(...future.conditions) + 
[16:12:33.234]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:33.234]                   if (TRUE && !signal) {
[16:12:33.234]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.234]                     {
[16:12:33.234]                       inherits <- base::inherits
[16:12:33.234]                       invokeRestart <- base::invokeRestart
[16:12:33.234]                       is.null <- base::is.null
[16:12:33.234]                       muffled <- FALSE
[16:12:33.234]                       if (inherits(cond, "message")) {
[16:12:33.234]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:33.234]                         if (muffled) 
[16:12:33.234]                           invokeRestart("muffleMessage")
[16:12:33.234]                       }
[16:12:33.234]                       else if (inherits(cond, "warning")) {
[16:12:33.234]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:33.234]                         if (muffled) 
[16:12:33.234]                           invokeRestart("muffleWarning")
[16:12:33.234]                       }
[16:12:33.234]                       else if (inherits(cond, "condition")) {
[16:12:33.234]                         if (!is.null(pattern)) {
[16:12:33.234]                           computeRestarts <- base::computeRestarts
[16:12:33.234]                           grepl <- base::grepl
[16:12:33.234]                           restarts <- computeRestarts(cond)
[16:12:33.234]                           for (restart in restarts) {
[16:12:33.234]                             name <- restart$name
[16:12:33.234]                             if (is.null(name)) 
[16:12:33.234]                               next
[16:12:33.234]                             if (!grepl(pattern, name)) 
[16:12:33.234]                               next
[16:12:33.234]                             invokeRestart(restart)
[16:12:33.234]                             muffled <- TRUE
[16:12:33.234]                             break
[16:12:33.234]                           }
[16:12:33.234]                         }
[16:12:33.234]                       }
[16:12:33.234]                       invisible(muffled)
[16:12:33.234]                     }
[16:12:33.234]                     muffleCondition(cond, pattern = "^muffle")
[16:12:33.234]                   }
[16:12:33.234]                 }
[16:12:33.234]                 else {
[16:12:33.234]                   if (TRUE) {
[16:12:33.234]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.234]                     {
[16:12:33.234]                       inherits <- base::inherits
[16:12:33.234]                       invokeRestart <- base::invokeRestart
[16:12:33.234]                       is.null <- base::is.null
[16:12:33.234]                       muffled <- FALSE
[16:12:33.234]                       if (inherits(cond, "message")) {
[16:12:33.234]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:33.234]                         if (muffled) 
[16:12:33.234]                           invokeRestart("muffleMessage")
[16:12:33.234]                       }
[16:12:33.234]                       else if (inherits(cond, "warning")) {
[16:12:33.234]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:33.234]                         if (muffled) 
[16:12:33.234]                           invokeRestart("muffleWarning")
[16:12:33.234]                       }
[16:12:33.234]                       else if (inherits(cond, "condition")) {
[16:12:33.234]                         if (!is.null(pattern)) {
[16:12:33.234]                           computeRestarts <- base::computeRestarts
[16:12:33.234]                           grepl <- base::grepl
[16:12:33.234]                           restarts <- computeRestarts(cond)
[16:12:33.234]                           for (restart in restarts) {
[16:12:33.234]                             name <- restart$name
[16:12:33.234]                             if (is.null(name)) 
[16:12:33.234]                               next
[16:12:33.234]                             if (!grepl(pattern, name)) 
[16:12:33.234]                               next
[16:12:33.234]                             invokeRestart(restart)
[16:12:33.234]                             muffled <- TRUE
[16:12:33.234]                             break
[16:12:33.234]                           }
[16:12:33.234]                         }
[16:12:33.234]                       }
[16:12:33.234]                       invisible(muffled)
[16:12:33.234]                     }
[16:12:33.234]                     muffleCondition(cond, pattern = "^muffle")
[16:12:33.234]                   }
[16:12:33.234]                 }
[16:12:33.234]             }
[16:12:33.234]         }))
[16:12:33.234]     }, error = function(ex) {
[16:12:33.234]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:33.234]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:33.234]                 ...future.rng), started = ...future.startTime, 
[16:12:33.234]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:33.234]             version = "1.8"), class = "FutureResult")
[16:12:33.234]     }, finally = {
[16:12:33.234]         if (!identical(...future.workdir, getwd())) 
[16:12:33.234]             setwd(...future.workdir)
[16:12:33.234]         {
[16:12:33.234]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:33.234]                 ...future.oldOptions$nwarnings <- NULL
[16:12:33.234]             }
[16:12:33.234]             base::options(...future.oldOptions)
[16:12:33.234]             if (.Platform$OS.type == "windows") {
[16:12:33.234]                 old_names <- names(...future.oldEnvVars)
[16:12:33.234]                 envs <- base::Sys.getenv()
[16:12:33.234]                 names <- names(envs)
[16:12:33.234]                 common <- intersect(names, old_names)
[16:12:33.234]                 added <- setdiff(names, old_names)
[16:12:33.234]                 removed <- setdiff(old_names, names)
[16:12:33.234]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:33.234]                   envs[common]]
[16:12:33.234]                 NAMES <- toupper(changed)
[16:12:33.234]                 args <- list()
[16:12:33.234]                 for (kk in seq_along(NAMES)) {
[16:12:33.234]                   name <- changed[[kk]]
[16:12:33.234]                   NAME <- NAMES[[kk]]
[16:12:33.234]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.234]                     next
[16:12:33.234]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:33.234]                 }
[16:12:33.234]                 NAMES <- toupper(added)
[16:12:33.234]                 for (kk in seq_along(NAMES)) {
[16:12:33.234]                   name <- added[[kk]]
[16:12:33.234]                   NAME <- NAMES[[kk]]
[16:12:33.234]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.234]                     next
[16:12:33.234]                   args[[name]] <- ""
[16:12:33.234]                 }
[16:12:33.234]                 NAMES <- toupper(removed)
[16:12:33.234]                 for (kk in seq_along(NAMES)) {
[16:12:33.234]                   name <- removed[[kk]]
[16:12:33.234]                   NAME <- NAMES[[kk]]
[16:12:33.234]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.234]                     next
[16:12:33.234]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:33.234]                 }
[16:12:33.234]                 if (length(args) > 0) 
[16:12:33.234]                   base::do.call(base::Sys.setenv, args = args)
[16:12:33.234]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:33.234]             }
[16:12:33.234]             else {
[16:12:33.234]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:33.234]             }
[16:12:33.234]             {
[16:12:33.234]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:33.234]                   0L) {
[16:12:33.234]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:33.234]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:33.234]                   base::options(opts)
[16:12:33.234]                 }
[16:12:33.234]                 {
[16:12:33.234]                   {
[16:12:33.234]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:33.234]                     NULL
[16:12:33.234]                   }
[16:12:33.234]                   options(future.plan = NULL)
[16:12:33.234]                   if (is.na(NA_character_)) 
[16:12:33.234]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:33.234]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:33.234]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:33.234]                     envir = parent.frame()) 
[16:12:33.234]                   {
[16:12:33.234]                     default_workers <- missing(workers)
[16:12:33.234]                     if (is.function(workers)) 
[16:12:33.234]                       workers <- workers()
[16:12:33.234]                     workers <- structure(as.integer(workers), 
[16:12:33.234]                       class = class(workers))
[16:12:33.234]                     stop_if_not(is.finite(workers), workers >= 
[16:12:33.234]                       1L)
[16:12:33.234]                     if ((workers == 1L && !inherits(workers, 
[16:12:33.234]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:33.234]                       if (default_workers) 
[16:12:33.234]                         supportsMulticore(warn = TRUE)
[16:12:33.234]                       return(sequential(..., envir = envir))
[16:12:33.234]                     }
[16:12:33.234]                     oopts <- options(mc.cores = workers)
[16:12:33.234]                     on.exit(options(oopts))
[16:12:33.234]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:33.234]                       envir = envir)
[16:12:33.234]                     if (!future$lazy) 
[16:12:33.234]                       future <- run(future)
[16:12:33.234]                     invisible(future)
[16:12:33.234]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:33.234]                 }
[16:12:33.234]             }
[16:12:33.234]         }
[16:12:33.234]     })
[16:12:33.234]     if (TRUE) {
[16:12:33.234]         base::sink(type = "output", split = FALSE)
[16:12:33.234]         if (TRUE) {
[16:12:33.234]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:33.234]         }
[16:12:33.234]         else {
[16:12:33.234]             ...future.result["stdout"] <- base::list(NULL)
[16:12:33.234]         }
[16:12:33.234]         base::close(...future.stdout)
[16:12:33.234]         ...future.stdout <- NULL
[16:12:33.234]     }
[16:12:33.234]     ...future.result$conditions <- ...future.conditions
[16:12:33.234]     ...future.result$finished <- base::Sys.time()
[16:12:33.234]     ...future.result
[16:12:33.234] }
[16:12:33.237] assign_globals() ...
[16:12:33.237] List of 2
[16:12:33.237]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[16:12:33.237]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[16:12:33.237]  - attr(*, "where")=List of 2
[16:12:33.237]   ..$ weight:<environment: R_EmptyEnv> 
[16:12:33.237]   ..$ group :<environment: R_EmptyEnv> 
[16:12:33.237]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:33.237]  - attr(*, "resolved")= logi FALSE
[16:12:33.237]  - attr(*, "total_size")= num 896
[16:12:33.237]  - attr(*, "already-done")= logi TRUE
[16:12:33.241] - copied ‘weight’ to environment
[16:12:33.241] - copied ‘group’ to environment
[16:12:33.241] assign_globals() ... done
[16:12:33.241] requestCore(): workers = 2
[16:12:33.243] MulticoreFuture started
[16:12:33.243] - Launch lazy future ... done
[16:12:33.243] run() for ‘MulticoreFuture’ ... done
[16:12:33.244] plan(): Setting new future strategy stack:
[16:12:33.244] List of future strategies:
[16:12:33.244] 1. sequential:
[16:12:33.244]    - args: function (..., envir = parent.frame())
[16:12:33.244]    - tweaked: FALSE
[16:12:33.244]    - call: NULL
[16:12:33.245] plan(): nbrOfWorkers() = 1
[16:12:33.249] plan(): Setting new future strategy stack:
[16:12:33.249] List of future strategies:
[16:12:33.249] 1. multicore:
[16:12:33.249]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:33.249]    - tweaked: FALSE
[16:12:33.249]    - call: plan(strategy)
[16:12:33.254] plan(): nbrOfWorkers() = 2

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[16:12:33.258] getGlobalsAndPackages() ...
[16:12:33.258] Searching for globals...
[16:12:33.263] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:12:33.263] Searching for globals ... DONE
[16:12:33.263] Resolving globals: FALSE
[16:12:33.264] The total size of the 2 globals is 896 bytes (896 bytes)
[16:12:33.264] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:12:33.265] - globals: [2] ‘weight’, ‘group’
[16:12:33.265] - packages: [1] ‘stats’
[16:12:33.265] getGlobalsAndPackages() ... DONE
[16:12:33.265] run() for ‘Future’ ...
[16:12:33.265] - state: ‘created’
[16:12:33.266] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:33.270] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:33.270] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:33.270]   - Field: ‘label’
[16:12:33.270]   - Field: ‘local’
[16:12:33.270]   - Field: ‘owner’
[16:12:33.270]   - Field: ‘envir’
[16:12:33.270]   - Field: ‘workers’
[16:12:33.271]   - Field: ‘packages’
[16:12:33.271]   - Field: ‘gc’
[16:12:33.271]   - Field: ‘job’
[16:12:33.271]   - Field: ‘conditions’
[16:12:33.271]   - Field: ‘expr’
[16:12:33.271]   - Field: ‘uuid’
[16:12:33.271]   - Field: ‘seed’
[16:12:33.271]   - Field: ‘version’
[16:12:33.271]   - Field: ‘result’
[16:12:33.272]   - Field: ‘asynchronous’
[16:12:33.272]   - Field: ‘calls’
[16:12:33.272]   - Field: ‘globals’
[16:12:33.272]   - Field: ‘stdout’
[16:12:33.272]   - Field: ‘earlySignal’
[16:12:33.272]   - Field: ‘lazy’
[16:12:33.272]   - Field: ‘state’
[16:12:33.273] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:33.273] - Launch lazy future ...
[16:12:33.273] Packages needed by the future expression (n = 1): ‘stats’
[16:12:33.273] Packages needed by future strategies (n = 0): <none>
[16:12:33.274] {
[16:12:33.274]     {
[16:12:33.274]         {
[16:12:33.274]             ...future.startTime <- base::Sys.time()
[16:12:33.274]             {
[16:12:33.274]                 {
[16:12:33.274]                   {
[16:12:33.274]                     {
[16:12:33.274]                       {
[16:12:33.274]                         base::local({
[16:12:33.274]                           has_future <- base::requireNamespace("future", 
[16:12:33.274]                             quietly = TRUE)
[16:12:33.274]                           if (has_future) {
[16:12:33.274]                             ns <- base::getNamespace("future")
[16:12:33.274]                             version <- ns[[".package"]][["version"]]
[16:12:33.274]                             if (is.null(version)) 
[16:12:33.274]                               version <- utils::packageVersion("future")
[16:12:33.274]                           }
[16:12:33.274]                           else {
[16:12:33.274]                             version <- NULL
[16:12:33.274]                           }
[16:12:33.274]                           if (!has_future || version < "1.8.0") {
[16:12:33.274]                             info <- base::c(r_version = base::gsub("R version ", 
[16:12:33.274]                               "", base::R.version$version.string), 
[16:12:33.274]                               platform = base::sprintf("%s (%s-bit)", 
[16:12:33.274]                                 base::R.version$platform, 8 * 
[16:12:33.274]                                   base::.Machine$sizeof.pointer), 
[16:12:33.274]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:33.274]                                 "release", "version")], collapse = " "), 
[16:12:33.274]                               hostname = base::Sys.info()[["nodename"]])
[16:12:33.274]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:12:33.274]                               info)
[16:12:33.274]                             info <- base::paste(info, collapse = "; ")
[16:12:33.274]                             if (!has_future) {
[16:12:33.274]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:33.274]                                 info)
[16:12:33.274]                             }
[16:12:33.274]                             else {
[16:12:33.274]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:33.274]                                 info, version)
[16:12:33.274]                             }
[16:12:33.274]                             base::stop(msg)
[16:12:33.274]                           }
[16:12:33.274]                         })
[16:12:33.274]                       }
[16:12:33.274]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:33.274]                       base::options(mc.cores = 1L)
[16:12:33.274]                     }
[16:12:33.274]                     base::local({
[16:12:33.274]                       for (pkg in "stats") {
[16:12:33.274]                         base::loadNamespace(pkg)
[16:12:33.274]                         base::library(pkg, character.only = TRUE)
[16:12:33.274]                       }
[16:12:33.274]                     })
[16:12:33.274]                   }
[16:12:33.274]                   options(future.plan = NULL)
[16:12:33.274]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:33.274]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:33.274]                 }
[16:12:33.274]                 ...future.workdir <- getwd()
[16:12:33.274]             }
[16:12:33.274]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:33.274]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:33.274]         }
[16:12:33.274]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:33.274]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:33.274]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:33.274]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:33.274]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:33.274]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:33.274]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:33.274]             base::names(...future.oldOptions))
[16:12:33.274]     }
[16:12:33.274]     if (FALSE) {
[16:12:33.274]     }
[16:12:33.274]     else {
[16:12:33.274]         if (TRUE) {
[16:12:33.274]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:33.274]                 open = "w")
[16:12:33.274]         }
[16:12:33.274]         else {
[16:12:33.274]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:33.274]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:33.274]         }
[16:12:33.274]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:33.274]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:33.274]             base::sink(type = "output", split = FALSE)
[16:12:33.274]             base::close(...future.stdout)
[16:12:33.274]         }, add = TRUE)
[16:12:33.274]     }
[16:12:33.274]     ...future.frame <- base::sys.nframe()
[16:12:33.274]     ...future.conditions <- base::list()
[16:12:33.274]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:33.274]     if (FALSE) {
[16:12:33.274]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:33.274]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:33.274]     }
[16:12:33.274]     ...future.result <- base::tryCatch({
[16:12:33.274]         base::withCallingHandlers({
[16:12:33.274]             ...future.value <- base::withVisible(base::local({
[16:12:33.274]                 withCallingHandlers({
[16:12:33.274]                   {
[16:12:33.274]                     lm(weight ~ group - 1)
[16:12:33.274]                   }
[16:12:33.274]                 }, immediateCondition = function(cond) {
[16:12:33.274]                   save_rds <- function (object, pathname, ...) 
[16:12:33.274]                   {
[16:12:33.274]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:33.274]                     if (file_test("-f", pathname_tmp)) {
[16:12:33.274]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.274]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:33.274]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.274]                         fi_tmp[["mtime"]])
[16:12:33.274]                     }
[16:12:33.274]                     tryCatch({
[16:12:33.274]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:33.274]                     }, error = function(ex) {
[16:12:33.274]                       msg <- conditionMessage(ex)
[16:12:33.274]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.274]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:33.274]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.274]                         fi_tmp[["mtime"]], msg)
[16:12:33.274]                       ex$message <- msg
[16:12:33.274]                       stop(ex)
[16:12:33.274]                     })
[16:12:33.274]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:33.274]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:33.274]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:33.274]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.274]                       fi <- file.info(pathname)
[16:12:33.274]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:33.274]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.274]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:33.274]                         fi[["size"]], fi[["mtime"]])
[16:12:33.274]                       stop(msg)
[16:12:33.274]                     }
[16:12:33.274]                     invisible(pathname)
[16:12:33.274]                   }
[16:12:33.274]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:33.274]                     rootPath = tempdir()) 
[16:12:33.274]                   {
[16:12:33.274]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:33.274]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:33.274]                       tmpdir = path, fileext = ".rds")
[16:12:33.274]                     save_rds(obj, file)
[16:12:33.274]                   }
[16:12:33.274]                   saveImmediateCondition(cond, path = "/tmp/RtmpjVCO6F/.future/immediateConditions")
[16:12:33.274]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.274]                   {
[16:12:33.274]                     inherits <- base::inherits
[16:12:33.274]                     invokeRestart <- base::invokeRestart
[16:12:33.274]                     is.null <- base::is.null
[16:12:33.274]                     muffled <- FALSE
[16:12:33.274]                     if (inherits(cond, "message")) {
[16:12:33.274]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:33.274]                       if (muffled) 
[16:12:33.274]                         invokeRestart("muffleMessage")
[16:12:33.274]                     }
[16:12:33.274]                     else if (inherits(cond, "warning")) {
[16:12:33.274]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:33.274]                       if (muffled) 
[16:12:33.274]                         invokeRestart("muffleWarning")
[16:12:33.274]                     }
[16:12:33.274]                     else if (inherits(cond, "condition")) {
[16:12:33.274]                       if (!is.null(pattern)) {
[16:12:33.274]                         computeRestarts <- base::computeRestarts
[16:12:33.274]                         grepl <- base::grepl
[16:12:33.274]                         restarts <- computeRestarts(cond)
[16:12:33.274]                         for (restart in restarts) {
[16:12:33.274]                           name <- restart$name
[16:12:33.274]                           if (is.null(name)) 
[16:12:33.274]                             next
[16:12:33.274]                           if (!grepl(pattern, name)) 
[16:12:33.274]                             next
[16:12:33.274]                           invokeRestart(restart)
[16:12:33.274]                           muffled <- TRUE
[16:12:33.274]                           break
[16:12:33.274]                         }
[16:12:33.274]                       }
[16:12:33.274]                     }
[16:12:33.274]                     invisible(muffled)
[16:12:33.274]                   }
[16:12:33.274]                   muffleCondition(cond)
[16:12:33.274]                 })
[16:12:33.274]             }))
[16:12:33.274]             future::FutureResult(value = ...future.value$value, 
[16:12:33.274]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:33.274]                   ...future.rng), globalenv = if (FALSE) 
[16:12:33.274]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:33.274]                     ...future.globalenv.names))
[16:12:33.274]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:33.274]         }, condition = base::local({
[16:12:33.274]             c <- base::c
[16:12:33.274]             inherits <- base::inherits
[16:12:33.274]             invokeRestart <- base::invokeRestart
[16:12:33.274]             length <- base::length
[16:12:33.274]             list <- base::list
[16:12:33.274]             seq.int <- base::seq.int
[16:12:33.274]             signalCondition <- base::signalCondition
[16:12:33.274]             sys.calls <- base::sys.calls
[16:12:33.274]             `[[` <- base::`[[`
[16:12:33.274]             `+` <- base::`+`
[16:12:33.274]             `<<-` <- base::`<<-`
[16:12:33.274]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:33.274]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:33.274]                   3L)]
[16:12:33.274]             }
[16:12:33.274]             function(cond) {
[16:12:33.274]                 is_error <- inherits(cond, "error")
[16:12:33.274]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:33.274]                   NULL)
[16:12:33.274]                 if (is_error) {
[16:12:33.274]                   sessionInformation <- function() {
[16:12:33.274]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:33.274]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:33.274]                       search = base::search(), system = base::Sys.info())
[16:12:33.274]                   }
[16:12:33.274]                   ...future.conditions[[length(...future.conditions) + 
[16:12:33.274]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:33.274]                     cond$call), session = sessionInformation(), 
[16:12:33.274]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:33.274]                   signalCondition(cond)
[16:12:33.274]                 }
[16:12:33.274]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:33.274]                 "immediateCondition"))) {
[16:12:33.274]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:33.274]                   ...future.conditions[[length(...future.conditions) + 
[16:12:33.274]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:33.274]                   if (TRUE && !signal) {
[16:12:33.274]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.274]                     {
[16:12:33.274]                       inherits <- base::inherits
[16:12:33.274]                       invokeRestart <- base::invokeRestart
[16:12:33.274]                       is.null <- base::is.null
[16:12:33.274]                       muffled <- FALSE
[16:12:33.274]                       if (inherits(cond, "message")) {
[16:12:33.274]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:33.274]                         if (muffled) 
[16:12:33.274]                           invokeRestart("muffleMessage")
[16:12:33.274]                       }
[16:12:33.274]                       else if (inherits(cond, "warning")) {
[16:12:33.274]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:33.274]                         if (muffled) 
[16:12:33.274]                           invokeRestart("muffleWarning")
[16:12:33.274]                       }
[16:12:33.274]                       else if (inherits(cond, "condition")) {
[16:12:33.274]                         if (!is.null(pattern)) {
[16:12:33.274]                           computeRestarts <- base::computeRestarts
[16:12:33.274]                           grepl <- base::grepl
[16:12:33.274]                           restarts <- computeRestarts(cond)
[16:12:33.274]                           for (restart in restarts) {
[16:12:33.274]                             name <- restart$name
[16:12:33.274]                             if (is.null(name)) 
[16:12:33.274]                               next
[16:12:33.274]                             if (!grepl(pattern, name)) 
[16:12:33.274]                               next
[16:12:33.274]                             invokeRestart(restart)
[16:12:33.274]                             muffled <- TRUE
[16:12:33.274]                             break
[16:12:33.274]                           }
[16:12:33.274]                         }
[16:12:33.274]                       }
[16:12:33.274]                       invisible(muffled)
[16:12:33.274]                     }
[16:12:33.274]                     muffleCondition(cond, pattern = "^muffle")
[16:12:33.274]                   }
[16:12:33.274]                 }
[16:12:33.274]                 else {
[16:12:33.274]                   if (TRUE) {
[16:12:33.274]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.274]                     {
[16:12:33.274]                       inherits <- base::inherits
[16:12:33.274]                       invokeRestart <- base::invokeRestart
[16:12:33.274]                       is.null <- base::is.null
[16:12:33.274]                       muffled <- FALSE
[16:12:33.274]                       if (inherits(cond, "message")) {
[16:12:33.274]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:33.274]                         if (muffled) 
[16:12:33.274]                           invokeRestart("muffleMessage")
[16:12:33.274]                       }
[16:12:33.274]                       else if (inherits(cond, "warning")) {
[16:12:33.274]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:33.274]                         if (muffled) 
[16:12:33.274]                           invokeRestart("muffleWarning")
[16:12:33.274]                       }
[16:12:33.274]                       else if (inherits(cond, "condition")) {
[16:12:33.274]                         if (!is.null(pattern)) {
[16:12:33.274]                           computeRestarts <- base::computeRestarts
[16:12:33.274]                           grepl <- base::grepl
[16:12:33.274]                           restarts <- computeRestarts(cond)
[16:12:33.274]                           for (restart in restarts) {
[16:12:33.274]                             name <- restart$name
[16:12:33.274]                             if (is.null(name)) 
[16:12:33.274]                               next
[16:12:33.274]                             if (!grepl(pattern, name)) 
[16:12:33.274]                               next
[16:12:33.274]                             invokeRestart(restart)
[16:12:33.274]                             muffled <- TRUE
[16:12:33.274]                             break
[16:12:33.274]                           }
[16:12:33.274]                         }
[16:12:33.274]                       }
[16:12:33.274]                       invisible(muffled)
[16:12:33.274]                     }
[16:12:33.274]                     muffleCondition(cond, pattern = "^muffle")
[16:12:33.274]                   }
[16:12:33.274]                 }
[16:12:33.274]             }
[16:12:33.274]         }))
[16:12:33.274]     }, error = function(ex) {
[16:12:33.274]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:33.274]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:33.274]                 ...future.rng), started = ...future.startTime, 
[16:12:33.274]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:33.274]             version = "1.8"), class = "FutureResult")
[16:12:33.274]     }, finally = {
[16:12:33.274]         if (!identical(...future.workdir, getwd())) 
[16:12:33.274]             setwd(...future.workdir)
[16:12:33.274]         {
[16:12:33.274]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:33.274]                 ...future.oldOptions$nwarnings <- NULL
[16:12:33.274]             }
[16:12:33.274]             base::options(...future.oldOptions)
[16:12:33.274]             if (.Platform$OS.type == "windows") {
[16:12:33.274]                 old_names <- names(...future.oldEnvVars)
[16:12:33.274]                 envs <- base::Sys.getenv()
[16:12:33.274]                 names <- names(envs)
[16:12:33.274]                 common <- intersect(names, old_names)
[16:12:33.274]                 added <- setdiff(names, old_names)
[16:12:33.274]                 removed <- setdiff(old_names, names)
[16:12:33.274]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:33.274]                   envs[common]]
[16:12:33.274]                 NAMES <- toupper(changed)
[16:12:33.274]                 args <- list()
[16:12:33.274]                 for (kk in seq_along(NAMES)) {
[16:12:33.274]                   name <- changed[[kk]]
[16:12:33.274]                   NAME <- NAMES[[kk]]
[16:12:33.274]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.274]                     next
[16:12:33.274]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:33.274]                 }
[16:12:33.274]                 NAMES <- toupper(added)
[16:12:33.274]                 for (kk in seq_along(NAMES)) {
[16:12:33.274]                   name <- added[[kk]]
[16:12:33.274]                   NAME <- NAMES[[kk]]
[16:12:33.274]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.274]                     next
[16:12:33.274]                   args[[name]] <- ""
[16:12:33.274]                 }
[16:12:33.274]                 NAMES <- toupper(removed)
[16:12:33.274]                 for (kk in seq_along(NAMES)) {
[16:12:33.274]                   name <- removed[[kk]]
[16:12:33.274]                   NAME <- NAMES[[kk]]
[16:12:33.274]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.274]                     next
[16:12:33.274]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:33.274]                 }
[16:12:33.274]                 if (length(args) > 0) 
[16:12:33.274]                   base::do.call(base::Sys.setenv, args = args)
[16:12:33.274]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:33.274]             }
[16:12:33.274]             else {
[16:12:33.274]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:33.274]             }
[16:12:33.274]             {
[16:12:33.274]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:33.274]                   0L) {
[16:12:33.274]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:33.274]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:33.274]                   base::options(opts)
[16:12:33.274]                 }
[16:12:33.274]                 {
[16:12:33.274]                   {
[16:12:33.274]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:33.274]                     NULL
[16:12:33.274]                   }
[16:12:33.274]                   options(future.plan = NULL)
[16:12:33.274]                   if (is.na(NA_character_)) 
[16:12:33.274]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:33.274]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:33.274]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:33.274]                     envir = parent.frame()) 
[16:12:33.274]                   {
[16:12:33.274]                     default_workers <- missing(workers)
[16:12:33.274]                     if (is.function(workers)) 
[16:12:33.274]                       workers <- workers()
[16:12:33.274]                     workers <- structure(as.integer(workers), 
[16:12:33.274]                       class = class(workers))
[16:12:33.274]                     stop_if_not(is.finite(workers), workers >= 
[16:12:33.274]                       1L)
[16:12:33.274]                     if ((workers == 1L && !inherits(workers, 
[16:12:33.274]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:33.274]                       if (default_workers) 
[16:12:33.274]                         supportsMulticore(warn = TRUE)
[16:12:33.274]                       return(sequential(..., envir = envir))
[16:12:33.274]                     }
[16:12:33.274]                     oopts <- options(mc.cores = workers)
[16:12:33.274]                     on.exit(options(oopts))
[16:12:33.274]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:33.274]                       envir = envir)
[16:12:33.274]                     if (!future$lazy) 
[16:12:33.274]                       future <- run(future)
[16:12:33.274]                     invisible(future)
[16:12:33.274]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:33.274]                 }
[16:12:33.274]             }
[16:12:33.274]         }
[16:12:33.274]     })
[16:12:33.274]     if (TRUE) {
[16:12:33.274]         base::sink(type = "output", split = FALSE)
[16:12:33.274]         if (TRUE) {
[16:12:33.274]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:33.274]         }
[16:12:33.274]         else {
[16:12:33.274]             ...future.result["stdout"] <- base::list(NULL)
[16:12:33.274]         }
[16:12:33.274]         base::close(...future.stdout)
[16:12:33.274]         ...future.stdout <- NULL
[16:12:33.274]     }
[16:12:33.274]     ...future.result$conditions <- ...future.conditions
[16:12:33.274]     ...future.result$finished <- base::Sys.time()
[16:12:33.274]     ...future.result
[16:12:33.274] }
[16:12:33.276] assign_globals() ...
[16:12:33.276] List of 2
[16:12:33.276]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[16:12:33.276]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[16:12:33.276]  - attr(*, "where")=List of 2
[16:12:33.276]   ..$ weight:<environment: R_EmptyEnv> 
[16:12:33.276]   ..$ group :<environment: R_EmptyEnv> 
[16:12:33.276]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:33.276]  - attr(*, "resolved")= logi FALSE
[16:12:33.276]  - attr(*, "total_size")= num 896
[16:12:33.276]  - attr(*, "already-done")= logi TRUE
[16:12:33.280] - copied ‘weight’ to environment
[16:12:33.280] - copied ‘group’ to environment
[16:12:33.280] assign_globals() ... done
[16:12:33.280] requestCore(): workers = 2
[16:12:33.282] MulticoreFuture started
[16:12:33.282] - Launch lazy future ... done
[16:12:33.283] run() for ‘MulticoreFuture’ ... done
[16:12:33.284] plan(): Setting new future strategy stack:
[16:12:33.284] List of future strategies:
[16:12:33.284] 1. sequential:
[16:12:33.284]    - args: function (..., envir = parent.frame())
[16:12:33.284]    - tweaked: FALSE
[16:12:33.284]    - call: NULL
[16:12:33.285] plan(): nbrOfWorkers() = 1
[16:12:33.288] plan(): Setting new future strategy stack:
[16:12:33.288] List of future strategies:
[16:12:33.288] 1. multicore:
[16:12:33.288]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:33.288]    - tweaked: FALSE
[16:12:33.288]    - call: plan(strategy)
[16:12:33.293] plan(): nbrOfWorkers() = 2

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[16:12:33.297] getGlobalsAndPackages() ...
[16:12:33.298] Searching for globals...
[16:12:33.299] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[16:12:33.299] Searching for globals ... DONE
[16:12:33.299] Resolving globals: FALSE
[16:12:33.300] The total size of the 1 globals is 96 bytes (96 bytes)
[16:12:33.300] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[16:12:33.301] - globals: [1] ‘x’
[16:12:33.301] - packages: [1] ‘stats’
[16:12:33.301] getGlobalsAndPackages() ... DONE
[16:12:33.301] run() for ‘Future’ ...
[16:12:33.301] - state: ‘created’
[16:12:33.301] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:33.306] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:33.306] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:33.308]   - Field: ‘label’
[16:12:33.308]   - Field: ‘local’
[16:12:33.308]   - Field: ‘owner’
[16:12:33.309]   - Field: ‘envir’
[16:12:33.309]   - Field: ‘workers’
[16:12:33.309]   - Field: ‘packages’
[16:12:33.309]   - Field: ‘gc’
[16:12:33.309]   - Field: ‘job’
[16:12:33.309]   - Field: ‘conditions’
[16:12:33.310]   - Field: ‘expr’
[16:12:33.310]   - Field: ‘uuid’
[16:12:33.310]   - Field: ‘seed’
[16:12:33.310]   - Field: ‘version’
[16:12:33.310]   - Field: ‘result’
[16:12:33.310]   - Field: ‘asynchronous’
[16:12:33.310]   - Field: ‘calls’
[16:12:33.310]   - Field: ‘globals’
[16:12:33.310]   - Field: ‘stdout’
[16:12:33.311]   - Field: ‘earlySignal’
[16:12:33.311]   - Field: ‘lazy’
[16:12:33.311]   - Field: ‘state’
[16:12:33.311] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:33.311] - Launch lazy future ...
[16:12:33.311] Packages needed by the future expression (n = 1): ‘stats’
[16:12:33.312] Packages needed by future strategies (n = 0): <none>
[16:12:33.312] {
[16:12:33.312]     {
[16:12:33.312]         {
[16:12:33.312]             ...future.startTime <- base::Sys.time()
[16:12:33.312]             {
[16:12:33.312]                 {
[16:12:33.312]                   {
[16:12:33.312]                     {
[16:12:33.312]                       {
[16:12:33.312]                         base::local({
[16:12:33.312]                           has_future <- base::requireNamespace("future", 
[16:12:33.312]                             quietly = TRUE)
[16:12:33.312]                           if (has_future) {
[16:12:33.312]                             ns <- base::getNamespace("future")
[16:12:33.312]                             version <- ns[[".package"]][["version"]]
[16:12:33.312]                             if (is.null(version)) 
[16:12:33.312]                               version <- utils::packageVersion("future")
[16:12:33.312]                           }
[16:12:33.312]                           else {
[16:12:33.312]                             version <- NULL
[16:12:33.312]                           }
[16:12:33.312]                           if (!has_future || version < "1.8.0") {
[16:12:33.312]                             info <- base::c(r_version = base::gsub("R version ", 
[16:12:33.312]                               "", base::R.version$version.string), 
[16:12:33.312]                               platform = base::sprintf("%s (%s-bit)", 
[16:12:33.312]                                 base::R.version$platform, 8 * 
[16:12:33.312]                                   base::.Machine$sizeof.pointer), 
[16:12:33.312]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:33.312]                                 "release", "version")], collapse = " "), 
[16:12:33.312]                               hostname = base::Sys.info()[["nodename"]])
[16:12:33.312]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:12:33.312]                               info)
[16:12:33.312]                             info <- base::paste(info, collapse = "; ")
[16:12:33.312]                             if (!has_future) {
[16:12:33.312]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:33.312]                                 info)
[16:12:33.312]                             }
[16:12:33.312]                             else {
[16:12:33.312]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:33.312]                                 info, version)
[16:12:33.312]                             }
[16:12:33.312]                             base::stop(msg)
[16:12:33.312]                           }
[16:12:33.312]                         })
[16:12:33.312]                       }
[16:12:33.312]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:33.312]                       base::options(mc.cores = 1L)
[16:12:33.312]                     }
[16:12:33.312]                     base::local({
[16:12:33.312]                       for (pkg in "stats") {
[16:12:33.312]                         base::loadNamespace(pkg)
[16:12:33.312]                         base::library(pkg, character.only = TRUE)
[16:12:33.312]                       }
[16:12:33.312]                     })
[16:12:33.312]                   }
[16:12:33.312]                   options(future.plan = NULL)
[16:12:33.312]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:33.312]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:33.312]                 }
[16:12:33.312]                 ...future.workdir <- getwd()
[16:12:33.312]             }
[16:12:33.312]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:33.312]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:33.312]         }
[16:12:33.312]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:33.312]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:33.312]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:33.312]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:33.312]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:33.312]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:33.312]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:33.312]             base::names(...future.oldOptions))
[16:12:33.312]     }
[16:12:33.312]     if (FALSE) {
[16:12:33.312]     }
[16:12:33.312]     else {
[16:12:33.312]         if (TRUE) {
[16:12:33.312]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:33.312]                 open = "w")
[16:12:33.312]         }
[16:12:33.312]         else {
[16:12:33.312]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:33.312]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:33.312]         }
[16:12:33.312]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:33.312]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:33.312]             base::sink(type = "output", split = FALSE)
[16:12:33.312]             base::close(...future.stdout)
[16:12:33.312]         }, add = TRUE)
[16:12:33.312]     }
[16:12:33.312]     ...future.frame <- base::sys.nframe()
[16:12:33.312]     ...future.conditions <- base::list()
[16:12:33.312]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:33.312]     if (FALSE) {
[16:12:33.312]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:33.312]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:33.312]     }
[16:12:33.312]     ...future.result <- base::tryCatch({
[16:12:33.312]         base::withCallingHandlers({
[16:12:33.312]             ...future.value <- base::withVisible(base::local({
[16:12:33.312]                 withCallingHandlers({
[16:12:33.312]                   {
[16:12:33.312]                     xtabs(~x)
[16:12:33.312]                   }
[16:12:33.312]                 }, immediateCondition = function(cond) {
[16:12:33.312]                   save_rds <- function (object, pathname, ...) 
[16:12:33.312]                   {
[16:12:33.312]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:33.312]                     if (file_test("-f", pathname_tmp)) {
[16:12:33.312]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.312]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:33.312]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.312]                         fi_tmp[["mtime"]])
[16:12:33.312]                     }
[16:12:33.312]                     tryCatch({
[16:12:33.312]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:33.312]                     }, error = function(ex) {
[16:12:33.312]                       msg <- conditionMessage(ex)
[16:12:33.312]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.312]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:33.312]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.312]                         fi_tmp[["mtime"]], msg)
[16:12:33.312]                       ex$message <- msg
[16:12:33.312]                       stop(ex)
[16:12:33.312]                     })
[16:12:33.312]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:33.312]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:33.312]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:33.312]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.312]                       fi <- file.info(pathname)
[16:12:33.312]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:33.312]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.312]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:33.312]                         fi[["size"]], fi[["mtime"]])
[16:12:33.312]                       stop(msg)
[16:12:33.312]                     }
[16:12:33.312]                     invisible(pathname)
[16:12:33.312]                   }
[16:12:33.312]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:33.312]                     rootPath = tempdir()) 
[16:12:33.312]                   {
[16:12:33.312]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:33.312]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:33.312]                       tmpdir = path, fileext = ".rds")
[16:12:33.312]                     save_rds(obj, file)
[16:12:33.312]                   }
[16:12:33.312]                   saveImmediateCondition(cond, path = "/tmp/RtmpjVCO6F/.future/immediateConditions")
[16:12:33.312]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.312]                   {
[16:12:33.312]                     inherits <- base::inherits
[16:12:33.312]                     invokeRestart <- base::invokeRestart
[16:12:33.312]                     is.null <- base::is.null
[16:12:33.312]                     muffled <- FALSE
[16:12:33.312]                     if (inherits(cond, "message")) {
[16:12:33.312]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:33.312]                       if (muffled) 
[16:12:33.312]                         invokeRestart("muffleMessage")
[16:12:33.312]                     }
[16:12:33.312]                     else if (inherits(cond, "warning")) {
[16:12:33.312]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:33.312]                       if (muffled) 
[16:12:33.312]                         invokeRestart("muffleWarning")
[16:12:33.312]                     }
[16:12:33.312]                     else if (inherits(cond, "condition")) {
[16:12:33.312]                       if (!is.null(pattern)) {
[16:12:33.312]                         computeRestarts <- base::computeRestarts
[16:12:33.312]                         grepl <- base::grepl
[16:12:33.312]                         restarts <- computeRestarts(cond)
[16:12:33.312]                         for (restart in restarts) {
[16:12:33.312]                           name <- restart$name
[16:12:33.312]                           if (is.null(name)) 
[16:12:33.312]                             next
[16:12:33.312]                           if (!grepl(pattern, name)) 
[16:12:33.312]                             next
[16:12:33.312]                           invokeRestart(restart)
[16:12:33.312]                           muffled <- TRUE
[16:12:33.312]                           break
[16:12:33.312]                         }
[16:12:33.312]                       }
[16:12:33.312]                     }
[16:12:33.312]                     invisible(muffled)
[16:12:33.312]                   }
[16:12:33.312]                   muffleCondition(cond)
[16:12:33.312]                 })
[16:12:33.312]             }))
[16:12:33.312]             future::FutureResult(value = ...future.value$value, 
[16:12:33.312]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:33.312]                   ...future.rng), globalenv = if (FALSE) 
[16:12:33.312]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:33.312]                     ...future.globalenv.names))
[16:12:33.312]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:33.312]         }, condition = base::local({
[16:12:33.312]             c <- base::c
[16:12:33.312]             inherits <- base::inherits
[16:12:33.312]             invokeRestart <- base::invokeRestart
[16:12:33.312]             length <- base::length
[16:12:33.312]             list <- base::list
[16:12:33.312]             seq.int <- base::seq.int
[16:12:33.312]             signalCondition <- base::signalCondition
[16:12:33.312]             sys.calls <- base::sys.calls
[16:12:33.312]             `[[` <- base::`[[`
[16:12:33.312]             `+` <- base::`+`
[16:12:33.312]             `<<-` <- base::`<<-`
[16:12:33.312]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:33.312]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:33.312]                   3L)]
[16:12:33.312]             }
[16:12:33.312]             function(cond) {
[16:12:33.312]                 is_error <- inherits(cond, "error")
[16:12:33.312]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:33.312]                   NULL)
[16:12:33.312]                 if (is_error) {
[16:12:33.312]                   sessionInformation <- function() {
[16:12:33.312]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:33.312]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:33.312]                       search = base::search(), system = base::Sys.info())
[16:12:33.312]                   }
[16:12:33.312]                   ...future.conditions[[length(...future.conditions) + 
[16:12:33.312]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:33.312]                     cond$call), session = sessionInformation(), 
[16:12:33.312]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:33.312]                   signalCondition(cond)
[16:12:33.312]                 }
[16:12:33.312]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:33.312]                 "immediateCondition"))) {
[16:12:33.312]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:33.312]                   ...future.conditions[[length(...future.conditions) + 
[16:12:33.312]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:33.312]                   if (TRUE && !signal) {
[16:12:33.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.312]                     {
[16:12:33.312]                       inherits <- base::inherits
[16:12:33.312]                       invokeRestart <- base::invokeRestart
[16:12:33.312]                       is.null <- base::is.null
[16:12:33.312]                       muffled <- FALSE
[16:12:33.312]                       if (inherits(cond, "message")) {
[16:12:33.312]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:33.312]                         if (muffled) 
[16:12:33.312]                           invokeRestart("muffleMessage")
[16:12:33.312]                       }
[16:12:33.312]                       else if (inherits(cond, "warning")) {
[16:12:33.312]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:33.312]                         if (muffled) 
[16:12:33.312]                           invokeRestart("muffleWarning")
[16:12:33.312]                       }
[16:12:33.312]                       else if (inherits(cond, "condition")) {
[16:12:33.312]                         if (!is.null(pattern)) {
[16:12:33.312]                           computeRestarts <- base::computeRestarts
[16:12:33.312]                           grepl <- base::grepl
[16:12:33.312]                           restarts <- computeRestarts(cond)
[16:12:33.312]                           for (restart in restarts) {
[16:12:33.312]                             name <- restart$name
[16:12:33.312]                             if (is.null(name)) 
[16:12:33.312]                               next
[16:12:33.312]                             if (!grepl(pattern, name)) 
[16:12:33.312]                               next
[16:12:33.312]                             invokeRestart(restart)
[16:12:33.312]                             muffled <- TRUE
[16:12:33.312]                             break
[16:12:33.312]                           }
[16:12:33.312]                         }
[16:12:33.312]                       }
[16:12:33.312]                       invisible(muffled)
[16:12:33.312]                     }
[16:12:33.312]                     muffleCondition(cond, pattern = "^muffle")
[16:12:33.312]                   }
[16:12:33.312]                 }
[16:12:33.312]                 else {
[16:12:33.312]                   if (TRUE) {
[16:12:33.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.312]                     {
[16:12:33.312]                       inherits <- base::inherits
[16:12:33.312]                       invokeRestart <- base::invokeRestart
[16:12:33.312]                       is.null <- base::is.null
[16:12:33.312]                       muffled <- FALSE
[16:12:33.312]                       if (inherits(cond, "message")) {
[16:12:33.312]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:33.312]                         if (muffled) 
[16:12:33.312]                           invokeRestart("muffleMessage")
[16:12:33.312]                       }
[16:12:33.312]                       else if (inherits(cond, "warning")) {
[16:12:33.312]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:33.312]                         if (muffled) 
[16:12:33.312]                           invokeRestart("muffleWarning")
[16:12:33.312]                       }
[16:12:33.312]                       else if (inherits(cond, "condition")) {
[16:12:33.312]                         if (!is.null(pattern)) {
[16:12:33.312]                           computeRestarts <- base::computeRestarts
[16:12:33.312]                           grepl <- base::grepl
[16:12:33.312]                           restarts <- computeRestarts(cond)
[16:12:33.312]                           for (restart in restarts) {
[16:12:33.312]                             name <- restart$name
[16:12:33.312]                             if (is.null(name)) 
[16:12:33.312]                               next
[16:12:33.312]                             if (!grepl(pattern, name)) 
[16:12:33.312]                               next
[16:12:33.312]                             invokeRestart(restart)
[16:12:33.312]                             muffled <- TRUE
[16:12:33.312]                             break
[16:12:33.312]                           }
[16:12:33.312]                         }
[16:12:33.312]                       }
[16:12:33.312]                       invisible(muffled)
[16:12:33.312]                     }
[16:12:33.312]                     muffleCondition(cond, pattern = "^muffle")
[16:12:33.312]                   }
[16:12:33.312]                 }
[16:12:33.312]             }
[16:12:33.312]         }))
[16:12:33.312]     }, error = function(ex) {
[16:12:33.312]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:33.312]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:33.312]                 ...future.rng), started = ...future.startTime, 
[16:12:33.312]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:33.312]             version = "1.8"), class = "FutureResult")
[16:12:33.312]     }, finally = {
[16:12:33.312]         if (!identical(...future.workdir, getwd())) 
[16:12:33.312]             setwd(...future.workdir)
[16:12:33.312]         {
[16:12:33.312]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:33.312]                 ...future.oldOptions$nwarnings <- NULL
[16:12:33.312]             }
[16:12:33.312]             base::options(...future.oldOptions)
[16:12:33.312]             if (.Platform$OS.type == "windows") {
[16:12:33.312]                 old_names <- names(...future.oldEnvVars)
[16:12:33.312]                 envs <- base::Sys.getenv()
[16:12:33.312]                 names <- names(envs)
[16:12:33.312]                 common <- intersect(names, old_names)
[16:12:33.312]                 added <- setdiff(names, old_names)
[16:12:33.312]                 removed <- setdiff(old_names, names)
[16:12:33.312]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:33.312]                   envs[common]]
[16:12:33.312]                 NAMES <- toupper(changed)
[16:12:33.312]                 args <- list()
[16:12:33.312]                 for (kk in seq_along(NAMES)) {
[16:12:33.312]                   name <- changed[[kk]]
[16:12:33.312]                   NAME <- NAMES[[kk]]
[16:12:33.312]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.312]                     next
[16:12:33.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:33.312]                 }
[16:12:33.312]                 NAMES <- toupper(added)
[16:12:33.312]                 for (kk in seq_along(NAMES)) {
[16:12:33.312]                   name <- added[[kk]]
[16:12:33.312]                   NAME <- NAMES[[kk]]
[16:12:33.312]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.312]                     next
[16:12:33.312]                   args[[name]] <- ""
[16:12:33.312]                 }
[16:12:33.312]                 NAMES <- toupper(removed)
[16:12:33.312]                 for (kk in seq_along(NAMES)) {
[16:12:33.312]                   name <- removed[[kk]]
[16:12:33.312]                   NAME <- NAMES[[kk]]
[16:12:33.312]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.312]                     next
[16:12:33.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:33.312]                 }
[16:12:33.312]                 if (length(args) > 0) 
[16:12:33.312]                   base::do.call(base::Sys.setenv, args = args)
[16:12:33.312]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:33.312]             }
[16:12:33.312]             else {
[16:12:33.312]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:33.312]             }
[16:12:33.312]             {
[16:12:33.312]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:33.312]                   0L) {
[16:12:33.312]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:33.312]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:33.312]                   base::options(opts)
[16:12:33.312]                 }
[16:12:33.312]                 {
[16:12:33.312]                   {
[16:12:33.312]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:33.312]                     NULL
[16:12:33.312]                   }
[16:12:33.312]                   options(future.plan = NULL)
[16:12:33.312]                   if (is.na(NA_character_)) 
[16:12:33.312]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:33.312]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:33.312]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:33.312]                     envir = parent.frame()) 
[16:12:33.312]                   {
[16:12:33.312]                     default_workers <- missing(workers)
[16:12:33.312]                     if (is.function(workers)) 
[16:12:33.312]                       workers <- workers()
[16:12:33.312]                     workers <- structure(as.integer(workers), 
[16:12:33.312]                       class = class(workers))
[16:12:33.312]                     stop_if_not(is.finite(workers), workers >= 
[16:12:33.312]                       1L)
[16:12:33.312]                     if ((workers == 1L && !inherits(workers, 
[16:12:33.312]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:33.312]                       if (default_workers) 
[16:12:33.312]                         supportsMulticore(warn = TRUE)
[16:12:33.312]                       return(sequential(..., envir = envir))
[16:12:33.312]                     }
[16:12:33.312]                     oopts <- options(mc.cores = workers)
[16:12:33.312]                     on.exit(options(oopts))
[16:12:33.312]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:33.312]                       envir = envir)
[16:12:33.312]                     if (!future$lazy) 
[16:12:33.312]                       future <- run(future)
[16:12:33.312]                     invisible(future)
[16:12:33.312]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:33.312]                 }
[16:12:33.312]             }
[16:12:33.312]         }
[16:12:33.312]     })
[16:12:33.312]     if (TRUE) {
[16:12:33.312]         base::sink(type = "output", split = FALSE)
[16:12:33.312]         if (TRUE) {
[16:12:33.312]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:33.312]         }
[16:12:33.312]         else {
[16:12:33.312]             ...future.result["stdout"] <- base::list(NULL)
[16:12:33.312]         }
[16:12:33.312]         base::close(...future.stdout)
[16:12:33.312]         ...future.stdout <- NULL
[16:12:33.312]     }
[16:12:33.312]     ...future.result$conditions <- ...future.conditions
[16:12:33.312]     ...future.result$finished <- base::Sys.time()
[16:12:33.312]     ...future.result
[16:12:33.312] }
[16:12:33.315] assign_globals() ...
[16:12:33.315] List of 1
[16:12:33.315]  $ x: num [1:5] 1 1 2 2 2
[16:12:33.315]  - attr(*, "where")=List of 1
[16:12:33.315]   ..$ x:<environment: R_EmptyEnv> 
[16:12:33.315]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:33.315]  - attr(*, "resolved")= logi FALSE
[16:12:33.315]  - attr(*, "total_size")= num 96
[16:12:33.315]  - attr(*, "already-done")= logi TRUE
[16:12:33.318] - copied ‘x’ to environment
[16:12:33.318] assign_globals() ... done
[16:12:33.318] requestCore(): workers = 2
[16:12:33.320] MulticoreFuture started
[16:12:33.320] - Launch lazy future ... done
[16:12:33.321] run() for ‘MulticoreFuture’ ... done
[16:12:33.321] plan(): Setting new future strategy stack:
[16:12:33.322] List of future strategies:
[16:12:33.322] 1. sequential:
[16:12:33.322]    - args: function (..., envir = parent.frame())
[16:12:33.322]    - tweaked: FALSE
[16:12:33.322]    - call: NULL
[16:12:33.323] plan(): nbrOfWorkers() = 1
[16:12:33.325] plan(): Setting new future strategy stack:
[16:12:33.326] List of future strategies:
[16:12:33.326] 1. multicore:
[16:12:33.326]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:33.326]    - tweaked: FALSE
[16:12:33.326]    - call: plan(strategy)
[16:12:33.330] plan(): nbrOfWorkers() = 2
x
1 2 
2 3 
[16:12:33.332] getGlobalsAndPackages() ...
[16:12:33.332] Searching for globals...
[16:12:33.334] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[16:12:33.334] Searching for globals ... DONE
[16:12:33.334] Resolving globals: FALSE
[16:12:33.335] The total size of the 1 globals is 96 bytes (96 bytes)
[16:12:33.335] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[16:12:33.336] - globals: [1] ‘x’
[16:12:33.336] - packages: [1] ‘stats’
[16:12:33.336] getGlobalsAndPackages() ... DONE
[16:12:33.336] run() for ‘Future’ ...
[16:12:33.336] - state: ‘created’
[16:12:33.337] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:33.340] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:33.341] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:33.341]   - Field: ‘label’
[16:12:33.341]   - Field: ‘local’
[16:12:33.341]   - Field: ‘owner’
[16:12:33.341]   - Field: ‘envir’
[16:12:33.341]   - Field: ‘workers’
[16:12:33.341]   - Field: ‘packages’
[16:12:33.341]   - Field: ‘gc’
[16:12:33.342]   - Field: ‘job’
[16:12:33.342]   - Field: ‘conditions’
[16:12:33.342]   - Field: ‘expr’
[16:12:33.342]   - Field: ‘uuid’
[16:12:33.342]   - Field: ‘seed’
[16:12:33.342]   - Field: ‘version’
[16:12:33.342]   - Field: ‘result’
[16:12:33.342]   - Field: ‘asynchronous’
[16:12:33.342]   - Field: ‘calls’
[16:12:33.343]   - Field: ‘globals’
[16:12:33.343]   - Field: ‘stdout’
[16:12:33.343]   - Field: ‘earlySignal’
[16:12:33.343]   - Field: ‘lazy’
[16:12:33.343]   - Field: ‘state’
[16:12:33.343] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:33.343] - Launch lazy future ...
[16:12:33.344] Packages needed by the future expression (n = 1): ‘stats’
[16:12:33.344] Packages needed by future strategies (n = 0): <none>
[16:12:33.344] {
[16:12:33.344]     {
[16:12:33.344]         {
[16:12:33.344]             ...future.startTime <- base::Sys.time()
[16:12:33.344]             {
[16:12:33.344]                 {
[16:12:33.344]                   {
[16:12:33.344]                     {
[16:12:33.344]                       {
[16:12:33.344]                         base::local({
[16:12:33.344]                           has_future <- base::requireNamespace("future", 
[16:12:33.344]                             quietly = TRUE)
[16:12:33.344]                           if (has_future) {
[16:12:33.344]                             ns <- base::getNamespace("future")
[16:12:33.344]                             version <- ns[[".package"]][["version"]]
[16:12:33.344]                             if (is.null(version)) 
[16:12:33.344]                               version <- utils::packageVersion("future")
[16:12:33.344]                           }
[16:12:33.344]                           else {
[16:12:33.344]                             version <- NULL
[16:12:33.344]                           }
[16:12:33.344]                           if (!has_future || version < "1.8.0") {
[16:12:33.344]                             info <- base::c(r_version = base::gsub("R version ", 
[16:12:33.344]                               "", base::R.version$version.string), 
[16:12:33.344]                               platform = base::sprintf("%s (%s-bit)", 
[16:12:33.344]                                 base::R.version$platform, 8 * 
[16:12:33.344]                                   base::.Machine$sizeof.pointer), 
[16:12:33.344]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:33.344]                                 "release", "version")], collapse = " "), 
[16:12:33.344]                               hostname = base::Sys.info()[["nodename"]])
[16:12:33.344]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:12:33.344]                               info)
[16:12:33.344]                             info <- base::paste(info, collapse = "; ")
[16:12:33.344]                             if (!has_future) {
[16:12:33.344]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:33.344]                                 info)
[16:12:33.344]                             }
[16:12:33.344]                             else {
[16:12:33.344]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:33.344]                                 info, version)
[16:12:33.344]                             }
[16:12:33.344]                             base::stop(msg)
[16:12:33.344]                           }
[16:12:33.344]                         })
[16:12:33.344]                       }
[16:12:33.344]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:33.344]                       base::options(mc.cores = 1L)
[16:12:33.344]                     }
[16:12:33.344]                     base::local({
[16:12:33.344]                       for (pkg in "stats") {
[16:12:33.344]                         base::loadNamespace(pkg)
[16:12:33.344]                         base::library(pkg, character.only = TRUE)
[16:12:33.344]                       }
[16:12:33.344]                     })
[16:12:33.344]                   }
[16:12:33.344]                   options(future.plan = NULL)
[16:12:33.344]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:33.344]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:33.344]                 }
[16:12:33.344]                 ...future.workdir <- getwd()
[16:12:33.344]             }
[16:12:33.344]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:33.344]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:33.344]         }
[16:12:33.344]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:33.344]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:33.344]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:33.344]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:33.344]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:33.344]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:33.344]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:33.344]             base::names(...future.oldOptions))
[16:12:33.344]     }
[16:12:33.344]     if (FALSE) {
[16:12:33.344]     }
[16:12:33.344]     else {
[16:12:33.344]         if (TRUE) {
[16:12:33.344]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:33.344]                 open = "w")
[16:12:33.344]         }
[16:12:33.344]         else {
[16:12:33.344]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:33.344]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:33.344]         }
[16:12:33.344]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:33.344]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:33.344]             base::sink(type = "output", split = FALSE)
[16:12:33.344]             base::close(...future.stdout)
[16:12:33.344]         }, add = TRUE)
[16:12:33.344]     }
[16:12:33.344]     ...future.frame <- base::sys.nframe()
[16:12:33.344]     ...future.conditions <- base::list()
[16:12:33.344]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:33.344]     if (FALSE) {
[16:12:33.344]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:33.344]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:33.344]     }
[16:12:33.344]     ...future.result <- base::tryCatch({
[16:12:33.344]         base::withCallingHandlers({
[16:12:33.344]             ...future.value <- base::withVisible(base::local({
[16:12:33.344]                 withCallingHandlers({
[16:12:33.344]                   {
[16:12:33.344]                     xtabs(~x)
[16:12:33.344]                   }
[16:12:33.344]                 }, immediateCondition = function(cond) {
[16:12:33.344]                   save_rds <- function (object, pathname, ...) 
[16:12:33.344]                   {
[16:12:33.344]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:33.344]                     if (file_test("-f", pathname_tmp)) {
[16:12:33.344]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.344]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:33.344]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.344]                         fi_tmp[["mtime"]])
[16:12:33.344]                     }
[16:12:33.344]                     tryCatch({
[16:12:33.344]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:33.344]                     }, error = function(ex) {
[16:12:33.344]                       msg <- conditionMessage(ex)
[16:12:33.344]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.344]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:33.344]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.344]                         fi_tmp[["mtime"]], msg)
[16:12:33.344]                       ex$message <- msg
[16:12:33.344]                       stop(ex)
[16:12:33.344]                     })
[16:12:33.344]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:33.344]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:33.344]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:33.344]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.344]                       fi <- file.info(pathname)
[16:12:33.344]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:33.344]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.344]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:33.344]                         fi[["size"]], fi[["mtime"]])
[16:12:33.344]                       stop(msg)
[16:12:33.344]                     }
[16:12:33.344]                     invisible(pathname)
[16:12:33.344]                   }
[16:12:33.344]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:33.344]                     rootPath = tempdir()) 
[16:12:33.344]                   {
[16:12:33.344]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:33.344]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:33.344]                       tmpdir = path, fileext = ".rds")
[16:12:33.344]                     save_rds(obj, file)
[16:12:33.344]                   }
[16:12:33.344]                   saveImmediateCondition(cond, path = "/tmp/RtmpjVCO6F/.future/immediateConditions")
[16:12:33.344]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.344]                   {
[16:12:33.344]                     inherits <- base::inherits
[16:12:33.344]                     invokeRestart <- base::invokeRestart
[16:12:33.344]                     is.null <- base::is.null
[16:12:33.344]                     muffled <- FALSE
[16:12:33.344]                     if (inherits(cond, "message")) {
[16:12:33.344]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:33.344]                       if (muffled) 
[16:12:33.344]                         invokeRestart("muffleMessage")
[16:12:33.344]                     }
[16:12:33.344]                     else if (inherits(cond, "warning")) {
[16:12:33.344]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:33.344]                       if (muffled) 
[16:12:33.344]                         invokeRestart("muffleWarning")
[16:12:33.344]                     }
[16:12:33.344]                     else if (inherits(cond, "condition")) {
[16:12:33.344]                       if (!is.null(pattern)) {
[16:12:33.344]                         computeRestarts <- base::computeRestarts
[16:12:33.344]                         grepl <- base::grepl
[16:12:33.344]                         restarts <- computeRestarts(cond)
[16:12:33.344]                         for (restart in restarts) {
[16:12:33.344]                           name <- restart$name
[16:12:33.344]                           if (is.null(name)) 
[16:12:33.344]                             next
[16:12:33.344]                           if (!grepl(pattern, name)) 
[16:12:33.344]                             next
[16:12:33.344]                           invokeRestart(restart)
[16:12:33.344]                           muffled <- TRUE
[16:12:33.344]                           break
[16:12:33.344]                         }
[16:12:33.344]                       }
[16:12:33.344]                     }
[16:12:33.344]                     invisible(muffled)
[16:12:33.344]                   }
[16:12:33.344]                   muffleCondition(cond)
[16:12:33.344]                 })
[16:12:33.344]             }))
[16:12:33.344]             future::FutureResult(value = ...future.value$value, 
[16:12:33.344]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:33.344]                   ...future.rng), globalenv = if (FALSE) 
[16:12:33.344]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:33.344]                     ...future.globalenv.names))
[16:12:33.344]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:33.344]         }, condition = base::local({
[16:12:33.344]             c <- base::c
[16:12:33.344]             inherits <- base::inherits
[16:12:33.344]             invokeRestart <- base::invokeRestart
[16:12:33.344]             length <- base::length
[16:12:33.344]             list <- base::list
[16:12:33.344]             seq.int <- base::seq.int
[16:12:33.344]             signalCondition <- base::signalCondition
[16:12:33.344]             sys.calls <- base::sys.calls
[16:12:33.344]             `[[` <- base::`[[`
[16:12:33.344]             `+` <- base::`+`
[16:12:33.344]             `<<-` <- base::`<<-`
[16:12:33.344]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:33.344]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:33.344]                   3L)]
[16:12:33.344]             }
[16:12:33.344]             function(cond) {
[16:12:33.344]                 is_error <- inherits(cond, "error")
[16:12:33.344]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:33.344]                   NULL)
[16:12:33.344]                 if (is_error) {
[16:12:33.344]                   sessionInformation <- function() {
[16:12:33.344]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:33.344]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:33.344]                       search = base::search(), system = base::Sys.info())
[16:12:33.344]                   }
[16:12:33.344]                   ...future.conditions[[length(...future.conditions) + 
[16:12:33.344]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:33.344]                     cond$call), session = sessionInformation(), 
[16:12:33.344]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:33.344]                   signalCondition(cond)
[16:12:33.344]                 }
[16:12:33.344]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:33.344]                 "immediateCondition"))) {
[16:12:33.344]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:33.344]                   ...future.conditions[[length(...future.conditions) + 
[16:12:33.344]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:33.344]                   if (TRUE && !signal) {
[16:12:33.344]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.344]                     {
[16:12:33.344]                       inherits <- base::inherits
[16:12:33.344]                       invokeRestart <- base::invokeRestart
[16:12:33.344]                       is.null <- base::is.null
[16:12:33.344]                       muffled <- FALSE
[16:12:33.344]                       if (inherits(cond, "message")) {
[16:12:33.344]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:33.344]                         if (muffled) 
[16:12:33.344]                           invokeRestart("muffleMessage")
[16:12:33.344]                       }
[16:12:33.344]                       else if (inherits(cond, "warning")) {
[16:12:33.344]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:33.344]                         if (muffled) 
[16:12:33.344]                           invokeRestart("muffleWarning")
[16:12:33.344]                       }
[16:12:33.344]                       else if (inherits(cond, "condition")) {
[16:12:33.344]                         if (!is.null(pattern)) {
[16:12:33.344]                           computeRestarts <- base::computeRestarts
[16:12:33.344]                           grepl <- base::grepl
[16:12:33.344]                           restarts <- computeRestarts(cond)
[16:12:33.344]                           for (restart in restarts) {
[16:12:33.344]                             name <- restart$name
[16:12:33.344]                             if (is.null(name)) 
[16:12:33.344]                               next
[16:12:33.344]                             if (!grepl(pattern, name)) 
[16:12:33.344]                               next
[16:12:33.344]                             invokeRestart(restart)
[16:12:33.344]                             muffled <- TRUE
[16:12:33.344]                             break
[16:12:33.344]                           }
[16:12:33.344]                         }
[16:12:33.344]                       }
[16:12:33.344]                       invisible(muffled)
[16:12:33.344]                     }
[16:12:33.344]                     muffleCondition(cond, pattern = "^muffle")
[16:12:33.344]                   }
[16:12:33.344]                 }
[16:12:33.344]                 else {
[16:12:33.344]                   if (TRUE) {
[16:12:33.344]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.344]                     {
[16:12:33.344]                       inherits <- base::inherits
[16:12:33.344]                       invokeRestart <- base::invokeRestart
[16:12:33.344]                       is.null <- base::is.null
[16:12:33.344]                       muffled <- FALSE
[16:12:33.344]                       if (inherits(cond, "message")) {
[16:12:33.344]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:33.344]                         if (muffled) 
[16:12:33.344]                           invokeRestart("muffleMessage")
[16:12:33.344]                       }
[16:12:33.344]                       else if (inherits(cond, "warning")) {
[16:12:33.344]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:33.344]                         if (muffled) 
[16:12:33.344]                           invokeRestart("muffleWarning")
[16:12:33.344]                       }
[16:12:33.344]                       else if (inherits(cond, "condition")) {
[16:12:33.344]                         if (!is.null(pattern)) {
[16:12:33.344]                           computeRestarts <- base::computeRestarts
[16:12:33.344]                           grepl <- base::grepl
[16:12:33.344]                           restarts <- computeRestarts(cond)
[16:12:33.344]                           for (restart in restarts) {
[16:12:33.344]                             name <- restart$name
[16:12:33.344]                             if (is.null(name)) 
[16:12:33.344]                               next
[16:12:33.344]                             if (!grepl(pattern, name)) 
[16:12:33.344]                               next
[16:12:33.344]                             invokeRestart(restart)
[16:12:33.344]                             muffled <- TRUE
[16:12:33.344]                             break
[16:12:33.344]                           }
[16:12:33.344]                         }
[16:12:33.344]                       }
[16:12:33.344]                       invisible(muffled)
[16:12:33.344]                     }
[16:12:33.344]                     muffleCondition(cond, pattern = "^muffle")
[16:12:33.344]                   }
[16:12:33.344]                 }
[16:12:33.344]             }
[16:12:33.344]         }))
[16:12:33.344]     }, error = function(ex) {
[16:12:33.344]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:33.344]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:33.344]                 ...future.rng), started = ...future.startTime, 
[16:12:33.344]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:33.344]             version = "1.8"), class = "FutureResult")
[16:12:33.344]     }, finally = {
[16:12:33.344]         if (!identical(...future.workdir, getwd())) 
[16:12:33.344]             setwd(...future.workdir)
[16:12:33.344]         {
[16:12:33.344]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:33.344]                 ...future.oldOptions$nwarnings <- NULL
[16:12:33.344]             }
[16:12:33.344]             base::options(...future.oldOptions)
[16:12:33.344]             if (.Platform$OS.type == "windows") {
[16:12:33.344]                 old_names <- names(...future.oldEnvVars)
[16:12:33.344]                 envs <- base::Sys.getenv()
[16:12:33.344]                 names <- names(envs)
[16:12:33.344]                 common <- intersect(names, old_names)
[16:12:33.344]                 added <- setdiff(names, old_names)
[16:12:33.344]                 removed <- setdiff(old_names, names)
[16:12:33.344]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:33.344]                   envs[common]]
[16:12:33.344]                 NAMES <- toupper(changed)
[16:12:33.344]                 args <- list()
[16:12:33.344]                 for (kk in seq_along(NAMES)) {
[16:12:33.344]                   name <- changed[[kk]]
[16:12:33.344]                   NAME <- NAMES[[kk]]
[16:12:33.344]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.344]                     next
[16:12:33.344]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:33.344]                 }
[16:12:33.344]                 NAMES <- toupper(added)
[16:12:33.344]                 for (kk in seq_along(NAMES)) {
[16:12:33.344]                   name <- added[[kk]]
[16:12:33.344]                   NAME <- NAMES[[kk]]
[16:12:33.344]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.344]                     next
[16:12:33.344]                   args[[name]] <- ""
[16:12:33.344]                 }
[16:12:33.344]                 NAMES <- toupper(removed)
[16:12:33.344]                 for (kk in seq_along(NAMES)) {
[16:12:33.344]                   name <- removed[[kk]]
[16:12:33.344]                   NAME <- NAMES[[kk]]
[16:12:33.344]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.344]                     next
[16:12:33.344]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:33.344]                 }
[16:12:33.344]                 if (length(args) > 0) 
[16:12:33.344]                   base::do.call(base::Sys.setenv, args = args)
[16:12:33.344]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:33.344]             }
[16:12:33.344]             else {
[16:12:33.344]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:33.344]             }
[16:12:33.344]             {
[16:12:33.344]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:33.344]                   0L) {
[16:12:33.344]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:33.344]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:33.344]                   base::options(opts)
[16:12:33.344]                 }
[16:12:33.344]                 {
[16:12:33.344]                   {
[16:12:33.344]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:33.344]                     NULL
[16:12:33.344]                   }
[16:12:33.344]                   options(future.plan = NULL)
[16:12:33.344]                   if (is.na(NA_character_)) 
[16:12:33.344]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:33.344]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:33.344]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:33.344]                     envir = parent.frame()) 
[16:12:33.344]                   {
[16:12:33.344]                     default_workers <- missing(workers)
[16:12:33.344]                     if (is.function(workers)) 
[16:12:33.344]                       workers <- workers()
[16:12:33.344]                     workers <- structure(as.integer(workers), 
[16:12:33.344]                       class = class(workers))
[16:12:33.344]                     stop_if_not(is.finite(workers), workers >= 
[16:12:33.344]                       1L)
[16:12:33.344]                     if ((workers == 1L && !inherits(workers, 
[16:12:33.344]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:33.344]                       if (default_workers) 
[16:12:33.344]                         supportsMulticore(warn = TRUE)
[16:12:33.344]                       return(sequential(..., envir = envir))
[16:12:33.344]                     }
[16:12:33.344]                     oopts <- options(mc.cores = workers)
[16:12:33.344]                     on.exit(options(oopts))
[16:12:33.344]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:33.344]                       envir = envir)
[16:12:33.344]                     if (!future$lazy) 
[16:12:33.344]                       future <- run(future)
[16:12:33.344]                     invisible(future)
[16:12:33.344]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:33.344]                 }
[16:12:33.344]             }
[16:12:33.344]         }
[16:12:33.344]     })
[16:12:33.344]     if (TRUE) {
[16:12:33.344]         base::sink(type = "output", split = FALSE)
[16:12:33.344]         if (TRUE) {
[16:12:33.344]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:33.344]         }
[16:12:33.344]         else {
[16:12:33.344]             ...future.result["stdout"] <- base::list(NULL)
[16:12:33.344]         }
[16:12:33.344]         base::close(...future.stdout)
[16:12:33.344]         ...future.stdout <- NULL
[16:12:33.344]     }
[16:12:33.344]     ...future.result$conditions <- ...future.conditions
[16:12:33.344]     ...future.result$finished <- base::Sys.time()
[16:12:33.344]     ...future.result
[16:12:33.344] }
[16:12:33.347] assign_globals() ...
[16:12:33.347] List of 1
[16:12:33.347]  $ x: num [1:5] 1 1 2 2 2
[16:12:33.347]  - attr(*, "where")=List of 1
[16:12:33.347]   ..$ x:<environment: R_EmptyEnv> 
[16:12:33.347]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:33.347]  - attr(*, "resolved")= logi FALSE
[16:12:33.347]  - attr(*, "total_size")= num 96
[16:12:33.347]  - attr(*, "already-done")= logi TRUE
[16:12:33.352] - copied ‘x’ to environment
[16:12:33.352] assign_globals() ... done
[16:12:33.353] requestCore(): workers = 2
[16:12:33.355] MulticoreFuture started
[16:12:33.355] - Launch lazy future ... done
[16:12:33.355] run() for ‘MulticoreFuture’ ... done
[16:12:33.356] plan(): Setting new future strategy stack:
[16:12:33.356] List of future strategies:
[16:12:33.356] 1. sequential:
[16:12:33.356]    - args: function (..., envir = parent.frame())
[16:12:33.356]    - tweaked: FALSE
[16:12:33.356]    - call: NULL
[16:12:33.357] plan(): nbrOfWorkers() = 1
[16:12:33.361] plan(): Setting new future strategy stack:
[16:12:33.361] List of future strategies:
[16:12:33.361] 1. multicore:
[16:12:33.361]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:33.361]    - tweaked: FALSE
[16:12:33.361]    - call: plan(strategy)
[16:12:33.366] plan(): nbrOfWorkers() = 2
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[16:12:33.369] getGlobalsAndPackages() ...
[16:12:33.369] Searching for globals...
[16:12:33.372] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[16:12:33.372] Searching for globals ... DONE
[16:12:33.372] Resolving globals: FALSE
[16:12:33.373] 
[16:12:33.373] - packages: [2] ‘stats’, ‘datasets’
[16:12:33.373] getGlobalsAndPackages() ... DONE
[16:12:33.373] run() for ‘Future’ ...
[16:12:33.374] - state: ‘created’
[16:12:33.374] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:33.378] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:33.378] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:33.378]   - Field: ‘label’
[16:12:33.378]   - Field: ‘local’
[16:12:33.378]   - Field: ‘owner’
[16:12:33.379]   - Field: ‘envir’
[16:12:33.379]   - Field: ‘workers’
[16:12:33.379]   - Field: ‘packages’
[16:12:33.379]   - Field: ‘gc’
[16:12:33.379]   - Field: ‘job’
[16:12:33.379]   - Field: ‘conditions’
[16:12:33.379]   - Field: ‘expr’
[16:12:33.379]   - Field: ‘uuid’
[16:12:33.379]   - Field: ‘seed’
[16:12:33.380]   - Field: ‘version’
[16:12:33.380]   - Field: ‘result’
[16:12:33.380]   - Field: ‘asynchronous’
[16:12:33.380]   - Field: ‘calls’
[16:12:33.380]   - Field: ‘globals’
[16:12:33.380]   - Field: ‘stdout’
[16:12:33.380]   - Field: ‘earlySignal’
[16:12:33.380]   - Field: ‘lazy’
[16:12:33.381]   - Field: ‘state’
[16:12:33.381] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:33.381] - Launch lazy future ...
[16:12:33.381] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:12:33.381] Packages needed by future strategies (n = 0): <none>
[16:12:33.382] {
[16:12:33.382]     {
[16:12:33.382]         {
[16:12:33.382]             ...future.startTime <- base::Sys.time()
[16:12:33.382]             {
[16:12:33.382]                 {
[16:12:33.382]                   {
[16:12:33.382]                     {
[16:12:33.382]                       {
[16:12:33.382]                         base::local({
[16:12:33.382]                           has_future <- base::requireNamespace("future", 
[16:12:33.382]                             quietly = TRUE)
[16:12:33.382]                           if (has_future) {
[16:12:33.382]                             ns <- base::getNamespace("future")
[16:12:33.382]                             version <- ns[[".package"]][["version"]]
[16:12:33.382]                             if (is.null(version)) 
[16:12:33.382]                               version <- utils::packageVersion("future")
[16:12:33.382]                           }
[16:12:33.382]                           else {
[16:12:33.382]                             version <- NULL
[16:12:33.382]                           }
[16:12:33.382]                           if (!has_future || version < "1.8.0") {
[16:12:33.382]                             info <- base::c(r_version = base::gsub("R version ", 
[16:12:33.382]                               "", base::R.version$version.string), 
[16:12:33.382]                               platform = base::sprintf("%s (%s-bit)", 
[16:12:33.382]                                 base::R.version$platform, 8 * 
[16:12:33.382]                                   base::.Machine$sizeof.pointer), 
[16:12:33.382]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:33.382]                                 "release", "version")], collapse = " "), 
[16:12:33.382]                               hostname = base::Sys.info()[["nodename"]])
[16:12:33.382]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:12:33.382]                               info)
[16:12:33.382]                             info <- base::paste(info, collapse = "; ")
[16:12:33.382]                             if (!has_future) {
[16:12:33.382]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:33.382]                                 info)
[16:12:33.382]                             }
[16:12:33.382]                             else {
[16:12:33.382]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:33.382]                                 info, version)
[16:12:33.382]                             }
[16:12:33.382]                             base::stop(msg)
[16:12:33.382]                           }
[16:12:33.382]                         })
[16:12:33.382]                       }
[16:12:33.382]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:33.382]                       base::options(mc.cores = 1L)
[16:12:33.382]                     }
[16:12:33.382]                     base::local({
[16:12:33.382]                       for (pkg in c("stats", "datasets")) {
[16:12:33.382]                         base::loadNamespace(pkg)
[16:12:33.382]                         base::library(pkg, character.only = TRUE)
[16:12:33.382]                       }
[16:12:33.382]                     })
[16:12:33.382]                   }
[16:12:33.382]                   options(future.plan = NULL)
[16:12:33.382]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:33.382]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:33.382]                 }
[16:12:33.382]                 ...future.workdir <- getwd()
[16:12:33.382]             }
[16:12:33.382]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:33.382]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:33.382]         }
[16:12:33.382]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:33.382]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:33.382]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:33.382]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:33.382]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:33.382]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:33.382]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:33.382]             base::names(...future.oldOptions))
[16:12:33.382]     }
[16:12:33.382]     if (FALSE) {
[16:12:33.382]     }
[16:12:33.382]     else {
[16:12:33.382]         if (TRUE) {
[16:12:33.382]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:33.382]                 open = "w")
[16:12:33.382]         }
[16:12:33.382]         else {
[16:12:33.382]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:33.382]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:33.382]         }
[16:12:33.382]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:33.382]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:33.382]             base::sink(type = "output", split = FALSE)
[16:12:33.382]             base::close(...future.stdout)
[16:12:33.382]         }, add = TRUE)
[16:12:33.382]     }
[16:12:33.382]     ...future.frame <- base::sys.nframe()
[16:12:33.382]     ...future.conditions <- base::list()
[16:12:33.382]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:33.382]     if (FALSE) {
[16:12:33.382]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:33.382]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:33.382]     }
[16:12:33.382]     ...future.result <- base::tryCatch({
[16:12:33.382]         base::withCallingHandlers({
[16:12:33.382]             ...future.value <- base::withVisible(base::local({
[16:12:33.382]                 withCallingHandlers({
[16:12:33.382]                   {
[16:12:33.382]                     lm(dist ~ . - 1, data = cars)
[16:12:33.382]                   }
[16:12:33.382]                 }, immediateCondition = function(cond) {
[16:12:33.382]                   save_rds <- function (object, pathname, ...) 
[16:12:33.382]                   {
[16:12:33.382]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:33.382]                     if (file_test("-f", pathname_tmp)) {
[16:12:33.382]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.382]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:33.382]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.382]                         fi_tmp[["mtime"]])
[16:12:33.382]                     }
[16:12:33.382]                     tryCatch({
[16:12:33.382]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:33.382]                     }, error = function(ex) {
[16:12:33.382]                       msg <- conditionMessage(ex)
[16:12:33.382]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.382]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:33.382]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.382]                         fi_tmp[["mtime"]], msg)
[16:12:33.382]                       ex$message <- msg
[16:12:33.382]                       stop(ex)
[16:12:33.382]                     })
[16:12:33.382]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:33.382]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:33.382]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:33.382]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.382]                       fi <- file.info(pathname)
[16:12:33.382]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:33.382]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.382]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:33.382]                         fi[["size"]], fi[["mtime"]])
[16:12:33.382]                       stop(msg)
[16:12:33.382]                     }
[16:12:33.382]                     invisible(pathname)
[16:12:33.382]                   }
[16:12:33.382]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:33.382]                     rootPath = tempdir()) 
[16:12:33.382]                   {
[16:12:33.382]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:33.382]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:33.382]                       tmpdir = path, fileext = ".rds")
[16:12:33.382]                     save_rds(obj, file)
[16:12:33.382]                   }
[16:12:33.382]                   saveImmediateCondition(cond, path = "/tmp/RtmpjVCO6F/.future/immediateConditions")
[16:12:33.382]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.382]                   {
[16:12:33.382]                     inherits <- base::inherits
[16:12:33.382]                     invokeRestart <- base::invokeRestart
[16:12:33.382]                     is.null <- base::is.null
[16:12:33.382]                     muffled <- FALSE
[16:12:33.382]                     if (inherits(cond, "message")) {
[16:12:33.382]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:33.382]                       if (muffled) 
[16:12:33.382]                         invokeRestart("muffleMessage")
[16:12:33.382]                     }
[16:12:33.382]                     else if (inherits(cond, "warning")) {
[16:12:33.382]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:33.382]                       if (muffled) 
[16:12:33.382]                         invokeRestart("muffleWarning")
[16:12:33.382]                     }
[16:12:33.382]                     else if (inherits(cond, "condition")) {
[16:12:33.382]                       if (!is.null(pattern)) {
[16:12:33.382]                         computeRestarts <- base::computeRestarts
[16:12:33.382]                         grepl <- base::grepl
[16:12:33.382]                         restarts <- computeRestarts(cond)
[16:12:33.382]                         for (restart in restarts) {
[16:12:33.382]                           name <- restart$name
[16:12:33.382]                           if (is.null(name)) 
[16:12:33.382]                             next
[16:12:33.382]                           if (!grepl(pattern, name)) 
[16:12:33.382]                             next
[16:12:33.382]                           invokeRestart(restart)
[16:12:33.382]                           muffled <- TRUE
[16:12:33.382]                           break
[16:12:33.382]                         }
[16:12:33.382]                       }
[16:12:33.382]                     }
[16:12:33.382]                     invisible(muffled)
[16:12:33.382]                   }
[16:12:33.382]                   muffleCondition(cond)
[16:12:33.382]                 })
[16:12:33.382]             }))
[16:12:33.382]             future::FutureResult(value = ...future.value$value, 
[16:12:33.382]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:33.382]                   ...future.rng), globalenv = if (FALSE) 
[16:12:33.382]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:33.382]                     ...future.globalenv.names))
[16:12:33.382]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:33.382]         }, condition = base::local({
[16:12:33.382]             c <- base::c
[16:12:33.382]             inherits <- base::inherits
[16:12:33.382]             invokeRestart <- base::invokeRestart
[16:12:33.382]             length <- base::length
[16:12:33.382]             list <- base::list
[16:12:33.382]             seq.int <- base::seq.int
[16:12:33.382]             signalCondition <- base::signalCondition
[16:12:33.382]             sys.calls <- base::sys.calls
[16:12:33.382]             `[[` <- base::`[[`
[16:12:33.382]             `+` <- base::`+`
[16:12:33.382]             `<<-` <- base::`<<-`
[16:12:33.382]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:33.382]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:33.382]                   3L)]
[16:12:33.382]             }
[16:12:33.382]             function(cond) {
[16:12:33.382]                 is_error <- inherits(cond, "error")
[16:12:33.382]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:33.382]                   NULL)
[16:12:33.382]                 if (is_error) {
[16:12:33.382]                   sessionInformation <- function() {
[16:12:33.382]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:33.382]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:33.382]                       search = base::search(), system = base::Sys.info())
[16:12:33.382]                   }
[16:12:33.382]                   ...future.conditions[[length(...future.conditions) + 
[16:12:33.382]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:33.382]                     cond$call), session = sessionInformation(), 
[16:12:33.382]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:33.382]                   signalCondition(cond)
[16:12:33.382]                 }
[16:12:33.382]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:33.382]                 "immediateCondition"))) {
[16:12:33.382]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:33.382]                   ...future.conditions[[length(...future.conditions) + 
[16:12:33.382]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:33.382]                   if (TRUE && !signal) {
[16:12:33.382]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.382]                     {
[16:12:33.382]                       inherits <- base::inherits
[16:12:33.382]                       invokeRestart <- base::invokeRestart
[16:12:33.382]                       is.null <- base::is.null
[16:12:33.382]                       muffled <- FALSE
[16:12:33.382]                       if (inherits(cond, "message")) {
[16:12:33.382]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:33.382]                         if (muffled) 
[16:12:33.382]                           invokeRestart("muffleMessage")
[16:12:33.382]                       }
[16:12:33.382]                       else if (inherits(cond, "warning")) {
[16:12:33.382]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:33.382]                         if (muffled) 
[16:12:33.382]                           invokeRestart("muffleWarning")
[16:12:33.382]                       }
[16:12:33.382]                       else if (inherits(cond, "condition")) {
[16:12:33.382]                         if (!is.null(pattern)) {
[16:12:33.382]                           computeRestarts <- base::computeRestarts
[16:12:33.382]                           grepl <- base::grepl
[16:12:33.382]                           restarts <- computeRestarts(cond)
[16:12:33.382]                           for (restart in restarts) {
[16:12:33.382]                             name <- restart$name
[16:12:33.382]                             if (is.null(name)) 
[16:12:33.382]                               next
[16:12:33.382]                             if (!grepl(pattern, name)) 
[16:12:33.382]                               next
[16:12:33.382]                             invokeRestart(restart)
[16:12:33.382]                             muffled <- TRUE
[16:12:33.382]                             break
[16:12:33.382]                           }
[16:12:33.382]                         }
[16:12:33.382]                       }
[16:12:33.382]                       invisible(muffled)
[16:12:33.382]                     }
[16:12:33.382]                     muffleCondition(cond, pattern = "^muffle")
[16:12:33.382]                   }
[16:12:33.382]                 }
[16:12:33.382]                 else {
[16:12:33.382]                   if (TRUE) {
[16:12:33.382]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.382]                     {
[16:12:33.382]                       inherits <- base::inherits
[16:12:33.382]                       invokeRestart <- base::invokeRestart
[16:12:33.382]                       is.null <- base::is.null
[16:12:33.382]                       muffled <- FALSE
[16:12:33.382]                       if (inherits(cond, "message")) {
[16:12:33.382]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:33.382]                         if (muffled) 
[16:12:33.382]                           invokeRestart("muffleMessage")
[16:12:33.382]                       }
[16:12:33.382]                       else if (inherits(cond, "warning")) {
[16:12:33.382]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:33.382]                         if (muffled) 
[16:12:33.382]                           invokeRestart("muffleWarning")
[16:12:33.382]                       }
[16:12:33.382]                       else if (inherits(cond, "condition")) {
[16:12:33.382]                         if (!is.null(pattern)) {
[16:12:33.382]                           computeRestarts <- base::computeRestarts
[16:12:33.382]                           grepl <- base::grepl
[16:12:33.382]                           restarts <- computeRestarts(cond)
[16:12:33.382]                           for (restart in restarts) {
[16:12:33.382]                             name <- restart$name
[16:12:33.382]                             if (is.null(name)) 
[16:12:33.382]                               next
[16:12:33.382]                             if (!grepl(pattern, name)) 
[16:12:33.382]                               next
[16:12:33.382]                             invokeRestart(restart)
[16:12:33.382]                             muffled <- TRUE
[16:12:33.382]                             break
[16:12:33.382]                           }
[16:12:33.382]                         }
[16:12:33.382]                       }
[16:12:33.382]                       invisible(muffled)
[16:12:33.382]                     }
[16:12:33.382]                     muffleCondition(cond, pattern = "^muffle")
[16:12:33.382]                   }
[16:12:33.382]                 }
[16:12:33.382]             }
[16:12:33.382]         }))
[16:12:33.382]     }, error = function(ex) {
[16:12:33.382]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:33.382]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:33.382]                 ...future.rng), started = ...future.startTime, 
[16:12:33.382]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:33.382]             version = "1.8"), class = "FutureResult")
[16:12:33.382]     }, finally = {
[16:12:33.382]         if (!identical(...future.workdir, getwd())) 
[16:12:33.382]             setwd(...future.workdir)
[16:12:33.382]         {
[16:12:33.382]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:33.382]                 ...future.oldOptions$nwarnings <- NULL
[16:12:33.382]             }
[16:12:33.382]             base::options(...future.oldOptions)
[16:12:33.382]             if (.Platform$OS.type == "windows") {
[16:12:33.382]                 old_names <- names(...future.oldEnvVars)
[16:12:33.382]                 envs <- base::Sys.getenv()
[16:12:33.382]                 names <- names(envs)
[16:12:33.382]                 common <- intersect(names, old_names)
[16:12:33.382]                 added <- setdiff(names, old_names)
[16:12:33.382]                 removed <- setdiff(old_names, names)
[16:12:33.382]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:33.382]                   envs[common]]
[16:12:33.382]                 NAMES <- toupper(changed)
[16:12:33.382]                 args <- list()
[16:12:33.382]                 for (kk in seq_along(NAMES)) {
[16:12:33.382]                   name <- changed[[kk]]
[16:12:33.382]                   NAME <- NAMES[[kk]]
[16:12:33.382]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.382]                     next
[16:12:33.382]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:33.382]                 }
[16:12:33.382]                 NAMES <- toupper(added)
[16:12:33.382]                 for (kk in seq_along(NAMES)) {
[16:12:33.382]                   name <- added[[kk]]
[16:12:33.382]                   NAME <- NAMES[[kk]]
[16:12:33.382]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.382]                     next
[16:12:33.382]                   args[[name]] <- ""
[16:12:33.382]                 }
[16:12:33.382]                 NAMES <- toupper(removed)
[16:12:33.382]                 for (kk in seq_along(NAMES)) {
[16:12:33.382]                   name <- removed[[kk]]
[16:12:33.382]                   NAME <- NAMES[[kk]]
[16:12:33.382]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.382]                     next
[16:12:33.382]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:33.382]                 }
[16:12:33.382]                 if (length(args) > 0) 
[16:12:33.382]                   base::do.call(base::Sys.setenv, args = args)
[16:12:33.382]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:33.382]             }
[16:12:33.382]             else {
[16:12:33.382]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:33.382]             }
[16:12:33.382]             {
[16:12:33.382]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:33.382]                   0L) {
[16:12:33.382]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:33.382]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:33.382]                   base::options(opts)
[16:12:33.382]                 }
[16:12:33.382]                 {
[16:12:33.382]                   {
[16:12:33.382]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:33.382]                     NULL
[16:12:33.382]                   }
[16:12:33.382]                   options(future.plan = NULL)
[16:12:33.382]                   if (is.na(NA_character_)) 
[16:12:33.382]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:33.382]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:33.382]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:33.382]                     envir = parent.frame()) 
[16:12:33.382]                   {
[16:12:33.382]                     default_workers <- missing(workers)
[16:12:33.382]                     if (is.function(workers)) 
[16:12:33.382]                       workers <- workers()
[16:12:33.382]                     workers <- structure(as.integer(workers), 
[16:12:33.382]                       class = class(workers))
[16:12:33.382]                     stop_if_not(is.finite(workers), workers >= 
[16:12:33.382]                       1L)
[16:12:33.382]                     if ((workers == 1L && !inherits(workers, 
[16:12:33.382]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:33.382]                       if (default_workers) 
[16:12:33.382]                         supportsMulticore(warn = TRUE)
[16:12:33.382]                       return(sequential(..., envir = envir))
[16:12:33.382]                     }
[16:12:33.382]                     oopts <- options(mc.cores = workers)
[16:12:33.382]                     on.exit(options(oopts))
[16:12:33.382]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:33.382]                       envir = envir)
[16:12:33.382]                     if (!future$lazy) 
[16:12:33.382]                       future <- run(future)
[16:12:33.382]                     invisible(future)
[16:12:33.382]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:33.382]                 }
[16:12:33.382]             }
[16:12:33.382]         }
[16:12:33.382]     })
[16:12:33.382]     if (TRUE) {
[16:12:33.382]         base::sink(type = "output", split = FALSE)
[16:12:33.382]         if (TRUE) {
[16:12:33.382]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:33.382]         }
[16:12:33.382]         else {
[16:12:33.382]             ...future.result["stdout"] <- base::list(NULL)
[16:12:33.382]         }
[16:12:33.382]         base::close(...future.stdout)
[16:12:33.382]         ...future.stdout <- NULL
[16:12:33.382]     }
[16:12:33.382]     ...future.result$conditions <- ...future.conditions
[16:12:33.382]     ...future.result$finished <- base::Sys.time()
[16:12:33.382]     ...future.result
[16:12:33.382] }
[16:12:33.385] requestCore(): workers = 2
[16:12:33.386] MulticoreFuture started
[16:12:33.387] - Launch lazy future ... done
[16:12:33.387] run() for ‘MulticoreFuture’ ... done
[16:12:33.388] plan(): Setting new future strategy stack:
[16:12:33.388] List of future strategies:
[16:12:33.388] 1. sequential:
[16:12:33.388]    - args: function (..., envir = parent.frame())
[16:12:33.388]    - tweaked: FALSE
[16:12:33.388]    - call: NULL
[16:12:33.389] plan(): nbrOfWorkers() = 1
[16:12:33.392] plan(): Setting new future strategy stack:
[16:12:33.392] List of future strategies:
[16:12:33.392] 1. multicore:
[16:12:33.392]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:33.392]    - tweaked: FALSE
[16:12:33.392]    - call: plan(strategy)
[16:12:33.397] plan(): nbrOfWorkers() = 2

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[16:12:33.402] getGlobalsAndPackages() ...
[16:12:33.403] Searching for globals...
[16:12:33.405] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[16:12:33.405] Searching for globals ... DONE
[16:12:33.405] Resolving globals: FALSE
[16:12:33.406] 
[16:12:33.406] - packages: [2] ‘stats’, ‘datasets’
[16:12:33.406] getGlobalsAndPackages() ... DONE
[16:12:33.406] run() for ‘Future’ ...
[16:12:33.406] - state: ‘created’
[16:12:33.407] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:33.443] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:33.443] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:33.444]   - Field: ‘label’
[16:12:33.444]   - Field: ‘local’
[16:12:33.444]   - Field: ‘owner’
[16:12:33.444]   - Field: ‘envir’
[16:12:33.444]   - Field: ‘workers’
[16:12:33.444]   - Field: ‘packages’
[16:12:33.444]   - Field: ‘gc’
[16:12:33.444]   - Field: ‘job’
[16:12:33.444]   - Field: ‘conditions’
[16:12:33.445]   - Field: ‘expr’
[16:12:33.445]   - Field: ‘uuid’
[16:12:33.445]   - Field: ‘seed’
[16:12:33.445]   - Field: ‘version’
[16:12:33.445]   - Field: ‘result’
[16:12:33.445]   - Field: ‘asynchronous’
[16:12:33.445]   - Field: ‘calls’
[16:12:33.445]   - Field: ‘globals’
[16:12:33.445]   - Field: ‘stdout’
[16:12:33.445]   - Field: ‘earlySignal’
[16:12:33.446]   - Field: ‘lazy’
[16:12:33.446]   - Field: ‘state’
[16:12:33.446] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:33.446] - Launch lazy future ...
[16:12:33.446] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:12:33.446] Packages needed by future strategies (n = 0): <none>
[16:12:33.447] {
[16:12:33.447]     {
[16:12:33.447]         {
[16:12:33.447]             ...future.startTime <- base::Sys.time()
[16:12:33.447]             {
[16:12:33.447]                 {
[16:12:33.447]                   {
[16:12:33.447]                     {
[16:12:33.447]                       {
[16:12:33.447]                         base::local({
[16:12:33.447]                           has_future <- base::requireNamespace("future", 
[16:12:33.447]                             quietly = TRUE)
[16:12:33.447]                           if (has_future) {
[16:12:33.447]                             ns <- base::getNamespace("future")
[16:12:33.447]                             version <- ns[[".package"]][["version"]]
[16:12:33.447]                             if (is.null(version)) 
[16:12:33.447]                               version <- utils::packageVersion("future")
[16:12:33.447]                           }
[16:12:33.447]                           else {
[16:12:33.447]                             version <- NULL
[16:12:33.447]                           }
[16:12:33.447]                           if (!has_future || version < "1.8.0") {
[16:12:33.447]                             info <- base::c(r_version = base::gsub("R version ", 
[16:12:33.447]                               "", base::R.version$version.string), 
[16:12:33.447]                               platform = base::sprintf("%s (%s-bit)", 
[16:12:33.447]                                 base::R.version$platform, 8 * 
[16:12:33.447]                                   base::.Machine$sizeof.pointer), 
[16:12:33.447]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:33.447]                                 "release", "version")], collapse = " "), 
[16:12:33.447]                               hostname = base::Sys.info()[["nodename"]])
[16:12:33.447]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:12:33.447]                               info)
[16:12:33.447]                             info <- base::paste(info, collapse = "; ")
[16:12:33.447]                             if (!has_future) {
[16:12:33.447]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:33.447]                                 info)
[16:12:33.447]                             }
[16:12:33.447]                             else {
[16:12:33.447]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:33.447]                                 info, version)
[16:12:33.447]                             }
[16:12:33.447]                             base::stop(msg)
[16:12:33.447]                           }
[16:12:33.447]                         })
[16:12:33.447]                       }
[16:12:33.447]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:33.447]                       base::options(mc.cores = 1L)
[16:12:33.447]                     }
[16:12:33.447]                     base::local({
[16:12:33.447]                       for (pkg in c("stats", "datasets")) {
[16:12:33.447]                         base::loadNamespace(pkg)
[16:12:33.447]                         base::library(pkg, character.only = TRUE)
[16:12:33.447]                       }
[16:12:33.447]                     })
[16:12:33.447]                   }
[16:12:33.447]                   options(future.plan = NULL)
[16:12:33.447]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:33.447]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:33.447]                 }
[16:12:33.447]                 ...future.workdir <- getwd()
[16:12:33.447]             }
[16:12:33.447]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:33.447]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:33.447]         }
[16:12:33.447]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:33.447]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:33.447]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:33.447]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:33.447]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:33.447]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:33.447]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:33.447]             base::names(...future.oldOptions))
[16:12:33.447]     }
[16:12:33.447]     if (FALSE) {
[16:12:33.447]     }
[16:12:33.447]     else {
[16:12:33.447]         if (TRUE) {
[16:12:33.447]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:33.447]                 open = "w")
[16:12:33.447]         }
[16:12:33.447]         else {
[16:12:33.447]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:33.447]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:33.447]         }
[16:12:33.447]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:33.447]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:33.447]             base::sink(type = "output", split = FALSE)
[16:12:33.447]             base::close(...future.stdout)
[16:12:33.447]         }, add = TRUE)
[16:12:33.447]     }
[16:12:33.447]     ...future.frame <- base::sys.nframe()
[16:12:33.447]     ...future.conditions <- base::list()
[16:12:33.447]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:33.447]     if (FALSE) {
[16:12:33.447]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:33.447]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:33.447]     }
[16:12:33.447]     ...future.result <- base::tryCatch({
[16:12:33.447]         base::withCallingHandlers({
[16:12:33.447]             ...future.value <- base::withVisible(base::local({
[16:12:33.447]                 withCallingHandlers({
[16:12:33.447]                   {
[16:12:33.447]                     lm(dist ~ . + 0, data = cars)
[16:12:33.447]                   }
[16:12:33.447]                 }, immediateCondition = function(cond) {
[16:12:33.447]                   save_rds <- function (object, pathname, ...) 
[16:12:33.447]                   {
[16:12:33.447]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:33.447]                     if (file_test("-f", pathname_tmp)) {
[16:12:33.447]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.447]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:33.447]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.447]                         fi_tmp[["mtime"]])
[16:12:33.447]                     }
[16:12:33.447]                     tryCatch({
[16:12:33.447]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:33.447]                     }, error = function(ex) {
[16:12:33.447]                       msg <- conditionMessage(ex)
[16:12:33.447]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.447]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:33.447]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.447]                         fi_tmp[["mtime"]], msg)
[16:12:33.447]                       ex$message <- msg
[16:12:33.447]                       stop(ex)
[16:12:33.447]                     })
[16:12:33.447]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:33.447]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:33.447]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:33.447]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.447]                       fi <- file.info(pathname)
[16:12:33.447]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:33.447]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.447]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:33.447]                         fi[["size"]], fi[["mtime"]])
[16:12:33.447]                       stop(msg)
[16:12:33.447]                     }
[16:12:33.447]                     invisible(pathname)
[16:12:33.447]                   }
[16:12:33.447]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:33.447]                     rootPath = tempdir()) 
[16:12:33.447]                   {
[16:12:33.447]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:33.447]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:33.447]                       tmpdir = path, fileext = ".rds")
[16:12:33.447]                     save_rds(obj, file)
[16:12:33.447]                   }
[16:12:33.447]                   saveImmediateCondition(cond, path = "/tmp/RtmpjVCO6F/.future/immediateConditions")
[16:12:33.447]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.447]                   {
[16:12:33.447]                     inherits <- base::inherits
[16:12:33.447]                     invokeRestart <- base::invokeRestart
[16:12:33.447]                     is.null <- base::is.null
[16:12:33.447]                     muffled <- FALSE
[16:12:33.447]                     if (inherits(cond, "message")) {
[16:12:33.447]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:33.447]                       if (muffled) 
[16:12:33.447]                         invokeRestart("muffleMessage")
[16:12:33.447]                     }
[16:12:33.447]                     else if (inherits(cond, "warning")) {
[16:12:33.447]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:33.447]                       if (muffled) 
[16:12:33.447]                         invokeRestart("muffleWarning")
[16:12:33.447]                     }
[16:12:33.447]                     else if (inherits(cond, "condition")) {
[16:12:33.447]                       if (!is.null(pattern)) {
[16:12:33.447]                         computeRestarts <- base::computeRestarts
[16:12:33.447]                         grepl <- base::grepl
[16:12:33.447]                         restarts <- computeRestarts(cond)
[16:12:33.447]                         for (restart in restarts) {
[16:12:33.447]                           name <- restart$name
[16:12:33.447]                           if (is.null(name)) 
[16:12:33.447]                             next
[16:12:33.447]                           if (!grepl(pattern, name)) 
[16:12:33.447]                             next
[16:12:33.447]                           invokeRestart(restart)
[16:12:33.447]                           muffled <- TRUE
[16:12:33.447]                           break
[16:12:33.447]                         }
[16:12:33.447]                       }
[16:12:33.447]                     }
[16:12:33.447]                     invisible(muffled)
[16:12:33.447]                   }
[16:12:33.447]                   muffleCondition(cond)
[16:12:33.447]                 })
[16:12:33.447]             }))
[16:12:33.447]             future::FutureResult(value = ...future.value$value, 
[16:12:33.447]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:33.447]                   ...future.rng), globalenv = if (FALSE) 
[16:12:33.447]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:33.447]                     ...future.globalenv.names))
[16:12:33.447]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:33.447]         }, condition = base::local({
[16:12:33.447]             c <- base::c
[16:12:33.447]             inherits <- base::inherits
[16:12:33.447]             invokeRestart <- base::invokeRestart
[16:12:33.447]             length <- base::length
[16:12:33.447]             list <- base::list
[16:12:33.447]             seq.int <- base::seq.int
[16:12:33.447]             signalCondition <- base::signalCondition
[16:12:33.447]             sys.calls <- base::sys.calls
[16:12:33.447]             `[[` <- base::`[[`
[16:12:33.447]             `+` <- base::`+`
[16:12:33.447]             `<<-` <- base::`<<-`
[16:12:33.447]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:33.447]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:33.447]                   3L)]
[16:12:33.447]             }
[16:12:33.447]             function(cond) {
[16:12:33.447]                 is_error <- inherits(cond, "error")
[16:12:33.447]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:33.447]                   NULL)
[16:12:33.447]                 if (is_error) {
[16:12:33.447]                   sessionInformation <- function() {
[16:12:33.447]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:33.447]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:33.447]                       search = base::search(), system = base::Sys.info())
[16:12:33.447]                   }
[16:12:33.447]                   ...future.conditions[[length(...future.conditions) + 
[16:12:33.447]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:33.447]                     cond$call), session = sessionInformation(), 
[16:12:33.447]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:33.447]                   signalCondition(cond)
[16:12:33.447]                 }
[16:12:33.447]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:33.447]                 "immediateCondition"))) {
[16:12:33.447]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:33.447]                   ...future.conditions[[length(...future.conditions) + 
[16:12:33.447]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:33.447]                   if (TRUE && !signal) {
[16:12:33.447]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.447]                     {
[16:12:33.447]                       inherits <- base::inherits
[16:12:33.447]                       invokeRestart <- base::invokeRestart
[16:12:33.447]                       is.null <- base::is.null
[16:12:33.447]                       muffled <- FALSE
[16:12:33.447]                       if (inherits(cond, "message")) {
[16:12:33.447]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:33.447]                         if (muffled) 
[16:12:33.447]                           invokeRestart("muffleMessage")
[16:12:33.447]                       }
[16:12:33.447]                       else if (inherits(cond, "warning")) {
[16:12:33.447]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:33.447]                         if (muffled) 
[16:12:33.447]                           invokeRestart("muffleWarning")
[16:12:33.447]                       }
[16:12:33.447]                       else if (inherits(cond, "condition")) {
[16:12:33.447]                         if (!is.null(pattern)) {
[16:12:33.447]                           computeRestarts <- base::computeRestarts
[16:12:33.447]                           grepl <- base::grepl
[16:12:33.447]                           restarts <- computeRestarts(cond)
[16:12:33.447]                           for (restart in restarts) {
[16:12:33.447]                             name <- restart$name
[16:12:33.447]                             if (is.null(name)) 
[16:12:33.447]                               next
[16:12:33.447]                             if (!grepl(pattern, name)) 
[16:12:33.447]                               next
[16:12:33.447]                             invokeRestart(restart)
[16:12:33.447]                             muffled <- TRUE
[16:12:33.447]                             break
[16:12:33.447]                           }
[16:12:33.447]                         }
[16:12:33.447]                       }
[16:12:33.447]                       invisible(muffled)
[16:12:33.447]                     }
[16:12:33.447]                     muffleCondition(cond, pattern = "^muffle")
[16:12:33.447]                   }
[16:12:33.447]                 }
[16:12:33.447]                 else {
[16:12:33.447]                   if (TRUE) {
[16:12:33.447]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.447]                     {
[16:12:33.447]                       inherits <- base::inherits
[16:12:33.447]                       invokeRestart <- base::invokeRestart
[16:12:33.447]                       is.null <- base::is.null
[16:12:33.447]                       muffled <- FALSE
[16:12:33.447]                       if (inherits(cond, "message")) {
[16:12:33.447]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:33.447]                         if (muffled) 
[16:12:33.447]                           invokeRestart("muffleMessage")
[16:12:33.447]                       }
[16:12:33.447]                       else if (inherits(cond, "warning")) {
[16:12:33.447]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:33.447]                         if (muffled) 
[16:12:33.447]                           invokeRestart("muffleWarning")
[16:12:33.447]                       }
[16:12:33.447]                       else if (inherits(cond, "condition")) {
[16:12:33.447]                         if (!is.null(pattern)) {
[16:12:33.447]                           computeRestarts <- base::computeRestarts
[16:12:33.447]                           grepl <- base::grepl
[16:12:33.447]                           restarts <- computeRestarts(cond)
[16:12:33.447]                           for (restart in restarts) {
[16:12:33.447]                             name <- restart$name
[16:12:33.447]                             if (is.null(name)) 
[16:12:33.447]                               next
[16:12:33.447]                             if (!grepl(pattern, name)) 
[16:12:33.447]                               next
[16:12:33.447]                             invokeRestart(restart)
[16:12:33.447]                             muffled <- TRUE
[16:12:33.447]                             break
[16:12:33.447]                           }
[16:12:33.447]                         }
[16:12:33.447]                       }
[16:12:33.447]                       invisible(muffled)
[16:12:33.447]                     }
[16:12:33.447]                     muffleCondition(cond, pattern = "^muffle")
[16:12:33.447]                   }
[16:12:33.447]                 }
[16:12:33.447]             }
[16:12:33.447]         }))
[16:12:33.447]     }, error = function(ex) {
[16:12:33.447]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:33.447]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:33.447]                 ...future.rng), started = ...future.startTime, 
[16:12:33.447]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:33.447]             version = "1.8"), class = "FutureResult")
[16:12:33.447]     }, finally = {
[16:12:33.447]         if (!identical(...future.workdir, getwd())) 
[16:12:33.447]             setwd(...future.workdir)
[16:12:33.447]         {
[16:12:33.447]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:33.447]                 ...future.oldOptions$nwarnings <- NULL
[16:12:33.447]             }
[16:12:33.447]             base::options(...future.oldOptions)
[16:12:33.447]             if (.Platform$OS.type == "windows") {
[16:12:33.447]                 old_names <- names(...future.oldEnvVars)
[16:12:33.447]                 envs <- base::Sys.getenv()
[16:12:33.447]                 names <- names(envs)
[16:12:33.447]                 common <- intersect(names, old_names)
[16:12:33.447]                 added <- setdiff(names, old_names)
[16:12:33.447]                 removed <- setdiff(old_names, names)
[16:12:33.447]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:33.447]                   envs[common]]
[16:12:33.447]                 NAMES <- toupper(changed)
[16:12:33.447]                 args <- list()
[16:12:33.447]                 for (kk in seq_along(NAMES)) {
[16:12:33.447]                   name <- changed[[kk]]
[16:12:33.447]                   NAME <- NAMES[[kk]]
[16:12:33.447]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.447]                     next
[16:12:33.447]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:33.447]                 }
[16:12:33.447]                 NAMES <- toupper(added)
[16:12:33.447]                 for (kk in seq_along(NAMES)) {
[16:12:33.447]                   name <- added[[kk]]
[16:12:33.447]                   NAME <- NAMES[[kk]]
[16:12:33.447]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.447]                     next
[16:12:33.447]                   args[[name]] <- ""
[16:12:33.447]                 }
[16:12:33.447]                 NAMES <- toupper(removed)
[16:12:33.447]                 for (kk in seq_along(NAMES)) {
[16:12:33.447]                   name <- removed[[kk]]
[16:12:33.447]                   NAME <- NAMES[[kk]]
[16:12:33.447]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.447]                     next
[16:12:33.447]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:33.447]                 }
[16:12:33.447]                 if (length(args) > 0) 
[16:12:33.447]                   base::do.call(base::Sys.setenv, args = args)
[16:12:33.447]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:33.447]             }
[16:12:33.447]             else {
[16:12:33.447]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:33.447]             }
[16:12:33.447]             {
[16:12:33.447]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:33.447]                   0L) {
[16:12:33.447]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:33.447]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:33.447]                   base::options(opts)
[16:12:33.447]                 }
[16:12:33.447]                 {
[16:12:33.447]                   {
[16:12:33.447]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:33.447]                     NULL
[16:12:33.447]                   }
[16:12:33.447]                   options(future.plan = NULL)
[16:12:33.447]                   if (is.na(NA_character_)) 
[16:12:33.447]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:33.447]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:33.447]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:33.447]                     envir = parent.frame()) 
[16:12:33.447]                   {
[16:12:33.447]                     default_workers <- missing(workers)
[16:12:33.447]                     if (is.function(workers)) 
[16:12:33.447]                       workers <- workers()
[16:12:33.447]                     workers <- structure(as.integer(workers), 
[16:12:33.447]                       class = class(workers))
[16:12:33.447]                     stop_if_not(is.finite(workers), workers >= 
[16:12:33.447]                       1L)
[16:12:33.447]                     if ((workers == 1L && !inherits(workers, 
[16:12:33.447]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:33.447]                       if (default_workers) 
[16:12:33.447]                         supportsMulticore(warn = TRUE)
[16:12:33.447]                       return(sequential(..., envir = envir))
[16:12:33.447]                     }
[16:12:33.447]                     oopts <- options(mc.cores = workers)
[16:12:33.447]                     on.exit(options(oopts))
[16:12:33.447]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:33.447]                       envir = envir)
[16:12:33.447]                     if (!future$lazy) 
[16:12:33.447]                       future <- run(future)
[16:12:33.447]                     invisible(future)
[16:12:33.447]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:33.447]                 }
[16:12:33.447]             }
[16:12:33.447]         }
[16:12:33.447]     })
[16:12:33.447]     if (TRUE) {
[16:12:33.447]         base::sink(type = "output", split = FALSE)
[16:12:33.447]         if (TRUE) {
[16:12:33.447]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:33.447]         }
[16:12:33.447]         else {
[16:12:33.447]             ...future.result["stdout"] <- base::list(NULL)
[16:12:33.447]         }
[16:12:33.447]         base::close(...future.stdout)
[16:12:33.447]         ...future.stdout <- NULL
[16:12:33.447]     }
[16:12:33.447]     ...future.result$conditions <- ...future.conditions
[16:12:33.447]     ...future.result$finished <- base::Sys.time()
[16:12:33.447]     ...future.result
[16:12:33.447] }
[16:12:33.449] requestCore(): workers = 2
[16:12:33.451] MulticoreFuture started
[16:12:33.451] - Launch lazy future ... done
[16:12:33.452] run() for ‘MulticoreFuture’ ... done
[16:12:33.453] plan(): Setting new future strategy stack:
[16:12:33.453] List of future strategies:
[16:12:33.453] 1. sequential:
[16:12:33.453]    - args: function (..., envir = parent.frame())
[16:12:33.453]    - tweaked: FALSE
[16:12:33.453]    - call: NULL
[16:12:33.454] plan(): nbrOfWorkers() = 1
[16:12:33.458] plan(): Setting new future strategy stack:
[16:12:33.458] List of future strategies:
[16:12:33.458] 1. multicore:
[16:12:33.458]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:33.458]    - tweaked: FALSE
[16:12:33.458]    - call: plan(strategy)
[16:12:33.463] plan(): nbrOfWorkers() = 2

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[16:12:33.469] getGlobalsAndPackages() ...
[16:12:33.469] Searching for globals...
[16:12:33.471] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[16:12:33.472] Searching for globals ... DONE
[16:12:33.472] Resolving globals: FALSE
[16:12:33.472] 
[16:12:33.472] - packages: [2] ‘stats’, ‘datasets’
[16:12:33.473] getGlobalsAndPackages() ... DONE
[16:12:33.473] run() for ‘Future’ ...
[16:12:33.473] - state: ‘created’
[16:12:33.473] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:33.477] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:33.477] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:33.478]   - Field: ‘label’
[16:12:33.478]   - Field: ‘local’
[16:12:33.478]   - Field: ‘owner’
[16:12:33.478]   - Field: ‘envir’
[16:12:33.478]   - Field: ‘workers’
[16:12:33.478]   - Field: ‘packages’
[16:12:33.478]   - Field: ‘gc’
[16:12:33.478]   - Field: ‘job’
[16:12:33.478]   - Field: ‘conditions’
[16:12:33.479]   - Field: ‘expr’
[16:12:33.479]   - Field: ‘uuid’
[16:12:33.479]   - Field: ‘seed’
[16:12:33.479]   - Field: ‘version’
[16:12:33.479]   - Field: ‘result’
[16:12:33.479]   - Field: ‘asynchronous’
[16:12:33.479]   - Field: ‘calls’
[16:12:33.479]   - Field: ‘globals’
[16:12:33.480]   - Field: ‘stdout’
[16:12:33.480]   - Field: ‘earlySignal’
[16:12:33.480]   - Field: ‘lazy’
[16:12:33.480]   - Field: ‘state’
[16:12:33.480] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:33.480] - Launch lazy future ...
[16:12:33.481] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:12:33.481] Packages needed by future strategies (n = 0): <none>
[16:12:33.481] {
[16:12:33.481]     {
[16:12:33.481]         {
[16:12:33.481]             ...future.startTime <- base::Sys.time()
[16:12:33.481]             {
[16:12:33.481]                 {
[16:12:33.481]                   {
[16:12:33.481]                     {
[16:12:33.481]                       {
[16:12:33.481]                         base::local({
[16:12:33.481]                           has_future <- base::requireNamespace("future", 
[16:12:33.481]                             quietly = TRUE)
[16:12:33.481]                           if (has_future) {
[16:12:33.481]                             ns <- base::getNamespace("future")
[16:12:33.481]                             version <- ns[[".package"]][["version"]]
[16:12:33.481]                             if (is.null(version)) 
[16:12:33.481]                               version <- utils::packageVersion("future")
[16:12:33.481]                           }
[16:12:33.481]                           else {
[16:12:33.481]                             version <- NULL
[16:12:33.481]                           }
[16:12:33.481]                           if (!has_future || version < "1.8.0") {
[16:12:33.481]                             info <- base::c(r_version = base::gsub("R version ", 
[16:12:33.481]                               "", base::R.version$version.string), 
[16:12:33.481]                               platform = base::sprintf("%s (%s-bit)", 
[16:12:33.481]                                 base::R.version$platform, 8 * 
[16:12:33.481]                                   base::.Machine$sizeof.pointer), 
[16:12:33.481]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:33.481]                                 "release", "version")], collapse = " "), 
[16:12:33.481]                               hostname = base::Sys.info()[["nodename"]])
[16:12:33.481]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:12:33.481]                               info)
[16:12:33.481]                             info <- base::paste(info, collapse = "; ")
[16:12:33.481]                             if (!has_future) {
[16:12:33.481]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:33.481]                                 info)
[16:12:33.481]                             }
[16:12:33.481]                             else {
[16:12:33.481]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:33.481]                                 info, version)
[16:12:33.481]                             }
[16:12:33.481]                             base::stop(msg)
[16:12:33.481]                           }
[16:12:33.481]                         })
[16:12:33.481]                       }
[16:12:33.481]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:33.481]                       base::options(mc.cores = 1L)
[16:12:33.481]                     }
[16:12:33.481]                     base::local({
[16:12:33.481]                       for (pkg in c("stats", "datasets")) {
[16:12:33.481]                         base::loadNamespace(pkg)
[16:12:33.481]                         base::library(pkg, character.only = TRUE)
[16:12:33.481]                       }
[16:12:33.481]                     })
[16:12:33.481]                   }
[16:12:33.481]                   options(future.plan = NULL)
[16:12:33.481]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:33.481]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:33.481]                 }
[16:12:33.481]                 ...future.workdir <- getwd()
[16:12:33.481]             }
[16:12:33.481]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:33.481]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:33.481]         }
[16:12:33.481]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:33.481]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:33.481]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:33.481]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:33.481]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:33.481]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:33.481]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:33.481]             base::names(...future.oldOptions))
[16:12:33.481]     }
[16:12:33.481]     if (FALSE) {
[16:12:33.481]     }
[16:12:33.481]     else {
[16:12:33.481]         if (TRUE) {
[16:12:33.481]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:33.481]                 open = "w")
[16:12:33.481]         }
[16:12:33.481]         else {
[16:12:33.481]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:33.481]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:33.481]         }
[16:12:33.481]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:33.481]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:33.481]             base::sink(type = "output", split = FALSE)
[16:12:33.481]             base::close(...future.stdout)
[16:12:33.481]         }, add = TRUE)
[16:12:33.481]     }
[16:12:33.481]     ...future.frame <- base::sys.nframe()
[16:12:33.481]     ...future.conditions <- base::list()
[16:12:33.481]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:33.481]     if (FALSE) {
[16:12:33.481]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:33.481]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:33.481]     }
[16:12:33.481]     ...future.result <- base::tryCatch({
[16:12:33.481]         base::withCallingHandlers({
[16:12:33.481]             ...future.value <- base::withVisible(base::local({
[16:12:33.481]                 withCallingHandlers({
[16:12:33.481]                   {
[16:12:33.481]                     lm(dist ~ speed + speed^2, data = cars)
[16:12:33.481]                   }
[16:12:33.481]                 }, immediateCondition = function(cond) {
[16:12:33.481]                   save_rds <- function (object, pathname, ...) 
[16:12:33.481]                   {
[16:12:33.481]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:33.481]                     if (file_test("-f", pathname_tmp)) {
[16:12:33.481]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.481]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:33.481]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.481]                         fi_tmp[["mtime"]])
[16:12:33.481]                     }
[16:12:33.481]                     tryCatch({
[16:12:33.481]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:33.481]                     }, error = function(ex) {
[16:12:33.481]                       msg <- conditionMessage(ex)
[16:12:33.481]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.481]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:33.481]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.481]                         fi_tmp[["mtime"]], msg)
[16:12:33.481]                       ex$message <- msg
[16:12:33.481]                       stop(ex)
[16:12:33.481]                     })
[16:12:33.481]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:33.481]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:33.481]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:33.481]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.481]                       fi <- file.info(pathname)
[16:12:33.481]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:33.481]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.481]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:33.481]                         fi[["size"]], fi[["mtime"]])
[16:12:33.481]                       stop(msg)
[16:12:33.481]                     }
[16:12:33.481]                     invisible(pathname)
[16:12:33.481]                   }
[16:12:33.481]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:33.481]                     rootPath = tempdir()) 
[16:12:33.481]                   {
[16:12:33.481]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:33.481]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:33.481]                       tmpdir = path, fileext = ".rds")
[16:12:33.481]                     save_rds(obj, file)
[16:12:33.481]                   }
[16:12:33.481]                   saveImmediateCondition(cond, path = "/tmp/RtmpjVCO6F/.future/immediateConditions")
[16:12:33.481]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.481]                   {
[16:12:33.481]                     inherits <- base::inherits
[16:12:33.481]                     invokeRestart <- base::invokeRestart
[16:12:33.481]                     is.null <- base::is.null
[16:12:33.481]                     muffled <- FALSE
[16:12:33.481]                     if (inherits(cond, "message")) {
[16:12:33.481]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:33.481]                       if (muffled) 
[16:12:33.481]                         invokeRestart("muffleMessage")
[16:12:33.481]                     }
[16:12:33.481]                     else if (inherits(cond, "warning")) {
[16:12:33.481]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:33.481]                       if (muffled) 
[16:12:33.481]                         invokeRestart("muffleWarning")
[16:12:33.481]                     }
[16:12:33.481]                     else if (inherits(cond, "condition")) {
[16:12:33.481]                       if (!is.null(pattern)) {
[16:12:33.481]                         computeRestarts <- base::computeRestarts
[16:12:33.481]                         grepl <- base::grepl
[16:12:33.481]                         restarts <- computeRestarts(cond)
[16:12:33.481]                         for (restart in restarts) {
[16:12:33.481]                           name <- restart$name
[16:12:33.481]                           if (is.null(name)) 
[16:12:33.481]                             next
[16:12:33.481]                           if (!grepl(pattern, name)) 
[16:12:33.481]                             next
[16:12:33.481]                           invokeRestart(restart)
[16:12:33.481]                           muffled <- TRUE
[16:12:33.481]                           break
[16:12:33.481]                         }
[16:12:33.481]                       }
[16:12:33.481]                     }
[16:12:33.481]                     invisible(muffled)
[16:12:33.481]                   }
[16:12:33.481]                   muffleCondition(cond)
[16:12:33.481]                 })
[16:12:33.481]             }))
[16:12:33.481]             future::FutureResult(value = ...future.value$value, 
[16:12:33.481]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:33.481]                   ...future.rng), globalenv = if (FALSE) 
[16:12:33.481]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:33.481]                     ...future.globalenv.names))
[16:12:33.481]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:33.481]         }, condition = base::local({
[16:12:33.481]             c <- base::c
[16:12:33.481]             inherits <- base::inherits
[16:12:33.481]             invokeRestart <- base::invokeRestart
[16:12:33.481]             length <- base::length
[16:12:33.481]             list <- base::list
[16:12:33.481]             seq.int <- base::seq.int
[16:12:33.481]             signalCondition <- base::signalCondition
[16:12:33.481]             sys.calls <- base::sys.calls
[16:12:33.481]             `[[` <- base::`[[`
[16:12:33.481]             `+` <- base::`+`
[16:12:33.481]             `<<-` <- base::`<<-`
[16:12:33.481]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:33.481]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:33.481]                   3L)]
[16:12:33.481]             }
[16:12:33.481]             function(cond) {
[16:12:33.481]                 is_error <- inherits(cond, "error")
[16:12:33.481]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:33.481]                   NULL)
[16:12:33.481]                 if (is_error) {
[16:12:33.481]                   sessionInformation <- function() {
[16:12:33.481]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:33.481]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:33.481]                       search = base::search(), system = base::Sys.info())
[16:12:33.481]                   }
[16:12:33.481]                   ...future.conditions[[length(...future.conditions) + 
[16:12:33.481]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:33.481]                     cond$call), session = sessionInformation(), 
[16:12:33.481]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:33.481]                   signalCondition(cond)
[16:12:33.481]                 }
[16:12:33.481]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:33.481]                 "immediateCondition"))) {
[16:12:33.481]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:33.481]                   ...future.conditions[[length(...future.conditions) + 
[16:12:33.481]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:33.481]                   if (TRUE && !signal) {
[16:12:33.481]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.481]                     {
[16:12:33.481]                       inherits <- base::inherits
[16:12:33.481]                       invokeRestart <- base::invokeRestart
[16:12:33.481]                       is.null <- base::is.null
[16:12:33.481]                       muffled <- FALSE
[16:12:33.481]                       if (inherits(cond, "message")) {
[16:12:33.481]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:33.481]                         if (muffled) 
[16:12:33.481]                           invokeRestart("muffleMessage")
[16:12:33.481]                       }
[16:12:33.481]                       else if (inherits(cond, "warning")) {
[16:12:33.481]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:33.481]                         if (muffled) 
[16:12:33.481]                           invokeRestart("muffleWarning")
[16:12:33.481]                       }
[16:12:33.481]                       else if (inherits(cond, "condition")) {
[16:12:33.481]                         if (!is.null(pattern)) {
[16:12:33.481]                           computeRestarts <- base::computeRestarts
[16:12:33.481]                           grepl <- base::grepl
[16:12:33.481]                           restarts <- computeRestarts(cond)
[16:12:33.481]                           for (restart in restarts) {
[16:12:33.481]                             name <- restart$name
[16:12:33.481]                             if (is.null(name)) 
[16:12:33.481]                               next
[16:12:33.481]                             if (!grepl(pattern, name)) 
[16:12:33.481]                               next
[16:12:33.481]                             invokeRestart(restart)
[16:12:33.481]                             muffled <- TRUE
[16:12:33.481]                             break
[16:12:33.481]                           }
[16:12:33.481]                         }
[16:12:33.481]                       }
[16:12:33.481]                       invisible(muffled)
[16:12:33.481]                     }
[16:12:33.481]                     muffleCondition(cond, pattern = "^muffle")
[16:12:33.481]                   }
[16:12:33.481]                 }
[16:12:33.481]                 else {
[16:12:33.481]                   if (TRUE) {
[16:12:33.481]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.481]                     {
[16:12:33.481]                       inherits <- base::inherits
[16:12:33.481]                       invokeRestart <- base::invokeRestart
[16:12:33.481]                       is.null <- base::is.null
[16:12:33.481]                       muffled <- FALSE
[16:12:33.481]                       if (inherits(cond, "message")) {
[16:12:33.481]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:33.481]                         if (muffled) 
[16:12:33.481]                           invokeRestart("muffleMessage")
[16:12:33.481]                       }
[16:12:33.481]                       else if (inherits(cond, "warning")) {
[16:12:33.481]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:33.481]                         if (muffled) 
[16:12:33.481]                           invokeRestart("muffleWarning")
[16:12:33.481]                       }
[16:12:33.481]                       else if (inherits(cond, "condition")) {
[16:12:33.481]                         if (!is.null(pattern)) {
[16:12:33.481]                           computeRestarts <- base::computeRestarts
[16:12:33.481]                           grepl <- base::grepl
[16:12:33.481]                           restarts <- computeRestarts(cond)
[16:12:33.481]                           for (restart in restarts) {
[16:12:33.481]                             name <- restart$name
[16:12:33.481]                             if (is.null(name)) 
[16:12:33.481]                               next
[16:12:33.481]                             if (!grepl(pattern, name)) 
[16:12:33.481]                               next
[16:12:33.481]                             invokeRestart(restart)
[16:12:33.481]                             muffled <- TRUE
[16:12:33.481]                             break
[16:12:33.481]                           }
[16:12:33.481]                         }
[16:12:33.481]                       }
[16:12:33.481]                       invisible(muffled)
[16:12:33.481]                     }
[16:12:33.481]                     muffleCondition(cond, pattern = "^muffle")
[16:12:33.481]                   }
[16:12:33.481]                 }
[16:12:33.481]             }
[16:12:33.481]         }))
[16:12:33.481]     }, error = function(ex) {
[16:12:33.481]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:33.481]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:33.481]                 ...future.rng), started = ...future.startTime, 
[16:12:33.481]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:33.481]             version = "1.8"), class = "FutureResult")
[16:12:33.481]     }, finally = {
[16:12:33.481]         if (!identical(...future.workdir, getwd())) 
[16:12:33.481]             setwd(...future.workdir)
[16:12:33.481]         {
[16:12:33.481]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:33.481]                 ...future.oldOptions$nwarnings <- NULL
[16:12:33.481]             }
[16:12:33.481]             base::options(...future.oldOptions)
[16:12:33.481]             if (.Platform$OS.type == "windows") {
[16:12:33.481]                 old_names <- names(...future.oldEnvVars)
[16:12:33.481]                 envs <- base::Sys.getenv()
[16:12:33.481]                 names <- names(envs)
[16:12:33.481]                 common <- intersect(names, old_names)
[16:12:33.481]                 added <- setdiff(names, old_names)
[16:12:33.481]                 removed <- setdiff(old_names, names)
[16:12:33.481]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:33.481]                   envs[common]]
[16:12:33.481]                 NAMES <- toupper(changed)
[16:12:33.481]                 args <- list()
[16:12:33.481]                 for (kk in seq_along(NAMES)) {
[16:12:33.481]                   name <- changed[[kk]]
[16:12:33.481]                   NAME <- NAMES[[kk]]
[16:12:33.481]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.481]                     next
[16:12:33.481]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:33.481]                 }
[16:12:33.481]                 NAMES <- toupper(added)
[16:12:33.481]                 for (kk in seq_along(NAMES)) {
[16:12:33.481]                   name <- added[[kk]]
[16:12:33.481]                   NAME <- NAMES[[kk]]
[16:12:33.481]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.481]                     next
[16:12:33.481]                   args[[name]] <- ""
[16:12:33.481]                 }
[16:12:33.481]                 NAMES <- toupper(removed)
[16:12:33.481]                 for (kk in seq_along(NAMES)) {
[16:12:33.481]                   name <- removed[[kk]]
[16:12:33.481]                   NAME <- NAMES[[kk]]
[16:12:33.481]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.481]                     next
[16:12:33.481]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:33.481]                 }
[16:12:33.481]                 if (length(args) > 0) 
[16:12:33.481]                   base::do.call(base::Sys.setenv, args = args)
[16:12:33.481]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:33.481]             }
[16:12:33.481]             else {
[16:12:33.481]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:33.481]             }
[16:12:33.481]             {
[16:12:33.481]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:33.481]                   0L) {
[16:12:33.481]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:33.481]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:33.481]                   base::options(opts)
[16:12:33.481]                 }
[16:12:33.481]                 {
[16:12:33.481]                   {
[16:12:33.481]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:33.481]                     NULL
[16:12:33.481]                   }
[16:12:33.481]                   options(future.plan = NULL)
[16:12:33.481]                   if (is.na(NA_character_)) 
[16:12:33.481]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:33.481]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:33.481]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:33.481]                     envir = parent.frame()) 
[16:12:33.481]                   {
[16:12:33.481]                     default_workers <- missing(workers)
[16:12:33.481]                     if (is.function(workers)) 
[16:12:33.481]                       workers <- workers()
[16:12:33.481]                     workers <- structure(as.integer(workers), 
[16:12:33.481]                       class = class(workers))
[16:12:33.481]                     stop_if_not(is.finite(workers), workers >= 
[16:12:33.481]                       1L)
[16:12:33.481]                     if ((workers == 1L && !inherits(workers, 
[16:12:33.481]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:33.481]                       if (default_workers) 
[16:12:33.481]                         supportsMulticore(warn = TRUE)
[16:12:33.481]                       return(sequential(..., envir = envir))
[16:12:33.481]                     }
[16:12:33.481]                     oopts <- options(mc.cores = workers)
[16:12:33.481]                     on.exit(options(oopts))
[16:12:33.481]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:33.481]                       envir = envir)
[16:12:33.481]                     if (!future$lazy) 
[16:12:33.481]                       future <- run(future)
[16:12:33.481]                     invisible(future)
[16:12:33.481]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:33.481]                 }
[16:12:33.481]             }
[16:12:33.481]         }
[16:12:33.481]     })
[16:12:33.481]     if (TRUE) {
[16:12:33.481]         base::sink(type = "output", split = FALSE)
[16:12:33.481]         if (TRUE) {
[16:12:33.481]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:33.481]         }
[16:12:33.481]         else {
[16:12:33.481]             ...future.result["stdout"] <- base::list(NULL)
[16:12:33.481]         }
[16:12:33.481]         base::close(...future.stdout)
[16:12:33.481]         ...future.stdout <- NULL
[16:12:33.481]     }
[16:12:33.481]     ...future.result$conditions <- ...future.conditions
[16:12:33.481]     ...future.result$finished <- base::Sys.time()
[16:12:33.481]     ...future.result
[16:12:33.481] }
[16:12:33.484] requestCore(): workers = 2
[16:12:33.486] MulticoreFuture started
[16:12:33.486] - Launch lazy future ... done
[16:12:33.486] run() for ‘MulticoreFuture’ ... done
[16:12:33.487] plan(): Setting new future strategy stack:
[16:12:33.488] List of future strategies:
[16:12:33.488] 1. sequential:
[16:12:33.488]    - args: function (..., envir = parent.frame())
[16:12:33.488]    - tweaked: FALSE
[16:12:33.488]    - call: NULL
[16:12:33.489] plan(): nbrOfWorkers() = 1
[16:12:33.492] plan(): Setting new future strategy stack:
[16:12:33.492] List of future strategies:
[16:12:33.492] 1. multicore:
[16:12:33.492]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:33.492]    - tweaked: FALSE
[16:12:33.492]    - call: plan(strategy)
[16:12:33.497] plan(): nbrOfWorkers() = 2

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[16:12:33.503] getGlobalsAndPackages() ...
[16:12:33.503] Searching for globals...
[16:12:33.509] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[16:12:33.510] Searching for globals ... DONE
[16:12:33.510] Resolving globals: FALSE
[16:12:33.510] 
[16:12:33.511] - packages: [2] ‘stats’, ‘datasets’
[16:12:33.511] getGlobalsAndPackages() ... DONE
[16:12:33.511] run() for ‘Future’ ...
[16:12:33.511] - state: ‘created’
[16:12:33.511] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:33.515] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:33.515] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:33.516]   - Field: ‘label’
[16:12:33.516]   - Field: ‘local’
[16:12:33.516]   - Field: ‘owner’
[16:12:33.516]   - Field: ‘envir’
[16:12:33.516]   - Field: ‘workers’
[16:12:33.516]   - Field: ‘packages’
[16:12:33.516]   - Field: ‘gc’
[16:12:33.517]   - Field: ‘job’
[16:12:33.517]   - Field: ‘conditions’
[16:12:33.517]   - Field: ‘expr’
[16:12:33.517]   - Field: ‘uuid’
[16:12:33.517]   - Field: ‘seed’
[16:12:33.517]   - Field: ‘version’
[16:12:33.517]   - Field: ‘result’
[16:12:33.517]   - Field: ‘asynchronous’
[16:12:33.518]   - Field: ‘calls’
[16:12:33.518]   - Field: ‘globals’
[16:12:33.518]   - Field: ‘stdout’
[16:12:33.518]   - Field: ‘earlySignal’
[16:12:33.518]   - Field: ‘lazy’
[16:12:33.518]   - Field: ‘state’
[16:12:33.518] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:33.518] - Launch lazy future ...
[16:12:33.519] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:12:33.519] Packages needed by future strategies (n = 0): <none>
[16:12:33.519] {
[16:12:33.519]     {
[16:12:33.519]         {
[16:12:33.519]             ...future.startTime <- base::Sys.time()
[16:12:33.519]             {
[16:12:33.519]                 {
[16:12:33.519]                   {
[16:12:33.519]                     {
[16:12:33.519]                       {
[16:12:33.519]                         base::local({
[16:12:33.519]                           has_future <- base::requireNamespace("future", 
[16:12:33.519]                             quietly = TRUE)
[16:12:33.519]                           if (has_future) {
[16:12:33.519]                             ns <- base::getNamespace("future")
[16:12:33.519]                             version <- ns[[".package"]][["version"]]
[16:12:33.519]                             if (is.null(version)) 
[16:12:33.519]                               version <- utils::packageVersion("future")
[16:12:33.519]                           }
[16:12:33.519]                           else {
[16:12:33.519]                             version <- NULL
[16:12:33.519]                           }
[16:12:33.519]                           if (!has_future || version < "1.8.0") {
[16:12:33.519]                             info <- base::c(r_version = base::gsub("R version ", 
[16:12:33.519]                               "", base::R.version$version.string), 
[16:12:33.519]                               platform = base::sprintf("%s (%s-bit)", 
[16:12:33.519]                                 base::R.version$platform, 8 * 
[16:12:33.519]                                   base::.Machine$sizeof.pointer), 
[16:12:33.519]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:33.519]                                 "release", "version")], collapse = " "), 
[16:12:33.519]                               hostname = base::Sys.info()[["nodename"]])
[16:12:33.519]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:12:33.519]                               info)
[16:12:33.519]                             info <- base::paste(info, collapse = "; ")
[16:12:33.519]                             if (!has_future) {
[16:12:33.519]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:33.519]                                 info)
[16:12:33.519]                             }
[16:12:33.519]                             else {
[16:12:33.519]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:33.519]                                 info, version)
[16:12:33.519]                             }
[16:12:33.519]                             base::stop(msg)
[16:12:33.519]                           }
[16:12:33.519]                         })
[16:12:33.519]                       }
[16:12:33.519]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:33.519]                       base::options(mc.cores = 1L)
[16:12:33.519]                     }
[16:12:33.519]                     base::local({
[16:12:33.519]                       for (pkg in c("stats", "datasets")) {
[16:12:33.519]                         base::loadNamespace(pkg)
[16:12:33.519]                         base::library(pkg, character.only = TRUE)
[16:12:33.519]                       }
[16:12:33.519]                     })
[16:12:33.519]                   }
[16:12:33.519]                   options(future.plan = NULL)
[16:12:33.519]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:33.519]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:33.519]                 }
[16:12:33.519]                 ...future.workdir <- getwd()
[16:12:33.519]             }
[16:12:33.519]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:33.519]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:33.519]         }
[16:12:33.519]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:33.519]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:33.519]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:33.519]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:33.519]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:33.519]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:33.519]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:33.519]             base::names(...future.oldOptions))
[16:12:33.519]     }
[16:12:33.519]     if (FALSE) {
[16:12:33.519]     }
[16:12:33.519]     else {
[16:12:33.519]         if (TRUE) {
[16:12:33.519]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:33.519]                 open = "w")
[16:12:33.519]         }
[16:12:33.519]         else {
[16:12:33.519]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:33.519]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:33.519]         }
[16:12:33.519]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:33.519]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:33.519]             base::sink(type = "output", split = FALSE)
[16:12:33.519]             base::close(...future.stdout)
[16:12:33.519]         }, add = TRUE)
[16:12:33.519]     }
[16:12:33.519]     ...future.frame <- base::sys.nframe()
[16:12:33.519]     ...future.conditions <- base::list()
[16:12:33.519]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:33.519]     if (FALSE) {
[16:12:33.519]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:33.519]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:33.519]     }
[16:12:33.519]     ...future.result <- base::tryCatch({
[16:12:33.519]         base::withCallingHandlers({
[16:12:33.519]             ...future.value <- base::withVisible(base::local({
[16:12:33.519]                 withCallingHandlers({
[16:12:33.519]                   {
[16:12:33.519]                     lm(dist ~ speed + I(speed^2), data = cars)
[16:12:33.519]                   }
[16:12:33.519]                 }, immediateCondition = function(cond) {
[16:12:33.519]                   save_rds <- function (object, pathname, ...) 
[16:12:33.519]                   {
[16:12:33.519]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:33.519]                     if (file_test("-f", pathname_tmp)) {
[16:12:33.519]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.519]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:33.519]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.519]                         fi_tmp[["mtime"]])
[16:12:33.519]                     }
[16:12:33.519]                     tryCatch({
[16:12:33.519]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:33.519]                     }, error = function(ex) {
[16:12:33.519]                       msg <- conditionMessage(ex)
[16:12:33.519]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.519]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:33.519]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.519]                         fi_tmp[["mtime"]], msg)
[16:12:33.519]                       ex$message <- msg
[16:12:33.519]                       stop(ex)
[16:12:33.519]                     })
[16:12:33.519]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:33.519]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:33.519]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:33.519]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.519]                       fi <- file.info(pathname)
[16:12:33.519]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:33.519]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.519]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:33.519]                         fi[["size"]], fi[["mtime"]])
[16:12:33.519]                       stop(msg)
[16:12:33.519]                     }
[16:12:33.519]                     invisible(pathname)
[16:12:33.519]                   }
[16:12:33.519]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:33.519]                     rootPath = tempdir()) 
[16:12:33.519]                   {
[16:12:33.519]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:33.519]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:33.519]                       tmpdir = path, fileext = ".rds")
[16:12:33.519]                     save_rds(obj, file)
[16:12:33.519]                   }
[16:12:33.519]                   saveImmediateCondition(cond, path = "/tmp/RtmpjVCO6F/.future/immediateConditions")
[16:12:33.519]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.519]                   {
[16:12:33.519]                     inherits <- base::inherits
[16:12:33.519]                     invokeRestart <- base::invokeRestart
[16:12:33.519]                     is.null <- base::is.null
[16:12:33.519]                     muffled <- FALSE
[16:12:33.519]                     if (inherits(cond, "message")) {
[16:12:33.519]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:33.519]                       if (muffled) 
[16:12:33.519]                         invokeRestart("muffleMessage")
[16:12:33.519]                     }
[16:12:33.519]                     else if (inherits(cond, "warning")) {
[16:12:33.519]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:33.519]                       if (muffled) 
[16:12:33.519]                         invokeRestart("muffleWarning")
[16:12:33.519]                     }
[16:12:33.519]                     else if (inherits(cond, "condition")) {
[16:12:33.519]                       if (!is.null(pattern)) {
[16:12:33.519]                         computeRestarts <- base::computeRestarts
[16:12:33.519]                         grepl <- base::grepl
[16:12:33.519]                         restarts <- computeRestarts(cond)
[16:12:33.519]                         for (restart in restarts) {
[16:12:33.519]                           name <- restart$name
[16:12:33.519]                           if (is.null(name)) 
[16:12:33.519]                             next
[16:12:33.519]                           if (!grepl(pattern, name)) 
[16:12:33.519]                             next
[16:12:33.519]                           invokeRestart(restart)
[16:12:33.519]                           muffled <- TRUE
[16:12:33.519]                           break
[16:12:33.519]                         }
[16:12:33.519]                       }
[16:12:33.519]                     }
[16:12:33.519]                     invisible(muffled)
[16:12:33.519]                   }
[16:12:33.519]                   muffleCondition(cond)
[16:12:33.519]                 })
[16:12:33.519]             }))
[16:12:33.519]             future::FutureResult(value = ...future.value$value, 
[16:12:33.519]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:33.519]                   ...future.rng), globalenv = if (FALSE) 
[16:12:33.519]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:33.519]                     ...future.globalenv.names))
[16:12:33.519]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:33.519]         }, condition = base::local({
[16:12:33.519]             c <- base::c
[16:12:33.519]             inherits <- base::inherits
[16:12:33.519]             invokeRestart <- base::invokeRestart
[16:12:33.519]             length <- base::length
[16:12:33.519]             list <- base::list
[16:12:33.519]             seq.int <- base::seq.int
[16:12:33.519]             signalCondition <- base::signalCondition
[16:12:33.519]             sys.calls <- base::sys.calls
[16:12:33.519]             `[[` <- base::`[[`
[16:12:33.519]             `+` <- base::`+`
[16:12:33.519]             `<<-` <- base::`<<-`
[16:12:33.519]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:33.519]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:33.519]                   3L)]
[16:12:33.519]             }
[16:12:33.519]             function(cond) {
[16:12:33.519]                 is_error <- inherits(cond, "error")
[16:12:33.519]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:33.519]                   NULL)
[16:12:33.519]                 if (is_error) {
[16:12:33.519]                   sessionInformation <- function() {
[16:12:33.519]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:33.519]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:33.519]                       search = base::search(), system = base::Sys.info())
[16:12:33.519]                   }
[16:12:33.519]                   ...future.conditions[[length(...future.conditions) + 
[16:12:33.519]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:33.519]                     cond$call), session = sessionInformation(), 
[16:12:33.519]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:33.519]                   signalCondition(cond)
[16:12:33.519]                 }
[16:12:33.519]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:33.519]                 "immediateCondition"))) {
[16:12:33.519]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:33.519]                   ...future.conditions[[length(...future.conditions) + 
[16:12:33.519]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:33.519]                   if (TRUE && !signal) {
[16:12:33.519]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.519]                     {
[16:12:33.519]                       inherits <- base::inherits
[16:12:33.519]                       invokeRestart <- base::invokeRestart
[16:12:33.519]                       is.null <- base::is.null
[16:12:33.519]                       muffled <- FALSE
[16:12:33.519]                       if (inherits(cond, "message")) {
[16:12:33.519]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:33.519]                         if (muffled) 
[16:12:33.519]                           invokeRestart("muffleMessage")
[16:12:33.519]                       }
[16:12:33.519]                       else if (inherits(cond, "warning")) {
[16:12:33.519]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:33.519]                         if (muffled) 
[16:12:33.519]                           invokeRestart("muffleWarning")
[16:12:33.519]                       }
[16:12:33.519]                       else if (inherits(cond, "condition")) {
[16:12:33.519]                         if (!is.null(pattern)) {
[16:12:33.519]                           computeRestarts <- base::computeRestarts
[16:12:33.519]                           grepl <- base::grepl
[16:12:33.519]                           restarts <- computeRestarts(cond)
[16:12:33.519]                           for (restart in restarts) {
[16:12:33.519]                             name <- restart$name
[16:12:33.519]                             if (is.null(name)) 
[16:12:33.519]                               next
[16:12:33.519]                             if (!grepl(pattern, name)) 
[16:12:33.519]                               next
[16:12:33.519]                             invokeRestart(restart)
[16:12:33.519]                             muffled <- TRUE
[16:12:33.519]                             break
[16:12:33.519]                           }
[16:12:33.519]                         }
[16:12:33.519]                       }
[16:12:33.519]                       invisible(muffled)
[16:12:33.519]                     }
[16:12:33.519]                     muffleCondition(cond, pattern = "^muffle")
[16:12:33.519]                   }
[16:12:33.519]                 }
[16:12:33.519]                 else {
[16:12:33.519]                   if (TRUE) {
[16:12:33.519]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.519]                     {
[16:12:33.519]                       inherits <- base::inherits
[16:12:33.519]                       invokeRestart <- base::invokeRestart
[16:12:33.519]                       is.null <- base::is.null
[16:12:33.519]                       muffled <- FALSE
[16:12:33.519]                       if (inherits(cond, "message")) {
[16:12:33.519]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:33.519]                         if (muffled) 
[16:12:33.519]                           invokeRestart("muffleMessage")
[16:12:33.519]                       }
[16:12:33.519]                       else if (inherits(cond, "warning")) {
[16:12:33.519]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:33.519]                         if (muffled) 
[16:12:33.519]                           invokeRestart("muffleWarning")
[16:12:33.519]                       }
[16:12:33.519]                       else if (inherits(cond, "condition")) {
[16:12:33.519]                         if (!is.null(pattern)) {
[16:12:33.519]                           computeRestarts <- base::computeRestarts
[16:12:33.519]                           grepl <- base::grepl
[16:12:33.519]                           restarts <- computeRestarts(cond)
[16:12:33.519]                           for (restart in restarts) {
[16:12:33.519]                             name <- restart$name
[16:12:33.519]                             if (is.null(name)) 
[16:12:33.519]                               next
[16:12:33.519]                             if (!grepl(pattern, name)) 
[16:12:33.519]                               next
[16:12:33.519]                             invokeRestart(restart)
[16:12:33.519]                             muffled <- TRUE
[16:12:33.519]                             break
[16:12:33.519]                           }
[16:12:33.519]                         }
[16:12:33.519]                       }
[16:12:33.519]                       invisible(muffled)
[16:12:33.519]                     }
[16:12:33.519]                     muffleCondition(cond, pattern = "^muffle")
[16:12:33.519]                   }
[16:12:33.519]                 }
[16:12:33.519]             }
[16:12:33.519]         }))
[16:12:33.519]     }, error = function(ex) {
[16:12:33.519]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:33.519]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:33.519]                 ...future.rng), started = ...future.startTime, 
[16:12:33.519]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:33.519]             version = "1.8"), class = "FutureResult")
[16:12:33.519]     }, finally = {
[16:12:33.519]         if (!identical(...future.workdir, getwd())) 
[16:12:33.519]             setwd(...future.workdir)
[16:12:33.519]         {
[16:12:33.519]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:33.519]                 ...future.oldOptions$nwarnings <- NULL
[16:12:33.519]             }
[16:12:33.519]             base::options(...future.oldOptions)
[16:12:33.519]             if (.Platform$OS.type == "windows") {
[16:12:33.519]                 old_names <- names(...future.oldEnvVars)
[16:12:33.519]                 envs <- base::Sys.getenv()
[16:12:33.519]                 names <- names(envs)
[16:12:33.519]                 common <- intersect(names, old_names)
[16:12:33.519]                 added <- setdiff(names, old_names)
[16:12:33.519]                 removed <- setdiff(old_names, names)
[16:12:33.519]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:33.519]                   envs[common]]
[16:12:33.519]                 NAMES <- toupper(changed)
[16:12:33.519]                 args <- list()
[16:12:33.519]                 for (kk in seq_along(NAMES)) {
[16:12:33.519]                   name <- changed[[kk]]
[16:12:33.519]                   NAME <- NAMES[[kk]]
[16:12:33.519]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.519]                     next
[16:12:33.519]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:33.519]                 }
[16:12:33.519]                 NAMES <- toupper(added)
[16:12:33.519]                 for (kk in seq_along(NAMES)) {
[16:12:33.519]                   name <- added[[kk]]
[16:12:33.519]                   NAME <- NAMES[[kk]]
[16:12:33.519]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.519]                     next
[16:12:33.519]                   args[[name]] <- ""
[16:12:33.519]                 }
[16:12:33.519]                 NAMES <- toupper(removed)
[16:12:33.519]                 for (kk in seq_along(NAMES)) {
[16:12:33.519]                   name <- removed[[kk]]
[16:12:33.519]                   NAME <- NAMES[[kk]]
[16:12:33.519]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.519]                     next
[16:12:33.519]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:33.519]                 }
[16:12:33.519]                 if (length(args) > 0) 
[16:12:33.519]                   base::do.call(base::Sys.setenv, args = args)
[16:12:33.519]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:33.519]             }
[16:12:33.519]             else {
[16:12:33.519]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:33.519]             }
[16:12:33.519]             {
[16:12:33.519]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:33.519]                   0L) {
[16:12:33.519]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:33.519]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:33.519]                   base::options(opts)
[16:12:33.519]                 }
[16:12:33.519]                 {
[16:12:33.519]                   {
[16:12:33.519]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:33.519]                     NULL
[16:12:33.519]                   }
[16:12:33.519]                   options(future.plan = NULL)
[16:12:33.519]                   if (is.na(NA_character_)) 
[16:12:33.519]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:33.519]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:33.519]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:33.519]                     envir = parent.frame()) 
[16:12:33.519]                   {
[16:12:33.519]                     default_workers <- missing(workers)
[16:12:33.519]                     if (is.function(workers)) 
[16:12:33.519]                       workers <- workers()
[16:12:33.519]                     workers <- structure(as.integer(workers), 
[16:12:33.519]                       class = class(workers))
[16:12:33.519]                     stop_if_not(is.finite(workers), workers >= 
[16:12:33.519]                       1L)
[16:12:33.519]                     if ((workers == 1L && !inherits(workers, 
[16:12:33.519]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:33.519]                       if (default_workers) 
[16:12:33.519]                         supportsMulticore(warn = TRUE)
[16:12:33.519]                       return(sequential(..., envir = envir))
[16:12:33.519]                     }
[16:12:33.519]                     oopts <- options(mc.cores = workers)
[16:12:33.519]                     on.exit(options(oopts))
[16:12:33.519]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:33.519]                       envir = envir)
[16:12:33.519]                     if (!future$lazy) 
[16:12:33.519]                       future <- run(future)
[16:12:33.519]                     invisible(future)
[16:12:33.519]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:33.519]                 }
[16:12:33.519]             }
[16:12:33.519]         }
[16:12:33.519]     })
[16:12:33.519]     if (TRUE) {
[16:12:33.519]         base::sink(type = "output", split = FALSE)
[16:12:33.519]         if (TRUE) {
[16:12:33.519]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:33.519]         }
[16:12:33.519]         else {
[16:12:33.519]             ...future.result["stdout"] <- base::list(NULL)
[16:12:33.519]         }
[16:12:33.519]         base::close(...future.stdout)
[16:12:33.519]         ...future.stdout <- NULL
[16:12:33.519]     }
[16:12:33.519]     ...future.result$conditions <- ...future.conditions
[16:12:33.519]     ...future.result$finished <- base::Sys.time()
[16:12:33.519]     ...future.result
[16:12:33.519] }
[16:12:33.522] requestCore(): workers = 2
[16:12:33.524] MulticoreFuture started
[16:12:33.524] - Launch lazy future ... done
[16:12:33.525] run() for ‘MulticoreFuture’ ... done
[16:12:33.526] plan(): Setting new future strategy stack:
[16:12:33.526] List of future strategies:
[16:12:33.526] 1. sequential:
[16:12:33.526]    - args: function (..., envir = parent.frame())
[16:12:33.526]    - tweaked: FALSE
[16:12:33.526]    - call: NULL
[16:12:33.527] plan(): nbrOfWorkers() = 1
[16:12:33.531] plan(): Setting new future strategy stack:
[16:12:33.531] List of future strategies:
[16:12:33.531] 1. multicore:
[16:12:33.531]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:33.531]    - tweaked: FALSE
[16:12:33.531]    - call: plan(strategy)
[16:12:33.536] plan(): nbrOfWorkers() = 2

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[16:12:33.542] getGlobalsAndPackages() ...
[16:12:33.542] Searching for globals...
[16:12:33.544] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[16:12:33.544] Searching for globals ... DONE
[16:12:33.545] Resolving globals: FALSE
[16:12:33.545] 
[16:12:33.545] - packages: [2] ‘stats’, ‘datasets’
[16:12:33.546] getGlobalsAndPackages() ... DONE
[16:12:33.546] run() for ‘Future’ ...
[16:12:33.546] - state: ‘created’
[16:12:33.546] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:33.550] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:33.550] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:33.551]   - Field: ‘label’
[16:12:33.551]   - Field: ‘local’
[16:12:33.551]   - Field: ‘owner’
[16:12:33.551]   - Field: ‘envir’
[16:12:33.551]   - Field: ‘workers’
[16:12:33.551]   - Field: ‘packages’
[16:12:33.551]   - Field: ‘gc’
[16:12:33.551]   - Field: ‘job’
[16:12:33.552]   - Field: ‘conditions’
[16:12:33.552]   - Field: ‘expr’
[16:12:33.552]   - Field: ‘uuid’
[16:12:33.552]   - Field: ‘seed’
[16:12:33.552]   - Field: ‘version’
[16:12:33.552]   - Field: ‘result’
[16:12:33.552]   - Field: ‘asynchronous’
[16:12:33.552]   - Field: ‘calls’
[16:12:33.552]   - Field: ‘globals’
[16:12:33.553]   - Field: ‘stdout’
[16:12:33.553]   - Field: ‘earlySignal’
[16:12:33.553]   - Field: ‘lazy’
[16:12:33.553]   - Field: ‘state’
[16:12:33.553] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:33.553] - Launch lazy future ...
[16:12:33.554] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:12:33.554] Packages needed by future strategies (n = 0): <none>
[16:12:33.554] {
[16:12:33.554]     {
[16:12:33.554]         {
[16:12:33.554]             ...future.startTime <- base::Sys.time()
[16:12:33.554]             {
[16:12:33.554]                 {
[16:12:33.554]                   {
[16:12:33.554]                     {
[16:12:33.554]                       {
[16:12:33.554]                         base::local({
[16:12:33.554]                           has_future <- base::requireNamespace("future", 
[16:12:33.554]                             quietly = TRUE)
[16:12:33.554]                           if (has_future) {
[16:12:33.554]                             ns <- base::getNamespace("future")
[16:12:33.554]                             version <- ns[[".package"]][["version"]]
[16:12:33.554]                             if (is.null(version)) 
[16:12:33.554]                               version <- utils::packageVersion("future")
[16:12:33.554]                           }
[16:12:33.554]                           else {
[16:12:33.554]                             version <- NULL
[16:12:33.554]                           }
[16:12:33.554]                           if (!has_future || version < "1.8.0") {
[16:12:33.554]                             info <- base::c(r_version = base::gsub("R version ", 
[16:12:33.554]                               "", base::R.version$version.string), 
[16:12:33.554]                               platform = base::sprintf("%s (%s-bit)", 
[16:12:33.554]                                 base::R.version$platform, 8 * 
[16:12:33.554]                                   base::.Machine$sizeof.pointer), 
[16:12:33.554]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:33.554]                                 "release", "version")], collapse = " "), 
[16:12:33.554]                               hostname = base::Sys.info()[["nodename"]])
[16:12:33.554]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:12:33.554]                               info)
[16:12:33.554]                             info <- base::paste(info, collapse = "; ")
[16:12:33.554]                             if (!has_future) {
[16:12:33.554]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:33.554]                                 info)
[16:12:33.554]                             }
[16:12:33.554]                             else {
[16:12:33.554]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:33.554]                                 info, version)
[16:12:33.554]                             }
[16:12:33.554]                             base::stop(msg)
[16:12:33.554]                           }
[16:12:33.554]                         })
[16:12:33.554]                       }
[16:12:33.554]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:33.554]                       base::options(mc.cores = 1L)
[16:12:33.554]                     }
[16:12:33.554]                     base::local({
[16:12:33.554]                       for (pkg in c("stats", "datasets")) {
[16:12:33.554]                         base::loadNamespace(pkg)
[16:12:33.554]                         base::library(pkg, character.only = TRUE)
[16:12:33.554]                       }
[16:12:33.554]                     })
[16:12:33.554]                   }
[16:12:33.554]                   options(future.plan = NULL)
[16:12:33.554]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:33.554]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:33.554]                 }
[16:12:33.554]                 ...future.workdir <- getwd()
[16:12:33.554]             }
[16:12:33.554]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:33.554]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:33.554]         }
[16:12:33.554]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:33.554]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:33.554]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:33.554]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:33.554]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:33.554]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:33.554]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:33.554]             base::names(...future.oldOptions))
[16:12:33.554]     }
[16:12:33.554]     if (FALSE) {
[16:12:33.554]     }
[16:12:33.554]     else {
[16:12:33.554]         if (TRUE) {
[16:12:33.554]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:33.554]                 open = "w")
[16:12:33.554]         }
[16:12:33.554]         else {
[16:12:33.554]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:33.554]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:33.554]         }
[16:12:33.554]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:33.554]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:33.554]             base::sink(type = "output", split = FALSE)
[16:12:33.554]             base::close(...future.stdout)
[16:12:33.554]         }, add = TRUE)
[16:12:33.554]     }
[16:12:33.554]     ...future.frame <- base::sys.nframe()
[16:12:33.554]     ...future.conditions <- base::list()
[16:12:33.554]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:33.554]     if (FALSE) {
[16:12:33.554]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:33.554]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:33.554]     }
[16:12:33.554]     ...future.result <- base::tryCatch({
[16:12:33.554]         base::withCallingHandlers({
[16:12:33.554]             ...future.value <- base::withVisible(base::local({
[16:12:33.554]                 withCallingHandlers({
[16:12:33.554]                   {
[16:12:33.554]                     lm(dist ~ poly(speed, 2), data = cars)
[16:12:33.554]                   }
[16:12:33.554]                 }, immediateCondition = function(cond) {
[16:12:33.554]                   save_rds <- function (object, pathname, ...) 
[16:12:33.554]                   {
[16:12:33.554]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:33.554]                     if (file_test("-f", pathname_tmp)) {
[16:12:33.554]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.554]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:33.554]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.554]                         fi_tmp[["mtime"]])
[16:12:33.554]                     }
[16:12:33.554]                     tryCatch({
[16:12:33.554]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:33.554]                     }, error = function(ex) {
[16:12:33.554]                       msg <- conditionMessage(ex)
[16:12:33.554]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.554]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:33.554]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.554]                         fi_tmp[["mtime"]], msg)
[16:12:33.554]                       ex$message <- msg
[16:12:33.554]                       stop(ex)
[16:12:33.554]                     })
[16:12:33.554]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:33.554]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:33.554]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:33.554]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.554]                       fi <- file.info(pathname)
[16:12:33.554]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:33.554]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.554]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:33.554]                         fi[["size"]], fi[["mtime"]])
[16:12:33.554]                       stop(msg)
[16:12:33.554]                     }
[16:12:33.554]                     invisible(pathname)
[16:12:33.554]                   }
[16:12:33.554]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:33.554]                     rootPath = tempdir()) 
[16:12:33.554]                   {
[16:12:33.554]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:33.554]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:33.554]                       tmpdir = path, fileext = ".rds")
[16:12:33.554]                     save_rds(obj, file)
[16:12:33.554]                   }
[16:12:33.554]                   saveImmediateCondition(cond, path = "/tmp/RtmpjVCO6F/.future/immediateConditions")
[16:12:33.554]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.554]                   {
[16:12:33.554]                     inherits <- base::inherits
[16:12:33.554]                     invokeRestart <- base::invokeRestart
[16:12:33.554]                     is.null <- base::is.null
[16:12:33.554]                     muffled <- FALSE
[16:12:33.554]                     if (inherits(cond, "message")) {
[16:12:33.554]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:33.554]                       if (muffled) 
[16:12:33.554]                         invokeRestart("muffleMessage")
[16:12:33.554]                     }
[16:12:33.554]                     else if (inherits(cond, "warning")) {
[16:12:33.554]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:33.554]                       if (muffled) 
[16:12:33.554]                         invokeRestart("muffleWarning")
[16:12:33.554]                     }
[16:12:33.554]                     else if (inherits(cond, "condition")) {
[16:12:33.554]                       if (!is.null(pattern)) {
[16:12:33.554]                         computeRestarts <- base::computeRestarts
[16:12:33.554]                         grepl <- base::grepl
[16:12:33.554]                         restarts <- computeRestarts(cond)
[16:12:33.554]                         for (restart in restarts) {
[16:12:33.554]                           name <- restart$name
[16:12:33.554]                           if (is.null(name)) 
[16:12:33.554]                             next
[16:12:33.554]                           if (!grepl(pattern, name)) 
[16:12:33.554]                             next
[16:12:33.554]                           invokeRestart(restart)
[16:12:33.554]                           muffled <- TRUE
[16:12:33.554]                           break
[16:12:33.554]                         }
[16:12:33.554]                       }
[16:12:33.554]                     }
[16:12:33.554]                     invisible(muffled)
[16:12:33.554]                   }
[16:12:33.554]                   muffleCondition(cond)
[16:12:33.554]                 })
[16:12:33.554]             }))
[16:12:33.554]             future::FutureResult(value = ...future.value$value, 
[16:12:33.554]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:33.554]                   ...future.rng), globalenv = if (FALSE) 
[16:12:33.554]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:33.554]                     ...future.globalenv.names))
[16:12:33.554]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:33.554]         }, condition = base::local({
[16:12:33.554]             c <- base::c
[16:12:33.554]             inherits <- base::inherits
[16:12:33.554]             invokeRestart <- base::invokeRestart
[16:12:33.554]             length <- base::length
[16:12:33.554]             list <- base::list
[16:12:33.554]             seq.int <- base::seq.int
[16:12:33.554]             signalCondition <- base::signalCondition
[16:12:33.554]             sys.calls <- base::sys.calls
[16:12:33.554]             `[[` <- base::`[[`
[16:12:33.554]             `+` <- base::`+`
[16:12:33.554]             `<<-` <- base::`<<-`
[16:12:33.554]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:33.554]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:33.554]                   3L)]
[16:12:33.554]             }
[16:12:33.554]             function(cond) {
[16:12:33.554]                 is_error <- inherits(cond, "error")
[16:12:33.554]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:33.554]                   NULL)
[16:12:33.554]                 if (is_error) {
[16:12:33.554]                   sessionInformation <- function() {
[16:12:33.554]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:33.554]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:33.554]                       search = base::search(), system = base::Sys.info())
[16:12:33.554]                   }
[16:12:33.554]                   ...future.conditions[[length(...future.conditions) + 
[16:12:33.554]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:33.554]                     cond$call), session = sessionInformation(), 
[16:12:33.554]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:33.554]                   signalCondition(cond)
[16:12:33.554]                 }
[16:12:33.554]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:33.554]                 "immediateCondition"))) {
[16:12:33.554]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:33.554]                   ...future.conditions[[length(...future.conditions) + 
[16:12:33.554]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:33.554]                   if (TRUE && !signal) {
[16:12:33.554]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.554]                     {
[16:12:33.554]                       inherits <- base::inherits
[16:12:33.554]                       invokeRestart <- base::invokeRestart
[16:12:33.554]                       is.null <- base::is.null
[16:12:33.554]                       muffled <- FALSE
[16:12:33.554]                       if (inherits(cond, "message")) {
[16:12:33.554]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:33.554]                         if (muffled) 
[16:12:33.554]                           invokeRestart("muffleMessage")
[16:12:33.554]                       }
[16:12:33.554]                       else if (inherits(cond, "warning")) {
[16:12:33.554]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:33.554]                         if (muffled) 
[16:12:33.554]                           invokeRestart("muffleWarning")
[16:12:33.554]                       }
[16:12:33.554]                       else if (inherits(cond, "condition")) {
[16:12:33.554]                         if (!is.null(pattern)) {
[16:12:33.554]                           computeRestarts <- base::computeRestarts
[16:12:33.554]                           grepl <- base::grepl
[16:12:33.554]                           restarts <- computeRestarts(cond)
[16:12:33.554]                           for (restart in restarts) {
[16:12:33.554]                             name <- restart$name
[16:12:33.554]                             if (is.null(name)) 
[16:12:33.554]                               next
[16:12:33.554]                             if (!grepl(pattern, name)) 
[16:12:33.554]                               next
[16:12:33.554]                             invokeRestart(restart)
[16:12:33.554]                             muffled <- TRUE
[16:12:33.554]                             break
[16:12:33.554]                           }
[16:12:33.554]                         }
[16:12:33.554]                       }
[16:12:33.554]                       invisible(muffled)
[16:12:33.554]                     }
[16:12:33.554]                     muffleCondition(cond, pattern = "^muffle")
[16:12:33.554]                   }
[16:12:33.554]                 }
[16:12:33.554]                 else {
[16:12:33.554]                   if (TRUE) {
[16:12:33.554]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.554]                     {
[16:12:33.554]                       inherits <- base::inherits
[16:12:33.554]                       invokeRestart <- base::invokeRestart
[16:12:33.554]                       is.null <- base::is.null
[16:12:33.554]                       muffled <- FALSE
[16:12:33.554]                       if (inherits(cond, "message")) {
[16:12:33.554]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:33.554]                         if (muffled) 
[16:12:33.554]                           invokeRestart("muffleMessage")
[16:12:33.554]                       }
[16:12:33.554]                       else if (inherits(cond, "warning")) {
[16:12:33.554]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:33.554]                         if (muffled) 
[16:12:33.554]                           invokeRestart("muffleWarning")
[16:12:33.554]                       }
[16:12:33.554]                       else if (inherits(cond, "condition")) {
[16:12:33.554]                         if (!is.null(pattern)) {
[16:12:33.554]                           computeRestarts <- base::computeRestarts
[16:12:33.554]                           grepl <- base::grepl
[16:12:33.554]                           restarts <- computeRestarts(cond)
[16:12:33.554]                           for (restart in restarts) {
[16:12:33.554]                             name <- restart$name
[16:12:33.554]                             if (is.null(name)) 
[16:12:33.554]                               next
[16:12:33.554]                             if (!grepl(pattern, name)) 
[16:12:33.554]                               next
[16:12:33.554]                             invokeRestart(restart)
[16:12:33.554]                             muffled <- TRUE
[16:12:33.554]                             break
[16:12:33.554]                           }
[16:12:33.554]                         }
[16:12:33.554]                       }
[16:12:33.554]                       invisible(muffled)
[16:12:33.554]                     }
[16:12:33.554]                     muffleCondition(cond, pattern = "^muffle")
[16:12:33.554]                   }
[16:12:33.554]                 }
[16:12:33.554]             }
[16:12:33.554]         }))
[16:12:33.554]     }, error = function(ex) {
[16:12:33.554]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:33.554]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:33.554]                 ...future.rng), started = ...future.startTime, 
[16:12:33.554]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:33.554]             version = "1.8"), class = "FutureResult")
[16:12:33.554]     }, finally = {
[16:12:33.554]         if (!identical(...future.workdir, getwd())) 
[16:12:33.554]             setwd(...future.workdir)
[16:12:33.554]         {
[16:12:33.554]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:33.554]                 ...future.oldOptions$nwarnings <- NULL
[16:12:33.554]             }
[16:12:33.554]             base::options(...future.oldOptions)
[16:12:33.554]             if (.Platform$OS.type == "windows") {
[16:12:33.554]                 old_names <- names(...future.oldEnvVars)
[16:12:33.554]                 envs <- base::Sys.getenv()
[16:12:33.554]                 names <- names(envs)
[16:12:33.554]                 common <- intersect(names, old_names)
[16:12:33.554]                 added <- setdiff(names, old_names)
[16:12:33.554]                 removed <- setdiff(old_names, names)
[16:12:33.554]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:33.554]                   envs[common]]
[16:12:33.554]                 NAMES <- toupper(changed)
[16:12:33.554]                 args <- list()
[16:12:33.554]                 for (kk in seq_along(NAMES)) {
[16:12:33.554]                   name <- changed[[kk]]
[16:12:33.554]                   NAME <- NAMES[[kk]]
[16:12:33.554]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.554]                     next
[16:12:33.554]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:33.554]                 }
[16:12:33.554]                 NAMES <- toupper(added)
[16:12:33.554]                 for (kk in seq_along(NAMES)) {
[16:12:33.554]                   name <- added[[kk]]
[16:12:33.554]                   NAME <- NAMES[[kk]]
[16:12:33.554]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.554]                     next
[16:12:33.554]                   args[[name]] <- ""
[16:12:33.554]                 }
[16:12:33.554]                 NAMES <- toupper(removed)
[16:12:33.554]                 for (kk in seq_along(NAMES)) {
[16:12:33.554]                   name <- removed[[kk]]
[16:12:33.554]                   NAME <- NAMES[[kk]]
[16:12:33.554]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.554]                     next
[16:12:33.554]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:33.554]                 }
[16:12:33.554]                 if (length(args) > 0) 
[16:12:33.554]                   base::do.call(base::Sys.setenv, args = args)
[16:12:33.554]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:33.554]             }
[16:12:33.554]             else {
[16:12:33.554]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:33.554]             }
[16:12:33.554]             {
[16:12:33.554]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:33.554]                   0L) {
[16:12:33.554]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:33.554]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:33.554]                   base::options(opts)
[16:12:33.554]                 }
[16:12:33.554]                 {
[16:12:33.554]                   {
[16:12:33.554]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:33.554]                     NULL
[16:12:33.554]                   }
[16:12:33.554]                   options(future.plan = NULL)
[16:12:33.554]                   if (is.na(NA_character_)) 
[16:12:33.554]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:33.554]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:33.554]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:33.554]                     envir = parent.frame()) 
[16:12:33.554]                   {
[16:12:33.554]                     default_workers <- missing(workers)
[16:12:33.554]                     if (is.function(workers)) 
[16:12:33.554]                       workers <- workers()
[16:12:33.554]                     workers <- structure(as.integer(workers), 
[16:12:33.554]                       class = class(workers))
[16:12:33.554]                     stop_if_not(is.finite(workers), workers >= 
[16:12:33.554]                       1L)
[16:12:33.554]                     if ((workers == 1L && !inherits(workers, 
[16:12:33.554]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:33.554]                       if (default_workers) 
[16:12:33.554]                         supportsMulticore(warn = TRUE)
[16:12:33.554]                       return(sequential(..., envir = envir))
[16:12:33.554]                     }
[16:12:33.554]                     oopts <- options(mc.cores = workers)
[16:12:33.554]                     on.exit(options(oopts))
[16:12:33.554]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:33.554]                       envir = envir)
[16:12:33.554]                     if (!future$lazy) 
[16:12:33.554]                       future <- run(future)
[16:12:33.554]                     invisible(future)
[16:12:33.554]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:33.554]                 }
[16:12:33.554]             }
[16:12:33.554]         }
[16:12:33.554]     })
[16:12:33.554]     if (TRUE) {
[16:12:33.554]         base::sink(type = "output", split = FALSE)
[16:12:33.554]         if (TRUE) {
[16:12:33.554]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:33.554]         }
[16:12:33.554]         else {
[16:12:33.554]             ...future.result["stdout"] <- base::list(NULL)
[16:12:33.554]         }
[16:12:33.554]         base::close(...future.stdout)
[16:12:33.554]         ...future.stdout <- NULL
[16:12:33.554]     }
[16:12:33.554]     ...future.result$conditions <- ...future.conditions
[16:12:33.554]     ...future.result$finished <- base::Sys.time()
[16:12:33.554]     ...future.result
[16:12:33.554] }
[16:12:33.557] requestCore(): workers = 2
[16:12:33.559] MulticoreFuture started
[16:12:33.559] - Launch lazy future ... done
[16:12:33.560] run() for ‘MulticoreFuture’ ... done
[16:12:33.561] plan(): Setting new future strategy stack:
[16:12:33.561] List of future strategies:
[16:12:33.561] 1. sequential:
[16:12:33.561]    - args: function (..., envir = parent.frame())
[16:12:33.561]    - tweaked: FALSE
[16:12:33.561]    - call: NULL
[16:12:33.562] plan(): nbrOfWorkers() = 1
[16:12:33.571] plan(): Setting new future strategy stack:
[16:12:33.571] List of future strategies:
[16:12:33.571] 1. multicore:
[16:12:33.571]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:33.571]    - tweaked: FALSE
[16:12:33.571]    - call: plan(strategy)
[16:12:33.578] plan(): nbrOfWorkers() = 2

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[16:12:33.588] getGlobalsAndPackages() ...
[16:12:33.588] Searching for globals...
[16:12:33.594] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[16:12:33.594] Searching for globals ... DONE
[16:12:33.594] Resolving globals: FALSE
[16:12:33.595] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[16:12:33.596] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[16:12:33.596] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[16:12:33.596] 
[16:12:33.596] getGlobalsAndPackages() ... DONE
[16:12:33.597] run() for ‘Future’ ...
[16:12:33.597] - state: ‘created’
[16:12:33.597] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:33.601] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:33.601] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:33.601]   - Field: ‘label’
[16:12:33.601]   - Field: ‘local’
[16:12:33.601]   - Field: ‘owner’
[16:12:33.601]   - Field: ‘envir’
[16:12:33.601]   - Field: ‘workers’
[16:12:33.602]   - Field: ‘packages’
[16:12:33.602]   - Field: ‘gc’
[16:12:33.602]   - Field: ‘job’
[16:12:33.602]   - Field: ‘conditions’
[16:12:33.602]   - Field: ‘expr’
[16:12:33.602]   - Field: ‘uuid’
[16:12:33.602]   - Field: ‘seed’
[16:12:33.602]   - Field: ‘version’
[16:12:33.602]   - Field: ‘result’
[16:12:33.603]   - Field: ‘asynchronous’
[16:12:33.603]   - Field: ‘calls’
[16:12:33.603]   - Field: ‘globals’
[16:12:33.603]   - Field: ‘stdout’
[16:12:33.603]   - Field: ‘earlySignal’
[16:12:33.603]   - Field: ‘lazy’
[16:12:33.603]   - Field: ‘state’
[16:12:33.603] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:33.603] - Launch lazy future ...
[16:12:33.604] Packages needed by the future expression (n = 0): <none>
[16:12:33.604] Packages needed by future strategies (n = 0): <none>
[16:12:33.604] {
[16:12:33.604]     {
[16:12:33.604]         {
[16:12:33.604]             ...future.startTime <- base::Sys.time()
[16:12:33.604]             {
[16:12:33.604]                 {
[16:12:33.604]                   {
[16:12:33.604]                     {
[16:12:33.604]                       base::local({
[16:12:33.604]                         has_future <- base::requireNamespace("future", 
[16:12:33.604]                           quietly = TRUE)
[16:12:33.604]                         if (has_future) {
[16:12:33.604]                           ns <- base::getNamespace("future")
[16:12:33.604]                           version <- ns[[".package"]][["version"]]
[16:12:33.604]                           if (is.null(version)) 
[16:12:33.604]                             version <- utils::packageVersion("future")
[16:12:33.604]                         }
[16:12:33.604]                         else {
[16:12:33.604]                           version <- NULL
[16:12:33.604]                         }
[16:12:33.604]                         if (!has_future || version < "1.8.0") {
[16:12:33.604]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:33.604]                             "", base::R.version$version.string), 
[16:12:33.604]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:33.604]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:33.604]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:33.604]                               "release", "version")], collapse = " "), 
[16:12:33.604]                             hostname = base::Sys.info()[["nodename"]])
[16:12:33.604]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:33.604]                             info)
[16:12:33.604]                           info <- base::paste(info, collapse = "; ")
[16:12:33.604]                           if (!has_future) {
[16:12:33.604]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:33.604]                               info)
[16:12:33.604]                           }
[16:12:33.604]                           else {
[16:12:33.604]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:33.604]                               info, version)
[16:12:33.604]                           }
[16:12:33.604]                           base::stop(msg)
[16:12:33.604]                         }
[16:12:33.604]                       })
[16:12:33.604]                     }
[16:12:33.604]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:33.604]                     base::options(mc.cores = 1L)
[16:12:33.604]                   }
[16:12:33.604]                   options(future.plan = NULL)
[16:12:33.604]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:33.604]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:33.604]                 }
[16:12:33.604]                 ...future.workdir <- getwd()
[16:12:33.604]             }
[16:12:33.604]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:33.604]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:33.604]         }
[16:12:33.604]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:33.604]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:33.604]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:33.604]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:33.604]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:33.604]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:33.604]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:33.604]             base::names(...future.oldOptions))
[16:12:33.604]     }
[16:12:33.604]     if (FALSE) {
[16:12:33.604]     }
[16:12:33.604]     else {
[16:12:33.604]         if (TRUE) {
[16:12:33.604]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:33.604]                 open = "w")
[16:12:33.604]         }
[16:12:33.604]         else {
[16:12:33.604]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:33.604]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:33.604]         }
[16:12:33.604]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:33.604]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:33.604]             base::sink(type = "output", split = FALSE)
[16:12:33.604]             base::close(...future.stdout)
[16:12:33.604]         }, add = TRUE)
[16:12:33.604]     }
[16:12:33.604]     ...future.frame <- base::sys.nframe()
[16:12:33.604]     ...future.conditions <- base::list()
[16:12:33.604]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:33.604]     if (FALSE) {
[16:12:33.604]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:33.604]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:33.604]     }
[16:12:33.604]     ...future.result <- base::tryCatch({
[16:12:33.604]         base::withCallingHandlers({
[16:12:33.604]             ...future.value <- base::withVisible(base::local({
[16:12:33.604]                 withCallingHandlers({
[16:12:33.604]                   {
[16:12:33.604]                     outer_function(1L)
[16:12:33.604]                   }
[16:12:33.604]                 }, immediateCondition = function(cond) {
[16:12:33.604]                   save_rds <- function (object, pathname, ...) 
[16:12:33.604]                   {
[16:12:33.604]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:33.604]                     if (file_test("-f", pathname_tmp)) {
[16:12:33.604]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.604]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:33.604]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.604]                         fi_tmp[["mtime"]])
[16:12:33.604]                     }
[16:12:33.604]                     tryCatch({
[16:12:33.604]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:33.604]                     }, error = function(ex) {
[16:12:33.604]                       msg <- conditionMessage(ex)
[16:12:33.604]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.604]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:33.604]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.604]                         fi_tmp[["mtime"]], msg)
[16:12:33.604]                       ex$message <- msg
[16:12:33.604]                       stop(ex)
[16:12:33.604]                     })
[16:12:33.604]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:33.604]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:33.604]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:33.604]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.604]                       fi <- file.info(pathname)
[16:12:33.604]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:33.604]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.604]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:33.604]                         fi[["size"]], fi[["mtime"]])
[16:12:33.604]                       stop(msg)
[16:12:33.604]                     }
[16:12:33.604]                     invisible(pathname)
[16:12:33.604]                   }
[16:12:33.604]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:33.604]                     rootPath = tempdir()) 
[16:12:33.604]                   {
[16:12:33.604]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:33.604]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:33.604]                       tmpdir = path, fileext = ".rds")
[16:12:33.604]                     save_rds(obj, file)
[16:12:33.604]                   }
[16:12:33.604]                   saveImmediateCondition(cond, path = "/tmp/RtmpjVCO6F/.future/immediateConditions")
[16:12:33.604]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.604]                   {
[16:12:33.604]                     inherits <- base::inherits
[16:12:33.604]                     invokeRestart <- base::invokeRestart
[16:12:33.604]                     is.null <- base::is.null
[16:12:33.604]                     muffled <- FALSE
[16:12:33.604]                     if (inherits(cond, "message")) {
[16:12:33.604]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:33.604]                       if (muffled) 
[16:12:33.604]                         invokeRestart("muffleMessage")
[16:12:33.604]                     }
[16:12:33.604]                     else if (inherits(cond, "warning")) {
[16:12:33.604]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:33.604]                       if (muffled) 
[16:12:33.604]                         invokeRestart("muffleWarning")
[16:12:33.604]                     }
[16:12:33.604]                     else if (inherits(cond, "condition")) {
[16:12:33.604]                       if (!is.null(pattern)) {
[16:12:33.604]                         computeRestarts <- base::computeRestarts
[16:12:33.604]                         grepl <- base::grepl
[16:12:33.604]                         restarts <- computeRestarts(cond)
[16:12:33.604]                         for (restart in restarts) {
[16:12:33.604]                           name <- restart$name
[16:12:33.604]                           if (is.null(name)) 
[16:12:33.604]                             next
[16:12:33.604]                           if (!grepl(pattern, name)) 
[16:12:33.604]                             next
[16:12:33.604]                           invokeRestart(restart)
[16:12:33.604]                           muffled <- TRUE
[16:12:33.604]                           break
[16:12:33.604]                         }
[16:12:33.604]                       }
[16:12:33.604]                     }
[16:12:33.604]                     invisible(muffled)
[16:12:33.604]                   }
[16:12:33.604]                   muffleCondition(cond)
[16:12:33.604]                 })
[16:12:33.604]             }))
[16:12:33.604]             future::FutureResult(value = ...future.value$value, 
[16:12:33.604]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:33.604]                   ...future.rng), globalenv = if (FALSE) 
[16:12:33.604]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:33.604]                     ...future.globalenv.names))
[16:12:33.604]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:33.604]         }, condition = base::local({
[16:12:33.604]             c <- base::c
[16:12:33.604]             inherits <- base::inherits
[16:12:33.604]             invokeRestart <- base::invokeRestart
[16:12:33.604]             length <- base::length
[16:12:33.604]             list <- base::list
[16:12:33.604]             seq.int <- base::seq.int
[16:12:33.604]             signalCondition <- base::signalCondition
[16:12:33.604]             sys.calls <- base::sys.calls
[16:12:33.604]             `[[` <- base::`[[`
[16:12:33.604]             `+` <- base::`+`
[16:12:33.604]             `<<-` <- base::`<<-`
[16:12:33.604]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:33.604]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:33.604]                   3L)]
[16:12:33.604]             }
[16:12:33.604]             function(cond) {
[16:12:33.604]                 is_error <- inherits(cond, "error")
[16:12:33.604]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:33.604]                   NULL)
[16:12:33.604]                 if (is_error) {
[16:12:33.604]                   sessionInformation <- function() {
[16:12:33.604]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:33.604]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:33.604]                       search = base::search(), system = base::Sys.info())
[16:12:33.604]                   }
[16:12:33.604]                   ...future.conditions[[length(...future.conditions) + 
[16:12:33.604]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:33.604]                     cond$call), session = sessionInformation(), 
[16:12:33.604]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:33.604]                   signalCondition(cond)
[16:12:33.604]                 }
[16:12:33.604]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:33.604]                 "immediateCondition"))) {
[16:12:33.604]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:33.604]                   ...future.conditions[[length(...future.conditions) + 
[16:12:33.604]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:33.604]                   if (TRUE && !signal) {
[16:12:33.604]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.604]                     {
[16:12:33.604]                       inherits <- base::inherits
[16:12:33.604]                       invokeRestart <- base::invokeRestart
[16:12:33.604]                       is.null <- base::is.null
[16:12:33.604]                       muffled <- FALSE
[16:12:33.604]                       if (inherits(cond, "message")) {
[16:12:33.604]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:33.604]                         if (muffled) 
[16:12:33.604]                           invokeRestart("muffleMessage")
[16:12:33.604]                       }
[16:12:33.604]                       else if (inherits(cond, "warning")) {
[16:12:33.604]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:33.604]                         if (muffled) 
[16:12:33.604]                           invokeRestart("muffleWarning")
[16:12:33.604]                       }
[16:12:33.604]                       else if (inherits(cond, "condition")) {
[16:12:33.604]                         if (!is.null(pattern)) {
[16:12:33.604]                           computeRestarts <- base::computeRestarts
[16:12:33.604]                           grepl <- base::grepl
[16:12:33.604]                           restarts <- computeRestarts(cond)
[16:12:33.604]                           for (restart in restarts) {
[16:12:33.604]                             name <- restart$name
[16:12:33.604]                             if (is.null(name)) 
[16:12:33.604]                               next
[16:12:33.604]                             if (!grepl(pattern, name)) 
[16:12:33.604]                               next
[16:12:33.604]                             invokeRestart(restart)
[16:12:33.604]                             muffled <- TRUE
[16:12:33.604]                             break
[16:12:33.604]                           }
[16:12:33.604]                         }
[16:12:33.604]                       }
[16:12:33.604]                       invisible(muffled)
[16:12:33.604]                     }
[16:12:33.604]                     muffleCondition(cond, pattern = "^muffle")
[16:12:33.604]                   }
[16:12:33.604]                 }
[16:12:33.604]                 else {
[16:12:33.604]                   if (TRUE) {
[16:12:33.604]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.604]                     {
[16:12:33.604]                       inherits <- base::inherits
[16:12:33.604]                       invokeRestart <- base::invokeRestart
[16:12:33.604]                       is.null <- base::is.null
[16:12:33.604]                       muffled <- FALSE
[16:12:33.604]                       if (inherits(cond, "message")) {
[16:12:33.604]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:33.604]                         if (muffled) 
[16:12:33.604]                           invokeRestart("muffleMessage")
[16:12:33.604]                       }
[16:12:33.604]                       else if (inherits(cond, "warning")) {
[16:12:33.604]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:33.604]                         if (muffled) 
[16:12:33.604]                           invokeRestart("muffleWarning")
[16:12:33.604]                       }
[16:12:33.604]                       else if (inherits(cond, "condition")) {
[16:12:33.604]                         if (!is.null(pattern)) {
[16:12:33.604]                           computeRestarts <- base::computeRestarts
[16:12:33.604]                           grepl <- base::grepl
[16:12:33.604]                           restarts <- computeRestarts(cond)
[16:12:33.604]                           for (restart in restarts) {
[16:12:33.604]                             name <- restart$name
[16:12:33.604]                             if (is.null(name)) 
[16:12:33.604]                               next
[16:12:33.604]                             if (!grepl(pattern, name)) 
[16:12:33.604]                               next
[16:12:33.604]                             invokeRestart(restart)
[16:12:33.604]                             muffled <- TRUE
[16:12:33.604]                             break
[16:12:33.604]                           }
[16:12:33.604]                         }
[16:12:33.604]                       }
[16:12:33.604]                       invisible(muffled)
[16:12:33.604]                     }
[16:12:33.604]                     muffleCondition(cond, pattern = "^muffle")
[16:12:33.604]                   }
[16:12:33.604]                 }
[16:12:33.604]             }
[16:12:33.604]         }))
[16:12:33.604]     }, error = function(ex) {
[16:12:33.604]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:33.604]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:33.604]                 ...future.rng), started = ...future.startTime, 
[16:12:33.604]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:33.604]             version = "1.8"), class = "FutureResult")
[16:12:33.604]     }, finally = {
[16:12:33.604]         if (!identical(...future.workdir, getwd())) 
[16:12:33.604]             setwd(...future.workdir)
[16:12:33.604]         {
[16:12:33.604]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:33.604]                 ...future.oldOptions$nwarnings <- NULL
[16:12:33.604]             }
[16:12:33.604]             base::options(...future.oldOptions)
[16:12:33.604]             if (.Platform$OS.type == "windows") {
[16:12:33.604]                 old_names <- names(...future.oldEnvVars)
[16:12:33.604]                 envs <- base::Sys.getenv()
[16:12:33.604]                 names <- names(envs)
[16:12:33.604]                 common <- intersect(names, old_names)
[16:12:33.604]                 added <- setdiff(names, old_names)
[16:12:33.604]                 removed <- setdiff(old_names, names)
[16:12:33.604]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:33.604]                   envs[common]]
[16:12:33.604]                 NAMES <- toupper(changed)
[16:12:33.604]                 args <- list()
[16:12:33.604]                 for (kk in seq_along(NAMES)) {
[16:12:33.604]                   name <- changed[[kk]]
[16:12:33.604]                   NAME <- NAMES[[kk]]
[16:12:33.604]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.604]                     next
[16:12:33.604]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:33.604]                 }
[16:12:33.604]                 NAMES <- toupper(added)
[16:12:33.604]                 for (kk in seq_along(NAMES)) {
[16:12:33.604]                   name <- added[[kk]]
[16:12:33.604]                   NAME <- NAMES[[kk]]
[16:12:33.604]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.604]                     next
[16:12:33.604]                   args[[name]] <- ""
[16:12:33.604]                 }
[16:12:33.604]                 NAMES <- toupper(removed)
[16:12:33.604]                 for (kk in seq_along(NAMES)) {
[16:12:33.604]                   name <- removed[[kk]]
[16:12:33.604]                   NAME <- NAMES[[kk]]
[16:12:33.604]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.604]                     next
[16:12:33.604]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:33.604]                 }
[16:12:33.604]                 if (length(args) > 0) 
[16:12:33.604]                   base::do.call(base::Sys.setenv, args = args)
[16:12:33.604]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:33.604]             }
[16:12:33.604]             else {
[16:12:33.604]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:33.604]             }
[16:12:33.604]             {
[16:12:33.604]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:33.604]                   0L) {
[16:12:33.604]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:33.604]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:33.604]                   base::options(opts)
[16:12:33.604]                 }
[16:12:33.604]                 {
[16:12:33.604]                   {
[16:12:33.604]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:33.604]                     NULL
[16:12:33.604]                   }
[16:12:33.604]                   options(future.plan = NULL)
[16:12:33.604]                   if (is.na(NA_character_)) 
[16:12:33.604]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:33.604]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:33.604]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:33.604]                     envir = parent.frame()) 
[16:12:33.604]                   {
[16:12:33.604]                     default_workers <- missing(workers)
[16:12:33.604]                     if (is.function(workers)) 
[16:12:33.604]                       workers <- workers()
[16:12:33.604]                     workers <- structure(as.integer(workers), 
[16:12:33.604]                       class = class(workers))
[16:12:33.604]                     stop_if_not(is.finite(workers), workers >= 
[16:12:33.604]                       1L)
[16:12:33.604]                     if ((workers == 1L && !inherits(workers, 
[16:12:33.604]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:33.604]                       if (default_workers) 
[16:12:33.604]                         supportsMulticore(warn = TRUE)
[16:12:33.604]                       return(sequential(..., envir = envir))
[16:12:33.604]                     }
[16:12:33.604]                     oopts <- options(mc.cores = workers)
[16:12:33.604]                     on.exit(options(oopts))
[16:12:33.604]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:33.604]                       envir = envir)
[16:12:33.604]                     if (!future$lazy) 
[16:12:33.604]                       future <- run(future)
[16:12:33.604]                     invisible(future)
[16:12:33.604]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:33.604]                 }
[16:12:33.604]             }
[16:12:33.604]         }
[16:12:33.604]     })
[16:12:33.604]     if (TRUE) {
[16:12:33.604]         base::sink(type = "output", split = FALSE)
[16:12:33.604]         if (TRUE) {
[16:12:33.604]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:33.604]         }
[16:12:33.604]         else {
[16:12:33.604]             ...future.result["stdout"] <- base::list(NULL)
[16:12:33.604]         }
[16:12:33.604]         base::close(...future.stdout)
[16:12:33.604]         ...future.stdout <- NULL
[16:12:33.604]     }
[16:12:33.604]     ...future.result$conditions <- ...future.conditions
[16:12:33.604]     ...future.result$finished <- base::Sys.time()
[16:12:33.604]     ...future.result
[16:12:33.604] }
[16:12:33.607] assign_globals() ...
[16:12:33.607] List of 3
[16:12:33.607]  $ outer_function:function (x)  
[16:12:33.607]  $ map           :function (.x, .f, ...)  
[16:12:33.607]  $ inner_function:function (x)  
[16:12:33.607]  - attr(*, "where")=List of 3
[16:12:33.607]   ..$ outer_function:<environment: R_EmptyEnv> 
[16:12:33.607]   ..$ map           :<environment: R_EmptyEnv> 
[16:12:33.607]   ..$ inner_function:<environment: R_EmptyEnv> 
[16:12:33.607]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:33.607]  - attr(*, "resolved")= logi FALSE
[16:12:33.607]  - attr(*, "total_size")= num 7704
[16:12:33.607]  - attr(*, "already-done")= logi TRUE
[16:12:33.611] - reassign environment for ‘outer_function’
[16:12:33.611] - copied ‘outer_function’ to environment
[16:12:33.611] - reassign environment for ‘map’
[16:12:33.611] - copied ‘map’ to environment
[16:12:33.611] - reassign environment for ‘inner_function’
[16:12:33.611] - copied ‘inner_function’ to environment
[16:12:33.611] assign_globals() ... done
[16:12:33.611] requestCore(): workers = 2
[16:12:33.613] MulticoreFuture started
[16:12:33.614] - Launch lazy future ... done
[16:12:33.614] run() for ‘MulticoreFuture’ ... done
[16:12:33.614] plan(): Setting new future strategy stack:
[16:12:33.614] List of future strategies:
[16:12:33.614] 1. sequential:
[16:12:33.614]    - args: function (..., envir = parent.frame())
[16:12:33.614]    - tweaked: FALSE
[16:12:33.614]    - call: NULL
[16:12:33.615] plan(): nbrOfWorkers() = 1
[16:12:33.618] plan(): Setting new future strategy stack:
[16:12:33.618] List of future strategies:
[16:12:33.618] 1. multicore:
[16:12:33.618]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:33.618]    - tweaked: FALSE
[16:12:33.618]    - call: plan(strategy)
[16:12:33.623] plan(): nbrOfWorkers() = 2
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[16:12:33.629] getGlobalsAndPackages() ...
[16:12:33.629] Searching for globals...
[16:12:33.638] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[16:12:33.638] Searching for globals ... DONE
[16:12:33.638] Resolving globals: FALSE
[16:12:33.639] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[16:12:33.639] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[16:12:33.639] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[16:12:33.640] 
[16:12:33.640] getGlobalsAndPackages() ... DONE
[16:12:33.640] run() for ‘Future’ ...
[16:12:33.640] - state: ‘created’
[16:12:33.640] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:33.644] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:33.645] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:33.645]   - Field: ‘label’
[16:12:33.645]   - Field: ‘local’
[16:12:33.645]   - Field: ‘owner’
[16:12:33.645]   - Field: ‘envir’
[16:12:33.645]   - Field: ‘workers’
[16:12:33.645]   - Field: ‘packages’
[16:12:33.645]   - Field: ‘gc’
[16:12:33.646]   - Field: ‘job’
[16:12:33.646]   - Field: ‘conditions’
[16:12:33.646]   - Field: ‘expr’
[16:12:33.646]   - Field: ‘uuid’
[16:12:33.646]   - Field: ‘seed’
[16:12:33.646]   - Field: ‘version’
[16:12:33.646]   - Field: ‘result’
[16:12:33.646]   - Field: ‘asynchronous’
[16:12:33.646]   - Field: ‘calls’
[16:12:33.647]   - Field: ‘globals’
[16:12:33.647]   - Field: ‘stdout’
[16:12:33.647]   - Field: ‘earlySignal’
[16:12:33.647]   - Field: ‘lazy’
[16:12:33.647]   - Field: ‘state’
[16:12:33.647] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:33.647] - Launch lazy future ...
[16:12:33.647] Packages needed by the future expression (n = 0): <none>
[16:12:33.648] Packages needed by future strategies (n = 0): <none>
[16:12:33.648] {
[16:12:33.648]     {
[16:12:33.648]         {
[16:12:33.648]             ...future.startTime <- base::Sys.time()
[16:12:33.648]             {
[16:12:33.648]                 {
[16:12:33.648]                   {
[16:12:33.648]                     {
[16:12:33.648]                       base::local({
[16:12:33.648]                         has_future <- base::requireNamespace("future", 
[16:12:33.648]                           quietly = TRUE)
[16:12:33.648]                         if (has_future) {
[16:12:33.648]                           ns <- base::getNamespace("future")
[16:12:33.648]                           version <- ns[[".package"]][["version"]]
[16:12:33.648]                           if (is.null(version)) 
[16:12:33.648]                             version <- utils::packageVersion("future")
[16:12:33.648]                         }
[16:12:33.648]                         else {
[16:12:33.648]                           version <- NULL
[16:12:33.648]                         }
[16:12:33.648]                         if (!has_future || version < "1.8.0") {
[16:12:33.648]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:33.648]                             "", base::R.version$version.string), 
[16:12:33.648]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:33.648]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:33.648]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:33.648]                               "release", "version")], collapse = " "), 
[16:12:33.648]                             hostname = base::Sys.info()[["nodename"]])
[16:12:33.648]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:33.648]                             info)
[16:12:33.648]                           info <- base::paste(info, collapse = "; ")
[16:12:33.648]                           if (!has_future) {
[16:12:33.648]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:33.648]                               info)
[16:12:33.648]                           }
[16:12:33.648]                           else {
[16:12:33.648]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:33.648]                               info, version)
[16:12:33.648]                           }
[16:12:33.648]                           base::stop(msg)
[16:12:33.648]                         }
[16:12:33.648]                       })
[16:12:33.648]                     }
[16:12:33.648]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:33.648]                     base::options(mc.cores = 1L)
[16:12:33.648]                   }
[16:12:33.648]                   options(future.plan = NULL)
[16:12:33.648]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:33.648]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:33.648]                 }
[16:12:33.648]                 ...future.workdir <- getwd()
[16:12:33.648]             }
[16:12:33.648]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:33.648]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:33.648]         }
[16:12:33.648]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:33.648]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:33.648]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:33.648]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:33.648]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:33.648]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:33.648]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:33.648]             base::names(...future.oldOptions))
[16:12:33.648]     }
[16:12:33.648]     if (FALSE) {
[16:12:33.648]     }
[16:12:33.648]     else {
[16:12:33.648]         if (TRUE) {
[16:12:33.648]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:33.648]                 open = "w")
[16:12:33.648]         }
[16:12:33.648]         else {
[16:12:33.648]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:33.648]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:33.648]         }
[16:12:33.648]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:33.648]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:33.648]             base::sink(type = "output", split = FALSE)
[16:12:33.648]             base::close(...future.stdout)
[16:12:33.648]         }, add = TRUE)
[16:12:33.648]     }
[16:12:33.648]     ...future.frame <- base::sys.nframe()
[16:12:33.648]     ...future.conditions <- base::list()
[16:12:33.648]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:33.648]     if (FALSE) {
[16:12:33.648]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:33.648]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:33.648]     }
[16:12:33.648]     ...future.result <- base::tryCatch({
[16:12:33.648]         base::withCallingHandlers({
[16:12:33.648]             ...future.value <- base::withVisible(base::local({
[16:12:33.648]                 withCallingHandlers({
[16:12:33.648]                   {
[16:12:33.648]                     outer_function(1L)
[16:12:33.648]                   }
[16:12:33.648]                 }, immediateCondition = function(cond) {
[16:12:33.648]                   save_rds <- function (object, pathname, ...) 
[16:12:33.648]                   {
[16:12:33.648]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:33.648]                     if (file_test("-f", pathname_tmp)) {
[16:12:33.648]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.648]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:33.648]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.648]                         fi_tmp[["mtime"]])
[16:12:33.648]                     }
[16:12:33.648]                     tryCatch({
[16:12:33.648]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:33.648]                     }, error = function(ex) {
[16:12:33.648]                       msg <- conditionMessage(ex)
[16:12:33.648]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.648]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:33.648]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.648]                         fi_tmp[["mtime"]], msg)
[16:12:33.648]                       ex$message <- msg
[16:12:33.648]                       stop(ex)
[16:12:33.648]                     })
[16:12:33.648]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:33.648]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:33.648]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:33.648]                       fi_tmp <- file.info(pathname_tmp)
[16:12:33.648]                       fi <- file.info(pathname)
[16:12:33.648]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:33.648]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:33.648]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:33.648]                         fi[["size"]], fi[["mtime"]])
[16:12:33.648]                       stop(msg)
[16:12:33.648]                     }
[16:12:33.648]                     invisible(pathname)
[16:12:33.648]                   }
[16:12:33.648]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:33.648]                     rootPath = tempdir()) 
[16:12:33.648]                   {
[16:12:33.648]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:33.648]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:33.648]                       tmpdir = path, fileext = ".rds")
[16:12:33.648]                     save_rds(obj, file)
[16:12:33.648]                   }
[16:12:33.648]                   saveImmediateCondition(cond, path = "/tmp/RtmpjVCO6F/.future/immediateConditions")
[16:12:33.648]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.648]                   {
[16:12:33.648]                     inherits <- base::inherits
[16:12:33.648]                     invokeRestart <- base::invokeRestart
[16:12:33.648]                     is.null <- base::is.null
[16:12:33.648]                     muffled <- FALSE
[16:12:33.648]                     if (inherits(cond, "message")) {
[16:12:33.648]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:33.648]                       if (muffled) 
[16:12:33.648]                         invokeRestart("muffleMessage")
[16:12:33.648]                     }
[16:12:33.648]                     else if (inherits(cond, "warning")) {
[16:12:33.648]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:33.648]                       if (muffled) 
[16:12:33.648]                         invokeRestart("muffleWarning")
[16:12:33.648]                     }
[16:12:33.648]                     else if (inherits(cond, "condition")) {
[16:12:33.648]                       if (!is.null(pattern)) {
[16:12:33.648]                         computeRestarts <- base::computeRestarts
[16:12:33.648]                         grepl <- base::grepl
[16:12:33.648]                         restarts <- computeRestarts(cond)
[16:12:33.648]                         for (restart in restarts) {
[16:12:33.648]                           name <- restart$name
[16:12:33.648]                           if (is.null(name)) 
[16:12:33.648]                             next
[16:12:33.648]                           if (!grepl(pattern, name)) 
[16:12:33.648]                             next
[16:12:33.648]                           invokeRestart(restart)
[16:12:33.648]                           muffled <- TRUE
[16:12:33.648]                           break
[16:12:33.648]                         }
[16:12:33.648]                       }
[16:12:33.648]                     }
[16:12:33.648]                     invisible(muffled)
[16:12:33.648]                   }
[16:12:33.648]                   muffleCondition(cond)
[16:12:33.648]                 })
[16:12:33.648]             }))
[16:12:33.648]             future::FutureResult(value = ...future.value$value, 
[16:12:33.648]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:33.648]                   ...future.rng), globalenv = if (FALSE) 
[16:12:33.648]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:33.648]                     ...future.globalenv.names))
[16:12:33.648]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:33.648]         }, condition = base::local({
[16:12:33.648]             c <- base::c
[16:12:33.648]             inherits <- base::inherits
[16:12:33.648]             invokeRestart <- base::invokeRestart
[16:12:33.648]             length <- base::length
[16:12:33.648]             list <- base::list
[16:12:33.648]             seq.int <- base::seq.int
[16:12:33.648]             signalCondition <- base::signalCondition
[16:12:33.648]             sys.calls <- base::sys.calls
[16:12:33.648]             `[[` <- base::`[[`
[16:12:33.648]             `+` <- base::`+`
[16:12:33.648]             `<<-` <- base::`<<-`
[16:12:33.648]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:33.648]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:33.648]                   3L)]
[16:12:33.648]             }
[16:12:33.648]             function(cond) {
[16:12:33.648]                 is_error <- inherits(cond, "error")
[16:12:33.648]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:33.648]                   NULL)
[16:12:33.648]                 if (is_error) {
[16:12:33.648]                   sessionInformation <- function() {
[16:12:33.648]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:33.648]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:33.648]                       search = base::search(), system = base::Sys.info())
[16:12:33.648]                   }
[16:12:33.648]                   ...future.conditions[[length(...future.conditions) + 
[16:12:33.648]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:33.648]                     cond$call), session = sessionInformation(), 
[16:12:33.648]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:33.648]                   signalCondition(cond)
[16:12:33.648]                 }
[16:12:33.648]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:33.648]                 "immediateCondition"))) {
[16:12:33.648]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:33.648]                   ...future.conditions[[length(...future.conditions) + 
[16:12:33.648]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:33.648]                   if (TRUE && !signal) {
[16:12:33.648]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.648]                     {
[16:12:33.648]                       inherits <- base::inherits
[16:12:33.648]                       invokeRestart <- base::invokeRestart
[16:12:33.648]                       is.null <- base::is.null
[16:12:33.648]                       muffled <- FALSE
[16:12:33.648]                       if (inherits(cond, "message")) {
[16:12:33.648]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:33.648]                         if (muffled) 
[16:12:33.648]                           invokeRestart("muffleMessage")
[16:12:33.648]                       }
[16:12:33.648]                       else if (inherits(cond, "warning")) {
[16:12:33.648]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:33.648]                         if (muffled) 
[16:12:33.648]                           invokeRestart("muffleWarning")
[16:12:33.648]                       }
[16:12:33.648]                       else if (inherits(cond, "condition")) {
[16:12:33.648]                         if (!is.null(pattern)) {
[16:12:33.648]                           computeRestarts <- base::computeRestarts
[16:12:33.648]                           grepl <- base::grepl
[16:12:33.648]                           restarts <- computeRestarts(cond)
[16:12:33.648]                           for (restart in restarts) {
[16:12:33.648]                             name <- restart$name
[16:12:33.648]                             if (is.null(name)) 
[16:12:33.648]                               next
[16:12:33.648]                             if (!grepl(pattern, name)) 
[16:12:33.648]                               next
[16:12:33.648]                             invokeRestart(restart)
[16:12:33.648]                             muffled <- TRUE
[16:12:33.648]                             break
[16:12:33.648]                           }
[16:12:33.648]                         }
[16:12:33.648]                       }
[16:12:33.648]                       invisible(muffled)
[16:12:33.648]                     }
[16:12:33.648]                     muffleCondition(cond, pattern = "^muffle")
[16:12:33.648]                   }
[16:12:33.648]                 }
[16:12:33.648]                 else {
[16:12:33.648]                   if (TRUE) {
[16:12:33.648]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:33.648]                     {
[16:12:33.648]                       inherits <- base::inherits
[16:12:33.648]                       invokeRestart <- base::invokeRestart
[16:12:33.648]                       is.null <- base::is.null
[16:12:33.648]                       muffled <- FALSE
[16:12:33.648]                       if (inherits(cond, "message")) {
[16:12:33.648]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:33.648]                         if (muffled) 
[16:12:33.648]                           invokeRestart("muffleMessage")
[16:12:33.648]                       }
[16:12:33.648]                       else if (inherits(cond, "warning")) {
[16:12:33.648]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:33.648]                         if (muffled) 
[16:12:33.648]                           invokeRestart("muffleWarning")
[16:12:33.648]                       }
[16:12:33.648]                       else if (inherits(cond, "condition")) {
[16:12:33.648]                         if (!is.null(pattern)) {
[16:12:33.648]                           computeRestarts <- base::computeRestarts
[16:12:33.648]                           grepl <- base::grepl
[16:12:33.648]                           restarts <- computeRestarts(cond)
[16:12:33.648]                           for (restart in restarts) {
[16:12:33.648]                             name <- restart$name
[16:12:33.648]                             if (is.null(name)) 
[16:12:33.648]                               next
[16:12:33.648]                             if (!grepl(pattern, name)) 
[16:12:33.648]                               next
[16:12:33.648]                             invokeRestart(restart)
[16:12:33.648]                             muffled <- TRUE
[16:12:33.648]                             break
[16:12:33.648]                           }
[16:12:33.648]                         }
[16:12:33.648]                       }
[16:12:33.648]                       invisible(muffled)
[16:12:33.648]                     }
[16:12:33.648]                     muffleCondition(cond, pattern = "^muffle")
[16:12:33.648]                   }
[16:12:33.648]                 }
[16:12:33.648]             }
[16:12:33.648]         }))
[16:12:33.648]     }, error = function(ex) {
[16:12:33.648]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:33.648]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:33.648]                 ...future.rng), started = ...future.startTime, 
[16:12:33.648]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:33.648]             version = "1.8"), class = "FutureResult")
[16:12:33.648]     }, finally = {
[16:12:33.648]         if (!identical(...future.workdir, getwd())) 
[16:12:33.648]             setwd(...future.workdir)
[16:12:33.648]         {
[16:12:33.648]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:33.648]                 ...future.oldOptions$nwarnings <- NULL
[16:12:33.648]             }
[16:12:33.648]             base::options(...future.oldOptions)
[16:12:33.648]             if (.Platform$OS.type == "windows") {
[16:12:33.648]                 old_names <- names(...future.oldEnvVars)
[16:12:33.648]                 envs <- base::Sys.getenv()
[16:12:33.648]                 names <- names(envs)
[16:12:33.648]                 common <- intersect(names, old_names)
[16:12:33.648]                 added <- setdiff(names, old_names)
[16:12:33.648]                 removed <- setdiff(old_names, names)
[16:12:33.648]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:33.648]                   envs[common]]
[16:12:33.648]                 NAMES <- toupper(changed)
[16:12:33.648]                 args <- list()
[16:12:33.648]                 for (kk in seq_along(NAMES)) {
[16:12:33.648]                   name <- changed[[kk]]
[16:12:33.648]                   NAME <- NAMES[[kk]]
[16:12:33.648]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.648]                     next
[16:12:33.648]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:33.648]                 }
[16:12:33.648]                 NAMES <- toupper(added)
[16:12:33.648]                 for (kk in seq_along(NAMES)) {
[16:12:33.648]                   name <- added[[kk]]
[16:12:33.648]                   NAME <- NAMES[[kk]]
[16:12:33.648]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.648]                     next
[16:12:33.648]                   args[[name]] <- ""
[16:12:33.648]                 }
[16:12:33.648]                 NAMES <- toupper(removed)
[16:12:33.648]                 for (kk in seq_along(NAMES)) {
[16:12:33.648]                   name <- removed[[kk]]
[16:12:33.648]                   NAME <- NAMES[[kk]]
[16:12:33.648]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:33.648]                     next
[16:12:33.648]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:33.648]                 }
[16:12:33.648]                 if (length(args) > 0) 
[16:12:33.648]                   base::do.call(base::Sys.setenv, args = args)
[16:12:33.648]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:33.648]             }
[16:12:33.648]             else {
[16:12:33.648]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:33.648]             }
[16:12:33.648]             {
[16:12:33.648]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:33.648]                   0L) {
[16:12:33.648]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:33.648]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:33.648]                   base::options(opts)
[16:12:33.648]                 }
[16:12:33.648]                 {
[16:12:33.648]                   {
[16:12:33.648]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:33.648]                     NULL
[16:12:33.648]                   }
[16:12:33.648]                   options(future.plan = NULL)
[16:12:33.648]                   if (is.na(NA_character_)) 
[16:12:33.648]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:33.648]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:33.648]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:33.648]                     envir = parent.frame()) 
[16:12:33.648]                   {
[16:12:33.648]                     default_workers <- missing(workers)
[16:12:33.648]                     if (is.function(workers)) 
[16:12:33.648]                       workers <- workers()
[16:12:33.648]                     workers <- structure(as.integer(workers), 
[16:12:33.648]                       class = class(workers))
[16:12:33.648]                     stop_if_not(is.finite(workers), workers >= 
[16:12:33.648]                       1L)
[16:12:33.648]                     if ((workers == 1L && !inherits(workers, 
[16:12:33.648]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:33.648]                       if (default_workers) 
[16:12:33.648]                         supportsMulticore(warn = TRUE)
[16:12:33.648]                       return(sequential(..., envir = envir))
[16:12:33.648]                     }
[16:12:33.648]                     oopts <- options(mc.cores = workers)
[16:12:33.648]                     on.exit(options(oopts))
[16:12:33.648]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:33.648]                       envir = envir)
[16:12:33.648]                     if (!future$lazy) 
[16:12:33.648]                       future <- run(future)
[16:12:33.648]                     invisible(future)
[16:12:33.648]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:33.648]                 }
[16:12:33.648]             }
[16:12:33.648]         }
[16:12:33.648]     })
[16:12:33.648]     if (TRUE) {
[16:12:33.648]         base::sink(type = "output", split = FALSE)
[16:12:33.648]         if (TRUE) {
[16:12:33.648]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:33.648]         }
[16:12:33.648]         else {
[16:12:33.648]             ...future.result["stdout"] <- base::list(NULL)
[16:12:33.648]         }
[16:12:33.648]         base::close(...future.stdout)
[16:12:33.648]         ...future.stdout <- NULL
[16:12:33.648]     }
[16:12:33.648]     ...future.result$conditions <- ...future.conditions
[16:12:33.648]     ...future.result$finished <- base::Sys.time()
[16:12:33.648]     ...future.result
[16:12:33.648] }
[16:12:33.651] assign_globals() ...
[16:12:33.651] List of 3
[16:12:33.651]  $ outer_function:function (x)  
[16:12:33.651]  $ map           :function (.x, .f, ...)  
[16:12:33.651]  $ inner_function:function (x)  
[16:12:33.651]  - attr(*, "where")=List of 3
[16:12:33.651]   ..$ outer_function:<environment: R_EmptyEnv> 
[16:12:33.651]   ..$ map           :<environment: R_EmptyEnv> 
[16:12:33.651]   ..$ inner_function:<environment: R_EmptyEnv> 
[16:12:33.651]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:33.651]  - attr(*, "resolved")= logi FALSE
[16:12:33.651]  - attr(*, "total_size")= num 7704
[16:12:33.651]  - attr(*, "already-done")= logi TRUE
[16:12:33.654] - reassign environment for ‘outer_function’
[16:12:33.655] - copied ‘outer_function’ to environment
[16:12:33.655] - reassign environment for ‘map’
[16:12:33.655] - copied ‘map’ to environment
[16:12:33.655] - reassign environment for ‘inner_function’
[16:12:33.655] - copied ‘inner_function’ to environment
[16:12:33.655] assign_globals() ... done
[16:12:33.655] requestCore(): workers = 2
[16:12:33.657] MulticoreFuture started
[16:12:33.657] - Launch lazy future ... done
[16:12:33.658] run() for ‘MulticoreFuture’ ... done
[16:12:33.658] plan(): Setting new future strategy stack:
[16:12:33.658] List of future strategies:
[16:12:33.658] 1. sequential:
[16:12:33.658]    - args: function (..., envir = parent.frame())
[16:12:33.658]    - tweaked: FALSE
[16:12:33.658]    - call: NULL
[16:12:33.659] plan(): nbrOfWorkers() = 1
[16:12:33.661] plan(): Setting new future strategy stack:
[16:12:33.662] List of future strategies:
[16:12:33.662] 1. multicore:
[16:12:33.662]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:33.662]    - tweaked: FALSE
[16:12:33.662]    - call: plan(strategy)
[16:12:33.667] plan(): nbrOfWorkers() = 2
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
- plan('multisession') ...
[16:12:33.670] plan(): Setting new future strategy stack:
[16:12:33.670] List of future strategies:
[16:12:33.670] 1. multisession:
[16:12:33.670]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:12:33.670]    - tweaked: FALSE
[16:12:33.670]    - call: plan(strategy)
[16:12:33.670] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:12:33.670] multisession:
[16:12:33.670] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:12:33.670] - tweaked: FALSE
[16:12:33.670] - call: plan(strategy)
[16:12:33.677] getGlobalsAndPackages() ...
[16:12:33.677] Not searching for globals
[16:12:33.680] - globals: [0] <none>
[16:12:33.680] getGlobalsAndPackages() ... DONE
[16:12:33.681] [local output] makeClusterPSOCK() ...
[16:12:33.719] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:12:33.725] [local output] Base port: 11127
[16:12:33.725] [local output] Getting setup options for 2 cluster nodes ...
[16:12:33.725] [local output]  - Node 1 of 2 ...
[16:12:33.725] [local output] localMachine=TRUE => revtunnel=FALSE

[16:12:33.726] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpjVCO6F/worker.rank=1.parallelly.parent=84029.1483d27fbd5c3.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpjVCO6F/worker.rank=1.parallelly.parent=84029.1483d27fbd5c3.pid")'’
[16:12:33.911] - Possible to infer worker's PID: TRUE
[16:12:33.912] [local output] Rscript port: 11127

[16:12:33.912] [local output]  - Node 2 of 2 ...
[16:12:33.913] [local output] localMachine=TRUE => revtunnel=FALSE

[16:12:33.913] [local output] Rscript port: 11127

[16:12:33.913] [local output] Getting setup options for 2 cluster nodes ... done
[16:12:33.914] [local output]  - Parallel setup requested for some PSOCK nodes
[16:12:33.914] [local output] Setting up PSOCK nodes in parallel
[16:12:33.914] List of 36
[16:12:33.914]  $ worker          : chr "localhost"
[16:12:33.914]   ..- attr(*, "localhost")= logi TRUE
[16:12:33.914]  $ master          : chr "localhost"
[16:12:33.914]  $ port            : int 11127
[16:12:33.914]  $ connectTimeout  : num 120
[16:12:33.914]  $ timeout         : num 2592000
[16:12:33.914]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:12:33.914]  $ homogeneous     : logi TRUE
[16:12:33.914]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:12:33.914]  $ rscript_envs    : NULL
[16:12:33.914]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:12:33.914]  $ rscript_startup : NULL
[16:12:33.914]  $ rscript_sh      : chr "sh"
[16:12:33.914]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:12:33.914]  $ methods         : logi TRUE
[16:12:33.914]  $ socketOptions   : chr "no-delay"
[16:12:33.914]  $ useXDR          : logi FALSE
[16:12:33.914]  $ outfile         : chr "/dev/null"
[16:12:33.914]  $ renice          : int NA
[16:12:33.914]  $ rshcmd          : NULL
[16:12:33.914]  $ user            : chr(0) 
[16:12:33.914]  $ revtunnel       : logi FALSE
[16:12:33.914]  $ rshlogfile      : NULL
[16:12:33.914]  $ rshopts         : chr(0) 
[16:12:33.914]  $ rank            : int 1
[16:12:33.914]  $ manual          : logi FALSE
[16:12:33.914]  $ dryrun          : logi FALSE
[16:12:33.914]  $ quiet           : logi FALSE
[16:12:33.914]  $ setup_strategy  : chr "parallel"
[16:12:33.914]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:12:33.914]  $ pidfile         : chr "/tmp/RtmpjVCO6F/worker.rank=1.parallelly.parent=84029.1483d27fbd5c3.pid"
[16:12:33.914]  $ rshcmd_label    : NULL
[16:12:33.914]  $ rsh_call        : NULL
[16:12:33.914]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:12:33.914]  $ localMachine    : logi TRUE
[16:12:33.914]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:12:33.914]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:12:33.914]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:12:33.914]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:12:33.914]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:12:33.914]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:12:33.914]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:12:33.914]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:12:33.914]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:12:33.914]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:12:33.914]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:12:33.914]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:12:33.914]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:12:33.914]  $ arguments       :List of 28
[16:12:33.914]   ..$ worker          : chr "localhost"
[16:12:33.914]   ..$ master          : NULL
[16:12:33.914]   ..$ port            : int 11127
[16:12:33.914]   ..$ connectTimeout  : num 120
[16:12:33.914]   ..$ timeout         : num 2592000
[16:12:33.914]   ..$ rscript         : NULL
[16:12:33.914]   ..$ homogeneous     : NULL
[16:12:33.914]   ..$ rscript_args    : NULL
[16:12:33.914]   ..$ rscript_envs    : NULL
[16:12:33.914]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:12:33.914]   ..$ rscript_startup : NULL
[16:12:33.914]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:12:33.914]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:12:33.914]   ..$ methods         : logi TRUE
[16:12:33.914]   ..$ socketOptions   : chr "no-delay"
[16:12:33.914]   ..$ useXDR          : logi FALSE
[16:12:33.914]   ..$ outfile         : chr "/dev/null"
[16:12:33.914]   ..$ renice          : int NA
[16:12:33.914]   ..$ rshcmd          : NULL
[16:12:33.914]   ..$ user            : NULL
[16:12:33.914]   ..$ revtunnel       : logi NA
[16:12:33.914]   ..$ rshlogfile      : NULL
[16:12:33.914]   ..$ rshopts         : NULL
[16:12:33.914]   ..$ rank            : int 1
[16:12:33.914]   ..$ manual          : logi FALSE
[16:12:33.914]   ..$ dryrun          : logi FALSE
[16:12:33.914]   ..$ quiet           : logi FALSE
[16:12:33.914]   ..$ setup_strategy  : chr "parallel"
[16:12:33.914]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:12:33.931] [local output] System call to launch all workers:
[16:12:33.931] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpjVCO6F/worker.rank=1.parallelly.parent=84029.1483d27fbd5c3.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11127 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:12:33.931] [local output] Starting PSOCK main server
[16:12:33.933] [local output] Workers launched
[16:12:33.933] [local output] Waiting for workers to connect back
[16:12:33.933]  - [local output] 0 workers out of 2 ready
[16:12:34.177]  - [local output] 0 workers out of 2 ready
[16:12:34.177]  - [local output] 1 workers out of 2 ready
[16:12:34.177]  - [local output] 2 workers out of 2 ready
[16:12:34.178] [local output] Launching of workers completed
[16:12:34.178] [local output] Collecting session information from workers
[16:12:34.179] [local output]  - Worker #1 of 2
[16:12:34.179] [local output]  - Worker #2 of 2
[16:12:34.179] [local output] makeClusterPSOCK() ... done
[16:12:34.191] Packages needed by the future expression (n = 0): <none>
[16:12:34.191] Packages needed by future strategies (n = 0): <none>
[16:12:34.192] {
[16:12:34.192]     {
[16:12:34.192]         {
[16:12:34.192]             ...future.startTime <- base::Sys.time()
[16:12:34.192]             {
[16:12:34.192]                 {
[16:12:34.192]                   {
[16:12:34.192]                     {
[16:12:34.192]                       base::local({
[16:12:34.192]                         has_future <- base::requireNamespace("future", 
[16:12:34.192]                           quietly = TRUE)
[16:12:34.192]                         if (has_future) {
[16:12:34.192]                           ns <- base::getNamespace("future")
[16:12:34.192]                           version <- ns[[".package"]][["version"]]
[16:12:34.192]                           if (is.null(version)) 
[16:12:34.192]                             version <- utils::packageVersion("future")
[16:12:34.192]                         }
[16:12:34.192]                         else {
[16:12:34.192]                           version <- NULL
[16:12:34.192]                         }
[16:12:34.192]                         if (!has_future || version < "1.8.0") {
[16:12:34.192]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:34.192]                             "", base::R.version$version.string), 
[16:12:34.192]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:34.192]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:34.192]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:34.192]                               "release", "version")], collapse = " "), 
[16:12:34.192]                             hostname = base::Sys.info()[["nodename"]])
[16:12:34.192]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:34.192]                             info)
[16:12:34.192]                           info <- base::paste(info, collapse = "; ")
[16:12:34.192]                           if (!has_future) {
[16:12:34.192]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:34.192]                               info)
[16:12:34.192]                           }
[16:12:34.192]                           else {
[16:12:34.192]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:34.192]                               info, version)
[16:12:34.192]                           }
[16:12:34.192]                           base::stop(msg)
[16:12:34.192]                         }
[16:12:34.192]                       })
[16:12:34.192]                     }
[16:12:34.192]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:34.192]                     base::options(mc.cores = 1L)
[16:12:34.192]                   }
[16:12:34.192]                   options(future.plan = NULL)
[16:12:34.192]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:34.192]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:34.192]                 }
[16:12:34.192]                 ...future.workdir <- getwd()
[16:12:34.192]             }
[16:12:34.192]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:34.192]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:34.192]         }
[16:12:34.192]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:34.192]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:34.192]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:34.192]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:34.192]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:34.192]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:34.192]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:34.192]             base::names(...future.oldOptions))
[16:12:34.192]     }
[16:12:34.192]     if (FALSE) {
[16:12:34.192]     }
[16:12:34.192]     else {
[16:12:34.192]         if (TRUE) {
[16:12:34.192]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:34.192]                 open = "w")
[16:12:34.192]         }
[16:12:34.192]         else {
[16:12:34.192]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:34.192]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:34.192]         }
[16:12:34.192]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:34.192]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:34.192]             base::sink(type = "output", split = FALSE)
[16:12:34.192]             base::close(...future.stdout)
[16:12:34.192]         }, add = TRUE)
[16:12:34.192]     }
[16:12:34.192]     ...future.frame <- base::sys.nframe()
[16:12:34.192]     ...future.conditions <- base::list()
[16:12:34.192]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:34.192]     if (FALSE) {
[16:12:34.192]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:34.192]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:34.192]     }
[16:12:34.192]     ...future.result <- base::tryCatch({
[16:12:34.192]         base::withCallingHandlers({
[16:12:34.192]             ...future.value <- base::withVisible(base::local({
[16:12:34.192]                 ...future.makeSendCondition <- local({
[16:12:34.192]                   sendCondition <- NULL
[16:12:34.192]                   function(frame = 1L) {
[16:12:34.192]                     if (is.function(sendCondition)) 
[16:12:34.192]                       return(sendCondition)
[16:12:34.192]                     ns <- getNamespace("parallel")
[16:12:34.192]                     if (exists("sendData", mode = "function", 
[16:12:34.192]                       envir = ns)) {
[16:12:34.192]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:34.192]                         envir = ns)
[16:12:34.192]                       envir <- sys.frame(frame)
[16:12:34.192]                       master <- NULL
[16:12:34.192]                       while (!identical(envir, .GlobalEnv) && 
[16:12:34.192]                         !identical(envir, emptyenv())) {
[16:12:34.192]                         if (exists("master", mode = "list", envir = envir, 
[16:12:34.192]                           inherits = FALSE)) {
[16:12:34.192]                           master <- get("master", mode = "list", 
[16:12:34.192]                             envir = envir, inherits = FALSE)
[16:12:34.192]                           if (inherits(master, c("SOCKnode", 
[16:12:34.192]                             "SOCK0node"))) {
[16:12:34.192]                             sendCondition <<- function(cond) {
[16:12:34.192]                               data <- list(type = "VALUE", value = cond, 
[16:12:34.192]                                 success = TRUE)
[16:12:34.192]                               parallel_sendData(master, data)
[16:12:34.192]                             }
[16:12:34.192]                             return(sendCondition)
[16:12:34.192]                           }
[16:12:34.192]                         }
[16:12:34.192]                         frame <- frame + 1L
[16:12:34.192]                         envir <- sys.frame(frame)
[16:12:34.192]                       }
[16:12:34.192]                     }
[16:12:34.192]                     sendCondition <<- function(cond) NULL
[16:12:34.192]                   }
[16:12:34.192]                 })
[16:12:34.192]                 withCallingHandlers({
[16:12:34.192]                   NA
[16:12:34.192]                 }, immediateCondition = function(cond) {
[16:12:34.192]                   sendCondition <- ...future.makeSendCondition()
[16:12:34.192]                   sendCondition(cond)
[16:12:34.192]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:34.192]                   {
[16:12:34.192]                     inherits <- base::inherits
[16:12:34.192]                     invokeRestart <- base::invokeRestart
[16:12:34.192]                     is.null <- base::is.null
[16:12:34.192]                     muffled <- FALSE
[16:12:34.192]                     if (inherits(cond, "message")) {
[16:12:34.192]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:34.192]                       if (muffled) 
[16:12:34.192]                         invokeRestart("muffleMessage")
[16:12:34.192]                     }
[16:12:34.192]                     else if (inherits(cond, "warning")) {
[16:12:34.192]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:34.192]                       if (muffled) 
[16:12:34.192]                         invokeRestart("muffleWarning")
[16:12:34.192]                     }
[16:12:34.192]                     else if (inherits(cond, "condition")) {
[16:12:34.192]                       if (!is.null(pattern)) {
[16:12:34.192]                         computeRestarts <- base::computeRestarts
[16:12:34.192]                         grepl <- base::grepl
[16:12:34.192]                         restarts <- computeRestarts(cond)
[16:12:34.192]                         for (restart in restarts) {
[16:12:34.192]                           name <- restart$name
[16:12:34.192]                           if (is.null(name)) 
[16:12:34.192]                             next
[16:12:34.192]                           if (!grepl(pattern, name)) 
[16:12:34.192]                             next
[16:12:34.192]                           invokeRestart(restart)
[16:12:34.192]                           muffled <- TRUE
[16:12:34.192]                           break
[16:12:34.192]                         }
[16:12:34.192]                       }
[16:12:34.192]                     }
[16:12:34.192]                     invisible(muffled)
[16:12:34.192]                   }
[16:12:34.192]                   muffleCondition(cond)
[16:12:34.192]                 })
[16:12:34.192]             }))
[16:12:34.192]             future::FutureResult(value = ...future.value$value, 
[16:12:34.192]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:34.192]                   ...future.rng), globalenv = if (FALSE) 
[16:12:34.192]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:34.192]                     ...future.globalenv.names))
[16:12:34.192]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:34.192]         }, condition = base::local({
[16:12:34.192]             c <- base::c
[16:12:34.192]             inherits <- base::inherits
[16:12:34.192]             invokeRestart <- base::invokeRestart
[16:12:34.192]             length <- base::length
[16:12:34.192]             list <- base::list
[16:12:34.192]             seq.int <- base::seq.int
[16:12:34.192]             signalCondition <- base::signalCondition
[16:12:34.192]             sys.calls <- base::sys.calls
[16:12:34.192]             `[[` <- base::`[[`
[16:12:34.192]             `+` <- base::`+`
[16:12:34.192]             `<<-` <- base::`<<-`
[16:12:34.192]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:34.192]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:34.192]                   3L)]
[16:12:34.192]             }
[16:12:34.192]             function(cond) {
[16:12:34.192]                 is_error <- inherits(cond, "error")
[16:12:34.192]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:34.192]                   NULL)
[16:12:34.192]                 if (is_error) {
[16:12:34.192]                   sessionInformation <- function() {
[16:12:34.192]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:34.192]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:34.192]                       search = base::search(), system = base::Sys.info())
[16:12:34.192]                   }
[16:12:34.192]                   ...future.conditions[[length(...future.conditions) + 
[16:12:34.192]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:34.192]                     cond$call), session = sessionInformation(), 
[16:12:34.192]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:34.192]                   signalCondition(cond)
[16:12:34.192]                 }
[16:12:34.192]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:34.192]                 "immediateCondition"))) {
[16:12:34.192]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:34.192]                   ...future.conditions[[length(...future.conditions) + 
[16:12:34.192]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:34.192]                   if (TRUE && !signal) {
[16:12:34.192]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:34.192]                     {
[16:12:34.192]                       inherits <- base::inherits
[16:12:34.192]                       invokeRestart <- base::invokeRestart
[16:12:34.192]                       is.null <- base::is.null
[16:12:34.192]                       muffled <- FALSE
[16:12:34.192]                       if (inherits(cond, "message")) {
[16:12:34.192]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:34.192]                         if (muffled) 
[16:12:34.192]                           invokeRestart("muffleMessage")
[16:12:34.192]                       }
[16:12:34.192]                       else if (inherits(cond, "warning")) {
[16:12:34.192]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:34.192]                         if (muffled) 
[16:12:34.192]                           invokeRestart("muffleWarning")
[16:12:34.192]                       }
[16:12:34.192]                       else if (inherits(cond, "condition")) {
[16:12:34.192]                         if (!is.null(pattern)) {
[16:12:34.192]                           computeRestarts <- base::computeRestarts
[16:12:34.192]                           grepl <- base::grepl
[16:12:34.192]                           restarts <- computeRestarts(cond)
[16:12:34.192]                           for (restart in restarts) {
[16:12:34.192]                             name <- restart$name
[16:12:34.192]                             if (is.null(name)) 
[16:12:34.192]                               next
[16:12:34.192]                             if (!grepl(pattern, name)) 
[16:12:34.192]                               next
[16:12:34.192]                             invokeRestart(restart)
[16:12:34.192]                             muffled <- TRUE
[16:12:34.192]                             break
[16:12:34.192]                           }
[16:12:34.192]                         }
[16:12:34.192]                       }
[16:12:34.192]                       invisible(muffled)
[16:12:34.192]                     }
[16:12:34.192]                     muffleCondition(cond, pattern = "^muffle")
[16:12:34.192]                   }
[16:12:34.192]                 }
[16:12:34.192]                 else {
[16:12:34.192]                   if (TRUE) {
[16:12:34.192]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:34.192]                     {
[16:12:34.192]                       inherits <- base::inherits
[16:12:34.192]                       invokeRestart <- base::invokeRestart
[16:12:34.192]                       is.null <- base::is.null
[16:12:34.192]                       muffled <- FALSE
[16:12:34.192]                       if (inherits(cond, "message")) {
[16:12:34.192]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:34.192]                         if (muffled) 
[16:12:34.192]                           invokeRestart("muffleMessage")
[16:12:34.192]                       }
[16:12:34.192]                       else if (inherits(cond, "warning")) {
[16:12:34.192]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:34.192]                         if (muffled) 
[16:12:34.192]                           invokeRestart("muffleWarning")
[16:12:34.192]                       }
[16:12:34.192]                       else if (inherits(cond, "condition")) {
[16:12:34.192]                         if (!is.null(pattern)) {
[16:12:34.192]                           computeRestarts <- base::computeRestarts
[16:12:34.192]                           grepl <- base::grepl
[16:12:34.192]                           restarts <- computeRestarts(cond)
[16:12:34.192]                           for (restart in restarts) {
[16:12:34.192]                             name <- restart$name
[16:12:34.192]                             if (is.null(name)) 
[16:12:34.192]                               next
[16:12:34.192]                             if (!grepl(pattern, name)) 
[16:12:34.192]                               next
[16:12:34.192]                             invokeRestart(restart)
[16:12:34.192]                             muffled <- TRUE
[16:12:34.192]                             break
[16:12:34.192]                           }
[16:12:34.192]                         }
[16:12:34.192]                       }
[16:12:34.192]                       invisible(muffled)
[16:12:34.192]                     }
[16:12:34.192]                     muffleCondition(cond, pattern = "^muffle")
[16:12:34.192]                   }
[16:12:34.192]                 }
[16:12:34.192]             }
[16:12:34.192]         }))
[16:12:34.192]     }, error = function(ex) {
[16:12:34.192]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:34.192]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:34.192]                 ...future.rng), started = ...future.startTime, 
[16:12:34.192]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:34.192]             version = "1.8"), class = "FutureResult")
[16:12:34.192]     }, finally = {
[16:12:34.192]         if (!identical(...future.workdir, getwd())) 
[16:12:34.192]             setwd(...future.workdir)
[16:12:34.192]         {
[16:12:34.192]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:34.192]                 ...future.oldOptions$nwarnings <- NULL
[16:12:34.192]             }
[16:12:34.192]             base::options(...future.oldOptions)
[16:12:34.192]             if (.Platform$OS.type == "windows") {
[16:12:34.192]                 old_names <- names(...future.oldEnvVars)
[16:12:34.192]                 envs <- base::Sys.getenv()
[16:12:34.192]                 names <- names(envs)
[16:12:34.192]                 common <- intersect(names, old_names)
[16:12:34.192]                 added <- setdiff(names, old_names)
[16:12:34.192]                 removed <- setdiff(old_names, names)
[16:12:34.192]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:34.192]                   envs[common]]
[16:12:34.192]                 NAMES <- toupper(changed)
[16:12:34.192]                 args <- list()
[16:12:34.192]                 for (kk in seq_along(NAMES)) {
[16:12:34.192]                   name <- changed[[kk]]
[16:12:34.192]                   NAME <- NAMES[[kk]]
[16:12:34.192]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:34.192]                     next
[16:12:34.192]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:34.192]                 }
[16:12:34.192]                 NAMES <- toupper(added)
[16:12:34.192]                 for (kk in seq_along(NAMES)) {
[16:12:34.192]                   name <- added[[kk]]
[16:12:34.192]                   NAME <- NAMES[[kk]]
[16:12:34.192]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:34.192]                     next
[16:12:34.192]                   args[[name]] <- ""
[16:12:34.192]                 }
[16:12:34.192]                 NAMES <- toupper(removed)
[16:12:34.192]                 for (kk in seq_along(NAMES)) {
[16:12:34.192]                   name <- removed[[kk]]
[16:12:34.192]                   NAME <- NAMES[[kk]]
[16:12:34.192]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:34.192]                     next
[16:12:34.192]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:34.192]                 }
[16:12:34.192]                 if (length(args) > 0) 
[16:12:34.192]                   base::do.call(base::Sys.setenv, args = args)
[16:12:34.192]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:34.192]             }
[16:12:34.192]             else {
[16:12:34.192]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:34.192]             }
[16:12:34.192]             {
[16:12:34.192]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:34.192]                   0L) {
[16:12:34.192]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:34.192]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:34.192]                   base::options(opts)
[16:12:34.192]                 }
[16:12:34.192]                 {
[16:12:34.192]                   {
[16:12:34.192]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:34.192]                     NULL
[16:12:34.192]                   }
[16:12:34.192]                   options(future.plan = NULL)
[16:12:34.192]                   if (is.na(NA_character_)) 
[16:12:34.192]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:34.192]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:34.192]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:34.192]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:34.192]                     envir = parent.frame()) 
[16:12:34.192]                   {
[16:12:34.192]                     if (is.function(workers)) 
[16:12:34.192]                       workers <- workers()
[16:12:34.192]                     workers <- structure(as.integer(workers), 
[16:12:34.192]                       class = class(workers))
[16:12:34.192]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:34.192]                       workers >= 1)
[16:12:34.192]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:34.192]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:34.192]                     }
[16:12:34.192]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:34.192]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:34.192]                       envir = envir)
[16:12:34.192]                     if (!future$lazy) 
[16:12:34.192]                       future <- run(future)
[16:12:34.192]                     invisible(future)
[16:12:34.192]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:34.192]                 }
[16:12:34.192]             }
[16:12:34.192]         }
[16:12:34.192]     })
[16:12:34.192]     if (TRUE) {
[16:12:34.192]         base::sink(type = "output", split = FALSE)
[16:12:34.192]         if (TRUE) {
[16:12:34.192]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:34.192]         }
[16:12:34.192]         else {
[16:12:34.192]             ...future.result["stdout"] <- base::list(NULL)
[16:12:34.192]         }
[16:12:34.192]         base::close(...future.stdout)
[16:12:34.192]         ...future.stdout <- NULL
[16:12:34.192]     }
[16:12:34.192]     ...future.result$conditions <- ...future.conditions
[16:12:34.192]     ...future.result$finished <- base::Sys.time()
[16:12:34.192]     ...future.result
[16:12:34.192] }
[16:12:34.263] MultisessionFuture started
[16:12:34.263] result() for ClusterFuture ...
[16:12:34.264] receiveMessageFromWorker() for ClusterFuture ...
[16:12:34.264] - Validating connection of MultisessionFuture
[16:12:34.296] - received message: FutureResult
[16:12:34.296] - Received FutureResult
[16:12:34.297] - Erased future from FutureRegistry
[16:12:34.297] result() for ClusterFuture ...
[16:12:34.297] - result already collected: FutureResult
[16:12:34.297] result() for ClusterFuture ... done
[16:12:34.297] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:34.297] result() for ClusterFuture ... done
[16:12:34.297] result() for ClusterFuture ...
[16:12:34.298] - result already collected: FutureResult
[16:12:34.298] result() for ClusterFuture ... done
[16:12:34.298] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:12:34.301] plan(): nbrOfWorkers() = 2
- lm(<formula>) ...
[16:12:34.302] getGlobalsAndPackages() ...
[16:12:34.302] Searching for globals...
[16:12:34.304] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:12:34.304] Searching for globals ... DONE
[16:12:34.304] Resolving globals: FALSE
[16:12:34.305] The total size of the 2 globals is 896 bytes (896 bytes)
[16:12:34.305] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:12:34.305] - globals: [2] ‘weight’, ‘group’
[16:12:34.306] - packages: [1] ‘stats’
[16:12:34.306] getGlobalsAndPackages() ... DONE
[16:12:34.306] run() for ‘Future’ ...
[16:12:34.306] - state: ‘created’
[16:12:34.306] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:34.321] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:34.322] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:34.322]   - Field: ‘node’
[16:12:34.322]   - Field: ‘label’
[16:12:34.322]   - Field: ‘local’
[16:12:34.322]   - Field: ‘owner’
[16:12:34.322]   - Field: ‘envir’
[16:12:34.322]   - Field: ‘workers’
[16:12:34.322]   - Field: ‘packages’
[16:12:34.322]   - Field: ‘gc’
[16:12:34.322]   - Field: ‘conditions’
[16:12:34.323]   - Field: ‘persistent’
[16:12:34.323]   - Field: ‘expr’
[16:12:34.323]   - Field: ‘uuid’
[16:12:34.323]   - Field: ‘seed’
[16:12:34.323]   - Field: ‘version’
[16:12:34.323]   - Field: ‘result’
[16:12:34.323]   - Field: ‘asynchronous’
[16:12:34.323]   - Field: ‘calls’
[16:12:34.323]   - Field: ‘globals’
[16:12:34.324]   - Field: ‘stdout’
[16:12:34.324]   - Field: ‘earlySignal’
[16:12:34.324]   - Field: ‘lazy’
[16:12:34.324]   - Field: ‘state’
[16:12:34.324] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:34.324] - Launch lazy future ...
[16:12:34.325] Packages needed by the future expression (n = 1): ‘stats’
[16:12:34.325] Packages needed by future strategies (n = 0): <none>
[16:12:34.325] {
[16:12:34.325]     {
[16:12:34.325]         {
[16:12:34.325]             ...future.startTime <- base::Sys.time()
[16:12:34.325]             {
[16:12:34.325]                 {
[16:12:34.325]                   {
[16:12:34.325]                     {
[16:12:34.325]                       {
[16:12:34.325]                         base::local({
[16:12:34.325]                           has_future <- base::requireNamespace("future", 
[16:12:34.325]                             quietly = TRUE)
[16:12:34.325]                           if (has_future) {
[16:12:34.325]                             ns <- base::getNamespace("future")
[16:12:34.325]                             version <- ns[[".package"]][["version"]]
[16:12:34.325]                             if (is.null(version)) 
[16:12:34.325]                               version <- utils::packageVersion("future")
[16:12:34.325]                           }
[16:12:34.325]                           else {
[16:12:34.325]                             version <- NULL
[16:12:34.325]                           }
[16:12:34.325]                           if (!has_future || version < "1.8.0") {
[16:12:34.325]                             info <- base::c(r_version = base::gsub("R version ", 
[16:12:34.325]                               "", base::R.version$version.string), 
[16:12:34.325]                               platform = base::sprintf("%s (%s-bit)", 
[16:12:34.325]                                 base::R.version$platform, 8 * 
[16:12:34.325]                                   base::.Machine$sizeof.pointer), 
[16:12:34.325]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:34.325]                                 "release", "version")], collapse = " "), 
[16:12:34.325]                               hostname = base::Sys.info()[["nodename"]])
[16:12:34.325]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:12:34.325]                               info)
[16:12:34.325]                             info <- base::paste(info, collapse = "; ")
[16:12:34.325]                             if (!has_future) {
[16:12:34.325]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:34.325]                                 info)
[16:12:34.325]                             }
[16:12:34.325]                             else {
[16:12:34.325]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:34.325]                                 info, version)
[16:12:34.325]                             }
[16:12:34.325]                             base::stop(msg)
[16:12:34.325]                           }
[16:12:34.325]                         })
[16:12:34.325]                       }
[16:12:34.325]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:34.325]                       base::options(mc.cores = 1L)
[16:12:34.325]                     }
[16:12:34.325]                     base::local({
[16:12:34.325]                       for (pkg in "stats") {
[16:12:34.325]                         base::loadNamespace(pkg)
[16:12:34.325]                         base::library(pkg, character.only = TRUE)
[16:12:34.325]                       }
[16:12:34.325]                     })
[16:12:34.325]                   }
[16:12:34.325]                   options(future.plan = NULL)
[16:12:34.325]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:34.325]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:34.325]                 }
[16:12:34.325]                 ...future.workdir <- getwd()
[16:12:34.325]             }
[16:12:34.325]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:34.325]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:34.325]         }
[16:12:34.325]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:34.325]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:34.325]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:34.325]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:34.325]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:34.325]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:34.325]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:34.325]             base::names(...future.oldOptions))
[16:12:34.325]     }
[16:12:34.325]     if (FALSE) {
[16:12:34.325]     }
[16:12:34.325]     else {
[16:12:34.325]         if (TRUE) {
[16:12:34.325]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:34.325]                 open = "w")
[16:12:34.325]         }
[16:12:34.325]         else {
[16:12:34.325]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:34.325]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:34.325]         }
[16:12:34.325]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:34.325]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:34.325]             base::sink(type = "output", split = FALSE)
[16:12:34.325]             base::close(...future.stdout)
[16:12:34.325]         }, add = TRUE)
[16:12:34.325]     }
[16:12:34.325]     ...future.frame <- base::sys.nframe()
[16:12:34.325]     ...future.conditions <- base::list()
[16:12:34.325]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:34.325]     if (FALSE) {
[16:12:34.325]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:34.325]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:34.325]     }
[16:12:34.325]     ...future.result <- base::tryCatch({
[16:12:34.325]         base::withCallingHandlers({
[16:12:34.325]             ...future.value <- base::withVisible(base::local({
[16:12:34.325]                 ...future.makeSendCondition <- local({
[16:12:34.325]                   sendCondition <- NULL
[16:12:34.325]                   function(frame = 1L) {
[16:12:34.325]                     if (is.function(sendCondition)) 
[16:12:34.325]                       return(sendCondition)
[16:12:34.325]                     ns <- getNamespace("parallel")
[16:12:34.325]                     if (exists("sendData", mode = "function", 
[16:12:34.325]                       envir = ns)) {
[16:12:34.325]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:34.325]                         envir = ns)
[16:12:34.325]                       envir <- sys.frame(frame)
[16:12:34.325]                       master <- NULL
[16:12:34.325]                       while (!identical(envir, .GlobalEnv) && 
[16:12:34.325]                         !identical(envir, emptyenv())) {
[16:12:34.325]                         if (exists("master", mode = "list", envir = envir, 
[16:12:34.325]                           inherits = FALSE)) {
[16:12:34.325]                           master <- get("master", mode = "list", 
[16:12:34.325]                             envir = envir, inherits = FALSE)
[16:12:34.325]                           if (inherits(master, c("SOCKnode", 
[16:12:34.325]                             "SOCK0node"))) {
[16:12:34.325]                             sendCondition <<- function(cond) {
[16:12:34.325]                               data <- list(type = "VALUE", value = cond, 
[16:12:34.325]                                 success = TRUE)
[16:12:34.325]                               parallel_sendData(master, data)
[16:12:34.325]                             }
[16:12:34.325]                             return(sendCondition)
[16:12:34.325]                           }
[16:12:34.325]                         }
[16:12:34.325]                         frame <- frame + 1L
[16:12:34.325]                         envir <- sys.frame(frame)
[16:12:34.325]                       }
[16:12:34.325]                     }
[16:12:34.325]                     sendCondition <<- function(cond) NULL
[16:12:34.325]                   }
[16:12:34.325]                 })
[16:12:34.325]                 withCallingHandlers({
[16:12:34.325]                   {
[16:12:34.325]                     lm(weight ~ group - 1)
[16:12:34.325]                   }
[16:12:34.325]                 }, immediateCondition = function(cond) {
[16:12:34.325]                   sendCondition <- ...future.makeSendCondition()
[16:12:34.325]                   sendCondition(cond)
[16:12:34.325]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:34.325]                   {
[16:12:34.325]                     inherits <- base::inherits
[16:12:34.325]                     invokeRestart <- base::invokeRestart
[16:12:34.325]                     is.null <- base::is.null
[16:12:34.325]                     muffled <- FALSE
[16:12:34.325]                     if (inherits(cond, "message")) {
[16:12:34.325]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:34.325]                       if (muffled) 
[16:12:34.325]                         invokeRestart("muffleMessage")
[16:12:34.325]                     }
[16:12:34.325]                     else if (inherits(cond, "warning")) {
[16:12:34.325]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:34.325]                       if (muffled) 
[16:12:34.325]                         invokeRestart("muffleWarning")
[16:12:34.325]                     }
[16:12:34.325]                     else if (inherits(cond, "condition")) {
[16:12:34.325]                       if (!is.null(pattern)) {
[16:12:34.325]                         computeRestarts <- base::computeRestarts
[16:12:34.325]                         grepl <- base::grepl
[16:12:34.325]                         restarts <- computeRestarts(cond)
[16:12:34.325]                         for (restart in restarts) {
[16:12:34.325]                           name <- restart$name
[16:12:34.325]                           if (is.null(name)) 
[16:12:34.325]                             next
[16:12:34.325]                           if (!grepl(pattern, name)) 
[16:12:34.325]                             next
[16:12:34.325]                           invokeRestart(restart)
[16:12:34.325]                           muffled <- TRUE
[16:12:34.325]                           break
[16:12:34.325]                         }
[16:12:34.325]                       }
[16:12:34.325]                     }
[16:12:34.325]                     invisible(muffled)
[16:12:34.325]                   }
[16:12:34.325]                   muffleCondition(cond)
[16:12:34.325]                 })
[16:12:34.325]             }))
[16:12:34.325]             future::FutureResult(value = ...future.value$value, 
[16:12:34.325]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:34.325]                   ...future.rng), globalenv = if (FALSE) 
[16:12:34.325]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:34.325]                     ...future.globalenv.names))
[16:12:34.325]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:34.325]         }, condition = base::local({
[16:12:34.325]             c <- base::c
[16:12:34.325]             inherits <- base::inherits
[16:12:34.325]             invokeRestart <- base::invokeRestart
[16:12:34.325]             length <- base::length
[16:12:34.325]             list <- base::list
[16:12:34.325]             seq.int <- base::seq.int
[16:12:34.325]             signalCondition <- base::signalCondition
[16:12:34.325]             sys.calls <- base::sys.calls
[16:12:34.325]             `[[` <- base::`[[`
[16:12:34.325]             `+` <- base::`+`
[16:12:34.325]             `<<-` <- base::`<<-`
[16:12:34.325]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:34.325]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:34.325]                   3L)]
[16:12:34.325]             }
[16:12:34.325]             function(cond) {
[16:12:34.325]                 is_error <- inherits(cond, "error")
[16:12:34.325]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:34.325]                   NULL)
[16:12:34.325]                 if (is_error) {
[16:12:34.325]                   sessionInformation <- function() {
[16:12:34.325]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:34.325]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:34.325]                       search = base::search(), system = base::Sys.info())
[16:12:34.325]                   }
[16:12:34.325]                   ...future.conditions[[length(...future.conditions) + 
[16:12:34.325]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:34.325]                     cond$call), session = sessionInformation(), 
[16:12:34.325]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:34.325]                   signalCondition(cond)
[16:12:34.325]                 }
[16:12:34.325]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:34.325]                 "immediateCondition"))) {
[16:12:34.325]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:34.325]                   ...future.conditions[[length(...future.conditions) + 
[16:12:34.325]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:34.325]                   if (TRUE && !signal) {
[16:12:34.325]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:34.325]                     {
[16:12:34.325]                       inherits <- base::inherits
[16:12:34.325]                       invokeRestart <- base::invokeRestart
[16:12:34.325]                       is.null <- base::is.null
[16:12:34.325]                       muffled <- FALSE
[16:12:34.325]                       if (inherits(cond, "message")) {
[16:12:34.325]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:34.325]                         if (muffled) 
[16:12:34.325]                           invokeRestart("muffleMessage")
[16:12:34.325]                       }
[16:12:34.325]                       else if (inherits(cond, "warning")) {
[16:12:34.325]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:34.325]                         if (muffled) 
[16:12:34.325]                           invokeRestart("muffleWarning")
[16:12:34.325]                       }
[16:12:34.325]                       else if (inherits(cond, "condition")) {
[16:12:34.325]                         if (!is.null(pattern)) {
[16:12:34.325]                           computeRestarts <- base::computeRestarts
[16:12:34.325]                           grepl <- base::grepl
[16:12:34.325]                           restarts <- computeRestarts(cond)
[16:12:34.325]                           for (restart in restarts) {
[16:12:34.325]                             name <- restart$name
[16:12:34.325]                             if (is.null(name)) 
[16:12:34.325]                               next
[16:12:34.325]                             if (!grepl(pattern, name)) 
[16:12:34.325]                               next
[16:12:34.325]                             invokeRestart(restart)
[16:12:34.325]                             muffled <- TRUE
[16:12:34.325]                             break
[16:12:34.325]                           }
[16:12:34.325]                         }
[16:12:34.325]                       }
[16:12:34.325]                       invisible(muffled)
[16:12:34.325]                     }
[16:12:34.325]                     muffleCondition(cond, pattern = "^muffle")
[16:12:34.325]                   }
[16:12:34.325]                 }
[16:12:34.325]                 else {
[16:12:34.325]                   if (TRUE) {
[16:12:34.325]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:34.325]                     {
[16:12:34.325]                       inherits <- base::inherits
[16:12:34.325]                       invokeRestart <- base::invokeRestart
[16:12:34.325]                       is.null <- base::is.null
[16:12:34.325]                       muffled <- FALSE
[16:12:34.325]                       if (inherits(cond, "message")) {
[16:12:34.325]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:34.325]                         if (muffled) 
[16:12:34.325]                           invokeRestart("muffleMessage")
[16:12:34.325]                       }
[16:12:34.325]                       else if (inherits(cond, "warning")) {
[16:12:34.325]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:34.325]                         if (muffled) 
[16:12:34.325]                           invokeRestart("muffleWarning")
[16:12:34.325]                       }
[16:12:34.325]                       else if (inherits(cond, "condition")) {
[16:12:34.325]                         if (!is.null(pattern)) {
[16:12:34.325]                           computeRestarts <- base::computeRestarts
[16:12:34.325]                           grepl <- base::grepl
[16:12:34.325]                           restarts <- computeRestarts(cond)
[16:12:34.325]                           for (restart in restarts) {
[16:12:34.325]                             name <- restart$name
[16:12:34.325]                             if (is.null(name)) 
[16:12:34.325]                               next
[16:12:34.325]                             if (!grepl(pattern, name)) 
[16:12:34.325]                               next
[16:12:34.325]                             invokeRestart(restart)
[16:12:34.325]                             muffled <- TRUE
[16:12:34.325]                             break
[16:12:34.325]                           }
[16:12:34.325]                         }
[16:12:34.325]                       }
[16:12:34.325]                       invisible(muffled)
[16:12:34.325]                     }
[16:12:34.325]                     muffleCondition(cond, pattern = "^muffle")
[16:12:34.325]                   }
[16:12:34.325]                 }
[16:12:34.325]             }
[16:12:34.325]         }))
[16:12:34.325]     }, error = function(ex) {
[16:12:34.325]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:34.325]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:34.325]                 ...future.rng), started = ...future.startTime, 
[16:12:34.325]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:34.325]             version = "1.8"), class = "FutureResult")
[16:12:34.325]     }, finally = {
[16:12:34.325]         if (!identical(...future.workdir, getwd())) 
[16:12:34.325]             setwd(...future.workdir)
[16:12:34.325]         {
[16:12:34.325]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:34.325]                 ...future.oldOptions$nwarnings <- NULL
[16:12:34.325]             }
[16:12:34.325]             base::options(...future.oldOptions)
[16:12:34.325]             if (.Platform$OS.type == "windows") {
[16:12:34.325]                 old_names <- names(...future.oldEnvVars)
[16:12:34.325]                 envs <- base::Sys.getenv()
[16:12:34.325]                 names <- names(envs)
[16:12:34.325]                 common <- intersect(names, old_names)
[16:12:34.325]                 added <- setdiff(names, old_names)
[16:12:34.325]                 removed <- setdiff(old_names, names)
[16:12:34.325]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:34.325]                   envs[common]]
[16:12:34.325]                 NAMES <- toupper(changed)
[16:12:34.325]                 args <- list()
[16:12:34.325]                 for (kk in seq_along(NAMES)) {
[16:12:34.325]                   name <- changed[[kk]]
[16:12:34.325]                   NAME <- NAMES[[kk]]
[16:12:34.325]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:34.325]                     next
[16:12:34.325]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:34.325]                 }
[16:12:34.325]                 NAMES <- toupper(added)
[16:12:34.325]                 for (kk in seq_along(NAMES)) {
[16:12:34.325]                   name <- added[[kk]]
[16:12:34.325]                   NAME <- NAMES[[kk]]
[16:12:34.325]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:34.325]                     next
[16:12:34.325]                   args[[name]] <- ""
[16:12:34.325]                 }
[16:12:34.325]                 NAMES <- toupper(removed)
[16:12:34.325]                 for (kk in seq_along(NAMES)) {
[16:12:34.325]                   name <- removed[[kk]]
[16:12:34.325]                   NAME <- NAMES[[kk]]
[16:12:34.325]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:34.325]                     next
[16:12:34.325]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:34.325]                 }
[16:12:34.325]                 if (length(args) > 0) 
[16:12:34.325]                   base::do.call(base::Sys.setenv, args = args)
[16:12:34.325]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:34.325]             }
[16:12:34.325]             else {
[16:12:34.325]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:34.325]             }
[16:12:34.325]             {
[16:12:34.325]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:34.325]                   0L) {
[16:12:34.325]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:34.325]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:34.325]                   base::options(opts)
[16:12:34.325]                 }
[16:12:34.325]                 {
[16:12:34.325]                   {
[16:12:34.325]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:34.325]                     NULL
[16:12:34.325]                   }
[16:12:34.325]                   options(future.plan = NULL)
[16:12:34.325]                   if (is.na(NA_character_)) 
[16:12:34.325]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:34.325]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:34.325]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:34.325]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:34.325]                     envir = parent.frame()) 
[16:12:34.325]                   {
[16:12:34.325]                     if (is.function(workers)) 
[16:12:34.325]                       workers <- workers()
[16:12:34.325]                     workers <- structure(as.integer(workers), 
[16:12:34.325]                       class = class(workers))
[16:12:34.325]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:34.325]                       workers >= 1)
[16:12:34.325]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:34.325]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:34.325]                     }
[16:12:34.325]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:34.325]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:34.325]                       envir = envir)
[16:12:34.325]                     if (!future$lazy) 
[16:12:34.325]                       future <- run(future)
[16:12:34.325]                     invisible(future)
[16:12:34.325]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:34.325]                 }
[16:12:34.325]             }
[16:12:34.325]         }
[16:12:34.325]     })
[16:12:34.325]     if (TRUE) {
[16:12:34.325]         base::sink(type = "output", split = FALSE)
[16:12:34.325]         if (TRUE) {
[16:12:34.325]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:34.325]         }
[16:12:34.325]         else {
[16:12:34.325]             ...future.result["stdout"] <- base::list(NULL)
[16:12:34.325]         }
[16:12:34.325]         base::close(...future.stdout)
[16:12:34.325]         ...future.stdout <- NULL
[16:12:34.325]     }
[16:12:34.325]     ...future.result$conditions <- ...future.conditions
[16:12:34.325]     ...future.result$finished <- base::Sys.time()
[16:12:34.325]     ...future.result
[16:12:34.325] }
[16:12:34.328] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[16:12:34.329] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[16:12:34.329] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[16:12:34.329] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[16:12:34.330] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[16:12:34.330] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[16:12:34.330] MultisessionFuture started
[16:12:34.331] - Launch lazy future ... done
[16:12:34.331] run() for ‘MultisessionFuture’ ... done
[16:12:34.331] result() for ClusterFuture ...
[16:12:34.331] receiveMessageFromWorker() for ClusterFuture ...
[16:12:34.331] - Validating connection of MultisessionFuture
[16:12:34.380] - received message: FutureResult
[16:12:34.380] - Received FutureResult
[16:12:34.380] - Erased future from FutureRegistry
[16:12:34.380] result() for ClusterFuture ...
[16:12:34.380] - result already collected: FutureResult
[16:12:34.381] result() for ClusterFuture ... done
[16:12:34.381] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:34.381] result() for ClusterFuture ... done
[16:12:34.381] result() for ClusterFuture ...
[16:12:34.381] - result already collected: FutureResult
[16:12:34.381] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[16:12:34.383] getGlobalsAndPackages() ...
[16:12:34.383] Searching for globals...
[16:12:34.385] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:12:34.385] Searching for globals ... DONE
[16:12:34.386] Resolving globals: FALSE
[16:12:34.386] The total size of the 2 globals is 896 bytes (896 bytes)
[16:12:34.387] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:12:34.387] - globals: [2] ‘weight’, ‘group’
[16:12:34.387] - packages: [1] ‘stats’
[16:12:34.387] getGlobalsAndPackages() ... DONE
[16:12:34.387] run() for ‘Future’ ...
[16:12:34.387] - state: ‘created’
[16:12:34.388] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:34.403] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:34.403] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:34.403]   - Field: ‘node’
[16:12:34.403]   - Field: ‘label’
[16:12:34.403]   - Field: ‘local’
[16:12:34.403]   - Field: ‘owner’
[16:12:34.403]   - Field: ‘envir’
[16:12:34.403]   - Field: ‘workers’
[16:12:34.403]   - Field: ‘packages’
[16:12:34.403]   - Field: ‘gc’
[16:12:34.404]   - Field: ‘conditions’
[16:12:34.404]   - Field: ‘persistent’
[16:12:34.404]   - Field: ‘expr’
[16:12:34.404]   - Field: ‘uuid’
[16:12:34.404]   - Field: ‘seed’
[16:12:34.404]   - Field: ‘version’
[16:12:34.404]   - Field: ‘result’
[16:12:34.404]   - Field: ‘asynchronous’
[16:12:34.405]   - Field: ‘calls’
[16:12:34.405]   - Field: ‘globals’
[16:12:34.405]   - Field: ‘stdout’
[16:12:34.405]   - Field: ‘earlySignal’
[16:12:34.405]   - Field: ‘lazy’
[16:12:34.405]   - Field: ‘state’
[16:12:34.405] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:34.405] - Launch lazy future ...
[16:12:34.406] Packages needed by the future expression (n = 1): ‘stats’
[16:12:34.406] Packages needed by future strategies (n = 0): <none>
[16:12:34.406] {
[16:12:34.406]     {
[16:12:34.406]         {
[16:12:34.406]             ...future.startTime <- base::Sys.time()
[16:12:34.406]             {
[16:12:34.406]                 {
[16:12:34.406]                   {
[16:12:34.406]                     {
[16:12:34.406]                       {
[16:12:34.406]                         base::local({
[16:12:34.406]                           has_future <- base::requireNamespace("future", 
[16:12:34.406]                             quietly = TRUE)
[16:12:34.406]                           if (has_future) {
[16:12:34.406]                             ns <- base::getNamespace("future")
[16:12:34.406]                             version <- ns[[".package"]][["version"]]
[16:12:34.406]                             if (is.null(version)) 
[16:12:34.406]                               version <- utils::packageVersion("future")
[16:12:34.406]                           }
[16:12:34.406]                           else {
[16:12:34.406]                             version <- NULL
[16:12:34.406]                           }
[16:12:34.406]                           if (!has_future || version < "1.8.0") {
[16:12:34.406]                             info <- base::c(r_version = base::gsub("R version ", 
[16:12:34.406]                               "", base::R.version$version.string), 
[16:12:34.406]                               platform = base::sprintf("%s (%s-bit)", 
[16:12:34.406]                                 base::R.version$platform, 8 * 
[16:12:34.406]                                   base::.Machine$sizeof.pointer), 
[16:12:34.406]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:34.406]                                 "release", "version")], collapse = " "), 
[16:12:34.406]                               hostname = base::Sys.info()[["nodename"]])
[16:12:34.406]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:12:34.406]                               info)
[16:12:34.406]                             info <- base::paste(info, collapse = "; ")
[16:12:34.406]                             if (!has_future) {
[16:12:34.406]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:34.406]                                 info)
[16:12:34.406]                             }
[16:12:34.406]                             else {
[16:12:34.406]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:34.406]                                 info, version)
[16:12:34.406]                             }
[16:12:34.406]                             base::stop(msg)
[16:12:34.406]                           }
[16:12:34.406]                         })
[16:12:34.406]                       }
[16:12:34.406]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:34.406]                       base::options(mc.cores = 1L)
[16:12:34.406]                     }
[16:12:34.406]                     base::local({
[16:12:34.406]                       for (pkg in "stats") {
[16:12:34.406]                         base::loadNamespace(pkg)
[16:12:34.406]                         base::library(pkg, character.only = TRUE)
[16:12:34.406]                       }
[16:12:34.406]                     })
[16:12:34.406]                   }
[16:12:34.406]                   options(future.plan = NULL)
[16:12:34.406]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:34.406]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:34.406]                 }
[16:12:34.406]                 ...future.workdir <- getwd()
[16:12:34.406]             }
[16:12:34.406]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:34.406]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:34.406]         }
[16:12:34.406]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:34.406]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:34.406]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:34.406]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:34.406]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:34.406]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:34.406]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:34.406]             base::names(...future.oldOptions))
[16:12:34.406]     }
[16:12:34.406]     if (FALSE) {
[16:12:34.406]     }
[16:12:34.406]     else {
[16:12:34.406]         if (TRUE) {
[16:12:34.406]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:34.406]                 open = "w")
[16:12:34.406]         }
[16:12:34.406]         else {
[16:12:34.406]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:34.406]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:34.406]         }
[16:12:34.406]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:34.406]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:34.406]             base::sink(type = "output", split = FALSE)
[16:12:34.406]             base::close(...future.stdout)
[16:12:34.406]         }, add = TRUE)
[16:12:34.406]     }
[16:12:34.406]     ...future.frame <- base::sys.nframe()
[16:12:34.406]     ...future.conditions <- base::list()
[16:12:34.406]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:34.406]     if (FALSE) {
[16:12:34.406]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:34.406]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:34.406]     }
[16:12:34.406]     ...future.result <- base::tryCatch({
[16:12:34.406]         base::withCallingHandlers({
[16:12:34.406]             ...future.value <- base::withVisible(base::local({
[16:12:34.406]                 ...future.makeSendCondition <- local({
[16:12:34.406]                   sendCondition <- NULL
[16:12:34.406]                   function(frame = 1L) {
[16:12:34.406]                     if (is.function(sendCondition)) 
[16:12:34.406]                       return(sendCondition)
[16:12:34.406]                     ns <- getNamespace("parallel")
[16:12:34.406]                     if (exists("sendData", mode = "function", 
[16:12:34.406]                       envir = ns)) {
[16:12:34.406]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:34.406]                         envir = ns)
[16:12:34.406]                       envir <- sys.frame(frame)
[16:12:34.406]                       master <- NULL
[16:12:34.406]                       while (!identical(envir, .GlobalEnv) && 
[16:12:34.406]                         !identical(envir, emptyenv())) {
[16:12:34.406]                         if (exists("master", mode = "list", envir = envir, 
[16:12:34.406]                           inherits = FALSE)) {
[16:12:34.406]                           master <- get("master", mode = "list", 
[16:12:34.406]                             envir = envir, inherits = FALSE)
[16:12:34.406]                           if (inherits(master, c("SOCKnode", 
[16:12:34.406]                             "SOCK0node"))) {
[16:12:34.406]                             sendCondition <<- function(cond) {
[16:12:34.406]                               data <- list(type = "VALUE", value = cond, 
[16:12:34.406]                                 success = TRUE)
[16:12:34.406]                               parallel_sendData(master, data)
[16:12:34.406]                             }
[16:12:34.406]                             return(sendCondition)
[16:12:34.406]                           }
[16:12:34.406]                         }
[16:12:34.406]                         frame <- frame + 1L
[16:12:34.406]                         envir <- sys.frame(frame)
[16:12:34.406]                       }
[16:12:34.406]                     }
[16:12:34.406]                     sendCondition <<- function(cond) NULL
[16:12:34.406]                   }
[16:12:34.406]                 })
[16:12:34.406]                 withCallingHandlers({
[16:12:34.406]                   {
[16:12:34.406]                     lm(weight ~ group - 1)
[16:12:34.406]                   }
[16:12:34.406]                 }, immediateCondition = function(cond) {
[16:12:34.406]                   sendCondition <- ...future.makeSendCondition()
[16:12:34.406]                   sendCondition(cond)
[16:12:34.406]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:34.406]                   {
[16:12:34.406]                     inherits <- base::inherits
[16:12:34.406]                     invokeRestart <- base::invokeRestart
[16:12:34.406]                     is.null <- base::is.null
[16:12:34.406]                     muffled <- FALSE
[16:12:34.406]                     if (inherits(cond, "message")) {
[16:12:34.406]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:34.406]                       if (muffled) 
[16:12:34.406]                         invokeRestart("muffleMessage")
[16:12:34.406]                     }
[16:12:34.406]                     else if (inherits(cond, "warning")) {
[16:12:34.406]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:34.406]                       if (muffled) 
[16:12:34.406]                         invokeRestart("muffleWarning")
[16:12:34.406]                     }
[16:12:34.406]                     else if (inherits(cond, "condition")) {
[16:12:34.406]                       if (!is.null(pattern)) {
[16:12:34.406]                         computeRestarts <- base::computeRestarts
[16:12:34.406]                         grepl <- base::grepl
[16:12:34.406]                         restarts <- computeRestarts(cond)
[16:12:34.406]                         for (restart in restarts) {
[16:12:34.406]                           name <- restart$name
[16:12:34.406]                           if (is.null(name)) 
[16:12:34.406]                             next
[16:12:34.406]                           if (!grepl(pattern, name)) 
[16:12:34.406]                             next
[16:12:34.406]                           invokeRestart(restart)
[16:12:34.406]                           muffled <- TRUE
[16:12:34.406]                           break
[16:12:34.406]                         }
[16:12:34.406]                       }
[16:12:34.406]                     }
[16:12:34.406]                     invisible(muffled)
[16:12:34.406]                   }
[16:12:34.406]                   muffleCondition(cond)
[16:12:34.406]                 })
[16:12:34.406]             }))
[16:12:34.406]             future::FutureResult(value = ...future.value$value, 
[16:12:34.406]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:34.406]                   ...future.rng), globalenv = if (FALSE) 
[16:12:34.406]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:34.406]                     ...future.globalenv.names))
[16:12:34.406]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:34.406]         }, condition = base::local({
[16:12:34.406]             c <- base::c
[16:12:34.406]             inherits <- base::inherits
[16:12:34.406]             invokeRestart <- base::invokeRestart
[16:12:34.406]             length <- base::length
[16:12:34.406]             list <- base::list
[16:12:34.406]             seq.int <- base::seq.int
[16:12:34.406]             signalCondition <- base::signalCondition
[16:12:34.406]             sys.calls <- base::sys.calls
[16:12:34.406]             `[[` <- base::`[[`
[16:12:34.406]             `+` <- base::`+`
[16:12:34.406]             `<<-` <- base::`<<-`
[16:12:34.406]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:34.406]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:34.406]                   3L)]
[16:12:34.406]             }
[16:12:34.406]             function(cond) {
[16:12:34.406]                 is_error <- inherits(cond, "error")
[16:12:34.406]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:34.406]                   NULL)
[16:12:34.406]                 if (is_error) {
[16:12:34.406]                   sessionInformation <- function() {
[16:12:34.406]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:34.406]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:34.406]                       search = base::search(), system = base::Sys.info())
[16:12:34.406]                   }
[16:12:34.406]                   ...future.conditions[[length(...future.conditions) + 
[16:12:34.406]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:34.406]                     cond$call), session = sessionInformation(), 
[16:12:34.406]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:34.406]                   signalCondition(cond)
[16:12:34.406]                 }
[16:12:34.406]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:34.406]                 "immediateCondition"))) {
[16:12:34.406]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:34.406]                   ...future.conditions[[length(...future.conditions) + 
[16:12:34.406]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:34.406]                   if (TRUE && !signal) {
[16:12:34.406]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:34.406]                     {
[16:12:34.406]                       inherits <- base::inherits
[16:12:34.406]                       invokeRestart <- base::invokeRestart
[16:12:34.406]                       is.null <- base::is.null
[16:12:34.406]                       muffled <- FALSE
[16:12:34.406]                       if (inherits(cond, "message")) {
[16:12:34.406]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:34.406]                         if (muffled) 
[16:12:34.406]                           invokeRestart("muffleMessage")
[16:12:34.406]                       }
[16:12:34.406]                       else if (inherits(cond, "warning")) {
[16:12:34.406]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:34.406]                         if (muffled) 
[16:12:34.406]                           invokeRestart("muffleWarning")
[16:12:34.406]                       }
[16:12:34.406]                       else if (inherits(cond, "condition")) {
[16:12:34.406]                         if (!is.null(pattern)) {
[16:12:34.406]                           computeRestarts <- base::computeRestarts
[16:12:34.406]                           grepl <- base::grepl
[16:12:34.406]                           restarts <- computeRestarts(cond)
[16:12:34.406]                           for (restart in restarts) {
[16:12:34.406]                             name <- restart$name
[16:12:34.406]                             if (is.null(name)) 
[16:12:34.406]                               next
[16:12:34.406]                             if (!grepl(pattern, name)) 
[16:12:34.406]                               next
[16:12:34.406]                             invokeRestart(restart)
[16:12:34.406]                             muffled <- TRUE
[16:12:34.406]                             break
[16:12:34.406]                           }
[16:12:34.406]                         }
[16:12:34.406]                       }
[16:12:34.406]                       invisible(muffled)
[16:12:34.406]                     }
[16:12:34.406]                     muffleCondition(cond, pattern = "^muffle")
[16:12:34.406]                   }
[16:12:34.406]                 }
[16:12:34.406]                 else {
[16:12:34.406]                   if (TRUE) {
[16:12:34.406]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:34.406]                     {
[16:12:34.406]                       inherits <- base::inherits
[16:12:34.406]                       invokeRestart <- base::invokeRestart
[16:12:34.406]                       is.null <- base::is.null
[16:12:34.406]                       muffled <- FALSE
[16:12:34.406]                       if (inherits(cond, "message")) {
[16:12:34.406]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:34.406]                         if (muffled) 
[16:12:34.406]                           invokeRestart("muffleMessage")
[16:12:34.406]                       }
[16:12:34.406]                       else if (inherits(cond, "warning")) {
[16:12:34.406]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:34.406]                         if (muffled) 
[16:12:34.406]                           invokeRestart("muffleWarning")
[16:12:34.406]                       }
[16:12:34.406]                       else if (inherits(cond, "condition")) {
[16:12:34.406]                         if (!is.null(pattern)) {
[16:12:34.406]                           computeRestarts <- base::computeRestarts
[16:12:34.406]                           grepl <- base::grepl
[16:12:34.406]                           restarts <- computeRestarts(cond)
[16:12:34.406]                           for (restart in restarts) {
[16:12:34.406]                             name <- restart$name
[16:12:34.406]                             if (is.null(name)) 
[16:12:34.406]                               next
[16:12:34.406]                             if (!grepl(pattern, name)) 
[16:12:34.406]                               next
[16:12:34.406]                             invokeRestart(restart)
[16:12:34.406]                             muffled <- TRUE
[16:12:34.406]                             break
[16:12:34.406]                           }
[16:12:34.406]                         }
[16:12:34.406]                       }
[16:12:34.406]                       invisible(muffled)
[16:12:34.406]                     }
[16:12:34.406]                     muffleCondition(cond, pattern = "^muffle")
[16:12:34.406]                   }
[16:12:34.406]                 }
[16:12:34.406]             }
[16:12:34.406]         }))
[16:12:34.406]     }, error = function(ex) {
[16:12:34.406]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:34.406]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:34.406]                 ...future.rng), started = ...future.startTime, 
[16:12:34.406]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:34.406]             version = "1.8"), class = "FutureResult")
[16:12:34.406]     }, finally = {
[16:12:34.406]         if (!identical(...future.workdir, getwd())) 
[16:12:34.406]             setwd(...future.workdir)
[16:12:34.406]         {
[16:12:34.406]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:34.406]                 ...future.oldOptions$nwarnings <- NULL
[16:12:34.406]             }
[16:12:34.406]             base::options(...future.oldOptions)
[16:12:34.406]             if (.Platform$OS.type == "windows") {
[16:12:34.406]                 old_names <- names(...future.oldEnvVars)
[16:12:34.406]                 envs <- base::Sys.getenv()
[16:12:34.406]                 names <- names(envs)
[16:12:34.406]                 common <- intersect(names, old_names)
[16:12:34.406]                 added <- setdiff(names, old_names)
[16:12:34.406]                 removed <- setdiff(old_names, names)
[16:12:34.406]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:34.406]                   envs[common]]
[16:12:34.406]                 NAMES <- toupper(changed)
[16:12:34.406]                 args <- list()
[16:12:34.406]                 for (kk in seq_along(NAMES)) {
[16:12:34.406]                   name <- changed[[kk]]
[16:12:34.406]                   NAME <- NAMES[[kk]]
[16:12:34.406]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:34.406]                     next
[16:12:34.406]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:34.406]                 }
[16:12:34.406]                 NAMES <- toupper(added)
[16:12:34.406]                 for (kk in seq_along(NAMES)) {
[16:12:34.406]                   name <- added[[kk]]
[16:12:34.406]                   NAME <- NAMES[[kk]]
[16:12:34.406]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:34.406]                     next
[16:12:34.406]                   args[[name]] <- ""
[16:12:34.406]                 }
[16:12:34.406]                 NAMES <- toupper(removed)
[16:12:34.406]                 for (kk in seq_along(NAMES)) {
[16:12:34.406]                   name <- removed[[kk]]
[16:12:34.406]                   NAME <- NAMES[[kk]]
[16:12:34.406]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:34.406]                     next
[16:12:34.406]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:34.406]                 }
[16:12:34.406]                 if (length(args) > 0) 
[16:12:34.406]                   base::do.call(base::Sys.setenv, args = args)
[16:12:34.406]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:34.406]             }
[16:12:34.406]             else {
[16:12:34.406]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:34.406]             }
[16:12:34.406]             {
[16:12:34.406]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:34.406]                   0L) {
[16:12:34.406]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:34.406]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:34.406]                   base::options(opts)
[16:12:34.406]                 }
[16:12:34.406]                 {
[16:12:34.406]                   {
[16:12:34.406]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:34.406]                     NULL
[16:12:34.406]                   }
[16:12:34.406]                   options(future.plan = NULL)
[16:12:34.406]                   if (is.na(NA_character_)) 
[16:12:34.406]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:34.406]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:34.406]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:34.406]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:34.406]                     envir = parent.frame()) 
[16:12:34.406]                   {
[16:12:34.406]                     if (is.function(workers)) 
[16:12:34.406]                       workers <- workers()
[16:12:34.406]                     workers <- structure(as.integer(workers), 
[16:12:34.406]                       class = class(workers))
[16:12:34.406]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:34.406]                       workers >= 1)
[16:12:34.406]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:34.406]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:34.406]                     }
[16:12:34.406]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:34.406]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:34.406]                       envir = envir)
[16:12:34.406]                     if (!future$lazy) 
[16:12:34.406]                       future <- run(future)
[16:12:34.406]                     invisible(future)
[16:12:34.406]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:34.406]                 }
[16:12:34.406]             }
[16:12:34.406]         }
[16:12:34.406]     })
[16:12:34.406]     if (TRUE) {
[16:12:34.406]         base::sink(type = "output", split = FALSE)
[16:12:34.406]         if (TRUE) {
[16:12:34.406]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:34.406]         }
[16:12:34.406]         else {
[16:12:34.406]             ...future.result["stdout"] <- base::list(NULL)
[16:12:34.406]         }
[16:12:34.406]         base::close(...future.stdout)
[16:12:34.406]         ...future.stdout <- NULL
[16:12:34.406]     }
[16:12:34.406]     ...future.result$conditions <- ...future.conditions
[16:12:34.406]     ...future.result$finished <- base::Sys.time()
[16:12:34.406]     ...future.result
[16:12:34.406] }
[16:12:34.409] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[16:12:34.410] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[16:12:34.410] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[16:12:34.410] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[16:12:34.411] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[16:12:34.411] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[16:12:34.411] MultisessionFuture started
[16:12:34.411] - Launch lazy future ... done
[16:12:34.411] run() for ‘MultisessionFuture’ ... done
[16:12:34.412] result() for ClusterFuture ...
[16:12:34.412] receiveMessageFromWorker() for ClusterFuture ...
[16:12:34.412] - Validating connection of MultisessionFuture
[16:12:34.457] - received message: FutureResult
[16:12:34.458] - Received FutureResult
[16:12:34.458] - Erased future from FutureRegistry
[16:12:34.458] result() for ClusterFuture ...
[16:12:34.458] - result already collected: FutureResult
[16:12:34.458] result() for ClusterFuture ... done
[16:12:34.458] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:34.458] result() for ClusterFuture ... done
[16:12:34.458] result() for ClusterFuture ...
[16:12:34.459] - result already collected: FutureResult
[16:12:34.459] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[16:12:34.461] getGlobalsAndPackages() ...
[16:12:34.461] Searching for globals...
[16:12:34.463] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:12:34.463] Searching for globals ... DONE
[16:12:34.463] Resolving globals: FALSE
[16:12:34.464] The total size of the 2 globals is 896 bytes (896 bytes)
[16:12:34.464] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:12:34.465] - globals: [2] ‘weight’, ‘group’
[16:12:34.465] - packages: [1] ‘stats’
[16:12:34.465] getGlobalsAndPackages() ... DONE
[16:12:34.465] run() for ‘Future’ ...
[16:12:34.465] - state: ‘created’
[16:12:34.465] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:34.481] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:34.481] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:34.481]   - Field: ‘node’
[16:12:34.481]   - Field: ‘label’
[16:12:34.481]   - Field: ‘local’
[16:12:34.481]   - Field: ‘owner’
[16:12:34.481]   - Field: ‘envir’
[16:12:34.481]   - Field: ‘workers’
[16:12:34.481]   - Field: ‘packages’
[16:12:34.482]   - Field: ‘gc’
[16:12:34.482]   - Field: ‘conditions’
[16:12:34.482]   - Field: ‘persistent’
[16:12:34.482]   - Field: ‘expr’
[16:12:34.482]   - Field: ‘uuid’
[16:12:34.482]   - Field: ‘seed’
[16:12:34.482]   - Field: ‘version’
[16:12:34.482]   - Field: ‘result’
[16:12:34.482]   - Field: ‘asynchronous’
[16:12:34.483]   - Field: ‘calls’
[16:12:34.483]   - Field: ‘globals’
[16:12:34.483]   - Field: ‘stdout’
[16:12:34.483]   - Field: ‘earlySignal’
[16:12:34.483]   - Field: ‘lazy’
[16:12:34.483]   - Field: ‘state’
[16:12:34.483] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:34.483] - Launch lazy future ...
[16:12:34.484] Packages needed by the future expression (n = 1): ‘stats’
[16:12:34.484] Packages needed by future strategies (n = 0): <none>
[16:12:34.484] {
[16:12:34.484]     {
[16:12:34.484]         {
[16:12:34.484]             ...future.startTime <- base::Sys.time()
[16:12:34.484]             {
[16:12:34.484]                 {
[16:12:34.484]                   {
[16:12:34.484]                     {
[16:12:34.484]                       {
[16:12:34.484]                         base::local({
[16:12:34.484]                           has_future <- base::requireNamespace("future", 
[16:12:34.484]                             quietly = TRUE)
[16:12:34.484]                           if (has_future) {
[16:12:34.484]                             ns <- base::getNamespace("future")
[16:12:34.484]                             version <- ns[[".package"]][["version"]]
[16:12:34.484]                             if (is.null(version)) 
[16:12:34.484]                               version <- utils::packageVersion("future")
[16:12:34.484]                           }
[16:12:34.484]                           else {
[16:12:34.484]                             version <- NULL
[16:12:34.484]                           }
[16:12:34.484]                           if (!has_future || version < "1.8.0") {
[16:12:34.484]                             info <- base::c(r_version = base::gsub("R version ", 
[16:12:34.484]                               "", base::R.version$version.string), 
[16:12:34.484]                               platform = base::sprintf("%s (%s-bit)", 
[16:12:34.484]                                 base::R.version$platform, 8 * 
[16:12:34.484]                                   base::.Machine$sizeof.pointer), 
[16:12:34.484]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:34.484]                                 "release", "version")], collapse = " "), 
[16:12:34.484]                               hostname = base::Sys.info()[["nodename"]])
[16:12:34.484]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:12:34.484]                               info)
[16:12:34.484]                             info <- base::paste(info, collapse = "; ")
[16:12:34.484]                             if (!has_future) {
[16:12:34.484]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:34.484]                                 info)
[16:12:34.484]                             }
[16:12:34.484]                             else {
[16:12:34.484]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:34.484]                                 info, version)
[16:12:34.484]                             }
[16:12:34.484]                             base::stop(msg)
[16:12:34.484]                           }
[16:12:34.484]                         })
[16:12:34.484]                       }
[16:12:34.484]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:34.484]                       base::options(mc.cores = 1L)
[16:12:34.484]                     }
[16:12:34.484]                     base::local({
[16:12:34.484]                       for (pkg in "stats") {
[16:12:34.484]                         base::loadNamespace(pkg)
[16:12:34.484]                         base::library(pkg, character.only = TRUE)
[16:12:34.484]                       }
[16:12:34.484]                     })
[16:12:34.484]                   }
[16:12:34.484]                   options(future.plan = NULL)
[16:12:34.484]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:34.484]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:34.484]                 }
[16:12:34.484]                 ...future.workdir <- getwd()
[16:12:34.484]             }
[16:12:34.484]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:34.484]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:34.484]         }
[16:12:34.484]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:34.484]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:34.484]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:34.484]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:34.484]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:34.484]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:34.484]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:34.484]             base::names(...future.oldOptions))
[16:12:34.484]     }
[16:12:34.484]     if (FALSE) {
[16:12:34.484]     }
[16:12:34.484]     else {
[16:12:34.484]         if (TRUE) {
[16:12:34.484]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:34.484]                 open = "w")
[16:12:34.484]         }
[16:12:34.484]         else {
[16:12:34.484]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:34.484]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:34.484]         }
[16:12:34.484]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:34.484]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:34.484]             base::sink(type = "output", split = FALSE)
[16:12:34.484]             base::close(...future.stdout)
[16:12:34.484]         }, add = TRUE)
[16:12:34.484]     }
[16:12:34.484]     ...future.frame <- base::sys.nframe()
[16:12:34.484]     ...future.conditions <- base::list()
[16:12:34.484]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:34.484]     if (FALSE) {
[16:12:34.484]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:34.484]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:34.484]     }
[16:12:34.484]     ...future.result <- base::tryCatch({
[16:12:34.484]         base::withCallingHandlers({
[16:12:34.484]             ...future.value <- base::withVisible(base::local({
[16:12:34.484]                 ...future.makeSendCondition <- local({
[16:12:34.484]                   sendCondition <- NULL
[16:12:34.484]                   function(frame = 1L) {
[16:12:34.484]                     if (is.function(sendCondition)) 
[16:12:34.484]                       return(sendCondition)
[16:12:34.484]                     ns <- getNamespace("parallel")
[16:12:34.484]                     if (exists("sendData", mode = "function", 
[16:12:34.484]                       envir = ns)) {
[16:12:34.484]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:34.484]                         envir = ns)
[16:12:34.484]                       envir <- sys.frame(frame)
[16:12:34.484]                       master <- NULL
[16:12:34.484]                       while (!identical(envir, .GlobalEnv) && 
[16:12:34.484]                         !identical(envir, emptyenv())) {
[16:12:34.484]                         if (exists("master", mode = "list", envir = envir, 
[16:12:34.484]                           inherits = FALSE)) {
[16:12:34.484]                           master <- get("master", mode = "list", 
[16:12:34.484]                             envir = envir, inherits = FALSE)
[16:12:34.484]                           if (inherits(master, c("SOCKnode", 
[16:12:34.484]                             "SOCK0node"))) {
[16:12:34.484]                             sendCondition <<- function(cond) {
[16:12:34.484]                               data <- list(type = "VALUE", value = cond, 
[16:12:34.484]                                 success = TRUE)
[16:12:34.484]                               parallel_sendData(master, data)
[16:12:34.484]                             }
[16:12:34.484]                             return(sendCondition)
[16:12:34.484]                           }
[16:12:34.484]                         }
[16:12:34.484]                         frame <- frame + 1L
[16:12:34.484]                         envir <- sys.frame(frame)
[16:12:34.484]                       }
[16:12:34.484]                     }
[16:12:34.484]                     sendCondition <<- function(cond) NULL
[16:12:34.484]                   }
[16:12:34.484]                 })
[16:12:34.484]                 withCallingHandlers({
[16:12:34.484]                   {
[16:12:34.484]                     lm(weight ~ group - 1)
[16:12:34.484]                   }
[16:12:34.484]                 }, immediateCondition = function(cond) {
[16:12:34.484]                   sendCondition <- ...future.makeSendCondition()
[16:12:34.484]                   sendCondition(cond)
[16:12:34.484]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:34.484]                   {
[16:12:34.484]                     inherits <- base::inherits
[16:12:34.484]                     invokeRestart <- base::invokeRestart
[16:12:34.484]                     is.null <- base::is.null
[16:12:34.484]                     muffled <- FALSE
[16:12:34.484]                     if (inherits(cond, "message")) {
[16:12:34.484]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:34.484]                       if (muffled) 
[16:12:34.484]                         invokeRestart("muffleMessage")
[16:12:34.484]                     }
[16:12:34.484]                     else if (inherits(cond, "warning")) {
[16:12:34.484]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:34.484]                       if (muffled) 
[16:12:34.484]                         invokeRestart("muffleWarning")
[16:12:34.484]                     }
[16:12:34.484]                     else if (inherits(cond, "condition")) {
[16:12:34.484]                       if (!is.null(pattern)) {
[16:12:34.484]                         computeRestarts <- base::computeRestarts
[16:12:34.484]                         grepl <- base::grepl
[16:12:34.484]                         restarts <- computeRestarts(cond)
[16:12:34.484]                         for (restart in restarts) {
[16:12:34.484]                           name <- restart$name
[16:12:34.484]                           if (is.null(name)) 
[16:12:34.484]                             next
[16:12:34.484]                           if (!grepl(pattern, name)) 
[16:12:34.484]                             next
[16:12:34.484]                           invokeRestart(restart)
[16:12:34.484]                           muffled <- TRUE
[16:12:34.484]                           break
[16:12:34.484]                         }
[16:12:34.484]                       }
[16:12:34.484]                     }
[16:12:34.484]                     invisible(muffled)
[16:12:34.484]                   }
[16:12:34.484]                   muffleCondition(cond)
[16:12:34.484]                 })
[16:12:34.484]             }))
[16:12:34.484]             future::FutureResult(value = ...future.value$value, 
[16:12:34.484]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:34.484]                   ...future.rng), globalenv = if (FALSE) 
[16:12:34.484]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:34.484]                     ...future.globalenv.names))
[16:12:34.484]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:34.484]         }, condition = base::local({
[16:12:34.484]             c <- base::c
[16:12:34.484]             inherits <- base::inherits
[16:12:34.484]             invokeRestart <- base::invokeRestart
[16:12:34.484]             length <- base::length
[16:12:34.484]             list <- base::list
[16:12:34.484]             seq.int <- base::seq.int
[16:12:34.484]             signalCondition <- base::signalCondition
[16:12:34.484]             sys.calls <- base::sys.calls
[16:12:34.484]             `[[` <- base::`[[`
[16:12:34.484]             `+` <- base::`+`
[16:12:34.484]             `<<-` <- base::`<<-`
[16:12:34.484]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:34.484]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:34.484]                   3L)]
[16:12:34.484]             }
[16:12:34.484]             function(cond) {
[16:12:34.484]                 is_error <- inherits(cond, "error")
[16:12:34.484]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:34.484]                   NULL)
[16:12:34.484]                 if (is_error) {
[16:12:34.484]                   sessionInformation <- function() {
[16:12:34.484]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:34.484]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:34.484]                       search = base::search(), system = base::Sys.info())
[16:12:34.484]                   }
[16:12:34.484]                   ...future.conditions[[length(...future.conditions) + 
[16:12:34.484]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:34.484]                     cond$call), session = sessionInformation(), 
[16:12:34.484]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:34.484]                   signalCondition(cond)
[16:12:34.484]                 }
[16:12:34.484]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:34.484]                 "immediateCondition"))) {
[16:12:34.484]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:34.484]                   ...future.conditions[[length(...future.conditions) + 
[16:12:34.484]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:34.484]                   if (TRUE && !signal) {
[16:12:34.484]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:34.484]                     {
[16:12:34.484]                       inherits <- base::inherits
[16:12:34.484]                       invokeRestart <- base::invokeRestart
[16:12:34.484]                       is.null <- base::is.null
[16:12:34.484]                       muffled <- FALSE
[16:12:34.484]                       if (inherits(cond, "message")) {
[16:12:34.484]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:34.484]                         if (muffled) 
[16:12:34.484]                           invokeRestart("muffleMessage")
[16:12:34.484]                       }
[16:12:34.484]                       else if (inherits(cond, "warning")) {
[16:12:34.484]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:34.484]                         if (muffled) 
[16:12:34.484]                           invokeRestart("muffleWarning")
[16:12:34.484]                       }
[16:12:34.484]                       else if (inherits(cond, "condition")) {
[16:12:34.484]                         if (!is.null(pattern)) {
[16:12:34.484]                           computeRestarts <- base::computeRestarts
[16:12:34.484]                           grepl <- base::grepl
[16:12:34.484]                           restarts <- computeRestarts(cond)
[16:12:34.484]                           for (restart in restarts) {
[16:12:34.484]                             name <- restart$name
[16:12:34.484]                             if (is.null(name)) 
[16:12:34.484]                               next
[16:12:34.484]                             if (!grepl(pattern, name)) 
[16:12:34.484]                               next
[16:12:34.484]                             invokeRestart(restart)
[16:12:34.484]                             muffled <- TRUE
[16:12:34.484]                             break
[16:12:34.484]                           }
[16:12:34.484]                         }
[16:12:34.484]                       }
[16:12:34.484]                       invisible(muffled)
[16:12:34.484]                     }
[16:12:34.484]                     muffleCondition(cond, pattern = "^muffle")
[16:12:34.484]                   }
[16:12:34.484]                 }
[16:12:34.484]                 else {
[16:12:34.484]                   if (TRUE) {
[16:12:34.484]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:34.484]                     {
[16:12:34.484]                       inherits <- base::inherits
[16:12:34.484]                       invokeRestart <- base::invokeRestart
[16:12:34.484]                       is.null <- base::is.null
[16:12:34.484]                       muffled <- FALSE
[16:12:34.484]                       if (inherits(cond, "message")) {
[16:12:34.484]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:34.484]                         if (muffled) 
[16:12:34.484]                           invokeRestart("muffleMessage")
[16:12:34.484]                       }
[16:12:34.484]                       else if (inherits(cond, "warning")) {
[16:12:34.484]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:34.484]                         if (muffled) 
[16:12:34.484]                           invokeRestart("muffleWarning")
[16:12:34.484]                       }
[16:12:34.484]                       else if (inherits(cond, "condition")) {
[16:12:34.484]                         if (!is.null(pattern)) {
[16:12:34.484]                           computeRestarts <- base::computeRestarts
[16:12:34.484]                           grepl <- base::grepl
[16:12:34.484]                           restarts <- computeRestarts(cond)
[16:12:34.484]                           for (restart in restarts) {
[16:12:34.484]                             name <- restart$name
[16:12:34.484]                             if (is.null(name)) 
[16:12:34.484]                               next
[16:12:34.484]                             if (!grepl(pattern, name)) 
[16:12:34.484]                               next
[16:12:34.484]                             invokeRestart(restart)
[16:12:34.484]                             muffled <- TRUE
[16:12:34.484]                             break
[16:12:34.484]                           }
[16:12:34.484]                         }
[16:12:34.484]                       }
[16:12:34.484]                       invisible(muffled)
[16:12:34.484]                     }
[16:12:34.484]                     muffleCondition(cond, pattern = "^muffle")
[16:12:34.484]                   }
[16:12:34.484]                 }
[16:12:34.484]             }
[16:12:34.484]         }))
[16:12:34.484]     }, error = function(ex) {
[16:12:34.484]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:34.484]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:34.484]                 ...future.rng), started = ...future.startTime, 
[16:12:34.484]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:34.484]             version = "1.8"), class = "FutureResult")
[16:12:34.484]     }, finally = {
[16:12:34.484]         if (!identical(...future.workdir, getwd())) 
[16:12:34.484]             setwd(...future.workdir)
[16:12:34.484]         {
[16:12:34.484]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:34.484]                 ...future.oldOptions$nwarnings <- NULL
[16:12:34.484]             }
[16:12:34.484]             base::options(...future.oldOptions)
[16:12:34.484]             if (.Platform$OS.type == "windows") {
[16:12:34.484]                 old_names <- names(...future.oldEnvVars)
[16:12:34.484]                 envs <- base::Sys.getenv()
[16:12:34.484]                 names <- names(envs)
[16:12:34.484]                 common <- intersect(names, old_names)
[16:12:34.484]                 added <- setdiff(names, old_names)
[16:12:34.484]                 removed <- setdiff(old_names, names)
[16:12:34.484]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:34.484]                   envs[common]]
[16:12:34.484]                 NAMES <- toupper(changed)
[16:12:34.484]                 args <- list()
[16:12:34.484]                 for (kk in seq_along(NAMES)) {
[16:12:34.484]                   name <- changed[[kk]]
[16:12:34.484]                   NAME <- NAMES[[kk]]
[16:12:34.484]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:34.484]                     next
[16:12:34.484]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:34.484]                 }
[16:12:34.484]                 NAMES <- toupper(added)
[16:12:34.484]                 for (kk in seq_along(NAMES)) {
[16:12:34.484]                   name <- added[[kk]]
[16:12:34.484]                   NAME <- NAMES[[kk]]
[16:12:34.484]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:34.484]                     next
[16:12:34.484]                   args[[name]] <- ""
[16:12:34.484]                 }
[16:12:34.484]                 NAMES <- toupper(removed)
[16:12:34.484]                 for (kk in seq_along(NAMES)) {
[16:12:34.484]                   name <- removed[[kk]]
[16:12:34.484]                   NAME <- NAMES[[kk]]
[16:12:34.484]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:34.484]                     next
[16:12:34.484]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:34.484]                 }
[16:12:34.484]                 if (length(args) > 0) 
[16:12:34.484]                   base::do.call(base::Sys.setenv, args = args)
[16:12:34.484]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:34.484]             }
[16:12:34.484]             else {
[16:12:34.484]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:34.484]             }
[16:12:34.484]             {
[16:12:34.484]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:34.484]                   0L) {
[16:12:34.484]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:34.484]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:34.484]                   base::options(opts)
[16:12:34.484]                 }
[16:12:34.484]                 {
[16:12:34.484]                   {
[16:12:34.484]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:34.484]                     NULL
[16:12:34.484]                   }
[16:12:34.484]                   options(future.plan = NULL)
[16:12:34.484]                   if (is.na(NA_character_)) 
[16:12:34.484]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:34.484]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:34.484]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:34.484]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:34.484]                     envir = parent.frame()) 
[16:12:34.484]                   {
[16:12:34.484]                     if (is.function(workers)) 
[16:12:34.484]                       workers <- workers()
[16:12:34.484]                     workers <- structure(as.integer(workers), 
[16:12:34.484]                       class = class(workers))
[16:12:34.484]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:34.484]                       workers >= 1)
[16:12:34.484]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:34.484]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:34.484]                     }
[16:12:34.484]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:34.484]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:34.484]                       envir = envir)
[16:12:34.484]                     if (!future$lazy) 
[16:12:34.484]                       future <- run(future)
[16:12:34.484]                     invisible(future)
[16:12:34.484]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:34.484]                 }
[16:12:34.484]             }
[16:12:34.484]         }
[16:12:34.484]     })
[16:12:34.484]     if (TRUE) {
[16:12:34.484]         base::sink(type = "output", split = FALSE)
[16:12:34.484]         if (TRUE) {
[16:12:34.484]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:34.484]         }
[16:12:34.484]         else {
[16:12:34.484]             ...future.result["stdout"] <- base::list(NULL)
[16:12:34.484]         }
[16:12:34.484]         base::close(...future.stdout)
[16:12:34.484]         ...future.stdout <- NULL
[16:12:34.484]     }
[16:12:34.484]     ...future.result$conditions <- ...future.conditions
[16:12:34.484]     ...future.result$finished <- base::Sys.time()
[16:12:34.484]     ...future.result
[16:12:34.484] }
[16:12:34.488] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[16:12:34.488] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[16:12:34.488] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[16:12:34.488] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[16:12:34.491] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[16:12:34.491] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[16:12:34.492] MultisessionFuture started
[16:12:34.492] - Launch lazy future ... done
[16:12:34.492] run() for ‘MultisessionFuture’ ... done
[16:12:34.492] result() for ClusterFuture ...
[16:12:34.492] receiveMessageFromWorker() for ClusterFuture ...
[16:12:34.492] - Validating connection of MultisessionFuture
[16:12:34.541] - received message: FutureResult
[16:12:34.541] - Received FutureResult
[16:12:34.542] - Erased future from FutureRegistry
[16:12:34.542] result() for ClusterFuture ...
[16:12:34.542] - result already collected: FutureResult
[16:12:34.542] result() for ClusterFuture ... done
[16:12:34.542] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:34.542] result() for ClusterFuture ... done
[16:12:34.542] result() for ClusterFuture ...
[16:12:34.542] - result already collected: FutureResult
[16:12:34.543] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[16:12:34.544] getGlobalsAndPackages() ...
[16:12:34.544] Searching for globals...
[16:12:34.546] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:12:34.546] Searching for globals ... DONE
[16:12:34.546] Resolving globals: FALSE
[16:12:34.547] The total size of the 2 globals is 896 bytes (896 bytes)
[16:12:34.547] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:12:34.547] - globals: [2] ‘weight’, ‘group’
[16:12:34.547] - packages: [1] ‘stats’
[16:12:34.547] getGlobalsAndPackages() ... DONE
[16:12:34.548] run() for ‘Future’ ...
[16:12:34.548] - state: ‘created’
[16:12:34.548] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:34.562] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:34.562] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:34.562]   - Field: ‘node’
[16:12:34.562]   - Field: ‘label’
[16:12:34.562]   - Field: ‘local’
[16:12:34.562]   - Field: ‘owner’
[16:12:34.562]   - Field: ‘envir’
[16:12:34.562]   - Field: ‘workers’
[16:12:34.562]   - Field: ‘packages’
[16:12:34.563]   - Field: ‘gc’
[16:12:34.563]   - Field: ‘conditions’
[16:12:34.563]   - Field: ‘persistent’
[16:12:34.563]   - Field: ‘expr’
[16:12:34.563]   - Field: ‘uuid’
[16:12:34.563]   - Field: ‘seed’
[16:12:34.563]   - Field: ‘version’
[16:12:34.563]   - Field: ‘result’
[16:12:34.563]   - Field: ‘asynchronous’
[16:12:34.563]   - Field: ‘calls’
[16:12:34.563]   - Field: ‘globals’
[16:12:34.564]   - Field: ‘stdout’
[16:12:34.564]   - Field: ‘earlySignal’
[16:12:34.564]   - Field: ‘lazy’
[16:12:34.564]   - Field: ‘state’
[16:12:34.564] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:34.564] - Launch lazy future ...
[16:12:34.564] Packages needed by the future expression (n = 1): ‘stats’
[16:12:34.564] Packages needed by future strategies (n = 0): <none>
[16:12:34.565] {
[16:12:34.565]     {
[16:12:34.565]         {
[16:12:34.565]             ...future.startTime <- base::Sys.time()
[16:12:34.565]             {
[16:12:34.565]                 {
[16:12:34.565]                   {
[16:12:34.565]                     {
[16:12:34.565]                       {
[16:12:34.565]                         base::local({
[16:12:34.565]                           has_future <- base::requireNamespace("future", 
[16:12:34.565]                             quietly = TRUE)
[16:12:34.565]                           if (has_future) {
[16:12:34.565]                             ns <- base::getNamespace("future")
[16:12:34.565]                             version <- ns[[".package"]][["version"]]
[16:12:34.565]                             if (is.null(version)) 
[16:12:34.565]                               version <- utils::packageVersion("future")
[16:12:34.565]                           }
[16:12:34.565]                           else {
[16:12:34.565]                             version <- NULL
[16:12:34.565]                           }
[16:12:34.565]                           if (!has_future || version < "1.8.0") {
[16:12:34.565]                             info <- base::c(r_version = base::gsub("R version ", 
[16:12:34.565]                               "", base::R.version$version.string), 
[16:12:34.565]                               platform = base::sprintf("%s (%s-bit)", 
[16:12:34.565]                                 base::R.version$platform, 8 * 
[16:12:34.565]                                   base::.Machine$sizeof.pointer), 
[16:12:34.565]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:34.565]                                 "release", "version")], collapse = " "), 
[16:12:34.565]                               hostname = base::Sys.info()[["nodename"]])
[16:12:34.565]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:12:34.565]                               info)
[16:12:34.565]                             info <- base::paste(info, collapse = "; ")
[16:12:34.565]                             if (!has_future) {
[16:12:34.565]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:34.565]                                 info)
[16:12:34.565]                             }
[16:12:34.565]                             else {
[16:12:34.565]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:34.565]                                 info, version)
[16:12:34.565]                             }
[16:12:34.565]                             base::stop(msg)
[16:12:34.565]                           }
[16:12:34.565]                         })
[16:12:34.565]                       }
[16:12:34.565]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:34.565]                       base::options(mc.cores = 1L)
[16:12:34.565]                     }
[16:12:34.565]                     base::local({
[16:12:34.565]                       for (pkg in "stats") {
[16:12:34.565]                         base::loadNamespace(pkg)
[16:12:34.565]                         base::library(pkg, character.only = TRUE)
[16:12:34.565]                       }
[16:12:34.565]                     })
[16:12:34.565]                   }
[16:12:34.565]                   options(future.plan = NULL)
[16:12:34.565]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:34.565]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:34.565]                 }
[16:12:34.565]                 ...future.workdir <- getwd()
[16:12:34.565]             }
[16:12:34.565]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:34.565]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:34.565]         }
[16:12:34.565]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:34.565]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:34.565]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:34.565]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:34.565]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:34.565]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:34.565]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:34.565]             base::names(...future.oldOptions))
[16:12:34.565]     }
[16:12:34.565]     if (FALSE) {
[16:12:34.565]     }
[16:12:34.565]     else {
[16:12:34.565]         if (TRUE) {
[16:12:34.565]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:34.565]                 open = "w")
[16:12:34.565]         }
[16:12:34.565]         else {
[16:12:34.565]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:34.565]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:34.565]         }
[16:12:34.565]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:34.565]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:34.565]             base::sink(type = "output", split = FALSE)
[16:12:34.565]             base::close(...future.stdout)
[16:12:34.565]         }, add = TRUE)
[16:12:34.565]     }
[16:12:34.565]     ...future.frame <- base::sys.nframe()
[16:12:34.565]     ...future.conditions <- base::list()
[16:12:34.565]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:34.565]     if (FALSE) {
[16:12:34.565]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:34.565]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:34.565]     }
[16:12:34.565]     ...future.result <- base::tryCatch({
[16:12:34.565]         base::withCallingHandlers({
[16:12:34.565]             ...future.value <- base::withVisible(base::local({
[16:12:34.565]                 ...future.makeSendCondition <- local({
[16:12:34.565]                   sendCondition <- NULL
[16:12:34.565]                   function(frame = 1L) {
[16:12:34.565]                     if (is.function(sendCondition)) 
[16:12:34.565]                       return(sendCondition)
[16:12:34.565]                     ns <- getNamespace("parallel")
[16:12:34.565]                     if (exists("sendData", mode = "function", 
[16:12:34.565]                       envir = ns)) {
[16:12:34.565]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:34.565]                         envir = ns)
[16:12:34.565]                       envir <- sys.frame(frame)
[16:12:34.565]                       master <- NULL
[16:12:34.565]                       while (!identical(envir, .GlobalEnv) && 
[16:12:34.565]                         !identical(envir, emptyenv())) {
[16:12:34.565]                         if (exists("master", mode = "list", envir = envir, 
[16:12:34.565]                           inherits = FALSE)) {
[16:12:34.565]                           master <- get("master", mode = "list", 
[16:12:34.565]                             envir = envir, inherits = FALSE)
[16:12:34.565]                           if (inherits(master, c("SOCKnode", 
[16:12:34.565]                             "SOCK0node"))) {
[16:12:34.565]                             sendCondition <<- function(cond) {
[16:12:34.565]                               data <- list(type = "VALUE", value = cond, 
[16:12:34.565]                                 success = TRUE)
[16:12:34.565]                               parallel_sendData(master, data)
[16:12:34.565]                             }
[16:12:34.565]                             return(sendCondition)
[16:12:34.565]                           }
[16:12:34.565]                         }
[16:12:34.565]                         frame <- frame + 1L
[16:12:34.565]                         envir <- sys.frame(frame)
[16:12:34.565]                       }
[16:12:34.565]                     }
[16:12:34.565]                     sendCondition <<- function(cond) NULL
[16:12:34.565]                   }
[16:12:34.565]                 })
[16:12:34.565]                 withCallingHandlers({
[16:12:34.565]                   {
[16:12:34.565]                     lm(weight ~ group - 1)
[16:12:34.565]                   }
[16:12:34.565]                 }, immediateCondition = function(cond) {
[16:12:34.565]                   sendCondition <- ...future.makeSendCondition()
[16:12:34.565]                   sendCondition(cond)
[16:12:34.565]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:34.565]                   {
[16:12:34.565]                     inherits <- base::inherits
[16:12:34.565]                     invokeRestart <- base::invokeRestart
[16:12:34.565]                     is.null <- base::is.null
[16:12:34.565]                     muffled <- FALSE
[16:12:34.565]                     if (inherits(cond, "message")) {
[16:12:34.565]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:34.565]                       if (muffled) 
[16:12:34.565]                         invokeRestart("muffleMessage")
[16:12:34.565]                     }
[16:12:34.565]                     else if (inherits(cond, "warning")) {
[16:12:34.565]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:34.565]                       if (muffled) 
[16:12:34.565]                         invokeRestart("muffleWarning")
[16:12:34.565]                     }
[16:12:34.565]                     else if (inherits(cond, "condition")) {
[16:12:34.565]                       if (!is.null(pattern)) {
[16:12:34.565]                         computeRestarts <- base::computeRestarts
[16:12:34.565]                         grepl <- base::grepl
[16:12:34.565]                         restarts <- computeRestarts(cond)
[16:12:34.565]                         for (restart in restarts) {
[16:12:34.565]                           name <- restart$name
[16:12:34.565]                           if (is.null(name)) 
[16:12:34.565]                             next
[16:12:34.565]                           if (!grepl(pattern, name)) 
[16:12:34.565]                             next
[16:12:34.565]                           invokeRestart(restart)
[16:12:34.565]                           muffled <- TRUE
[16:12:34.565]                           break
[16:12:34.565]                         }
[16:12:34.565]                       }
[16:12:34.565]                     }
[16:12:34.565]                     invisible(muffled)
[16:12:34.565]                   }
[16:12:34.565]                   muffleCondition(cond)
[16:12:34.565]                 })
[16:12:34.565]             }))
[16:12:34.565]             future::FutureResult(value = ...future.value$value, 
[16:12:34.565]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:34.565]                   ...future.rng), globalenv = if (FALSE) 
[16:12:34.565]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:34.565]                     ...future.globalenv.names))
[16:12:34.565]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:34.565]         }, condition = base::local({
[16:12:34.565]             c <- base::c
[16:12:34.565]             inherits <- base::inherits
[16:12:34.565]             invokeRestart <- base::invokeRestart
[16:12:34.565]             length <- base::length
[16:12:34.565]             list <- base::list
[16:12:34.565]             seq.int <- base::seq.int
[16:12:34.565]             signalCondition <- base::signalCondition
[16:12:34.565]             sys.calls <- base::sys.calls
[16:12:34.565]             `[[` <- base::`[[`
[16:12:34.565]             `+` <- base::`+`
[16:12:34.565]             `<<-` <- base::`<<-`
[16:12:34.565]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:34.565]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:34.565]                   3L)]
[16:12:34.565]             }
[16:12:34.565]             function(cond) {
[16:12:34.565]                 is_error <- inherits(cond, "error")
[16:12:34.565]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:34.565]                   NULL)
[16:12:34.565]                 if (is_error) {
[16:12:34.565]                   sessionInformation <- function() {
[16:12:34.565]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:34.565]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:34.565]                       search = base::search(), system = base::Sys.info())
[16:12:34.565]                   }
[16:12:34.565]                   ...future.conditions[[length(...future.conditions) + 
[16:12:34.565]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:34.565]                     cond$call), session = sessionInformation(), 
[16:12:34.565]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:34.565]                   signalCondition(cond)
[16:12:34.565]                 }
[16:12:34.565]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:34.565]                 "immediateCondition"))) {
[16:12:34.565]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:34.565]                   ...future.conditions[[length(...future.conditions) + 
[16:12:34.565]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:34.565]                   if (TRUE && !signal) {
[16:12:34.565]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:34.565]                     {
[16:12:34.565]                       inherits <- base::inherits
[16:12:34.565]                       invokeRestart <- base::invokeRestart
[16:12:34.565]                       is.null <- base::is.null
[16:12:34.565]                       muffled <- FALSE
[16:12:34.565]                       if (inherits(cond, "message")) {
[16:12:34.565]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:34.565]                         if (muffled) 
[16:12:34.565]                           invokeRestart("muffleMessage")
[16:12:34.565]                       }
[16:12:34.565]                       else if (inherits(cond, "warning")) {
[16:12:34.565]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:34.565]                         if (muffled) 
[16:12:34.565]                           invokeRestart("muffleWarning")
[16:12:34.565]                       }
[16:12:34.565]                       else if (inherits(cond, "condition")) {
[16:12:34.565]                         if (!is.null(pattern)) {
[16:12:34.565]                           computeRestarts <- base::computeRestarts
[16:12:34.565]                           grepl <- base::grepl
[16:12:34.565]                           restarts <- computeRestarts(cond)
[16:12:34.565]                           for (restart in restarts) {
[16:12:34.565]                             name <- restart$name
[16:12:34.565]                             if (is.null(name)) 
[16:12:34.565]                               next
[16:12:34.565]                             if (!grepl(pattern, name)) 
[16:12:34.565]                               next
[16:12:34.565]                             invokeRestart(restart)
[16:12:34.565]                             muffled <- TRUE
[16:12:34.565]                             break
[16:12:34.565]                           }
[16:12:34.565]                         }
[16:12:34.565]                       }
[16:12:34.565]                       invisible(muffled)
[16:12:34.565]                     }
[16:12:34.565]                     muffleCondition(cond, pattern = "^muffle")
[16:12:34.565]                   }
[16:12:34.565]                 }
[16:12:34.565]                 else {
[16:12:34.565]                   if (TRUE) {
[16:12:34.565]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:34.565]                     {
[16:12:34.565]                       inherits <- base::inherits
[16:12:34.565]                       invokeRestart <- base::invokeRestart
[16:12:34.565]                       is.null <- base::is.null
[16:12:34.565]                       muffled <- FALSE
[16:12:34.565]                       if (inherits(cond, "message")) {
[16:12:34.565]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:34.565]                         if (muffled) 
[16:12:34.565]                           invokeRestart("muffleMessage")
[16:12:34.565]                       }
[16:12:34.565]                       else if (inherits(cond, "warning")) {
[16:12:34.565]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:34.565]                         if (muffled) 
[16:12:34.565]                           invokeRestart("muffleWarning")
[16:12:34.565]                       }
[16:12:34.565]                       else if (inherits(cond, "condition")) {
[16:12:34.565]                         if (!is.null(pattern)) {
[16:12:34.565]                           computeRestarts <- base::computeRestarts
[16:12:34.565]                           grepl <- base::grepl
[16:12:34.565]                           restarts <- computeRestarts(cond)
[16:12:34.565]                           for (restart in restarts) {
[16:12:34.565]                             name <- restart$name
[16:12:34.565]                             if (is.null(name)) 
[16:12:34.565]                               next
[16:12:34.565]                             if (!grepl(pattern, name)) 
[16:12:34.565]                               next
[16:12:34.565]                             invokeRestart(restart)
[16:12:34.565]                             muffled <- TRUE
[16:12:34.565]                             break
[16:12:34.565]                           }
[16:12:34.565]                         }
[16:12:34.565]                       }
[16:12:34.565]                       invisible(muffled)
[16:12:34.565]                     }
[16:12:34.565]                     muffleCondition(cond, pattern = "^muffle")
[16:12:34.565]                   }
[16:12:34.565]                 }
[16:12:34.565]             }
[16:12:34.565]         }))
[16:12:34.565]     }, error = function(ex) {
[16:12:34.565]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:34.565]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:34.565]                 ...future.rng), started = ...future.startTime, 
[16:12:34.565]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:34.565]             version = "1.8"), class = "FutureResult")
[16:12:34.565]     }, finally = {
[16:12:34.565]         if (!identical(...future.workdir, getwd())) 
[16:12:34.565]             setwd(...future.workdir)
[16:12:34.565]         {
[16:12:34.565]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:34.565]                 ...future.oldOptions$nwarnings <- NULL
[16:12:34.565]             }
[16:12:34.565]             base::options(...future.oldOptions)
[16:12:34.565]             if (.Platform$OS.type == "windows") {
[16:12:34.565]                 old_names <- names(...future.oldEnvVars)
[16:12:34.565]                 envs <- base::Sys.getenv()
[16:12:34.565]                 names <- names(envs)
[16:12:34.565]                 common <- intersect(names, old_names)
[16:12:34.565]                 added <- setdiff(names, old_names)
[16:12:34.565]                 removed <- setdiff(old_names, names)
[16:12:34.565]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:34.565]                   envs[common]]
[16:12:34.565]                 NAMES <- toupper(changed)
[16:12:34.565]                 args <- list()
[16:12:34.565]                 for (kk in seq_along(NAMES)) {
[16:12:34.565]                   name <- changed[[kk]]
[16:12:34.565]                   NAME <- NAMES[[kk]]
[16:12:34.565]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:34.565]                     next
[16:12:34.565]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:34.565]                 }
[16:12:34.565]                 NAMES <- toupper(added)
[16:12:34.565]                 for (kk in seq_along(NAMES)) {
[16:12:34.565]                   name <- added[[kk]]
[16:12:34.565]                   NAME <- NAMES[[kk]]
[16:12:34.565]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:34.565]                     next
[16:12:34.565]                   args[[name]] <- ""
[16:12:34.565]                 }
[16:12:34.565]                 NAMES <- toupper(removed)
[16:12:34.565]                 for (kk in seq_along(NAMES)) {
[16:12:34.565]                   name <- removed[[kk]]
[16:12:34.565]                   NAME <- NAMES[[kk]]
[16:12:34.565]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:34.565]                     next
[16:12:34.565]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:34.565]                 }
[16:12:34.565]                 if (length(args) > 0) 
[16:12:34.565]                   base::do.call(base::Sys.setenv, args = args)
[16:12:34.565]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:34.565]             }
[16:12:34.565]             else {
[16:12:34.565]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:34.565]             }
[16:12:34.565]             {
[16:12:34.565]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:34.565]                   0L) {
[16:12:34.565]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:34.565]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:34.565]                   base::options(opts)
[16:12:34.565]                 }
[16:12:34.565]                 {
[16:12:34.565]                   {
[16:12:34.565]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:34.565]                     NULL
[16:12:34.565]                   }
[16:12:34.565]                   options(future.plan = NULL)
[16:12:34.565]                   if (is.na(NA_character_)) 
[16:12:34.565]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:34.565]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:34.565]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:34.565]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:34.565]                     envir = parent.frame()) 
[16:12:34.565]                   {
[16:12:34.565]                     if (is.function(workers)) 
[16:12:34.565]                       workers <- workers()
[16:12:34.565]                     workers <- structure(as.integer(workers), 
[16:12:34.565]                       class = class(workers))
[16:12:34.565]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:34.565]                       workers >= 1)
[16:12:34.565]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:34.565]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:34.565]                     }
[16:12:34.565]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:34.565]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:34.565]                       envir = envir)
[16:12:34.565]                     if (!future$lazy) 
[16:12:34.565]                       future <- run(future)
[16:12:34.565]                     invisible(future)
[16:12:34.565]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:34.565]                 }
[16:12:34.565]             }
[16:12:34.565]         }
[16:12:34.565]     })
[16:12:34.565]     if (TRUE) {
[16:12:34.565]         base::sink(type = "output", split = FALSE)
[16:12:34.565]         if (TRUE) {
[16:12:34.565]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:34.565]         }
[16:12:34.565]         else {
[16:12:34.565]             ...future.result["stdout"] <- base::list(NULL)
[16:12:34.565]         }
[16:12:34.565]         base::close(...future.stdout)
[16:12:34.565]         ...future.stdout <- NULL
[16:12:34.565]     }
[16:12:34.565]     ...future.result$conditions <- ...future.conditions
[16:12:34.565]     ...future.result$finished <- base::Sys.time()
[16:12:34.565]     ...future.result
[16:12:34.565] }
[16:12:34.567] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[16:12:34.568] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[16:12:34.568] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[16:12:34.568] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[16:12:34.568] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[16:12:34.569] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[16:12:34.569] MultisessionFuture started
[16:12:34.569] - Launch lazy future ... done
[16:12:34.569] run() for ‘MultisessionFuture’ ... done
[16:12:34.569] result() for ClusterFuture ...
[16:12:34.569] receiveMessageFromWorker() for ClusterFuture ...
[16:12:34.570] - Validating connection of MultisessionFuture
[16:12:34.617] - received message: FutureResult
[16:12:34.617] - Received FutureResult
[16:12:34.617] - Erased future from FutureRegistry
[16:12:34.617] result() for ClusterFuture ...
[16:12:34.618] - result already collected: FutureResult
[16:12:34.618] result() for ClusterFuture ... done
[16:12:34.618] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:34.618] result() for ClusterFuture ... done
[16:12:34.618] result() for ClusterFuture ...
[16:12:34.618] - result already collected: FutureResult
[16:12:34.618] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[16:12:34.620] getGlobalsAndPackages() ...
[16:12:34.620] Searching for globals...
[16:12:34.621] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:12:34.621] Searching for globals ... DONE
[16:12:34.622] Resolving globals: FALSE
[16:12:34.622] The total size of the 2 globals is 896 bytes (896 bytes)
[16:12:34.622] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:12:34.623] - globals: [2] ‘weight’, ‘group’
[16:12:34.623] - packages: [1] ‘stats’
[16:12:34.623] getGlobalsAndPackages() ... DONE
[16:12:34.623] run() for ‘Future’ ...
[16:12:34.623] - state: ‘created’
[16:12:34.623] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:34.639] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:34.639] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:34.639]   - Field: ‘node’
[16:12:34.639]   - Field: ‘label’
[16:12:34.639]   - Field: ‘local’
[16:12:34.639]   - Field: ‘owner’
[16:12:34.639]   - Field: ‘envir’
[16:12:34.639]   - Field: ‘workers’
[16:12:34.639]   - Field: ‘packages’
[16:12:34.640]   - Field: ‘gc’
[16:12:34.640]   - Field: ‘conditions’
[16:12:34.640]   - Field: ‘persistent’
[16:12:34.640]   - Field: ‘expr’
[16:12:34.640]   - Field: ‘uuid’
[16:12:34.640]   - Field: ‘seed’
[16:12:34.640]   - Field: ‘version’
[16:12:34.640]   - Field: ‘result’
[16:12:34.640]   - Field: ‘asynchronous’
[16:12:34.640]   - Field: ‘calls’
[16:12:34.641]   - Field: ‘globals’
[16:12:34.641]   - Field: ‘stdout’
[16:12:34.641]   - Field: ‘earlySignal’
[16:12:34.641]   - Field: ‘lazy’
[16:12:34.641]   - Field: ‘state’
[16:12:34.641] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:34.641] - Launch lazy future ...
[16:12:34.641] Packages needed by the future expression (n = 1): ‘stats’
[16:12:34.641] Packages needed by future strategies (n = 0): <none>
[16:12:34.642] {
[16:12:34.642]     {
[16:12:34.642]         {
[16:12:34.642]             ...future.startTime <- base::Sys.time()
[16:12:34.642]             {
[16:12:34.642]                 {
[16:12:34.642]                   {
[16:12:34.642]                     {
[16:12:34.642]                       {
[16:12:34.642]                         base::local({
[16:12:34.642]                           has_future <- base::requireNamespace("future", 
[16:12:34.642]                             quietly = TRUE)
[16:12:34.642]                           if (has_future) {
[16:12:34.642]                             ns <- base::getNamespace("future")
[16:12:34.642]                             version <- ns[[".package"]][["version"]]
[16:12:34.642]                             if (is.null(version)) 
[16:12:34.642]                               version <- utils::packageVersion("future")
[16:12:34.642]                           }
[16:12:34.642]                           else {
[16:12:34.642]                             version <- NULL
[16:12:34.642]                           }
[16:12:34.642]                           if (!has_future || version < "1.8.0") {
[16:12:34.642]                             info <- base::c(r_version = base::gsub("R version ", 
[16:12:34.642]                               "", base::R.version$version.string), 
[16:12:34.642]                               platform = base::sprintf("%s (%s-bit)", 
[16:12:34.642]                                 base::R.version$platform, 8 * 
[16:12:34.642]                                   base::.Machine$sizeof.pointer), 
[16:12:34.642]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:34.642]                                 "release", "version")], collapse = " "), 
[16:12:34.642]                               hostname = base::Sys.info()[["nodename"]])
[16:12:34.642]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:12:34.642]                               info)
[16:12:34.642]                             info <- base::paste(info, collapse = "; ")
[16:12:34.642]                             if (!has_future) {
[16:12:34.642]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:34.642]                                 info)
[16:12:34.642]                             }
[16:12:34.642]                             else {
[16:12:34.642]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:34.642]                                 info, version)
[16:12:34.642]                             }
[16:12:34.642]                             base::stop(msg)
[16:12:34.642]                           }
[16:12:34.642]                         })
[16:12:34.642]                       }
[16:12:34.642]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:34.642]                       base::options(mc.cores = 1L)
[16:12:34.642]                     }
[16:12:34.642]                     base::local({
[16:12:34.642]                       for (pkg in "stats") {
[16:12:34.642]                         base::loadNamespace(pkg)
[16:12:34.642]                         base::library(pkg, character.only = TRUE)
[16:12:34.642]                       }
[16:12:34.642]                     })
[16:12:34.642]                   }
[16:12:34.642]                   options(future.plan = NULL)
[16:12:34.642]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:34.642]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:34.642]                 }
[16:12:34.642]                 ...future.workdir <- getwd()
[16:12:34.642]             }
[16:12:34.642]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:34.642]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:34.642]         }
[16:12:34.642]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:34.642]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:34.642]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:34.642]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:34.642]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:34.642]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:34.642]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:34.642]             base::names(...future.oldOptions))
[16:12:34.642]     }
[16:12:34.642]     if (FALSE) {
[16:12:34.642]     }
[16:12:34.642]     else {
[16:12:34.642]         if (TRUE) {
[16:12:34.642]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:34.642]                 open = "w")
[16:12:34.642]         }
[16:12:34.642]         else {
[16:12:34.642]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:34.642]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:34.642]         }
[16:12:34.642]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:34.642]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:34.642]             base::sink(type = "output", split = FALSE)
[16:12:34.642]             base::close(...future.stdout)
[16:12:34.642]         }, add = TRUE)
[16:12:34.642]     }
[16:12:34.642]     ...future.frame <- base::sys.nframe()
[16:12:34.642]     ...future.conditions <- base::list()
[16:12:34.642]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:34.642]     if (FALSE) {
[16:12:34.642]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:34.642]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:34.642]     }
[16:12:34.642]     ...future.result <- base::tryCatch({
[16:12:34.642]         base::withCallingHandlers({
[16:12:34.642]             ...future.value <- base::withVisible(base::local({
[16:12:34.642]                 ...future.makeSendCondition <- local({
[16:12:34.642]                   sendCondition <- NULL
[16:12:34.642]                   function(frame = 1L) {
[16:12:34.642]                     if (is.function(sendCondition)) 
[16:12:34.642]                       return(sendCondition)
[16:12:34.642]                     ns <- getNamespace("parallel")
[16:12:34.642]                     if (exists("sendData", mode = "function", 
[16:12:34.642]                       envir = ns)) {
[16:12:34.642]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:34.642]                         envir = ns)
[16:12:34.642]                       envir <- sys.frame(frame)
[16:12:34.642]                       master <- NULL
[16:12:34.642]                       while (!identical(envir, .GlobalEnv) && 
[16:12:34.642]                         !identical(envir, emptyenv())) {
[16:12:34.642]                         if (exists("master", mode = "list", envir = envir, 
[16:12:34.642]                           inherits = FALSE)) {
[16:12:34.642]                           master <- get("master", mode = "list", 
[16:12:34.642]                             envir = envir, inherits = FALSE)
[16:12:34.642]                           if (inherits(master, c("SOCKnode", 
[16:12:34.642]                             "SOCK0node"))) {
[16:12:34.642]                             sendCondition <<- function(cond) {
[16:12:34.642]                               data <- list(type = "VALUE", value = cond, 
[16:12:34.642]                                 success = TRUE)
[16:12:34.642]                               parallel_sendData(master, data)
[16:12:34.642]                             }
[16:12:34.642]                             return(sendCondition)
[16:12:34.642]                           }
[16:12:34.642]                         }
[16:12:34.642]                         frame <- frame + 1L
[16:12:34.642]                         envir <- sys.frame(frame)
[16:12:34.642]                       }
[16:12:34.642]                     }
[16:12:34.642]                     sendCondition <<- function(cond) NULL
[16:12:34.642]                   }
[16:12:34.642]                 })
[16:12:34.642]                 withCallingHandlers({
[16:12:34.642]                   {
[16:12:34.642]                     lm(weight ~ group - 1)
[16:12:34.642]                   }
[16:12:34.642]                 }, immediateCondition = function(cond) {
[16:12:34.642]                   sendCondition <- ...future.makeSendCondition()
[16:12:34.642]                   sendCondition(cond)
[16:12:34.642]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:34.642]                   {
[16:12:34.642]                     inherits <- base::inherits
[16:12:34.642]                     invokeRestart <- base::invokeRestart
[16:12:34.642]                     is.null <- base::is.null
[16:12:34.642]                     muffled <- FALSE
[16:12:34.642]                     if (inherits(cond, "message")) {
[16:12:34.642]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:34.642]                       if (muffled) 
[16:12:34.642]                         invokeRestart("muffleMessage")
[16:12:34.642]                     }
[16:12:34.642]                     else if (inherits(cond, "warning")) {
[16:12:34.642]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:34.642]                       if (muffled) 
[16:12:34.642]                         invokeRestart("muffleWarning")
[16:12:34.642]                     }
[16:12:34.642]                     else if (inherits(cond, "condition")) {
[16:12:34.642]                       if (!is.null(pattern)) {
[16:12:34.642]                         computeRestarts <- base::computeRestarts
[16:12:34.642]                         grepl <- base::grepl
[16:12:34.642]                         restarts <- computeRestarts(cond)
[16:12:34.642]                         for (restart in restarts) {
[16:12:34.642]                           name <- restart$name
[16:12:34.642]                           if (is.null(name)) 
[16:12:34.642]                             next
[16:12:34.642]                           if (!grepl(pattern, name)) 
[16:12:34.642]                             next
[16:12:34.642]                           invokeRestart(restart)
[16:12:34.642]                           muffled <- TRUE
[16:12:34.642]                           break
[16:12:34.642]                         }
[16:12:34.642]                       }
[16:12:34.642]                     }
[16:12:34.642]                     invisible(muffled)
[16:12:34.642]                   }
[16:12:34.642]                   muffleCondition(cond)
[16:12:34.642]                 })
[16:12:34.642]             }))
[16:12:34.642]             future::FutureResult(value = ...future.value$value, 
[16:12:34.642]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:34.642]                   ...future.rng), globalenv = if (FALSE) 
[16:12:34.642]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:34.642]                     ...future.globalenv.names))
[16:12:34.642]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:34.642]         }, condition = base::local({
[16:12:34.642]             c <- base::c
[16:12:34.642]             inherits <- base::inherits
[16:12:34.642]             invokeRestart <- base::invokeRestart
[16:12:34.642]             length <- base::length
[16:12:34.642]             list <- base::list
[16:12:34.642]             seq.int <- base::seq.int
[16:12:34.642]             signalCondition <- base::signalCondition
[16:12:34.642]             sys.calls <- base::sys.calls
[16:12:34.642]             `[[` <- base::`[[`
[16:12:34.642]             `+` <- base::`+`
[16:12:34.642]             `<<-` <- base::`<<-`
[16:12:34.642]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:34.642]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:34.642]                   3L)]
[16:12:34.642]             }
[16:12:34.642]             function(cond) {
[16:12:34.642]                 is_error <- inherits(cond, "error")
[16:12:34.642]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:34.642]                   NULL)
[16:12:34.642]                 if (is_error) {
[16:12:34.642]                   sessionInformation <- function() {
[16:12:34.642]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:34.642]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:34.642]                       search = base::search(), system = base::Sys.info())
[16:12:34.642]                   }
[16:12:34.642]                   ...future.conditions[[length(...future.conditions) + 
[16:12:34.642]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:34.642]                     cond$call), session = sessionInformation(), 
[16:12:34.642]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:34.642]                   signalCondition(cond)
[16:12:34.642]                 }
[16:12:34.642]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:34.642]                 "immediateCondition"))) {
[16:12:34.642]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:34.642]                   ...future.conditions[[length(...future.conditions) + 
[16:12:34.642]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:34.642]                   if (TRUE && !signal) {
[16:12:34.642]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:34.642]                     {
[16:12:34.642]                       inherits <- base::inherits
[16:12:34.642]                       invokeRestart <- base::invokeRestart
[16:12:34.642]                       is.null <- base::is.null
[16:12:34.642]                       muffled <- FALSE
[16:12:34.642]                       if (inherits(cond, "message")) {
[16:12:34.642]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:34.642]                         if (muffled) 
[16:12:34.642]                           invokeRestart("muffleMessage")
[16:12:34.642]                       }
[16:12:34.642]                       else if (inherits(cond, "warning")) {
[16:12:34.642]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:34.642]                         if (muffled) 
[16:12:34.642]                           invokeRestart("muffleWarning")
[16:12:34.642]                       }
[16:12:34.642]                       else if (inherits(cond, "condition")) {
[16:12:34.642]                         if (!is.null(pattern)) {
[16:12:34.642]                           computeRestarts <- base::computeRestarts
[16:12:34.642]                           grepl <- base::grepl
[16:12:34.642]                           restarts <- computeRestarts(cond)
[16:12:34.642]                           for (restart in restarts) {
[16:12:34.642]                             name <- restart$name
[16:12:34.642]                             if (is.null(name)) 
[16:12:34.642]                               next
[16:12:34.642]                             if (!grepl(pattern, name)) 
[16:12:34.642]                               next
[16:12:34.642]                             invokeRestart(restart)
[16:12:34.642]                             muffled <- TRUE
[16:12:34.642]                             break
[16:12:34.642]                           }
[16:12:34.642]                         }
[16:12:34.642]                       }
[16:12:34.642]                       invisible(muffled)
[16:12:34.642]                     }
[16:12:34.642]                     muffleCondition(cond, pattern = "^muffle")
[16:12:34.642]                   }
[16:12:34.642]                 }
[16:12:34.642]                 else {
[16:12:34.642]                   if (TRUE) {
[16:12:34.642]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:34.642]                     {
[16:12:34.642]                       inherits <- base::inherits
[16:12:34.642]                       invokeRestart <- base::invokeRestart
[16:12:34.642]                       is.null <- base::is.null
[16:12:34.642]                       muffled <- FALSE
[16:12:34.642]                       if (inherits(cond, "message")) {
[16:12:34.642]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:34.642]                         if (muffled) 
[16:12:34.642]                           invokeRestart("muffleMessage")
[16:12:34.642]                       }
[16:12:34.642]                       else if (inherits(cond, "warning")) {
[16:12:34.642]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:34.642]                         if (muffled) 
[16:12:34.642]                           invokeRestart("muffleWarning")
[16:12:34.642]                       }
[16:12:34.642]                       else if (inherits(cond, "condition")) {
[16:12:34.642]                         if (!is.null(pattern)) {
[16:12:34.642]                           computeRestarts <- base::computeRestarts
[16:12:34.642]                           grepl <- base::grepl
[16:12:34.642]                           restarts <- computeRestarts(cond)
[16:12:34.642]                           for (restart in restarts) {
[16:12:34.642]                             name <- restart$name
[16:12:34.642]                             if (is.null(name)) 
[16:12:34.642]                               next
[16:12:34.642]                             if (!grepl(pattern, name)) 
[16:12:34.642]                               next
[16:12:34.642]                             invokeRestart(restart)
[16:12:34.642]                             muffled <- TRUE
[16:12:34.642]                             break
[16:12:34.642]                           }
[16:12:34.642]                         }
[16:12:34.642]                       }
[16:12:34.642]                       invisible(muffled)
[16:12:34.642]                     }
[16:12:34.642]                     muffleCondition(cond, pattern = "^muffle")
[16:12:34.642]                   }
[16:12:34.642]                 }
[16:12:34.642]             }
[16:12:34.642]         }))
[16:12:34.642]     }, error = function(ex) {
[16:12:34.642]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:34.642]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:34.642]                 ...future.rng), started = ...future.startTime, 
[16:12:34.642]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:34.642]             version = "1.8"), class = "FutureResult")
[16:12:34.642]     }, finally = {
[16:12:34.642]         if (!identical(...future.workdir, getwd())) 
[16:12:34.642]             setwd(...future.workdir)
[16:12:34.642]         {
[16:12:34.642]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:34.642]                 ...future.oldOptions$nwarnings <- NULL
[16:12:34.642]             }
[16:12:34.642]             base::options(...future.oldOptions)
[16:12:34.642]             if (.Platform$OS.type == "windows") {
[16:12:34.642]                 old_names <- names(...future.oldEnvVars)
[16:12:34.642]                 envs <- base::Sys.getenv()
[16:12:34.642]                 names <- names(envs)
[16:12:34.642]                 common <- intersect(names, old_names)
[16:12:34.642]                 added <- setdiff(names, old_names)
[16:12:34.642]                 removed <- setdiff(old_names, names)
[16:12:34.642]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:34.642]                   envs[common]]
[16:12:34.642]                 NAMES <- toupper(changed)
[16:12:34.642]                 args <- list()
[16:12:34.642]                 for (kk in seq_along(NAMES)) {
[16:12:34.642]                   name <- changed[[kk]]
[16:12:34.642]                   NAME <- NAMES[[kk]]
[16:12:34.642]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:34.642]                     next
[16:12:34.642]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:34.642]                 }
[16:12:34.642]                 NAMES <- toupper(added)
[16:12:34.642]                 for (kk in seq_along(NAMES)) {
[16:12:34.642]                   name <- added[[kk]]
[16:12:34.642]                   NAME <- NAMES[[kk]]
[16:12:34.642]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:34.642]                     next
[16:12:34.642]                   args[[name]] <- ""
[16:12:34.642]                 }
[16:12:34.642]                 NAMES <- toupper(removed)
[16:12:34.642]                 for (kk in seq_along(NAMES)) {
[16:12:34.642]                   name <- removed[[kk]]
[16:12:34.642]                   NAME <- NAMES[[kk]]
[16:12:34.642]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:34.642]                     next
[16:12:34.642]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:34.642]                 }
[16:12:34.642]                 if (length(args) > 0) 
[16:12:34.642]                   base::do.call(base::Sys.setenv, args = args)
[16:12:34.642]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:34.642]             }
[16:12:34.642]             else {
[16:12:34.642]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:34.642]             }
[16:12:34.642]             {
[16:12:34.642]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:34.642]                   0L) {
[16:12:34.642]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:34.642]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:34.642]                   base::options(opts)
[16:12:34.642]                 }
[16:12:34.642]                 {
[16:12:34.642]                   {
[16:12:34.642]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:34.642]                     NULL
[16:12:34.642]                   }
[16:12:34.642]                   options(future.plan = NULL)
[16:12:34.642]                   if (is.na(NA_character_)) 
[16:12:34.642]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:34.642]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:34.642]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:34.642]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:34.642]                     envir = parent.frame()) 
[16:12:34.642]                   {
[16:12:34.642]                     if (is.function(workers)) 
[16:12:34.642]                       workers <- workers()
[16:12:34.642]                     workers <- structure(as.integer(workers), 
[16:12:34.642]                       class = class(workers))
[16:12:34.642]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:34.642]                       workers >= 1)
[16:12:34.642]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:34.642]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:34.642]                     }
[16:12:34.642]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:34.642]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:34.642]                       envir = envir)
[16:12:34.642]                     if (!future$lazy) 
[16:12:34.642]                       future <- run(future)
[16:12:34.642]                     invisible(future)
[16:12:34.642]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:34.642]                 }
[16:12:34.642]             }
[16:12:34.642]         }
[16:12:34.642]     })
[16:12:34.642]     if (TRUE) {
[16:12:34.642]         base::sink(type = "output", split = FALSE)
[16:12:34.642]         if (TRUE) {
[16:12:34.642]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:34.642]         }
[16:12:34.642]         else {
[16:12:34.642]             ...future.result["stdout"] <- base::list(NULL)
[16:12:34.642]         }
[16:12:34.642]         base::close(...future.stdout)
[16:12:34.642]         ...future.stdout <- NULL
[16:12:34.642]     }
[16:12:34.642]     ...future.result$conditions <- ...future.conditions
[16:12:34.642]     ...future.result$finished <- base::Sys.time()
[16:12:34.642]     ...future.result
[16:12:34.642] }
[16:12:34.644] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[16:12:34.645] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[16:12:34.645] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[16:12:34.645] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[16:12:34.646] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[16:12:34.646] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[16:12:34.646] MultisessionFuture started
[16:12:34.646] - Launch lazy future ... done
[16:12:34.646] run() for ‘MultisessionFuture’ ... done
[16:12:34.647] result() for ClusterFuture ...
[16:12:34.647] receiveMessageFromWorker() for ClusterFuture ...
[16:12:34.647] - Validating connection of MultisessionFuture
[16:12:34.694] - received message: FutureResult
[16:12:34.694] - Received FutureResult
[16:12:34.694] - Erased future from FutureRegistry
[16:12:34.694] result() for ClusterFuture ...
[16:12:34.694] - result already collected: FutureResult
[16:12:34.694] result() for ClusterFuture ... done
[16:12:34.695] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:34.695] result() for ClusterFuture ... done
[16:12:34.695] result() for ClusterFuture ...
[16:12:34.695] - result already collected: FutureResult
[16:12:34.695] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[16:12:34.697] getGlobalsAndPackages() ...
[16:12:34.697] Searching for globals...
[16:12:34.698] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[16:12:34.698] Searching for globals ... DONE
[16:12:34.698] Resolving globals: FALSE
[16:12:34.699] The total size of the 1 globals is 96 bytes (96 bytes)
[16:12:34.699] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[16:12:34.699] - globals: [1] ‘x’
[16:12:34.699] - packages: [1] ‘stats’
[16:12:34.699] getGlobalsAndPackages() ... DONE
[16:12:34.700] run() for ‘Future’ ...
[16:12:34.700] - state: ‘created’
[16:12:34.700] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:34.714] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:34.714] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:34.715]   - Field: ‘node’
[16:12:34.715]   - Field: ‘label’
[16:12:34.715]   - Field: ‘local’
[16:12:34.715]   - Field: ‘owner’
[16:12:34.715]   - Field: ‘envir’
[16:12:34.715]   - Field: ‘workers’
[16:12:34.715]   - Field: ‘packages’
[16:12:34.715]   - Field: ‘gc’
[16:12:34.715]   - Field: ‘conditions’
[16:12:34.715]   - Field: ‘persistent’
[16:12:34.716]   - Field: ‘expr’
[16:12:34.716]   - Field: ‘uuid’
[16:12:34.716]   - Field: ‘seed’
[16:12:34.716]   - Field: ‘version’
[16:12:34.716]   - Field: ‘result’
[16:12:34.716]   - Field: ‘asynchronous’
[16:12:34.716]   - Field: ‘calls’
[16:12:34.716]   - Field: ‘globals’
[16:12:34.716]   - Field: ‘stdout’
[16:12:34.716]   - Field: ‘earlySignal’
[16:12:34.716]   - Field: ‘lazy’
[16:12:34.717]   - Field: ‘state’
[16:12:34.717] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:34.717] - Launch lazy future ...
[16:12:34.717] Packages needed by the future expression (n = 1): ‘stats’
[16:12:34.717] Packages needed by future strategies (n = 0): <none>
[16:12:34.718] {
[16:12:34.718]     {
[16:12:34.718]         {
[16:12:34.718]             ...future.startTime <- base::Sys.time()
[16:12:34.718]             {
[16:12:34.718]                 {
[16:12:34.718]                   {
[16:12:34.718]                     {
[16:12:34.718]                       {
[16:12:34.718]                         base::local({
[16:12:34.718]                           has_future <- base::requireNamespace("future", 
[16:12:34.718]                             quietly = TRUE)
[16:12:34.718]                           if (has_future) {
[16:12:34.718]                             ns <- base::getNamespace("future")
[16:12:34.718]                             version <- ns[[".package"]][["version"]]
[16:12:34.718]                             if (is.null(version)) 
[16:12:34.718]                               version <- utils::packageVersion("future")
[16:12:34.718]                           }
[16:12:34.718]                           else {
[16:12:34.718]                             version <- NULL
[16:12:34.718]                           }
[16:12:34.718]                           if (!has_future || version < "1.8.0") {
[16:12:34.718]                             info <- base::c(r_version = base::gsub("R version ", 
[16:12:34.718]                               "", base::R.version$version.string), 
[16:12:34.718]                               platform = base::sprintf("%s (%s-bit)", 
[16:12:34.718]                                 base::R.version$platform, 8 * 
[16:12:34.718]                                   base::.Machine$sizeof.pointer), 
[16:12:34.718]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:34.718]                                 "release", "version")], collapse = " "), 
[16:12:34.718]                               hostname = base::Sys.info()[["nodename"]])
[16:12:34.718]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:12:34.718]                               info)
[16:12:34.718]                             info <- base::paste(info, collapse = "; ")
[16:12:34.718]                             if (!has_future) {
[16:12:34.718]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:34.718]                                 info)
[16:12:34.718]                             }
[16:12:34.718]                             else {
[16:12:34.718]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:34.718]                                 info, version)
[16:12:34.718]                             }
[16:12:34.718]                             base::stop(msg)
[16:12:34.718]                           }
[16:12:34.718]                         })
[16:12:34.718]                       }
[16:12:34.718]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:34.718]                       base::options(mc.cores = 1L)
[16:12:34.718]                     }
[16:12:34.718]                     base::local({
[16:12:34.718]                       for (pkg in "stats") {
[16:12:34.718]                         base::loadNamespace(pkg)
[16:12:34.718]                         base::library(pkg, character.only = TRUE)
[16:12:34.718]                       }
[16:12:34.718]                     })
[16:12:34.718]                   }
[16:12:34.718]                   options(future.plan = NULL)
[16:12:34.718]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:34.718]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:34.718]                 }
[16:12:34.718]                 ...future.workdir <- getwd()
[16:12:34.718]             }
[16:12:34.718]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:34.718]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:34.718]         }
[16:12:34.718]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:34.718]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:34.718]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:34.718]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:34.718]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:34.718]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:34.718]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:34.718]             base::names(...future.oldOptions))
[16:12:34.718]     }
[16:12:34.718]     if (FALSE) {
[16:12:34.718]     }
[16:12:34.718]     else {
[16:12:34.718]         if (TRUE) {
[16:12:34.718]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:34.718]                 open = "w")
[16:12:34.718]         }
[16:12:34.718]         else {
[16:12:34.718]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:34.718]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:34.718]         }
[16:12:34.718]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:34.718]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:34.718]             base::sink(type = "output", split = FALSE)
[16:12:34.718]             base::close(...future.stdout)
[16:12:34.718]         }, add = TRUE)
[16:12:34.718]     }
[16:12:34.718]     ...future.frame <- base::sys.nframe()
[16:12:34.718]     ...future.conditions <- base::list()
[16:12:34.718]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:34.718]     if (FALSE) {
[16:12:34.718]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:34.718]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:34.718]     }
[16:12:34.718]     ...future.result <- base::tryCatch({
[16:12:34.718]         base::withCallingHandlers({
[16:12:34.718]             ...future.value <- base::withVisible(base::local({
[16:12:34.718]                 ...future.makeSendCondition <- local({
[16:12:34.718]                   sendCondition <- NULL
[16:12:34.718]                   function(frame = 1L) {
[16:12:34.718]                     if (is.function(sendCondition)) 
[16:12:34.718]                       return(sendCondition)
[16:12:34.718]                     ns <- getNamespace("parallel")
[16:12:34.718]                     if (exists("sendData", mode = "function", 
[16:12:34.718]                       envir = ns)) {
[16:12:34.718]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:34.718]                         envir = ns)
[16:12:34.718]                       envir <- sys.frame(frame)
[16:12:34.718]                       master <- NULL
[16:12:34.718]                       while (!identical(envir, .GlobalEnv) && 
[16:12:34.718]                         !identical(envir, emptyenv())) {
[16:12:34.718]                         if (exists("master", mode = "list", envir = envir, 
[16:12:34.718]                           inherits = FALSE)) {
[16:12:34.718]                           master <- get("master", mode = "list", 
[16:12:34.718]                             envir = envir, inherits = FALSE)
[16:12:34.718]                           if (inherits(master, c("SOCKnode", 
[16:12:34.718]                             "SOCK0node"))) {
[16:12:34.718]                             sendCondition <<- function(cond) {
[16:12:34.718]                               data <- list(type = "VALUE", value = cond, 
[16:12:34.718]                                 success = TRUE)
[16:12:34.718]                               parallel_sendData(master, data)
[16:12:34.718]                             }
[16:12:34.718]                             return(sendCondition)
[16:12:34.718]                           }
[16:12:34.718]                         }
[16:12:34.718]                         frame <- frame + 1L
[16:12:34.718]                         envir <- sys.frame(frame)
[16:12:34.718]                       }
[16:12:34.718]                     }
[16:12:34.718]                     sendCondition <<- function(cond) NULL
[16:12:34.718]                   }
[16:12:34.718]                 })
[16:12:34.718]                 withCallingHandlers({
[16:12:34.718]                   {
[16:12:34.718]                     xtabs(~x)
[16:12:34.718]                   }
[16:12:34.718]                 }, immediateCondition = function(cond) {
[16:12:34.718]                   sendCondition <- ...future.makeSendCondition()
[16:12:34.718]                   sendCondition(cond)
[16:12:34.718]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:34.718]                   {
[16:12:34.718]                     inherits <- base::inherits
[16:12:34.718]                     invokeRestart <- base::invokeRestart
[16:12:34.718]                     is.null <- base::is.null
[16:12:34.718]                     muffled <- FALSE
[16:12:34.718]                     if (inherits(cond, "message")) {
[16:12:34.718]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:34.718]                       if (muffled) 
[16:12:34.718]                         invokeRestart("muffleMessage")
[16:12:34.718]                     }
[16:12:34.718]                     else if (inherits(cond, "warning")) {
[16:12:34.718]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:34.718]                       if (muffled) 
[16:12:34.718]                         invokeRestart("muffleWarning")
[16:12:34.718]                     }
[16:12:34.718]                     else if (inherits(cond, "condition")) {
[16:12:34.718]                       if (!is.null(pattern)) {
[16:12:34.718]                         computeRestarts <- base::computeRestarts
[16:12:34.718]                         grepl <- base::grepl
[16:12:34.718]                         restarts <- computeRestarts(cond)
[16:12:34.718]                         for (restart in restarts) {
[16:12:34.718]                           name <- restart$name
[16:12:34.718]                           if (is.null(name)) 
[16:12:34.718]                             next
[16:12:34.718]                           if (!grepl(pattern, name)) 
[16:12:34.718]                             next
[16:12:34.718]                           invokeRestart(restart)
[16:12:34.718]                           muffled <- TRUE
[16:12:34.718]                           break
[16:12:34.718]                         }
[16:12:34.718]                       }
[16:12:34.718]                     }
[16:12:34.718]                     invisible(muffled)
[16:12:34.718]                   }
[16:12:34.718]                   muffleCondition(cond)
[16:12:34.718]                 })
[16:12:34.718]             }))
[16:12:34.718]             future::FutureResult(value = ...future.value$value, 
[16:12:34.718]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:34.718]                   ...future.rng), globalenv = if (FALSE) 
[16:12:34.718]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:34.718]                     ...future.globalenv.names))
[16:12:34.718]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:34.718]         }, condition = base::local({
[16:12:34.718]             c <- base::c
[16:12:34.718]             inherits <- base::inherits
[16:12:34.718]             invokeRestart <- base::invokeRestart
[16:12:34.718]             length <- base::length
[16:12:34.718]             list <- base::list
[16:12:34.718]             seq.int <- base::seq.int
[16:12:34.718]             signalCondition <- base::signalCondition
[16:12:34.718]             sys.calls <- base::sys.calls
[16:12:34.718]             `[[` <- base::`[[`
[16:12:34.718]             `+` <- base::`+`
[16:12:34.718]             `<<-` <- base::`<<-`
[16:12:34.718]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:34.718]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:34.718]                   3L)]
[16:12:34.718]             }
[16:12:34.718]             function(cond) {
[16:12:34.718]                 is_error <- inherits(cond, "error")
[16:12:34.718]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:34.718]                   NULL)
[16:12:34.718]                 if (is_error) {
[16:12:34.718]                   sessionInformation <- function() {
[16:12:34.718]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:34.718]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:34.718]                       search = base::search(), system = base::Sys.info())
[16:12:34.718]                   }
[16:12:34.718]                   ...future.conditions[[length(...future.conditions) + 
[16:12:34.718]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:34.718]                     cond$call), session = sessionInformation(), 
[16:12:34.718]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:34.718]                   signalCondition(cond)
[16:12:34.718]                 }
[16:12:34.718]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:34.718]                 "immediateCondition"))) {
[16:12:34.718]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:34.718]                   ...future.conditions[[length(...future.conditions) + 
[16:12:34.718]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:34.718]                   if (TRUE && !signal) {
[16:12:34.718]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:34.718]                     {
[16:12:34.718]                       inherits <- base::inherits
[16:12:34.718]                       invokeRestart <- base::invokeRestart
[16:12:34.718]                       is.null <- base::is.null
[16:12:34.718]                       muffled <- FALSE
[16:12:34.718]                       if (inherits(cond, "message")) {
[16:12:34.718]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:34.718]                         if (muffled) 
[16:12:34.718]                           invokeRestart("muffleMessage")
[16:12:34.718]                       }
[16:12:34.718]                       else if (inherits(cond, "warning")) {
[16:12:34.718]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:34.718]                         if (muffled) 
[16:12:34.718]                           invokeRestart("muffleWarning")
[16:12:34.718]                       }
[16:12:34.718]                       else if (inherits(cond, "condition")) {
[16:12:34.718]                         if (!is.null(pattern)) {
[16:12:34.718]                           computeRestarts <- base::computeRestarts
[16:12:34.718]                           grepl <- base::grepl
[16:12:34.718]                           restarts <- computeRestarts(cond)
[16:12:34.718]                           for (restart in restarts) {
[16:12:34.718]                             name <- restart$name
[16:12:34.718]                             if (is.null(name)) 
[16:12:34.718]                               next
[16:12:34.718]                             if (!grepl(pattern, name)) 
[16:12:34.718]                               next
[16:12:34.718]                             invokeRestart(restart)
[16:12:34.718]                             muffled <- TRUE
[16:12:34.718]                             break
[16:12:34.718]                           }
[16:12:34.718]                         }
[16:12:34.718]                       }
[16:12:34.718]                       invisible(muffled)
[16:12:34.718]                     }
[16:12:34.718]                     muffleCondition(cond, pattern = "^muffle")
[16:12:34.718]                   }
[16:12:34.718]                 }
[16:12:34.718]                 else {
[16:12:34.718]                   if (TRUE) {
[16:12:34.718]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:34.718]                     {
[16:12:34.718]                       inherits <- base::inherits
[16:12:34.718]                       invokeRestart <- base::invokeRestart
[16:12:34.718]                       is.null <- base::is.null
[16:12:34.718]                       muffled <- FALSE
[16:12:34.718]                       if (inherits(cond, "message")) {
[16:12:34.718]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:34.718]                         if (muffled) 
[16:12:34.718]                           invokeRestart("muffleMessage")
[16:12:34.718]                       }
[16:12:34.718]                       else if (inherits(cond, "warning")) {
[16:12:34.718]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:34.718]                         if (muffled) 
[16:12:34.718]                           invokeRestart("muffleWarning")
[16:12:34.718]                       }
[16:12:34.718]                       else if (inherits(cond, "condition")) {
[16:12:34.718]                         if (!is.null(pattern)) {
[16:12:34.718]                           computeRestarts <- base::computeRestarts
[16:12:34.718]                           grepl <- base::grepl
[16:12:34.718]                           restarts <- computeRestarts(cond)
[16:12:34.718]                           for (restart in restarts) {
[16:12:34.718]                             name <- restart$name
[16:12:34.718]                             if (is.null(name)) 
[16:12:34.718]                               next
[16:12:34.718]                             if (!grepl(pattern, name)) 
[16:12:34.718]                               next
[16:12:34.718]                             invokeRestart(restart)
[16:12:34.718]                             muffled <- TRUE
[16:12:34.718]                             break
[16:12:34.718]                           }
[16:12:34.718]                         }
[16:12:34.718]                       }
[16:12:34.718]                       invisible(muffled)
[16:12:34.718]                     }
[16:12:34.718]                     muffleCondition(cond, pattern = "^muffle")
[16:12:34.718]                   }
[16:12:34.718]                 }
[16:12:34.718]             }
[16:12:34.718]         }))
[16:12:34.718]     }, error = function(ex) {
[16:12:34.718]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:34.718]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:34.718]                 ...future.rng), started = ...future.startTime, 
[16:12:34.718]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:34.718]             version = "1.8"), class = "FutureResult")
[16:12:34.718]     }, finally = {
[16:12:34.718]         if (!identical(...future.workdir, getwd())) 
[16:12:34.718]             setwd(...future.workdir)
[16:12:34.718]         {
[16:12:34.718]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:34.718]                 ...future.oldOptions$nwarnings <- NULL
[16:12:34.718]             }
[16:12:34.718]             base::options(...future.oldOptions)
[16:12:34.718]             if (.Platform$OS.type == "windows") {
[16:12:34.718]                 old_names <- names(...future.oldEnvVars)
[16:12:34.718]                 envs <- base::Sys.getenv()
[16:12:34.718]                 names <- names(envs)
[16:12:34.718]                 common <- intersect(names, old_names)
[16:12:34.718]                 added <- setdiff(names, old_names)
[16:12:34.718]                 removed <- setdiff(old_names, names)
[16:12:34.718]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:34.718]                   envs[common]]
[16:12:34.718]                 NAMES <- toupper(changed)
[16:12:34.718]                 args <- list()
[16:12:34.718]                 for (kk in seq_along(NAMES)) {
[16:12:34.718]                   name <- changed[[kk]]
[16:12:34.718]                   NAME <- NAMES[[kk]]
[16:12:34.718]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:34.718]                     next
[16:12:34.718]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:34.718]                 }
[16:12:34.718]                 NAMES <- toupper(added)
[16:12:34.718]                 for (kk in seq_along(NAMES)) {
[16:12:34.718]                   name <- added[[kk]]
[16:12:34.718]                   NAME <- NAMES[[kk]]
[16:12:34.718]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:34.718]                     next
[16:12:34.718]                   args[[name]] <- ""
[16:12:34.718]                 }
[16:12:34.718]                 NAMES <- toupper(removed)
[16:12:34.718]                 for (kk in seq_along(NAMES)) {
[16:12:34.718]                   name <- removed[[kk]]
[16:12:34.718]                   NAME <- NAMES[[kk]]
[16:12:34.718]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:34.718]                     next
[16:12:34.718]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:34.718]                 }
[16:12:34.718]                 if (length(args) > 0) 
[16:12:34.718]                   base::do.call(base::Sys.setenv, args = args)
[16:12:34.718]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:34.718]             }
[16:12:34.718]             else {
[16:12:34.718]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:34.718]             }
[16:12:34.718]             {
[16:12:34.718]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:34.718]                   0L) {
[16:12:34.718]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:34.718]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:34.718]                   base::options(opts)
[16:12:34.718]                 }
[16:12:34.718]                 {
[16:12:34.718]                   {
[16:12:34.718]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:34.718]                     NULL
[16:12:34.718]                   }
[16:12:34.718]                   options(future.plan = NULL)
[16:12:34.718]                   if (is.na(NA_character_)) 
[16:12:34.718]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:34.718]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:34.718]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:34.718]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:34.718]                     envir = parent.frame()) 
[16:12:34.718]                   {
[16:12:34.718]                     if (is.function(workers)) 
[16:12:34.718]                       workers <- workers()
[16:12:34.718]                     workers <- structure(as.integer(workers), 
[16:12:34.718]                       class = class(workers))
[16:12:34.718]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:34.718]                       workers >= 1)
[16:12:34.718]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:34.718]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:34.718]                     }
[16:12:34.718]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:34.718]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:34.718]                       envir = envir)
[16:12:34.718]                     if (!future$lazy) 
[16:12:34.718]                       future <- run(future)
[16:12:34.718]                     invisible(future)
[16:12:34.718]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:34.718]                 }
[16:12:34.718]             }
[16:12:34.718]         }
[16:12:34.718]     })
[16:12:34.718]     if (TRUE) {
[16:12:34.718]         base::sink(type = "output", split = FALSE)
[16:12:34.718]         if (TRUE) {
[16:12:34.718]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:34.718]         }
[16:12:34.718]         else {
[16:12:34.718]             ...future.result["stdout"] <- base::list(NULL)
[16:12:34.718]         }
[16:12:34.718]         base::close(...future.stdout)
[16:12:34.718]         ...future.stdout <- NULL
[16:12:34.718]     }
[16:12:34.718]     ...future.result$conditions <- ...future.conditions
[16:12:34.718]     ...future.result$finished <- base::Sys.time()
[16:12:34.718]     ...future.result
[16:12:34.718] }
[16:12:34.720] Exporting 1 global objects (96 bytes) to cluster node #1 ...
[16:12:34.721] Exporting ‘x’ (96 bytes) to cluster node #1 ...
[16:12:34.721] Exporting ‘x’ (96 bytes) to cluster node #1 ... DONE
[16:12:34.721] Exporting 1 global objects (96 bytes) to cluster node #1 ... DONE
[16:12:34.722] MultisessionFuture started
[16:12:34.722] - Launch lazy future ... done
[16:12:34.722] run() for ‘MultisessionFuture’ ... done
[16:12:34.722] result() for ClusterFuture ...
[16:12:34.722] receiveMessageFromWorker() for ClusterFuture ...
[16:12:34.722] - Validating connection of MultisessionFuture
[16:12:34.770] - received message: FutureResult
[16:12:34.770] - Received FutureResult
[16:12:34.770] - Erased future from FutureRegistry
[16:12:34.770] result() for ClusterFuture ...
[16:12:34.770] - result already collected: FutureResult
[16:12:34.770] result() for ClusterFuture ... done
[16:12:34.770] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:34.770] result() for ClusterFuture ... done
[16:12:34.770] result() for ClusterFuture ...
[16:12:34.771] - result already collected: FutureResult
[16:12:34.771] result() for ClusterFuture ... done
x
1 2 
2 3 
[16:12:34.771] getGlobalsAndPackages() ...
[16:12:34.771] Searching for globals...
[16:12:34.773] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[16:12:34.773] Searching for globals ... DONE
[16:12:34.773] Resolving globals: FALSE
[16:12:34.773] The total size of the 1 globals is 96 bytes (96 bytes)
[16:12:34.774] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[16:12:34.774] - globals: [1] ‘x’
[16:12:34.774] - packages: [1] ‘stats’
[16:12:34.774] getGlobalsAndPackages() ... DONE
[16:12:34.774] run() for ‘Future’ ...
[16:12:34.774] - state: ‘created’
[16:12:34.774] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:34.789] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:34.789] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:34.789]   - Field: ‘node’
[16:12:34.789]   - Field: ‘label’
[16:12:34.789]   - Field: ‘local’
[16:12:34.789]   - Field: ‘owner’
[16:12:34.789]   - Field: ‘envir’
[16:12:34.790]   - Field: ‘workers’
[16:12:34.790]   - Field: ‘packages’
[16:12:34.790]   - Field: ‘gc’
[16:12:34.790]   - Field: ‘conditions’
[16:12:34.790]   - Field: ‘persistent’
[16:12:34.790]   - Field: ‘expr’
[16:12:34.790]   - Field: ‘uuid’
[16:12:34.790]   - Field: ‘seed’
[16:12:34.790]   - Field: ‘version’
[16:12:34.790]   - Field: ‘result’
[16:12:34.790]   - Field: ‘asynchronous’
[16:12:34.791]   - Field: ‘calls’
[16:12:34.791]   - Field: ‘globals’
[16:12:34.791]   - Field: ‘stdout’
[16:12:34.791]   - Field: ‘earlySignal’
[16:12:34.791]   - Field: ‘lazy’
[16:12:34.791]   - Field: ‘state’
[16:12:34.791] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:34.791] - Launch lazy future ...
[16:12:34.791] Packages needed by the future expression (n = 1): ‘stats’
[16:12:34.792] Packages needed by future strategies (n = 0): <none>
[16:12:34.792] {
[16:12:34.792]     {
[16:12:34.792]         {
[16:12:34.792]             ...future.startTime <- base::Sys.time()
[16:12:34.792]             {
[16:12:34.792]                 {
[16:12:34.792]                   {
[16:12:34.792]                     {
[16:12:34.792]                       {
[16:12:34.792]                         base::local({
[16:12:34.792]                           has_future <- base::requireNamespace("future", 
[16:12:34.792]                             quietly = TRUE)
[16:12:34.792]                           if (has_future) {
[16:12:34.792]                             ns <- base::getNamespace("future")
[16:12:34.792]                             version <- ns[[".package"]][["version"]]
[16:12:34.792]                             if (is.null(version)) 
[16:12:34.792]                               version <- utils::packageVersion("future")
[16:12:34.792]                           }
[16:12:34.792]                           else {
[16:12:34.792]                             version <- NULL
[16:12:34.792]                           }
[16:12:34.792]                           if (!has_future || version < "1.8.0") {
[16:12:34.792]                             info <- base::c(r_version = base::gsub("R version ", 
[16:12:34.792]                               "", base::R.version$version.string), 
[16:12:34.792]                               platform = base::sprintf("%s (%s-bit)", 
[16:12:34.792]                                 base::R.version$platform, 8 * 
[16:12:34.792]                                   base::.Machine$sizeof.pointer), 
[16:12:34.792]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:34.792]                                 "release", "version")], collapse = " "), 
[16:12:34.792]                               hostname = base::Sys.info()[["nodename"]])
[16:12:34.792]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:12:34.792]                               info)
[16:12:34.792]                             info <- base::paste(info, collapse = "; ")
[16:12:34.792]                             if (!has_future) {
[16:12:34.792]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:34.792]                                 info)
[16:12:34.792]                             }
[16:12:34.792]                             else {
[16:12:34.792]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:34.792]                                 info, version)
[16:12:34.792]                             }
[16:12:34.792]                             base::stop(msg)
[16:12:34.792]                           }
[16:12:34.792]                         })
[16:12:34.792]                       }
[16:12:34.792]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:34.792]                       base::options(mc.cores = 1L)
[16:12:34.792]                     }
[16:12:34.792]                     base::local({
[16:12:34.792]                       for (pkg in "stats") {
[16:12:34.792]                         base::loadNamespace(pkg)
[16:12:34.792]                         base::library(pkg, character.only = TRUE)
[16:12:34.792]                       }
[16:12:34.792]                     })
[16:12:34.792]                   }
[16:12:34.792]                   options(future.plan = NULL)
[16:12:34.792]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:34.792]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:34.792]                 }
[16:12:34.792]                 ...future.workdir <- getwd()
[16:12:34.792]             }
[16:12:34.792]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:34.792]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:34.792]         }
[16:12:34.792]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:34.792]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:34.792]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:34.792]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:34.792]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:34.792]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:34.792]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:34.792]             base::names(...future.oldOptions))
[16:12:34.792]     }
[16:12:34.792]     if (FALSE) {
[16:12:34.792]     }
[16:12:34.792]     else {
[16:12:34.792]         if (TRUE) {
[16:12:34.792]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:34.792]                 open = "w")
[16:12:34.792]         }
[16:12:34.792]         else {
[16:12:34.792]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:34.792]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:34.792]         }
[16:12:34.792]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:34.792]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:34.792]             base::sink(type = "output", split = FALSE)
[16:12:34.792]             base::close(...future.stdout)
[16:12:34.792]         }, add = TRUE)
[16:12:34.792]     }
[16:12:34.792]     ...future.frame <- base::sys.nframe()
[16:12:34.792]     ...future.conditions <- base::list()
[16:12:34.792]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:34.792]     if (FALSE) {
[16:12:34.792]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:34.792]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:34.792]     }
[16:12:34.792]     ...future.result <- base::tryCatch({
[16:12:34.792]         base::withCallingHandlers({
[16:12:34.792]             ...future.value <- base::withVisible(base::local({
[16:12:34.792]                 ...future.makeSendCondition <- local({
[16:12:34.792]                   sendCondition <- NULL
[16:12:34.792]                   function(frame = 1L) {
[16:12:34.792]                     if (is.function(sendCondition)) 
[16:12:34.792]                       return(sendCondition)
[16:12:34.792]                     ns <- getNamespace("parallel")
[16:12:34.792]                     if (exists("sendData", mode = "function", 
[16:12:34.792]                       envir = ns)) {
[16:12:34.792]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:34.792]                         envir = ns)
[16:12:34.792]                       envir <- sys.frame(frame)
[16:12:34.792]                       master <- NULL
[16:12:34.792]                       while (!identical(envir, .GlobalEnv) && 
[16:12:34.792]                         !identical(envir, emptyenv())) {
[16:12:34.792]                         if (exists("master", mode = "list", envir = envir, 
[16:12:34.792]                           inherits = FALSE)) {
[16:12:34.792]                           master <- get("master", mode = "list", 
[16:12:34.792]                             envir = envir, inherits = FALSE)
[16:12:34.792]                           if (inherits(master, c("SOCKnode", 
[16:12:34.792]                             "SOCK0node"))) {
[16:12:34.792]                             sendCondition <<- function(cond) {
[16:12:34.792]                               data <- list(type = "VALUE", value = cond, 
[16:12:34.792]                                 success = TRUE)
[16:12:34.792]                               parallel_sendData(master, data)
[16:12:34.792]                             }
[16:12:34.792]                             return(sendCondition)
[16:12:34.792]                           }
[16:12:34.792]                         }
[16:12:34.792]                         frame <- frame + 1L
[16:12:34.792]                         envir <- sys.frame(frame)
[16:12:34.792]                       }
[16:12:34.792]                     }
[16:12:34.792]                     sendCondition <<- function(cond) NULL
[16:12:34.792]                   }
[16:12:34.792]                 })
[16:12:34.792]                 withCallingHandlers({
[16:12:34.792]                   {
[16:12:34.792]                     xtabs(~x)
[16:12:34.792]                   }
[16:12:34.792]                 }, immediateCondition = function(cond) {
[16:12:34.792]                   sendCondition <- ...future.makeSendCondition()
[16:12:34.792]                   sendCondition(cond)
[16:12:34.792]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:34.792]                   {
[16:12:34.792]                     inherits <- base::inherits
[16:12:34.792]                     invokeRestart <- base::invokeRestart
[16:12:34.792]                     is.null <- base::is.null
[16:12:34.792]                     muffled <- FALSE
[16:12:34.792]                     if (inherits(cond, "message")) {
[16:12:34.792]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:34.792]                       if (muffled) 
[16:12:34.792]                         invokeRestart("muffleMessage")
[16:12:34.792]                     }
[16:12:34.792]                     else if (inherits(cond, "warning")) {
[16:12:34.792]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:34.792]                       if (muffled) 
[16:12:34.792]                         invokeRestart("muffleWarning")
[16:12:34.792]                     }
[16:12:34.792]                     else if (inherits(cond, "condition")) {
[16:12:34.792]                       if (!is.null(pattern)) {
[16:12:34.792]                         computeRestarts <- base::computeRestarts
[16:12:34.792]                         grepl <- base::grepl
[16:12:34.792]                         restarts <- computeRestarts(cond)
[16:12:34.792]                         for (restart in restarts) {
[16:12:34.792]                           name <- restart$name
[16:12:34.792]                           if (is.null(name)) 
[16:12:34.792]                             next
[16:12:34.792]                           if (!grepl(pattern, name)) 
[16:12:34.792]                             next
[16:12:34.792]                           invokeRestart(restart)
[16:12:34.792]                           muffled <- TRUE
[16:12:34.792]                           break
[16:12:34.792]                         }
[16:12:34.792]                       }
[16:12:34.792]                     }
[16:12:34.792]                     invisible(muffled)
[16:12:34.792]                   }
[16:12:34.792]                   muffleCondition(cond)
[16:12:34.792]                 })
[16:12:34.792]             }))
[16:12:34.792]             future::FutureResult(value = ...future.value$value, 
[16:12:34.792]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:34.792]                   ...future.rng), globalenv = if (FALSE) 
[16:12:34.792]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:34.792]                     ...future.globalenv.names))
[16:12:34.792]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:34.792]         }, condition = base::local({
[16:12:34.792]             c <- base::c
[16:12:34.792]             inherits <- base::inherits
[16:12:34.792]             invokeRestart <- base::invokeRestart
[16:12:34.792]             length <- base::length
[16:12:34.792]             list <- base::list
[16:12:34.792]             seq.int <- base::seq.int
[16:12:34.792]             signalCondition <- base::signalCondition
[16:12:34.792]             sys.calls <- base::sys.calls
[16:12:34.792]             `[[` <- base::`[[`
[16:12:34.792]             `+` <- base::`+`
[16:12:34.792]             `<<-` <- base::`<<-`
[16:12:34.792]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:34.792]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:34.792]                   3L)]
[16:12:34.792]             }
[16:12:34.792]             function(cond) {
[16:12:34.792]                 is_error <- inherits(cond, "error")
[16:12:34.792]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:34.792]                   NULL)
[16:12:34.792]                 if (is_error) {
[16:12:34.792]                   sessionInformation <- function() {
[16:12:34.792]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:34.792]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:34.792]                       search = base::search(), system = base::Sys.info())
[16:12:34.792]                   }
[16:12:34.792]                   ...future.conditions[[length(...future.conditions) + 
[16:12:34.792]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:34.792]                     cond$call), session = sessionInformation(), 
[16:12:34.792]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:34.792]                   signalCondition(cond)
[16:12:34.792]                 }
[16:12:34.792]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:34.792]                 "immediateCondition"))) {
[16:12:34.792]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:34.792]                   ...future.conditions[[length(...future.conditions) + 
[16:12:34.792]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:34.792]                   if (TRUE && !signal) {
[16:12:34.792]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:34.792]                     {
[16:12:34.792]                       inherits <- base::inherits
[16:12:34.792]                       invokeRestart <- base::invokeRestart
[16:12:34.792]                       is.null <- base::is.null
[16:12:34.792]                       muffled <- FALSE
[16:12:34.792]                       if (inherits(cond, "message")) {
[16:12:34.792]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:34.792]                         if (muffled) 
[16:12:34.792]                           invokeRestart("muffleMessage")
[16:12:34.792]                       }
[16:12:34.792]                       else if (inherits(cond, "warning")) {
[16:12:34.792]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:34.792]                         if (muffled) 
[16:12:34.792]                           invokeRestart("muffleWarning")
[16:12:34.792]                       }
[16:12:34.792]                       else if (inherits(cond, "condition")) {
[16:12:34.792]                         if (!is.null(pattern)) {
[16:12:34.792]                           computeRestarts <- base::computeRestarts
[16:12:34.792]                           grepl <- base::grepl
[16:12:34.792]                           restarts <- computeRestarts(cond)
[16:12:34.792]                           for (restart in restarts) {
[16:12:34.792]                             name <- restart$name
[16:12:34.792]                             if (is.null(name)) 
[16:12:34.792]                               next
[16:12:34.792]                             if (!grepl(pattern, name)) 
[16:12:34.792]                               next
[16:12:34.792]                             invokeRestart(restart)
[16:12:34.792]                             muffled <- TRUE
[16:12:34.792]                             break
[16:12:34.792]                           }
[16:12:34.792]                         }
[16:12:34.792]                       }
[16:12:34.792]                       invisible(muffled)
[16:12:34.792]                     }
[16:12:34.792]                     muffleCondition(cond, pattern = "^muffle")
[16:12:34.792]                   }
[16:12:34.792]                 }
[16:12:34.792]                 else {
[16:12:34.792]                   if (TRUE) {
[16:12:34.792]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:34.792]                     {
[16:12:34.792]                       inherits <- base::inherits
[16:12:34.792]                       invokeRestart <- base::invokeRestart
[16:12:34.792]                       is.null <- base::is.null
[16:12:34.792]                       muffled <- FALSE
[16:12:34.792]                       if (inherits(cond, "message")) {
[16:12:34.792]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:34.792]                         if (muffled) 
[16:12:34.792]                           invokeRestart("muffleMessage")
[16:12:34.792]                       }
[16:12:34.792]                       else if (inherits(cond, "warning")) {
[16:12:34.792]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:34.792]                         if (muffled) 
[16:12:34.792]                           invokeRestart("muffleWarning")
[16:12:34.792]                       }
[16:12:34.792]                       else if (inherits(cond, "condition")) {
[16:12:34.792]                         if (!is.null(pattern)) {
[16:12:34.792]                           computeRestarts <- base::computeRestarts
[16:12:34.792]                           grepl <- base::grepl
[16:12:34.792]                           restarts <- computeRestarts(cond)
[16:12:34.792]                           for (restart in restarts) {
[16:12:34.792]                             name <- restart$name
[16:12:34.792]                             if (is.null(name)) 
[16:12:34.792]                               next
[16:12:34.792]                             if (!grepl(pattern, name)) 
[16:12:34.792]                               next
[16:12:34.792]                             invokeRestart(restart)
[16:12:34.792]                             muffled <- TRUE
[16:12:34.792]                             break
[16:12:34.792]                           }
[16:12:34.792]                         }
[16:12:34.792]                       }
[16:12:34.792]                       invisible(muffled)
[16:12:34.792]                     }
[16:12:34.792]                     muffleCondition(cond, pattern = "^muffle")
[16:12:34.792]                   }
[16:12:34.792]                 }
[16:12:34.792]             }
[16:12:34.792]         }))
[16:12:34.792]     }, error = function(ex) {
[16:12:34.792]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:34.792]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:34.792]                 ...future.rng), started = ...future.startTime, 
[16:12:34.792]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:34.792]             version = "1.8"), class = "FutureResult")
[16:12:34.792]     }, finally = {
[16:12:34.792]         if (!identical(...future.workdir, getwd())) 
[16:12:34.792]             setwd(...future.workdir)
[16:12:34.792]         {
[16:12:34.792]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:34.792]                 ...future.oldOptions$nwarnings <- NULL
[16:12:34.792]             }
[16:12:34.792]             base::options(...future.oldOptions)
[16:12:34.792]             if (.Platform$OS.type == "windows") {
[16:12:34.792]                 old_names <- names(...future.oldEnvVars)
[16:12:34.792]                 envs <- base::Sys.getenv()
[16:12:34.792]                 names <- names(envs)
[16:12:34.792]                 common <- intersect(names, old_names)
[16:12:34.792]                 added <- setdiff(names, old_names)
[16:12:34.792]                 removed <- setdiff(old_names, names)
[16:12:34.792]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:34.792]                   envs[common]]
[16:12:34.792]                 NAMES <- toupper(changed)
[16:12:34.792]                 args <- list()
[16:12:34.792]                 for (kk in seq_along(NAMES)) {
[16:12:34.792]                   name <- changed[[kk]]
[16:12:34.792]                   NAME <- NAMES[[kk]]
[16:12:34.792]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:34.792]                     next
[16:12:34.792]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:34.792]                 }
[16:12:34.792]                 NAMES <- toupper(added)
[16:12:34.792]                 for (kk in seq_along(NAMES)) {
[16:12:34.792]                   name <- added[[kk]]
[16:12:34.792]                   NAME <- NAMES[[kk]]
[16:12:34.792]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:34.792]                     next
[16:12:34.792]                   args[[name]] <- ""
[16:12:34.792]                 }
[16:12:34.792]                 NAMES <- toupper(removed)
[16:12:34.792]                 for (kk in seq_along(NAMES)) {
[16:12:34.792]                   name <- removed[[kk]]
[16:12:34.792]                   NAME <- NAMES[[kk]]
[16:12:34.792]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:34.792]                     next
[16:12:34.792]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:34.792]                 }
[16:12:34.792]                 if (length(args) > 0) 
[16:12:34.792]                   base::do.call(base::Sys.setenv, args = args)
[16:12:34.792]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:34.792]             }
[16:12:34.792]             else {
[16:12:34.792]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:34.792]             }
[16:12:34.792]             {
[16:12:34.792]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:34.792]                   0L) {
[16:12:34.792]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:34.792]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:34.792]                   base::options(opts)
[16:12:34.792]                 }
[16:12:34.792]                 {
[16:12:34.792]                   {
[16:12:34.792]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:34.792]                     NULL
[16:12:34.792]                   }
[16:12:34.792]                   options(future.plan = NULL)
[16:12:34.792]                   if (is.na(NA_character_)) 
[16:12:34.792]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:34.792]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:34.792]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:34.792]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:34.792]                     envir = parent.frame()) 
[16:12:34.792]                   {
[16:12:34.792]                     if (is.function(workers)) 
[16:12:34.792]                       workers <- workers()
[16:12:34.792]                     workers <- structure(as.integer(workers), 
[16:12:34.792]                       class = class(workers))
[16:12:34.792]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:34.792]                       workers >= 1)
[16:12:34.792]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:34.792]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:34.792]                     }
[16:12:34.792]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:34.792]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:34.792]                       envir = envir)
[16:12:34.792]                     if (!future$lazy) 
[16:12:34.792]                       future <- run(future)
[16:12:34.792]                     invisible(future)
[16:12:34.792]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:34.792]                 }
[16:12:34.792]             }
[16:12:34.792]         }
[16:12:34.792]     })
[16:12:34.792]     if (TRUE) {
[16:12:34.792]         base::sink(type = "output", split = FALSE)
[16:12:34.792]         if (TRUE) {
[16:12:34.792]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:34.792]         }
[16:12:34.792]         else {
[16:12:34.792]             ...future.result["stdout"] <- base::list(NULL)
[16:12:34.792]         }
[16:12:34.792]         base::close(...future.stdout)
[16:12:34.792]         ...future.stdout <- NULL
[16:12:34.792]     }
[16:12:34.792]     ...future.result$conditions <- ...future.conditions
[16:12:34.792]     ...future.result$finished <- base::Sys.time()
[16:12:34.792]     ...future.result
[16:12:34.792] }
[16:12:34.795] Exporting 1 global objects (96 bytes) to cluster node #1 ...
[16:12:34.795] Exporting ‘x’ (96 bytes) to cluster node #1 ...
[16:12:34.795] Exporting ‘x’ (96 bytes) to cluster node #1 ... DONE
[16:12:34.795] Exporting 1 global objects (96 bytes) to cluster node #1 ... DONE
[16:12:34.796] MultisessionFuture started
[16:12:34.796] - Launch lazy future ... done
[16:12:34.796] run() for ‘MultisessionFuture’ ... done
[16:12:34.796] result() for ClusterFuture ...
[16:12:34.797] receiveMessageFromWorker() for ClusterFuture ...
[16:12:34.797] - Validating connection of MultisessionFuture
[16:12:34.845] - received message: FutureResult
[16:12:34.845] - Received FutureResult
[16:12:34.845] - Erased future from FutureRegistry
[16:12:34.845] result() for ClusterFuture ...
[16:12:34.845] - result already collected: FutureResult
[16:12:34.845] result() for ClusterFuture ... done
[16:12:34.845] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:34.845] result() for ClusterFuture ... done
[16:12:34.846] result() for ClusterFuture ...
[16:12:34.846] - result already collected: FutureResult
[16:12:34.846] result() for ClusterFuture ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[16:12:34.847] getGlobalsAndPackages() ...
[16:12:34.847] Searching for globals...
[16:12:34.849] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[16:12:34.849] Searching for globals ... DONE
[16:12:34.849] Resolving globals: FALSE
[16:12:34.850] 
[16:12:34.850] - packages: [2] ‘stats’, ‘datasets’
[16:12:34.850] getGlobalsAndPackages() ... DONE
[16:12:34.850] run() for ‘Future’ ...
[16:12:34.850] - state: ‘created’
[16:12:34.850] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:34.865] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:34.865] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:34.865]   - Field: ‘node’
[16:12:34.865]   - Field: ‘label’
[16:12:34.865]   - Field: ‘local’
[16:12:34.865]   - Field: ‘owner’
[16:12:34.865]   - Field: ‘envir’
[16:12:34.865]   - Field: ‘workers’
[16:12:34.865]   - Field: ‘packages’
[16:12:34.866]   - Field: ‘gc’
[16:12:34.866]   - Field: ‘conditions’
[16:12:34.866]   - Field: ‘persistent’
[16:12:34.866]   - Field: ‘expr’
[16:12:34.866]   - Field: ‘uuid’
[16:12:34.866]   - Field: ‘seed’
[16:12:34.866]   - Field: ‘version’
[16:12:34.866]   - Field: ‘result’
[16:12:34.866]   - Field: ‘asynchronous’
[16:12:34.866]   - Field: ‘calls’
[16:12:34.866]   - Field: ‘globals’
[16:12:34.867]   - Field: ‘stdout’
[16:12:34.867]   - Field: ‘earlySignal’
[16:12:34.867]   - Field: ‘lazy’
[16:12:34.867]   - Field: ‘state’
[16:12:34.867] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:34.867] - Launch lazy future ...
[16:12:34.867] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:12:34.867] Packages needed by future strategies (n = 0): <none>
[16:12:34.868] {
[16:12:34.868]     {
[16:12:34.868]         {
[16:12:34.868]             ...future.startTime <- base::Sys.time()
[16:12:34.868]             {
[16:12:34.868]                 {
[16:12:34.868]                   {
[16:12:34.868]                     {
[16:12:34.868]                       {
[16:12:34.868]                         base::local({
[16:12:34.868]                           has_future <- base::requireNamespace("future", 
[16:12:34.868]                             quietly = TRUE)
[16:12:34.868]                           if (has_future) {
[16:12:34.868]                             ns <- base::getNamespace("future")
[16:12:34.868]                             version <- ns[[".package"]][["version"]]
[16:12:34.868]                             if (is.null(version)) 
[16:12:34.868]                               version <- utils::packageVersion("future")
[16:12:34.868]                           }
[16:12:34.868]                           else {
[16:12:34.868]                             version <- NULL
[16:12:34.868]                           }
[16:12:34.868]                           if (!has_future || version < "1.8.0") {
[16:12:34.868]                             info <- base::c(r_version = base::gsub("R version ", 
[16:12:34.868]                               "", base::R.version$version.string), 
[16:12:34.868]                               platform = base::sprintf("%s (%s-bit)", 
[16:12:34.868]                                 base::R.version$platform, 8 * 
[16:12:34.868]                                   base::.Machine$sizeof.pointer), 
[16:12:34.868]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:34.868]                                 "release", "version")], collapse = " "), 
[16:12:34.868]                               hostname = base::Sys.info()[["nodename"]])
[16:12:34.868]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:12:34.868]                               info)
[16:12:34.868]                             info <- base::paste(info, collapse = "; ")
[16:12:34.868]                             if (!has_future) {
[16:12:34.868]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:34.868]                                 info)
[16:12:34.868]                             }
[16:12:34.868]                             else {
[16:12:34.868]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:34.868]                                 info, version)
[16:12:34.868]                             }
[16:12:34.868]                             base::stop(msg)
[16:12:34.868]                           }
[16:12:34.868]                         })
[16:12:34.868]                       }
[16:12:34.868]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:34.868]                       base::options(mc.cores = 1L)
[16:12:34.868]                     }
[16:12:34.868]                     base::local({
[16:12:34.868]                       for (pkg in c("stats", "datasets")) {
[16:12:34.868]                         base::loadNamespace(pkg)
[16:12:34.868]                         base::library(pkg, character.only = TRUE)
[16:12:34.868]                       }
[16:12:34.868]                     })
[16:12:34.868]                   }
[16:12:34.868]                   options(future.plan = NULL)
[16:12:34.868]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:34.868]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:34.868]                 }
[16:12:34.868]                 ...future.workdir <- getwd()
[16:12:34.868]             }
[16:12:34.868]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:34.868]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:34.868]         }
[16:12:34.868]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:34.868]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:34.868]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:34.868]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:34.868]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:34.868]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:34.868]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:34.868]             base::names(...future.oldOptions))
[16:12:34.868]     }
[16:12:34.868]     if (FALSE) {
[16:12:34.868]     }
[16:12:34.868]     else {
[16:12:34.868]         if (TRUE) {
[16:12:34.868]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:34.868]                 open = "w")
[16:12:34.868]         }
[16:12:34.868]         else {
[16:12:34.868]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:34.868]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:34.868]         }
[16:12:34.868]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:34.868]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:34.868]             base::sink(type = "output", split = FALSE)
[16:12:34.868]             base::close(...future.stdout)
[16:12:34.868]         }, add = TRUE)
[16:12:34.868]     }
[16:12:34.868]     ...future.frame <- base::sys.nframe()
[16:12:34.868]     ...future.conditions <- base::list()
[16:12:34.868]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:34.868]     if (FALSE) {
[16:12:34.868]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:34.868]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:34.868]     }
[16:12:34.868]     ...future.result <- base::tryCatch({
[16:12:34.868]         base::withCallingHandlers({
[16:12:34.868]             ...future.value <- base::withVisible(base::local({
[16:12:34.868]                 ...future.makeSendCondition <- local({
[16:12:34.868]                   sendCondition <- NULL
[16:12:34.868]                   function(frame = 1L) {
[16:12:34.868]                     if (is.function(sendCondition)) 
[16:12:34.868]                       return(sendCondition)
[16:12:34.868]                     ns <- getNamespace("parallel")
[16:12:34.868]                     if (exists("sendData", mode = "function", 
[16:12:34.868]                       envir = ns)) {
[16:12:34.868]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:34.868]                         envir = ns)
[16:12:34.868]                       envir <- sys.frame(frame)
[16:12:34.868]                       master <- NULL
[16:12:34.868]                       while (!identical(envir, .GlobalEnv) && 
[16:12:34.868]                         !identical(envir, emptyenv())) {
[16:12:34.868]                         if (exists("master", mode = "list", envir = envir, 
[16:12:34.868]                           inherits = FALSE)) {
[16:12:34.868]                           master <- get("master", mode = "list", 
[16:12:34.868]                             envir = envir, inherits = FALSE)
[16:12:34.868]                           if (inherits(master, c("SOCKnode", 
[16:12:34.868]                             "SOCK0node"))) {
[16:12:34.868]                             sendCondition <<- function(cond) {
[16:12:34.868]                               data <- list(type = "VALUE", value = cond, 
[16:12:34.868]                                 success = TRUE)
[16:12:34.868]                               parallel_sendData(master, data)
[16:12:34.868]                             }
[16:12:34.868]                             return(sendCondition)
[16:12:34.868]                           }
[16:12:34.868]                         }
[16:12:34.868]                         frame <- frame + 1L
[16:12:34.868]                         envir <- sys.frame(frame)
[16:12:34.868]                       }
[16:12:34.868]                     }
[16:12:34.868]                     sendCondition <<- function(cond) NULL
[16:12:34.868]                   }
[16:12:34.868]                 })
[16:12:34.868]                 withCallingHandlers({
[16:12:34.868]                   {
[16:12:34.868]                     lm(dist ~ . - 1, data = cars)
[16:12:34.868]                   }
[16:12:34.868]                 }, immediateCondition = function(cond) {
[16:12:34.868]                   sendCondition <- ...future.makeSendCondition()
[16:12:34.868]                   sendCondition(cond)
[16:12:34.868]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:34.868]                   {
[16:12:34.868]                     inherits <- base::inherits
[16:12:34.868]                     invokeRestart <- base::invokeRestart
[16:12:34.868]                     is.null <- base::is.null
[16:12:34.868]                     muffled <- FALSE
[16:12:34.868]                     if (inherits(cond, "message")) {
[16:12:34.868]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:34.868]                       if (muffled) 
[16:12:34.868]                         invokeRestart("muffleMessage")
[16:12:34.868]                     }
[16:12:34.868]                     else if (inherits(cond, "warning")) {
[16:12:34.868]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:34.868]                       if (muffled) 
[16:12:34.868]                         invokeRestart("muffleWarning")
[16:12:34.868]                     }
[16:12:34.868]                     else if (inherits(cond, "condition")) {
[16:12:34.868]                       if (!is.null(pattern)) {
[16:12:34.868]                         computeRestarts <- base::computeRestarts
[16:12:34.868]                         grepl <- base::grepl
[16:12:34.868]                         restarts <- computeRestarts(cond)
[16:12:34.868]                         for (restart in restarts) {
[16:12:34.868]                           name <- restart$name
[16:12:34.868]                           if (is.null(name)) 
[16:12:34.868]                             next
[16:12:34.868]                           if (!grepl(pattern, name)) 
[16:12:34.868]                             next
[16:12:34.868]                           invokeRestart(restart)
[16:12:34.868]                           muffled <- TRUE
[16:12:34.868]                           break
[16:12:34.868]                         }
[16:12:34.868]                       }
[16:12:34.868]                     }
[16:12:34.868]                     invisible(muffled)
[16:12:34.868]                   }
[16:12:34.868]                   muffleCondition(cond)
[16:12:34.868]                 })
[16:12:34.868]             }))
[16:12:34.868]             future::FutureResult(value = ...future.value$value, 
[16:12:34.868]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:34.868]                   ...future.rng), globalenv = if (FALSE) 
[16:12:34.868]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:34.868]                     ...future.globalenv.names))
[16:12:34.868]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:34.868]         }, condition = base::local({
[16:12:34.868]             c <- base::c
[16:12:34.868]             inherits <- base::inherits
[16:12:34.868]             invokeRestart <- base::invokeRestart
[16:12:34.868]             length <- base::length
[16:12:34.868]             list <- base::list
[16:12:34.868]             seq.int <- base::seq.int
[16:12:34.868]             signalCondition <- base::signalCondition
[16:12:34.868]             sys.calls <- base::sys.calls
[16:12:34.868]             `[[` <- base::`[[`
[16:12:34.868]             `+` <- base::`+`
[16:12:34.868]             `<<-` <- base::`<<-`
[16:12:34.868]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:34.868]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:34.868]                   3L)]
[16:12:34.868]             }
[16:12:34.868]             function(cond) {
[16:12:34.868]                 is_error <- inherits(cond, "error")
[16:12:34.868]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:34.868]                   NULL)
[16:12:34.868]                 if (is_error) {
[16:12:34.868]                   sessionInformation <- function() {
[16:12:34.868]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:34.868]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:34.868]                       search = base::search(), system = base::Sys.info())
[16:12:34.868]                   }
[16:12:34.868]                   ...future.conditions[[length(...future.conditions) + 
[16:12:34.868]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:34.868]                     cond$call), session = sessionInformation(), 
[16:12:34.868]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:34.868]                   signalCondition(cond)
[16:12:34.868]                 }
[16:12:34.868]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:34.868]                 "immediateCondition"))) {
[16:12:34.868]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:34.868]                   ...future.conditions[[length(...future.conditions) + 
[16:12:34.868]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:34.868]                   if (TRUE && !signal) {
[16:12:34.868]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:34.868]                     {
[16:12:34.868]                       inherits <- base::inherits
[16:12:34.868]                       invokeRestart <- base::invokeRestart
[16:12:34.868]                       is.null <- base::is.null
[16:12:34.868]                       muffled <- FALSE
[16:12:34.868]                       if (inherits(cond, "message")) {
[16:12:34.868]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:34.868]                         if (muffled) 
[16:12:34.868]                           invokeRestart("muffleMessage")
[16:12:34.868]                       }
[16:12:34.868]                       else if (inherits(cond, "warning")) {
[16:12:34.868]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:34.868]                         if (muffled) 
[16:12:34.868]                           invokeRestart("muffleWarning")
[16:12:34.868]                       }
[16:12:34.868]                       else if (inherits(cond, "condition")) {
[16:12:34.868]                         if (!is.null(pattern)) {
[16:12:34.868]                           computeRestarts <- base::computeRestarts
[16:12:34.868]                           grepl <- base::grepl
[16:12:34.868]                           restarts <- computeRestarts(cond)
[16:12:34.868]                           for (restart in restarts) {
[16:12:34.868]                             name <- restart$name
[16:12:34.868]                             if (is.null(name)) 
[16:12:34.868]                               next
[16:12:34.868]                             if (!grepl(pattern, name)) 
[16:12:34.868]                               next
[16:12:34.868]                             invokeRestart(restart)
[16:12:34.868]                             muffled <- TRUE
[16:12:34.868]                             break
[16:12:34.868]                           }
[16:12:34.868]                         }
[16:12:34.868]                       }
[16:12:34.868]                       invisible(muffled)
[16:12:34.868]                     }
[16:12:34.868]                     muffleCondition(cond, pattern = "^muffle")
[16:12:34.868]                   }
[16:12:34.868]                 }
[16:12:34.868]                 else {
[16:12:34.868]                   if (TRUE) {
[16:12:34.868]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:34.868]                     {
[16:12:34.868]                       inherits <- base::inherits
[16:12:34.868]                       invokeRestart <- base::invokeRestart
[16:12:34.868]                       is.null <- base::is.null
[16:12:34.868]                       muffled <- FALSE
[16:12:34.868]                       if (inherits(cond, "message")) {
[16:12:34.868]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:34.868]                         if (muffled) 
[16:12:34.868]                           invokeRestart("muffleMessage")
[16:12:34.868]                       }
[16:12:34.868]                       else if (inherits(cond, "warning")) {
[16:12:34.868]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:34.868]                         if (muffled) 
[16:12:34.868]                           invokeRestart("muffleWarning")
[16:12:34.868]                       }
[16:12:34.868]                       else if (inherits(cond, "condition")) {
[16:12:34.868]                         if (!is.null(pattern)) {
[16:12:34.868]                           computeRestarts <- base::computeRestarts
[16:12:34.868]                           grepl <- base::grepl
[16:12:34.868]                           restarts <- computeRestarts(cond)
[16:12:34.868]                           for (restart in restarts) {
[16:12:34.868]                             name <- restart$name
[16:12:34.868]                             if (is.null(name)) 
[16:12:34.868]                               next
[16:12:34.868]                             if (!grepl(pattern, name)) 
[16:12:34.868]                               next
[16:12:34.868]                             invokeRestart(restart)
[16:12:34.868]                             muffled <- TRUE
[16:12:34.868]                             break
[16:12:34.868]                           }
[16:12:34.868]                         }
[16:12:34.868]                       }
[16:12:34.868]                       invisible(muffled)
[16:12:34.868]                     }
[16:12:34.868]                     muffleCondition(cond, pattern = "^muffle")
[16:12:34.868]                   }
[16:12:34.868]                 }
[16:12:34.868]             }
[16:12:34.868]         }))
[16:12:34.868]     }, error = function(ex) {
[16:12:34.868]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:34.868]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:34.868]                 ...future.rng), started = ...future.startTime, 
[16:12:34.868]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:34.868]             version = "1.8"), class = "FutureResult")
[16:12:34.868]     }, finally = {
[16:12:34.868]         if (!identical(...future.workdir, getwd())) 
[16:12:34.868]             setwd(...future.workdir)
[16:12:34.868]         {
[16:12:34.868]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:34.868]                 ...future.oldOptions$nwarnings <- NULL
[16:12:34.868]             }
[16:12:34.868]             base::options(...future.oldOptions)
[16:12:34.868]             if (.Platform$OS.type == "windows") {
[16:12:34.868]                 old_names <- names(...future.oldEnvVars)
[16:12:34.868]                 envs <- base::Sys.getenv()
[16:12:34.868]                 names <- names(envs)
[16:12:34.868]                 common <- intersect(names, old_names)
[16:12:34.868]                 added <- setdiff(names, old_names)
[16:12:34.868]                 removed <- setdiff(old_names, names)
[16:12:34.868]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:34.868]                   envs[common]]
[16:12:34.868]                 NAMES <- toupper(changed)
[16:12:34.868]                 args <- list()
[16:12:34.868]                 for (kk in seq_along(NAMES)) {
[16:12:34.868]                   name <- changed[[kk]]
[16:12:34.868]                   NAME <- NAMES[[kk]]
[16:12:34.868]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:34.868]                     next
[16:12:34.868]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:34.868]                 }
[16:12:34.868]                 NAMES <- toupper(added)
[16:12:34.868]                 for (kk in seq_along(NAMES)) {
[16:12:34.868]                   name <- added[[kk]]
[16:12:34.868]                   NAME <- NAMES[[kk]]
[16:12:34.868]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:34.868]                     next
[16:12:34.868]                   args[[name]] <- ""
[16:12:34.868]                 }
[16:12:34.868]                 NAMES <- toupper(removed)
[16:12:34.868]                 for (kk in seq_along(NAMES)) {
[16:12:34.868]                   name <- removed[[kk]]
[16:12:34.868]                   NAME <- NAMES[[kk]]
[16:12:34.868]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:34.868]                     next
[16:12:34.868]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:34.868]                 }
[16:12:34.868]                 if (length(args) > 0) 
[16:12:34.868]                   base::do.call(base::Sys.setenv, args = args)
[16:12:34.868]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:34.868]             }
[16:12:34.868]             else {
[16:12:34.868]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:34.868]             }
[16:12:34.868]             {
[16:12:34.868]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:34.868]                   0L) {
[16:12:34.868]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:34.868]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:34.868]                   base::options(opts)
[16:12:34.868]                 }
[16:12:34.868]                 {
[16:12:34.868]                   {
[16:12:34.868]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:34.868]                     NULL
[16:12:34.868]                   }
[16:12:34.868]                   options(future.plan = NULL)
[16:12:34.868]                   if (is.na(NA_character_)) 
[16:12:34.868]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:34.868]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:34.868]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:34.868]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:34.868]                     envir = parent.frame()) 
[16:12:34.868]                   {
[16:12:34.868]                     if (is.function(workers)) 
[16:12:34.868]                       workers <- workers()
[16:12:34.868]                     workers <- structure(as.integer(workers), 
[16:12:34.868]                       class = class(workers))
[16:12:34.868]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:34.868]                       workers >= 1)
[16:12:34.868]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:34.868]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:34.868]                     }
[16:12:34.868]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:34.868]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:34.868]                       envir = envir)
[16:12:34.868]                     if (!future$lazy) 
[16:12:34.868]                       future <- run(future)
[16:12:34.868]                     invisible(future)
[16:12:34.868]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:34.868]                 }
[16:12:34.868]             }
[16:12:34.868]         }
[16:12:34.868]     })
[16:12:34.868]     if (TRUE) {
[16:12:34.868]         base::sink(type = "output", split = FALSE)
[16:12:34.868]         if (TRUE) {
[16:12:34.868]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:34.868]         }
[16:12:34.868]         else {
[16:12:34.868]             ...future.result["stdout"] <- base::list(NULL)
[16:12:34.868]         }
[16:12:34.868]         base::close(...future.stdout)
[16:12:34.868]         ...future.stdout <- NULL
[16:12:34.868]     }
[16:12:34.868]     ...future.result$conditions <- ...future.conditions
[16:12:34.868]     ...future.result$finished <- base::Sys.time()
[16:12:34.868]     ...future.result
[16:12:34.868] }
[16:12:34.871] MultisessionFuture started
[16:12:34.871] - Launch lazy future ... done
[16:12:34.872] run() for ‘MultisessionFuture’ ... done
[16:12:34.872] result() for ClusterFuture ...
[16:12:34.872] receiveMessageFromWorker() for ClusterFuture ...
[16:12:34.872] - Validating connection of MultisessionFuture
[16:12:34.920] - received message: FutureResult
[16:12:34.920] - Received FutureResult
[16:12:34.921] - Erased future from FutureRegistry
[16:12:34.921] result() for ClusterFuture ...
[16:12:34.921] - result already collected: FutureResult
[16:12:34.921] result() for ClusterFuture ... done
[16:12:34.921] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:34.921] result() for ClusterFuture ... done
[16:12:34.921] result() for ClusterFuture ...
[16:12:34.921] - result already collected: FutureResult
[16:12:34.921] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[16:12:34.926] getGlobalsAndPackages() ...
[16:12:34.926] Searching for globals...
[16:12:34.928] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[16:12:34.928] Searching for globals ... DONE
[16:12:34.928] Resolving globals: FALSE
[16:12:34.929] 
[16:12:34.929] - packages: [2] ‘stats’, ‘datasets’
[16:12:34.929] getGlobalsAndPackages() ... DONE
[16:12:34.929] run() for ‘Future’ ...
[16:12:34.929] - state: ‘created’
[16:12:34.929] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:34.944] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:34.944] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:34.944]   - Field: ‘node’
[16:12:34.944]   - Field: ‘label’
[16:12:34.944]   - Field: ‘local’
[16:12:34.944]   - Field: ‘owner’
[16:12:34.944]   - Field: ‘envir’
[16:12:34.945]   - Field: ‘workers’
[16:12:34.945]   - Field: ‘packages’
[16:12:34.945]   - Field: ‘gc’
[16:12:34.945]   - Field: ‘conditions’
[16:12:34.945]   - Field: ‘persistent’
[16:12:34.945]   - Field: ‘expr’
[16:12:34.945]   - Field: ‘uuid’
[16:12:34.945]   - Field: ‘seed’
[16:12:34.945]   - Field: ‘version’
[16:12:34.945]   - Field: ‘result’
[16:12:34.945]   - Field: ‘asynchronous’
[16:12:34.945]   - Field: ‘calls’
[16:12:34.946]   - Field: ‘globals’
[16:12:34.946]   - Field: ‘stdout’
[16:12:34.946]   - Field: ‘earlySignal’
[16:12:34.946]   - Field: ‘lazy’
[16:12:34.946]   - Field: ‘state’
[16:12:34.946] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:34.946] - Launch lazy future ...
[16:12:34.946] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:12:34.946] Packages needed by future strategies (n = 0): <none>
[16:12:34.947] {
[16:12:34.947]     {
[16:12:34.947]         {
[16:12:34.947]             ...future.startTime <- base::Sys.time()
[16:12:34.947]             {
[16:12:34.947]                 {
[16:12:34.947]                   {
[16:12:34.947]                     {
[16:12:34.947]                       {
[16:12:34.947]                         base::local({
[16:12:34.947]                           has_future <- base::requireNamespace("future", 
[16:12:34.947]                             quietly = TRUE)
[16:12:34.947]                           if (has_future) {
[16:12:34.947]                             ns <- base::getNamespace("future")
[16:12:34.947]                             version <- ns[[".package"]][["version"]]
[16:12:34.947]                             if (is.null(version)) 
[16:12:34.947]                               version <- utils::packageVersion("future")
[16:12:34.947]                           }
[16:12:34.947]                           else {
[16:12:34.947]                             version <- NULL
[16:12:34.947]                           }
[16:12:34.947]                           if (!has_future || version < "1.8.0") {
[16:12:34.947]                             info <- base::c(r_version = base::gsub("R version ", 
[16:12:34.947]                               "", base::R.version$version.string), 
[16:12:34.947]                               platform = base::sprintf("%s (%s-bit)", 
[16:12:34.947]                                 base::R.version$platform, 8 * 
[16:12:34.947]                                   base::.Machine$sizeof.pointer), 
[16:12:34.947]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:34.947]                                 "release", "version")], collapse = " "), 
[16:12:34.947]                               hostname = base::Sys.info()[["nodename"]])
[16:12:34.947]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:12:34.947]                               info)
[16:12:34.947]                             info <- base::paste(info, collapse = "; ")
[16:12:34.947]                             if (!has_future) {
[16:12:34.947]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:34.947]                                 info)
[16:12:34.947]                             }
[16:12:34.947]                             else {
[16:12:34.947]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:34.947]                                 info, version)
[16:12:34.947]                             }
[16:12:34.947]                             base::stop(msg)
[16:12:34.947]                           }
[16:12:34.947]                         })
[16:12:34.947]                       }
[16:12:34.947]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:34.947]                       base::options(mc.cores = 1L)
[16:12:34.947]                     }
[16:12:34.947]                     base::local({
[16:12:34.947]                       for (pkg in c("stats", "datasets")) {
[16:12:34.947]                         base::loadNamespace(pkg)
[16:12:34.947]                         base::library(pkg, character.only = TRUE)
[16:12:34.947]                       }
[16:12:34.947]                     })
[16:12:34.947]                   }
[16:12:34.947]                   options(future.plan = NULL)
[16:12:34.947]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:34.947]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:34.947]                 }
[16:12:34.947]                 ...future.workdir <- getwd()
[16:12:34.947]             }
[16:12:34.947]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:34.947]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:34.947]         }
[16:12:34.947]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:34.947]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:34.947]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:34.947]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:34.947]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:34.947]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:34.947]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:34.947]             base::names(...future.oldOptions))
[16:12:34.947]     }
[16:12:34.947]     if (FALSE) {
[16:12:34.947]     }
[16:12:34.947]     else {
[16:12:34.947]         if (TRUE) {
[16:12:34.947]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:34.947]                 open = "w")
[16:12:34.947]         }
[16:12:34.947]         else {
[16:12:34.947]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:34.947]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:34.947]         }
[16:12:34.947]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:34.947]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:34.947]             base::sink(type = "output", split = FALSE)
[16:12:34.947]             base::close(...future.stdout)
[16:12:34.947]         }, add = TRUE)
[16:12:34.947]     }
[16:12:34.947]     ...future.frame <- base::sys.nframe()
[16:12:34.947]     ...future.conditions <- base::list()
[16:12:34.947]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:34.947]     if (FALSE) {
[16:12:34.947]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:34.947]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:34.947]     }
[16:12:34.947]     ...future.result <- base::tryCatch({
[16:12:34.947]         base::withCallingHandlers({
[16:12:34.947]             ...future.value <- base::withVisible(base::local({
[16:12:34.947]                 ...future.makeSendCondition <- local({
[16:12:34.947]                   sendCondition <- NULL
[16:12:34.947]                   function(frame = 1L) {
[16:12:34.947]                     if (is.function(sendCondition)) 
[16:12:34.947]                       return(sendCondition)
[16:12:34.947]                     ns <- getNamespace("parallel")
[16:12:34.947]                     if (exists("sendData", mode = "function", 
[16:12:34.947]                       envir = ns)) {
[16:12:34.947]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:34.947]                         envir = ns)
[16:12:34.947]                       envir <- sys.frame(frame)
[16:12:34.947]                       master <- NULL
[16:12:34.947]                       while (!identical(envir, .GlobalEnv) && 
[16:12:34.947]                         !identical(envir, emptyenv())) {
[16:12:34.947]                         if (exists("master", mode = "list", envir = envir, 
[16:12:34.947]                           inherits = FALSE)) {
[16:12:34.947]                           master <- get("master", mode = "list", 
[16:12:34.947]                             envir = envir, inherits = FALSE)
[16:12:34.947]                           if (inherits(master, c("SOCKnode", 
[16:12:34.947]                             "SOCK0node"))) {
[16:12:34.947]                             sendCondition <<- function(cond) {
[16:12:34.947]                               data <- list(type = "VALUE", value = cond, 
[16:12:34.947]                                 success = TRUE)
[16:12:34.947]                               parallel_sendData(master, data)
[16:12:34.947]                             }
[16:12:34.947]                             return(sendCondition)
[16:12:34.947]                           }
[16:12:34.947]                         }
[16:12:34.947]                         frame <- frame + 1L
[16:12:34.947]                         envir <- sys.frame(frame)
[16:12:34.947]                       }
[16:12:34.947]                     }
[16:12:34.947]                     sendCondition <<- function(cond) NULL
[16:12:34.947]                   }
[16:12:34.947]                 })
[16:12:34.947]                 withCallingHandlers({
[16:12:34.947]                   {
[16:12:34.947]                     lm(dist ~ . + 0, data = cars)
[16:12:34.947]                   }
[16:12:34.947]                 }, immediateCondition = function(cond) {
[16:12:34.947]                   sendCondition <- ...future.makeSendCondition()
[16:12:34.947]                   sendCondition(cond)
[16:12:34.947]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:34.947]                   {
[16:12:34.947]                     inherits <- base::inherits
[16:12:34.947]                     invokeRestart <- base::invokeRestart
[16:12:34.947]                     is.null <- base::is.null
[16:12:34.947]                     muffled <- FALSE
[16:12:34.947]                     if (inherits(cond, "message")) {
[16:12:34.947]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:34.947]                       if (muffled) 
[16:12:34.947]                         invokeRestart("muffleMessage")
[16:12:34.947]                     }
[16:12:34.947]                     else if (inherits(cond, "warning")) {
[16:12:34.947]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:34.947]                       if (muffled) 
[16:12:34.947]                         invokeRestart("muffleWarning")
[16:12:34.947]                     }
[16:12:34.947]                     else if (inherits(cond, "condition")) {
[16:12:34.947]                       if (!is.null(pattern)) {
[16:12:34.947]                         computeRestarts <- base::computeRestarts
[16:12:34.947]                         grepl <- base::grepl
[16:12:34.947]                         restarts <- computeRestarts(cond)
[16:12:34.947]                         for (restart in restarts) {
[16:12:34.947]                           name <- restart$name
[16:12:34.947]                           if (is.null(name)) 
[16:12:34.947]                             next
[16:12:34.947]                           if (!grepl(pattern, name)) 
[16:12:34.947]                             next
[16:12:34.947]                           invokeRestart(restart)
[16:12:34.947]                           muffled <- TRUE
[16:12:34.947]                           break
[16:12:34.947]                         }
[16:12:34.947]                       }
[16:12:34.947]                     }
[16:12:34.947]                     invisible(muffled)
[16:12:34.947]                   }
[16:12:34.947]                   muffleCondition(cond)
[16:12:34.947]                 })
[16:12:34.947]             }))
[16:12:34.947]             future::FutureResult(value = ...future.value$value, 
[16:12:34.947]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:34.947]                   ...future.rng), globalenv = if (FALSE) 
[16:12:34.947]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:34.947]                     ...future.globalenv.names))
[16:12:34.947]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:34.947]         }, condition = base::local({
[16:12:34.947]             c <- base::c
[16:12:34.947]             inherits <- base::inherits
[16:12:34.947]             invokeRestart <- base::invokeRestart
[16:12:34.947]             length <- base::length
[16:12:34.947]             list <- base::list
[16:12:34.947]             seq.int <- base::seq.int
[16:12:34.947]             signalCondition <- base::signalCondition
[16:12:34.947]             sys.calls <- base::sys.calls
[16:12:34.947]             `[[` <- base::`[[`
[16:12:34.947]             `+` <- base::`+`
[16:12:34.947]             `<<-` <- base::`<<-`
[16:12:34.947]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:34.947]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:34.947]                   3L)]
[16:12:34.947]             }
[16:12:34.947]             function(cond) {
[16:12:34.947]                 is_error <- inherits(cond, "error")
[16:12:34.947]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:34.947]                   NULL)
[16:12:34.947]                 if (is_error) {
[16:12:34.947]                   sessionInformation <- function() {
[16:12:34.947]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:34.947]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:34.947]                       search = base::search(), system = base::Sys.info())
[16:12:34.947]                   }
[16:12:34.947]                   ...future.conditions[[length(...future.conditions) + 
[16:12:34.947]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:34.947]                     cond$call), session = sessionInformation(), 
[16:12:34.947]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:34.947]                   signalCondition(cond)
[16:12:34.947]                 }
[16:12:34.947]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:34.947]                 "immediateCondition"))) {
[16:12:34.947]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:34.947]                   ...future.conditions[[length(...future.conditions) + 
[16:12:34.947]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:34.947]                   if (TRUE && !signal) {
[16:12:34.947]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:34.947]                     {
[16:12:34.947]                       inherits <- base::inherits
[16:12:34.947]                       invokeRestart <- base::invokeRestart
[16:12:34.947]                       is.null <- base::is.null
[16:12:34.947]                       muffled <- FALSE
[16:12:34.947]                       if (inherits(cond, "message")) {
[16:12:34.947]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:34.947]                         if (muffled) 
[16:12:34.947]                           invokeRestart("muffleMessage")
[16:12:34.947]                       }
[16:12:34.947]                       else if (inherits(cond, "warning")) {
[16:12:34.947]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:34.947]                         if (muffled) 
[16:12:34.947]                           invokeRestart("muffleWarning")
[16:12:34.947]                       }
[16:12:34.947]                       else if (inherits(cond, "condition")) {
[16:12:34.947]                         if (!is.null(pattern)) {
[16:12:34.947]                           computeRestarts <- base::computeRestarts
[16:12:34.947]                           grepl <- base::grepl
[16:12:34.947]                           restarts <- computeRestarts(cond)
[16:12:34.947]                           for (restart in restarts) {
[16:12:34.947]                             name <- restart$name
[16:12:34.947]                             if (is.null(name)) 
[16:12:34.947]                               next
[16:12:34.947]                             if (!grepl(pattern, name)) 
[16:12:34.947]                               next
[16:12:34.947]                             invokeRestart(restart)
[16:12:34.947]                             muffled <- TRUE
[16:12:34.947]                             break
[16:12:34.947]                           }
[16:12:34.947]                         }
[16:12:34.947]                       }
[16:12:34.947]                       invisible(muffled)
[16:12:34.947]                     }
[16:12:34.947]                     muffleCondition(cond, pattern = "^muffle")
[16:12:34.947]                   }
[16:12:34.947]                 }
[16:12:34.947]                 else {
[16:12:34.947]                   if (TRUE) {
[16:12:34.947]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:34.947]                     {
[16:12:34.947]                       inherits <- base::inherits
[16:12:34.947]                       invokeRestart <- base::invokeRestart
[16:12:34.947]                       is.null <- base::is.null
[16:12:34.947]                       muffled <- FALSE
[16:12:34.947]                       if (inherits(cond, "message")) {
[16:12:34.947]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:34.947]                         if (muffled) 
[16:12:34.947]                           invokeRestart("muffleMessage")
[16:12:34.947]                       }
[16:12:34.947]                       else if (inherits(cond, "warning")) {
[16:12:34.947]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:34.947]                         if (muffled) 
[16:12:34.947]                           invokeRestart("muffleWarning")
[16:12:34.947]                       }
[16:12:34.947]                       else if (inherits(cond, "condition")) {
[16:12:34.947]                         if (!is.null(pattern)) {
[16:12:34.947]                           computeRestarts <- base::computeRestarts
[16:12:34.947]                           grepl <- base::grepl
[16:12:34.947]                           restarts <- computeRestarts(cond)
[16:12:34.947]                           for (restart in restarts) {
[16:12:34.947]                             name <- restart$name
[16:12:34.947]                             if (is.null(name)) 
[16:12:34.947]                               next
[16:12:34.947]                             if (!grepl(pattern, name)) 
[16:12:34.947]                               next
[16:12:34.947]                             invokeRestart(restart)
[16:12:34.947]                             muffled <- TRUE
[16:12:34.947]                             break
[16:12:34.947]                           }
[16:12:34.947]                         }
[16:12:34.947]                       }
[16:12:34.947]                       invisible(muffled)
[16:12:34.947]                     }
[16:12:34.947]                     muffleCondition(cond, pattern = "^muffle")
[16:12:34.947]                   }
[16:12:34.947]                 }
[16:12:34.947]             }
[16:12:34.947]         }))
[16:12:34.947]     }, error = function(ex) {
[16:12:34.947]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:34.947]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:34.947]                 ...future.rng), started = ...future.startTime, 
[16:12:34.947]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:34.947]             version = "1.8"), class = "FutureResult")
[16:12:34.947]     }, finally = {
[16:12:34.947]         if (!identical(...future.workdir, getwd())) 
[16:12:34.947]             setwd(...future.workdir)
[16:12:34.947]         {
[16:12:34.947]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:34.947]                 ...future.oldOptions$nwarnings <- NULL
[16:12:34.947]             }
[16:12:34.947]             base::options(...future.oldOptions)
[16:12:34.947]             if (.Platform$OS.type == "windows") {
[16:12:34.947]                 old_names <- names(...future.oldEnvVars)
[16:12:34.947]                 envs <- base::Sys.getenv()
[16:12:34.947]                 names <- names(envs)
[16:12:34.947]                 common <- intersect(names, old_names)
[16:12:34.947]                 added <- setdiff(names, old_names)
[16:12:34.947]                 removed <- setdiff(old_names, names)
[16:12:34.947]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:34.947]                   envs[common]]
[16:12:34.947]                 NAMES <- toupper(changed)
[16:12:34.947]                 args <- list()
[16:12:34.947]                 for (kk in seq_along(NAMES)) {
[16:12:34.947]                   name <- changed[[kk]]
[16:12:34.947]                   NAME <- NAMES[[kk]]
[16:12:34.947]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:34.947]                     next
[16:12:34.947]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:34.947]                 }
[16:12:34.947]                 NAMES <- toupper(added)
[16:12:34.947]                 for (kk in seq_along(NAMES)) {
[16:12:34.947]                   name <- added[[kk]]
[16:12:34.947]                   NAME <- NAMES[[kk]]
[16:12:34.947]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:34.947]                     next
[16:12:34.947]                   args[[name]] <- ""
[16:12:34.947]                 }
[16:12:34.947]                 NAMES <- toupper(removed)
[16:12:34.947]                 for (kk in seq_along(NAMES)) {
[16:12:34.947]                   name <- removed[[kk]]
[16:12:34.947]                   NAME <- NAMES[[kk]]
[16:12:34.947]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:34.947]                     next
[16:12:34.947]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:34.947]                 }
[16:12:34.947]                 if (length(args) > 0) 
[16:12:34.947]                   base::do.call(base::Sys.setenv, args = args)
[16:12:34.947]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:34.947]             }
[16:12:34.947]             else {
[16:12:34.947]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:34.947]             }
[16:12:34.947]             {
[16:12:34.947]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:34.947]                   0L) {
[16:12:34.947]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:34.947]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:34.947]                   base::options(opts)
[16:12:34.947]                 }
[16:12:34.947]                 {
[16:12:34.947]                   {
[16:12:34.947]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:34.947]                     NULL
[16:12:34.947]                   }
[16:12:34.947]                   options(future.plan = NULL)
[16:12:34.947]                   if (is.na(NA_character_)) 
[16:12:34.947]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:34.947]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:34.947]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:34.947]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:34.947]                     envir = parent.frame()) 
[16:12:34.947]                   {
[16:12:34.947]                     if (is.function(workers)) 
[16:12:34.947]                       workers <- workers()
[16:12:34.947]                     workers <- structure(as.integer(workers), 
[16:12:34.947]                       class = class(workers))
[16:12:34.947]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:34.947]                       workers >= 1)
[16:12:34.947]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:34.947]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:34.947]                     }
[16:12:34.947]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:34.947]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:34.947]                       envir = envir)
[16:12:34.947]                     if (!future$lazy) 
[16:12:34.947]                       future <- run(future)
[16:12:34.947]                     invisible(future)
[16:12:34.947]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:34.947]                 }
[16:12:34.947]             }
[16:12:34.947]         }
[16:12:34.947]     })
[16:12:34.947]     if (TRUE) {
[16:12:34.947]         base::sink(type = "output", split = FALSE)
[16:12:34.947]         if (TRUE) {
[16:12:34.947]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:34.947]         }
[16:12:34.947]         else {
[16:12:34.947]             ...future.result["stdout"] <- base::list(NULL)
[16:12:34.947]         }
[16:12:34.947]         base::close(...future.stdout)
[16:12:34.947]         ...future.stdout <- NULL
[16:12:34.947]     }
[16:12:34.947]     ...future.result$conditions <- ...future.conditions
[16:12:34.947]     ...future.result$finished <- base::Sys.time()
[16:12:34.947]     ...future.result
[16:12:34.947] }
[16:12:34.950] MultisessionFuture started
[16:12:34.950] - Launch lazy future ... done
[16:12:34.950] run() for ‘MultisessionFuture’ ... done
[16:12:34.951] result() for ClusterFuture ...
[16:12:34.951] receiveMessageFromWorker() for ClusterFuture ...
[16:12:34.951] - Validating connection of MultisessionFuture
[16:12:34.997] - received message: FutureResult
[16:12:34.997] - Received FutureResult
[16:12:34.998] - Erased future from FutureRegistry
[16:12:34.998] result() for ClusterFuture ...
[16:12:34.998] - result already collected: FutureResult
[16:12:34.998] result() for ClusterFuture ... done
[16:12:34.998] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:34.998] result() for ClusterFuture ... done
[16:12:34.998] result() for ClusterFuture ...
[16:12:34.998] - result already collected: FutureResult
[16:12:34.998] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[16:12:35.001] getGlobalsAndPackages() ...
[16:12:35.001] Searching for globals...
[16:12:35.002] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[16:12:35.003] Searching for globals ... DONE
[16:12:35.003] Resolving globals: FALSE
[16:12:35.003] 
[16:12:35.003] - packages: [2] ‘stats’, ‘datasets’
[16:12:35.003] getGlobalsAndPackages() ... DONE
[16:12:35.004] run() for ‘Future’ ...
[16:12:35.004] - state: ‘created’
[16:12:35.004] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:35.018] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:35.018] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:35.019]   - Field: ‘node’
[16:12:35.019]   - Field: ‘label’
[16:12:35.019]   - Field: ‘local’
[16:12:35.019]   - Field: ‘owner’
[16:12:35.019]   - Field: ‘envir’
[16:12:35.019]   - Field: ‘workers’
[16:12:35.019]   - Field: ‘packages’
[16:12:35.019]   - Field: ‘gc’
[16:12:35.019]   - Field: ‘conditions’
[16:12:35.019]   - Field: ‘persistent’
[16:12:35.020]   - Field: ‘expr’
[16:12:35.020]   - Field: ‘uuid’
[16:12:35.020]   - Field: ‘seed’
[16:12:35.020]   - Field: ‘version’
[16:12:35.020]   - Field: ‘result’
[16:12:35.020]   - Field: ‘asynchronous’
[16:12:35.020]   - Field: ‘calls’
[16:12:35.020]   - Field: ‘globals’
[16:12:35.020]   - Field: ‘stdout’
[16:12:35.020]   - Field: ‘earlySignal’
[16:12:35.020]   - Field: ‘lazy’
[16:12:35.021]   - Field: ‘state’
[16:12:35.021] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:35.021] - Launch lazy future ...
[16:12:35.021] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:12:35.021] Packages needed by future strategies (n = 0): <none>
[16:12:35.022] {
[16:12:35.022]     {
[16:12:35.022]         {
[16:12:35.022]             ...future.startTime <- base::Sys.time()
[16:12:35.022]             {
[16:12:35.022]                 {
[16:12:35.022]                   {
[16:12:35.022]                     {
[16:12:35.022]                       {
[16:12:35.022]                         base::local({
[16:12:35.022]                           has_future <- base::requireNamespace("future", 
[16:12:35.022]                             quietly = TRUE)
[16:12:35.022]                           if (has_future) {
[16:12:35.022]                             ns <- base::getNamespace("future")
[16:12:35.022]                             version <- ns[[".package"]][["version"]]
[16:12:35.022]                             if (is.null(version)) 
[16:12:35.022]                               version <- utils::packageVersion("future")
[16:12:35.022]                           }
[16:12:35.022]                           else {
[16:12:35.022]                             version <- NULL
[16:12:35.022]                           }
[16:12:35.022]                           if (!has_future || version < "1.8.0") {
[16:12:35.022]                             info <- base::c(r_version = base::gsub("R version ", 
[16:12:35.022]                               "", base::R.version$version.string), 
[16:12:35.022]                               platform = base::sprintf("%s (%s-bit)", 
[16:12:35.022]                                 base::R.version$platform, 8 * 
[16:12:35.022]                                   base::.Machine$sizeof.pointer), 
[16:12:35.022]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:35.022]                                 "release", "version")], collapse = " "), 
[16:12:35.022]                               hostname = base::Sys.info()[["nodename"]])
[16:12:35.022]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:12:35.022]                               info)
[16:12:35.022]                             info <- base::paste(info, collapse = "; ")
[16:12:35.022]                             if (!has_future) {
[16:12:35.022]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:35.022]                                 info)
[16:12:35.022]                             }
[16:12:35.022]                             else {
[16:12:35.022]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:35.022]                                 info, version)
[16:12:35.022]                             }
[16:12:35.022]                             base::stop(msg)
[16:12:35.022]                           }
[16:12:35.022]                         })
[16:12:35.022]                       }
[16:12:35.022]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:35.022]                       base::options(mc.cores = 1L)
[16:12:35.022]                     }
[16:12:35.022]                     base::local({
[16:12:35.022]                       for (pkg in c("stats", "datasets")) {
[16:12:35.022]                         base::loadNamespace(pkg)
[16:12:35.022]                         base::library(pkg, character.only = TRUE)
[16:12:35.022]                       }
[16:12:35.022]                     })
[16:12:35.022]                   }
[16:12:35.022]                   options(future.plan = NULL)
[16:12:35.022]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:35.022]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:35.022]                 }
[16:12:35.022]                 ...future.workdir <- getwd()
[16:12:35.022]             }
[16:12:35.022]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:35.022]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:35.022]         }
[16:12:35.022]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:35.022]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:35.022]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:35.022]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:35.022]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:35.022]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:35.022]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:35.022]             base::names(...future.oldOptions))
[16:12:35.022]     }
[16:12:35.022]     if (FALSE) {
[16:12:35.022]     }
[16:12:35.022]     else {
[16:12:35.022]         if (TRUE) {
[16:12:35.022]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:35.022]                 open = "w")
[16:12:35.022]         }
[16:12:35.022]         else {
[16:12:35.022]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:35.022]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:35.022]         }
[16:12:35.022]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:35.022]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:35.022]             base::sink(type = "output", split = FALSE)
[16:12:35.022]             base::close(...future.stdout)
[16:12:35.022]         }, add = TRUE)
[16:12:35.022]     }
[16:12:35.022]     ...future.frame <- base::sys.nframe()
[16:12:35.022]     ...future.conditions <- base::list()
[16:12:35.022]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:35.022]     if (FALSE) {
[16:12:35.022]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:35.022]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:35.022]     }
[16:12:35.022]     ...future.result <- base::tryCatch({
[16:12:35.022]         base::withCallingHandlers({
[16:12:35.022]             ...future.value <- base::withVisible(base::local({
[16:12:35.022]                 ...future.makeSendCondition <- local({
[16:12:35.022]                   sendCondition <- NULL
[16:12:35.022]                   function(frame = 1L) {
[16:12:35.022]                     if (is.function(sendCondition)) 
[16:12:35.022]                       return(sendCondition)
[16:12:35.022]                     ns <- getNamespace("parallel")
[16:12:35.022]                     if (exists("sendData", mode = "function", 
[16:12:35.022]                       envir = ns)) {
[16:12:35.022]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:35.022]                         envir = ns)
[16:12:35.022]                       envir <- sys.frame(frame)
[16:12:35.022]                       master <- NULL
[16:12:35.022]                       while (!identical(envir, .GlobalEnv) && 
[16:12:35.022]                         !identical(envir, emptyenv())) {
[16:12:35.022]                         if (exists("master", mode = "list", envir = envir, 
[16:12:35.022]                           inherits = FALSE)) {
[16:12:35.022]                           master <- get("master", mode = "list", 
[16:12:35.022]                             envir = envir, inherits = FALSE)
[16:12:35.022]                           if (inherits(master, c("SOCKnode", 
[16:12:35.022]                             "SOCK0node"))) {
[16:12:35.022]                             sendCondition <<- function(cond) {
[16:12:35.022]                               data <- list(type = "VALUE", value = cond, 
[16:12:35.022]                                 success = TRUE)
[16:12:35.022]                               parallel_sendData(master, data)
[16:12:35.022]                             }
[16:12:35.022]                             return(sendCondition)
[16:12:35.022]                           }
[16:12:35.022]                         }
[16:12:35.022]                         frame <- frame + 1L
[16:12:35.022]                         envir <- sys.frame(frame)
[16:12:35.022]                       }
[16:12:35.022]                     }
[16:12:35.022]                     sendCondition <<- function(cond) NULL
[16:12:35.022]                   }
[16:12:35.022]                 })
[16:12:35.022]                 withCallingHandlers({
[16:12:35.022]                   {
[16:12:35.022]                     lm(dist ~ speed + speed^2, data = cars)
[16:12:35.022]                   }
[16:12:35.022]                 }, immediateCondition = function(cond) {
[16:12:35.022]                   sendCondition <- ...future.makeSendCondition()
[16:12:35.022]                   sendCondition(cond)
[16:12:35.022]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:35.022]                   {
[16:12:35.022]                     inherits <- base::inherits
[16:12:35.022]                     invokeRestart <- base::invokeRestart
[16:12:35.022]                     is.null <- base::is.null
[16:12:35.022]                     muffled <- FALSE
[16:12:35.022]                     if (inherits(cond, "message")) {
[16:12:35.022]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:35.022]                       if (muffled) 
[16:12:35.022]                         invokeRestart("muffleMessage")
[16:12:35.022]                     }
[16:12:35.022]                     else if (inherits(cond, "warning")) {
[16:12:35.022]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:35.022]                       if (muffled) 
[16:12:35.022]                         invokeRestart("muffleWarning")
[16:12:35.022]                     }
[16:12:35.022]                     else if (inherits(cond, "condition")) {
[16:12:35.022]                       if (!is.null(pattern)) {
[16:12:35.022]                         computeRestarts <- base::computeRestarts
[16:12:35.022]                         grepl <- base::grepl
[16:12:35.022]                         restarts <- computeRestarts(cond)
[16:12:35.022]                         for (restart in restarts) {
[16:12:35.022]                           name <- restart$name
[16:12:35.022]                           if (is.null(name)) 
[16:12:35.022]                             next
[16:12:35.022]                           if (!grepl(pattern, name)) 
[16:12:35.022]                             next
[16:12:35.022]                           invokeRestart(restart)
[16:12:35.022]                           muffled <- TRUE
[16:12:35.022]                           break
[16:12:35.022]                         }
[16:12:35.022]                       }
[16:12:35.022]                     }
[16:12:35.022]                     invisible(muffled)
[16:12:35.022]                   }
[16:12:35.022]                   muffleCondition(cond)
[16:12:35.022]                 })
[16:12:35.022]             }))
[16:12:35.022]             future::FutureResult(value = ...future.value$value, 
[16:12:35.022]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:35.022]                   ...future.rng), globalenv = if (FALSE) 
[16:12:35.022]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:35.022]                     ...future.globalenv.names))
[16:12:35.022]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:35.022]         }, condition = base::local({
[16:12:35.022]             c <- base::c
[16:12:35.022]             inherits <- base::inherits
[16:12:35.022]             invokeRestart <- base::invokeRestart
[16:12:35.022]             length <- base::length
[16:12:35.022]             list <- base::list
[16:12:35.022]             seq.int <- base::seq.int
[16:12:35.022]             signalCondition <- base::signalCondition
[16:12:35.022]             sys.calls <- base::sys.calls
[16:12:35.022]             `[[` <- base::`[[`
[16:12:35.022]             `+` <- base::`+`
[16:12:35.022]             `<<-` <- base::`<<-`
[16:12:35.022]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:35.022]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:35.022]                   3L)]
[16:12:35.022]             }
[16:12:35.022]             function(cond) {
[16:12:35.022]                 is_error <- inherits(cond, "error")
[16:12:35.022]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:35.022]                   NULL)
[16:12:35.022]                 if (is_error) {
[16:12:35.022]                   sessionInformation <- function() {
[16:12:35.022]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:35.022]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:35.022]                       search = base::search(), system = base::Sys.info())
[16:12:35.022]                   }
[16:12:35.022]                   ...future.conditions[[length(...future.conditions) + 
[16:12:35.022]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:35.022]                     cond$call), session = sessionInformation(), 
[16:12:35.022]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:35.022]                   signalCondition(cond)
[16:12:35.022]                 }
[16:12:35.022]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:35.022]                 "immediateCondition"))) {
[16:12:35.022]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:35.022]                   ...future.conditions[[length(...future.conditions) + 
[16:12:35.022]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:35.022]                   if (TRUE && !signal) {
[16:12:35.022]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:35.022]                     {
[16:12:35.022]                       inherits <- base::inherits
[16:12:35.022]                       invokeRestart <- base::invokeRestart
[16:12:35.022]                       is.null <- base::is.null
[16:12:35.022]                       muffled <- FALSE
[16:12:35.022]                       if (inherits(cond, "message")) {
[16:12:35.022]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:35.022]                         if (muffled) 
[16:12:35.022]                           invokeRestart("muffleMessage")
[16:12:35.022]                       }
[16:12:35.022]                       else if (inherits(cond, "warning")) {
[16:12:35.022]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:35.022]                         if (muffled) 
[16:12:35.022]                           invokeRestart("muffleWarning")
[16:12:35.022]                       }
[16:12:35.022]                       else if (inherits(cond, "condition")) {
[16:12:35.022]                         if (!is.null(pattern)) {
[16:12:35.022]                           computeRestarts <- base::computeRestarts
[16:12:35.022]                           grepl <- base::grepl
[16:12:35.022]                           restarts <- computeRestarts(cond)
[16:12:35.022]                           for (restart in restarts) {
[16:12:35.022]                             name <- restart$name
[16:12:35.022]                             if (is.null(name)) 
[16:12:35.022]                               next
[16:12:35.022]                             if (!grepl(pattern, name)) 
[16:12:35.022]                               next
[16:12:35.022]                             invokeRestart(restart)
[16:12:35.022]                             muffled <- TRUE
[16:12:35.022]                             break
[16:12:35.022]                           }
[16:12:35.022]                         }
[16:12:35.022]                       }
[16:12:35.022]                       invisible(muffled)
[16:12:35.022]                     }
[16:12:35.022]                     muffleCondition(cond, pattern = "^muffle")
[16:12:35.022]                   }
[16:12:35.022]                 }
[16:12:35.022]                 else {
[16:12:35.022]                   if (TRUE) {
[16:12:35.022]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:35.022]                     {
[16:12:35.022]                       inherits <- base::inherits
[16:12:35.022]                       invokeRestart <- base::invokeRestart
[16:12:35.022]                       is.null <- base::is.null
[16:12:35.022]                       muffled <- FALSE
[16:12:35.022]                       if (inherits(cond, "message")) {
[16:12:35.022]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:35.022]                         if (muffled) 
[16:12:35.022]                           invokeRestart("muffleMessage")
[16:12:35.022]                       }
[16:12:35.022]                       else if (inherits(cond, "warning")) {
[16:12:35.022]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:35.022]                         if (muffled) 
[16:12:35.022]                           invokeRestart("muffleWarning")
[16:12:35.022]                       }
[16:12:35.022]                       else if (inherits(cond, "condition")) {
[16:12:35.022]                         if (!is.null(pattern)) {
[16:12:35.022]                           computeRestarts <- base::computeRestarts
[16:12:35.022]                           grepl <- base::grepl
[16:12:35.022]                           restarts <- computeRestarts(cond)
[16:12:35.022]                           for (restart in restarts) {
[16:12:35.022]                             name <- restart$name
[16:12:35.022]                             if (is.null(name)) 
[16:12:35.022]                               next
[16:12:35.022]                             if (!grepl(pattern, name)) 
[16:12:35.022]                               next
[16:12:35.022]                             invokeRestart(restart)
[16:12:35.022]                             muffled <- TRUE
[16:12:35.022]                             break
[16:12:35.022]                           }
[16:12:35.022]                         }
[16:12:35.022]                       }
[16:12:35.022]                       invisible(muffled)
[16:12:35.022]                     }
[16:12:35.022]                     muffleCondition(cond, pattern = "^muffle")
[16:12:35.022]                   }
[16:12:35.022]                 }
[16:12:35.022]             }
[16:12:35.022]         }))
[16:12:35.022]     }, error = function(ex) {
[16:12:35.022]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:35.022]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:35.022]                 ...future.rng), started = ...future.startTime, 
[16:12:35.022]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:35.022]             version = "1.8"), class = "FutureResult")
[16:12:35.022]     }, finally = {
[16:12:35.022]         if (!identical(...future.workdir, getwd())) 
[16:12:35.022]             setwd(...future.workdir)
[16:12:35.022]         {
[16:12:35.022]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:35.022]                 ...future.oldOptions$nwarnings <- NULL
[16:12:35.022]             }
[16:12:35.022]             base::options(...future.oldOptions)
[16:12:35.022]             if (.Platform$OS.type == "windows") {
[16:12:35.022]                 old_names <- names(...future.oldEnvVars)
[16:12:35.022]                 envs <- base::Sys.getenv()
[16:12:35.022]                 names <- names(envs)
[16:12:35.022]                 common <- intersect(names, old_names)
[16:12:35.022]                 added <- setdiff(names, old_names)
[16:12:35.022]                 removed <- setdiff(old_names, names)
[16:12:35.022]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:35.022]                   envs[common]]
[16:12:35.022]                 NAMES <- toupper(changed)
[16:12:35.022]                 args <- list()
[16:12:35.022]                 for (kk in seq_along(NAMES)) {
[16:12:35.022]                   name <- changed[[kk]]
[16:12:35.022]                   NAME <- NAMES[[kk]]
[16:12:35.022]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:35.022]                     next
[16:12:35.022]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:35.022]                 }
[16:12:35.022]                 NAMES <- toupper(added)
[16:12:35.022]                 for (kk in seq_along(NAMES)) {
[16:12:35.022]                   name <- added[[kk]]
[16:12:35.022]                   NAME <- NAMES[[kk]]
[16:12:35.022]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:35.022]                     next
[16:12:35.022]                   args[[name]] <- ""
[16:12:35.022]                 }
[16:12:35.022]                 NAMES <- toupper(removed)
[16:12:35.022]                 for (kk in seq_along(NAMES)) {
[16:12:35.022]                   name <- removed[[kk]]
[16:12:35.022]                   NAME <- NAMES[[kk]]
[16:12:35.022]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:35.022]                     next
[16:12:35.022]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:35.022]                 }
[16:12:35.022]                 if (length(args) > 0) 
[16:12:35.022]                   base::do.call(base::Sys.setenv, args = args)
[16:12:35.022]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:35.022]             }
[16:12:35.022]             else {
[16:12:35.022]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:35.022]             }
[16:12:35.022]             {
[16:12:35.022]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:35.022]                   0L) {
[16:12:35.022]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:35.022]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:35.022]                   base::options(opts)
[16:12:35.022]                 }
[16:12:35.022]                 {
[16:12:35.022]                   {
[16:12:35.022]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:35.022]                     NULL
[16:12:35.022]                   }
[16:12:35.022]                   options(future.plan = NULL)
[16:12:35.022]                   if (is.na(NA_character_)) 
[16:12:35.022]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:35.022]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:35.022]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:35.022]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:35.022]                     envir = parent.frame()) 
[16:12:35.022]                   {
[16:12:35.022]                     if (is.function(workers)) 
[16:12:35.022]                       workers <- workers()
[16:12:35.022]                     workers <- structure(as.integer(workers), 
[16:12:35.022]                       class = class(workers))
[16:12:35.022]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:35.022]                       workers >= 1)
[16:12:35.022]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:35.022]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:35.022]                     }
[16:12:35.022]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:35.022]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:35.022]                       envir = envir)
[16:12:35.022]                     if (!future$lazy) 
[16:12:35.022]                       future <- run(future)
[16:12:35.022]                     invisible(future)
[16:12:35.022]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:35.022]                 }
[16:12:35.022]             }
[16:12:35.022]         }
[16:12:35.022]     })
[16:12:35.022]     if (TRUE) {
[16:12:35.022]         base::sink(type = "output", split = FALSE)
[16:12:35.022]         if (TRUE) {
[16:12:35.022]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:35.022]         }
[16:12:35.022]         else {
[16:12:35.022]             ...future.result["stdout"] <- base::list(NULL)
[16:12:35.022]         }
[16:12:35.022]         base::close(...future.stdout)
[16:12:35.022]         ...future.stdout <- NULL
[16:12:35.022]     }
[16:12:35.022]     ...future.result$conditions <- ...future.conditions
[16:12:35.022]     ...future.result$finished <- base::Sys.time()
[16:12:35.022]     ...future.result
[16:12:35.022] }
[16:12:35.025] MultisessionFuture started
[16:12:35.025] - Launch lazy future ... done
[16:12:35.025] run() for ‘MultisessionFuture’ ... done
[16:12:35.025] result() for ClusterFuture ...
[16:12:35.025] receiveMessageFromWorker() for ClusterFuture ...
[16:12:35.025] - Validating connection of MultisessionFuture
[16:12:35.073] - received message: FutureResult
[16:12:35.074] - Received FutureResult
[16:12:35.074] - Erased future from FutureRegistry
[16:12:35.074] result() for ClusterFuture ...
[16:12:35.074] - result already collected: FutureResult
[16:12:35.074] result() for ClusterFuture ... done
[16:12:35.074] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:35.074] result() for ClusterFuture ... done
[16:12:35.074] result() for ClusterFuture ...
[16:12:35.074] - result already collected: FutureResult
[16:12:35.074] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[16:12:35.077] getGlobalsAndPackages() ...
[16:12:35.077] Searching for globals...
[16:12:35.079] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[16:12:35.079] Searching for globals ... DONE
[16:12:35.079] Resolving globals: FALSE
[16:12:35.080] 
[16:12:35.080] - packages: [2] ‘stats’, ‘datasets’
[16:12:35.080] getGlobalsAndPackages() ... DONE
[16:12:35.080] run() for ‘Future’ ...
[16:12:35.081] - state: ‘created’
[16:12:35.081] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:35.095] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:35.095] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:35.095]   - Field: ‘node’
[16:12:35.095]   - Field: ‘label’
[16:12:35.095]   - Field: ‘local’
[16:12:35.096]   - Field: ‘owner’
[16:12:35.096]   - Field: ‘envir’
[16:12:35.096]   - Field: ‘workers’
[16:12:35.096]   - Field: ‘packages’
[16:12:35.096]   - Field: ‘gc’
[16:12:35.096]   - Field: ‘conditions’
[16:12:35.096]   - Field: ‘persistent’
[16:12:35.096]   - Field: ‘expr’
[16:12:35.096]   - Field: ‘uuid’
[16:12:35.096]   - Field: ‘seed’
[16:12:35.096]   - Field: ‘version’
[16:12:35.097]   - Field: ‘result’
[16:12:35.097]   - Field: ‘asynchronous’
[16:12:35.097]   - Field: ‘calls’
[16:12:35.097]   - Field: ‘globals’
[16:12:35.097]   - Field: ‘stdout’
[16:12:35.097]   - Field: ‘earlySignal’
[16:12:35.097]   - Field: ‘lazy’
[16:12:35.097]   - Field: ‘state’
[16:12:35.097] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:35.097] - Launch lazy future ...
[16:12:35.098] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:12:35.098] Packages needed by future strategies (n = 0): <none>
[16:12:35.098] {
[16:12:35.098]     {
[16:12:35.098]         {
[16:12:35.098]             ...future.startTime <- base::Sys.time()
[16:12:35.098]             {
[16:12:35.098]                 {
[16:12:35.098]                   {
[16:12:35.098]                     {
[16:12:35.098]                       {
[16:12:35.098]                         base::local({
[16:12:35.098]                           has_future <- base::requireNamespace("future", 
[16:12:35.098]                             quietly = TRUE)
[16:12:35.098]                           if (has_future) {
[16:12:35.098]                             ns <- base::getNamespace("future")
[16:12:35.098]                             version <- ns[[".package"]][["version"]]
[16:12:35.098]                             if (is.null(version)) 
[16:12:35.098]                               version <- utils::packageVersion("future")
[16:12:35.098]                           }
[16:12:35.098]                           else {
[16:12:35.098]                             version <- NULL
[16:12:35.098]                           }
[16:12:35.098]                           if (!has_future || version < "1.8.0") {
[16:12:35.098]                             info <- base::c(r_version = base::gsub("R version ", 
[16:12:35.098]                               "", base::R.version$version.string), 
[16:12:35.098]                               platform = base::sprintf("%s (%s-bit)", 
[16:12:35.098]                                 base::R.version$platform, 8 * 
[16:12:35.098]                                   base::.Machine$sizeof.pointer), 
[16:12:35.098]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:35.098]                                 "release", "version")], collapse = " "), 
[16:12:35.098]                               hostname = base::Sys.info()[["nodename"]])
[16:12:35.098]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:12:35.098]                               info)
[16:12:35.098]                             info <- base::paste(info, collapse = "; ")
[16:12:35.098]                             if (!has_future) {
[16:12:35.098]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:35.098]                                 info)
[16:12:35.098]                             }
[16:12:35.098]                             else {
[16:12:35.098]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:35.098]                                 info, version)
[16:12:35.098]                             }
[16:12:35.098]                             base::stop(msg)
[16:12:35.098]                           }
[16:12:35.098]                         })
[16:12:35.098]                       }
[16:12:35.098]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:35.098]                       base::options(mc.cores = 1L)
[16:12:35.098]                     }
[16:12:35.098]                     base::local({
[16:12:35.098]                       for (pkg in c("stats", "datasets")) {
[16:12:35.098]                         base::loadNamespace(pkg)
[16:12:35.098]                         base::library(pkg, character.only = TRUE)
[16:12:35.098]                       }
[16:12:35.098]                     })
[16:12:35.098]                   }
[16:12:35.098]                   options(future.plan = NULL)
[16:12:35.098]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:35.098]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:35.098]                 }
[16:12:35.098]                 ...future.workdir <- getwd()
[16:12:35.098]             }
[16:12:35.098]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:35.098]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:35.098]         }
[16:12:35.098]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:35.098]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:35.098]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:35.098]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:35.098]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:35.098]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:35.098]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:35.098]             base::names(...future.oldOptions))
[16:12:35.098]     }
[16:12:35.098]     if (FALSE) {
[16:12:35.098]     }
[16:12:35.098]     else {
[16:12:35.098]         if (TRUE) {
[16:12:35.098]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:35.098]                 open = "w")
[16:12:35.098]         }
[16:12:35.098]         else {
[16:12:35.098]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:35.098]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:35.098]         }
[16:12:35.098]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:35.098]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:35.098]             base::sink(type = "output", split = FALSE)
[16:12:35.098]             base::close(...future.stdout)
[16:12:35.098]         }, add = TRUE)
[16:12:35.098]     }
[16:12:35.098]     ...future.frame <- base::sys.nframe()
[16:12:35.098]     ...future.conditions <- base::list()
[16:12:35.098]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:35.098]     if (FALSE) {
[16:12:35.098]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:35.098]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:35.098]     }
[16:12:35.098]     ...future.result <- base::tryCatch({
[16:12:35.098]         base::withCallingHandlers({
[16:12:35.098]             ...future.value <- base::withVisible(base::local({
[16:12:35.098]                 ...future.makeSendCondition <- local({
[16:12:35.098]                   sendCondition <- NULL
[16:12:35.098]                   function(frame = 1L) {
[16:12:35.098]                     if (is.function(sendCondition)) 
[16:12:35.098]                       return(sendCondition)
[16:12:35.098]                     ns <- getNamespace("parallel")
[16:12:35.098]                     if (exists("sendData", mode = "function", 
[16:12:35.098]                       envir = ns)) {
[16:12:35.098]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:35.098]                         envir = ns)
[16:12:35.098]                       envir <- sys.frame(frame)
[16:12:35.098]                       master <- NULL
[16:12:35.098]                       while (!identical(envir, .GlobalEnv) && 
[16:12:35.098]                         !identical(envir, emptyenv())) {
[16:12:35.098]                         if (exists("master", mode = "list", envir = envir, 
[16:12:35.098]                           inherits = FALSE)) {
[16:12:35.098]                           master <- get("master", mode = "list", 
[16:12:35.098]                             envir = envir, inherits = FALSE)
[16:12:35.098]                           if (inherits(master, c("SOCKnode", 
[16:12:35.098]                             "SOCK0node"))) {
[16:12:35.098]                             sendCondition <<- function(cond) {
[16:12:35.098]                               data <- list(type = "VALUE", value = cond, 
[16:12:35.098]                                 success = TRUE)
[16:12:35.098]                               parallel_sendData(master, data)
[16:12:35.098]                             }
[16:12:35.098]                             return(sendCondition)
[16:12:35.098]                           }
[16:12:35.098]                         }
[16:12:35.098]                         frame <- frame + 1L
[16:12:35.098]                         envir <- sys.frame(frame)
[16:12:35.098]                       }
[16:12:35.098]                     }
[16:12:35.098]                     sendCondition <<- function(cond) NULL
[16:12:35.098]                   }
[16:12:35.098]                 })
[16:12:35.098]                 withCallingHandlers({
[16:12:35.098]                   {
[16:12:35.098]                     lm(dist ~ speed + I(speed^2), data = cars)
[16:12:35.098]                   }
[16:12:35.098]                 }, immediateCondition = function(cond) {
[16:12:35.098]                   sendCondition <- ...future.makeSendCondition()
[16:12:35.098]                   sendCondition(cond)
[16:12:35.098]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:35.098]                   {
[16:12:35.098]                     inherits <- base::inherits
[16:12:35.098]                     invokeRestart <- base::invokeRestart
[16:12:35.098]                     is.null <- base::is.null
[16:12:35.098]                     muffled <- FALSE
[16:12:35.098]                     if (inherits(cond, "message")) {
[16:12:35.098]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:35.098]                       if (muffled) 
[16:12:35.098]                         invokeRestart("muffleMessage")
[16:12:35.098]                     }
[16:12:35.098]                     else if (inherits(cond, "warning")) {
[16:12:35.098]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:35.098]                       if (muffled) 
[16:12:35.098]                         invokeRestart("muffleWarning")
[16:12:35.098]                     }
[16:12:35.098]                     else if (inherits(cond, "condition")) {
[16:12:35.098]                       if (!is.null(pattern)) {
[16:12:35.098]                         computeRestarts <- base::computeRestarts
[16:12:35.098]                         grepl <- base::grepl
[16:12:35.098]                         restarts <- computeRestarts(cond)
[16:12:35.098]                         for (restart in restarts) {
[16:12:35.098]                           name <- restart$name
[16:12:35.098]                           if (is.null(name)) 
[16:12:35.098]                             next
[16:12:35.098]                           if (!grepl(pattern, name)) 
[16:12:35.098]                             next
[16:12:35.098]                           invokeRestart(restart)
[16:12:35.098]                           muffled <- TRUE
[16:12:35.098]                           break
[16:12:35.098]                         }
[16:12:35.098]                       }
[16:12:35.098]                     }
[16:12:35.098]                     invisible(muffled)
[16:12:35.098]                   }
[16:12:35.098]                   muffleCondition(cond)
[16:12:35.098]                 })
[16:12:35.098]             }))
[16:12:35.098]             future::FutureResult(value = ...future.value$value, 
[16:12:35.098]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:35.098]                   ...future.rng), globalenv = if (FALSE) 
[16:12:35.098]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:35.098]                     ...future.globalenv.names))
[16:12:35.098]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:35.098]         }, condition = base::local({
[16:12:35.098]             c <- base::c
[16:12:35.098]             inherits <- base::inherits
[16:12:35.098]             invokeRestart <- base::invokeRestart
[16:12:35.098]             length <- base::length
[16:12:35.098]             list <- base::list
[16:12:35.098]             seq.int <- base::seq.int
[16:12:35.098]             signalCondition <- base::signalCondition
[16:12:35.098]             sys.calls <- base::sys.calls
[16:12:35.098]             `[[` <- base::`[[`
[16:12:35.098]             `+` <- base::`+`
[16:12:35.098]             `<<-` <- base::`<<-`
[16:12:35.098]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:35.098]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:35.098]                   3L)]
[16:12:35.098]             }
[16:12:35.098]             function(cond) {
[16:12:35.098]                 is_error <- inherits(cond, "error")
[16:12:35.098]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:35.098]                   NULL)
[16:12:35.098]                 if (is_error) {
[16:12:35.098]                   sessionInformation <- function() {
[16:12:35.098]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:35.098]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:35.098]                       search = base::search(), system = base::Sys.info())
[16:12:35.098]                   }
[16:12:35.098]                   ...future.conditions[[length(...future.conditions) + 
[16:12:35.098]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:35.098]                     cond$call), session = sessionInformation(), 
[16:12:35.098]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:35.098]                   signalCondition(cond)
[16:12:35.098]                 }
[16:12:35.098]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:35.098]                 "immediateCondition"))) {
[16:12:35.098]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:35.098]                   ...future.conditions[[length(...future.conditions) + 
[16:12:35.098]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:35.098]                   if (TRUE && !signal) {
[16:12:35.098]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:35.098]                     {
[16:12:35.098]                       inherits <- base::inherits
[16:12:35.098]                       invokeRestart <- base::invokeRestart
[16:12:35.098]                       is.null <- base::is.null
[16:12:35.098]                       muffled <- FALSE
[16:12:35.098]                       if (inherits(cond, "message")) {
[16:12:35.098]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:35.098]                         if (muffled) 
[16:12:35.098]                           invokeRestart("muffleMessage")
[16:12:35.098]                       }
[16:12:35.098]                       else if (inherits(cond, "warning")) {
[16:12:35.098]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:35.098]                         if (muffled) 
[16:12:35.098]                           invokeRestart("muffleWarning")
[16:12:35.098]                       }
[16:12:35.098]                       else if (inherits(cond, "condition")) {
[16:12:35.098]                         if (!is.null(pattern)) {
[16:12:35.098]                           computeRestarts <- base::computeRestarts
[16:12:35.098]                           grepl <- base::grepl
[16:12:35.098]                           restarts <- computeRestarts(cond)
[16:12:35.098]                           for (restart in restarts) {
[16:12:35.098]                             name <- restart$name
[16:12:35.098]                             if (is.null(name)) 
[16:12:35.098]                               next
[16:12:35.098]                             if (!grepl(pattern, name)) 
[16:12:35.098]                               next
[16:12:35.098]                             invokeRestart(restart)
[16:12:35.098]                             muffled <- TRUE
[16:12:35.098]                             break
[16:12:35.098]                           }
[16:12:35.098]                         }
[16:12:35.098]                       }
[16:12:35.098]                       invisible(muffled)
[16:12:35.098]                     }
[16:12:35.098]                     muffleCondition(cond, pattern = "^muffle")
[16:12:35.098]                   }
[16:12:35.098]                 }
[16:12:35.098]                 else {
[16:12:35.098]                   if (TRUE) {
[16:12:35.098]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:35.098]                     {
[16:12:35.098]                       inherits <- base::inherits
[16:12:35.098]                       invokeRestart <- base::invokeRestart
[16:12:35.098]                       is.null <- base::is.null
[16:12:35.098]                       muffled <- FALSE
[16:12:35.098]                       if (inherits(cond, "message")) {
[16:12:35.098]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:35.098]                         if (muffled) 
[16:12:35.098]                           invokeRestart("muffleMessage")
[16:12:35.098]                       }
[16:12:35.098]                       else if (inherits(cond, "warning")) {
[16:12:35.098]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:35.098]                         if (muffled) 
[16:12:35.098]                           invokeRestart("muffleWarning")
[16:12:35.098]                       }
[16:12:35.098]                       else if (inherits(cond, "condition")) {
[16:12:35.098]                         if (!is.null(pattern)) {
[16:12:35.098]                           computeRestarts <- base::computeRestarts
[16:12:35.098]                           grepl <- base::grepl
[16:12:35.098]                           restarts <- computeRestarts(cond)
[16:12:35.098]                           for (restart in restarts) {
[16:12:35.098]                             name <- restart$name
[16:12:35.098]                             if (is.null(name)) 
[16:12:35.098]                               next
[16:12:35.098]                             if (!grepl(pattern, name)) 
[16:12:35.098]                               next
[16:12:35.098]                             invokeRestart(restart)
[16:12:35.098]                             muffled <- TRUE
[16:12:35.098]                             break
[16:12:35.098]                           }
[16:12:35.098]                         }
[16:12:35.098]                       }
[16:12:35.098]                       invisible(muffled)
[16:12:35.098]                     }
[16:12:35.098]                     muffleCondition(cond, pattern = "^muffle")
[16:12:35.098]                   }
[16:12:35.098]                 }
[16:12:35.098]             }
[16:12:35.098]         }))
[16:12:35.098]     }, error = function(ex) {
[16:12:35.098]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:35.098]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:35.098]                 ...future.rng), started = ...future.startTime, 
[16:12:35.098]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:35.098]             version = "1.8"), class = "FutureResult")
[16:12:35.098]     }, finally = {
[16:12:35.098]         if (!identical(...future.workdir, getwd())) 
[16:12:35.098]             setwd(...future.workdir)
[16:12:35.098]         {
[16:12:35.098]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:35.098]                 ...future.oldOptions$nwarnings <- NULL
[16:12:35.098]             }
[16:12:35.098]             base::options(...future.oldOptions)
[16:12:35.098]             if (.Platform$OS.type == "windows") {
[16:12:35.098]                 old_names <- names(...future.oldEnvVars)
[16:12:35.098]                 envs <- base::Sys.getenv()
[16:12:35.098]                 names <- names(envs)
[16:12:35.098]                 common <- intersect(names, old_names)
[16:12:35.098]                 added <- setdiff(names, old_names)
[16:12:35.098]                 removed <- setdiff(old_names, names)
[16:12:35.098]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:35.098]                   envs[common]]
[16:12:35.098]                 NAMES <- toupper(changed)
[16:12:35.098]                 args <- list()
[16:12:35.098]                 for (kk in seq_along(NAMES)) {
[16:12:35.098]                   name <- changed[[kk]]
[16:12:35.098]                   NAME <- NAMES[[kk]]
[16:12:35.098]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:35.098]                     next
[16:12:35.098]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:35.098]                 }
[16:12:35.098]                 NAMES <- toupper(added)
[16:12:35.098]                 for (kk in seq_along(NAMES)) {
[16:12:35.098]                   name <- added[[kk]]
[16:12:35.098]                   NAME <- NAMES[[kk]]
[16:12:35.098]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:35.098]                     next
[16:12:35.098]                   args[[name]] <- ""
[16:12:35.098]                 }
[16:12:35.098]                 NAMES <- toupper(removed)
[16:12:35.098]                 for (kk in seq_along(NAMES)) {
[16:12:35.098]                   name <- removed[[kk]]
[16:12:35.098]                   NAME <- NAMES[[kk]]
[16:12:35.098]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:35.098]                     next
[16:12:35.098]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:35.098]                 }
[16:12:35.098]                 if (length(args) > 0) 
[16:12:35.098]                   base::do.call(base::Sys.setenv, args = args)
[16:12:35.098]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:35.098]             }
[16:12:35.098]             else {
[16:12:35.098]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:35.098]             }
[16:12:35.098]             {
[16:12:35.098]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:35.098]                   0L) {
[16:12:35.098]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:35.098]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:35.098]                   base::options(opts)
[16:12:35.098]                 }
[16:12:35.098]                 {
[16:12:35.098]                   {
[16:12:35.098]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:35.098]                     NULL
[16:12:35.098]                   }
[16:12:35.098]                   options(future.plan = NULL)
[16:12:35.098]                   if (is.na(NA_character_)) 
[16:12:35.098]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:35.098]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:35.098]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:35.098]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:35.098]                     envir = parent.frame()) 
[16:12:35.098]                   {
[16:12:35.098]                     if (is.function(workers)) 
[16:12:35.098]                       workers <- workers()
[16:12:35.098]                     workers <- structure(as.integer(workers), 
[16:12:35.098]                       class = class(workers))
[16:12:35.098]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:35.098]                       workers >= 1)
[16:12:35.098]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:35.098]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:35.098]                     }
[16:12:35.098]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:35.098]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:35.098]                       envir = envir)
[16:12:35.098]                     if (!future$lazy) 
[16:12:35.098]                       future <- run(future)
[16:12:35.098]                     invisible(future)
[16:12:35.098]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:35.098]                 }
[16:12:35.098]             }
[16:12:35.098]         }
[16:12:35.098]     })
[16:12:35.098]     if (TRUE) {
[16:12:35.098]         base::sink(type = "output", split = FALSE)
[16:12:35.098]         if (TRUE) {
[16:12:35.098]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:35.098]         }
[16:12:35.098]         else {
[16:12:35.098]             ...future.result["stdout"] <- base::list(NULL)
[16:12:35.098]         }
[16:12:35.098]         base::close(...future.stdout)
[16:12:35.098]         ...future.stdout <- NULL
[16:12:35.098]     }
[16:12:35.098]     ...future.result$conditions <- ...future.conditions
[16:12:35.098]     ...future.result$finished <- base::Sys.time()
[16:12:35.098]     ...future.result
[16:12:35.098] }
[16:12:35.101] MultisessionFuture started
[16:12:35.102] - Launch lazy future ... done
[16:12:35.102] run() for ‘MultisessionFuture’ ... done
[16:12:35.102] result() for ClusterFuture ...
[16:12:35.102] receiveMessageFromWorker() for ClusterFuture ...
[16:12:35.102] - Validating connection of MultisessionFuture
[16:12:35.149] - received message: FutureResult
[16:12:35.149] - Received FutureResult
[16:12:35.149] - Erased future from FutureRegistry
[16:12:35.150] result() for ClusterFuture ...
[16:12:35.150] - result already collected: FutureResult
[16:12:35.150] result() for ClusterFuture ... done
[16:12:35.150] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:35.150] result() for ClusterFuture ... done
[16:12:35.150] result() for ClusterFuture ...
[16:12:35.150] - result already collected: FutureResult
[16:12:35.150] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[16:12:35.153] getGlobalsAndPackages() ...
[16:12:35.153] Searching for globals...
[16:12:35.154] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[16:12:35.155] Searching for globals ... DONE
[16:12:35.155] Resolving globals: FALSE
[16:12:35.155] 
[16:12:35.155] - packages: [2] ‘stats’, ‘datasets’
[16:12:35.155] getGlobalsAndPackages() ... DONE
[16:12:35.156] run() for ‘Future’ ...
[16:12:35.156] - state: ‘created’
[16:12:35.156] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:35.170] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:35.170] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:35.170]   - Field: ‘node’
[16:12:35.170]   - Field: ‘label’
[16:12:35.170]   - Field: ‘local’
[16:12:35.170]   - Field: ‘owner’
[16:12:35.171]   - Field: ‘envir’
[16:12:35.171]   - Field: ‘workers’
[16:12:35.171]   - Field: ‘packages’
[16:12:35.171]   - Field: ‘gc’
[16:12:35.171]   - Field: ‘conditions’
[16:12:35.171]   - Field: ‘persistent’
[16:12:35.171]   - Field: ‘expr’
[16:12:35.171]   - Field: ‘uuid’
[16:12:35.171]   - Field: ‘seed’
[16:12:35.171]   - Field: ‘version’
[16:12:35.171]   - Field: ‘result’
[16:12:35.172]   - Field: ‘asynchronous’
[16:12:35.172]   - Field: ‘calls’
[16:12:35.172]   - Field: ‘globals’
[16:12:35.172]   - Field: ‘stdout’
[16:12:35.172]   - Field: ‘earlySignal’
[16:12:35.172]   - Field: ‘lazy’
[16:12:35.172]   - Field: ‘state’
[16:12:35.172] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:35.172] - Launch lazy future ...
[16:12:35.173] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:12:35.173] Packages needed by future strategies (n = 0): <none>
[16:12:35.173] {
[16:12:35.173]     {
[16:12:35.173]         {
[16:12:35.173]             ...future.startTime <- base::Sys.time()
[16:12:35.173]             {
[16:12:35.173]                 {
[16:12:35.173]                   {
[16:12:35.173]                     {
[16:12:35.173]                       {
[16:12:35.173]                         base::local({
[16:12:35.173]                           has_future <- base::requireNamespace("future", 
[16:12:35.173]                             quietly = TRUE)
[16:12:35.173]                           if (has_future) {
[16:12:35.173]                             ns <- base::getNamespace("future")
[16:12:35.173]                             version <- ns[[".package"]][["version"]]
[16:12:35.173]                             if (is.null(version)) 
[16:12:35.173]                               version <- utils::packageVersion("future")
[16:12:35.173]                           }
[16:12:35.173]                           else {
[16:12:35.173]                             version <- NULL
[16:12:35.173]                           }
[16:12:35.173]                           if (!has_future || version < "1.8.0") {
[16:12:35.173]                             info <- base::c(r_version = base::gsub("R version ", 
[16:12:35.173]                               "", base::R.version$version.string), 
[16:12:35.173]                               platform = base::sprintf("%s (%s-bit)", 
[16:12:35.173]                                 base::R.version$platform, 8 * 
[16:12:35.173]                                   base::.Machine$sizeof.pointer), 
[16:12:35.173]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:35.173]                                 "release", "version")], collapse = " "), 
[16:12:35.173]                               hostname = base::Sys.info()[["nodename"]])
[16:12:35.173]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:12:35.173]                               info)
[16:12:35.173]                             info <- base::paste(info, collapse = "; ")
[16:12:35.173]                             if (!has_future) {
[16:12:35.173]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:35.173]                                 info)
[16:12:35.173]                             }
[16:12:35.173]                             else {
[16:12:35.173]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:35.173]                                 info, version)
[16:12:35.173]                             }
[16:12:35.173]                             base::stop(msg)
[16:12:35.173]                           }
[16:12:35.173]                         })
[16:12:35.173]                       }
[16:12:35.173]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:35.173]                       base::options(mc.cores = 1L)
[16:12:35.173]                     }
[16:12:35.173]                     base::local({
[16:12:35.173]                       for (pkg in c("stats", "datasets")) {
[16:12:35.173]                         base::loadNamespace(pkg)
[16:12:35.173]                         base::library(pkg, character.only = TRUE)
[16:12:35.173]                       }
[16:12:35.173]                     })
[16:12:35.173]                   }
[16:12:35.173]                   options(future.plan = NULL)
[16:12:35.173]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:35.173]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:35.173]                 }
[16:12:35.173]                 ...future.workdir <- getwd()
[16:12:35.173]             }
[16:12:35.173]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:35.173]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:35.173]         }
[16:12:35.173]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:35.173]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:35.173]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:35.173]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:35.173]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:35.173]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:35.173]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:35.173]             base::names(...future.oldOptions))
[16:12:35.173]     }
[16:12:35.173]     if (FALSE) {
[16:12:35.173]     }
[16:12:35.173]     else {
[16:12:35.173]         if (TRUE) {
[16:12:35.173]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:35.173]                 open = "w")
[16:12:35.173]         }
[16:12:35.173]         else {
[16:12:35.173]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:35.173]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:35.173]         }
[16:12:35.173]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:35.173]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:35.173]             base::sink(type = "output", split = FALSE)
[16:12:35.173]             base::close(...future.stdout)
[16:12:35.173]         }, add = TRUE)
[16:12:35.173]     }
[16:12:35.173]     ...future.frame <- base::sys.nframe()
[16:12:35.173]     ...future.conditions <- base::list()
[16:12:35.173]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:35.173]     if (FALSE) {
[16:12:35.173]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:35.173]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:35.173]     }
[16:12:35.173]     ...future.result <- base::tryCatch({
[16:12:35.173]         base::withCallingHandlers({
[16:12:35.173]             ...future.value <- base::withVisible(base::local({
[16:12:35.173]                 ...future.makeSendCondition <- local({
[16:12:35.173]                   sendCondition <- NULL
[16:12:35.173]                   function(frame = 1L) {
[16:12:35.173]                     if (is.function(sendCondition)) 
[16:12:35.173]                       return(sendCondition)
[16:12:35.173]                     ns <- getNamespace("parallel")
[16:12:35.173]                     if (exists("sendData", mode = "function", 
[16:12:35.173]                       envir = ns)) {
[16:12:35.173]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:35.173]                         envir = ns)
[16:12:35.173]                       envir <- sys.frame(frame)
[16:12:35.173]                       master <- NULL
[16:12:35.173]                       while (!identical(envir, .GlobalEnv) && 
[16:12:35.173]                         !identical(envir, emptyenv())) {
[16:12:35.173]                         if (exists("master", mode = "list", envir = envir, 
[16:12:35.173]                           inherits = FALSE)) {
[16:12:35.173]                           master <- get("master", mode = "list", 
[16:12:35.173]                             envir = envir, inherits = FALSE)
[16:12:35.173]                           if (inherits(master, c("SOCKnode", 
[16:12:35.173]                             "SOCK0node"))) {
[16:12:35.173]                             sendCondition <<- function(cond) {
[16:12:35.173]                               data <- list(type = "VALUE", value = cond, 
[16:12:35.173]                                 success = TRUE)
[16:12:35.173]                               parallel_sendData(master, data)
[16:12:35.173]                             }
[16:12:35.173]                             return(sendCondition)
[16:12:35.173]                           }
[16:12:35.173]                         }
[16:12:35.173]                         frame <- frame + 1L
[16:12:35.173]                         envir <- sys.frame(frame)
[16:12:35.173]                       }
[16:12:35.173]                     }
[16:12:35.173]                     sendCondition <<- function(cond) NULL
[16:12:35.173]                   }
[16:12:35.173]                 })
[16:12:35.173]                 withCallingHandlers({
[16:12:35.173]                   {
[16:12:35.173]                     lm(dist ~ poly(speed, 2), data = cars)
[16:12:35.173]                   }
[16:12:35.173]                 }, immediateCondition = function(cond) {
[16:12:35.173]                   sendCondition <- ...future.makeSendCondition()
[16:12:35.173]                   sendCondition(cond)
[16:12:35.173]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:35.173]                   {
[16:12:35.173]                     inherits <- base::inherits
[16:12:35.173]                     invokeRestart <- base::invokeRestart
[16:12:35.173]                     is.null <- base::is.null
[16:12:35.173]                     muffled <- FALSE
[16:12:35.173]                     if (inherits(cond, "message")) {
[16:12:35.173]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:35.173]                       if (muffled) 
[16:12:35.173]                         invokeRestart("muffleMessage")
[16:12:35.173]                     }
[16:12:35.173]                     else if (inherits(cond, "warning")) {
[16:12:35.173]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:35.173]                       if (muffled) 
[16:12:35.173]                         invokeRestart("muffleWarning")
[16:12:35.173]                     }
[16:12:35.173]                     else if (inherits(cond, "condition")) {
[16:12:35.173]                       if (!is.null(pattern)) {
[16:12:35.173]                         computeRestarts <- base::computeRestarts
[16:12:35.173]                         grepl <- base::grepl
[16:12:35.173]                         restarts <- computeRestarts(cond)
[16:12:35.173]                         for (restart in restarts) {
[16:12:35.173]                           name <- restart$name
[16:12:35.173]                           if (is.null(name)) 
[16:12:35.173]                             next
[16:12:35.173]                           if (!grepl(pattern, name)) 
[16:12:35.173]                             next
[16:12:35.173]                           invokeRestart(restart)
[16:12:35.173]                           muffled <- TRUE
[16:12:35.173]                           break
[16:12:35.173]                         }
[16:12:35.173]                       }
[16:12:35.173]                     }
[16:12:35.173]                     invisible(muffled)
[16:12:35.173]                   }
[16:12:35.173]                   muffleCondition(cond)
[16:12:35.173]                 })
[16:12:35.173]             }))
[16:12:35.173]             future::FutureResult(value = ...future.value$value, 
[16:12:35.173]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:35.173]                   ...future.rng), globalenv = if (FALSE) 
[16:12:35.173]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:35.173]                     ...future.globalenv.names))
[16:12:35.173]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:35.173]         }, condition = base::local({
[16:12:35.173]             c <- base::c
[16:12:35.173]             inherits <- base::inherits
[16:12:35.173]             invokeRestart <- base::invokeRestart
[16:12:35.173]             length <- base::length
[16:12:35.173]             list <- base::list
[16:12:35.173]             seq.int <- base::seq.int
[16:12:35.173]             signalCondition <- base::signalCondition
[16:12:35.173]             sys.calls <- base::sys.calls
[16:12:35.173]             `[[` <- base::`[[`
[16:12:35.173]             `+` <- base::`+`
[16:12:35.173]             `<<-` <- base::`<<-`
[16:12:35.173]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:35.173]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:35.173]                   3L)]
[16:12:35.173]             }
[16:12:35.173]             function(cond) {
[16:12:35.173]                 is_error <- inherits(cond, "error")
[16:12:35.173]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:35.173]                   NULL)
[16:12:35.173]                 if (is_error) {
[16:12:35.173]                   sessionInformation <- function() {
[16:12:35.173]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:35.173]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:35.173]                       search = base::search(), system = base::Sys.info())
[16:12:35.173]                   }
[16:12:35.173]                   ...future.conditions[[length(...future.conditions) + 
[16:12:35.173]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:35.173]                     cond$call), session = sessionInformation(), 
[16:12:35.173]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:35.173]                   signalCondition(cond)
[16:12:35.173]                 }
[16:12:35.173]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:35.173]                 "immediateCondition"))) {
[16:12:35.173]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:35.173]                   ...future.conditions[[length(...future.conditions) + 
[16:12:35.173]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:35.173]                   if (TRUE && !signal) {
[16:12:35.173]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:35.173]                     {
[16:12:35.173]                       inherits <- base::inherits
[16:12:35.173]                       invokeRestart <- base::invokeRestart
[16:12:35.173]                       is.null <- base::is.null
[16:12:35.173]                       muffled <- FALSE
[16:12:35.173]                       if (inherits(cond, "message")) {
[16:12:35.173]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:35.173]                         if (muffled) 
[16:12:35.173]                           invokeRestart("muffleMessage")
[16:12:35.173]                       }
[16:12:35.173]                       else if (inherits(cond, "warning")) {
[16:12:35.173]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:35.173]                         if (muffled) 
[16:12:35.173]                           invokeRestart("muffleWarning")
[16:12:35.173]                       }
[16:12:35.173]                       else if (inherits(cond, "condition")) {
[16:12:35.173]                         if (!is.null(pattern)) {
[16:12:35.173]                           computeRestarts <- base::computeRestarts
[16:12:35.173]                           grepl <- base::grepl
[16:12:35.173]                           restarts <- computeRestarts(cond)
[16:12:35.173]                           for (restart in restarts) {
[16:12:35.173]                             name <- restart$name
[16:12:35.173]                             if (is.null(name)) 
[16:12:35.173]                               next
[16:12:35.173]                             if (!grepl(pattern, name)) 
[16:12:35.173]                               next
[16:12:35.173]                             invokeRestart(restart)
[16:12:35.173]                             muffled <- TRUE
[16:12:35.173]                             break
[16:12:35.173]                           }
[16:12:35.173]                         }
[16:12:35.173]                       }
[16:12:35.173]                       invisible(muffled)
[16:12:35.173]                     }
[16:12:35.173]                     muffleCondition(cond, pattern = "^muffle")
[16:12:35.173]                   }
[16:12:35.173]                 }
[16:12:35.173]                 else {
[16:12:35.173]                   if (TRUE) {
[16:12:35.173]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:35.173]                     {
[16:12:35.173]                       inherits <- base::inherits
[16:12:35.173]                       invokeRestart <- base::invokeRestart
[16:12:35.173]                       is.null <- base::is.null
[16:12:35.173]                       muffled <- FALSE
[16:12:35.173]                       if (inherits(cond, "message")) {
[16:12:35.173]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:35.173]                         if (muffled) 
[16:12:35.173]                           invokeRestart("muffleMessage")
[16:12:35.173]                       }
[16:12:35.173]                       else if (inherits(cond, "warning")) {
[16:12:35.173]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:35.173]                         if (muffled) 
[16:12:35.173]                           invokeRestart("muffleWarning")
[16:12:35.173]                       }
[16:12:35.173]                       else if (inherits(cond, "condition")) {
[16:12:35.173]                         if (!is.null(pattern)) {
[16:12:35.173]                           computeRestarts <- base::computeRestarts
[16:12:35.173]                           grepl <- base::grepl
[16:12:35.173]                           restarts <- computeRestarts(cond)
[16:12:35.173]                           for (restart in restarts) {
[16:12:35.173]                             name <- restart$name
[16:12:35.173]                             if (is.null(name)) 
[16:12:35.173]                               next
[16:12:35.173]                             if (!grepl(pattern, name)) 
[16:12:35.173]                               next
[16:12:35.173]                             invokeRestart(restart)
[16:12:35.173]                             muffled <- TRUE
[16:12:35.173]                             break
[16:12:35.173]                           }
[16:12:35.173]                         }
[16:12:35.173]                       }
[16:12:35.173]                       invisible(muffled)
[16:12:35.173]                     }
[16:12:35.173]                     muffleCondition(cond, pattern = "^muffle")
[16:12:35.173]                   }
[16:12:35.173]                 }
[16:12:35.173]             }
[16:12:35.173]         }))
[16:12:35.173]     }, error = function(ex) {
[16:12:35.173]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:35.173]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:35.173]                 ...future.rng), started = ...future.startTime, 
[16:12:35.173]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:35.173]             version = "1.8"), class = "FutureResult")
[16:12:35.173]     }, finally = {
[16:12:35.173]         if (!identical(...future.workdir, getwd())) 
[16:12:35.173]             setwd(...future.workdir)
[16:12:35.173]         {
[16:12:35.173]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:35.173]                 ...future.oldOptions$nwarnings <- NULL
[16:12:35.173]             }
[16:12:35.173]             base::options(...future.oldOptions)
[16:12:35.173]             if (.Platform$OS.type == "windows") {
[16:12:35.173]                 old_names <- names(...future.oldEnvVars)
[16:12:35.173]                 envs <- base::Sys.getenv()
[16:12:35.173]                 names <- names(envs)
[16:12:35.173]                 common <- intersect(names, old_names)
[16:12:35.173]                 added <- setdiff(names, old_names)
[16:12:35.173]                 removed <- setdiff(old_names, names)
[16:12:35.173]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:35.173]                   envs[common]]
[16:12:35.173]                 NAMES <- toupper(changed)
[16:12:35.173]                 args <- list()
[16:12:35.173]                 for (kk in seq_along(NAMES)) {
[16:12:35.173]                   name <- changed[[kk]]
[16:12:35.173]                   NAME <- NAMES[[kk]]
[16:12:35.173]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:35.173]                     next
[16:12:35.173]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:35.173]                 }
[16:12:35.173]                 NAMES <- toupper(added)
[16:12:35.173]                 for (kk in seq_along(NAMES)) {
[16:12:35.173]                   name <- added[[kk]]
[16:12:35.173]                   NAME <- NAMES[[kk]]
[16:12:35.173]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:35.173]                     next
[16:12:35.173]                   args[[name]] <- ""
[16:12:35.173]                 }
[16:12:35.173]                 NAMES <- toupper(removed)
[16:12:35.173]                 for (kk in seq_along(NAMES)) {
[16:12:35.173]                   name <- removed[[kk]]
[16:12:35.173]                   NAME <- NAMES[[kk]]
[16:12:35.173]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:35.173]                     next
[16:12:35.173]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:35.173]                 }
[16:12:35.173]                 if (length(args) > 0) 
[16:12:35.173]                   base::do.call(base::Sys.setenv, args = args)
[16:12:35.173]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:35.173]             }
[16:12:35.173]             else {
[16:12:35.173]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:35.173]             }
[16:12:35.173]             {
[16:12:35.173]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:35.173]                   0L) {
[16:12:35.173]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:35.173]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:35.173]                   base::options(opts)
[16:12:35.173]                 }
[16:12:35.173]                 {
[16:12:35.173]                   {
[16:12:35.173]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:35.173]                     NULL
[16:12:35.173]                   }
[16:12:35.173]                   options(future.plan = NULL)
[16:12:35.173]                   if (is.na(NA_character_)) 
[16:12:35.173]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:35.173]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:35.173]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:35.173]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:35.173]                     envir = parent.frame()) 
[16:12:35.173]                   {
[16:12:35.173]                     if (is.function(workers)) 
[16:12:35.173]                       workers <- workers()
[16:12:35.173]                     workers <- structure(as.integer(workers), 
[16:12:35.173]                       class = class(workers))
[16:12:35.173]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:35.173]                       workers >= 1)
[16:12:35.173]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:35.173]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:35.173]                     }
[16:12:35.173]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:35.173]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:35.173]                       envir = envir)
[16:12:35.173]                     if (!future$lazy) 
[16:12:35.173]                       future <- run(future)
[16:12:35.173]                     invisible(future)
[16:12:35.173]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:35.173]                 }
[16:12:35.173]             }
[16:12:35.173]         }
[16:12:35.173]     })
[16:12:35.173]     if (TRUE) {
[16:12:35.173]         base::sink(type = "output", split = FALSE)
[16:12:35.173]         if (TRUE) {
[16:12:35.173]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:35.173]         }
[16:12:35.173]         else {
[16:12:35.173]             ...future.result["stdout"] <- base::list(NULL)
[16:12:35.173]         }
[16:12:35.173]         base::close(...future.stdout)
[16:12:35.173]         ...future.stdout <- NULL
[16:12:35.173]     }
[16:12:35.173]     ...future.result$conditions <- ...future.conditions
[16:12:35.173]     ...future.result$finished <- base::Sys.time()
[16:12:35.173]     ...future.result
[16:12:35.173] }
[16:12:35.177] MultisessionFuture started
[16:12:35.177] - Launch lazy future ... done
[16:12:35.177] run() for ‘MultisessionFuture’ ... done
[16:12:35.177] result() for ClusterFuture ...
[16:12:35.177] receiveMessageFromWorker() for ClusterFuture ...
[16:12:35.177] - Validating connection of MultisessionFuture
[16:12:35.227] - received message: FutureResult
[16:12:35.227] - Received FutureResult
[16:12:35.227] - Erased future from FutureRegistry
[16:12:35.227] result() for ClusterFuture ...
[16:12:35.227] - result already collected: FutureResult
[16:12:35.228] result() for ClusterFuture ... done
[16:12:35.228] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:35.228] result() for ClusterFuture ... done
[16:12:35.228] result() for ClusterFuture ...
[16:12:35.228] - result already collected: FutureResult
[16:12:35.228] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[16:12:35.230] getGlobalsAndPackages() ...
[16:12:35.230] Searching for globals...
[16:12:35.234] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[16:12:35.234] Searching for globals ... DONE
[16:12:35.234] Resolving globals: FALSE
[16:12:35.235] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[16:12:35.236] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[16:12:35.236] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[16:12:35.236] 
[16:12:35.236] getGlobalsAndPackages() ... DONE
[16:12:35.236] run() for ‘Future’ ...
[16:12:35.236] - state: ‘created’
[16:12:35.236] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:35.251] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:35.251] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:35.252]   - Field: ‘node’
[16:12:35.252]   - Field: ‘label’
[16:12:35.252]   - Field: ‘local’
[16:12:35.252]   - Field: ‘owner’
[16:12:35.252]   - Field: ‘envir’
[16:12:35.252]   - Field: ‘workers’
[16:12:35.252]   - Field: ‘packages’
[16:12:35.255]   - Field: ‘gc’
[16:12:35.255]   - Field: ‘conditions’
[16:12:35.255]   - Field: ‘persistent’
[16:12:35.255]   - Field: ‘expr’
[16:12:35.255]   - Field: ‘uuid’
[16:12:35.255]   - Field: ‘seed’
[16:12:35.255]   - Field: ‘version’
[16:12:35.255]   - Field: ‘result’
[16:12:35.255]   - Field: ‘asynchronous’
[16:12:35.255]   - Field: ‘calls’
[16:12:35.255]   - Field: ‘globals’
[16:12:35.256]   - Field: ‘stdout’
[16:12:35.256]   - Field: ‘earlySignal’
[16:12:35.256]   - Field: ‘lazy’
[16:12:35.256]   - Field: ‘state’
[16:12:35.256] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:35.256] - Launch lazy future ...
[16:12:35.256] Packages needed by the future expression (n = 0): <none>
[16:12:35.256] Packages needed by future strategies (n = 0): <none>
[16:12:35.257] {
[16:12:35.257]     {
[16:12:35.257]         {
[16:12:35.257]             ...future.startTime <- base::Sys.time()
[16:12:35.257]             {
[16:12:35.257]                 {
[16:12:35.257]                   {
[16:12:35.257]                     {
[16:12:35.257]                       base::local({
[16:12:35.257]                         has_future <- base::requireNamespace("future", 
[16:12:35.257]                           quietly = TRUE)
[16:12:35.257]                         if (has_future) {
[16:12:35.257]                           ns <- base::getNamespace("future")
[16:12:35.257]                           version <- ns[[".package"]][["version"]]
[16:12:35.257]                           if (is.null(version)) 
[16:12:35.257]                             version <- utils::packageVersion("future")
[16:12:35.257]                         }
[16:12:35.257]                         else {
[16:12:35.257]                           version <- NULL
[16:12:35.257]                         }
[16:12:35.257]                         if (!has_future || version < "1.8.0") {
[16:12:35.257]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:35.257]                             "", base::R.version$version.string), 
[16:12:35.257]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:35.257]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:35.257]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:35.257]                               "release", "version")], collapse = " "), 
[16:12:35.257]                             hostname = base::Sys.info()[["nodename"]])
[16:12:35.257]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:35.257]                             info)
[16:12:35.257]                           info <- base::paste(info, collapse = "; ")
[16:12:35.257]                           if (!has_future) {
[16:12:35.257]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:35.257]                               info)
[16:12:35.257]                           }
[16:12:35.257]                           else {
[16:12:35.257]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:35.257]                               info, version)
[16:12:35.257]                           }
[16:12:35.257]                           base::stop(msg)
[16:12:35.257]                         }
[16:12:35.257]                       })
[16:12:35.257]                     }
[16:12:35.257]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:35.257]                     base::options(mc.cores = 1L)
[16:12:35.257]                   }
[16:12:35.257]                   options(future.plan = NULL)
[16:12:35.257]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:35.257]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:35.257]                 }
[16:12:35.257]                 ...future.workdir <- getwd()
[16:12:35.257]             }
[16:12:35.257]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:35.257]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:35.257]         }
[16:12:35.257]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:35.257]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:35.257]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:35.257]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:35.257]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:35.257]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:35.257]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:35.257]             base::names(...future.oldOptions))
[16:12:35.257]     }
[16:12:35.257]     if (FALSE) {
[16:12:35.257]     }
[16:12:35.257]     else {
[16:12:35.257]         if (TRUE) {
[16:12:35.257]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:35.257]                 open = "w")
[16:12:35.257]         }
[16:12:35.257]         else {
[16:12:35.257]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:35.257]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:35.257]         }
[16:12:35.257]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:35.257]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:35.257]             base::sink(type = "output", split = FALSE)
[16:12:35.257]             base::close(...future.stdout)
[16:12:35.257]         }, add = TRUE)
[16:12:35.257]     }
[16:12:35.257]     ...future.frame <- base::sys.nframe()
[16:12:35.257]     ...future.conditions <- base::list()
[16:12:35.257]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:35.257]     if (FALSE) {
[16:12:35.257]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:35.257]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:35.257]     }
[16:12:35.257]     ...future.result <- base::tryCatch({
[16:12:35.257]         base::withCallingHandlers({
[16:12:35.257]             ...future.value <- base::withVisible(base::local({
[16:12:35.257]                 ...future.makeSendCondition <- local({
[16:12:35.257]                   sendCondition <- NULL
[16:12:35.257]                   function(frame = 1L) {
[16:12:35.257]                     if (is.function(sendCondition)) 
[16:12:35.257]                       return(sendCondition)
[16:12:35.257]                     ns <- getNamespace("parallel")
[16:12:35.257]                     if (exists("sendData", mode = "function", 
[16:12:35.257]                       envir = ns)) {
[16:12:35.257]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:35.257]                         envir = ns)
[16:12:35.257]                       envir <- sys.frame(frame)
[16:12:35.257]                       master <- NULL
[16:12:35.257]                       while (!identical(envir, .GlobalEnv) && 
[16:12:35.257]                         !identical(envir, emptyenv())) {
[16:12:35.257]                         if (exists("master", mode = "list", envir = envir, 
[16:12:35.257]                           inherits = FALSE)) {
[16:12:35.257]                           master <- get("master", mode = "list", 
[16:12:35.257]                             envir = envir, inherits = FALSE)
[16:12:35.257]                           if (inherits(master, c("SOCKnode", 
[16:12:35.257]                             "SOCK0node"))) {
[16:12:35.257]                             sendCondition <<- function(cond) {
[16:12:35.257]                               data <- list(type = "VALUE", value = cond, 
[16:12:35.257]                                 success = TRUE)
[16:12:35.257]                               parallel_sendData(master, data)
[16:12:35.257]                             }
[16:12:35.257]                             return(sendCondition)
[16:12:35.257]                           }
[16:12:35.257]                         }
[16:12:35.257]                         frame <- frame + 1L
[16:12:35.257]                         envir <- sys.frame(frame)
[16:12:35.257]                       }
[16:12:35.257]                     }
[16:12:35.257]                     sendCondition <<- function(cond) NULL
[16:12:35.257]                   }
[16:12:35.257]                 })
[16:12:35.257]                 withCallingHandlers({
[16:12:35.257]                   {
[16:12:35.257]                     outer_function(1L)
[16:12:35.257]                   }
[16:12:35.257]                 }, immediateCondition = function(cond) {
[16:12:35.257]                   sendCondition <- ...future.makeSendCondition()
[16:12:35.257]                   sendCondition(cond)
[16:12:35.257]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:35.257]                   {
[16:12:35.257]                     inherits <- base::inherits
[16:12:35.257]                     invokeRestart <- base::invokeRestart
[16:12:35.257]                     is.null <- base::is.null
[16:12:35.257]                     muffled <- FALSE
[16:12:35.257]                     if (inherits(cond, "message")) {
[16:12:35.257]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:35.257]                       if (muffled) 
[16:12:35.257]                         invokeRestart("muffleMessage")
[16:12:35.257]                     }
[16:12:35.257]                     else if (inherits(cond, "warning")) {
[16:12:35.257]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:35.257]                       if (muffled) 
[16:12:35.257]                         invokeRestart("muffleWarning")
[16:12:35.257]                     }
[16:12:35.257]                     else if (inherits(cond, "condition")) {
[16:12:35.257]                       if (!is.null(pattern)) {
[16:12:35.257]                         computeRestarts <- base::computeRestarts
[16:12:35.257]                         grepl <- base::grepl
[16:12:35.257]                         restarts <- computeRestarts(cond)
[16:12:35.257]                         for (restart in restarts) {
[16:12:35.257]                           name <- restart$name
[16:12:35.257]                           if (is.null(name)) 
[16:12:35.257]                             next
[16:12:35.257]                           if (!grepl(pattern, name)) 
[16:12:35.257]                             next
[16:12:35.257]                           invokeRestart(restart)
[16:12:35.257]                           muffled <- TRUE
[16:12:35.257]                           break
[16:12:35.257]                         }
[16:12:35.257]                       }
[16:12:35.257]                     }
[16:12:35.257]                     invisible(muffled)
[16:12:35.257]                   }
[16:12:35.257]                   muffleCondition(cond)
[16:12:35.257]                 })
[16:12:35.257]             }))
[16:12:35.257]             future::FutureResult(value = ...future.value$value, 
[16:12:35.257]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:35.257]                   ...future.rng), globalenv = if (FALSE) 
[16:12:35.257]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:35.257]                     ...future.globalenv.names))
[16:12:35.257]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:35.257]         }, condition = base::local({
[16:12:35.257]             c <- base::c
[16:12:35.257]             inherits <- base::inherits
[16:12:35.257]             invokeRestart <- base::invokeRestart
[16:12:35.257]             length <- base::length
[16:12:35.257]             list <- base::list
[16:12:35.257]             seq.int <- base::seq.int
[16:12:35.257]             signalCondition <- base::signalCondition
[16:12:35.257]             sys.calls <- base::sys.calls
[16:12:35.257]             `[[` <- base::`[[`
[16:12:35.257]             `+` <- base::`+`
[16:12:35.257]             `<<-` <- base::`<<-`
[16:12:35.257]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:35.257]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:35.257]                   3L)]
[16:12:35.257]             }
[16:12:35.257]             function(cond) {
[16:12:35.257]                 is_error <- inherits(cond, "error")
[16:12:35.257]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:35.257]                   NULL)
[16:12:35.257]                 if (is_error) {
[16:12:35.257]                   sessionInformation <- function() {
[16:12:35.257]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:35.257]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:35.257]                       search = base::search(), system = base::Sys.info())
[16:12:35.257]                   }
[16:12:35.257]                   ...future.conditions[[length(...future.conditions) + 
[16:12:35.257]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:35.257]                     cond$call), session = sessionInformation(), 
[16:12:35.257]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:35.257]                   signalCondition(cond)
[16:12:35.257]                 }
[16:12:35.257]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:35.257]                 "immediateCondition"))) {
[16:12:35.257]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:35.257]                   ...future.conditions[[length(...future.conditions) + 
[16:12:35.257]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:35.257]                   if (TRUE && !signal) {
[16:12:35.257]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:35.257]                     {
[16:12:35.257]                       inherits <- base::inherits
[16:12:35.257]                       invokeRestart <- base::invokeRestart
[16:12:35.257]                       is.null <- base::is.null
[16:12:35.257]                       muffled <- FALSE
[16:12:35.257]                       if (inherits(cond, "message")) {
[16:12:35.257]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:35.257]                         if (muffled) 
[16:12:35.257]                           invokeRestart("muffleMessage")
[16:12:35.257]                       }
[16:12:35.257]                       else if (inherits(cond, "warning")) {
[16:12:35.257]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:35.257]                         if (muffled) 
[16:12:35.257]                           invokeRestart("muffleWarning")
[16:12:35.257]                       }
[16:12:35.257]                       else if (inherits(cond, "condition")) {
[16:12:35.257]                         if (!is.null(pattern)) {
[16:12:35.257]                           computeRestarts <- base::computeRestarts
[16:12:35.257]                           grepl <- base::grepl
[16:12:35.257]                           restarts <- computeRestarts(cond)
[16:12:35.257]                           for (restart in restarts) {
[16:12:35.257]                             name <- restart$name
[16:12:35.257]                             if (is.null(name)) 
[16:12:35.257]                               next
[16:12:35.257]                             if (!grepl(pattern, name)) 
[16:12:35.257]                               next
[16:12:35.257]                             invokeRestart(restart)
[16:12:35.257]                             muffled <- TRUE
[16:12:35.257]                             break
[16:12:35.257]                           }
[16:12:35.257]                         }
[16:12:35.257]                       }
[16:12:35.257]                       invisible(muffled)
[16:12:35.257]                     }
[16:12:35.257]                     muffleCondition(cond, pattern = "^muffle")
[16:12:35.257]                   }
[16:12:35.257]                 }
[16:12:35.257]                 else {
[16:12:35.257]                   if (TRUE) {
[16:12:35.257]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:35.257]                     {
[16:12:35.257]                       inherits <- base::inherits
[16:12:35.257]                       invokeRestart <- base::invokeRestart
[16:12:35.257]                       is.null <- base::is.null
[16:12:35.257]                       muffled <- FALSE
[16:12:35.257]                       if (inherits(cond, "message")) {
[16:12:35.257]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:35.257]                         if (muffled) 
[16:12:35.257]                           invokeRestart("muffleMessage")
[16:12:35.257]                       }
[16:12:35.257]                       else if (inherits(cond, "warning")) {
[16:12:35.257]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:35.257]                         if (muffled) 
[16:12:35.257]                           invokeRestart("muffleWarning")
[16:12:35.257]                       }
[16:12:35.257]                       else if (inherits(cond, "condition")) {
[16:12:35.257]                         if (!is.null(pattern)) {
[16:12:35.257]                           computeRestarts <- base::computeRestarts
[16:12:35.257]                           grepl <- base::grepl
[16:12:35.257]                           restarts <- computeRestarts(cond)
[16:12:35.257]                           for (restart in restarts) {
[16:12:35.257]                             name <- restart$name
[16:12:35.257]                             if (is.null(name)) 
[16:12:35.257]                               next
[16:12:35.257]                             if (!grepl(pattern, name)) 
[16:12:35.257]                               next
[16:12:35.257]                             invokeRestart(restart)
[16:12:35.257]                             muffled <- TRUE
[16:12:35.257]                             break
[16:12:35.257]                           }
[16:12:35.257]                         }
[16:12:35.257]                       }
[16:12:35.257]                       invisible(muffled)
[16:12:35.257]                     }
[16:12:35.257]                     muffleCondition(cond, pattern = "^muffle")
[16:12:35.257]                   }
[16:12:35.257]                 }
[16:12:35.257]             }
[16:12:35.257]         }))
[16:12:35.257]     }, error = function(ex) {
[16:12:35.257]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:35.257]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:35.257]                 ...future.rng), started = ...future.startTime, 
[16:12:35.257]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:35.257]             version = "1.8"), class = "FutureResult")
[16:12:35.257]     }, finally = {
[16:12:35.257]         if (!identical(...future.workdir, getwd())) 
[16:12:35.257]             setwd(...future.workdir)
[16:12:35.257]         {
[16:12:35.257]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:35.257]                 ...future.oldOptions$nwarnings <- NULL
[16:12:35.257]             }
[16:12:35.257]             base::options(...future.oldOptions)
[16:12:35.257]             if (.Platform$OS.type == "windows") {
[16:12:35.257]                 old_names <- names(...future.oldEnvVars)
[16:12:35.257]                 envs <- base::Sys.getenv()
[16:12:35.257]                 names <- names(envs)
[16:12:35.257]                 common <- intersect(names, old_names)
[16:12:35.257]                 added <- setdiff(names, old_names)
[16:12:35.257]                 removed <- setdiff(old_names, names)
[16:12:35.257]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:35.257]                   envs[common]]
[16:12:35.257]                 NAMES <- toupper(changed)
[16:12:35.257]                 args <- list()
[16:12:35.257]                 for (kk in seq_along(NAMES)) {
[16:12:35.257]                   name <- changed[[kk]]
[16:12:35.257]                   NAME <- NAMES[[kk]]
[16:12:35.257]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:35.257]                     next
[16:12:35.257]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:35.257]                 }
[16:12:35.257]                 NAMES <- toupper(added)
[16:12:35.257]                 for (kk in seq_along(NAMES)) {
[16:12:35.257]                   name <- added[[kk]]
[16:12:35.257]                   NAME <- NAMES[[kk]]
[16:12:35.257]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:35.257]                     next
[16:12:35.257]                   args[[name]] <- ""
[16:12:35.257]                 }
[16:12:35.257]                 NAMES <- toupper(removed)
[16:12:35.257]                 for (kk in seq_along(NAMES)) {
[16:12:35.257]                   name <- removed[[kk]]
[16:12:35.257]                   NAME <- NAMES[[kk]]
[16:12:35.257]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:35.257]                     next
[16:12:35.257]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:35.257]                 }
[16:12:35.257]                 if (length(args) > 0) 
[16:12:35.257]                   base::do.call(base::Sys.setenv, args = args)
[16:12:35.257]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:35.257]             }
[16:12:35.257]             else {
[16:12:35.257]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:35.257]             }
[16:12:35.257]             {
[16:12:35.257]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:35.257]                   0L) {
[16:12:35.257]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:35.257]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:35.257]                   base::options(opts)
[16:12:35.257]                 }
[16:12:35.257]                 {
[16:12:35.257]                   {
[16:12:35.257]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:35.257]                     NULL
[16:12:35.257]                   }
[16:12:35.257]                   options(future.plan = NULL)
[16:12:35.257]                   if (is.na(NA_character_)) 
[16:12:35.257]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:35.257]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:35.257]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:35.257]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:35.257]                     envir = parent.frame()) 
[16:12:35.257]                   {
[16:12:35.257]                     if (is.function(workers)) 
[16:12:35.257]                       workers <- workers()
[16:12:35.257]                     workers <- structure(as.integer(workers), 
[16:12:35.257]                       class = class(workers))
[16:12:35.257]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:35.257]                       workers >= 1)
[16:12:35.257]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:35.257]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:35.257]                     }
[16:12:35.257]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:35.257]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:35.257]                       envir = envir)
[16:12:35.257]                     if (!future$lazy) 
[16:12:35.257]                       future <- run(future)
[16:12:35.257]                     invisible(future)
[16:12:35.257]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:35.257]                 }
[16:12:35.257]             }
[16:12:35.257]         }
[16:12:35.257]     })
[16:12:35.257]     if (TRUE) {
[16:12:35.257]         base::sink(type = "output", split = FALSE)
[16:12:35.257]         if (TRUE) {
[16:12:35.257]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:35.257]         }
[16:12:35.257]         else {
[16:12:35.257]             ...future.result["stdout"] <- base::list(NULL)
[16:12:35.257]         }
[16:12:35.257]         base::close(...future.stdout)
[16:12:35.257]         ...future.stdout <- NULL
[16:12:35.257]     }
[16:12:35.257]     ...future.result$conditions <- ...future.conditions
[16:12:35.257]     ...future.result$finished <- base::Sys.time()
[16:12:35.257]     ...future.result
[16:12:35.257] }
[16:12:35.260] Exporting 3 global objects (7.52 KiB) to cluster node #1 ...
[16:12:35.260] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ...
[16:12:35.260] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ... DONE
[16:12:35.260] Exporting ‘map’ (4.43 KiB) to cluster node #1 ...
[16:12:35.261] Exporting ‘map’ (4.43 KiB) to cluster node #1 ... DONE
[16:12:35.261] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ...
[16:12:35.261] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ... DONE
[16:12:35.261] Exporting 3 global objects (7.52 KiB) to cluster node #1 ... DONE
[16:12:35.262] MultisessionFuture started
[16:12:35.262] - Launch lazy future ... done
[16:12:35.262] run() for ‘MultisessionFuture’ ... done
[16:12:35.262] result() for ClusterFuture ...
[16:12:35.262] receiveMessageFromWorker() for ClusterFuture ...
[16:12:35.262] - Validating connection of MultisessionFuture
[16:12:35.313] - received message: FutureResult
[16:12:35.313] - Received FutureResult
[16:12:35.313] - Erased future from FutureRegistry
[16:12:35.313] result() for ClusterFuture ...
[16:12:35.313] - result already collected: FutureResult
[16:12:35.313] result() for ClusterFuture ... done
[16:12:35.313] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:35.313] result() for ClusterFuture ... done
[16:12:35.314] result() for ClusterFuture ...
[16:12:35.314] - result already collected: FutureResult
[16:12:35.314] result() for ClusterFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[16:12:35.315] getGlobalsAndPackages() ...
[16:12:35.315] Searching for globals...
[16:12:35.319] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[16:12:35.319] Searching for globals ... DONE
[16:12:35.319] Resolving globals: FALSE
[16:12:35.320] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[16:12:35.320] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[16:12:35.320] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[16:12:35.321] 
[16:12:35.321] getGlobalsAndPackages() ... DONE
[16:12:35.321] run() for ‘Future’ ...
[16:12:35.321] - state: ‘created’
[16:12:35.321] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:35.336] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:35.336] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:35.336]   - Field: ‘node’
[16:12:35.336]   - Field: ‘label’
[16:12:35.336]   - Field: ‘local’
[16:12:35.336]   - Field: ‘owner’
[16:12:35.336]   - Field: ‘envir’
[16:12:35.336]   - Field: ‘workers’
[16:12:35.336]   - Field: ‘packages’
[16:12:35.337]   - Field: ‘gc’
[16:12:35.337]   - Field: ‘conditions’
[16:12:35.337]   - Field: ‘persistent’
[16:12:35.337]   - Field: ‘expr’
[16:12:35.337]   - Field: ‘uuid’
[16:12:35.337]   - Field: ‘seed’
[16:12:35.337]   - Field: ‘version’
[16:12:35.337]   - Field: ‘result’
[16:12:35.337]   - Field: ‘asynchronous’
[16:12:35.337]   - Field: ‘calls’
[16:12:35.337]   - Field: ‘globals’
[16:12:35.338]   - Field: ‘stdout’
[16:12:35.338]   - Field: ‘earlySignal’
[16:12:35.338]   - Field: ‘lazy’
[16:12:35.338]   - Field: ‘state’
[16:12:35.338] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:35.338] - Launch lazy future ...
[16:12:35.338] Packages needed by the future expression (n = 0): <none>
[16:12:35.338] Packages needed by future strategies (n = 0): <none>
[16:12:35.339] {
[16:12:35.339]     {
[16:12:35.339]         {
[16:12:35.339]             ...future.startTime <- base::Sys.time()
[16:12:35.339]             {
[16:12:35.339]                 {
[16:12:35.339]                   {
[16:12:35.339]                     {
[16:12:35.339]                       base::local({
[16:12:35.339]                         has_future <- base::requireNamespace("future", 
[16:12:35.339]                           quietly = TRUE)
[16:12:35.339]                         if (has_future) {
[16:12:35.339]                           ns <- base::getNamespace("future")
[16:12:35.339]                           version <- ns[[".package"]][["version"]]
[16:12:35.339]                           if (is.null(version)) 
[16:12:35.339]                             version <- utils::packageVersion("future")
[16:12:35.339]                         }
[16:12:35.339]                         else {
[16:12:35.339]                           version <- NULL
[16:12:35.339]                         }
[16:12:35.339]                         if (!has_future || version < "1.8.0") {
[16:12:35.339]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:35.339]                             "", base::R.version$version.string), 
[16:12:35.339]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:35.339]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:35.339]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:35.339]                               "release", "version")], collapse = " "), 
[16:12:35.339]                             hostname = base::Sys.info()[["nodename"]])
[16:12:35.339]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:35.339]                             info)
[16:12:35.339]                           info <- base::paste(info, collapse = "; ")
[16:12:35.339]                           if (!has_future) {
[16:12:35.339]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:35.339]                               info)
[16:12:35.339]                           }
[16:12:35.339]                           else {
[16:12:35.339]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:35.339]                               info, version)
[16:12:35.339]                           }
[16:12:35.339]                           base::stop(msg)
[16:12:35.339]                         }
[16:12:35.339]                       })
[16:12:35.339]                     }
[16:12:35.339]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:35.339]                     base::options(mc.cores = 1L)
[16:12:35.339]                   }
[16:12:35.339]                   options(future.plan = NULL)
[16:12:35.339]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:35.339]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:35.339]                 }
[16:12:35.339]                 ...future.workdir <- getwd()
[16:12:35.339]             }
[16:12:35.339]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:35.339]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:35.339]         }
[16:12:35.339]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:35.339]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:35.339]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:35.339]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:35.339]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:35.339]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:35.339]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:35.339]             base::names(...future.oldOptions))
[16:12:35.339]     }
[16:12:35.339]     if (FALSE) {
[16:12:35.339]     }
[16:12:35.339]     else {
[16:12:35.339]         if (TRUE) {
[16:12:35.339]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:35.339]                 open = "w")
[16:12:35.339]         }
[16:12:35.339]         else {
[16:12:35.339]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:35.339]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:35.339]         }
[16:12:35.339]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:35.339]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:35.339]             base::sink(type = "output", split = FALSE)
[16:12:35.339]             base::close(...future.stdout)
[16:12:35.339]         }, add = TRUE)
[16:12:35.339]     }
[16:12:35.339]     ...future.frame <- base::sys.nframe()
[16:12:35.339]     ...future.conditions <- base::list()
[16:12:35.339]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:35.339]     if (FALSE) {
[16:12:35.339]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:35.339]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:35.339]     }
[16:12:35.339]     ...future.result <- base::tryCatch({
[16:12:35.339]         base::withCallingHandlers({
[16:12:35.339]             ...future.value <- base::withVisible(base::local({
[16:12:35.339]                 ...future.makeSendCondition <- local({
[16:12:35.339]                   sendCondition <- NULL
[16:12:35.339]                   function(frame = 1L) {
[16:12:35.339]                     if (is.function(sendCondition)) 
[16:12:35.339]                       return(sendCondition)
[16:12:35.339]                     ns <- getNamespace("parallel")
[16:12:35.339]                     if (exists("sendData", mode = "function", 
[16:12:35.339]                       envir = ns)) {
[16:12:35.339]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:35.339]                         envir = ns)
[16:12:35.339]                       envir <- sys.frame(frame)
[16:12:35.339]                       master <- NULL
[16:12:35.339]                       while (!identical(envir, .GlobalEnv) && 
[16:12:35.339]                         !identical(envir, emptyenv())) {
[16:12:35.339]                         if (exists("master", mode = "list", envir = envir, 
[16:12:35.339]                           inherits = FALSE)) {
[16:12:35.339]                           master <- get("master", mode = "list", 
[16:12:35.339]                             envir = envir, inherits = FALSE)
[16:12:35.339]                           if (inherits(master, c("SOCKnode", 
[16:12:35.339]                             "SOCK0node"))) {
[16:12:35.339]                             sendCondition <<- function(cond) {
[16:12:35.339]                               data <- list(type = "VALUE", value = cond, 
[16:12:35.339]                                 success = TRUE)
[16:12:35.339]                               parallel_sendData(master, data)
[16:12:35.339]                             }
[16:12:35.339]                             return(sendCondition)
[16:12:35.339]                           }
[16:12:35.339]                         }
[16:12:35.339]                         frame <- frame + 1L
[16:12:35.339]                         envir <- sys.frame(frame)
[16:12:35.339]                       }
[16:12:35.339]                     }
[16:12:35.339]                     sendCondition <<- function(cond) NULL
[16:12:35.339]                   }
[16:12:35.339]                 })
[16:12:35.339]                 withCallingHandlers({
[16:12:35.339]                   {
[16:12:35.339]                     outer_function(1L)
[16:12:35.339]                   }
[16:12:35.339]                 }, immediateCondition = function(cond) {
[16:12:35.339]                   sendCondition <- ...future.makeSendCondition()
[16:12:35.339]                   sendCondition(cond)
[16:12:35.339]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:35.339]                   {
[16:12:35.339]                     inherits <- base::inherits
[16:12:35.339]                     invokeRestart <- base::invokeRestart
[16:12:35.339]                     is.null <- base::is.null
[16:12:35.339]                     muffled <- FALSE
[16:12:35.339]                     if (inherits(cond, "message")) {
[16:12:35.339]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:35.339]                       if (muffled) 
[16:12:35.339]                         invokeRestart("muffleMessage")
[16:12:35.339]                     }
[16:12:35.339]                     else if (inherits(cond, "warning")) {
[16:12:35.339]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:35.339]                       if (muffled) 
[16:12:35.339]                         invokeRestart("muffleWarning")
[16:12:35.339]                     }
[16:12:35.339]                     else if (inherits(cond, "condition")) {
[16:12:35.339]                       if (!is.null(pattern)) {
[16:12:35.339]                         computeRestarts <- base::computeRestarts
[16:12:35.339]                         grepl <- base::grepl
[16:12:35.339]                         restarts <- computeRestarts(cond)
[16:12:35.339]                         for (restart in restarts) {
[16:12:35.339]                           name <- restart$name
[16:12:35.339]                           if (is.null(name)) 
[16:12:35.339]                             next
[16:12:35.339]                           if (!grepl(pattern, name)) 
[16:12:35.339]                             next
[16:12:35.339]                           invokeRestart(restart)
[16:12:35.339]                           muffled <- TRUE
[16:12:35.339]                           break
[16:12:35.339]                         }
[16:12:35.339]                       }
[16:12:35.339]                     }
[16:12:35.339]                     invisible(muffled)
[16:12:35.339]                   }
[16:12:35.339]                   muffleCondition(cond)
[16:12:35.339]                 })
[16:12:35.339]             }))
[16:12:35.339]             future::FutureResult(value = ...future.value$value, 
[16:12:35.339]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:35.339]                   ...future.rng), globalenv = if (FALSE) 
[16:12:35.339]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:35.339]                     ...future.globalenv.names))
[16:12:35.339]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:35.339]         }, condition = base::local({
[16:12:35.339]             c <- base::c
[16:12:35.339]             inherits <- base::inherits
[16:12:35.339]             invokeRestart <- base::invokeRestart
[16:12:35.339]             length <- base::length
[16:12:35.339]             list <- base::list
[16:12:35.339]             seq.int <- base::seq.int
[16:12:35.339]             signalCondition <- base::signalCondition
[16:12:35.339]             sys.calls <- base::sys.calls
[16:12:35.339]             `[[` <- base::`[[`
[16:12:35.339]             `+` <- base::`+`
[16:12:35.339]             `<<-` <- base::`<<-`
[16:12:35.339]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:35.339]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:35.339]                   3L)]
[16:12:35.339]             }
[16:12:35.339]             function(cond) {
[16:12:35.339]                 is_error <- inherits(cond, "error")
[16:12:35.339]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:35.339]                   NULL)
[16:12:35.339]                 if (is_error) {
[16:12:35.339]                   sessionInformation <- function() {
[16:12:35.339]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:35.339]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:35.339]                       search = base::search(), system = base::Sys.info())
[16:12:35.339]                   }
[16:12:35.339]                   ...future.conditions[[length(...future.conditions) + 
[16:12:35.339]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:35.339]                     cond$call), session = sessionInformation(), 
[16:12:35.339]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:35.339]                   signalCondition(cond)
[16:12:35.339]                 }
[16:12:35.339]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:35.339]                 "immediateCondition"))) {
[16:12:35.339]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:35.339]                   ...future.conditions[[length(...future.conditions) + 
[16:12:35.339]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:35.339]                   if (TRUE && !signal) {
[16:12:35.339]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:35.339]                     {
[16:12:35.339]                       inherits <- base::inherits
[16:12:35.339]                       invokeRestart <- base::invokeRestart
[16:12:35.339]                       is.null <- base::is.null
[16:12:35.339]                       muffled <- FALSE
[16:12:35.339]                       if (inherits(cond, "message")) {
[16:12:35.339]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:35.339]                         if (muffled) 
[16:12:35.339]                           invokeRestart("muffleMessage")
[16:12:35.339]                       }
[16:12:35.339]                       else if (inherits(cond, "warning")) {
[16:12:35.339]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:35.339]                         if (muffled) 
[16:12:35.339]                           invokeRestart("muffleWarning")
[16:12:35.339]                       }
[16:12:35.339]                       else if (inherits(cond, "condition")) {
[16:12:35.339]                         if (!is.null(pattern)) {
[16:12:35.339]                           computeRestarts <- base::computeRestarts
[16:12:35.339]                           grepl <- base::grepl
[16:12:35.339]                           restarts <- computeRestarts(cond)
[16:12:35.339]                           for (restart in restarts) {
[16:12:35.339]                             name <- restart$name
[16:12:35.339]                             if (is.null(name)) 
[16:12:35.339]                               next
[16:12:35.339]                             if (!grepl(pattern, name)) 
[16:12:35.339]                               next
[16:12:35.339]                             invokeRestart(restart)
[16:12:35.339]                             muffled <- TRUE
[16:12:35.339]                             break
[16:12:35.339]                           }
[16:12:35.339]                         }
[16:12:35.339]                       }
[16:12:35.339]                       invisible(muffled)
[16:12:35.339]                     }
[16:12:35.339]                     muffleCondition(cond, pattern = "^muffle")
[16:12:35.339]                   }
[16:12:35.339]                 }
[16:12:35.339]                 else {
[16:12:35.339]                   if (TRUE) {
[16:12:35.339]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:35.339]                     {
[16:12:35.339]                       inherits <- base::inherits
[16:12:35.339]                       invokeRestart <- base::invokeRestart
[16:12:35.339]                       is.null <- base::is.null
[16:12:35.339]                       muffled <- FALSE
[16:12:35.339]                       if (inherits(cond, "message")) {
[16:12:35.339]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:35.339]                         if (muffled) 
[16:12:35.339]                           invokeRestart("muffleMessage")
[16:12:35.339]                       }
[16:12:35.339]                       else if (inherits(cond, "warning")) {
[16:12:35.339]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:35.339]                         if (muffled) 
[16:12:35.339]                           invokeRestart("muffleWarning")
[16:12:35.339]                       }
[16:12:35.339]                       else if (inherits(cond, "condition")) {
[16:12:35.339]                         if (!is.null(pattern)) {
[16:12:35.339]                           computeRestarts <- base::computeRestarts
[16:12:35.339]                           grepl <- base::grepl
[16:12:35.339]                           restarts <- computeRestarts(cond)
[16:12:35.339]                           for (restart in restarts) {
[16:12:35.339]                             name <- restart$name
[16:12:35.339]                             if (is.null(name)) 
[16:12:35.339]                               next
[16:12:35.339]                             if (!grepl(pattern, name)) 
[16:12:35.339]                               next
[16:12:35.339]                             invokeRestart(restart)
[16:12:35.339]                             muffled <- TRUE
[16:12:35.339]                             break
[16:12:35.339]                           }
[16:12:35.339]                         }
[16:12:35.339]                       }
[16:12:35.339]                       invisible(muffled)
[16:12:35.339]                     }
[16:12:35.339]                     muffleCondition(cond, pattern = "^muffle")
[16:12:35.339]                   }
[16:12:35.339]                 }
[16:12:35.339]             }
[16:12:35.339]         }))
[16:12:35.339]     }, error = function(ex) {
[16:12:35.339]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:35.339]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:35.339]                 ...future.rng), started = ...future.startTime, 
[16:12:35.339]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:35.339]             version = "1.8"), class = "FutureResult")
[16:12:35.339]     }, finally = {
[16:12:35.339]         if (!identical(...future.workdir, getwd())) 
[16:12:35.339]             setwd(...future.workdir)
[16:12:35.339]         {
[16:12:35.339]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:35.339]                 ...future.oldOptions$nwarnings <- NULL
[16:12:35.339]             }
[16:12:35.339]             base::options(...future.oldOptions)
[16:12:35.339]             if (.Platform$OS.type == "windows") {
[16:12:35.339]                 old_names <- names(...future.oldEnvVars)
[16:12:35.339]                 envs <- base::Sys.getenv()
[16:12:35.339]                 names <- names(envs)
[16:12:35.339]                 common <- intersect(names, old_names)
[16:12:35.339]                 added <- setdiff(names, old_names)
[16:12:35.339]                 removed <- setdiff(old_names, names)
[16:12:35.339]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:35.339]                   envs[common]]
[16:12:35.339]                 NAMES <- toupper(changed)
[16:12:35.339]                 args <- list()
[16:12:35.339]                 for (kk in seq_along(NAMES)) {
[16:12:35.339]                   name <- changed[[kk]]
[16:12:35.339]                   NAME <- NAMES[[kk]]
[16:12:35.339]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:35.339]                     next
[16:12:35.339]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:35.339]                 }
[16:12:35.339]                 NAMES <- toupper(added)
[16:12:35.339]                 for (kk in seq_along(NAMES)) {
[16:12:35.339]                   name <- added[[kk]]
[16:12:35.339]                   NAME <- NAMES[[kk]]
[16:12:35.339]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:35.339]                     next
[16:12:35.339]                   args[[name]] <- ""
[16:12:35.339]                 }
[16:12:35.339]                 NAMES <- toupper(removed)
[16:12:35.339]                 for (kk in seq_along(NAMES)) {
[16:12:35.339]                   name <- removed[[kk]]
[16:12:35.339]                   NAME <- NAMES[[kk]]
[16:12:35.339]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:35.339]                     next
[16:12:35.339]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:35.339]                 }
[16:12:35.339]                 if (length(args) > 0) 
[16:12:35.339]                   base::do.call(base::Sys.setenv, args = args)
[16:12:35.339]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:35.339]             }
[16:12:35.339]             else {
[16:12:35.339]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:35.339]             }
[16:12:35.339]             {
[16:12:35.339]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:35.339]                   0L) {
[16:12:35.339]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:35.339]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:35.339]                   base::options(opts)
[16:12:35.339]                 }
[16:12:35.339]                 {
[16:12:35.339]                   {
[16:12:35.339]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:35.339]                     NULL
[16:12:35.339]                   }
[16:12:35.339]                   options(future.plan = NULL)
[16:12:35.339]                   if (is.na(NA_character_)) 
[16:12:35.339]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:35.339]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:35.339]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:35.339]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:35.339]                     envir = parent.frame()) 
[16:12:35.339]                   {
[16:12:35.339]                     if (is.function(workers)) 
[16:12:35.339]                       workers <- workers()
[16:12:35.339]                     workers <- structure(as.integer(workers), 
[16:12:35.339]                       class = class(workers))
[16:12:35.339]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:35.339]                       workers >= 1)
[16:12:35.339]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:35.339]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:35.339]                     }
[16:12:35.339]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:35.339]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:35.339]                       envir = envir)
[16:12:35.339]                     if (!future$lazy) 
[16:12:35.339]                       future <- run(future)
[16:12:35.339]                     invisible(future)
[16:12:35.339]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:35.339]                 }
[16:12:35.339]             }
[16:12:35.339]         }
[16:12:35.339]     })
[16:12:35.339]     if (TRUE) {
[16:12:35.339]         base::sink(type = "output", split = FALSE)
[16:12:35.339]         if (TRUE) {
[16:12:35.339]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:35.339]         }
[16:12:35.339]         else {
[16:12:35.339]             ...future.result["stdout"] <- base::list(NULL)
[16:12:35.339]         }
[16:12:35.339]         base::close(...future.stdout)
[16:12:35.339]         ...future.stdout <- NULL
[16:12:35.339]     }
[16:12:35.339]     ...future.result$conditions <- ...future.conditions
[16:12:35.339]     ...future.result$finished <- base::Sys.time()
[16:12:35.339]     ...future.result
[16:12:35.339] }
[16:12:35.341] Exporting 3 global objects (7.52 KiB) to cluster node #1 ...
[16:12:35.342] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ...
[16:12:35.342] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ... DONE
[16:12:35.342] Exporting ‘map’ (4.43 KiB) to cluster node #1 ...
[16:12:35.342] Exporting ‘map’ (4.43 KiB) to cluster node #1 ... DONE
[16:12:35.342] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ...
[16:12:35.343] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ... DONE
[16:12:35.343] Exporting 3 global objects (7.52 KiB) to cluster node #1 ... DONE
[16:12:35.343] MultisessionFuture started
[16:12:35.343] - Launch lazy future ... done
[16:12:35.344] run() for ‘MultisessionFuture’ ... done
[16:12:35.344] result() for ClusterFuture ...
[16:12:35.344] receiveMessageFromWorker() for ClusterFuture ...
[16:12:35.344] - Validating connection of MultisessionFuture
[16:12:35.388] - received message: FutureResult
[16:12:35.388] - Received FutureResult
[16:12:35.389] - Erased future from FutureRegistry
[16:12:35.389] result() for ClusterFuture ...
[16:12:35.389] - result already collected: FutureResult
[16:12:35.389] result() for ClusterFuture ... done
[16:12:35.389] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:35.389] result() for ClusterFuture ... done
[16:12:35.389] result() for ClusterFuture ...
[16:12:35.389] - result already collected: FutureResult
[16:12:35.389] result() for ClusterFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
Testing with 2 cores ... DONE
> 
> message("*** Globals - formulas ... DONE")
*** Globals - formulas ... DONE
> 
> source("incl/end.R")
[16:12:35.391] plan(): Setting new future strategy stack:
[16:12:35.391] List of future strategies:
[16:12:35.391] 1. FutureStrategy:
[16:12:35.391]    - args: function (..., envir = parent.frame())
[16:12:35.391]    - tweaked: FALSE
[16:12:35.391]    - call: future::plan(oplan)
[16:12:35.392] plan(): nbrOfWorkers() = 1
> 
