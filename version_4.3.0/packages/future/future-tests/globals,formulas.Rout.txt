
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[13:20:31.507] plan(): Setting new future strategy stack:
[13:20:31.508] List of future strategies:
[13:20:31.508] 1. sequential:
[13:20:31.508]    - args: function (..., envir = parent.frame())
[13:20:31.508]    - tweaked: FALSE
[13:20:31.508]    - call: future::plan("sequential")
[13:20:31.521] plan(): nbrOfWorkers() = 1
> 
> library("datasets") ## cars data set
> library("stats")    ## lm(), poly(), xtabs()
> 
> message("*** Globals - formulas ...")
*** Globals - formulas ...
> 
> ## (i) lm(<formula>):
> ## From example("lm", package = "stats")
> ctl <- c(4.17, 5.58, 5.18, 6.11, 4.50, 4.61, 5.17, 4.53, 5.33, 5.14)
> trt <- c(4.81, 4.17, 4.41, 3.59, 5.87, 3.83, 6.03, 4.89, 4.32, 4.69)
> group <- gl(2, 10, 20, labels = c("Ctl", "Trt"))
> weight <- c(ctl, trt)
> ctl <- trt <- NULL
> ## Truth:
> fit_i <- lm(weight ~ group - 1)
> print(fit_i)

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

> 
> ## (ii) xtabs(~ x):
> x <- c(1, 1, 2, 2, 2)
> ## Truth:
> tbl_ii <- xtabs(~ x)
> print(tbl_ii)
x
1 2 
2 3 
> 
> ## (iii) lm(<formula>, data = cars):
> exprs <- list(
+   # "remove-intercept-term" form of no-intercept
+   a = substitute({ lm(dist ~ . -1, data = cars) }),
+   # "make-intercept-zero" form of no-intercept
+   b = substitute({ lm(dist ~ . +0, data = cars) }),
+   # doesn't do what we want here
+   c = substitute({ lm(dist ~ speed + speed ^ 2, data = cars) }),
+   # gets us a quadratic term
+   d = substitute({ lm(dist ~ speed + I(speed ^ 2), data = cars) }),
+   # avoid potential multicollinearity
+   e = substitute({ lm(dist ~ poly(speed, 2), data = cars) })
+ )
> 
> ## (iv) Globals - map(x, ~ expr):
> ## A fake purrr::map() function with limited functionality
> map <- function(.x, .f, ...) {
+   if (inherits(.f, "formula")) {
+     expr <- .f[[-1]]
+     .f <- eval(bquote(function(...) {
+       .(expr)
+     }))
+   }
+   eval(lapply(.x, FUN = .f, ...))
+ }
> 
> inner_function <- function(x) { x + 1 }
> 
> outer_function <- function(x) {
+   map(1:2, ~ inner_function(.x))
+ }
> 
> y_iv <- outer_function(1L)
> str(y_iv)
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
> 
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     message("- lm(<formula>) ...")
+     
+     ## Explicit future
+     f <- future({ lm(weight ~ group - 1) })
+     fit <- value(f)
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Explicit future (lazy)
+     f <- future({ lm(weight ~ group - 1) }, lazy = TRUE)
+     fit <- value(f)
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment
+     fit %<-% { lm(weight ~ group - 1) }
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment (non-lazy)
+     fit %<-% { lm(weight ~ group - 1) } %lazy% FALSE
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment (lazy)
+     fit %<-% { lm(weight ~ group - 1) } %lazy% TRUE
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     message("- Globals - one-side formulas, e.g. xtabs(~ x) ...")
+     ## Explicit future
+     f <- future({ xtabs(~ x) })
+     tbl <- value(f)
+     print(tbl)
+     stopifnot(all.equal(tbl, tbl_ii))
+ 
+     ## Future assignment
+     tbl %<-% { xtabs(~ x) }
+     print(tbl)
+     stopifnot(all.equal(tbl, tbl_ii))
+ 
+     message("- Globals - lm(<formula>, data = cars) ...")
+     for (kk in seq_along(exprs)) {
+       expr <- exprs[[kk]]
+       name <- names(exprs)[kk]
+       message(sprintf("- Globals - lm(<formula #%d (%s)>, data = cars) ...",
+                       kk, sQuote(name)))
+     
+       fit_iii <- eval(expr)
+       print(fit_iii)
+     
+       f <- future(expr, substitute = FALSE)
+       fit <- value(f)
+       print(fit)
+     
+       stopifnot(all.equal(fit, fit_iii))
+     } ## for (kk ...)
+ 
+     message("- Globals - map(x, ~ expr) ...")
+     f <- future({ outer_function(1L) })
+     y <- value(f)
+     str(y)
+     stopifnot(all.equal(y, y_iv))
+ 
+     y %<-% { outer_function(1L) }
+     str(y)
+     stopifnot(all.equal(y, y_iv))
+   } ## for (strategy ...)
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- plan('sequential') ...
[13:20:31.579] plan(): Setting new future strategy stack:
[13:20:31.579] List of future strategies:
[13:20:31.579] 1. sequential:
[13:20:31.579]    - args: function (..., envir = parent.frame())
[13:20:31.579]    - tweaked: FALSE
[13:20:31.579]    - call: plan(strategy)
[13:20:31.592] plan(): nbrOfWorkers() = 1
- lm(<formula>) ...
[13:20:31.593] getGlobalsAndPackages() ...
[13:20:31.593] Searching for globals...
[13:20:31.600] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:20:31.600] Searching for globals ... DONE
[13:20:31.600] Resolving globals: FALSE
[13:20:31.601] The total size of the 2 globals is 896 bytes (896 bytes)
[13:20:31.602] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:20:31.602] - globals: [2] ‘weight’, ‘group’
[13:20:31.602] - packages: [1] ‘stats’
[13:20:31.602] getGlobalsAndPackages() ... DONE
[13:20:31.603] run() for ‘Future’ ...
[13:20:31.603] - state: ‘created’
[13:20:31.603] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:31.603] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:31.604] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:31.604]   - Field: ‘label’
[13:20:31.604]   - Field: ‘local’
[13:20:31.604]   - Field: ‘owner’
[13:20:31.604]   - Field: ‘envir’
[13:20:31.604]   - Field: ‘packages’
[13:20:31.604]   - Field: ‘gc’
[13:20:31.604]   - Field: ‘conditions’
[13:20:31.604]   - Field: ‘expr’
[13:20:31.604]   - Field: ‘uuid’
[13:20:31.605]   - Field: ‘seed’
[13:20:31.605]   - Field: ‘version’
[13:20:31.605]   - Field: ‘result’
[13:20:31.605]   - Field: ‘asynchronous’
[13:20:31.605]   - Field: ‘calls’
[13:20:31.605]   - Field: ‘globals’
[13:20:31.605]   - Field: ‘stdout’
[13:20:31.605]   - Field: ‘earlySignal’
[13:20:31.605]   - Field: ‘lazy’
[13:20:31.605]   - Field: ‘state’
[13:20:31.606] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:31.606] - Launch lazy future ...
[13:20:31.606] Packages needed by the future expression (n = 1): ‘stats’
[13:20:31.607] Packages needed by future strategies (n = 0): <none>
[13:20:31.607] {
[13:20:31.607]     {
[13:20:31.607]         {
[13:20:31.607]             ...future.startTime <- base::Sys.time()
[13:20:31.607]             {
[13:20:31.607]                 {
[13:20:31.607]                   {
[13:20:31.607]                     {
[13:20:31.607]                       base::local({
[13:20:31.607]                         has_future <- base::requireNamespace("future", 
[13:20:31.607]                           quietly = TRUE)
[13:20:31.607]                         if (has_future) {
[13:20:31.607]                           ns <- base::getNamespace("future")
[13:20:31.607]                           version <- ns[[".package"]][["version"]]
[13:20:31.607]                           if (is.null(version)) 
[13:20:31.607]                             version <- utils::packageVersion("future")
[13:20:31.607]                         }
[13:20:31.607]                         else {
[13:20:31.607]                           version <- NULL
[13:20:31.607]                         }
[13:20:31.607]                         if (!has_future || version < "1.8.0") {
[13:20:31.607]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:31.607]                             "", base::R.version$version.string), 
[13:20:31.607]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:31.607]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:31.607]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:31.607]                               "release", "version")], collapse = " "), 
[13:20:31.607]                             hostname = base::Sys.info()[["nodename"]])
[13:20:31.607]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:31.607]                             info)
[13:20:31.607]                           info <- base::paste(info, collapse = "; ")
[13:20:31.607]                           if (!has_future) {
[13:20:31.607]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:31.607]                               info)
[13:20:31.607]                           }
[13:20:31.607]                           else {
[13:20:31.607]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:31.607]                               info, version)
[13:20:31.607]                           }
[13:20:31.607]                           base::stop(msg)
[13:20:31.607]                         }
[13:20:31.607]                       })
[13:20:31.607]                     }
[13:20:31.607]                     base::local({
[13:20:31.607]                       for (pkg in "stats") {
[13:20:31.607]                         base::loadNamespace(pkg)
[13:20:31.607]                         base::library(pkg, character.only = TRUE)
[13:20:31.607]                       }
[13:20:31.607]                     })
[13:20:31.607]                   }
[13:20:31.607]                   options(future.plan = NULL)
[13:20:31.607]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:31.607]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:31.607]                 }
[13:20:31.607]                 ...future.workdir <- getwd()
[13:20:31.607]             }
[13:20:31.607]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:31.607]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:31.607]         }
[13:20:31.607]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:31.607]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:31.607]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:31.607]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:31.607]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:31.607]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:31.607]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:31.607]             base::names(...future.oldOptions))
[13:20:31.607]     }
[13:20:31.607]     if (FALSE) {
[13:20:31.607]     }
[13:20:31.607]     else {
[13:20:31.607]         if (TRUE) {
[13:20:31.607]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:31.607]                 open = "w")
[13:20:31.607]         }
[13:20:31.607]         else {
[13:20:31.607]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:31.607]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:31.607]         }
[13:20:31.607]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:31.607]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:31.607]             base::sink(type = "output", split = FALSE)
[13:20:31.607]             base::close(...future.stdout)
[13:20:31.607]         }, add = TRUE)
[13:20:31.607]     }
[13:20:31.607]     ...future.frame <- base::sys.nframe()
[13:20:31.607]     ...future.conditions <- base::list()
[13:20:31.607]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:31.607]     if (FALSE) {
[13:20:31.607]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:31.607]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:31.607]     }
[13:20:31.607]     ...future.result <- base::tryCatch({
[13:20:31.607]         base::withCallingHandlers({
[13:20:31.607]             ...future.value <- base::withVisible(base::local({
[13:20:31.607]                 lm(weight ~ group - 1)
[13:20:31.607]             }))
[13:20:31.607]             future::FutureResult(value = ...future.value$value, 
[13:20:31.607]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:31.607]                   ...future.rng), globalenv = if (FALSE) 
[13:20:31.607]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:31.607]                     ...future.globalenv.names))
[13:20:31.607]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:31.607]         }, condition = base::local({
[13:20:31.607]             c <- base::c
[13:20:31.607]             inherits <- base::inherits
[13:20:31.607]             invokeRestart <- base::invokeRestart
[13:20:31.607]             length <- base::length
[13:20:31.607]             list <- base::list
[13:20:31.607]             seq.int <- base::seq.int
[13:20:31.607]             signalCondition <- base::signalCondition
[13:20:31.607]             sys.calls <- base::sys.calls
[13:20:31.607]             `[[` <- base::`[[`
[13:20:31.607]             `+` <- base::`+`
[13:20:31.607]             `<<-` <- base::`<<-`
[13:20:31.607]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:31.607]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:31.607]                   3L)]
[13:20:31.607]             }
[13:20:31.607]             function(cond) {
[13:20:31.607]                 is_error <- inherits(cond, "error")
[13:20:31.607]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:31.607]                   NULL)
[13:20:31.607]                 if (is_error) {
[13:20:31.607]                   sessionInformation <- function() {
[13:20:31.607]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:31.607]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:31.607]                       search = base::search(), system = base::Sys.info())
[13:20:31.607]                   }
[13:20:31.607]                   ...future.conditions[[length(...future.conditions) + 
[13:20:31.607]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:31.607]                     cond$call), session = sessionInformation(), 
[13:20:31.607]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:31.607]                   signalCondition(cond)
[13:20:31.607]                 }
[13:20:31.607]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:31.607]                 "immediateCondition"))) {
[13:20:31.607]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:31.607]                   ...future.conditions[[length(...future.conditions) + 
[13:20:31.607]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:31.607]                   if (TRUE && !signal) {
[13:20:31.607]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:31.607]                     {
[13:20:31.607]                       inherits <- base::inherits
[13:20:31.607]                       invokeRestart <- base::invokeRestart
[13:20:31.607]                       is.null <- base::is.null
[13:20:31.607]                       muffled <- FALSE
[13:20:31.607]                       if (inherits(cond, "message")) {
[13:20:31.607]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:31.607]                         if (muffled) 
[13:20:31.607]                           invokeRestart("muffleMessage")
[13:20:31.607]                       }
[13:20:31.607]                       else if (inherits(cond, "warning")) {
[13:20:31.607]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:31.607]                         if (muffled) 
[13:20:31.607]                           invokeRestart("muffleWarning")
[13:20:31.607]                       }
[13:20:31.607]                       else if (inherits(cond, "condition")) {
[13:20:31.607]                         if (!is.null(pattern)) {
[13:20:31.607]                           computeRestarts <- base::computeRestarts
[13:20:31.607]                           grepl <- base::grepl
[13:20:31.607]                           restarts <- computeRestarts(cond)
[13:20:31.607]                           for (restart in restarts) {
[13:20:31.607]                             name <- restart$name
[13:20:31.607]                             if (is.null(name)) 
[13:20:31.607]                               next
[13:20:31.607]                             if (!grepl(pattern, name)) 
[13:20:31.607]                               next
[13:20:31.607]                             invokeRestart(restart)
[13:20:31.607]                             muffled <- TRUE
[13:20:31.607]                             break
[13:20:31.607]                           }
[13:20:31.607]                         }
[13:20:31.607]                       }
[13:20:31.607]                       invisible(muffled)
[13:20:31.607]                     }
[13:20:31.607]                     muffleCondition(cond, pattern = "^muffle")
[13:20:31.607]                   }
[13:20:31.607]                 }
[13:20:31.607]                 else {
[13:20:31.607]                   if (TRUE) {
[13:20:31.607]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:31.607]                     {
[13:20:31.607]                       inherits <- base::inherits
[13:20:31.607]                       invokeRestart <- base::invokeRestart
[13:20:31.607]                       is.null <- base::is.null
[13:20:31.607]                       muffled <- FALSE
[13:20:31.607]                       if (inherits(cond, "message")) {
[13:20:31.607]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:31.607]                         if (muffled) 
[13:20:31.607]                           invokeRestart("muffleMessage")
[13:20:31.607]                       }
[13:20:31.607]                       else if (inherits(cond, "warning")) {
[13:20:31.607]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:31.607]                         if (muffled) 
[13:20:31.607]                           invokeRestart("muffleWarning")
[13:20:31.607]                       }
[13:20:31.607]                       else if (inherits(cond, "condition")) {
[13:20:31.607]                         if (!is.null(pattern)) {
[13:20:31.607]                           computeRestarts <- base::computeRestarts
[13:20:31.607]                           grepl <- base::grepl
[13:20:31.607]                           restarts <- computeRestarts(cond)
[13:20:31.607]                           for (restart in restarts) {
[13:20:31.607]                             name <- restart$name
[13:20:31.607]                             if (is.null(name)) 
[13:20:31.607]                               next
[13:20:31.607]                             if (!grepl(pattern, name)) 
[13:20:31.607]                               next
[13:20:31.607]                             invokeRestart(restart)
[13:20:31.607]                             muffled <- TRUE
[13:20:31.607]                             break
[13:20:31.607]                           }
[13:20:31.607]                         }
[13:20:31.607]                       }
[13:20:31.607]                       invisible(muffled)
[13:20:31.607]                     }
[13:20:31.607]                     muffleCondition(cond, pattern = "^muffle")
[13:20:31.607]                   }
[13:20:31.607]                 }
[13:20:31.607]             }
[13:20:31.607]         }))
[13:20:31.607]     }, error = function(ex) {
[13:20:31.607]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:31.607]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:31.607]                 ...future.rng), started = ...future.startTime, 
[13:20:31.607]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:31.607]             version = "1.8"), class = "FutureResult")
[13:20:31.607]     }, finally = {
[13:20:31.607]         if (!identical(...future.workdir, getwd())) 
[13:20:31.607]             setwd(...future.workdir)
[13:20:31.607]         {
[13:20:31.607]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:31.607]                 ...future.oldOptions$nwarnings <- NULL
[13:20:31.607]             }
[13:20:31.607]             base::options(...future.oldOptions)
[13:20:31.607]             if (.Platform$OS.type == "windows") {
[13:20:31.607]                 old_names <- names(...future.oldEnvVars)
[13:20:31.607]                 envs <- base::Sys.getenv()
[13:20:31.607]                 names <- names(envs)
[13:20:31.607]                 common <- intersect(names, old_names)
[13:20:31.607]                 added <- setdiff(names, old_names)
[13:20:31.607]                 removed <- setdiff(old_names, names)
[13:20:31.607]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:31.607]                   envs[common]]
[13:20:31.607]                 NAMES <- toupper(changed)
[13:20:31.607]                 args <- list()
[13:20:31.607]                 for (kk in seq_along(NAMES)) {
[13:20:31.607]                   name <- changed[[kk]]
[13:20:31.607]                   NAME <- NAMES[[kk]]
[13:20:31.607]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.607]                     next
[13:20:31.607]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:31.607]                 }
[13:20:31.607]                 NAMES <- toupper(added)
[13:20:31.607]                 for (kk in seq_along(NAMES)) {
[13:20:31.607]                   name <- added[[kk]]
[13:20:31.607]                   NAME <- NAMES[[kk]]
[13:20:31.607]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.607]                     next
[13:20:31.607]                   args[[name]] <- ""
[13:20:31.607]                 }
[13:20:31.607]                 NAMES <- toupper(removed)
[13:20:31.607]                 for (kk in seq_along(NAMES)) {
[13:20:31.607]                   name <- removed[[kk]]
[13:20:31.607]                   NAME <- NAMES[[kk]]
[13:20:31.607]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.607]                     next
[13:20:31.607]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:31.607]                 }
[13:20:31.607]                 if (length(args) > 0) 
[13:20:31.607]                   base::do.call(base::Sys.setenv, args = args)
[13:20:31.607]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:31.607]             }
[13:20:31.607]             else {
[13:20:31.607]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:31.607]             }
[13:20:31.607]             {
[13:20:31.607]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:31.607]                   0L) {
[13:20:31.607]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:31.607]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:31.607]                   base::options(opts)
[13:20:31.607]                 }
[13:20:31.607]                 {
[13:20:31.607]                   {
[13:20:31.607]                     NULL
[13:20:31.607]                     RNGkind("Mersenne-Twister")
[13:20:31.607]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:31.607]                       inherits = FALSE)
[13:20:31.607]                   }
[13:20:31.607]                   options(future.plan = NULL)
[13:20:31.607]                   if (is.na(NA_character_)) 
[13:20:31.607]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:31.607]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:31.607]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:31.607]                   {
[13:20:31.607]                     future <- SequentialFuture(..., envir = envir)
[13:20:31.607]                     if (!future$lazy) 
[13:20:31.607]                       future <- run(future)
[13:20:31.607]                     invisible(future)
[13:20:31.607]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:31.607]                 }
[13:20:31.607]             }
[13:20:31.607]         }
[13:20:31.607]     })
[13:20:31.607]     if (TRUE) {
[13:20:31.607]         base::sink(type = "output", split = FALSE)
[13:20:31.607]         if (TRUE) {
[13:20:31.607]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:31.607]         }
[13:20:31.607]         else {
[13:20:31.607]             ...future.result["stdout"] <- base::list(NULL)
[13:20:31.607]         }
[13:20:31.607]         base::close(...future.stdout)
[13:20:31.607]         ...future.stdout <- NULL
[13:20:31.607]     }
[13:20:31.607]     ...future.result$conditions <- ...future.conditions
[13:20:31.607]     ...future.result$finished <- base::Sys.time()
[13:20:31.607]     ...future.result
[13:20:31.607] }
[13:20:31.609] assign_globals() ...
[13:20:31.610] List of 2
[13:20:31.610]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[13:20:31.610]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:31.610]  - attr(*, "where")=List of 2
[13:20:31.610]   ..$ weight:<environment: R_EmptyEnv> 
[13:20:31.610]   ..$ group :<environment: R_EmptyEnv> 
[13:20:31.610]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:31.610]  - attr(*, "resolved")= logi FALSE
[13:20:31.610]  - attr(*, "total_size")= num 896
[13:20:31.610]  - attr(*, "already-done")= logi TRUE
[13:20:31.615] - copied ‘weight’ to environment
[13:20:31.616] - copied ‘group’ to environment
[13:20:31.616] assign_globals() ... done
[13:20:31.616] plan(): Setting new future strategy stack:
[13:20:31.616] List of future strategies:
[13:20:31.616] 1. sequential:
[13:20:31.616]    - args: function (..., envir = parent.frame())
[13:20:31.616]    - tweaked: FALSE
[13:20:31.616]    - call: NULL
[13:20:31.617] plan(): nbrOfWorkers() = 1
[13:20:31.619] plan(): Setting new future strategy stack:
[13:20:31.619] List of future strategies:
[13:20:31.619] 1. sequential:
[13:20:31.619]    - args: function (..., envir = parent.frame())
[13:20:31.619]    - tweaked: FALSE
[13:20:31.619]    - call: plan(strategy)
[13:20:31.619] plan(): nbrOfWorkers() = 1
[13:20:31.619] SequentialFuture started (and completed)
[13:20:31.620] - Launch lazy future ... done
[13:20:31.620] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[13:20:31.623] getGlobalsAndPackages() ...
[13:20:31.623] Searching for globals...
[13:20:31.624] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:20:31.624] Searching for globals ... DONE
[13:20:31.625] Resolving globals: FALSE
[13:20:31.625] The total size of the 2 globals is 896 bytes (896 bytes)
[13:20:31.625] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:20:31.626] - globals: [2] ‘weight’, ‘group’
[13:20:31.626] - packages: [1] ‘stats’
[13:20:31.626] getGlobalsAndPackages() ... DONE
[13:20:31.626] run() for ‘Future’ ...
[13:20:31.626] - state: ‘created’
[13:20:31.626] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:31.627] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:31.627] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:31.627]   - Field: ‘label’
[13:20:31.627]   - Field: ‘local’
[13:20:31.627]   - Field: ‘owner’
[13:20:31.627]   - Field: ‘envir’
[13:20:31.627]   - Field: ‘packages’
[13:20:31.627]   - Field: ‘gc’
[13:20:31.627]   - Field: ‘conditions’
[13:20:31.628]   - Field: ‘expr’
[13:20:31.628]   - Field: ‘uuid’
[13:20:31.628]   - Field: ‘seed’
[13:20:31.628]   - Field: ‘version’
[13:20:31.628]   - Field: ‘result’
[13:20:31.628]   - Field: ‘asynchronous’
[13:20:31.628]   - Field: ‘calls’
[13:20:31.628]   - Field: ‘globals’
[13:20:31.628]   - Field: ‘stdout’
[13:20:31.628]   - Field: ‘earlySignal’
[13:20:31.628]   - Field: ‘lazy’
[13:20:31.629]   - Field: ‘state’
[13:20:31.629] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:31.629] - Launch lazy future ...
[13:20:31.629] Packages needed by the future expression (n = 1): ‘stats’
[13:20:31.629] Packages needed by future strategies (n = 0): <none>
[13:20:31.630] {
[13:20:31.630]     {
[13:20:31.630]         {
[13:20:31.630]             ...future.startTime <- base::Sys.time()
[13:20:31.630]             {
[13:20:31.630]                 {
[13:20:31.630]                   {
[13:20:31.630]                     {
[13:20:31.630]                       base::local({
[13:20:31.630]                         has_future <- base::requireNamespace("future", 
[13:20:31.630]                           quietly = TRUE)
[13:20:31.630]                         if (has_future) {
[13:20:31.630]                           ns <- base::getNamespace("future")
[13:20:31.630]                           version <- ns[[".package"]][["version"]]
[13:20:31.630]                           if (is.null(version)) 
[13:20:31.630]                             version <- utils::packageVersion("future")
[13:20:31.630]                         }
[13:20:31.630]                         else {
[13:20:31.630]                           version <- NULL
[13:20:31.630]                         }
[13:20:31.630]                         if (!has_future || version < "1.8.0") {
[13:20:31.630]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:31.630]                             "", base::R.version$version.string), 
[13:20:31.630]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:31.630]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:31.630]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:31.630]                               "release", "version")], collapse = " "), 
[13:20:31.630]                             hostname = base::Sys.info()[["nodename"]])
[13:20:31.630]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:31.630]                             info)
[13:20:31.630]                           info <- base::paste(info, collapse = "; ")
[13:20:31.630]                           if (!has_future) {
[13:20:31.630]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:31.630]                               info)
[13:20:31.630]                           }
[13:20:31.630]                           else {
[13:20:31.630]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:31.630]                               info, version)
[13:20:31.630]                           }
[13:20:31.630]                           base::stop(msg)
[13:20:31.630]                         }
[13:20:31.630]                       })
[13:20:31.630]                     }
[13:20:31.630]                     base::local({
[13:20:31.630]                       for (pkg in "stats") {
[13:20:31.630]                         base::loadNamespace(pkg)
[13:20:31.630]                         base::library(pkg, character.only = TRUE)
[13:20:31.630]                       }
[13:20:31.630]                     })
[13:20:31.630]                   }
[13:20:31.630]                   options(future.plan = NULL)
[13:20:31.630]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:31.630]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:31.630]                 }
[13:20:31.630]                 ...future.workdir <- getwd()
[13:20:31.630]             }
[13:20:31.630]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:31.630]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:31.630]         }
[13:20:31.630]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:31.630]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:31.630]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:31.630]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:31.630]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:31.630]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:31.630]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:31.630]             base::names(...future.oldOptions))
[13:20:31.630]     }
[13:20:31.630]     if (FALSE) {
[13:20:31.630]     }
[13:20:31.630]     else {
[13:20:31.630]         if (TRUE) {
[13:20:31.630]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:31.630]                 open = "w")
[13:20:31.630]         }
[13:20:31.630]         else {
[13:20:31.630]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:31.630]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:31.630]         }
[13:20:31.630]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:31.630]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:31.630]             base::sink(type = "output", split = FALSE)
[13:20:31.630]             base::close(...future.stdout)
[13:20:31.630]         }, add = TRUE)
[13:20:31.630]     }
[13:20:31.630]     ...future.frame <- base::sys.nframe()
[13:20:31.630]     ...future.conditions <- base::list()
[13:20:31.630]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:31.630]     if (FALSE) {
[13:20:31.630]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:31.630]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:31.630]     }
[13:20:31.630]     ...future.result <- base::tryCatch({
[13:20:31.630]         base::withCallingHandlers({
[13:20:31.630]             ...future.value <- base::withVisible(base::local({
[13:20:31.630]                 lm(weight ~ group - 1)
[13:20:31.630]             }))
[13:20:31.630]             future::FutureResult(value = ...future.value$value, 
[13:20:31.630]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:31.630]                   ...future.rng), globalenv = if (FALSE) 
[13:20:31.630]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:31.630]                     ...future.globalenv.names))
[13:20:31.630]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:31.630]         }, condition = base::local({
[13:20:31.630]             c <- base::c
[13:20:31.630]             inherits <- base::inherits
[13:20:31.630]             invokeRestart <- base::invokeRestart
[13:20:31.630]             length <- base::length
[13:20:31.630]             list <- base::list
[13:20:31.630]             seq.int <- base::seq.int
[13:20:31.630]             signalCondition <- base::signalCondition
[13:20:31.630]             sys.calls <- base::sys.calls
[13:20:31.630]             `[[` <- base::`[[`
[13:20:31.630]             `+` <- base::`+`
[13:20:31.630]             `<<-` <- base::`<<-`
[13:20:31.630]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:31.630]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:31.630]                   3L)]
[13:20:31.630]             }
[13:20:31.630]             function(cond) {
[13:20:31.630]                 is_error <- inherits(cond, "error")
[13:20:31.630]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:31.630]                   NULL)
[13:20:31.630]                 if (is_error) {
[13:20:31.630]                   sessionInformation <- function() {
[13:20:31.630]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:31.630]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:31.630]                       search = base::search(), system = base::Sys.info())
[13:20:31.630]                   }
[13:20:31.630]                   ...future.conditions[[length(...future.conditions) + 
[13:20:31.630]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:31.630]                     cond$call), session = sessionInformation(), 
[13:20:31.630]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:31.630]                   signalCondition(cond)
[13:20:31.630]                 }
[13:20:31.630]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:31.630]                 "immediateCondition"))) {
[13:20:31.630]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:31.630]                   ...future.conditions[[length(...future.conditions) + 
[13:20:31.630]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:31.630]                   if (TRUE && !signal) {
[13:20:31.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:31.630]                     {
[13:20:31.630]                       inherits <- base::inherits
[13:20:31.630]                       invokeRestart <- base::invokeRestart
[13:20:31.630]                       is.null <- base::is.null
[13:20:31.630]                       muffled <- FALSE
[13:20:31.630]                       if (inherits(cond, "message")) {
[13:20:31.630]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:31.630]                         if (muffled) 
[13:20:31.630]                           invokeRestart("muffleMessage")
[13:20:31.630]                       }
[13:20:31.630]                       else if (inherits(cond, "warning")) {
[13:20:31.630]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:31.630]                         if (muffled) 
[13:20:31.630]                           invokeRestart("muffleWarning")
[13:20:31.630]                       }
[13:20:31.630]                       else if (inherits(cond, "condition")) {
[13:20:31.630]                         if (!is.null(pattern)) {
[13:20:31.630]                           computeRestarts <- base::computeRestarts
[13:20:31.630]                           grepl <- base::grepl
[13:20:31.630]                           restarts <- computeRestarts(cond)
[13:20:31.630]                           for (restart in restarts) {
[13:20:31.630]                             name <- restart$name
[13:20:31.630]                             if (is.null(name)) 
[13:20:31.630]                               next
[13:20:31.630]                             if (!grepl(pattern, name)) 
[13:20:31.630]                               next
[13:20:31.630]                             invokeRestart(restart)
[13:20:31.630]                             muffled <- TRUE
[13:20:31.630]                             break
[13:20:31.630]                           }
[13:20:31.630]                         }
[13:20:31.630]                       }
[13:20:31.630]                       invisible(muffled)
[13:20:31.630]                     }
[13:20:31.630]                     muffleCondition(cond, pattern = "^muffle")
[13:20:31.630]                   }
[13:20:31.630]                 }
[13:20:31.630]                 else {
[13:20:31.630]                   if (TRUE) {
[13:20:31.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:31.630]                     {
[13:20:31.630]                       inherits <- base::inherits
[13:20:31.630]                       invokeRestart <- base::invokeRestart
[13:20:31.630]                       is.null <- base::is.null
[13:20:31.630]                       muffled <- FALSE
[13:20:31.630]                       if (inherits(cond, "message")) {
[13:20:31.630]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:31.630]                         if (muffled) 
[13:20:31.630]                           invokeRestart("muffleMessage")
[13:20:31.630]                       }
[13:20:31.630]                       else if (inherits(cond, "warning")) {
[13:20:31.630]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:31.630]                         if (muffled) 
[13:20:31.630]                           invokeRestart("muffleWarning")
[13:20:31.630]                       }
[13:20:31.630]                       else if (inherits(cond, "condition")) {
[13:20:31.630]                         if (!is.null(pattern)) {
[13:20:31.630]                           computeRestarts <- base::computeRestarts
[13:20:31.630]                           grepl <- base::grepl
[13:20:31.630]                           restarts <- computeRestarts(cond)
[13:20:31.630]                           for (restart in restarts) {
[13:20:31.630]                             name <- restart$name
[13:20:31.630]                             if (is.null(name)) 
[13:20:31.630]                               next
[13:20:31.630]                             if (!grepl(pattern, name)) 
[13:20:31.630]                               next
[13:20:31.630]                             invokeRestart(restart)
[13:20:31.630]                             muffled <- TRUE
[13:20:31.630]                             break
[13:20:31.630]                           }
[13:20:31.630]                         }
[13:20:31.630]                       }
[13:20:31.630]                       invisible(muffled)
[13:20:31.630]                     }
[13:20:31.630]                     muffleCondition(cond, pattern = "^muffle")
[13:20:31.630]                   }
[13:20:31.630]                 }
[13:20:31.630]             }
[13:20:31.630]         }))
[13:20:31.630]     }, error = function(ex) {
[13:20:31.630]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:31.630]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:31.630]                 ...future.rng), started = ...future.startTime, 
[13:20:31.630]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:31.630]             version = "1.8"), class = "FutureResult")
[13:20:31.630]     }, finally = {
[13:20:31.630]         if (!identical(...future.workdir, getwd())) 
[13:20:31.630]             setwd(...future.workdir)
[13:20:31.630]         {
[13:20:31.630]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:31.630]                 ...future.oldOptions$nwarnings <- NULL
[13:20:31.630]             }
[13:20:31.630]             base::options(...future.oldOptions)
[13:20:31.630]             if (.Platform$OS.type == "windows") {
[13:20:31.630]                 old_names <- names(...future.oldEnvVars)
[13:20:31.630]                 envs <- base::Sys.getenv()
[13:20:31.630]                 names <- names(envs)
[13:20:31.630]                 common <- intersect(names, old_names)
[13:20:31.630]                 added <- setdiff(names, old_names)
[13:20:31.630]                 removed <- setdiff(old_names, names)
[13:20:31.630]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:31.630]                   envs[common]]
[13:20:31.630]                 NAMES <- toupper(changed)
[13:20:31.630]                 args <- list()
[13:20:31.630]                 for (kk in seq_along(NAMES)) {
[13:20:31.630]                   name <- changed[[kk]]
[13:20:31.630]                   NAME <- NAMES[[kk]]
[13:20:31.630]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.630]                     next
[13:20:31.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:31.630]                 }
[13:20:31.630]                 NAMES <- toupper(added)
[13:20:31.630]                 for (kk in seq_along(NAMES)) {
[13:20:31.630]                   name <- added[[kk]]
[13:20:31.630]                   NAME <- NAMES[[kk]]
[13:20:31.630]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.630]                     next
[13:20:31.630]                   args[[name]] <- ""
[13:20:31.630]                 }
[13:20:31.630]                 NAMES <- toupper(removed)
[13:20:31.630]                 for (kk in seq_along(NAMES)) {
[13:20:31.630]                   name <- removed[[kk]]
[13:20:31.630]                   NAME <- NAMES[[kk]]
[13:20:31.630]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.630]                     next
[13:20:31.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:31.630]                 }
[13:20:31.630]                 if (length(args) > 0) 
[13:20:31.630]                   base::do.call(base::Sys.setenv, args = args)
[13:20:31.630]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:31.630]             }
[13:20:31.630]             else {
[13:20:31.630]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:31.630]             }
[13:20:31.630]             {
[13:20:31.630]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:31.630]                   0L) {
[13:20:31.630]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:31.630]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:31.630]                   base::options(opts)
[13:20:31.630]                 }
[13:20:31.630]                 {
[13:20:31.630]                   {
[13:20:31.630]                     NULL
[13:20:31.630]                     RNGkind("Mersenne-Twister")
[13:20:31.630]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:31.630]                       inherits = FALSE)
[13:20:31.630]                   }
[13:20:31.630]                   options(future.plan = NULL)
[13:20:31.630]                   if (is.na(NA_character_)) 
[13:20:31.630]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:31.630]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:31.630]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:31.630]                   {
[13:20:31.630]                     future <- SequentialFuture(..., envir = envir)
[13:20:31.630]                     if (!future$lazy) 
[13:20:31.630]                       future <- run(future)
[13:20:31.630]                     invisible(future)
[13:20:31.630]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:31.630]                 }
[13:20:31.630]             }
[13:20:31.630]         }
[13:20:31.630]     })
[13:20:31.630]     if (TRUE) {
[13:20:31.630]         base::sink(type = "output", split = FALSE)
[13:20:31.630]         if (TRUE) {
[13:20:31.630]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:31.630]         }
[13:20:31.630]         else {
[13:20:31.630]             ...future.result["stdout"] <- base::list(NULL)
[13:20:31.630]         }
[13:20:31.630]         base::close(...future.stdout)
[13:20:31.630]         ...future.stdout <- NULL
[13:20:31.630]     }
[13:20:31.630]     ...future.result$conditions <- ...future.conditions
[13:20:31.630]     ...future.result$finished <- base::Sys.time()
[13:20:31.630]     ...future.result
[13:20:31.630] }
[13:20:31.631] assign_globals() ...
[13:20:31.631] List of 2
[13:20:31.631]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[13:20:31.631]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:31.631]  - attr(*, "where")=List of 2
[13:20:31.631]   ..$ weight:<environment: R_EmptyEnv> 
[13:20:31.631]   ..$ group :<environment: R_EmptyEnv> 
[13:20:31.631]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:31.631]  - attr(*, "resolved")= logi FALSE
[13:20:31.631]  - attr(*, "total_size")= num 896
[13:20:31.631]  - attr(*, "already-done")= logi TRUE
[13:20:31.634] - copied ‘weight’ to environment
[13:20:31.634] - copied ‘group’ to environment
[13:20:31.635] assign_globals() ... done
[13:20:31.635] plan(): Setting new future strategy stack:
[13:20:31.635] List of future strategies:
[13:20:31.635] 1. sequential:
[13:20:31.635]    - args: function (..., envir = parent.frame())
[13:20:31.635]    - tweaked: FALSE
[13:20:31.635]    - call: NULL
[13:20:31.635] plan(): nbrOfWorkers() = 1
[13:20:31.637] plan(): Setting new future strategy stack:
[13:20:31.637] List of future strategies:
[13:20:31.637] 1. sequential:
[13:20:31.637]    - args: function (..., envir = parent.frame())
[13:20:31.637]    - tweaked: FALSE
[13:20:31.637]    - call: plan(strategy)
[13:20:31.637] plan(): nbrOfWorkers() = 1
[13:20:31.638] SequentialFuture started (and completed)
[13:20:31.638] - Launch lazy future ... done
[13:20:31.638] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[13:20:31.642] getGlobalsAndPackages() ...
[13:20:31.643] Searching for globals...
[13:20:31.644] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:20:31.644] Searching for globals ... DONE
[13:20:31.644] Resolving globals: FALSE
[13:20:31.645] The total size of the 2 globals is 896 bytes (896 bytes)
[13:20:31.645] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:20:31.645] - globals: [2] ‘weight’, ‘group’
[13:20:31.645] - packages: [1] ‘stats’
[13:20:31.645] getGlobalsAndPackages() ... DONE
[13:20:31.646] run() for ‘Future’ ...
[13:20:31.646] - state: ‘created’
[13:20:31.646] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:31.646] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:31.646] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:31.646]   - Field: ‘label’
[13:20:31.646]   - Field: ‘local’
[13:20:31.647]   - Field: ‘owner’
[13:20:31.647]   - Field: ‘envir’
[13:20:31.647]   - Field: ‘packages’
[13:20:31.647]   - Field: ‘gc’
[13:20:31.647]   - Field: ‘conditions’
[13:20:31.647]   - Field: ‘expr’
[13:20:31.647]   - Field: ‘uuid’
[13:20:31.647]   - Field: ‘seed’
[13:20:31.647]   - Field: ‘version’
[13:20:31.647]   - Field: ‘result’
[13:20:31.648]   - Field: ‘asynchronous’
[13:20:31.648]   - Field: ‘calls’
[13:20:31.648]   - Field: ‘globals’
[13:20:31.648]   - Field: ‘stdout’
[13:20:31.648]   - Field: ‘earlySignal’
[13:20:31.648]   - Field: ‘lazy’
[13:20:31.648]   - Field: ‘state’
[13:20:31.648] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:31.648] - Launch lazy future ...
[13:20:31.648] Packages needed by the future expression (n = 1): ‘stats’
[13:20:31.649] Packages needed by future strategies (n = 0): <none>
[13:20:31.649] {
[13:20:31.649]     {
[13:20:31.649]         {
[13:20:31.649]             ...future.startTime <- base::Sys.time()
[13:20:31.649]             {
[13:20:31.649]                 {
[13:20:31.649]                   {
[13:20:31.649]                     {
[13:20:31.649]                       base::local({
[13:20:31.649]                         has_future <- base::requireNamespace("future", 
[13:20:31.649]                           quietly = TRUE)
[13:20:31.649]                         if (has_future) {
[13:20:31.649]                           ns <- base::getNamespace("future")
[13:20:31.649]                           version <- ns[[".package"]][["version"]]
[13:20:31.649]                           if (is.null(version)) 
[13:20:31.649]                             version <- utils::packageVersion("future")
[13:20:31.649]                         }
[13:20:31.649]                         else {
[13:20:31.649]                           version <- NULL
[13:20:31.649]                         }
[13:20:31.649]                         if (!has_future || version < "1.8.0") {
[13:20:31.649]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:31.649]                             "", base::R.version$version.string), 
[13:20:31.649]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:31.649]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:31.649]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:31.649]                               "release", "version")], collapse = " "), 
[13:20:31.649]                             hostname = base::Sys.info()[["nodename"]])
[13:20:31.649]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:31.649]                             info)
[13:20:31.649]                           info <- base::paste(info, collapse = "; ")
[13:20:31.649]                           if (!has_future) {
[13:20:31.649]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:31.649]                               info)
[13:20:31.649]                           }
[13:20:31.649]                           else {
[13:20:31.649]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:31.649]                               info, version)
[13:20:31.649]                           }
[13:20:31.649]                           base::stop(msg)
[13:20:31.649]                         }
[13:20:31.649]                       })
[13:20:31.649]                     }
[13:20:31.649]                     base::local({
[13:20:31.649]                       for (pkg in "stats") {
[13:20:31.649]                         base::loadNamespace(pkg)
[13:20:31.649]                         base::library(pkg, character.only = TRUE)
[13:20:31.649]                       }
[13:20:31.649]                     })
[13:20:31.649]                   }
[13:20:31.649]                   options(future.plan = NULL)
[13:20:31.649]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:31.649]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:31.649]                 }
[13:20:31.649]                 ...future.workdir <- getwd()
[13:20:31.649]             }
[13:20:31.649]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:31.649]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:31.649]         }
[13:20:31.649]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:31.649]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:31.649]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:31.649]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:31.649]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:31.649]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:31.649]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:31.649]             base::names(...future.oldOptions))
[13:20:31.649]     }
[13:20:31.649]     if (FALSE) {
[13:20:31.649]     }
[13:20:31.649]     else {
[13:20:31.649]         if (TRUE) {
[13:20:31.649]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:31.649]                 open = "w")
[13:20:31.649]         }
[13:20:31.649]         else {
[13:20:31.649]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:31.649]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:31.649]         }
[13:20:31.649]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:31.649]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:31.649]             base::sink(type = "output", split = FALSE)
[13:20:31.649]             base::close(...future.stdout)
[13:20:31.649]         }, add = TRUE)
[13:20:31.649]     }
[13:20:31.649]     ...future.frame <- base::sys.nframe()
[13:20:31.649]     ...future.conditions <- base::list()
[13:20:31.649]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:31.649]     if (FALSE) {
[13:20:31.649]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:31.649]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:31.649]     }
[13:20:31.649]     ...future.result <- base::tryCatch({
[13:20:31.649]         base::withCallingHandlers({
[13:20:31.649]             ...future.value <- base::withVisible(base::local({
[13:20:31.649]                 lm(weight ~ group - 1)
[13:20:31.649]             }))
[13:20:31.649]             future::FutureResult(value = ...future.value$value, 
[13:20:31.649]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:31.649]                   ...future.rng), globalenv = if (FALSE) 
[13:20:31.649]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:31.649]                     ...future.globalenv.names))
[13:20:31.649]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:31.649]         }, condition = base::local({
[13:20:31.649]             c <- base::c
[13:20:31.649]             inherits <- base::inherits
[13:20:31.649]             invokeRestart <- base::invokeRestart
[13:20:31.649]             length <- base::length
[13:20:31.649]             list <- base::list
[13:20:31.649]             seq.int <- base::seq.int
[13:20:31.649]             signalCondition <- base::signalCondition
[13:20:31.649]             sys.calls <- base::sys.calls
[13:20:31.649]             `[[` <- base::`[[`
[13:20:31.649]             `+` <- base::`+`
[13:20:31.649]             `<<-` <- base::`<<-`
[13:20:31.649]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:31.649]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:31.649]                   3L)]
[13:20:31.649]             }
[13:20:31.649]             function(cond) {
[13:20:31.649]                 is_error <- inherits(cond, "error")
[13:20:31.649]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:31.649]                   NULL)
[13:20:31.649]                 if (is_error) {
[13:20:31.649]                   sessionInformation <- function() {
[13:20:31.649]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:31.649]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:31.649]                       search = base::search(), system = base::Sys.info())
[13:20:31.649]                   }
[13:20:31.649]                   ...future.conditions[[length(...future.conditions) + 
[13:20:31.649]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:31.649]                     cond$call), session = sessionInformation(), 
[13:20:31.649]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:31.649]                   signalCondition(cond)
[13:20:31.649]                 }
[13:20:31.649]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:31.649]                 "immediateCondition"))) {
[13:20:31.649]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:31.649]                   ...future.conditions[[length(...future.conditions) + 
[13:20:31.649]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:31.649]                   if (TRUE && !signal) {
[13:20:31.649]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:31.649]                     {
[13:20:31.649]                       inherits <- base::inherits
[13:20:31.649]                       invokeRestart <- base::invokeRestart
[13:20:31.649]                       is.null <- base::is.null
[13:20:31.649]                       muffled <- FALSE
[13:20:31.649]                       if (inherits(cond, "message")) {
[13:20:31.649]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:31.649]                         if (muffled) 
[13:20:31.649]                           invokeRestart("muffleMessage")
[13:20:31.649]                       }
[13:20:31.649]                       else if (inherits(cond, "warning")) {
[13:20:31.649]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:31.649]                         if (muffled) 
[13:20:31.649]                           invokeRestart("muffleWarning")
[13:20:31.649]                       }
[13:20:31.649]                       else if (inherits(cond, "condition")) {
[13:20:31.649]                         if (!is.null(pattern)) {
[13:20:31.649]                           computeRestarts <- base::computeRestarts
[13:20:31.649]                           grepl <- base::grepl
[13:20:31.649]                           restarts <- computeRestarts(cond)
[13:20:31.649]                           for (restart in restarts) {
[13:20:31.649]                             name <- restart$name
[13:20:31.649]                             if (is.null(name)) 
[13:20:31.649]                               next
[13:20:31.649]                             if (!grepl(pattern, name)) 
[13:20:31.649]                               next
[13:20:31.649]                             invokeRestart(restart)
[13:20:31.649]                             muffled <- TRUE
[13:20:31.649]                             break
[13:20:31.649]                           }
[13:20:31.649]                         }
[13:20:31.649]                       }
[13:20:31.649]                       invisible(muffled)
[13:20:31.649]                     }
[13:20:31.649]                     muffleCondition(cond, pattern = "^muffle")
[13:20:31.649]                   }
[13:20:31.649]                 }
[13:20:31.649]                 else {
[13:20:31.649]                   if (TRUE) {
[13:20:31.649]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:31.649]                     {
[13:20:31.649]                       inherits <- base::inherits
[13:20:31.649]                       invokeRestart <- base::invokeRestart
[13:20:31.649]                       is.null <- base::is.null
[13:20:31.649]                       muffled <- FALSE
[13:20:31.649]                       if (inherits(cond, "message")) {
[13:20:31.649]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:31.649]                         if (muffled) 
[13:20:31.649]                           invokeRestart("muffleMessage")
[13:20:31.649]                       }
[13:20:31.649]                       else if (inherits(cond, "warning")) {
[13:20:31.649]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:31.649]                         if (muffled) 
[13:20:31.649]                           invokeRestart("muffleWarning")
[13:20:31.649]                       }
[13:20:31.649]                       else if (inherits(cond, "condition")) {
[13:20:31.649]                         if (!is.null(pattern)) {
[13:20:31.649]                           computeRestarts <- base::computeRestarts
[13:20:31.649]                           grepl <- base::grepl
[13:20:31.649]                           restarts <- computeRestarts(cond)
[13:20:31.649]                           for (restart in restarts) {
[13:20:31.649]                             name <- restart$name
[13:20:31.649]                             if (is.null(name)) 
[13:20:31.649]                               next
[13:20:31.649]                             if (!grepl(pattern, name)) 
[13:20:31.649]                               next
[13:20:31.649]                             invokeRestart(restart)
[13:20:31.649]                             muffled <- TRUE
[13:20:31.649]                             break
[13:20:31.649]                           }
[13:20:31.649]                         }
[13:20:31.649]                       }
[13:20:31.649]                       invisible(muffled)
[13:20:31.649]                     }
[13:20:31.649]                     muffleCondition(cond, pattern = "^muffle")
[13:20:31.649]                   }
[13:20:31.649]                 }
[13:20:31.649]             }
[13:20:31.649]         }))
[13:20:31.649]     }, error = function(ex) {
[13:20:31.649]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:31.649]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:31.649]                 ...future.rng), started = ...future.startTime, 
[13:20:31.649]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:31.649]             version = "1.8"), class = "FutureResult")
[13:20:31.649]     }, finally = {
[13:20:31.649]         if (!identical(...future.workdir, getwd())) 
[13:20:31.649]             setwd(...future.workdir)
[13:20:31.649]         {
[13:20:31.649]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:31.649]                 ...future.oldOptions$nwarnings <- NULL
[13:20:31.649]             }
[13:20:31.649]             base::options(...future.oldOptions)
[13:20:31.649]             if (.Platform$OS.type == "windows") {
[13:20:31.649]                 old_names <- names(...future.oldEnvVars)
[13:20:31.649]                 envs <- base::Sys.getenv()
[13:20:31.649]                 names <- names(envs)
[13:20:31.649]                 common <- intersect(names, old_names)
[13:20:31.649]                 added <- setdiff(names, old_names)
[13:20:31.649]                 removed <- setdiff(old_names, names)
[13:20:31.649]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:31.649]                   envs[common]]
[13:20:31.649]                 NAMES <- toupper(changed)
[13:20:31.649]                 args <- list()
[13:20:31.649]                 for (kk in seq_along(NAMES)) {
[13:20:31.649]                   name <- changed[[kk]]
[13:20:31.649]                   NAME <- NAMES[[kk]]
[13:20:31.649]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.649]                     next
[13:20:31.649]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:31.649]                 }
[13:20:31.649]                 NAMES <- toupper(added)
[13:20:31.649]                 for (kk in seq_along(NAMES)) {
[13:20:31.649]                   name <- added[[kk]]
[13:20:31.649]                   NAME <- NAMES[[kk]]
[13:20:31.649]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.649]                     next
[13:20:31.649]                   args[[name]] <- ""
[13:20:31.649]                 }
[13:20:31.649]                 NAMES <- toupper(removed)
[13:20:31.649]                 for (kk in seq_along(NAMES)) {
[13:20:31.649]                   name <- removed[[kk]]
[13:20:31.649]                   NAME <- NAMES[[kk]]
[13:20:31.649]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.649]                     next
[13:20:31.649]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:31.649]                 }
[13:20:31.649]                 if (length(args) > 0) 
[13:20:31.649]                   base::do.call(base::Sys.setenv, args = args)
[13:20:31.649]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:31.649]             }
[13:20:31.649]             else {
[13:20:31.649]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:31.649]             }
[13:20:31.649]             {
[13:20:31.649]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:31.649]                   0L) {
[13:20:31.649]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:31.649]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:31.649]                   base::options(opts)
[13:20:31.649]                 }
[13:20:31.649]                 {
[13:20:31.649]                   {
[13:20:31.649]                     NULL
[13:20:31.649]                     RNGkind("Mersenne-Twister")
[13:20:31.649]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:31.649]                       inherits = FALSE)
[13:20:31.649]                   }
[13:20:31.649]                   options(future.plan = NULL)
[13:20:31.649]                   if (is.na(NA_character_)) 
[13:20:31.649]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:31.649]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:31.649]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:31.649]                   {
[13:20:31.649]                     future <- SequentialFuture(..., envir = envir)
[13:20:31.649]                     if (!future$lazy) 
[13:20:31.649]                       future <- run(future)
[13:20:31.649]                     invisible(future)
[13:20:31.649]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:31.649]                 }
[13:20:31.649]             }
[13:20:31.649]         }
[13:20:31.649]     })
[13:20:31.649]     if (TRUE) {
[13:20:31.649]         base::sink(type = "output", split = FALSE)
[13:20:31.649]         if (TRUE) {
[13:20:31.649]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:31.649]         }
[13:20:31.649]         else {
[13:20:31.649]             ...future.result["stdout"] <- base::list(NULL)
[13:20:31.649]         }
[13:20:31.649]         base::close(...future.stdout)
[13:20:31.649]         ...future.stdout <- NULL
[13:20:31.649]     }
[13:20:31.649]     ...future.result$conditions <- ...future.conditions
[13:20:31.649]     ...future.result$finished <- base::Sys.time()
[13:20:31.649]     ...future.result
[13:20:31.649] }
[13:20:31.651] assign_globals() ...
[13:20:31.651] List of 2
[13:20:31.651]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[13:20:31.651]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:31.651]  - attr(*, "where")=List of 2
[13:20:31.651]   ..$ weight:<environment: R_EmptyEnv> 
[13:20:31.651]   ..$ group :<environment: R_EmptyEnv> 
[13:20:31.651]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:31.651]  - attr(*, "resolved")= logi FALSE
[13:20:31.651]  - attr(*, "total_size")= num 896
[13:20:31.651]  - attr(*, "already-done")= logi TRUE
[13:20:31.654] - copied ‘weight’ to environment
[13:20:31.654] - copied ‘group’ to environment
[13:20:31.654] assign_globals() ... done
[13:20:31.654] plan(): Setting new future strategy stack:
[13:20:31.654] List of future strategies:
[13:20:31.654] 1. sequential:
[13:20:31.654]    - args: function (..., envir = parent.frame())
[13:20:31.654]    - tweaked: FALSE
[13:20:31.654]    - call: NULL
[13:20:31.655] plan(): nbrOfWorkers() = 1
[13:20:31.656] plan(): Setting new future strategy stack:
[13:20:31.656] List of future strategies:
[13:20:31.656] 1. sequential:
[13:20:31.656]    - args: function (..., envir = parent.frame())
[13:20:31.656]    - tweaked: FALSE
[13:20:31.656]    - call: plan(strategy)
[13:20:31.657] plan(): nbrOfWorkers() = 1
[13:20:31.657] SequentialFuture started (and completed)
[13:20:31.657] - Launch lazy future ... done
[13:20:31.657] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[13:20:31.659] getGlobalsAndPackages() ...
[13:20:31.659] Searching for globals...
[13:20:31.660] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:20:31.661] Searching for globals ... DONE
[13:20:31.661] Resolving globals: FALSE
[13:20:31.661] The total size of the 2 globals is 896 bytes (896 bytes)
[13:20:31.661] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:20:31.662] - globals: [2] ‘weight’, ‘group’
[13:20:31.662] - packages: [1] ‘stats’
[13:20:31.662] getGlobalsAndPackages() ... DONE
[13:20:31.662] run() for ‘Future’ ...
[13:20:31.662] - state: ‘created’
[13:20:31.662] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:31.663] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:31.663] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:31.663]   - Field: ‘label’
[13:20:31.663]   - Field: ‘local’
[13:20:31.663]   - Field: ‘owner’
[13:20:31.663]   - Field: ‘envir’
[13:20:31.663]   - Field: ‘packages’
[13:20:31.663]   - Field: ‘gc’
[13:20:31.663]   - Field: ‘conditions’
[13:20:31.663]   - Field: ‘expr’
[13:20:31.664]   - Field: ‘uuid’
[13:20:31.664]   - Field: ‘seed’
[13:20:31.664]   - Field: ‘version’
[13:20:31.664]   - Field: ‘result’
[13:20:31.664]   - Field: ‘asynchronous’
[13:20:31.664]   - Field: ‘calls’
[13:20:31.664]   - Field: ‘globals’
[13:20:31.664]   - Field: ‘stdout’
[13:20:31.664]   - Field: ‘earlySignal’
[13:20:31.664]   - Field: ‘lazy’
[13:20:31.664]   - Field: ‘state’
[13:20:31.665] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:31.665] - Launch lazy future ...
[13:20:31.665] Packages needed by the future expression (n = 1): ‘stats’
[13:20:31.667] Packages needed by future strategies (n = 0): <none>
[13:20:31.667] {
[13:20:31.667]     {
[13:20:31.667]         {
[13:20:31.667]             ...future.startTime <- base::Sys.time()
[13:20:31.667]             {
[13:20:31.667]                 {
[13:20:31.667]                   {
[13:20:31.667]                     {
[13:20:31.667]                       base::local({
[13:20:31.667]                         has_future <- base::requireNamespace("future", 
[13:20:31.667]                           quietly = TRUE)
[13:20:31.667]                         if (has_future) {
[13:20:31.667]                           ns <- base::getNamespace("future")
[13:20:31.667]                           version <- ns[[".package"]][["version"]]
[13:20:31.667]                           if (is.null(version)) 
[13:20:31.667]                             version <- utils::packageVersion("future")
[13:20:31.667]                         }
[13:20:31.667]                         else {
[13:20:31.667]                           version <- NULL
[13:20:31.667]                         }
[13:20:31.667]                         if (!has_future || version < "1.8.0") {
[13:20:31.667]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:31.667]                             "", base::R.version$version.string), 
[13:20:31.667]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:31.667]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:31.667]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:31.667]                               "release", "version")], collapse = " "), 
[13:20:31.667]                             hostname = base::Sys.info()[["nodename"]])
[13:20:31.667]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:31.667]                             info)
[13:20:31.667]                           info <- base::paste(info, collapse = "; ")
[13:20:31.667]                           if (!has_future) {
[13:20:31.667]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:31.667]                               info)
[13:20:31.667]                           }
[13:20:31.667]                           else {
[13:20:31.667]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:31.667]                               info, version)
[13:20:31.667]                           }
[13:20:31.667]                           base::stop(msg)
[13:20:31.667]                         }
[13:20:31.667]                       })
[13:20:31.667]                     }
[13:20:31.667]                     base::local({
[13:20:31.667]                       for (pkg in "stats") {
[13:20:31.667]                         base::loadNamespace(pkg)
[13:20:31.667]                         base::library(pkg, character.only = TRUE)
[13:20:31.667]                       }
[13:20:31.667]                     })
[13:20:31.667]                   }
[13:20:31.667]                   options(future.plan = NULL)
[13:20:31.667]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:31.667]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:31.667]                 }
[13:20:31.667]                 ...future.workdir <- getwd()
[13:20:31.667]             }
[13:20:31.667]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:31.667]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:31.667]         }
[13:20:31.667]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:31.667]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:31.667]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:31.667]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:31.667]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:31.667]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:31.667]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:31.667]             base::names(...future.oldOptions))
[13:20:31.667]     }
[13:20:31.667]     if (FALSE) {
[13:20:31.667]     }
[13:20:31.667]     else {
[13:20:31.667]         if (TRUE) {
[13:20:31.667]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:31.667]                 open = "w")
[13:20:31.667]         }
[13:20:31.667]         else {
[13:20:31.667]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:31.667]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:31.667]         }
[13:20:31.667]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:31.667]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:31.667]             base::sink(type = "output", split = FALSE)
[13:20:31.667]             base::close(...future.stdout)
[13:20:31.667]         }, add = TRUE)
[13:20:31.667]     }
[13:20:31.667]     ...future.frame <- base::sys.nframe()
[13:20:31.667]     ...future.conditions <- base::list()
[13:20:31.667]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:31.667]     if (FALSE) {
[13:20:31.667]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:31.667]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:31.667]     }
[13:20:31.667]     ...future.result <- base::tryCatch({
[13:20:31.667]         base::withCallingHandlers({
[13:20:31.667]             ...future.value <- base::withVisible(base::local({
[13:20:31.667]                 lm(weight ~ group - 1)
[13:20:31.667]             }))
[13:20:31.667]             future::FutureResult(value = ...future.value$value, 
[13:20:31.667]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:31.667]                   ...future.rng), globalenv = if (FALSE) 
[13:20:31.667]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:31.667]                     ...future.globalenv.names))
[13:20:31.667]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:31.667]         }, condition = base::local({
[13:20:31.667]             c <- base::c
[13:20:31.667]             inherits <- base::inherits
[13:20:31.667]             invokeRestart <- base::invokeRestart
[13:20:31.667]             length <- base::length
[13:20:31.667]             list <- base::list
[13:20:31.667]             seq.int <- base::seq.int
[13:20:31.667]             signalCondition <- base::signalCondition
[13:20:31.667]             sys.calls <- base::sys.calls
[13:20:31.667]             `[[` <- base::`[[`
[13:20:31.667]             `+` <- base::`+`
[13:20:31.667]             `<<-` <- base::`<<-`
[13:20:31.667]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:31.667]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:31.667]                   3L)]
[13:20:31.667]             }
[13:20:31.667]             function(cond) {
[13:20:31.667]                 is_error <- inherits(cond, "error")
[13:20:31.667]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:31.667]                   NULL)
[13:20:31.667]                 if (is_error) {
[13:20:31.667]                   sessionInformation <- function() {
[13:20:31.667]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:31.667]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:31.667]                       search = base::search(), system = base::Sys.info())
[13:20:31.667]                   }
[13:20:31.667]                   ...future.conditions[[length(...future.conditions) + 
[13:20:31.667]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:31.667]                     cond$call), session = sessionInformation(), 
[13:20:31.667]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:31.667]                   signalCondition(cond)
[13:20:31.667]                 }
[13:20:31.667]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:31.667]                 "immediateCondition"))) {
[13:20:31.667]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:31.667]                   ...future.conditions[[length(...future.conditions) + 
[13:20:31.667]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:31.667]                   if (TRUE && !signal) {
[13:20:31.667]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:31.667]                     {
[13:20:31.667]                       inherits <- base::inherits
[13:20:31.667]                       invokeRestart <- base::invokeRestart
[13:20:31.667]                       is.null <- base::is.null
[13:20:31.667]                       muffled <- FALSE
[13:20:31.667]                       if (inherits(cond, "message")) {
[13:20:31.667]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:31.667]                         if (muffled) 
[13:20:31.667]                           invokeRestart("muffleMessage")
[13:20:31.667]                       }
[13:20:31.667]                       else if (inherits(cond, "warning")) {
[13:20:31.667]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:31.667]                         if (muffled) 
[13:20:31.667]                           invokeRestart("muffleWarning")
[13:20:31.667]                       }
[13:20:31.667]                       else if (inherits(cond, "condition")) {
[13:20:31.667]                         if (!is.null(pattern)) {
[13:20:31.667]                           computeRestarts <- base::computeRestarts
[13:20:31.667]                           grepl <- base::grepl
[13:20:31.667]                           restarts <- computeRestarts(cond)
[13:20:31.667]                           for (restart in restarts) {
[13:20:31.667]                             name <- restart$name
[13:20:31.667]                             if (is.null(name)) 
[13:20:31.667]                               next
[13:20:31.667]                             if (!grepl(pattern, name)) 
[13:20:31.667]                               next
[13:20:31.667]                             invokeRestart(restart)
[13:20:31.667]                             muffled <- TRUE
[13:20:31.667]                             break
[13:20:31.667]                           }
[13:20:31.667]                         }
[13:20:31.667]                       }
[13:20:31.667]                       invisible(muffled)
[13:20:31.667]                     }
[13:20:31.667]                     muffleCondition(cond, pattern = "^muffle")
[13:20:31.667]                   }
[13:20:31.667]                 }
[13:20:31.667]                 else {
[13:20:31.667]                   if (TRUE) {
[13:20:31.667]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:31.667]                     {
[13:20:31.667]                       inherits <- base::inherits
[13:20:31.667]                       invokeRestart <- base::invokeRestart
[13:20:31.667]                       is.null <- base::is.null
[13:20:31.667]                       muffled <- FALSE
[13:20:31.667]                       if (inherits(cond, "message")) {
[13:20:31.667]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:31.667]                         if (muffled) 
[13:20:31.667]                           invokeRestart("muffleMessage")
[13:20:31.667]                       }
[13:20:31.667]                       else if (inherits(cond, "warning")) {
[13:20:31.667]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:31.667]                         if (muffled) 
[13:20:31.667]                           invokeRestart("muffleWarning")
[13:20:31.667]                       }
[13:20:31.667]                       else if (inherits(cond, "condition")) {
[13:20:31.667]                         if (!is.null(pattern)) {
[13:20:31.667]                           computeRestarts <- base::computeRestarts
[13:20:31.667]                           grepl <- base::grepl
[13:20:31.667]                           restarts <- computeRestarts(cond)
[13:20:31.667]                           for (restart in restarts) {
[13:20:31.667]                             name <- restart$name
[13:20:31.667]                             if (is.null(name)) 
[13:20:31.667]                               next
[13:20:31.667]                             if (!grepl(pattern, name)) 
[13:20:31.667]                               next
[13:20:31.667]                             invokeRestart(restart)
[13:20:31.667]                             muffled <- TRUE
[13:20:31.667]                             break
[13:20:31.667]                           }
[13:20:31.667]                         }
[13:20:31.667]                       }
[13:20:31.667]                       invisible(muffled)
[13:20:31.667]                     }
[13:20:31.667]                     muffleCondition(cond, pattern = "^muffle")
[13:20:31.667]                   }
[13:20:31.667]                 }
[13:20:31.667]             }
[13:20:31.667]         }))
[13:20:31.667]     }, error = function(ex) {
[13:20:31.667]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:31.667]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:31.667]                 ...future.rng), started = ...future.startTime, 
[13:20:31.667]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:31.667]             version = "1.8"), class = "FutureResult")
[13:20:31.667]     }, finally = {
[13:20:31.667]         if (!identical(...future.workdir, getwd())) 
[13:20:31.667]             setwd(...future.workdir)
[13:20:31.667]         {
[13:20:31.667]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:31.667]                 ...future.oldOptions$nwarnings <- NULL
[13:20:31.667]             }
[13:20:31.667]             base::options(...future.oldOptions)
[13:20:31.667]             if (.Platform$OS.type == "windows") {
[13:20:31.667]                 old_names <- names(...future.oldEnvVars)
[13:20:31.667]                 envs <- base::Sys.getenv()
[13:20:31.667]                 names <- names(envs)
[13:20:31.667]                 common <- intersect(names, old_names)
[13:20:31.667]                 added <- setdiff(names, old_names)
[13:20:31.667]                 removed <- setdiff(old_names, names)
[13:20:31.667]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:31.667]                   envs[common]]
[13:20:31.667]                 NAMES <- toupper(changed)
[13:20:31.667]                 args <- list()
[13:20:31.667]                 for (kk in seq_along(NAMES)) {
[13:20:31.667]                   name <- changed[[kk]]
[13:20:31.667]                   NAME <- NAMES[[kk]]
[13:20:31.667]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.667]                     next
[13:20:31.667]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:31.667]                 }
[13:20:31.667]                 NAMES <- toupper(added)
[13:20:31.667]                 for (kk in seq_along(NAMES)) {
[13:20:31.667]                   name <- added[[kk]]
[13:20:31.667]                   NAME <- NAMES[[kk]]
[13:20:31.667]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.667]                     next
[13:20:31.667]                   args[[name]] <- ""
[13:20:31.667]                 }
[13:20:31.667]                 NAMES <- toupper(removed)
[13:20:31.667]                 for (kk in seq_along(NAMES)) {
[13:20:31.667]                   name <- removed[[kk]]
[13:20:31.667]                   NAME <- NAMES[[kk]]
[13:20:31.667]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.667]                     next
[13:20:31.667]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:31.667]                 }
[13:20:31.667]                 if (length(args) > 0) 
[13:20:31.667]                   base::do.call(base::Sys.setenv, args = args)
[13:20:31.667]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:31.667]             }
[13:20:31.667]             else {
[13:20:31.667]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:31.667]             }
[13:20:31.667]             {
[13:20:31.667]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:31.667]                   0L) {
[13:20:31.667]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:31.667]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:31.667]                   base::options(opts)
[13:20:31.667]                 }
[13:20:31.667]                 {
[13:20:31.667]                   {
[13:20:31.667]                     NULL
[13:20:31.667]                     RNGkind("Mersenne-Twister")
[13:20:31.667]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:31.667]                       inherits = FALSE)
[13:20:31.667]                   }
[13:20:31.667]                   options(future.plan = NULL)
[13:20:31.667]                   if (is.na(NA_character_)) 
[13:20:31.667]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:31.667]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:31.667]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:31.667]                   {
[13:20:31.667]                     future <- SequentialFuture(..., envir = envir)
[13:20:31.667]                     if (!future$lazy) 
[13:20:31.667]                       future <- run(future)
[13:20:31.667]                     invisible(future)
[13:20:31.667]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:31.667]                 }
[13:20:31.667]             }
[13:20:31.667]         }
[13:20:31.667]     })
[13:20:31.667]     if (TRUE) {
[13:20:31.667]         base::sink(type = "output", split = FALSE)
[13:20:31.667]         if (TRUE) {
[13:20:31.667]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:31.667]         }
[13:20:31.667]         else {
[13:20:31.667]             ...future.result["stdout"] <- base::list(NULL)
[13:20:31.667]         }
[13:20:31.667]         base::close(...future.stdout)
[13:20:31.667]         ...future.stdout <- NULL
[13:20:31.667]     }
[13:20:31.667]     ...future.result$conditions <- ...future.conditions
[13:20:31.667]     ...future.result$finished <- base::Sys.time()
[13:20:31.667]     ...future.result
[13:20:31.667] }
[13:20:31.669] assign_globals() ...
[13:20:31.669] List of 2
[13:20:31.669]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[13:20:31.669]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:31.669]  - attr(*, "where")=List of 2
[13:20:31.669]   ..$ weight:<environment: R_EmptyEnv> 
[13:20:31.669]   ..$ group :<environment: R_EmptyEnv> 
[13:20:31.669]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:31.669]  - attr(*, "resolved")= logi FALSE
[13:20:31.669]  - attr(*, "total_size")= num 896
[13:20:31.669]  - attr(*, "already-done")= logi TRUE
[13:20:31.672] - copied ‘weight’ to environment
[13:20:31.672] - copied ‘group’ to environment
[13:20:31.672] assign_globals() ... done
[13:20:31.672] plan(): Setting new future strategy stack:
[13:20:31.673] List of future strategies:
[13:20:31.673] 1. sequential:
[13:20:31.673]    - args: function (..., envir = parent.frame())
[13:20:31.673]    - tweaked: FALSE
[13:20:31.673]    - call: NULL
[13:20:31.673] plan(): nbrOfWorkers() = 1
[13:20:31.674] plan(): Setting new future strategy stack:
[13:20:31.674] List of future strategies:
[13:20:31.674] 1. sequential:
[13:20:31.674]    - args: function (..., envir = parent.frame())
[13:20:31.674]    - tweaked: FALSE
[13:20:31.674]    - call: plan(strategy)
[13:20:31.675] plan(): nbrOfWorkers() = 1
[13:20:31.675] SequentialFuture started (and completed)
[13:20:31.675] - Launch lazy future ... done
[13:20:31.675] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[13:20:31.677] getGlobalsAndPackages() ...
[13:20:31.677] Searching for globals...
[13:20:31.679] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:20:31.679] Searching for globals ... DONE
[13:20:31.680] Resolving globals: FALSE
[13:20:31.680] The total size of the 2 globals is 896 bytes (896 bytes)
[13:20:31.680] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:20:31.681] - globals: [2] ‘weight’, ‘group’
[13:20:31.681] - packages: [1] ‘stats’
[13:20:31.681] getGlobalsAndPackages() ... DONE
[13:20:31.681] run() for ‘Future’ ...
[13:20:31.681] - state: ‘created’
[13:20:31.681] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:31.682] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:31.682] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:31.682]   - Field: ‘label’
[13:20:31.682]   - Field: ‘local’
[13:20:31.682]   - Field: ‘owner’
[13:20:31.682]   - Field: ‘envir’
[13:20:31.682]   - Field: ‘packages’
[13:20:31.682]   - Field: ‘gc’
[13:20:31.682]   - Field: ‘conditions’
[13:20:31.682]   - Field: ‘expr’
[13:20:31.683]   - Field: ‘uuid’
[13:20:31.683]   - Field: ‘seed’
[13:20:31.683]   - Field: ‘version’
[13:20:31.683]   - Field: ‘result’
[13:20:31.683]   - Field: ‘asynchronous’
[13:20:31.683]   - Field: ‘calls’
[13:20:31.683]   - Field: ‘globals’
[13:20:31.683]   - Field: ‘stdout’
[13:20:31.683]   - Field: ‘earlySignal’
[13:20:31.683]   - Field: ‘lazy’
[13:20:31.683]   - Field: ‘state’
[13:20:31.684] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:31.684] - Launch lazy future ...
[13:20:31.684] Packages needed by the future expression (n = 1): ‘stats’
[13:20:31.684] Packages needed by future strategies (n = 0): <none>
[13:20:31.684] {
[13:20:31.684]     {
[13:20:31.684]         {
[13:20:31.684]             ...future.startTime <- base::Sys.time()
[13:20:31.684]             {
[13:20:31.684]                 {
[13:20:31.684]                   {
[13:20:31.684]                     {
[13:20:31.684]                       base::local({
[13:20:31.684]                         has_future <- base::requireNamespace("future", 
[13:20:31.684]                           quietly = TRUE)
[13:20:31.684]                         if (has_future) {
[13:20:31.684]                           ns <- base::getNamespace("future")
[13:20:31.684]                           version <- ns[[".package"]][["version"]]
[13:20:31.684]                           if (is.null(version)) 
[13:20:31.684]                             version <- utils::packageVersion("future")
[13:20:31.684]                         }
[13:20:31.684]                         else {
[13:20:31.684]                           version <- NULL
[13:20:31.684]                         }
[13:20:31.684]                         if (!has_future || version < "1.8.0") {
[13:20:31.684]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:31.684]                             "", base::R.version$version.string), 
[13:20:31.684]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:31.684]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:31.684]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:31.684]                               "release", "version")], collapse = " "), 
[13:20:31.684]                             hostname = base::Sys.info()[["nodename"]])
[13:20:31.684]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:31.684]                             info)
[13:20:31.684]                           info <- base::paste(info, collapse = "; ")
[13:20:31.684]                           if (!has_future) {
[13:20:31.684]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:31.684]                               info)
[13:20:31.684]                           }
[13:20:31.684]                           else {
[13:20:31.684]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:31.684]                               info, version)
[13:20:31.684]                           }
[13:20:31.684]                           base::stop(msg)
[13:20:31.684]                         }
[13:20:31.684]                       })
[13:20:31.684]                     }
[13:20:31.684]                     base::local({
[13:20:31.684]                       for (pkg in "stats") {
[13:20:31.684]                         base::loadNamespace(pkg)
[13:20:31.684]                         base::library(pkg, character.only = TRUE)
[13:20:31.684]                       }
[13:20:31.684]                     })
[13:20:31.684]                   }
[13:20:31.684]                   options(future.plan = NULL)
[13:20:31.684]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:31.684]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:31.684]                 }
[13:20:31.684]                 ...future.workdir <- getwd()
[13:20:31.684]             }
[13:20:31.684]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:31.684]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:31.684]         }
[13:20:31.684]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:31.684]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:31.684]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:31.684]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:31.684]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:31.684]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:31.684]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:31.684]             base::names(...future.oldOptions))
[13:20:31.684]     }
[13:20:31.684]     if (FALSE) {
[13:20:31.684]     }
[13:20:31.684]     else {
[13:20:31.684]         if (TRUE) {
[13:20:31.684]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:31.684]                 open = "w")
[13:20:31.684]         }
[13:20:31.684]         else {
[13:20:31.684]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:31.684]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:31.684]         }
[13:20:31.684]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:31.684]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:31.684]             base::sink(type = "output", split = FALSE)
[13:20:31.684]             base::close(...future.stdout)
[13:20:31.684]         }, add = TRUE)
[13:20:31.684]     }
[13:20:31.684]     ...future.frame <- base::sys.nframe()
[13:20:31.684]     ...future.conditions <- base::list()
[13:20:31.684]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:31.684]     if (FALSE) {
[13:20:31.684]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:31.684]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:31.684]     }
[13:20:31.684]     ...future.result <- base::tryCatch({
[13:20:31.684]         base::withCallingHandlers({
[13:20:31.684]             ...future.value <- base::withVisible(base::local({
[13:20:31.684]                 lm(weight ~ group - 1)
[13:20:31.684]             }))
[13:20:31.684]             future::FutureResult(value = ...future.value$value, 
[13:20:31.684]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:31.684]                   ...future.rng), globalenv = if (FALSE) 
[13:20:31.684]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:31.684]                     ...future.globalenv.names))
[13:20:31.684]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:31.684]         }, condition = base::local({
[13:20:31.684]             c <- base::c
[13:20:31.684]             inherits <- base::inherits
[13:20:31.684]             invokeRestart <- base::invokeRestart
[13:20:31.684]             length <- base::length
[13:20:31.684]             list <- base::list
[13:20:31.684]             seq.int <- base::seq.int
[13:20:31.684]             signalCondition <- base::signalCondition
[13:20:31.684]             sys.calls <- base::sys.calls
[13:20:31.684]             `[[` <- base::`[[`
[13:20:31.684]             `+` <- base::`+`
[13:20:31.684]             `<<-` <- base::`<<-`
[13:20:31.684]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:31.684]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:31.684]                   3L)]
[13:20:31.684]             }
[13:20:31.684]             function(cond) {
[13:20:31.684]                 is_error <- inherits(cond, "error")
[13:20:31.684]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:31.684]                   NULL)
[13:20:31.684]                 if (is_error) {
[13:20:31.684]                   sessionInformation <- function() {
[13:20:31.684]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:31.684]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:31.684]                       search = base::search(), system = base::Sys.info())
[13:20:31.684]                   }
[13:20:31.684]                   ...future.conditions[[length(...future.conditions) + 
[13:20:31.684]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:31.684]                     cond$call), session = sessionInformation(), 
[13:20:31.684]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:31.684]                   signalCondition(cond)
[13:20:31.684]                 }
[13:20:31.684]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:31.684]                 "immediateCondition"))) {
[13:20:31.684]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:31.684]                   ...future.conditions[[length(...future.conditions) + 
[13:20:31.684]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:31.684]                   if (TRUE && !signal) {
[13:20:31.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:31.684]                     {
[13:20:31.684]                       inherits <- base::inherits
[13:20:31.684]                       invokeRestart <- base::invokeRestart
[13:20:31.684]                       is.null <- base::is.null
[13:20:31.684]                       muffled <- FALSE
[13:20:31.684]                       if (inherits(cond, "message")) {
[13:20:31.684]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:31.684]                         if (muffled) 
[13:20:31.684]                           invokeRestart("muffleMessage")
[13:20:31.684]                       }
[13:20:31.684]                       else if (inherits(cond, "warning")) {
[13:20:31.684]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:31.684]                         if (muffled) 
[13:20:31.684]                           invokeRestart("muffleWarning")
[13:20:31.684]                       }
[13:20:31.684]                       else if (inherits(cond, "condition")) {
[13:20:31.684]                         if (!is.null(pattern)) {
[13:20:31.684]                           computeRestarts <- base::computeRestarts
[13:20:31.684]                           grepl <- base::grepl
[13:20:31.684]                           restarts <- computeRestarts(cond)
[13:20:31.684]                           for (restart in restarts) {
[13:20:31.684]                             name <- restart$name
[13:20:31.684]                             if (is.null(name)) 
[13:20:31.684]                               next
[13:20:31.684]                             if (!grepl(pattern, name)) 
[13:20:31.684]                               next
[13:20:31.684]                             invokeRestart(restart)
[13:20:31.684]                             muffled <- TRUE
[13:20:31.684]                             break
[13:20:31.684]                           }
[13:20:31.684]                         }
[13:20:31.684]                       }
[13:20:31.684]                       invisible(muffled)
[13:20:31.684]                     }
[13:20:31.684]                     muffleCondition(cond, pattern = "^muffle")
[13:20:31.684]                   }
[13:20:31.684]                 }
[13:20:31.684]                 else {
[13:20:31.684]                   if (TRUE) {
[13:20:31.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:31.684]                     {
[13:20:31.684]                       inherits <- base::inherits
[13:20:31.684]                       invokeRestart <- base::invokeRestart
[13:20:31.684]                       is.null <- base::is.null
[13:20:31.684]                       muffled <- FALSE
[13:20:31.684]                       if (inherits(cond, "message")) {
[13:20:31.684]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:31.684]                         if (muffled) 
[13:20:31.684]                           invokeRestart("muffleMessage")
[13:20:31.684]                       }
[13:20:31.684]                       else if (inherits(cond, "warning")) {
[13:20:31.684]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:31.684]                         if (muffled) 
[13:20:31.684]                           invokeRestart("muffleWarning")
[13:20:31.684]                       }
[13:20:31.684]                       else if (inherits(cond, "condition")) {
[13:20:31.684]                         if (!is.null(pattern)) {
[13:20:31.684]                           computeRestarts <- base::computeRestarts
[13:20:31.684]                           grepl <- base::grepl
[13:20:31.684]                           restarts <- computeRestarts(cond)
[13:20:31.684]                           for (restart in restarts) {
[13:20:31.684]                             name <- restart$name
[13:20:31.684]                             if (is.null(name)) 
[13:20:31.684]                               next
[13:20:31.684]                             if (!grepl(pattern, name)) 
[13:20:31.684]                               next
[13:20:31.684]                             invokeRestart(restart)
[13:20:31.684]                             muffled <- TRUE
[13:20:31.684]                             break
[13:20:31.684]                           }
[13:20:31.684]                         }
[13:20:31.684]                       }
[13:20:31.684]                       invisible(muffled)
[13:20:31.684]                     }
[13:20:31.684]                     muffleCondition(cond, pattern = "^muffle")
[13:20:31.684]                   }
[13:20:31.684]                 }
[13:20:31.684]             }
[13:20:31.684]         }))
[13:20:31.684]     }, error = function(ex) {
[13:20:31.684]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:31.684]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:31.684]                 ...future.rng), started = ...future.startTime, 
[13:20:31.684]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:31.684]             version = "1.8"), class = "FutureResult")
[13:20:31.684]     }, finally = {
[13:20:31.684]         if (!identical(...future.workdir, getwd())) 
[13:20:31.684]             setwd(...future.workdir)
[13:20:31.684]         {
[13:20:31.684]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:31.684]                 ...future.oldOptions$nwarnings <- NULL
[13:20:31.684]             }
[13:20:31.684]             base::options(...future.oldOptions)
[13:20:31.684]             if (.Platform$OS.type == "windows") {
[13:20:31.684]                 old_names <- names(...future.oldEnvVars)
[13:20:31.684]                 envs <- base::Sys.getenv()
[13:20:31.684]                 names <- names(envs)
[13:20:31.684]                 common <- intersect(names, old_names)
[13:20:31.684]                 added <- setdiff(names, old_names)
[13:20:31.684]                 removed <- setdiff(old_names, names)
[13:20:31.684]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:31.684]                   envs[common]]
[13:20:31.684]                 NAMES <- toupper(changed)
[13:20:31.684]                 args <- list()
[13:20:31.684]                 for (kk in seq_along(NAMES)) {
[13:20:31.684]                   name <- changed[[kk]]
[13:20:31.684]                   NAME <- NAMES[[kk]]
[13:20:31.684]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.684]                     next
[13:20:31.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:31.684]                 }
[13:20:31.684]                 NAMES <- toupper(added)
[13:20:31.684]                 for (kk in seq_along(NAMES)) {
[13:20:31.684]                   name <- added[[kk]]
[13:20:31.684]                   NAME <- NAMES[[kk]]
[13:20:31.684]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.684]                     next
[13:20:31.684]                   args[[name]] <- ""
[13:20:31.684]                 }
[13:20:31.684]                 NAMES <- toupper(removed)
[13:20:31.684]                 for (kk in seq_along(NAMES)) {
[13:20:31.684]                   name <- removed[[kk]]
[13:20:31.684]                   NAME <- NAMES[[kk]]
[13:20:31.684]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.684]                     next
[13:20:31.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:31.684]                 }
[13:20:31.684]                 if (length(args) > 0) 
[13:20:31.684]                   base::do.call(base::Sys.setenv, args = args)
[13:20:31.684]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:31.684]             }
[13:20:31.684]             else {
[13:20:31.684]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:31.684]             }
[13:20:31.684]             {
[13:20:31.684]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:31.684]                   0L) {
[13:20:31.684]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:31.684]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:31.684]                   base::options(opts)
[13:20:31.684]                 }
[13:20:31.684]                 {
[13:20:31.684]                   {
[13:20:31.684]                     NULL
[13:20:31.684]                     RNGkind("Mersenne-Twister")
[13:20:31.684]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:31.684]                       inherits = FALSE)
[13:20:31.684]                   }
[13:20:31.684]                   options(future.plan = NULL)
[13:20:31.684]                   if (is.na(NA_character_)) 
[13:20:31.684]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:31.684]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:31.684]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:31.684]                   {
[13:20:31.684]                     future <- SequentialFuture(..., envir = envir)
[13:20:31.684]                     if (!future$lazy) 
[13:20:31.684]                       future <- run(future)
[13:20:31.684]                     invisible(future)
[13:20:31.684]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:31.684]                 }
[13:20:31.684]             }
[13:20:31.684]         }
[13:20:31.684]     })
[13:20:31.684]     if (TRUE) {
[13:20:31.684]         base::sink(type = "output", split = FALSE)
[13:20:31.684]         if (TRUE) {
[13:20:31.684]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:31.684]         }
[13:20:31.684]         else {
[13:20:31.684]             ...future.result["stdout"] <- base::list(NULL)
[13:20:31.684]         }
[13:20:31.684]         base::close(...future.stdout)
[13:20:31.684]         ...future.stdout <- NULL
[13:20:31.684]     }
[13:20:31.684]     ...future.result$conditions <- ...future.conditions
[13:20:31.684]     ...future.result$finished <- base::Sys.time()
[13:20:31.684]     ...future.result
[13:20:31.684] }
[13:20:31.686] assign_globals() ...
[13:20:31.686] List of 2
[13:20:31.686]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[13:20:31.686]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:31.686]  - attr(*, "where")=List of 2
[13:20:31.686]   ..$ weight:<environment: R_EmptyEnv> 
[13:20:31.686]   ..$ group :<environment: R_EmptyEnv> 
[13:20:31.686]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:31.686]  - attr(*, "resolved")= logi FALSE
[13:20:31.686]  - attr(*, "total_size")= num 896
[13:20:31.686]  - attr(*, "already-done")= logi TRUE
[13:20:31.689] - copied ‘weight’ to environment
[13:20:31.689] - copied ‘group’ to environment
[13:20:31.689] assign_globals() ... done
[13:20:31.690] plan(): Setting new future strategy stack:
[13:20:31.690] List of future strategies:
[13:20:31.690] 1. sequential:
[13:20:31.690]    - args: function (..., envir = parent.frame())
[13:20:31.690]    - tweaked: FALSE
[13:20:31.690]    - call: NULL
[13:20:31.690] plan(): nbrOfWorkers() = 1
[13:20:31.692] plan(): Setting new future strategy stack:
[13:20:31.692] List of future strategies:
[13:20:31.692] 1. sequential:
[13:20:31.692]    - args: function (..., envir = parent.frame())
[13:20:31.692]    - tweaked: FALSE
[13:20:31.692]    - call: plan(strategy)
[13:20:31.692] plan(): nbrOfWorkers() = 1
[13:20:31.694] SequentialFuture started (and completed)
[13:20:31.694] - Launch lazy future ... done
[13:20:31.694] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[13:20:31.696] getGlobalsAndPackages() ...
[13:20:31.696] Searching for globals...
[13:20:31.697] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[13:20:31.697] Searching for globals ... DONE
[13:20:31.697] Resolving globals: FALSE
[13:20:31.697] The total size of the 1 globals is 96 bytes (96 bytes)
[13:20:31.698] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[13:20:31.698] - globals: [1] ‘x’
[13:20:31.698] - packages: [1] ‘stats’
[13:20:31.698] getGlobalsAndPackages() ... DONE
[13:20:31.698] run() for ‘Future’ ...
[13:20:31.698] - state: ‘created’
[13:20:31.698] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:31.699] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:31.699] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:31.699]   - Field: ‘label’
[13:20:31.699]   - Field: ‘local’
[13:20:31.699]   - Field: ‘owner’
[13:20:31.699]   - Field: ‘envir’
[13:20:31.699]   - Field: ‘packages’
[13:20:31.699]   - Field: ‘gc’
[13:20:31.699]   - Field: ‘conditions’
[13:20:31.700]   - Field: ‘expr’
[13:20:31.700]   - Field: ‘uuid’
[13:20:31.700]   - Field: ‘seed’
[13:20:31.700]   - Field: ‘version’
[13:20:31.700]   - Field: ‘result’
[13:20:31.700]   - Field: ‘asynchronous’
[13:20:31.700]   - Field: ‘calls’
[13:20:31.700]   - Field: ‘globals’
[13:20:31.700]   - Field: ‘stdout’
[13:20:31.700]   - Field: ‘earlySignal’
[13:20:31.700]   - Field: ‘lazy’
[13:20:31.701]   - Field: ‘state’
[13:20:31.701] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:31.701] - Launch lazy future ...
[13:20:31.701] Packages needed by the future expression (n = 1): ‘stats’
[13:20:31.701] Packages needed by future strategies (n = 0): <none>
[13:20:31.702] {
[13:20:31.702]     {
[13:20:31.702]         {
[13:20:31.702]             ...future.startTime <- base::Sys.time()
[13:20:31.702]             {
[13:20:31.702]                 {
[13:20:31.702]                   {
[13:20:31.702]                     {
[13:20:31.702]                       base::local({
[13:20:31.702]                         has_future <- base::requireNamespace("future", 
[13:20:31.702]                           quietly = TRUE)
[13:20:31.702]                         if (has_future) {
[13:20:31.702]                           ns <- base::getNamespace("future")
[13:20:31.702]                           version <- ns[[".package"]][["version"]]
[13:20:31.702]                           if (is.null(version)) 
[13:20:31.702]                             version <- utils::packageVersion("future")
[13:20:31.702]                         }
[13:20:31.702]                         else {
[13:20:31.702]                           version <- NULL
[13:20:31.702]                         }
[13:20:31.702]                         if (!has_future || version < "1.8.0") {
[13:20:31.702]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:31.702]                             "", base::R.version$version.string), 
[13:20:31.702]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:31.702]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:31.702]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:31.702]                               "release", "version")], collapse = " "), 
[13:20:31.702]                             hostname = base::Sys.info()[["nodename"]])
[13:20:31.702]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:31.702]                             info)
[13:20:31.702]                           info <- base::paste(info, collapse = "; ")
[13:20:31.702]                           if (!has_future) {
[13:20:31.702]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:31.702]                               info)
[13:20:31.702]                           }
[13:20:31.702]                           else {
[13:20:31.702]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:31.702]                               info, version)
[13:20:31.702]                           }
[13:20:31.702]                           base::stop(msg)
[13:20:31.702]                         }
[13:20:31.702]                       })
[13:20:31.702]                     }
[13:20:31.702]                     base::local({
[13:20:31.702]                       for (pkg in "stats") {
[13:20:31.702]                         base::loadNamespace(pkg)
[13:20:31.702]                         base::library(pkg, character.only = TRUE)
[13:20:31.702]                       }
[13:20:31.702]                     })
[13:20:31.702]                   }
[13:20:31.702]                   options(future.plan = NULL)
[13:20:31.702]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:31.702]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:31.702]                 }
[13:20:31.702]                 ...future.workdir <- getwd()
[13:20:31.702]             }
[13:20:31.702]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:31.702]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:31.702]         }
[13:20:31.702]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:31.702]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:31.702]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:31.702]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:31.702]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:31.702]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:31.702]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:31.702]             base::names(...future.oldOptions))
[13:20:31.702]     }
[13:20:31.702]     if (FALSE) {
[13:20:31.702]     }
[13:20:31.702]     else {
[13:20:31.702]         if (TRUE) {
[13:20:31.702]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:31.702]                 open = "w")
[13:20:31.702]         }
[13:20:31.702]         else {
[13:20:31.702]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:31.702]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:31.702]         }
[13:20:31.702]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:31.702]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:31.702]             base::sink(type = "output", split = FALSE)
[13:20:31.702]             base::close(...future.stdout)
[13:20:31.702]         }, add = TRUE)
[13:20:31.702]     }
[13:20:31.702]     ...future.frame <- base::sys.nframe()
[13:20:31.702]     ...future.conditions <- base::list()
[13:20:31.702]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:31.702]     if (FALSE) {
[13:20:31.702]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:31.702]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:31.702]     }
[13:20:31.702]     ...future.result <- base::tryCatch({
[13:20:31.702]         base::withCallingHandlers({
[13:20:31.702]             ...future.value <- base::withVisible(base::local({
[13:20:31.702]                 xtabs(~x)
[13:20:31.702]             }))
[13:20:31.702]             future::FutureResult(value = ...future.value$value, 
[13:20:31.702]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:31.702]                   ...future.rng), globalenv = if (FALSE) 
[13:20:31.702]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:31.702]                     ...future.globalenv.names))
[13:20:31.702]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:31.702]         }, condition = base::local({
[13:20:31.702]             c <- base::c
[13:20:31.702]             inherits <- base::inherits
[13:20:31.702]             invokeRestart <- base::invokeRestart
[13:20:31.702]             length <- base::length
[13:20:31.702]             list <- base::list
[13:20:31.702]             seq.int <- base::seq.int
[13:20:31.702]             signalCondition <- base::signalCondition
[13:20:31.702]             sys.calls <- base::sys.calls
[13:20:31.702]             `[[` <- base::`[[`
[13:20:31.702]             `+` <- base::`+`
[13:20:31.702]             `<<-` <- base::`<<-`
[13:20:31.702]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:31.702]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:31.702]                   3L)]
[13:20:31.702]             }
[13:20:31.702]             function(cond) {
[13:20:31.702]                 is_error <- inherits(cond, "error")
[13:20:31.702]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:31.702]                   NULL)
[13:20:31.702]                 if (is_error) {
[13:20:31.702]                   sessionInformation <- function() {
[13:20:31.702]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:31.702]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:31.702]                       search = base::search(), system = base::Sys.info())
[13:20:31.702]                   }
[13:20:31.702]                   ...future.conditions[[length(...future.conditions) + 
[13:20:31.702]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:31.702]                     cond$call), session = sessionInformation(), 
[13:20:31.702]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:31.702]                   signalCondition(cond)
[13:20:31.702]                 }
[13:20:31.702]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:31.702]                 "immediateCondition"))) {
[13:20:31.702]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:31.702]                   ...future.conditions[[length(...future.conditions) + 
[13:20:31.702]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:31.702]                   if (TRUE && !signal) {
[13:20:31.702]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:31.702]                     {
[13:20:31.702]                       inherits <- base::inherits
[13:20:31.702]                       invokeRestart <- base::invokeRestart
[13:20:31.702]                       is.null <- base::is.null
[13:20:31.702]                       muffled <- FALSE
[13:20:31.702]                       if (inherits(cond, "message")) {
[13:20:31.702]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:31.702]                         if (muffled) 
[13:20:31.702]                           invokeRestart("muffleMessage")
[13:20:31.702]                       }
[13:20:31.702]                       else if (inherits(cond, "warning")) {
[13:20:31.702]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:31.702]                         if (muffled) 
[13:20:31.702]                           invokeRestart("muffleWarning")
[13:20:31.702]                       }
[13:20:31.702]                       else if (inherits(cond, "condition")) {
[13:20:31.702]                         if (!is.null(pattern)) {
[13:20:31.702]                           computeRestarts <- base::computeRestarts
[13:20:31.702]                           grepl <- base::grepl
[13:20:31.702]                           restarts <- computeRestarts(cond)
[13:20:31.702]                           for (restart in restarts) {
[13:20:31.702]                             name <- restart$name
[13:20:31.702]                             if (is.null(name)) 
[13:20:31.702]                               next
[13:20:31.702]                             if (!grepl(pattern, name)) 
[13:20:31.702]                               next
[13:20:31.702]                             invokeRestart(restart)
[13:20:31.702]                             muffled <- TRUE
[13:20:31.702]                             break
[13:20:31.702]                           }
[13:20:31.702]                         }
[13:20:31.702]                       }
[13:20:31.702]                       invisible(muffled)
[13:20:31.702]                     }
[13:20:31.702]                     muffleCondition(cond, pattern = "^muffle")
[13:20:31.702]                   }
[13:20:31.702]                 }
[13:20:31.702]                 else {
[13:20:31.702]                   if (TRUE) {
[13:20:31.702]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:31.702]                     {
[13:20:31.702]                       inherits <- base::inherits
[13:20:31.702]                       invokeRestart <- base::invokeRestart
[13:20:31.702]                       is.null <- base::is.null
[13:20:31.702]                       muffled <- FALSE
[13:20:31.702]                       if (inherits(cond, "message")) {
[13:20:31.702]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:31.702]                         if (muffled) 
[13:20:31.702]                           invokeRestart("muffleMessage")
[13:20:31.702]                       }
[13:20:31.702]                       else if (inherits(cond, "warning")) {
[13:20:31.702]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:31.702]                         if (muffled) 
[13:20:31.702]                           invokeRestart("muffleWarning")
[13:20:31.702]                       }
[13:20:31.702]                       else if (inherits(cond, "condition")) {
[13:20:31.702]                         if (!is.null(pattern)) {
[13:20:31.702]                           computeRestarts <- base::computeRestarts
[13:20:31.702]                           grepl <- base::grepl
[13:20:31.702]                           restarts <- computeRestarts(cond)
[13:20:31.702]                           for (restart in restarts) {
[13:20:31.702]                             name <- restart$name
[13:20:31.702]                             if (is.null(name)) 
[13:20:31.702]                               next
[13:20:31.702]                             if (!grepl(pattern, name)) 
[13:20:31.702]                               next
[13:20:31.702]                             invokeRestart(restart)
[13:20:31.702]                             muffled <- TRUE
[13:20:31.702]                             break
[13:20:31.702]                           }
[13:20:31.702]                         }
[13:20:31.702]                       }
[13:20:31.702]                       invisible(muffled)
[13:20:31.702]                     }
[13:20:31.702]                     muffleCondition(cond, pattern = "^muffle")
[13:20:31.702]                   }
[13:20:31.702]                 }
[13:20:31.702]             }
[13:20:31.702]         }))
[13:20:31.702]     }, error = function(ex) {
[13:20:31.702]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:31.702]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:31.702]                 ...future.rng), started = ...future.startTime, 
[13:20:31.702]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:31.702]             version = "1.8"), class = "FutureResult")
[13:20:31.702]     }, finally = {
[13:20:31.702]         if (!identical(...future.workdir, getwd())) 
[13:20:31.702]             setwd(...future.workdir)
[13:20:31.702]         {
[13:20:31.702]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:31.702]                 ...future.oldOptions$nwarnings <- NULL
[13:20:31.702]             }
[13:20:31.702]             base::options(...future.oldOptions)
[13:20:31.702]             if (.Platform$OS.type == "windows") {
[13:20:31.702]                 old_names <- names(...future.oldEnvVars)
[13:20:31.702]                 envs <- base::Sys.getenv()
[13:20:31.702]                 names <- names(envs)
[13:20:31.702]                 common <- intersect(names, old_names)
[13:20:31.702]                 added <- setdiff(names, old_names)
[13:20:31.702]                 removed <- setdiff(old_names, names)
[13:20:31.702]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:31.702]                   envs[common]]
[13:20:31.702]                 NAMES <- toupper(changed)
[13:20:31.702]                 args <- list()
[13:20:31.702]                 for (kk in seq_along(NAMES)) {
[13:20:31.702]                   name <- changed[[kk]]
[13:20:31.702]                   NAME <- NAMES[[kk]]
[13:20:31.702]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.702]                     next
[13:20:31.702]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:31.702]                 }
[13:20:31.702]                 NAMES <- toupper(added)
[13:20:31.702]                 for (kk in seq_along(NAMES)) {
[13:20:31.702]                   name <- added[[kk]]
[13:20:31.702]                   NAME <- NAMES[[kk]]
[13:20:31.702]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.702]                     next
[13:20:31.702]                   args[[name]] <- ""
[13:20:31.702]                 }
[13:20:31.702]                 NAMES <- toupper(removed)
[13:20:31.702]                 for (kk in seq_along(NAMES)) {
[13:20:31.702]                   name <- removed[[kk]]
[13:20:31.702]                   NAME <- NAMES[[kk]]
[13:20:31.702]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.702]                     next
[13:20:31.702]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:31.702]                 }
[13:20:31.702]                 if (length(args) > 0) 
[13:20:31.702]                   base::do.call(base::Sys.setenv, args = args)
[13:20:31.702]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:31.702]             }
[13:20:31.702]             else {
[13:20:31.702]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:31.702]             }
[13:20:31.702]             {
[13:20:31.702]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:31.702]                   0L) {
[13:20:31.702]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:31.702]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:31.702]                   base::options(opts)
[13:20:31.702]                 }
[13:20:31.702]                 {
[13:20:31.702]                   {
[13:20:31.702]                     NULL
[13:20:31.702]                     RNGkind("Mersenne-Twister")
[13:20:31.702]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:31.702]                       inherits = FALSE)
[13:20:31.702]                   }
[13:20:31.702]                   options(future.plan = NULL)
[13:20:31.702]                   if (is.na(NA_character_)) 
[13:20:31.702]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:31.702]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:31.702]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:31.702]                   {
[13:20:31.702]                     future <- SequentialFuture(..., envir = envir)
[13:20:31.702]                     if (!future$lazy) 
[13:20:31.702]                       future <- run(future)
[13:20:31.702]                     invisible(future)
[13:20:31.702]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:31.702]                 }
[13:20:31.702]             }
[13:20:31.702]         }
[13:20:31.702]     })
[13:20:31.702]     if (TRUE) {
[13:20:31.702]         base::sink(type = "output", split = FALSE)
[13:20:31.702]         if (TRUE) {
[13:20:31.702]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:31.702]         }
[13:20:31.702]         else {
[13:20:31.702]             ...future.result["stdout"] <- base::list(NULL)
[13:20:31.702]         }
[13:20:31.702]         base::close(...future.stdout)
[13:20:31.702]         ...future.stdout <- NULL
[13:20:31.702]     }
[13:20:31.702]     ...future.result$conditions <- ...future.conditions
[13:20:31.702]     ...future.result$finished <- base::Sys.time()
[13:20:31.702]     ...future.result
[13:20:31.702] }
[13:20:31.703] assign_globals() ...
[13:20:31.703] List of 1
[13:20:31.703]  $ x: num [1:5] 1 1 2 2 2
[13:20:31.703]  - attr(*, "where")=List of 1
[13:20:31.703]   ..$ x:<environment: R_EmptyEnv> 
[13:20:31.703]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:31.703]  - attr(*, "resolved")= logi FALSE
[13:20:31.703]  - attr(*, "total_size")= num 96
[13:20:31.703]  - attr(*, "already-done")= logi TRUE
[13:20:31.706] - copied ‘x’ to environment
[13:20:31.706] assign_globals() ... done
[13:20:31.706] plan(): Setting new future strategy stack:
[13:20:31.706] List of future strategies:
[13:20:31.706] 1. sequential:
[13:20:31.706]    - args: function (..., envir = parent.frame())
[13:20:31.706]    - tweaked: FALSE
[13:20:31.706]    - call: NULL
[13:20:31.707] plan(): nbrOfWorkers() = 1
[13:20:31.708] plan(): Setting new future strategy stack:
[13:20:31.708] List of future strategies:
[13:20:31.708] 1. sequential:
[13:20:31.708]    - args: function (..., envir = parent.frame())
[13:20:31.708]    - tweaked: FALSE
[13:20:31.708]    - call: plan(strategy)
[13:20:31.708] plan(): nbrOfWorkers() = 1
[13:20:31.708] SequentialFuture started (and completed)
[13:20:31.708] - Launch lazy future ... done
[13:20:31.708] run() for ‘SequentialFuture’ ... done
x
1 2 
2 3 
[13:20:31.709] getGlobalsAndPackages() ...
[13:20:31.709] Searching for globals...
[13:20:31.710] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[13:20:31.710] Searching for globals ... DONE
[13:20:31.710] Resolving globals: FALSE
[13:20:31.711] The total size of the 1 globals is 96 bytes (96 bytes)
[13:20:31.711] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[13:20:31.711] - globals: [1] ‘x’
[13:20:31.711] - packages: [1] ‘stats’
[13:20:31.712] getGlobalsAndPackages() ... DONE
[13:20:31.712] run() for ‘Future’ ...
[13:20:31.712] - state: ‘created’
[13:20:31.712] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:31.712] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:31.712] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:31.712]   - Field: ‘label’
[13:20:31.713]   - Field: ‘local’
[13:20:31.713]   - Field: ‘owner’
[13:20:31.713]   - Field: ‘envir’
[13:20:31.713]   - Field: ‘packages’
[13:20:31.713]   - Field: ‘gc’
[13:20:31.713]   - Field: ‘conditions’
[13:20:31.713]   - Field: ‘expr’
[13:20:31.713]   - Field: ‘uuid’
[13:20:31.713]   - Field: ‘seed’
[13:20:31.713]   - Field: ‘version’
[13:20:31.714]   - Field: ‘result’
[13:20:31.714]   - Field: ‘asynchronous’
[13:20:31.714]   - Field: ‘calls’
[13:20:31.714]   - Field: ‘globals’
[13:20:31.714]   - Field: ‘stdout’
[13:20:31.714]   - Field: ‘earlySignal’
[13:20:31.714]   - Field: ‘lazy’
[13:20:31.714]   - Field: ‘state’
[13:20:31.714] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:31.714] - Launch lazy future ...
[13:20:31.715] Packages needed by the future expression (n = 1): ‘stats’
[13:20:31.715] Packages needed by future strategies (n = 0): <none>
[13:20:31.715] {
[13:20:31.715]     {
[13:20:31.715]         {
[13:20:31.715]             ...future.startTime <- base::Sys.time()
[13:20:31.715]             {
[13:20:31.715]                 {
[13:20:31.715]                   {
[13:20:31.715]                     {
[13:20:31.715]                       base::local({
[13:20:31.715]                         has_future <- base::requireNamespace("future", 
[13:20:31.715]                           quietly = TRUE)
[13:20:31.715]                         if (has_future) {
[13:20:31.715]                           ns <- base::getNamespace("future")
[13:20:31.715]                           version <- ns[[".package"]][["version"]]
[13:20:31.715]                           if (is.null(version)) 
[13:20:31.715]                             version <- utils::packageVersion("future")
[13:20:31.715]                         }
[13:20:31.715]                         else {
[13:20:31.715]                           version <- NULL
[13:20:31.715]                         }
[13:20:31.715]                         if (!has_future || version < "1.8.0") {
[13:20:31.715]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:31.715]                             "", base::R.version$version.string), 
[13:20:31.715]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:31.715]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:31.715]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:31.715]                               "release", "version")], collapse = " "), 
[13:20:31.715]                             hostname = base::Sys.info()[["nodename"]])
[13:20:31.715]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:31.715]                             info)
[13:20:31.715]                           info <- base::paste(info, collapse = "; ")
[13:20:31.715]                           if (!has_future) {
[13:20:31.715]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:31.715]                               info)
[13:20:31.715]                           }
[13:20:31.715]                           else {
[13:20:31.715]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:31.715]                               info, version)
[13:20:31.715]                           }
[13:20:31.715]                           base::stop(msg)
[13:20:31.715]                         }
[13:20:31.715]                       })
[13:20:31.715]                     }
[13:20:31.715]                     base::local({
[13:20:31.715]                       for (pkg in "stats") {
[13:20:31.715]                         base::loadNamespace(pkg)
[13:20:31.715]                         base::library(pkg, character.only = TRUE)
[13:20:31.715]                       }
[13:20:31.715]                     })
[13:20:31.715]                   }
[13:20:31.715]                   options(future.plan = NULL)
[13:20:31.715]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:31.715]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:31.715]                 }
[13:20:31.715]                 ...future.workdir <- getwd()
[13:20:31.715]             }
[13:20:31.715]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:31.715]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:31.715]         }
[13:20:31.715]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:31.715]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:31.715]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:31.715]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:31.715]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:31.715]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:31.715]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:31.715]             base::names(...future.oldOptions))
[13:20:31.715]     }
[13:20:31.715]     if (FALSE) {
[13:20:31.715]     }
[13:20:31.715]     else {
[13:20:31.715]         if (TRUE) {
[13:20:31.715]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:31.715]                 open = "w")
[13:20:31.715]         }
[13:20:31.715]         else {
[13:20:31.715]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:31.715]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:31.715]         }
[13:20:31.715]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:31.715]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:31.715]             base::sink(type = "output", split = FALSE)
[13:20:31.715]             base::close(...future.stdout)
[13:20:31.715]         }, add = TRUE)
[13:20:31.715]     }
[13:20:31.715]     ...future.frame <- base::sys.nframe()
[13:20:31.715]     ...future.conditions <- base::list()
[13:20:31.715]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:31.715]     if (FALSE) {
[13:20:31.715]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:31.715]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:31.715]     }
[13:20:31.715]     ...future.result <- base::tryCatch({
[13:20:31.715]         base::withCallingHandlers({
[13:20:31.715]             ...future.value <- base::withVisible(base::local({
[13:20:31.715]                 xtabs(~x)
[13:20:31.715]             }))
[13:20:31.715]             future::FutureResult(value = ...future.value$value, 
[13:20:31.715]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:31.715]                   ...future.rng), globalenv = if (FALSE) 
[13:20:31.715]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:31.715]                     ...future.globalenv.names))
[13:20:31.715]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:31.715]         }, condition = base::local({
[13:20:31.715]             c <- base::c
[13:20:31.715]             inherits <- base::inherits
[13:20:31.715]             invokeRestart <- base::invokeRestart
[13:20:31.715]             length <- base::length
[13:20:31.715]             list <- base::list
[13:20:31.715]             seq.int <- base::seq.int
[13:20:31.715]             signalCondition <- base::signalCondition
[13:20:31.715]             sys.calls <- base::sys.calls
[13:20:31.715]             `[[` <- base::`[[`
[13:20:31.715]             `+` <- base::`+`
[13:20:31.715]             `<<-` <- base::`<<-`
[13:20:31.715]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:31.715]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:31.715]                   3L)]
[13:20:31.715]             }
[13:20:31.715]             function(cond) {
[13:20:31.715]                 is_error <- inherits(cond, "error")
[13:20:31.715]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:31.715]                   NULL)
[13:20:31.715]                 if (is_error) {
[13:20:31.715]                   sessionInformation <- function() {
[13:20:31.715]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:31.715]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:31.715]                       search = base::search(), system = base::Sys.info())
[13:20:31.715]                   }
[13:20:31.715]                   ...future.conditions[[length(...future.conditions) + 
[13:20:31.715]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:31.715]                     cond$call), session = sessionInformation(), 
[13:20:31.715]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:31.715]                   signalCondition(cond)
[13:20:31.715]                 }
[13:20:31.715]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:31.715]                 "immediateCondition"))) {
[13:20:31.715]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:31.715]                   ...future.conditions[[length(...future.conditions) + 
[13:20:31.715]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:31.715]                   if (TRUE && !signal) {
[13:20:31.715]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:31.715]                     {
[13:20:31.715]                       inherits <- base::inherits
[13:20:31.715]                       invokeRestart <- base::invokeRestart
[13:20:31.715]                       is.null <- base::is.null
[13:20:31.715]                       muffled <- FALSE
[13:20:31.715]                       if (inherits(cond, "message")) {
[13:20:31.715]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:31.715]                         if (muffled) 
[13:20:31.715]                           invokeRestart("muffleMessage")
[13:20:31.715]                       }
[13:20:31.715]                       else if (inherits(cond, "warning")) {
[13:20:31.715]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:31.715]                         if (muffled) 
[13:20:31.715]                           invokeRestart("muffleWarning")
[13:20:31.715]                       }
[13:20:31.715]                       else if (inherits(cond, "condition")) {
[13:20:31.715]                         if (!is.null(pattern)) {
[13:20:31.715]                           computeRestarts <- base::computeRestarts
[13:20:31.715]                           grepl <- base::grepl
[13:20:31.715]                           restarts <- computeRestarts(cond)
[13:20:31.715]                           for (restart in restarts) {
[13:20:31.715]                             name <- restart$name
[13:20:31.715]                             if (is.null(name)) 
[13:20:31.715]                               next
[13:20:31.715]                             if (!grepl(pattern, name)) 
[13:20:31.715]                               next
[13:20:31.715]                             invokeRestart(restart)
[13:20:31.715]                             muffled <- TRUE
[13:20:31.715]                             break
[13:20:31.715]                           }
[13:20:31.715]                         }
[13:20:31.715]                       }
[13:20:31.715]                       invisible(muffled)
[13:20:31.715]                     }
[13:20:31.715]                     muffleCondition(cond, pattern = "^muffle")
[13:20:31.715]                   }
[13:20:31.715]                 }
[13:20:31.715]                 else {
[13:20:31.715]                   if (TRUE) {
[13:20:31.715]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:31.715]                     {
[13:20:31.715]                       inherits <- base::inherits
[13:20:31.715]                       invokeRestart <- base::invokeRestart
[13:20:31.715]                       is.null <- base::is.null
[13:20:31.715]                       muffled <- FALSE
[13:20:31.715]                       if (inherits(cond, "message")) {
[13:20:31.715]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:31.715]                         if (muffled) 
[13:20:31.715]                           invokeRestart("muffleMessage")
[13:20:31.715]                       }
[13:20:31.715]                       else if (inherits(cond, "warning")) {
[13:20:31.715]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:31.715]                         if (muffled) 
[13:20:31.715]                           invokeRestart("muffleWarning")
[13:20:31.715]                       }
[13:20:31.715]                       else if (inherits(cond, "condition")) {
[13:20:31.715]                         if (!is.null(pattern)) {
[13:20:31.715]                           computeRestarts <- base::computeRestarts
[13:20:31.715]                           grepl <- base::grepl
[13:20:31.715]                           restarts <- computeRestarts(cond)
[13:20:31.715]                           for (restart in restarts) {
[13:20:31.715]                             name <- restart$name
[13:20:31.715]                             if (is.null(name)) 
[13:20:31.715]                               next
[13:20:31.715]                             if (!grepl(pattern, name)) 
[13:20:31.715]                               next
[13:20:31.715]                             invokeRestart(restart)
[13:20:31.715]                             muffled <- TRUE
[13:20:31.715]                             break
[13:20:31.715]                           }
[13:20:31.715]                         }
[13:20:31.715]                       }
[13:20:31.715]                       invisible(muffled)
[13:20:31.715]                     }
[13:20:31.715]                     muffleCondition(cond, pattern = "^muffle")
[13:20:31.715]                   }
[13:20:31.715]                 }
[13:20:31.715]             }
[13:20:31.715]         }))
[13:20:31.715]     }, error = function(ex) {
[13:20:31.715]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:31.715]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:31.715]                 ...future.rng), started = ...future.startTime, 
[13:20:31.715]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:31.715]             version = "1.8"), class = "FutureResult")
[13:20:31.715]     }, finally = {
[13:20:31.715]         if (!identical(...future.workdir, getwd())) 
[13:20:31.715]             setwd(...future.workdir)
[13:20:31.715]         {
[13:20:31.715]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:31.715]                 ...future.oldOptions$nwarnings <- NULL
[13:20:31.715]             }
[13:20:31.715]             base::options(...future.oldOptions)
[13:20:31.715]             if (.Platform$OS.type == "windows") {
[13:20:31.715]                 old_names <- names(...future.oldEnvVars)
[13:20:31.715]                 envs <- base::Sys.getenv()
[13:20:31.715]                 names <- names(envs)
[13:20:31.715]                 common <- intersect(names, old_names)
[13:20:31.715]                 added <- setdiff(names, old_names)
[13:20:31.715]                 removed <- setdiff(old_names, names)
[13:20:31.715]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:31.715]                   envs[common]]
[13:20:31.715]                 NAMES <- toupper(changed)
[13:20:31.715]                 args <- list()
[13:20:31.715]                 for (kk in seq_along(NAMES)) {
[13:20:31.715]                   name <- changed[[kk]]
[13:20:31.715]                   NAME <- NAMES[[kk]]
[13:20:31.715]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.715]                     next
[13:20:31.715]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:31.715]                 }
[13:20:31.715]                 NAMES <- toupper(added)
[13:20:31.715]                 for (kk in seq_along(NAMES)) {
[13:20:31.715]                   name <- added[[kk]]
[13:20:31.715]                   NAME <- NAMES[[kk]]
[13:20:31.715]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.715]                     next
[13:20:31.715]                   args[[name]] <- ""
[13:20:31.715]                 }
[13:20:31.715]                 NAMES <- toupper(removed)
[13:20:31.715]                 for (kk in seq_along(NAMES)) {
[13:20:31.715]                   name <- removed[[kk]]
[13:20:31.715]                   NAME <- NAMES[[kk]]
[13:20:31.715]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.715]                     next
[13:20:31.715]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:31.715]                 }
[13:20:31.715]                 if (length(args) > 0) 
[13:20:31.715]                   base::do.call(base::Sys.setenv, args = args)
[13:20:31.715]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:31.715]             }
[13:20:31.715]             else {
[13:20:31.715]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:31.715]             }
[13:20:31.715]             {
[13:20:31.715]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:31.715]                   0L) {
[13:20:31.715]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:31.715]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:31.715]                   base::options(opts)
[13:20:31.715]                 }
[13:20:31.715]                 {
[13:20:31.715]                   {
[13:20:31.715]                     NULL
[13:20:31.715]                     RNGkind("Mersenne-Twister")
[13:20:31.715]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:31.715]                       inherits = FALSE)
[13:20:31.715]                   }
[13:20:31.715]                   options(future.plan = NULL)
[13:20:31.715]                   if (is.na(NA_character_)) 
[13:20:31.715]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:31.715]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:31.715]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:31.715]                   {
[13:20:31.715]                     future <- SequentialFuture(..., envir = envir)
[13:20:31.715]                     if (!future$lazy) 
[13:20:31.715]                       future <- run(future)
[13:20:31.715]                     invisible(future)
[13:20:31.715]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:31.715]                 }
[13:20:31.715]             }
[13:20:31.715]         }
[13:20:31.715]     })
[13:20:31.715]     if (TRUE) {
[13:20:31.715]         base::sink(type = "output", split = FALSE)
[13:20:31.715]         if (TRUE) {
[13:20:31.715]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:31.715]         }
[13:20:31.715]         else {
[13:20:31.715]             ...future.result["stdout"] <- base::list(NULL)
[13:20:31.715]         }
[13:20:31.715]         base::close(...future.stdout)
[13:20:31.715]         ...future.stdout <- NULL
[13:20:31.715]     }
[13:20:31.715]     ...future.result$conditions <- ...future.conditions
[13:20:31.715]     ...future.result$finished <- base::Sys.time()
[13:20:31.715]     ...future.result
[13:20:31.715] }
[13:20:31.717] assign_globals() ...
[13:20:31.717] List of 1
[13:20:31.717]  $ x: num [1:5] 1 1 2 2 2
[13:20:31.717]  - attr(*, "where")=List of 1
[13:20:31.717]   ..$ x:<environment: R_EmptyEnv> 
[13:20:31.717]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:31.717]  - attr(*, "resolved")= logi FALSE
[13:20:31.717]  - attr(*, "total_size")= num 96
[13:20:31.717]  - attr(*, "already-done")= logi TRUE
[13:20:31.721] - copied ‘x’ to environment
[13:20:31.721] assign_globals() ... done
[13:20:31.722] plan(): Setting new future strategy stack:
[13:20:31.722] List of future strategies:
[13:20:31.722] 1. sequential:
[13:20:31.722]    - args: function (..., envir = parent.frame())
[13:20:31.722]    - tweaked: FALSE
[13:20:31.722]    - call: NULL
[13:20:31.722] plan(): nbrOfWorkers() = 1
[13:20:31.723] plan(): Setting new future strategy stack:
[13:20:31.723] List of future strategies:
[13:20:31.723] 1. sequential:
[13:20:31.723]    - args: function (..., envir = parent.frame())
[13:20:31.723]    - tweaked: FALSE
[13:20:31.723]    - call: plan(strategy)
[13:20:31.724] plan(): nbrOfWorkers() = 1
[13:20:31.724] SequentialFuture started (and completed)
[13:20:31.724] - Launch lazy future ... done
[13:20:31.724] run() for ‘SequentialFuture’ ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[13:20:31.726] getGlobalsAndPackages() ...
[13:20:31.726] Searching for globals...
[13:20:31.728] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[13:20:31.728] Searching for globals ... DONE
[13:20:31.728] Resolving globals: FALSE
[13:20:31.728] 
[13:20:31.729] - packages: [2] ‘stats’, ‘datasets’
[13:20:31.729] getGlobalsAndPackages() ... DONE
[13:20:31.729] run() for ‘Future’ ...
[13:20:31.729] - state: ‘created’
[13:20:31.729] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:31.729] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:31.730] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:31.730]   - Field: ‘label’
[13:20:31.730]   - Field: ‘local’
[13:20:31.730]   - Field: ‘owner’
[13:20:31.730]   - Field: ‘envir’
[13:20:31.730]   - Field: ‘packages’
[13:20:31.730]   - Field: ‘gc’
[13:20:31.730]   - Field: ‘conditions’
[13:20:31.730]   - Field: ‘expr’
[13:20:31.730]   - Field: ‘uuid’
[13:20:31.731]   - Field: ‘seed’
[13:20:31.731]   - Field: ‘version’
[13:20:31.731]   - Field: ‘result’
[13:20:31.731]   - Field: ‘asynchronous’
[13:20:31.731]   - Field: ‘calls’
[13:20:31.731]   - Field: ‘globals’
[13:20:31.731]   - Field: ‘stdout’
[13:20:31.731]   - Field: ‘earlySignal’
[13:20:31.731]   - Field: ‘lazy’
[13:20:31.731]   - Field: ‘state’
[13:20:31.731] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:31.732] - Launch lazy future ...
[13:20:31.732] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:20:31.732] Packages needed by future strategies (n = 0): <none>
[13:20:31.732] {
[13:20:31.732]     {
[13:20:31.732]         {
[13:20:31.732]             ...future.startTime <- base::Sys.time()
[13:20:31.732]             {
[13:20:31.732]                 {
[13:20:31.732]                   {
[13:20:31.732]                     {
[13:20:31.732]                       base::local({
[13:20:31.732]                         has_future <- base::requireNamespace("future", 
[13:20:31.732]                           quietly = TRUE)
[13:20:31.732]                         if (has_future) {
[13:20:31.732]                           ns <- base::getNamespace("future")
[13:20:31.732]                           version <- ns[[".package"]][["version"]]
[13:20:31.732]                           if (is.null(version)) 
[13:20:31.732]                             version <- utils::packageVersion("future")
[13:20:31.732]                         }
[13:20:31.732]                         else {
[13:20:31.732]                           version <- NULL
[13:20:31.732]                         }
[13:20:31.732]                         if (!has_future || version < "1.8.0") {
[13:20:31.732]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:31.732]                             "", base::R.version$version.string), 
[13:20:31.732]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:31.732]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:31.732]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:31.732]                               "release", "version")], collapse = " "), 
[13:20:31.732]                             hostname = base::Sys.info()[["nodename"]])
[13:20:31.732]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:31.732]                             info)
[13:20:31.732]                           info <- base::paste(info, collapse = "; ")
[13:20:31.732]                           if (!has_future) {
[13:20:31.732]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:31.732]                               info)
[13:20:31.732]                           }
[13:20:31.732]                           else {
[13:20:31.732]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:31.732]                               info, version)
[13:20:31.732]                           }
[13:20:31.732]                           base::stop(msg)
[13:20:31.732]                         }
[13:20:31.732]                       })
[13:20:31.732]                     }
[13:20:31.732]                     base::local({
[13:20:31.732]                       for (pkg in c("stats", "datasets")) {
[13:20:31.732]                         base::loadNamespace(pkg)
[13:20:31.732]                         base::library(pkg, character.only = TRUE)
[13:20:31.732]                       }
[13:20:31.732]                     })
[13:20:31.732]                   }
[13:20:31.732]                   options(future.plan = NULL)
[13:20:31.732]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:31.732]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:31.732]                 }
[13:20:31.732]                 ...future.workdir <- getwd()
[13:20:31.732]             }
[13:20:31.732]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:31.732]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:31.732]         }
[13:20:31.732]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:31.732]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:31.732]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:31.732]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:31.732]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:31.732]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:31.732]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:31.732]             base::names(...future.oldOptions))
[13:20:31.732]     }
[13:20:31.732]     if (FALSE) {
[13:20:31.732]     }
[13:20:31.732]     else {
[13:20:31.732]         if (TRUE) {
[13:20:31.732]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:31.732]                 open = "w")
[13:20:31.732]         }
[13:20:31.732]         else {
[13:20:31.732]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:31.732]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:31.732]         }
[13:20:31.732]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:31.732]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:31.732]             base::sink(type = "output", split = FALSE)
[13:20:31.732]             base::close(...future.stdout)
[13:20:31.732]         }, add = TRUE)
[13:20:31.732]     }
[13:20:31.732]     ...future.frame <- base::sys.nframe()
[13:20:31.732]     ...future.conditions <- base::list()
[13:20:31.732]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:31.732]     if (FALSE) {
[13:20:31.732]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:31.732]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:31.732]     }
[13:20:31.732]     ...future.result <- base::tryCatch({
[13:20:31.732]         base::withCallingHandlers({
[13:20:31.732]             ...future.value <- base::withVisible(base::local({
[13:20:31.732]                 lm(dist ~ . - 1, data = cars)
[13:20:31.732]             }))
[13:20:31.732]             future::FutureResult(value = ...future.value$value, 
[13:20:31.732]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:31.732]                   ...future.rng), globalenv = if (FALSE) 
[13:20:31.732]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:31.732]                     ...future.globalenv.names))
[13:20:31.732]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:31.732]         }, condition = base::local({
[13:20:31.732]             c <- base::c
[13:20:31.732]             inherits <- base::inherits
[13:20:31.732]             invokeRestart <- base::invokeRestart
[13:20:31.732]             length <- base::length
[13:20:31.732]             list <- base::list
[13:20:31.732]             seq.int <- base::seq.int
[13:20:31.732]             signalCondition <- base::signalCondition
[13:20:31.732]             sys.calls <- base::sys.calls
[13:20:31.732]             `[[` <- base::`[[`
[13:20:31.732]             `+` <- base::`+`
[13:20:31.732]             `<<-` <- base::`<<-`
[13:20:31.732]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:31.732]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:31.732]                   3L)]
[13:20:31.732]             }
[13:20:31.732]             function(cond) {
[13:20:31.732]                 is_error <- inherits(cond, "error")
[13:20:31.732]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:31.732]                   NULL)
[13:20:31.732]                 if (is_error) {
[13:20:31.732]                   sessionInformation <- function() {
[13:20:31.732]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:31.732]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:31.732]                       search = base::search(), system = base::Sys.info())
[13:20:31.732]                   }
[13:20:31.732]                   ...future.conditions[[length(...future.conditions) + 
[13:20:31.732]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:31.732]                     cond$call), session = sessionInformation(), 
[13:20:31.732]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:31.732]                   signalCondition(cond)
[13:20:31.732]                 }
[13:20:31.732]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:31.732]                 "immediateCondition"))) {
[13:20:31.732]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:31.732]                   ...future.conditions[[length(...future.conditions) + 
[13:20:31.732]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:31.732]                   if (TRUE && !signal) {
[13:20:31.732]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:31.732]                     {
[13:20:31.732]                       inherits <- base::inherits
[13:20:31.732]                       invokeRestart <- base::invokeRestart
[13:20:31.732]                       is.null <- base::is.null
[13:20:31.732]                       muffled <- FALSE
[13:20:31.732]                       if (inherits(cond, "message")) {
[13:20:31.732]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:31.732]                         if (muffled) 
[13:20:31.732]                           invokeRestart("muffleMessage")
[13:20:31.732]                       }
[13:20:31.732]                       else if (inherits(cond, "warning")) {
[13:20:31.732]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:31.732]                         if (muffled) 
[13:20:31.732]                           invokeRestart("muffleWarning")
[13:20:31.732]                       }
[13:20:31.732]                       else if (inherits(cond, "condition")) {
[13:20:31.732]                         if (!is.null(pattern)) {
[13:20:31.732]                           computeRestarts <- base::computeRestarts
[13:20:31.732]                           grepl <- base::grepl
[13:20:31.732]                           restarts <- computeRestarts(cond)
[13:20:31.732]                           for (restart in restarts) {
[13:20:31.732]                             name <- restart$name
[13:20:31.732]                             if (is.null(name)) 
[13:20:31.732]                               next
[13:20:31.732]                             if (!grepl(pattern, name)) 
[13:20:31.732]                               next
[13:20:31.732]                             invokeRestart(restart)
[13:20:31.732]                             muffled <- TRUE
[13:20:31.732]                             break
[13:20:31.732]                           }
[13:20:31.732]                         }
[13:20:31.732]                       }
[13:20:31.732]                       invisible(muffled)
[13:20:31.732]                     }
[13:20:31.732]                     muffleCondition(cond, pattern = "^muffle")
[13:20:31.732]                   }
[13:20:31.732]                 }
[13:20:31.732]                 else {
[13:20:31.732]                   if (TRUE) {
[13:20:31.732]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:31.732]                     {
[13:20:31.732]                       inherits <- base::inherits
[13:20:31.732]                       invokeRestart <- base::invokeRestart
[13:20:31.732]                       is.null <- base::is.null
[13:20:31.732]                       muffled <- FALSE
[13:20:31.732]                       if (inherits(cond, "message")) {
[13:20:31.732]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:31.732]                         if (muffled) 
[13:20:31.732]                           invokeRestart("muffleMessage")
[13:20:31.732]                       }
[13:20:31.732]                       else if (inherits(cond, "warning")) {
[13:20:31.732]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:31.732]                         if (muffled) 
[13:20:31.732]                           invokeRestart("muffleWarning")
[13:20:31.732]                       }
[13:20:31.732]                       else if (inherits(cond, "condition")) {
[13:20:31.732]                         if (!is.null(pattern)) {
[13:20:31.732]                           computeRestarts <- base::computeRestarts
[13:20:31.732]                           grepl <- base::grepl
[13:20:31.732]                           restarts <- computeRestarts(cond)
[13:20:31.732]                           for (restart in restarts) {
[13:20:31.732]                             name <- restart$name
[13:20:31.732]                             if (is.null(name)) 
[13:20:31.732]                               next
[13:20:31.732]                             if (!grepl(pattern, name)) 
[13:20:31.732]                               next
[13:20:31.732]                             invokeRestart(restart)
[13:20:31.732]                             muffled <- TRUE
[13:20:31.732]                             break
[13:20:31.732]                           }
[13:20:31.732]                         }
[13:20:31.732]                       }
[13:20:31.732]                       invisible(muffled)
[13:20:31.732]                     }
[13:20:31.732]                     muffleCondition(cond, pattern = "^muffle")
[13:20:31.732]                   }
[13:20:31.732]                 }
[13:20:31.732]             }
[13:20:31.732]         }))
[13:20:31.732]     }, error = function(ex) {
[13:20:31.732]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:31.732]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:31.732]                 ...future.rng), started = ...future.startTime, 
[13:20:31.732]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:31.732]             version = "1.8"), class = "FutureResult")
[13:20:31.732]     }, finally = {
[13:20:31.732]         if (!identical(...future.workdir, getwd())) 
[13:20:31.732]             setwd(...future.workdir)
[13:20:31.732]         {
[13:20:31.732]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:31.732]                 ...future.oldOptions$nwarnings <- NULL
[13:20:31.732]             }
[13:20:31.732]             base::options(...future.oldOptions)
[13:20:31.732]             if (.Platform$OS.type == "windows") {
[13:20:31.732]                 old_names <- names(...future.oldEnvVars)
[13:20:31.732]                 envs <- base::Sys.getenv()
[13:20:31.732]                 names <- names(envs)
[13:20:31.732]                 common <- intersect(names, old_names)
[13:20:31.732]                 added <- setdiff(names, old_names)
[13:20:31.732]                 removed <- setdiff(old_names, names)
[13:20:31.732]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:31.732]                   envs[common]]
[13:20:31.732]                 NAMES <- toupper(changed)
[13:20:31.732]                 args <- list()
[13:20:31.732]                 for (kk in seq_along(NAMES)) {
[13:20:31.732]                   name <- changed[[kk]]
[13:20:31.732]                   NAME <- NAMES[[kk]]
[13:20:31.732]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.732]                     next
[13:20:31.732]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:31.732]                 }
[13:20:31.732]                 NAMES <- toupper(added)
[13:20:31.732]                 for (kk in seq_along(NAMES)) {
[13:20:31.732]                   name <- added[[kk]]
[13:20:31.732]                   NAME <- NAMES[[kk]]
[13:20:31.732]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.732]                     next
[13:20:31.732]                   args[[name]] <- ""
[13:20:31.732]                 }
[13:20:31.732]                 NAMES <- toupper(removed)
[13:20:31.732]                 for (kk in seq_along(NAMES)) {
[13:20:31.732]                   name <- removed[[kk]]
[13:20:31.732]                   NAME <- NAMES[[kk]]
[13:20:31.732]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.732]                     next
[13:20:31.732]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:31.732]                 }
[13:20:31.732]                 if (length(args) > 0) 
[13:20:31.732]                   base::do.call(base::Sys.setenv, args = args)
[13:20:31.732]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:31.732]             }
[13:20:31.732]             else {
[13:20:31.732]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:31.732]             }
[13:20:31.732]             {
[13:20:31.732]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:31.732]                   0L) {
[13:20:31.732]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:31.732]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:31.732]                   base::options(opts)
[13:20:31.732]                 }
[13:20:31.732]                 {
[13:20:31.732]                   {
[13:20:31.732]                     NULL
[13:20:31.732]                     RNGkind("Mersenne-Twister")
[13:20:31.732]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:31.732]                       inherits = FALSE)
[13:20:31.732]                   }
[13:20:31.732]                   options(future.plan = NULL)
[13:20:31.732]                   if (is.na(NA_character_)) 
[13:20:31.732]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:31.732]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:31.732]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:31.732]                   {
[13:20:31.732]                     future <- SequentialFuture(..., envir = envir)
[13:20:31.732]                     if (!future$lazy) 
[13:20:31.732]                       future <- run(future)
[13:20:31.732]                     invisible(future)
[13:20:31.732]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:31.732]                 }
[13:20:31.732]             }
[13:20:31.732]         }
[13:20:31.732]     })
[13:20:31.732]     if (TRUE) {
[13:20:31.732]         base::sink(type = "output", split = FALSE)
[13:20:31.732]         if (TRUE) {
[13:20:31.732]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:31.732]         }
[13:20:31.732]         else {
[13:20:31.732]             ...future.result["stdout"] <- base::list(NULL)
[13:20:31.732]         }
[13:20:31.732]         base::close(...future.stdout)
[13:20:31.732]         ...future.stdout <- NULL
[13:20:31.732]     }
[13:20:31.732]     ...future.result$conditions <- ...future.conditions
[13:20:31.732]     ...future.result$finished <- base::Sys.time()
[13:20:31.732]     ...future.result
[13:20:31.732] }
[13:20:31.734] plan(): Setting new future strategy stack:
[13:20:31.735] List of future strategies:
[13:20:31.735] 1. sequential:
[13:20:31.735]    - args: function (..., envir = parent.frame())
[13:20:31.735]    - tweaked: FALSE
[13:20:31.735]    - call: NULL
[13:20:31.735] plan(): nbrOfWorkers() = 1
[13:20:31.736] plan(): Setting new future strategy stack:
[13:20:31.736] List of future strategies:
[13:20:31.736] 1. sequential:
[13:20:31.736]    - args: function (..., envir = parent.frame())
[13:20:31.736]    - tweaked: FALSE
[13:20:31.736]    - call: plan(strategy)
[13:20:31.737] plan(): nbrOfWorkers() = 1
[13:20:31.737] SequentialFuture started (and completed)
[13:20:31.737] - Launch lazy future ... done
[13:20:31.737] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[13:20:31.740] getGlobalsAndPackages() ...
[13:20:31.740] Searching for globals...
[13:20:31.741] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[13:20:31.741] Searching for globals ... DONE
[13:20:31.741] Resolving globals: FALSE
[13:20:31.742] 
[13:20:31.742] - packages: [2] ‘stats’, ‘datasets’
[13:20:31.742] getGlobalsAndPackages() ... DONE
[13:20:31.742] run() for ‘Future’ ...
[13:20:31.742] - state: ‘created’
[13:20:31.743] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:31.743] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:31.743] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:31.743]   - Field: ‘label’
[13:20:31.743]   - Field: ‘local’
[13:20:31.743]   - Field: ‘owner’
[13:20:31.743]   - Field: ‘envir’
[13:20:31.743]   - Field: ‘packages’
[13:20:31.745]   - Field: ‘gc’
[13:20:31.745]   - Field: ‘conditions’
[13:20:31.746]   - Field: ‘expr’
[13:20:31.746]   - Field: ‘uuid’
[13:20:31.746]   - Field: ‘seed’
[13:20:31.746]   - Field: ‘version’
[13:20:31.746]   - Field: ‘result’
[13:20:31.746]   - Field: ‘asynchronous’
[13:20:31.746]   - Field: ‘calls’
[13:20:31.746]   - Field: ‘globals’
[13:20:31.746]   - Field: ‘stdout’
[13:20:31.747]   - Field: ‘earlySignal’
[13:20:31.747]   - Field: ‘lazy’
[13:20:31.747]   - Field: ‘state’
[13:20:31.747] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:31.747] - Launch lazy future ...
[13:20:31.747] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:20:31.747] Packages needed by future strategies (n = 0): <none>
[13:20:31.748] {
[13:20:31.748]     {
[13:20:31.748]         {
[13:20:31.748]             ...future.startTime <- base::Sys.time()
[13:20:31.748]             {
[13:20:31.748]                 {
[13:20:31.748]                   {
[13:20:31.748]                     {
[13:20:31.748]                       base::local({
[13:20:31.748]                         has_future <- base::requireNamespace("future", 
[13:20:31.748]                           quietly = TRUE)
[13:20:31.748]                         if (has_future) {
[13:20:31.748]                           ns <- base::getNamespace("future")
[13:20:31.748]                           version <- ns[[".package"]][["version"]]
[13:20:31.748]                           if (is.null(version)) 
[13:20:31.748]                             version <- utils::packageVersion("future")
[13:20:31.748]                         }
[13:20:31.748]                         else {
[13:20:31.748]                           version <- NULL
[13:20:31.748]                         }
[13:20:31.748]                         if (!has_future || version < "1.8.0") {
[13:20:31.748]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:31.748]                             "", base::R.version$version.string), 
[13:20:31.748]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:31.748]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:31.748]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:31.748]                               "release", "version")], collapse = " "), 
[13:20:31.748]                             hostname = base::Sys.info()[["nodename"]])
[13:20:31.748]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:31.748]                             info)
[13:20:31.748]                           info <- base::paste(info, collapse = "; ")
[13:20:31.748]                           if (!has_future) {
[13:20:31.748]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:31.748]                               info)
[13:20:31.748]                           }
[13:20:31.748]                           else {
[13:20:31.748]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:31.748]                               info, version)
[13:20:31.748]                           }
[13:20:31.748]                           base::stop(msg)
[13:20:31.748]                         }
[13:20:31.748]                       })
[13:20:31.748]                     }
[13:20:31.748]                     base::local({
[13:20:31.748]                       for (pkg in c("stats", "datasets")) {
[13:20:31.748]                         base::loadNamespace(pkg)
[13:20:31.748]                         base::library(pkg, character.only = TRUE)
[13:20:31.748]                       }
[13:20:31.748]                     })
[13:20:31.748]                   }
[13:20:31.748]                   options(future.plan = NULL)
[13:20:31.748]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:31.748]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:31.748]                 }
[13:20:31.748]                 ...future.workdir <- getwd()
[13:20:31.748]             }
[13:20:31.748]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:31.748]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:31.748]         }
[13:20:31.748]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:31.748]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:31.748]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:31.748]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:31.748]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:31.748]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:31.748]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:31.748]             base::names(...future.oldOptions))
[13:20:31.748]     }
[13:20:31.748]     if (FALSE) {
[13:20:31.748]     }
[13:20:31.748]     else {
[13:20:31.748]         if (TRUE) {
[13:20:31.748]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:31.748]                 open = "w")
[13:20:31.748]         }
[13:20:31.748]         else {
[13:20:31.748]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:31.748]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:31.748]         }
[13:20:31.748]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:31.748]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:31.748]             base::sink(type = "output", split = FALSE)
[13:20:31.748]             base::close(...future.stdout)
[13:20:31.748]         }, add = TRUE)
[13:20:31.748]     }
[13:20:31.748]     ...future.frame <- base::sys.nframe()
[13:20:31.748]     ...future.conditions <- base::list()
[13:20:31.748]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:31.748]     if (FALSE) {
[13:20:31.748]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:31.748]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:31.748]     }
[13:20:31.748]     ...future.result <- base::tryCatch({
[13:20:31.748]         base::withCallingHandlers({
[13:20:31.748]             ...future.value <- base::withVisible(base::local({
[13:20:31.748]                 lm(dist ~ . + 0, data = cars)
[13:20:31.748]             }))
[13:20:31.748]             future::FutureResult(value = ...future.value$value, 
[13:20:31.748]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:31.748]                   ...future.rng), globalenv = if (FALSE) 
[13:20:31.748]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:31.748]                     ...future.globalenv.names))
[13:20:31.748]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:31.748]         }, condition = base::local({
[13:20:31.748]             c <- base::c
[13:20:31.748]             inherits <- base::inherits
[13:20:31.748]             invokeRestart <- base::invokeRestart
[13:20:31.748]             length <- base::length
[13:20:31.748]             list <- base::list
[13:20:31.748]             seq.int <- base::seq.int
[13:20:31.748]             signalCondition <- base::signalCondition
[13:20:31.748]             sys.calls <- base::sys.calls
[13:20:31.748]             `[[` <- base::`[[`
[13:20:31.748]             `+` <- base::`+`
[13:20:31.748]             `<<-` <- base::`<<-`
[13:20:31.748]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:31.748]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:31.748]                   3L)]
[13:20:31.748]             }
[13:20:31.748]             function(cond) {
[13:20:31.748]                 is_error <- inherits(cond, "error")
[13:20:31.748]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:31.748]                   NULL)
[13:20:31.748]                 if (is_error) {
[13:20:31.748]                   sessionInformation <- function() {
[13:20:31.748]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:31.748]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:31.748]                       search = base::search(), system = base::Sys.info())
[13:20:31.748]                   }
[13:20:31.748]                   ...future.conditions[[length(...future.conditions) + 
[13:20:31.748]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:31.748]                     cond$call), session = sessionInformation(), 
[13:20:31.748]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:31.748]                   signalCondition(cond)
[13:20:31.748]                 }
[13:20:31.748]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:31.748]                 "immediateCondition"))) {
[13:20:31.748]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:31.748]                   ...future.conditions[[length(...future.conditions) + 
[13:20:31.748]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:31.748]                   if (TRUE && !signal) {
[13:20:31.748]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:31.748]                     {
[13:20:31.748]                       inherits <- base::inherits
[13:20:31.748]                       invokeRestart <- base::invokeRestart
[13:20:31.748]                       is.null <- base::is.null
[13:20:31.748]                       muffled <- FALSE
[13:20:31.748]                       if (inherits(cond, "message")) {
[13:20:31.748]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:31.748]                         if (muffled) 
[13:20:31.748]                           invokeRestart("muffleMessage")
[13:20:31.748]                       }
[13:20:31.748]                       else if (inherits(cond, "warning")) {
[13:20:31.748]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:31.748]                         if (muffled) 
[13:20:31.748]                           invokeRestart("muffleWarning")
[13:20:31.748]                       }
[13:20:31.748]                       else if (inherits(cond, "condition")) {
[13:20:31.748]                         if (!is.null(pattern)) {
[13:20:31.748]                           computeRestarts <- base::computeRestarts
[13:20:31.748]                           grepl <- base::grepl
[13:20:31.748]                           restarts <- computeRestarts(cond)
[13:20:31.748]                           for (restart in restarts) {
[13:20:31.748]                             name <- restart$name
[13:20:31.748]                             if (is.null(name)) 
[13:20:31.748]                               next
[13:20:31.748]                             if (!grepl(pattern, name)) 
[13:20:31.748]                               next
[13:20:31.748]                             invokeRestart(restart)
[13:20:31.748]                             muffled <- TRUE
[13:20:31.748]                             break
[13:20:31.748]                           }
[13:20:31.748]                         }
[13:20:31.748]                       }
[13:20:31.748]                       invisible(muffled)
[13:20:31.748]                     }
[13:20:31.748]                     muffleCondition(cond, pattern = "^muffle")
[13:20:31.748]                   }
[13:20:31.748]                 }
[13:20:31.748]                 else {
[13:20:31.748]                   if (TRUE) {
[13:20:31.748]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:31.748]                     {
[13:20:31.748]                       inherits <- base::inherits
[13:20:31.748]                       invokeRestart <- base::invokeRestart
[13:20:31.748]                       is.null <- base::is.null
[13:20:31.748]                       muffled <- FALSE
[13:20:31.748]                       if (inherits(cond, "message")) {
[13:20:31.748]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:31.748]                         if (muffled) 
[13:20:31.748]                           invokeRestart("muffleMessage")
[13:20:31.748]                       }
[13:20:31.748]                       else if (inherits(cond, "warning")) {
[13:20:31.748]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:31.748]                         if (muffled) 
[13:20:31.748]                           invokeRestart("muffleWarning")
[13:20:31.748]                       }
[13:20:31.748]                       else if (inherits(cond, "condition")) {
[13:20:31.748]                         if (!is.null(pattern)) {
[13:20:31.748]                           computeRestarts <- base::computeRestarts
[13:20:31.748]                           grepl <- base::grepl
[13:20:31.748]                           restarts <- computeRestarts(cond)
[13:20:31.748]                           for (restart in restarts) {
[13:20:31.748]                             name <- restart$name
[13:20:31.748]                             if (is.null(name)) 
[13:20:31.748]                               next
[13:20:31.748]                             if (!grepl(pattern, name)) 
[13:20:31.748]                               next
[13:20:31.748]                             invokeRestart(restart)
[13:20:31.748]                             muffled <- TRUE
[13:20:31.748]                             break
[13:20:31.748]                           }
[13:20:31.748]                         }
[13:20:31.748]                       }
[13:20:31.748]                       invisible(muffled)
[13:20:31.748]                     }
[13:20:31.748]                     muffleCondition(cond, pattern = "^muffle")
[13:20:31.748]                   }
[13:20:31.748]                 }
[13:20:31.748]             }
[13:20:31.748]         }))
[13:20:31.748]     }, error = function(ex) {
[13:20:31.748]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:31.748]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:31.748]                 ...future.rng), started = ...future.startTime, 
[13:20:31.748]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:31.748]             version = "1.8"), class = "FutureResult")
[13:20:31.748]     }, finally = {
[13:20:31.748]         if (!identical(...future.workdir, getwd())) 
[13:20:31.748]             setwd(...future.workdir)
[13:20:31.748]         {
[13:20:31.748]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:31.748]                 ...future.oldOptions$nwarnings <- NULL
[13:20:31.748]             }
[13:20:31.748]             base::options(...future.oldOptions)
[13:20:31.748]             if (.Platform$OS.type == "windows") {
[13:20:31.748]                 old_names <- names(...future.oldEnvVars)
[13:20:31.748]                 envs <- base::Sys.getenv()
[13:20:31.748]                 names <- names(envs)
[13:20:31.748]                 common <- intersect(names, old_names)
[13:20:31.748]                 added <- setdiff(names, old_names)
[13:20:31.748]                 removed <- setdiff(old_names, names)
[13:20:31.748]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:31.748]                   envs[common]]
[13:20:31.748]                 NAMES <- toupper(changed)
[13:20:31.748]                 args <- list()
[13:20:31.748]                 for (kk in seq_along(NAMES)) {
[13:20:31.748]                   name <- changed[[kk]]
[13:20:31.748]                   NAME <- NAMES[[kk]]
[13:20:31.748]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.748]                     next
[13:20:31.748]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:31.748]                 }
[13:20:31.748]                 NAMES <- toupper(added)
[13:20:31.748]                 for (kk in seq_along(NAMES)) {
[13:20:31.748]                   name <- added[[kk]]
[13:20:31.748]                   NAME <- NAMES[[kk]]
[13:20:31.748]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.748]                     next
[13:20:31.748]                   args[[name]] <- ""
[13:20:31.748]                 }
[13:20:31.748]                 NAMES <- toupper(removed)
[13:20:31.748]                 for (kk in seq_along(NAMES)) {
[13:20:31.748]                   name <- removed[[kk]]
[13:20:31.748]                   NAME <- NAMES[[kk]]
[13:20:31.748]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.748]                     next
[13:20:31.748]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:31.748]                 }
[13:20:31.748]                 if (length(args) > 0) 
[13:20:31.748]                   base::do.call(base::Sys.setenv, args = args)
[13:20:31.748]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:31.748]             }
[13:20:31.748]             else {
[13:20:31.748]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:31.748]             }
[13:20:31.748]             {
[13:20:31.748]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:31.748]                   0L) {
[13:20:31.748]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:31.748]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:31.748]                   base::options(opts)
[13:20:31.748]                 }
[13:20:31.748]                 {
[13:20:31.748]                   {
[13:20:31.748]                     NULL
[13:20:31.748]                     RNGkind("Mersenne-Twister")
[13:20:31.748]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:31.748]                       inherits = FALSE)
[13:20:31.748]                   }
[13:20:31.748]                   options(future.plan = NULL)
[13:20:31.748]                   if (is.na(NA_character_)) 
[13:20:31.748]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:31.748]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:31.748]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:31.748]                   {
[13:20:31.748]                     future <- SequentialFuture(..., envir = envir)
[13:20:31.748]                     if (!future$lazy) 
[13:20:31.748]                       future <- run(future)
[13:20:31.748]                     invisible(future)
[13:20:31.748]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:31.748]                 }
[13:20:31.748]             }
[13:20:31.748]         }
[13:20:31.748]     })
[13:20:31.748]     if (TRUE) {
[13:20:31.748]         base::sink(type = "output", split = FALSE)
[13:20:31.748]         if (TRUE) {
[13:20:31.748]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:31.748]         }
[13:20:31.748]         else {
[13:20:31.748]             ...future.result["stdout"] <- base::list(NULL)
[13:20:31.748]         }
[13:20:31.748]         base::close(...future.stdout)
[13:20:31.748]         ...future.stdout <- NULL
[13:20:31.748]     }
[13:20:31.748]     ...future.result$conditions <- ...future.conditions
[13:20:31.748]     ...future.result$finished <- base::Sys.time()
[13:20:31.748]     ...future.result
[13:20:31.748] }
[13:20:31.750] plan(): Setting new future strategy stack:
[13:20:31.750] List of future strategies:
[13:20:31.750] 1. sequential:
[13:20:31.750]    - args: function (..., envir = parent.frame())
[13:20:31.750]    - tweaked: FALSE
[13:20:31.750]    - call: NULL
[13:20:31.750] plan(): nbrOfWorkers() = 1
[13:20:31.752] plan(): Setting new future strategy stack:
[13:20:31.752] List of future strategies:
[13:20:31.752] 1. sequential:
[13:20:31.752]    - args: function (..., envir = parent.frame())
[13:20:31.752]    - tweaked: FALSE
[13:20:31.752]    - call: plan(strategy)
[13:20:31.752] plan(): nbrOfWorkers() = 1
[13:20:31.752] SequentialFuture started (and completed)
[13:20:31.752] - Launch lazy future ... done
[13:20:31.752] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[13:20:31.755] getGlobalsAndPackages() ...
[13:20:31.755] Searching for globals...
[13:20:31.757] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[13:20:31.757] Searching for globals ... DONE
[13:20:31.757] Resolving globals: FALSE
[13:20:31.757] 
[13:20:31.757] - packages: [2] ‘stats’, ‘datasets’
[13:20:31.758] getGlobalsAndPackages() ... DONE
[13:20:31.758] run() for ‘Future’ ...
[13:20:31.758] - state: ‘created’
[13:20:31.758] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:31.758] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:31.758] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:31.759]   - Field: ‘label’
[13:20:31.759]   - Field: ‘local’
[13:20:31.759]   - Field: ‘owner’
[13:20:31.759]   - Field: ‘envir’
[13:20:31.759]   - Field: ‘packages’
[13:20:31.759]   - Field: ‘gc’
[13:20:31.759]   - Field: ‘conditions’
[13:20:31.759]   - Field: ‘expr’
[13:20:31.759]   - Field: ‘uuid’
[13:20:31.759]   - Field: ‘seed’
[13:20:31.759]   - Field: ‘version’
[13:20:31.760]   - Field: ‘result’
[13:20:31.760]   - Field: ‘asynchronous’
[13:20:31.760]   - Field: ‘calls’
[13:20:31.760]   - Field: ‘globals’
[13:20:31.760]   - Field: ‘stdout’
[13:20:31.760]   - Field: ‘earlySignal’
[13:20:31.760]   - Field: ‘lazy’
[13:20:31.760]   - Field: ‘state’
[13:20:31.760] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:31.760] - Launch lazy future ...
[13:20:31.761] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:20:31.761] Packages needed by future strategies (n = 0): <none>
[13:20:31.761] {
[13:20:31.761]     {
[13:20:31.761]         {
[13:20:31.761]             ...future.startTime <- base::Sys.time()
[13:20:31.761]             {
[13:20:31.761]                 {
[13:20:31.761]                   {
[13:20:31.761]                     {
[13:20:31.761]                       base::local({
[13:20:31.761]                         has_future <- base::requireNamespace("future", 
[13:20:31.761]                           quietly = TRUE)
[13:20:31.761]                         if (has_future) {
[13:20:31.761]                           ns <- base::getNamespace("future")
[13:20:31.761]                           version <- ns[[".package"]][["version"]]
[13:20:31.761]                           if (is.null(version)) 
[13:20:31.761]                             version <- utils::packageVersion("future")
[13:20:31.761]                         }
[13:20:31.761]                         else {
[13:20:31.761]                           version <- NULL
[13:20:31.761]                         }
[13:20:31.761]                         if (!has_future || version < "1.8.0") {
[13:20:31.761]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:31.761]                             "", base::R.version$version.string), 
[13:20:31.761]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:31.761]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:31.761]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:31.761]                               "release", "version")], collapse = " "), 
[13:20:31.761]                             hostname = base::Sys.info()[["nodename"]])
[13:20:31.761]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:31.761]                             info)
[13:20:31.761]                           info <- base::paste(info, collapse = "; ")
[13:20:31.761]                           if (!has_future) {
[13:20:31.761]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:31.761]                               info)
[13:20:31.761]                           }
[13:20:31.761]                           else {
[13:20:31.761]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:31.761]                               info, version)
[13:20:31.761]                           }
[13:20:31.761]                           base::stop(msg)
[13:20:31.761]                         }
[13:20:31.761]                       })
[13:20:31.761]                     }
[13:20:31.761]                     base::local({
[13:20:31.761]                       for (pkg in c("stats", "datasets")) {
[13:20:31.761]                         base::loadNamespace(pkg)
[13:20:31.761]                         base::library(pkg, character.only = TRUE)
[13:20:31.761]                       }
[13:20:31.761]                     })
[13:20:31.761]                   }
[13:20:31.761]                   options(future.plan = NULL)
[13:20:31.761]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:31.761]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:31.761]                 }
[13:20:31.761]                 ...future.workdir <- getwd()
[13:20:31.761]             }
[13:20:31.761]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:31.761]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:31.761]         }
[13:20:31.761]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:31.761]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:31.761]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:31.761]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:31.761]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:31.761]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:31.761]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:31.761]             base::names(...future.oldOptions))
[13:20:31.761]     }
[13:20:31.761]     if (FALSE) {
[13:20:31.761]     }
[13:20:31.761]     else {
[13:20:31.761]         if (TRUE) {
[13:20:31.761]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:31.761]                 open = "w")
[13:20:31.761]         }
[13:20:31.761]         else {
[13:20:31.761]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:31.761]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:31.761]         }
[13:20:31.761]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:31.761]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:31.761]             base::sink(type = "output", split = FALSE)
[13:20:31.761]             base::close(...future.stdout)
[13:20:31.761]         }, add = TRUE)
[13:20:31.761]     }
[13:20:31.761]     ...future.frame <- base::sys.nframe()
[13:20:31.761]     ...future.conditions <- base::list()
[13:20:31.761]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:31.761]     if (FALSE) {
[13:20:31.761]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:31.761]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:31.761]     }
[13:20:31.761]     ...future.result <- base::tryCatch({
[13:20:31.761]         base::withCallingHandlers({
[13:20:31.761]             ...future.value <- base::withVisible(base::local({
[13:20:31.761]                 lm(dist ~ speed + speed^2, data = cars)
[13:20:31.761]             }))
[13:20:31.761]             future::FutureResult(value = ...future.value$value, 
[13:20:31.761]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:31.761]                   ...future.rng), globalenv = if (FALSE) 
[13:20:31.761]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:31.761]                     ...future.globalenv.names))
[13:20:31.761]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:31.761]         }, condition = base::local({
[13:20:31.761]             c <- base::c
[13:20:31.761]             inherits <- base::inherits
[13:20:31.761]             invokeRestart <- base::invokeRestart
[13:20:31.761]             length <- base::length
[13:20:31.761]             list <- base::list
[13:20:31.761]             seq.int <- base::seq.int
[13:20:31.761]             signalCondition <- base::signalCondition
[13:20:31.761]             sys.calls <- base::sys.calls
[13:20:31.761]             `[[` <- base::`[[`
[13:20:31.761]             `+` <- base::`+`
[13:20:31.761]             `<<-` <- base::`<<-`
[13:20:31.761]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:31.761]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:31.761]                   3L)]
[13:20:31.761]             }
[13:20:31.761]             function(cond) {
[13:20:31.761]                 is_error <- inherits(cond, "error")
[13:20:31.761]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:31.761]                   NULL)
[13:20:31.761]                 if (is_error) {
[13:20:31.761]                   sessionInformation <- function() {
[13:20:31.761]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:31.761]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:31.761]                       search = base::search(), system = base::Sys.info())
[13:20:31.761]                   }
[13:20:31.761]                   ...future.conditions[[length(...future.conditions) + 
[13:20:31.761]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:31.761]                     cond$call), session = sessionInformation(), 
[13:20:31.761]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:31.761]                   signalCondition(cond)
[13:20:31.761]                 }
[13:20:31.761]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:31.761]                 "immediateCondition"))) {
[13:20:31.761]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:31.761]                   ...future.conditions[[length(...future.conditions) + 
[13:20:31.761]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:31.761]                   if (TRUE && !signal) {
[13:20:31.761]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:31.761]                     {
[13:20:31.761]                       inherits <- base::inherits
[13:20:31.761]                       invokeRestart <- base::invokeRestart
[13:20:31.761]                       is.null <- base::is.null
[13:20:31.761]                       muffled <- FALSE
[13:20:31.761]                       if (inherits(cond, "message")) {
[13:20:31.761]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:31.761]                         if (muffled) 
[13:20:31.761]                           invokeRestart("muffleMessage")
[13:20:31.761]                       }
[13:20:31.761]                       else if (inherits(cond, "warning")) {
[13:20:31.761]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:31.761]                         if (muffled) 
[13:20:31.761]                           invokeRestart("muffleWarning")
[13:20:31.761]                       }
[13:20:31.761]                       else if (inherits(cond, "condition")) {
[13:20:31.761]                         if (!is.null(pattern)) {
[13:20:31.761]                           computeRestarts <- base::computeRestarts
[13:20:31.761]                           grepl <- base::grepl
[13:20:31.761]                           restarts <- computeRestarts(cond)
[13:20:31.761]                           for (restart in restarts) {
[13:20:31.761]                             name <- restart$name
[13:20:31.761]                             if (is.null(name)) 
[13:20:31.761]                               next
[13:20:31.761]                             if (!grepl(pattern, name)) 
[13:20:31.761]                               next
[13:20:31.761]                             invokeRestart(restart)
[13:20:31.761]                             muffled <- TRUE
[13:20:31.761]                             break
[13:20:31.761]                           }
[13:20:31.761]                         }
[13:20:31.761]                       }
[13:20:31.761]                       invisible(muffled)
[13:20:31.761]                     }
[13:20:31.761]                     muffleCondition(cond, pattern = "^muffle")
[13:20:31.761]                   }
[13:20:31.761]                 }
[13:20:31.761]                 else {
[13:20:31.761]                   if (TRUE) {
[13:20:31.761]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:31.761]                     {
[13:20:31.761]                       inherits <- base::inherits
[13:20:31.761]                       invokeRestart <- base::invokeRestart
[13:20:31.761]                       is.null <- base::is.null
[13:20:31.761]                       muffled <- FALSE
[13:20:31.761]                       if (inherits(cond, "message")) {
[13:20:31.761]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:31.761]                         if (muffled) 
[13:20:31.761]                           invokeRestart("muffleMessage")
[13:20:31.761]                       }
[13:20:31.761]                       else if (inherits(cond, "warning")) {
[13:20:31.761]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:31.761]                         if (muffled) 
[13:20:31.761]                           invokeRestart("muffleWarning")
[13:20:31.761]                       }
[13:20:31.761]                       else if (inherits(cond, "condition")) {
[13:20:31.761]                         if (!is.null(pattern)) {
[13:20:31.761]                           computeRestarts <- base::computeRestarts
[13:20:31.761]                           grepl <- base::grepl
[13:20:31.761]                           restarts <- computeRestarts(cond)
[13:20:31.761]                           for (restart in restarts) {
[13:20:31.761]                             name <- restart$name
[13:20:31.761]                             if (is.null(name)) 
[13:20:31.761]                               next
[13:20:31.761]                             if (!grepl(pattern, name)) 
[13:20:31.761]                               next
[13:20:31.761]                             invokeRestart(restart)
[13:20:31.761]                             muffled <- TRUE
[13:20:31.761]                             break
[13:20:31.761]                           }
[13:20:31.761]                         }
[13:20:31.761]                       }
[13:20:31.761]                       invisible(muffled)
[13:20:31.761]                     }
[13:20:31.761]                     muffleCondition(cond, pattern = "^muffle")
[13:20:31.761]                   }
[13:20:31.761]                 }
[13:20:31.761]             }
[13:20:31.761]         }))
[13:20:31.761]     }, error = function(ex) {
[13:20:31.761]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:31.761]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:31.761]                 ...future.rng), started = ...future.startTime, 
[13:20:31.761]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:31.761]             version = "1.8"), class = "FutureResult")
[13:20:31.761]     }, finally = {
[13:20:31.761]         if (!identical(...future.workdir, getwd())) 
[13:20:31.761]             setwd(...future.workdir)
[13:20:31.761]         {
[13:20:31.761]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:31.761]                 ...future.oldOptions$nwarnings <- NULL
[13:20:31.761]             }
[13:20:31.761]             base::options(...future.oldOptions)
[13:20:31.761]             if (.Platform$OS.type == "windows") {
[13:20:31.761]                 old_names <- names(...future.oldEnvVars)
[13:20:31.761]                 envs <- base::Sys.getenv()
[13:20:31.761]                 names <- names(envs)
[13:20:31.761]                 common <- intersect(names, old_names)
[13:20:31.761]                 added <- setdiff(names, old_names)
[13:20:31.761]                 removed <- setdiff(old_names, names)
[13:20:31.761]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:31.761]                   envs[common]]
[13:20:31.761]                 NAMES <- toupper(changed)
[13:20:31.761]                 args <- list()
[13:20:31.761]                 for (kk in seq_along(NAMES)) {
[13:20:31.761]                   name <- changed[[kk]]
[13:20:31.761]                   NAME <- NAMES[[kk]]
[13:20:31.761]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.761]                     next
[13:20:31.761]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:31.761]                 }
[13:20:31.761]                 NAMES <- toupper(added)
[13:20:31.761]                 for (kk in seq_along(NAMES)) {
[13:20:31.761]                   name <- added[[kk]]
[13:20:31.761]                   NAME <- NAMES[[kk]]
[13:20:31.761]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.761]                     next
[13:20:31.761]                   args[[name]] <- ""
[13:20:31.761]                 }
[13:20:31.761]                 NAMES <- toupper(removed)
[13:20:31.761]                 for (kk in seq_along(NAMES)) {
[13:20:31.761]                   name <- removed[[kk]]
[13:20:31.761]                   NAME <- NAMES[[kk]]
[13:20:31.761]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.761]                     next
[13:20:31.761]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:31.761]                 }
[13:20:31.761]                 if (length(args) > 0) 
[13:20:31.761]                   base::do.call(base::Sys.setenv, args = args)
[13:20:31.761]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:31.761]             }
[13:20:31.761]             else {
[13:20:31.761]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:31.761]             }
[13:20:31.761]             {
[13:20:31.761]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:31.761]                   0L) {
[13:20:31.761]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:31.761]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:31.761]                   base::options(opts)
[13:20:31.761]                 }
[13:20:31.761]                 {
[13:20:31.761]                   {
[13:20:31.761]                     NULL
[13:20:31.761]                     RNGkind("Mersenne-Twister")
[13:20:31.761]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:31.761]                       inherits = FALSE)
[13:20:31.761]                   }
[13:20:31.761]                   options(future.plan = NULL)
[13:20:31.761]                   if (is.na(NA_character_)) 
[13:20:31.761]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:31.761]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:31.761]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:31.761]                   {
[13:20:31.761]                     future <- SequentialFuture(..., envir = envir)
[13:20:31.761]                     if (!future$lazy) 
[13:20:31.761]                       future <- run(future)
[13:20:31.761]                     invisible(future)
[13:20:31.761]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:31.761]                 }
[13:20:31.761]             }
[13:20:31.761]         }
[13:20:31.761]     })
[13:20:31.761]     if (TRUE) {
[13:20:31.761]         base::sink(type = "output", split = FALSE)
[13:20:31.761]         if (TRUE) {
[13:20:31.761]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:31.761]         }
[13:20:31.761]         else {
[13:20:31.761]             ...future.result["stdout"] <- base::list(NULL)
[13:20:31.761]         }
[13:20:31.761]         base::close(...future.stdout)
[13:20:31.761]         ...future.stdout <- NULL
[13:20:31.761]     }
[13:20:31.761]     ...future.result$conditions <- ...future.conditions
[13:20:31.761]     ...future.result$finished <- base::Sys.time()
[13:20:31.761]     ...future.result
[13:20:31.761] }
[13:20:31.763] plan(): Setting new future strategy stack:
[13:20:31.763] List of future strategies:
[13:20:31.763] 1. sequential:
[13:20:31.763]    - args: function (..., envir = parent.frame())
[13:20:31.763]    - tweaked: FALSE
[13:20:31.763]    - call: NULL
[13:20:31.764] plan(): nbrOfWorkers() = 1
[13:20:31.765] plan(): Setting new future strategy stack:
[13:20:31.765] List of future strategies:
[13:20:31.765] 1. sequential:
[13:20:31.765]    - args: function (..., envir = parent.frame())
[13:20:31.765]    - tweaked: FALSE
[13:20:31.765]    - call: plan(strategy)
[13:20:31.765] plan(): nbrOfWorkers() = 1
[13:20:31.766] SequentialFuture started (and completed)
[13:20:31.766] - Launch lazy future ... done
[13:20:31.766] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[13:20:31.768] getGlobalsAndPackages() ...
[13:20:31.768] Searching for globals...
[13:20:31.773] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[13:20:31.773] Searching for globals ... DONE
[13:20:31.773] Resolving globals: FALSE
[13:20:31.773] 
[13:20:31.773] - packages: [2] ‘stats’, ‘datasets’
[13:20:31.774] getGlobalsAndPackages() ... DONE
[13:20:31.774] run() for ‘Future’ ...
[13:20:31.774] - state: ‘created’
[13:20:31.774] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:31.774] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:31.775] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:31.775]   - Field: ‘label’
[13:20:31.775]   - Field: ‘local’
[13:20:31.775]   - Field: ‘owner’
[13:20:31.775]   - Field: ‘envir’
[13:20:31.775]   - Field: ‘packages’
[13:20:31.775]   - Field: ‘gc’
[13:20:31.775]   - Field: ‘conditions’
[13:20:31.775]   - Field: ‘expr’
[13:20:31.775]   - Field: ‘uuid’
[13:20:31.776]   - Field: ‘seed’
[13:20:31.776]   - Field: ‘version’
[13:20:31.776]   - Field: ‘result’
[13:20:31.776]   - Field: ‘asynchronous’
[13:20:31.776]   - Field: ‘calls’
[13:20:31.776]   - Field: ‘globals’
[13:20:31.776]   - Field: ‘stdout’
[13:20:31.776]   - Field: ‘earlySignal’
[13:20:31.776]   - Field: ‘lazy’
[13:20:31.776]   - Field: ‘state’
[13:20:31.776] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:31.777] - Launch lazy future ...
[13:20:31.777] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:20:31.777] Packages needed by future strategies (n = 0): <none>
[13:20:31.777] {
[13:20:31.777]     {
[13:20:31.777]         {
[13:20:31.777]             ...future.startTime <- base::Sys.time()
[13:20:31.777]             {
[13:20:31.777]                 {
[13:20:31.777]                   {
[13:20:31.777]                     {
[13:20:31.777]                       base::local({
[13:20:31.777]                         has_future <- base::requireNamespace("future", 
[13:20:31.777]                           quietly = TRUE)
[13:20:31.777]                         if (has_future) {
[13:20:31.777]                           ns <- base::getNamespace("future")
[13:20:31.777]                           version <- ns[[".package"]][["version"]]
[13:20:31.777]                           if (is.null(version)) 
[13:20:31.777]                             version <- utils::packageVersion("future")
[13:20:31.777]                         }
[13:20:31.777]                         else {
[13:20:31.777]                           version <- NULL
[13:20:31.777]                         }
[13:20:31.777]                         if (!has_future || version < "1.8.0") {
[13:20:31.777]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:31.777]                             "", base::R.version$version.string), 
[13:20:31.777]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:31.777]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:31.777]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:31.777]                               "release", "version")], collapse = " "), 
[13:20:31.777]                             hostname = base::Sys.info()[["nodename"]])
[13:20:31.777]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:31.777]                             info)
[13:20:31.777]                           info <- base::paste(info, collapse = "; ")
[13:20:31.777]                           if (!has_future) {
[13:20:31.777]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:31.777]                               info)
[13:20:31.777]                           }
[13:20:31.777]                           else {
[13:20:31.777]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:31.777]                               info, version)
[13:20:31.777]                           }
[13:20:31.777]                           base::stop(msg)
[13:20:31.777]                         }
[13:20:31.777]                       })
[13:20:31.777]                     }
[13:20:31.777]                     base::local({
[13:20:31.777]                       for (pkg in c("stats", "datasets")) {
[13:20:31.777]                         base::loadNamespace(pkg)
[13:20:31.777]                         base::library(pkg, character.only = TRUE)
[13:20:31.777]                       }
[13:20:31.777]                     })
[13:20:31.777]                   }
[13:20:31.777]                   options(future.plan = NULL)
[13:20:31.777]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:31.777]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:31.777]                 }
[13:20:31.777]                 ...future.workdir <- getwd()
[13:20:31.777]             }
[13:20:31.777]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:31.777]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:31.777]         }
[13:20:31.777]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:31.777]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:31.777]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:31.777]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:31.777]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:31.777]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:31.777]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:31.777]             base::names(...future.oldOptions))
[13:20:31.777]     }
[13:20:31.777]     if (FALSE) {
[13:20:31.777]     }
[13:20:31.777]     else {
[13:20:31.777]         if (TRUE) {
[13:20:31.777]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:31.777]                 open = "w")
[13:20:31.777]         }
[13:20:31.777]         else {
[13:20:31.777]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:31.777]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:31.777]         }
[13:20:31.777]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:31.777]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:31.777]             base::sink(type = "output", split = FALSE)
[13:20:31.777]             base::close(...future.stdout)
[13:20:31.777]         }, add = TRUE)
[13:20:31.777]     }
[13:20:31.777]     ...future.frame <- base::sys.nframe()
[13:20:31.777]     ...future.conditions <- base::list()
[13:20:31.777]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:31.777]     if (FALSE) {
[13:20:31.777]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:31.777]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:31.777]     }
[13:20:31.777]     ...future.result <- base::tryCatch({
[13:20:31.777]         base::withCallingHandlers({
[13:20:31.777]             ...future.value <- base::withVisible(base::local({
[13:20:31.777]                 lm(dist ~ speed + I(speed^2), data = cars)
[13:20:31.777]             }))
[13:20:31.777]             future::FutureResult(value = ...future.value$value, 
[13:20:31.777]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:31.777]                   ...future.rng), globalenv = if (FALSE) 
[13:20:31.777]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:31.777]                     ...future.globalenv.names))
[13:20:31.777]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:31.777]         }, condition = base::local({
[13:20:31.777]             c <- base::c
[13:20:31.777]             inherits <- base::inherits
[13:20:31.777]             invokeRestart <- base::invokeRestart
[13:20:31.777]             length <- base::length
[13:20:31.777]             list <- base::list
[13:20:31.777]             seq.int <- base::seq.int
[13:20:31.777]             signalCondition <- base::signalCondition
[13:20:31.777]             sys.calls <- base::sys.calls
[13:20:31.777]             `[[` <- base::`[[`
[13:20:31.777]             `+` <- base::`+`
[13:20:31.777]             `<<-` <- base::`<<-`
[13:20:31.777]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:31.777]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:31.777]                   3L)]
[13:20:31.777]             }
[13:20:31.777]             function(cond) {
[13:20:31.777]                 is_error <- inherits(cond, "error")
[13:20:31.777]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:31.777]                   NULL)
[13:20:31.777]                 if (is_error) {
[13:20:31.777]                   sessionInformation <- function() {
[13:20:31.777]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:31.777]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:31.777]                       search = base::search(), system = base::Sys.info())
[13:20:31.777]                   }
[13:20:31.777]                   ...future.conditions[[length(...future.conditions) + 
[13:20:31.777]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:31.777]                     cond$call), session = sessionInformation(), 
[13:20:31.777]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:31.777]                   signalCondition(cond)
[13:20:31.777]                 }
[13:20:31.777]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:31.777]                 "immediateCondition"))) {
[13:20:31.777]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:31.777]                   ...future.conditions[[length(...future.conditions) + 
[13:20:31.777]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:31.777]                   if (TRUE && !signal) {
[13:20:31.777]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:31.777]                     {
[13:20:31.777]                       inherits <- base::inherits
[13:20:31.777]                       invokeRestart <- base::invokeRestart
[13:20:31.777]                       is.null <- base::is.null
[13:20:31.777]                       muffled <- FALSE
[13:20:31.777]                       if (inherits(cond, "message")) {
[13:20:31.777]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:31.777]                         if (muffled) 
[13:20:31.777]                           invokeRestart("muffleMessage")
[13:20:31.777]                       }
[13:20:31.777]                       else if (inherits(cond, "warning")) {
[13:20:31.777]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:31.777]                         if (muffled) 
[13:20:31.777]                           invokeRestart("muffleWarning")
[13:20:31.777]                       }
[13:20:31.777]                       else if (inherits(cond, "condition")) {
[13:20:31.777]                         if (!is.null(pattern)) {
[13:20:31.777]                           computeRestarts <- base::computeRestarts
[13:20:31.777]                           grepl <- base::grepl
[13:20:31.777]                           restarts <- computeRestarts(cond)
[13:20:31.777]                           for (restart in restarts) {
[13:20:31.777]                             name <- restart$name
[13:20:31.777]                             if (is.null(name)) 
[13:20:31.777]                               next
[13:20:31.777]                             if (!grepl(pattern, name)) 
[13:20:31.777]                               next
[13:20:31.777]                             invokeRestart(restart)
[13:20:31.777]                             muffled <- TRUE
[13:20:31.777]                             break
[13:20:31.777]                           }
[13:20:31.777]                         }
[13:20:31.777]                       }
[13:20:31.777]                       invisible(muffled)
[13:20:31.777]                     }
[13:20:31.777]                     muffleCondition(cond, pattern = "^muffle")
[13:20:31.777]                   }
[13:20:31.777]                 }
[13:20:31.777]                 else {
[13:20:31.777]                   if (TRUE) {
[13:20:31.777]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:31.777]                     {
[13:20:31.777]                       inherits <- base::inherits
[13:20:31.777]                       invokeRestart <- base::invokeRestart
[13:20:31.777]                       is.null <- base::is.null
[13:20:31.777]                       muffled <- FALSE
[13:20:31.777]                       if (inherits(cond, "message")) {
[13:20:31.777]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:31.777]                         if (muffled) 
[13:20:31.777]                           invokeRestart("muffleMessage")
[13:20:31.777]                       }
[13:20:31.777]                       else if (inherits(cond, "warning")) {
[13:20:31.777]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:31.777]                         if (muffled) 
[13:20:31.777]                           invokeRestart("muffleWarning")
[13:20:31.777]                       }
[13:20:31.777]                       else if (inherits(cond, "condition")) {
[13:20:31.777]                         if (!is.null(pattern)) {
[13:20:31.777]                           computeRestarts <- base::computeRestarts
[13:20:31.777]                           grepl <- base::grepl
[13:20:31.777]                           restarts <- computeRestarts(cond)
[13:20:31.777]                           for (restart in restarts) {
[13:20:31.777]                             name <- restart$name
[13:20:31.777]                             if (is.null(name)) 
[13:20:31.777]                               next
[13:20:31.777]                             if (!grepl(pattern, name)) 
[13:20:31.777]                               next
[13:20:31.777]                             invokeRestart(restart)
[13:20:31.777]                             muffled <- TRUE
[13:20:31.777]                             break
[13:20:31.777]                           }
[13:20:31.777]                         }
[13:20:31.777]                       }
[13:20:31.777]                       invisible(muffled)
[13:20:31.777]                     }
[13:20:31.777]                     muffleCondition(cond, pattern = "^muffle")
[13:20:31.777]                   }
[13:20:31.777]                 }
[13:20:31.777]             }
[13:20:31.777]         }))
[13:20:31.777]     }, error = function(ex) {
[13:20:31.777]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:31.777]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:31.777]                 ...future.rng), started = ...future.startTime, 
[13:20:31.777]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:31.777]             version = "1.8"), class = "FutureResult")
[13:20:31.777]     }, finally = {
[13:20:31.777]         if (!identical(...future.workdir, getwd())) 
[13:20:31.777]             setwd(...future.workdir)
[13:20:31.777]         {
[13:20:31.777]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:31.777]                 ...future.oldOptions$nwarnings <- NULL
[13:20:31.777]             }
[13:20:31.777]             base::options(...future.oldOptions)
[13:20:31.777]             if (.Platform$OS.type == "windows") {
[13:20:31.777]                 old_names <- names(...future.oldEnvVars)
[13:20:31.777]                 envs <- base::Sys.getenv()
[13:20:31.777]                 names <- names(envs)
[13:20:31.777]                 common <- intersect(names, old_names)
[13:20:31.777]                 added <- setdiff(names, old_names)
[13:20:31.777]                 removed <- setdiff(old_names, names)
[13:20:31.777]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:31.777]                   envs[common]]
[13:20:31.777]                 NAMES <- toupper(changed)
[13:20:31.777]                 args <- list()
[13:20:31.777]                 for (kk in seq_along(NAMES)) {
[13:20:31.777]                   name <- changed[[kk]]
[13:20:31.777]                   NAME <- NAMES[[kk]]
[13:20:31.777]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.777]                     next
[13:20:31.777]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:31.777]                 }
[13:20:31.777]                 NAMES <- toupper(added)
[13:20:31.777]                 for (kk in seq_along(NAMES)) {
[13:20:31.777]                   name <- added[[kk]]
[13:20:31.777]                   NAME <- NAMES[[kk]]
[13:20:31.777]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.777]                     next
[13:20:31.777]                   args[[name]] <- ""
[13:20:31.777]                 }
[13:20:31.777]                 NAMES <- toupper(removed)
[13:20:31.777]                 for (kk in seq_along(NAMES)) {
[13:20:31.777]                   name <- removed[[kk]]
[13:20:31.777]                   NAME <- NAMES[[kk]]
[13:20:31.777]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.777]                     next
[13:20:31.777]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:31.777]                 }
[13:20:31.777]                 if (length(args) > 0) 
[13:20:31.777]                   base::do.call(base::Sys.setenv, args = args)
[13:20:31.777]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:31.777]             }
[13:20:31.777]             else {
[13:20:31.777]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:31.777]             }
[13:20:31.777]             {
[13:20:31.777]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:31.777]                   0L) {
[13:20:31.777]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:31.777]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:31.777]                   base::options(opts)
[13:20:31.777]                 }
[13:20:31.777]                 {
[13:20:31.777]                   {
[13:20:31.777]                     NULL
[13:20:31.777]                     RNGkind("Mersenne-Twister")
[13:20:31.777]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:31.777]                       inherits = FALSE)
[13:20:31.777]                   }
[13:20:31.777]                   options(future.plan = NULL)
[13:20:31.777]                   if (is.na(NA_character_)) 
[13:20:31.777]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:31.777]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:31.777]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:31.777]                   {
[13:20:31.777]                     future <- SequentialFuture(..., envir = envir)
[13:20:31.777]                     if (!future$lazy) 
[13:20:31.777]                       future <- run(future)
[13:20:31.777]                     invisible(future)
[13:20:31.777]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:31.777]                 }
[13:20:31.777]             }
[13:20:31.777]         }
[13:20:31.777]     })
[13:20:31.777]     if (TRUE) {
[13:20:31.777]         base::sink(type = "output", split = FALSE)
[13:20:31.777]         if (TRUE) {
[13:20:31.777]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:31.777]         }
[13:20:31.777]         else {
[13:20:31.777]             ...future.result["stdout"] <- base::list(NULL)
[13:20:31.777]         }
[13:20:31.777]         base::close(...future.stdout)
[13:20:31.777]         ...future.stdout <- NULL
[13:20:31.777]     }
[13:20:31.777]     ...future.result$conditions <- ...future.conditions
[13:20:31.777]     ...future.result$finished <- base::Sys.time()
[13:20:31.777]     ...future.result
[13:20:31.777] }
[13:20:31.780] plan(): Setting new future strategy stack:
[13:20:31.780] List of future strategies:
[13:20:31.780] 1. sequential:
[13:20:31.780]    - args: function (..., envir = parent.frame())
[13:20:31.780]    - tweaked: FALSE
[13:20:31.780]    - call: NULL
[13:20:31.780] plan(): nbrOfWorkers() = 1
[13:20:31.782] plan(): Setting new future strategy stack:
[13:20:31.782] List of future strategies:
[13:20:31.782] 1. sequential:
[13:20:31.782]    - args: function (..., envir = parent.frame())
[13:20:31.782]    - tweaked: FALSE
[13:20:31.782]    - call: plan(strategy)
[13:20:31.782] plan(): nbrOfWorkers() = 1
[13:20:31.782] SequentialFuture started (and completed)
[13:20:31.782] - Launch lazy future ... done
[13:20:31.782] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[13:20:31.786] getGlobalsAndPackages() ...
[13:20:31.786] Searching for globals...
[13:20:31.788] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[13:20:31.788] Searching for globals ... DONE
[13:20:31.788] Resolving globals: FALSE
[13:20:31.789] 
[13:20:31.789] - packages: [2] ‘stats’, ‘datasets’
[13:20:31.789] getGlobalsAndPackages() ... DONE
[13:20:31.789] run() for ‘Future’ ...
[13:20:31.789] - state: ‘created’
[13:20:31.789] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:31.790] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:31.790] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:31.790]   - Field: ‘label’
[13:20:31.790]   - Field: ‘local’
[13:20:31.790]   - Field: ‘owner’
[13:20:31.790]   - Field: ‘envir’
[13:20:31.790]   - Field: ‘packages’
[13:20:31.790]   - Field: ‘gc’
[13:20:31.790]   - Field: ‘conditions’
[13:20:31.790]   - Field: ‘expr’
[13:20:31.791]   - Field: ‘uuid’
[13:20:31.791]   - Field: ‘seed’
[13:20:31.791]   - Field: ‘version’
[13:20:31.791]   - Field: ‘result’
[13:20:31.791]   - Field: ‘asynchronous’
[13:20:31.791]   - Field: ‘calls’
[13:20:31.791]   - Field: ‘globals’
[13:20:31.791]   - Field: ‘stdout’
[13:20:31.791]   - Field: ‘earlySignal’
[13:20:31.791]   - Field: ‘lazy’
[13:20:31.791]   - Field: ‘state’
[13:20:31.792] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:31.792] - Launch lazy future ...
[13:20:31.792] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:20:31.792] Packages needed by future strategies (n = 0): <none>
[13:20:31.793] {
[13:20:31.793]     {
[13:20:31.793]         {
[13:20:31.793]             ...future.startTime <- base::Sys.time()
[13:20:31.793]             {
[13:20:31.793]                 {
[13:20:31.793]                   {
[13:20:31.793]                     {
[13:20:31.793]                       base::local({
[13:20:31.793]                         has_future <- base::requireNamespace("future", 
[13:20:31.793]                           quietly = TRUE)
[13:20:31.793]                         if (has_future) {
[13:20:31.793]                           ns <- base::getNamespace("future")
[13:20:31.793]                           version <- ns[[".package"]][["version"]]
[13:20:31.793]                           if (is.null(version)) 
[13:20:31.793]                             version <- utils::packageVersion("future")
[13:20:31.793]                         }
[13:20:31.793]                         else {
[13:20:31.793]                           version <- NULL
[13:20:31.793]                         }
[13:20:31.793]                         if (!has_future || version < "1.8.0") {
[13:20:31.793]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:31.793]                             "", base::R.version$version.string), 
[13:20:31.793]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:31.793]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:31.793]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:31.793]                               "release", "version")], collapse = " "), 
[13:20:31.793]                             hostname = base::Sys.info()[["nodename"]])
[13:20:31.793]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:31.793]                             info)
[13:20:31.793]                           info <- base::paste(info, collapse = "; ")
[13:20:31.793]                           if (!has_future) {
[13:20:31.793]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:31.793]                               info)
[13:20:31.793]                           }
[13:20:31.793]                           else {
[13:20:31.793]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:31.793]                               info, version)
[13:20:31.793]                           }
[13:20:31.793]                           base::stop(msg)
[13:20:31.793]                         }
[13:20:31.793]                       })
[13:20:31.793]                     }
[13:20:31.793]                     base::local({
[13:20:31.793]                       for (pkg in c("stats", "datasets")) {
[13:20:31.793]                         base::loadNamespace(pkg)
[13:20:31.793]                         base::library(pkg, character.only = TRUE)
[13:20:31.793]                       }
[13:20:31.793]                     })
[13:20:31.793]                   }
[13:20:31.793]                   options(future.plan = NULL)
[13:20:31.793]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:31.793]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:31.793]                 }
[13:20:31.793]                 ...future.workdir <- getwd()
[13:20:31.793]             }
[13:20:31.793]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:31.793]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:31.793]         }
[13:20:31.793]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:31.793]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:31.793]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:31.793]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:31.793]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:31.793]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:31.793]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:31.793]             base::names(...future.oldOptions))
[13:20:31.793]     }
[13:20:31.793]     if (FALSE) {
[13:20:31.793]     }
[13:20:31.793]     else {
[13:20:31.793]         if (TRUE) {
[13:20:31.793]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:31.793]                 open = "w")
[13:20:31.793]         }
[13:20:31.793]         else {
[13:20:31.793]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:31.793]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:31.793]         }
[13:20:31.793]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:31.793]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:31.793]             base::sink(type = "output", split = FALSE)
[13:20:31.793]             base::close(...future.stdout)
[13:20:31.793]         }, add = TRUE)
[13:20:31.793]     }
[13:20:31.793]     ...future.frame <- base::sys.nframe()
[13:20:31.793]     ...future.conditions <- base::list()
[13:20:31.793]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:31.793]     if (FALSE) {
[13:20:31.793]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:31.793]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:31.793]     }
[13:20:31.793]     ...future.result <- base::tryCatch({
[13:20:31.793]         base::withCallingHandlers({
[13:20:31.793]             ...future.value <- base::withVisible(base::local({
[13:20:31.793]                 lm(dist ~ poly(speed, 2), data = cars)
[13:20:31.793]             }))
[13:20:31.793]             future::FutureResult(value = ...future.value$value, 
[13:20:31.793]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:31.793]                   ...future.rng), globalenv = if (FALSE) 
[13:20:31.793]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:31.793]                     ...future.globalenv.names))
[13:20:31.793]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:31.793]         }, condition = base::local({
[13:20:31.793]             c <- base::c
[13:20:31.793]             inherits <- base::inherits
[13:20:31.793]             invokeRestart <- base::invokeRestart
[13:20:31.793]             length <- base::length
[13:20:31.793]             list <- base::list
[13:20:31.793]             seq.int <- base::seq.int
[13:20:31.793]             signalCondition <- base::signalCondition
[13:20:31.793]             sys.calls <- base::sys.calls
[13:20:31.793]             `[[` <- base::`[[`
[13:20:31.793]             `+` <- base::`+`
[13:20:31.793]             `<<-` <- base::`<<-`
[13:20:31.793]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:31.793]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:31.793]                   3L)]
[13:20:31.793]             }
[13:20:31.793]             function(cond) {
[13:20:31.793]                 is_error <- inherits(cond, "error")
[13:20:31.793]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:31.793]                   NULL)
[13:20:31.793]                 if (is_error) {
[13:20:31.793]                   sessionInformation <- function() {
[13:20:31.793]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:31.793]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:31.793]                       search = base::search(), system = base::Sys.info())
[13:20:31.793]                   }
[13:20:31.793]                   ...future.conditions[[length(...future.conditions) + 
[13:20:31.793]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:31.793]                     cond$call), session = sessionInformation(), 
[13:20:31.793]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:31.793]                   signalCondition(cond)
[13:20:31.793]                 }
[13:20:31.793]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:31.793]                 "immediateCondition"))) {
[13:20:31.793]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:31.793]                   ...future.conditions[[length(...future.conditions) + 
[13:20:31.793]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:31.793]                   if (TRUE && !signal) {
[13:20:31.793]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:31.793]                     {
[13:20:31.793]                       inherits <- base::inherits
[13:20:31.793]                       invokeRestart <- base::invokeRestart
[13:20:31.793]                       is.null <- base::is.null
[13:20:31.793]                       muffled <- FALSE
[13:20:31.793]                       if (inherits(cond, "message")) {
[13:20:31.793]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:31.793]                         if (muffled) 
[13:20:31.793]                           invokeRestart("muffleMessage")
[13:20:31.793]                       }
[13:20:31.793]                       else if (inherits(cond, "warning")) {
[13:20:31.793]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:31.793]                         if (muffled) 
[13:20:31.793]                           invokeRestart("muffleWarning")
[13:20:31.793]                       }
[13:20:31.793]                       else if (inherits(cond, "condition")) {
[13:20:31.793]                         if (!is.null(pattern)) {
[13:20:31.793]                           computeRestarts <- base::computeRestarts
[13:20:31.793]                           grepl <- base::grepl
[13:20:31.793]                           restarts <- computeRestarts(cond)
[13:20:31.793]                           for (restart in restarts) {
[13:20:31.793]                             name <- restart$name
[13:20:31.793]                             if (is.null(name)) 
[13:20:31.793]                               next
[13:20:31.793]                             if (!grepl(pattern, name)) 
[13:20:31.793]                               next
[13:20:31.793]                             invokeRestart(restart)
[13:20:31.793]                             muffled <- TRUE
[13:20:31.793]                             break
[13:20:31.793]                           }
[13:20:31.793]                         }
[13:20:31.793]                       }
[13:20:31.793]                       invisible(muffled)
[13:20:31.793]                     }
[13:20:31.793]                     muffleCondition(cond, pattern = "^muffle")
[13:20:31.793]                   }
[13:20:31.793]                 }
[13:20:31.793]                 else {
[13:20:31.793]                   if (TRUE) {
[13:20:31.793]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:31.793]                     {
[13:20:31.793]                       inherits <- base::inherits
[13:20:31.793]                       invokeRestart <- base::invokeRestart
[13:20:31.793]                       is.null <- base::is.null
[13:20:31.793]                       muffled <- FALSE
[13:20:31.793]                       if (inherits(cond, "message")) {
[13:20:31.793]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:31.793]                         if (muffled) 
[13:20:31.793]                           invokeRestart("muffleMessage")
[13:20:31.793]                       }
[13:20:31.793]                       else if (inherits(cond, "warning")) {
[13:20:31.793]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:31.793]                         if (muffled) 
[13:20:31.793]                           invokeRestart("muffleWarning")
[13:20:31.793]                       }
[13:20:31.793]                       else if (inherits(cond, "condition")) {
[13:20:31.793]                         if (!is.null(pattern)) {
[13:20:31.793]                           computeRestarts <- base::computeRestarts
[13:20:31.793]                           grepl <- base::grepl
[13:20:31.793]                           restarts <- computeRestarts(cond)
[13:20:31.793]                           for (restart in restarts) {
[13:20:31.793]                             name <- restart$name
[13:20:31.793]                             if (is.null(name)) 
[13:20:31.793]                               next
[13:20:31.793]                             if (!grepl(pattern, name)) 
[13:20:31.793]                               next
[13:20:31.793]                             invokeRestart(restart)
[13:20:31.793]                             muffled <- TRUE
[13:20:31.793]                             break
[13:20:31.793]                           }
[13:20:31.793]                         }
[13:20:31.793]                       }
[13:20:31.793]                       invisible(muffled)
[13:20:31.793]                     }
[13:20:31.793]                     muffleCondition(cond, pattern = "^muffle")
[13:20:31.793]                   }
[13:20:31.793]                 }
[13:20:31.793]             }
[13:20:31.793]         }))
[13:20:31.793]     }, error = function(ex) {
[13:20:31.793]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:31.793]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:31.793]                 ...future.rng), started = ...future.startTime, 
[13:20:31.793]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:31.793]             version = "1.8"), class = "FutureResult")
[13:20:31.793]     }, finally = {
[13:20:31.793]         if (!identical(...future.workdir, getwd())) 
[13:20:31.793]             setwd(...future.workdir)
[13:20:31.793]         {
[13:20:31.793]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:31.793]                 ...future.oldOptions$nwarnings <- NULL
[13:20:31.793]             }
[13:20:31.793]             base::options(...future.oldOptions)
[13:20:31.793]             if (.Platform$OS.type == "windows") {
[13:20:31.793]                 old_names <- names(...future.oldEnvVars)
[13:20:31.793]                 envs <- base::Sys.getenv()
[13:20:31.793]                 names <- names(envs)
[13:20:31.793]                 common <- intersect(names, old_names)
[13:20:31.793]                 added <- setdiff(names, old_names)
[13:20:31.793]                 removed <- setdiff(old_names, names)
[13:20:31.793]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:31.793]                   envs[common]]
[13:20:31.793]                 NAMES <- toupper(changed)
[13:20:31.793]                 args <- list()
[13:20:31.793]                 for (kk in seq_along(NAMES)) {
[13:20:31.793]                   name <- changed[[kk]]
[13:20:31.793]                   NAME <- NAMES[[kk]]
[13:20:31.793]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.793]                     next
[13:20:31.793]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:31.793]                 }
[13:20:31.793]                 NAMES <- toupper(added)
[13:20:31.793]                 for (kk in seq_along(NAMES)) {
[13:20:31.793]                   name <- added[[kk]]
[13:20:31.793]                   NAME <- NAMES[[kk]]
[13:20:31.793]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.793]                     next
[13:20:31.793]                   args[[name]] <- ""
[13:20:31.793]                 }
[13:20:31.793]                 NAMES <- toupper(removed)
[13:20:31.793]                 for (kk in seq_along(NAMES)) {
[13:20:31.793]                   name <- removed[[kk]]
[13:20:31.793]                   NAME <- NAMES[[kk]]
[13:20:31.793]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.793]                     next
[13:20:31.793]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:31.793]                 }
[13:20:31.793]                 if (length(args) > 0) 
[13:20:31.793]                   base::do.call(base::Sys.setenv, args = args)
[13:20:31.793]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:31.793]             }
[13:20:31.793]             else {
[13:20:31.793]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:31.793]             }
[13:20:31.793]             {
[13:20:31.793]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:31.793]                   0L) {
[13:20:31.793]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:31.793]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:31.793]                   base::options(opts)
[13:20:31.793]                 }
[13:20:31.793]                 {
[13:20:31.793]                   {
[13:20:31.793]                     NULL
[13:20:31.793]                     RNGkind("Mersenne-Twister")
[13:20:31.793]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:31.793]                       inherits = FALSE)
[13:20:31.793]                   }
[13:20:31.793]                   options(future.plan = NULL)
[13:20:31.793]                   if (is.na(NA_character_)) 
[13:20:31.793]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:31.793]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:31.793]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:31.793]                   {
[13:20:31.793]                     future <- SequentialFuture(..., envir = envir)
[13:20:31.793]                     if (!future$lazy) 
[13:20:31.793]                       future <- run(future)
[13:20:31.793]                     invisible(future)
[13:20:31.793]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:31.793]                 }
[13:20:31.793]             }
[13:20:31.793]         }
[13:20:31.793]     })
[13:20:31.793]     if (TRUE) {
[13:20:31.793]         base::sink(type = "output", split = FALSE)
[13:20:31.793]         if (TRUE) {
[13:20:31.793]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:31.793]         }
[13:20:31.793]         else {
[13:20:31.793]             ...future.result["stdout"] <- base::list(NULL)
[13:20:31.793]         }
[13:20:31.793]         base::close(...future.stdout)
[13:20:31.793]         ...future.stdout <- NULL
[13:20:31.793]     }
[13:20:31.793]     ...future.result$conditions <- ...future.conditions
[13:20:31.793]     ...future.result$finished <- base::Sys.time()
[13:20:31.793]     ...future.result
[13:20:31.793] }
[13:20:31.795] plan(): Setting new future strategy stack:
[13:20:31.795] List of future strategies:
[13:20:31.795] 1. sequential:
[13:20:31.795]    - args: function (..., envir = parent.frame())
[13:20:31.795]    - tweaked: FALSE
[13:20:31.795]    - call: NULL
[13:20:31.795] plan(): nbrOfWorkers() = 1
[13:20:31.797] plan(): Setting new future strategy stack:
[13:20:31.797] List of future strategies:
[13:20:31.797] 1. sequential:
[13:20:31.797]    - args: function (..., envir = parent.frame())
[13:20:31.797]    - tweaked: FALSE
[13:20:31.797]    - call: plan(strategy)
[13:20:31.798] plan(): nbrOfWorkers() = 1
[13:20:31.800] SequentialFuture started (and completed)
[13:20:31.800] - Launch lazy future ... done
[13:20:31.800] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[13:20:31.802] getGlobalsAndPackages() ...
[13:20:31.803] Searching for globals...
[13:20:31.808] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[13:20:31.808] Searching for globals ... DONE
[13:20:31.808] Resolving globals: FALSE
[13:20:31.809] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[13:20:31.809] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[13:20:31.809] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[13:20:31.809] 
[13:20:31.810] getGlobalsAndPackages() ... DONE
[13:20:31.810] run() for ‘Future’ ...
[13:20:31.810] - state: ‘created’
[13:20:31.810] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:31.810] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:31.810] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:31.811]   - Field: ‘label’
[13:20:31.811]   - Field: ‘local’
[13:20:31.811]   - Field: ‘owner’
[13:20:31.811]   - Field: ‘envir’
[13:20:31.811]   - Field: ‘packages’
[13:20:31.811]   - Field: ‘gc’
[13:20:31.811]   - Field: ‘conditions’
[13:20:31.811]   - Field: ‘expr’
[13:20:31.811]   - Field: ‘uuid’
[13:20:31.811]   - Field: ‘seed’
[13:20:31.812]   - Field: ‘version’
[13:20:31.812]   - Field: ‘result’
[13:20:31.812]   - Field: ‘asynchronous’
[13:20:31.812]   - Field: ‘calls’
[13:20:31.812]   - Field: ‘globals’
[13:20:31.812]   - Field: ‘stdout’
[13:20:31.812]   - Field: ‘earlySignal’
[13:20:31.812]   - Field: ‘lazy’
[13:20:31.812]   - Field: ‘state’
[13:20:31.812] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:31.813] - Launch lazy future ...
[13:20:31.813] Packages needed by the future expression (n = 0): <none>
[13:20:31.813] Packages needed by future strategies (n = 0): <none>
[13:20:31.813] {
[13:20:31.813]     {
[13:20:31.813]         {
[13:20:31.813]             ...future.startTime <- base::Sys.time()
[13:20:31.813]             {
[13:20:31.813]                 {
[13:20:31.813]                   {
[13:20:31.813]                     base::local({
[13:20:31.813]                       has_future <- base::requireNamespace("future", 
[13:20:31.813]                         quietly = TRUE)
[13:20:31.813]                       if (has_future) {
[13:20:31.813]                         ns <- base::getNamespace("future")
[13:20:31.813]                         version <- ns[[".package"]][["version"]]
[13:20:31.813]                         if (is.null(version)) 
[13:20:31.813]                           version <- utils::packageVersion("future")
[13:20:31.813]                       }
[13:20:31.813]                       else {
[13:20:31.813]                         version <- NULL
[13:20:31.813]                       }
[13:20:31.813]                       if (!has_future || version < "1.8.0") {
[13:20:31.813]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:31.813]                           "", base::R.version$version.string), 
[13:20:31.813]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:31.813]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:31.813]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:31.813]                             "release", "version")], collapse = " "), 
[13:20:31.813]                           hostname = base::Sys.info()[["nodename"]])
[13:20:31.813]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:31.813]                           info)
[13:20:31.813]                         info <- base::paste(info, collapse = "; ")
[13:20:31.813]                         if (!has_future) {
[13:20:31.813]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:31.813]                             info)
[13:20:31.813]                         }
[13:20:31.813]                         else {
[13:20:31.813]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:31.813]                             info, version)
[13:20:31.813]                         }
[13:20:31.813]                         base::stop(msg)
[13:20:31.813]                       }
[13:20:31.813]                     })
[13:20:31.813]                   }
[13:20:31.813]                   options(future.plan = NULL)
[13:20:31.813]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:31.813]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:31.813]                 }
[13:20:31.813]                 ...future.workdir <- getwd()
[13:20:31.813]             }
[13:20:31.813]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:31.813]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:31.813]         }
[13:20:31.813]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:31.813]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:31.813]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:31.813]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:31.813]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:31.813]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:31.813]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:31.813]             base::names(...future.oldOptions))
[13:20:31.813]     }
[13:20:31.813]     if (FALSE) {
[13:20:31.813]     }
[13:20:31.813]     else {
[13:20:31.813]         if (TRUE) {
[13:20:31.813]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:31.813]                 open = "w")
[13:20:31.813]         }
[13:20:31.813]         else {
[13:20:31.813]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:31.813]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:31.813]         }
[13:20:31.813]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:31.813]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:31.813]             base::sink(type = "output", split = FALSE)
[13:20:31.813]             base::close(...future.stdout)
[13:20:31.813]         }, add = TRUE)
[13:20:31.813]     }
[13:20:31.813]     ...future.frame <- base::sys.nframe()
[13:20:31.813]     ...future.conditions <- base::list()
[13:20:31.813]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:31.813]     if (FALSE) {
[13:20:31.813]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:31.813]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:31.813]     }
[13:20:31.813]     ...future.result <- base::tryCatch({
[13:20:31.813]         base::withCallingHandlers({
[13:20:31.813]             ...future.value <- base::withVisible(base::local({
[13:20:31.813]                 outer_function(1L)
[13:20:31.813]             }))
[13:20:31.813]             future::FutureResult(value = ...future.value$value, 
[13:20:31.813]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:31.813]                   ...future.rng), globalenv = if (FALSE) 
[13:20:31.813]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:31.813]                     ...future.globalenv.names))
[13:20:31.813]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:31.813]         }, condition = base::local({
[13:20:31.813]             c <- base::c
[13:20:31.813]             inherits <- base::inherits
[13:20:31.813]             invokeRestart <- base::invokeRestart
[13:20:31.813]             length <- base::length
[13:20:31.813]             list <- base::list
[13:20:31.813]             seq.int <- base::seq.int
[13:20:31.813]             signalCondition <- base::signalCondition
[13:20:31.813]             sys.calls <- base::sys.calls
[13:20:31.813]             `[[` <- base::`[[`
[13:20:31.813]             `+` <- base::`+`
[13:20:31.813]             `<<-` <- base::`<<-`
[13:20:31.813]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:31.813]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:31.813]                   3L)]
[13:20:31.813]             }
[13:20:31.813]             function(cond) {
[13:20:31.813]                 is_error <- inherits(cond, "error")
[13:20:31.813]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:31.813]                   NULL)
[13:20:31.813]                 if (is_error) {
[13:20:31.813]                   sessionInformation <- function() {
[13:20:31.813]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:31.813]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:31.813]                       search = base::search(), system = base::Sys.info())
[13:20:31.813]                   }
[13:20:31.813]                   ...future.conditions[[length(...future.conditions) + 
[13:20:31.813]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:31.813]                     cond$call), session = sessionInformation(), 
[13:20:31.813]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:31.813]                   signalCondition(cond)
[13:20:31.813]                 }
[13:20:31.813]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:31.813]                 "immediateCondition"))) {
[13:20:31.813]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:31.813]                   ...future.conditions[[length(...future.conditions) + 
[13:20:31.813]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:31.813]                   if (TRUE && !signal) {
[13:20:31.813]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:31.813]                     {
[13:20:31.813]                       inherits <- base::inherits
[13:20:31.813]                       invokeRestart <- base::invokeRestart
[13:20:31.813]                       is.null <- base::is.null
[13:20:31.813]                       muffled <- FALSE
[13:20:31.813]                       if (inherits(cond, "message")) {
[13:20:31.813]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:31.813]                         if (muffled) 
[13:20:31.813]                           invokeRestart("muffleMessage")
[13:20:31.813]                       }
[13:20:31.813]                       else if (inherits(cond, "warning")) {
[13:20:31.813]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:31.813]                         if (muffled) 
[13:20:31.813]                           invokeRestart("muffleWarning")
[13:20:31.813]                       }
[13:20:31.813]                       else if (inherits(cond, "condition")) {
[13:20:31.813]                         if (!is.null(pattern)) {
[13:20:31.813]                           computeRestarts <- base::computeRestarts
[13:20:31.813]                           grepl <- base::grepl
[13:20:31.813]                           restarts <- computeRestarts(cond)
[13:20:31.813]                           for (restart in restarts) {
[13:20:31.813]                             name <- restart$name
[13:20:31.813]                             if (is.null(name)) 
[13:20:31.813]                               next
[13:20:31.813]                             if (!grepl(pattern, name)) 
[13:20:31.813]                               next
[13:20:31.813]                             invokeRestart(restart)
[13:20:31.813]                             muffled <- TRUE
[13:20:31.813]                             break
[13:20:31.813]                           }
[13:20:31.813]                         }
[13:20:31.813]                       }
[13:20:31.813]                       invisible(muffled)
[13:20:31.813]                     }
[13:20:31.813]                     muffleCondition(cond, pattern = "^muffle")
[13:20:31.813]                   }
[13:20:31.813]                 }
[13:20:31.813]                 else {
[13:20:31.813]                   if (TRUE) {
[13:20:31.813]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:31.813]                     {
[13:20:31.813]                       inherits <- base::inherits
[13:20:31.813]                       invokeRestart <- base::invokeRestart
[13:20:31.813]                       is.null <- base::is.null
[13:20:31.813]                       muffled <- FALSE
[13:20:31.813]                       if (inherits(cond, "message")) {
[13:20:31.813]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:31.813]                         if (muffled) 
[13:20:31.813]                           invokeRestart("muffleMessage")
[13:20:31.813]                       }
[13:20:31.813]                       else if (inherits(cond, "warning")) {
[13:20:31.813]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:31.813]                         if (muffled) 
[13:20:31.813]                           invokeRestart("muffleWarning")
[13:20:31.813]                       }
[13:20:31.813]                       else if (inherits(cond, "condition")) {
[13:20:31.813]                         if (!is.null(pattern)) {
[13:20:31.813]                           computeRestarts <- base::computeRestarts
[13:20:31.813]                           grepl <- base::grepl
[13:20:31.813]                           restarts <- computeRestarts(cond)
[13:20:31.813]                           for (restart in restarts) {
[13:20:31.813]                             name <- restart$name
[13:20:31.813]                             if (is.null(name)) 
[13:20:31.813]                               next
[13:20:31.813]                             if (!grepl(pattern, name)) 
[13:20:31.813]                               next
[13:20:31.813]                             invokeRestart(restart)
[13:20:31.813]                             muffled <- TRUE
[13:20:31.813]                             break
[13:20:31.813]                           }
[13:20:31.813]                         }
[13:20:31.813]                       }
[13:20:31.813]                       invisible(muffled)
[13:20:31.813]                     }
[13:20:31.813]                     muffleCondition(cond, pattern = "^muffle")
[13:20:31.813]                   }
[13:20:31.813]                 }
[13:20:31.813]             }
[13:20:31.813]         }))
[13:20:31.813]     }, error = function(ex) {
[13:20:31.813]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:31.813]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:31.813]                 ...future.rng), started = ...future.startTime, 
[13:20:31.813]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:31.813]             version = "1.8"), class = "FutureResult")
[13:20:31.813]     }, finally = {
[13:20:31.813]         if (!identical(...future.workdir, getwd())) 
[13:20:31.813]             setwd(...future.workdir)
[13:20:31.813]         {
[13:20:31.813]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:31.813]                 ...future.oldOptions$nwarnings <- NULL
[13:20:31.813]             }
[13:20:31.813]             base::options(...future.oldOptions)
[13:20:31.813]             if (.Platform$OS.type == "windows") {
[13:20:31.813]                 old_names <- names(...future.oldEnvVars)
[13:20:31.813]                 envs <- base::Sys.getenv()
[13:20:31.813]                 names <- names(envs)
[13:20:31.813]                 common <- intersect(names, old_names)
[13:20:31.813]                 added <- setdiff(names, old_names)
[13:20:31.813]                 removed <- setdiff(old_names, names)
[13:20:31.813]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:31.813]                   envs[common]]
[13:20:31.813]                 NAMES <- toupper(changed)
[13:20:31.813]                 args <- list()
[13:20:31.813]                 for (kk in seq_along(NAMES)) {
[13:20:31.813]                   name <- changed[[kk]]
[13:20:31.813]                   NAME <- NAMES[[kk]]
[13:20:31.813]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.813]                     next
[13:20:31.813]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:31.813]                 }
[13:20:31.813]                 NAMES <- toupper(added)
[13:20:31.813]                 for (kk in seq_along(NAMES)) {
[13:20:31.813]                   name <- added[[kk]]
[13:20:31.813]                   NAME <- NAMES[[kk]]
[13:20:31.813]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.813]                     next
[13:20:31.813]                   args[[name]] <- ""
[13:20:31.813]                 }
[13:20:31.813]                 NAMES <- toupper(removed)
[13:20:31.813]                 for (kk in seq_along(NAMES)) {
[13:20:31.813]                   name <- removed[[kk]]
[13:20:31.813]                   NAME <- NAMES[[kk]]
[13:20:31.813]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.813]                     next
[13:20:31.813]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:31.813]                 }
[13:20:31.813]                 if (length(args) > 0) 
[13:20:31.813]                   base::do.call(base::Sys.setenv, args = args)
[13:20:31.813]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:31.813]             }
[13:20:31.813]             else {
[13:20:31.813]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:31.813]             }
[13:20:31.813]             {
[13:20:31.813]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:31.813]                   0L) {
[13:20:31.813]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:31.813]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:31.813]                   base::options(opts)
[13:20:31.813]                 }
[13:20:31.813]                 {
[13:20:31.813]                   {
[13:20:31.813]                     NULL
[13:20:31.813]                     RNGkind("Mersenne-Twister")
[13:20:31.813]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:31.813]                       inherits = FALSE)
[13:20:31.813]                   }
[13:20:31.813]                   options(future.plan = NULL)
[13:20:31.813]                   if (is.na(NA_character_)) 
[13:20:31.813]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:31.813]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:31.813]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:31.813]                   {
[13:20:31.813]                     future <- SequentialFuture(..., envir = envir)
[13:20:31.813]                     if (!future$lazy) 
[13:20:31.813]                       future <- run(future)
[13:20:31.813]                     invisible(future)
[13:20:31.813]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:31.813]                 }
[13:20:31.813]             }
[13:20:31.813]         }
[13:20:31.813]     })
[13:20:31.813]     if (TRUE) {
[13:20:31.813]         base::sink(type = "output", split = FALSE)
[13:20:31.813]         if (TRUE) {
[13:20:31.813]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:31.813]         }
[13:20:31.813]         else {
[13:20:31.813]             ...future.result["stdout"] <- base::list(NULL)
[13:20:31.813]         }
[13:20:31.813]         base::close(...future.stdout)
[13:20:31.813]         ...future.stdout <- NULL
[13:20:31.813]     }
[13:20:31.813]     ...future.result$conditions <- ...future.conditions
[13:20:31.813]     ...future.result$finished <- base::Sys.time()
[13:20:31.813]     ...future.result
[13:20:31.813] }
[13:20:31.815] assign_globals() ...
[13:20:31.815] List of 3
[13:20:31.815]  $ outer_function:function (x)  
[13:20:31.815]  $ map           :function (.x, .f, ...)  
[13:20:31.815]  $ inner_function:function (x)  
[13:20:31.815]  - attr(*, "where")=List of 3
[13:20:31.815]   ..$ outer_function:<environment: R_EmptyEnv> 
[13:20:31.815]   ..$ map           :<environment: R_EmptyEnv> 
[13:20:31.815]   ..$ inner_function:<environment: R_EmptyEnv> 
[13:20:31.815]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:31.815]  - attr(*, "resolved")= logi FALSE
[13:20:31.815]  - attr(*, "total_size")= num 7704
[13:20:31.815]  - attr(*, "already-done")= logi TRUE
[13:20:31.819] - reassign environment for ‘outer_function’
[13:20:31.819] - copied ‘outer_function’ to environment
[13:20:31.819] - reassign environment for ‘map’
[13:20:31.819] - copied ‘map’ to environment
[13:20:31.819] - reassign environment for ‘inner_function’
[13:20:31.819] - copied ‘inner_function’ to environment
[13:20:31.819] assign_globals() ... done
[13:20:31.819] plan(): Setting new future strategy stack:
[13:20:31.819] List of future strategies:
[13:20:31.819] 1. sequential:
[13:20:31.819]    - args: function (..., envir = parent.frame())
[13:20:31.819]    - tweaked: FALSE
[13:20:31.819]    - call: NULL
[13:20:31.820] plan(): nbrOfWorkers() = 1
[13:20:31.828] plan(): Setting new future strategy stack:
[13:20:31.828] List of future strategies:
[13:20:31.828] 1. sequential:
[13:20:31.828]    - args: function (..., envir = parent.frame())
[13:20:31.828]    - tweaked: FALSE
[13:20:31.828]    - call: plan(strategy)
[13:20:31.829] plan(): nbrOfWorkers() = 1
[13:20:31.829] SequentialFuture started (and completed)
[13:20:31.829] - Launch lazy future ... done
[13:20:31.829] run() for ‘SequentialFuture’ ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[13:20:31.830] getGlobalsAndPackages() ...
[13:20:31.830] Searching for globals...
[13:20:31.835] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[13:20:31.835] Searching for globals ... DONE
[13:20:31.835] Resolving globals: FALSE
[13:20:31.836] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[13:20:31.836] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[13:20:31.836] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[13:20:31.836] 
[13:20:31.836] getGlobalsAndPackages() ... DONE
[13:20:31.837] run() for ‘Future’ ...
[13:20:31.837] - state: ‘created’
[13:20:31.837] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:31.837] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:31.837] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:31.837]   - Field: ‘label’
[13:20:31.838]   - Field: ‘local’
[13:20:31.838]   - Field: ‘owner’
[13:20:31.838]   - Field: ‘envir’
[13:20:31.838]   - Field: ‘packages’
[13:20:31.838]   - Field: ‘gc’
[13:20:31.838]   - Field: ‘conditions’
[13:20:31.838]   - Field: ‘expr’
[13:20:31.838]   - Field: ‘uuid’
[13:20:31.838]   - Field: ‘seed’
[13:20:31.838]   - Field: ‘version’
[13:20:31.839]   - Field: ‘result’
[13:20:31.839]   - Field: ‘asynchronous’
[13:20:31.839]   - Field: ‘calls’
[13:20:31.839]   - Field: ‘globals’
[13:20:31.839]   - Field: ‘stdout’
[13:20:31.839]   - Field: ‘earlySignal’
[13:20:31.839]   - Field: ‘lazy’
[13:20:31.839]   - Field: ‘state’
[13:20:31.839] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:31.839] - Launch lazy future ...
[13:20:31.840] Packages needed by the future expression (n = 0): <none>
[13:20:31.840] Packages needed by future strategies (n = 0): <none>
[13:20:31.840] {
[13:20:31.840]     {
[13:20:31.840]         {
[13:20:31.840]             ...future.startTime <- base::Sys.time()
[13:20:31.840]             {
[13:20:31.840]                 {
[13:20:31.840]                   {
[13:20:31.840]                     base::local({
[13:20:31.840]                       has_future <- base::requireNamespace("future", 
[13:20:31.840]                         quietly = TRUE)
[13:20:31.840]                       if (has_future) {
[13:20:31.840]                         ns <- base::getNamespace("future")
[13:20:31.840]                         version <- ns[[".package"]][["version"]]
[13:20:31.840]                         if (is.null(version)) 
[13:20:31.840]                           version <- utils::packageVersion("future")
[13:20:31.840]                       }
[13:20:31.840]                       else {
[13:20:31.840]                         version <- NULL
[13:20:31.840]                       }
[13:20:31.840]                       if (!has_future || version < "1.8.0") {
[13:20:31.840]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:31.840]                           "", base::R.version$version.string), 
[13:20:31.840]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:31.840]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:31.840]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:31.840]                             "release", "version")], collapse = " "), 
[13:20:31.840]                           hostname = base::Sys.info()[["nodename"]])
[13:20:31.840]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:31.840]                           info)
[13:20:31.840]                         info <- base::paste(info, collapse = "; ")
[13:20:31.840]                         if (!has_future) {
[13:20:31.840]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:31.840]                             info)
[13:20:31.840]                         }
[13:20:31.840]                         else {
[13:20:31.840]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:31.840]                             info, version)
[13:20:31.840]                         }
[13:20:31.840]                         base::stop(msg)
[13:20:31.840]                       }
[13:20:31.840]                     })
[13:20:31.840]                   }
[13:20:31.840]                   options(future.plan = NULL)
[13:20:31.840]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:31.840]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:31.840]                 }
[13:20:31.840]                 ...future.workdir <- getwd()
[13:20:31.840]             }
[13:20:31.840]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:31.840]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:31.840]         }
[13:20:31.840]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:31.840]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:31.840]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:31.840]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:31.840]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:31.840]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:31.840]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:31.840]             base::names(...future.oldOptions))
[13:20:31.840]     }
[13:20:31.840]     if (FALSE) {
[13:20:31.840]     }
[13:20:31.840]     else {
[13:20:31.840]         if (TRUE) {
[13:20:31.840]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:31.840]                 open = "w")
[13:20:31.840]         }
[13:20:31.840]         else {
[13:20:31.840]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:31.840]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:31.840]         }
[13:20:31.840]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:31.840]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:31.840]             base::sink(type = "output", split = FALSE)
[13:20:31.840]             base::close(...future.stdout)
[13:20:31.840]         }, add = TRUE)
[13:20:31.840]     }
[13:20:31.840]     ...future.frame <- base::sys.nframe()
[13:20:31.840]     ...future.conditions <- base::list()
[13:20:31.840]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:31.840]     if (FALSE) {
[13:20:31.840]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:31.840]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:31.840]     }
[13:20:31.840]     ...future.result <- base::tryCatch({
[13:20:31.840]         base::withCallingHandlers({
[13:20:31.840]             ...future.value <- base::withVisible(base::local({
[13:20:31.840]                 outer_function(1L)
[13:20:31.840]             }))
[13:20:31.840]             future::FutureResult(value = ...future.value$value, 
[13:20:31.840]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:31.840]                   ...future.rng), globalenv = if (FALSE) 
[13:20:31.840]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:31.840]                     ...future.globalenv.names))
[13:20:31.840]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:31.840]         }, condition = base::local({
[13:20:31.840]             c <- base::c
[13:20:31.840]             inherits <- base::inherits
[13:20:31.840]             invokeRestart <- base::invokeRestart
[13:20:31.840]             length <- base::length
[13:20:31.840]             list <- base::list
[13:20:31.840]             seq.int <- base::seq.int
[13:20:31.840]             signalCondition <- base::signalCondition
[13:20:31.840]             sys.calls <- base::sys.calls
[13:20:31.840]             `[[` <- base::`[[`
[13:20:31.840]             `+` <- base::`+`
[13:20:31.840]             `<<-` <- base::`<<-`
[13:20:31.840]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:31.840]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:31.840]                   3L)]
[13:20:31.840]             }
[13:20:31.840]             function(cond) {
[13:20:31.840]                 is_error <- inherits(cond, "error")
[13:20:31.840]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:31.840]                   NULL)
[13:20:31.840]                 if (is_error) {
[13:20:31.840]                   sessionInformation <- function() {
[13:20:31.840]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:31.840]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:31.840]                       search = base::search(), system = base::Sys.info())
[13:20:31.840]                   }
[13:20:31.840]                   ...future.conditions[[length(...future.conditions) + 
[13:20:31.840]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:31.840]                     cond$call), session = sessionInformation(), 
[13:20:31.840]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:31.840]                   signalCondition(cond)
[13:20:31.840]                 }
[13:20:31.840]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:31.840]                 "immediateCondition"))) {
[13:20:31.840]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:31.840]                   ...future.conditions[[length(...future.conditions) + 
[13:20:31.840]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:31.840]                   if (TRUE && !signal) {
[13:20:31.840]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:31.840]                     {
[13:20:31.840]                       inherits <- base::inherits
[13:20:31.840]                       invokeRestart <- base::invokeRestart
[13:20:31.840]                       is.null <- base::is.null
[13:20:31.840]                       muffled <- FALSE
[13:20:31.840]                       if (inherits(cond, "message")) {
[13:20:31.840]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:31.840]                         if (muffled) 
[13:20:31.840]                           invokeRestart("muffleMessage")
[13:20:31.840]                       }
[13:20:31.840]                       else if (inherits(cond, "warning")) {
[13:20:31.840]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:31.840]                         if (muffled) 
[13:20:31.840]                           invokeRestart("muffleWarning")
[13:20:31.840]                       }
[13:20:31.840]                       else if (inherits(cond, "condition")) {
[13:20:31.840]                         if (!is.null(pattern)) {
[13:20:31.840]                           computeRestarts <- base::computeRestarts
[13:20:31.840]                           grepl <- base::grepl
[13:20:31.840]                           restarts <- computeRestarts(cond)
[13:20:31.840]                           for (restart in restarts) {
[13:20:31.840]                             name <- restart$name
[13:20:31.840]                             if (is.null(name)) 
[13:20:31.840]                               next
[13:20:31.840]                             if (!grepl(pattern, name)) 
[13:20:31.840]                               next
[13:20:31.840]                             invokeRestart(restart)
[13:20:31.840]                             muffled <- TRUE
[13:20:31.840]                             break
[13:20:31.840]                           }
[13:20:31.840]                         }
[13:20:31.840]                       }
[13:20:31.840]                       invisible(muffled)
[13:20:31.840]                     }
[13:20:31.840]                     muffleCondition(cond, pattern = "^muffle")
[13:20:31.840]                   }
[13:20:31.840]                 }
[13:20:31.840]                 else {
[13:20:31.840]                   if (TRUE) {
[13:20:31.840]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:31.840]                     {
[13:20:31.840]                       inherits <- base::inherits
[13:20:31.840]                       invokeRestart <- base::invokeRestart
[13:20:31.840]                       is.null <- base::is.null
[13:20:31.840]                       muffled <- FALSE
[13:20:31.840]                       if (inherits(cond, "message")) {
[13:20:31.840]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:31.840]                         if (muffled) 
[13:20:31.840]                           invokeRestart("muffleMessage")
[13:20:31.840]                       }
[13:20:31.840]                       else if (inherits(cond, "warning")) {
[13:20:31.840]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:31.840]                         if (muffled) 
[13:20:31.840]                           invokeRestart("muffleWarning")
[13:20:31.840]                       }
[13:20:31.840]                       else if (inherits(cond, "condition")) {
[13:20:31.840]                         if (!is.null(pattern)) {
[13:20:31.840]                           computeRestarts <- base::computeRestarts
[13:20:31.840]                           grepl <- base::grepl
[13:20:31.840]                           restarts <- computeRestarts(cond)
[13:20:31.840]                           for (restart in restarts) {
[13:20:31.840]                             name <- restart$name
[13:20:31.840]                             if (is.null(name)) 
[13:20:31.840]                               next
[13:20:31.840]                             if (!grepl(pattern, name)) 
[13:20:31.840]                               next
[13:20:31.840]                             invokeRestart(restart)
[13:20:31.840]                             muffled <- TRUE
[13:20:31.840]                             break
[13:20:31.840]                           }
[13:20:31.840]                         }
[13:20:31.840]                       }
[13:20:31.840]                       invisible(muffled)
[13:20:31.840]                     }
[13:20:31.840]                     muffleCondition(cond, pattern = "^muffle")
[13:20:31.840]                   }
[13:20:31.840]                 }
[13:20:31.840]             }
[13:20:31.840]         }))
[13:20:31.840]     }, error = function(ex) {
[13:20:31.840]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:31.840]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:31.840]                 ...future.rng), started = ...future.startTime, 
[13:20:31.840]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:31.840]             version = "1.8"), class = "FutureResult")
[13:20:31.840]     }, finally = {
[13:20:31.840]         if (!identical(...future.workdir, getwd())) 
[13:20:31.840]             setwd(...future.workdir)
[13:20:31.840]         {
[13:20:31.840]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:31.840]                 ...future.oldOptions$nwarnings <- NULL
[13:20:31.840]             }
[13:20:31.840]             base::options(...future.oldOptions)
[13:20:31.840]             if (.Platform$OS.type == "windows") {
[13:20:31.840]                 old_names <- names(...future.oldEnvVars)
[13:20:31.840]                 envs <- base::Sys.getenv()
[13:20:31.840]                 names <- names(envs)
[13:20:31.840]                 common <- intersect(names, old_names)
[13:20:31.840]                 added <- setdiff(names, old_names)
[13:20:31.840]                 removed <- setdiff(old_names, names)
[13:20:31.840]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:31.840]                   envs[common]]
[13:20:31.840]                 NAMES <- toupper(changed)
[13:20:31.840]                 args <- list()
[13:20:31.840]                 for (kk in seq_along(NAMES)) {
[13:20:31.840]                   name <- changed[[kk]]
[13:20:31.840]                   NAME <- NAMES[[kk]]
[13:20:31.840]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.840]                     next
[13:20:31.840]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:31.840]                 }
[13:20:31.840]                 NAMES <- toupper(added)
[13:20:31.840]                 for (kk in seq_along(NAMES)) {
[13:20:31.840]                   name <- added[[kk]]
[13:20:31.840]                   NAME <- NAMES[[kk]]
[13:20:31.840]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.840]                     next
[13:20:31.840]                   args[[name]] <- ""
[13:20:31.840]                 }
[13:20:31.840]                 NAMES <- toupper(removed)
[13:20:31.840]                 for (kk in seq_along(NAMES)) {
[13:20:31.840]                   name <- removed[[kk]]
[13:20:31.840]                   NAME <- NAMES[[kk]]
[13:20:31.840]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.840]                     next
[13:20:31.840]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:31.840]                 }
[13:20:31.840]                 if (length(args) > 0) 
[13:20:31.840]                   base::do.call(base::Sys.setenv, args = args)
[13:20:31.840]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:31.840]             }
[13:20:31.840]             else {
[13:20:31.840]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:31.840]             }
[13:20:31.840]             {
[13:20:31.840]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:31.840]                   0L) {
[13:20:31.840]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:31.840]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:31.840]                   base::options(opts)
[13:20:31.840]                 }
[13:20:31.840]                 {
[13:20:31.840]                   {
[13:20:31.840]                     NULL
[13:20:31.840]                     RNGkind("Mersenne-Twister")
[13:20:31.840]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:31.840]                       inherits = FALSE)
[13:20:31.840]                   }
[13:20:31.840]                   options(future.plan = NULL)
[13:20:31.840]                   if (is.na(NA_character_)) 
[13:20:31.840]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:31.840]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:31.840]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:31.840]                   {
[13:20:31.840]                     future <- SequentialFuture(..., envir = envir)
[13:20:31.840]                     if (!future$lazy) 
[13:20:31.840]                       future <- run(future)
[13:20:31.840]                     invisible(future)
[13:20:31.840]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:31.840]                 }
[13:20:31.840]             }
[13:20:31.840]         }
[13:20:31.840]     })
[13:20:31.840]     if (TRUE) {
[13:20:31.840]         base::sink(type = "output", split = FALSE)
[13:20:31.840]         if (TRUE) {
[13:20:31.840]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:31.840]         }
[13:20:31.840]         else {
[13:20:31.840]             ...future.result["stdout"] <- base::list(NULL)
[13:20:31.840]         }
[13:20:31.840]         base::close(...future.stdout)
[13:20:31.840]         ...future.stdout <- NULL
[13:20:31.840]     }
[13:20:31.840]     ...future.result$conditions <- ...future.conditions
[13:20:31.840]     ...future.result$finished <- base::Sys.time()
[13:20:31.840]     ...future.result
[13:20:31.840] }
[13:20:31.842] assign_globals() ...
[13:20:31.842] List of 3
[13:20:31.842]  $ outer_function:function (x)  
[13:20:31.842]  $ map           :function (.x, .f, ...)  
[13:20:31.842]  $ inner_function:function (x)  
[13:20:31.842]  - attr(*, "where")=List of 3
[13:20:31.842]   ..$ outer_function:<environment: R_EmptyEnv> 
[13:20:31.842]   ..$ map           :<environment: R_EmptyEnv> 
[13:20:31.842]   ..$ inner_function:<environment: R_EmptyEnv> 
[13:20:31.842]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:31.842]  - attr(*, "resolved")= logi FALSE
[13:20:31.842]  - attr(*, "total_size")= num 7704
[13:20:31.842]  - attr(*, "already-done")= logi TRUE
[13:20:31.845] - reassign environment for ‘outer_function’
[13:20:31.845] - copied ‘outer_function’ to environment
[13:20:31.846] - reassign environment for ‘map’
[13:20:31.848] - copied ‘map’ to environment
[13:20:31.848] - reassign environment for ‘inner_function’
[13:20:31.848] - copied ‘inner_function’ to environment
[13:20:31.848] assign_globals() ... done
[13:20:31.849] plan(): Setting new future strategy stack:
[13:20:31.849] List of future strategies:
[13:20:31.849] 1. sequential:
[13:20:31.849]    - args: function (..., envir = parent.frame())
[13:20:31.849]    - tweaked: FALSE
[13:20:31.849]    - call: NULL
[13:20:31.849] plan(): nbrOfWorkers() = 1
[13:20:31.850] plan(): Setting new future strategy stack:
[13:20:31.850] List of future strategies:
[13:20:31.850] 1. sequential:
[13:20:31.850]    - args: function (..., envir = parent.frame())
[13:20:31.850]    - tweaked: FALSE
[13:20:31.850]    - call: plan(strategy)
[13:20:31.850] plan(): nbrOfWorkers() = 1
[13:20:31.851] SequentialFuture started (and completed)
[13:20:31.851] - Launch lazy future ... done
[13:20:31.851] run() for ‘SequentialFuture’ ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- plan('multicore') ...
[13:20:31.865] plan(): Setting new future strategy stack:
[13:20:31.865] List of future strategies:
[13:20:31.865] 1. multicore:
[13:20:31.865]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:31.865]    - tweaked: FALSE
[13:20:31.865]    - call: plan(strategy)
[13:20:31.870] plan(): nbrOfWorkers() = 2
- lm(<formula>) ...
[13:20:31.870] getGlobalsAndPackages() ...
[13:20:31.870] Searching for globals...
[13:20:31.872] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:20:31.872] Searching for globals ... DONE
[13:20:31.872] Resolving globals: FALSE
[13:20:31.873] The total size of the 2 globals is 896 bytes (896 bytes)
[13:20:31.873] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:20:31.873] - globals: [2] ‘weight’, ‘group’
[13:20:31.873] - packages: [1] ‘stats’
[13:20:31.873] getGlobalsAndPackages() ... DONE
[13:20:31.874] run() for ‘Future’ ...
[13:20:31.874] - state: ‘created’
[13:20:31.874] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:31.878] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:31.878] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:31.879]   - Field: ‘label’
[13:20:31.879]   - Field: ‘local’
[13:20:31.879]   - Field: ‘owner’
[13:20:31.879]   - Field: ‘envir’
[13:20:31.879]   - Field: ‘workers’
[13:20:31.879]   - Field: ‘packages’
[13:20:31.879]   - Field: ‘gc’
[13:20:31.880]   - Field: ‘job’
[13:20:31.880]   - Field: ‘conditions’
[13:20:31.880]   - Field: ‘expr’
[13:20:31.880]   - Field: ‘uuid’
[13:20:31.880]   - Field: ‘seed’
[13:20:31.880]   - Field: ‘version’
[13:20:31.880]   - Field: ‘result’
[13:20:31.880]   - Field: ‘asynchronous’
[13:20:31.880]   - Field: ‘calls’
[13:20:31.881]   - Field: ‘globals’
[13:20:31.881]   - Field: ‘stdout’
[13:20:31.881]   - Field: ‘earlySignal’
[13:20:31.881]   - Field: ‘lazy’
[13:20:31.884]   - Field: ‘state’
[13:20:31.884] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:31.884] - Launch lazy future ...
[13:20:31.886] Packages needed by the future expression (n = 1): ‘stats’
[13:20:31.886] Packages needed by future strategies (n = 0): <none>
[13:20:31.887] {
[13:20:31.887]     {
[13:20:31.887]         {
[13:20:31.887]             ...future.startTime <- base::Sys.time()
[13:20:31.887]             {
[13:20:31.887]                 {
[13:20:31.887]                   {
[13:20:31.887]                     {
[13:20:31.887]                       {
[13:20:31.887]                         base::local({
[13:20:31.887]                           has_future <- base::requireNamespace("future", 
[13:20:31.887]                             quietly = TRUE)
[13:20:31.887]                           if (has_future) {
[13:20:31.887]                             ns <- base::getNamespace("future")
[13:20:31.887]                             version <- ns[[".package"]][["version"]]
[13:20:31.887]                             if (is.null(version)) 
[13:20:31.887]                               version <- utils::packageVersion("future")
[13:20:31.887]                           }
[13:20:31.887]                           else {
[13:20:31.887]                             version <- NULL
[13:20:31.887]                           }
[13:20:31.887]                           if (!has_future || version < "1.8.0") {
[13:20:31.887]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:31.887]                               "", base::R.version$version.string), 
[13:20:31.887]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:31.887]                                 base::R.version$platform, 8 * 
[13:20:31.887]                                   base::.Machine$sizeof.pointer), 
[13:20:31.887]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:31.887]                                 "release", "version")], collapse = " "), 
[13:20:31.887]                               hostname = base::Sys.info()[["nodename"]])
[13:20:31.887]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:31.887]                               info)
[13:20:31.887]                             info <- base::paste(info, collapse = "; ")
[13:20:31.887]                             if (!has_future) {
[13:20:31.887]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:31.887]                                 info)
[13:20:31.887]                             }
[13:20:31.887]                             else {
[13:20:31.887]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:31.887]                                 info, version)
[13:20:31.887]                             }
[13:20:31.887]                             base::stop(msg)
[13:20:31.887]                           }
[13:20:31.887]                         })
[13:20:31.887]                       }
[13:20:31.887]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:31.887]                       base::options(mc.cores = 1L)
[13:20:31.887]                     }
[13:20:31.887]                     base::local({
[13:20:31.887]                       for (pkg in "stats") {
[13:20:31.887]                         base::loadNamespace(pkg)
[13:20:31.887]                         base::library(pkg, character.only = TRUE)
[13:20:31.887]                       }
[13:20:31.887]                     })
[13:20:31.887]                   }
[13:20:31.887]                   options(future.plan = NULL)
[13:20:31.887]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:31.887]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:31.887]                 }
[13:20:31.887]                 ...future.workdir <- getwd()
[13:20:31.887]             }
[13:20:31.887]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:31.887]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:31.887]         }
[13:20:31.887]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:31.887]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:31.887]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:31.887]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:31.887]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:31.887]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:31.887]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:31.887]             base::names(...future.oldOptions))
[13:20:31.887]     }
[13:20:31.887]     if (FALSE) {
[13:20:31.887]     }
[13:20:31.887]     else {
[13:20:31.887]         if (TRUE) {
[13:20:31.887]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:31.887]                 open = "w")
[13:20:31.887]         }
[13:20:31.887]         else {
[13:20:31.887]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:31.887]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:31.887]         }
[13:20:31.887]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:31.887]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:31.887]             base::sink(type = "output", split = FALSE)
[13:20:31.887]             base::close(...future.stdout)
[13:20:31.887]         }, add = TRUE)
[13:20:31.887]     }
[13:20:31.887]     ...future.frame <- base::sys.nframe()
[13:20:31.887]     ...future.conditions <- base::list()
[13:20:31.887]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:31.887]     if (FALSE) {
[13:20:31.887]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:31.887]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:31.887]     }
[13:20:31.887]     ...future.result <- base::tryCatch({
[13:20:31.887]         base::withCallingHandlers({
[13:20:31.887]             ...future.value <- base::withVisible(base::local({
[13:20:31.887]                 withCallingHandlers({
[13:20:31.887]                   {
[13:20:31.887]                     lm(weight ~ group - 1)
[13:20:31.887]                   }
[13:20:31.887]                 }, immediateCondition = function(cond) {
[13:20:31.887]                   save_rds <- function (object, pathname, ...) 
[13:20:31.887]                   {
[13:20:31.887]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:31.887]                     if (file_test("-f", pathname_tmp)) {
[13:20:31.887]                       fi_tmp <- file.info(pathname_tmp)
[13:20:31.887]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:31.887]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:31.887]                         fi_tmp[["mtime"]])
[13:20:31.887]                     }
[13:20:31.887]                     tryCatch({
[13:20:31.887]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:31.887]                     }, error = function(ex) {
[13:20:31.887]                       msg <- conditionMessage(ex)
[13:20:31.887]                       fi_tmp <- file.info(pathname_tmp)
[13:20:31.887]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:31.887]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:31.887]                         fi_tmp[["mtime"]], msg)
[13:20:31.887]                       ex$message <- msg
[13:20:31.887]                       stop(ex)
[13:20:31.887]                     })
[13:20:31.887]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:31.887]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:31.887]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:31.887]                       fi_tmp <- file.info(pathname_tmp)
[13:20:31.887]                       fi <- file.info(pathname)
[13:20:31.887]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:31.887]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:31.887]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:31.887]                         fi[["size"]], fi[["mtime"]])
[13:20:31.887]                       stop(msg)
[13:20:31.887]                     }
[13:20:31.887]                     invisible(pathname)
[13:20:31.887]                   }
[13:20:31.887]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:31.887]                     rootPath = tempdir()) 
[13:20:31.887]                   {
[13:20:31.887]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:31.887]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:31.887]                       tmpdir = path, fileext = ".rds")
[13:20:31.887]                     save_rds(obj, file)
[13:20:31.887]                   }
[13:20:31.887]                   saveImmediateCondition(cond, path = "/tmp/Rtmpnh0Esg/.future/immediateConditions")
[13:20:31.887]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:31.887]                   {
[13:20:31.887]                     inherits <- base::inherits
[13:20:31.887]                     invokeRestart <- base::invokeRestart
[13:20:31.887]                     is.null <- base::is.null
[13:20:31.887]                     muffled <- FALSE
[13:20:31.887]                     if (inherits(cond, "message")) {
[13:20:31.887]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:31.887]                       if (muffled) 
[13:20:31.887]                         invokeRestart("muffleMessage")
[13:20:31.887]                     }
[13:20:31.887]                     else if (inherits(cond, "warning")) {
[13:20:31.887]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:31.887]                       if (muffled) 
[13:20:31.887]                         invokeRestart("muffleWarning")
[13:20:31.887]                     }
[13:20:31.887]                     else if (inherits(cond, "condition")) {
[13:20:31.887]                       if (!is.null(pattern)) {
[13:20:31.887]                         computeRestarts <- base::computeRestarts
[13:20:31.887]                         grepl <- base::grepl
[13:20:31.887]                         restarts <- computeRestarts(cond)
[13:20:31.887]                         for (restart in restarts) {
[13:20:31.887]                           name <- restart$name
[13:20:31.887]                           if (is.null(name)) 
[13:20:31.887]                             next
[13:20:31.887]                           if (!grepl(pattern, name)) 
[13:20:31.887]                             next
[13:20:31.887]                           invokeRestart(restart)
[13:20:31.887]                           muffled <- TRUE
[13:20:31.887]                           break
[13:20:31.887]                         }
[13:20:31.887]                       }
[13:20:31.887]                     }
[13:20:31.887]                     invisible(muffled)
[13:20:31.887]                   }
[13:20:31.887]                   muffleCondition(cond)
[13:20:31.887]                 })
[13:20:31.887]             }))
[13:20:31.887]             future::FutureResult(value = ...future.value$value, 
[13:20:31.887]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:31.887]                   ...future.rng), globalenv = if (FALSE) 
[13:20:31.887]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:31.887]                     ...future.globalenv.names))
[13:20:31.887]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:31.887]         }, condition = base::local({
[13:20:31.887]             c <- base::c
[13:20:31.887]             inherits <- base::inherits
[13:20:31.887]             invokeRestart <- base::invokeRestart
[13:20:31.887]             length <- base::length
[13:20:31.887]             list <- base::list
[13:20:31.887]             seq.int <- base::seq.int
[13:20:31.887]             signalCondition <- base::signalCondition
[13:20:31.887]             sys.calls <- base::sys.calls
[13:20:31.887]             `[[` <- base::`[[`
[13:20:31.887]             `+` <- base::`+`
[13:20:31.887]             `<<-` <- base::`<<-`
[13:20:31.887]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:31.887]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:31.887]                   3L)]
[13:20:31.887]             }
[13:20:31.887]             function(cond) {
[13:20:31.887]                 is_error <- inherits(cond, "error")
[13:20:31.887]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:31.887]                   NULL)
[13:20:31.887]                 if (is_error) {
[13:20:31.887]                   sessionInformation <- function() {
[13:20:31.887]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:31.887]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:31.887]                       search = base::search(), system = base::Sys.info())
[13:20:31.887]                   }
[13:20:31.887]                   ...future.conditions[[length(...future.conditions) + 
[13:20:31.887]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:31.887]                     cond$call), session = sessionInformation(), 
[13:20:31.887]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:31.887]                   signalCondition(cond)
[13:20:31.887]                 }
[13:20:31.887]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:31.887]                 "immediateCondition"))) {
[13:20:31.887]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:31.887]                   ...future.conditions[[length(...future.conditions) + 
[13:20:31.887]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:31.887]                   if (TRUE && !signal) {
[13:20:31.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:31.887]                     {
[13:20:31.887]                       inherits <- base::inherits
[13:20:31.887]                       invokeRestart <- base::invokeRestart
[13:20:31.887]                       is.null <- base::is.null
[13:20:31.887]                       muffled <- FALSE
[13:20:31.887]                       if (inherits(cond, "message")) {
[13:20:31.887]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:31.887]                         if (muffled) 
[13:20:31.887]                           invokeRestart("muffleMessage")
[13:20:31.887]                       }
[13:20:31.887]                       else if (inherits(cond, "warning")) {
[13:20:31.887]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:31.887]                         if (muffled) 
[13:20:31.887]                           invokeRestart("muffleWarning")
[13:20:31.887]                       }
[13:20:31.887]                       else if (inherits(cond, "condition")) {
[13:20:31.887]                         if (!is.null(pattern)) {
[13:20:31.887]                           computeRestarts <- base::computeRestarts
[13:20:31.887]                           grepl <- base::grepl
[13:20:31.887]                           restarts <- computeRestarts(cond)
[13:20:31.887]                           for (restart in restarts) {
[13:20:31.887]                             name <- restart$name
[13:20:31.887]                             if (is.null(name)) 
[13:20:31.887]                               next
[13:20:31.887]                             if (!grepl(pattern, name)) 
[13:20:31.887]                               next
[13:20:31.887]                             invokeRestart(restart)
[13:20:31.887]                             muffled <- TRUE
[13:20:31.887]                             break
[13:20:31.887]                           }
[13:20:31.887]                         }
[13:20:31.887]                       }
[13:20:31.887]                       invisible(muffled)
[13:20:31.887]                     }
[13:20:31.887]                     muffleCondition(cond, pattern = "^muffle")
[13:20:31.887]                   }
[13:20:31.887]                 }
[13:20:31.887]                 else {
[13:20:31.887]                   if (TRUE) {
[13:20:31.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:31.887]                     {
[13:20:31.887]                       inherits <- base::inherits
[13:20:31.887]                       invokeRestart <- base::invokeRestart
[13:20:31.887]                       is.null <- base::is.null
[13:20:31.887]                       muffled <- FALSE
[13:20:31.887]                       if (inherits(cond, "message")) {
[13:20:31.887]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:31.887]                         if (muffled) 
[13:20:31.887]                           invokeRestart("muffleMessage")
[13:20:31.887]                       }
[13:20:31.887]                       else if (inherits(cond, "warning")) {
[13:20:31.887]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:31.887]                         if (muffled) 
[13:20:31.887]                           invokeRestart("muffleWarning")
[13:20:31.887]                       }
[13:20:31.887]                       else if (inherits(cond, "condition")) {
[13:20:31.887]                         if (!is.null(pattern)) {
[13:20:31.887]                           computeRestarts <- base::computeRestarts
[13:20:31.887]                           grepl <- base::grepl
[13:20:31.887]                           restarts <- computeRestarts(cond)
[13:20:31.887]                           for (restart in restarts) {
[13:20:31.887]                             name <- restart$name
[13:20:31.887]                             if (is.null(name)) 
[13:20:31.887]                               next
[13:20:31.887]                             if (!grepl(pattern, name)) 
[13:20:31.887]                               next
[13:20:31.887]                             invokeRestart(restart)
[13:20:31.887]                             muffled <- TRUE
[13:20:31.887]                             break
[13:20:31.887]                           }
[13:20:31.887]                         }
[13:20:31.887]                       }
[13:20:31.887]                       invisible(muffled)
[13:20:31.887]                     }
[13:20:31.887]                     muffleCondition(cond, pattern = "^muffle")
[13:20:31.887]                   }
[13:20:31.887]                 }
[13:20:31.887]             }
[13:20:31.887]         }))
[13:20:31.887]     }, error = function(ex) {
[13:20:31.887]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:31.887]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:31.887]                 ...future.rng), started = ...future.startTime, 
[13:20:31.887]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:31.887]             version = "1.8"), class = "FutureResult")
[13:20:31.887]     }, finally = {
[13:20:31.887]         if (!identical(...future.workdir, getwd())) 
[13:20:31.887]             setwd(...future.workdir)
[13:20:31.887]         {
[13:20:31.887]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:31.887]                 ...future.oldOptions$nwarnings <- NULL
[13:20:31.887]             }
[13:20:31.887]             base::options(...future.oldOptions)
[13:20:31.887]             if (.Platform$OS.type == "windows") {
[13:20:31.887]                 old_names <- names(...future.oldEnvVars)
[13:20:31.887]                 envs <- base::Sys.getenv()
[13:20:31.887]                 names <- names(envs)
[13:20:31.887]                 common <- intersect(names, old_names)
[13:20:31.887]                 added <- setdiff(names, old_names)
[13:20:31.887]                 removed <- setdiff(old_names, names)
[13:20:31.887]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:31.887]                   envs[common]]
[13:20:31.887]                 NAMES <- toupper(changed)
[13:20:31.887]                 args <- list()
[13:20:31.887]                 for (kk in seq_along(NAMES)) {
[13:20:31.887]                   name <- changed[[kk]]
[13:20:31.887]                   NAME <- NAMES[[kk]]
[13:20:31.887]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.887]                     next
[13:20:31.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:31.887]                 }
[13:20:31.887]                 NAMES <- toupper(added)
[13:20:31.887]                 for (kk in seq_along(NAMES)) {
[13:20:31.887]                   name <- added[[kk]]
[13:20:31.887]                   NAME <- NAMES[[kk]]
[13:20:31.887]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.887]                     next
[13:20:31.887]                   args[[name]] <- ""
[13:20:31.887]                 }
[13:20:31.887]                 NAMES <- toupper(removed)
[13:20:31.887]                 for (kk in seq_along(NAMES)) {
[13:20:31.887]                   name <- removed[[kk]]
[13:20:31.887]                   NAME <- NAMES[[kk]]
[13:20:31.887]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.887]                     next
[13:20:31.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:31.887]                 }
[13:20:31.887]                 if (length(args) > 0) 
[13:20:31.887]                   base::do.call(base::Sys.setenv, args = args)
[13:20:31.887]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:31.887]             }
[13:20:31.887]             else {
[13:20:31.887]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:31.887]             }
[13:20:31.887]             {
[13:20:31.887]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:31.887]                   0L) {
[13:20:31.887]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:31.887]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:31.887]                   base::options(opts)
[13:20:31.887]                 }
[13:20:31.887]                 {
[13:20:31.887]                   {
[13:20:31.887]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:31.887]                     NULL
[13:20:31.887]                   }
[13:20:31.887]                   options(future.plan = NULL)
[13:20:31.887]                   if (is.na(NA_character_)) 
[13:20:31.887]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:31.887]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:31.887]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:31.887]                     envir = parent.frame()) 
[13:20:31.887]                   {
[13:20:31.887]                     default_workers <- missing(workers)
[13:20:31.887]                     if (is.function(workers)) 
[13:20:31.887]                       workers <- workers()
[13:20:31.887]                     workers <- structure(as.integer(workers), 
[13:20:31.887]                       class = class(workers))
[13:20:31.887]                     stop_if_not(is.finite(workers), workers >= 
[13:20:31.887]                       1L)
[13:20:31.887]                     if ((workers == 1L && !inherits(workers, 
[13:20:31.887]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:31.887]                       if (default_workers) 
[13:20:31.887]                         supportsMulticore(warn = TRUE)
[13:20:31.887]                       return(sequential(..., envir = envir))
[13:20:31.887]                     }
[13:20:31.887]                     oopts <- options(mc.cores = workers)
[13:20:31.887]                     on.exit(options(oopts))
[13:20:31.887]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:31.887]                       envir = envir)
[13:20:31.887]                     if (!future$lazy) 
[13:20:31.887]                       future <- run(future)
[13:20:31.887]                     invisible(future)
[13:20:31.887]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:31.887]                 }
[13:20:31.887]             }
[13:20:31.887]         }
[13:20:31.887]     })
[13:20:31.887]     if (TRUE) {
[13:20:31.887]         base::sink(type = "output", split = FALSE)
[13:20:31.887]         if (TRUE) {
[13:20:31.887]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:31.887]         }
[13:20:31.887]         else {
[13:20:31.887]             ...future.result["stdout"] <- base::list(NULL)
[13:20:31.887]         }
[13:20:31.887]         base::close(...future.stdout)
[13:20:31.887]         ...future.stdout <- NULL
[13:20:31.887]     }
[13:20:31.887]     ...future.result$conditions <- ...future.conditions
[13:20:31.887]     ...future.result$finished <- base::Sys.time()
[13:20:31.887]     ...future.result
[13:20:31.887] }
[13:20:31.889] assign_globals() ...
[13:20:31.889] List of 2
[13:20:31.889]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[13:20:31.889]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:31.889]  - attr(*, "where")=List of 2
[13:20:31.889]   ..$ weight:<environment: R_EmptyEnv> 
[13:20:31.889]   ..$ group :<environment: R_EmptyEnv> 
[13:20:31.889]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:31.889]  - attr(*, "resolved")= logi FALSE
[13:20:31.889]  - attr(*, "total_size")= num 896
[13:20:31.889]  - attr(*, "already-done")= logi TRUE
[13:20:31.893] - copied ‘weight’ to environment
[13:20:31.893] - copied ‘group’ to environment
[13:20:31.893] assign_globals() ... done
[13:20:31.893] requestCore(): workers = 2
[13:20:31.896] MulticoreFuture started
[13:20:31.896] - Launch lazy future ... done
[13:20:31.897] run() for ‘MulticoreFuture’ ... done
[13:20:31.897] plan(): Setting new future strategy stack:
[13:20:31.897] List of future strategies:
[13:20:31.897] 1. sequential:
[13:20:31.897]    - args: function (..., envir = parent.frame())
[13:20:31.897]    - tweaked: FALSE
[13:20:31.897]    - call: NULL
[13:20:31.898] plan(): nbrOfWorkers() = 1
[13:20:31.902] plan(): Setting new future strategy stack:
[13:20:31.902] List of future strategies:
[13:20:31.902] 1. multicore:
[13:20:31.902]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:31.902]    - tweaked: FALSE
[13:20:31.902]    - call: plan(strategy)
[13:20:31.907] plan(): nbrOfWorkers() = 2

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[13:20:31.917] getGlobalsAndPackages() ...
[13:20:31.917] Searching for globals...
[13:20:31.919] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:20:31.919] Searching for globals ... DONE
[13:20:31.919] Resolving globals: FALSE
[13:20:31.920] The total size of the 2 globals is 896 bytes (896 bytes)
[13:20:31.920] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:20:31.920] - globals: [2] ‘weight’, ‘group’
[13:20:31.921] - packages: [1] ‘stats’
[13:20:31.921] getGlobalsAndPackages() ... DONE
[13:20:31.921] run() for ‘Future’ ...
[13:20:31.921] - state: ‘created’
[13:20:31.921] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:31.926] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:31.926] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:31.926]   - Field: ‘label’
[13:20:31.926]   - Field: ‘local’
[13:20:31.926]   - Field: ‘owner’
[13:20:31.926]   - Field: ‘envir’
[13:20:31.926]   - Field: ‘workers’
[13:20:31.927]   - Field: ‘packages’
[13:20:31.927]   - Field: ‘gc’
[13:20:31.927]   - Field: ‘job’
[13:20:31.927]   - Field: ‘conditions’
[13:20:31.927]   - Field: ‘expr’
[13:20:31.927]   - Field: ‘uuid’
[13:20:31.927]   - Field: ‘seed’
[13:20:31.927]   - Field: ‘version’
[13:20:31.927]   - Field: ‘result’
[13:20:31.928]   - Field: ‘asynchronous’
[13:20:31.928]   - Field: ‘calls’
[13:20:31.928]   - Field: ‘globals’
[13:20:31.928]   - Field: ‘stdout’
[13:20:31.928]   - Field: ‘earlySignal’
[13:20:31.928]   - Field: ‘lazy’
[13:20:31.928]   - Field: ‘state’
[13:20:31.928] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:31.928] - Launch lazy future ...
[13:20:31.929] Packages needed by the future expression (n = 1): ‘stats’
[13:20:31.929] Packages needed by future strategies (n = 0): <none>
[13:20:31.930] {
[13:20:31.930]     {
[13:20:31.930]         {
[13:20:31.930]             ...future.startTime <- base::Sys.time()
[13:20:31.930]             {
[13:20:31.930]                 {
[13:20:31.930]                   {
[13:20:31.930]                     {
[13:20:31.930]                       {
[13:20:31.930]                         base::local({
[13:20:31.930]                           has_future <- base::requireNamespace("future", 
[13:20:31.930]                             quietly = TRUE)
[13:20:31.930]                           if (has_future) {
[13:20:31.930]                             ns <- base::getNamespace("future")
[13:20:31.930]                             version <- ns[[".package"]][["version"]]
[13:20:31.930]                             if (is.null(version)) 
[13:20:31.930]                               version <- utils::packageVersion("future")
[13:20:31.930]                           }
[13:20:31.930]                           else {
[13:20:31.930]                             version <- NULL
[13:20:31.930]                           }
[13:20:31.930]                           if (!has_future || version < "1.8.0") {
[13:20:31.930]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:31.930]                               "", base::R.version$version.string), 
[13:20:31.930]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:31.930]                                 base::R.version$platform, 8 * 
[13:20:31.930]                                   base::.Machine$sizeof.pointer), 
[13:20:31.930]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:31.930]                                 "release", "version")], collapse = " "), 
[13:20:31.930]                               hostname = base::Sys.info()[["nodename"]])
[13:20:31.930]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:31.930]                               info)
[13:20:31.930]                             info <- base::paste(info, collapse = "; ")
[13:20:31.930]                             if (!has_future) {
[13:20:31.930]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:31.930]                                 info)
[13:20:31.930]                             }
[13:20:31.930]                             else {
[13:20:31.930]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:31.930]                                 info, version)
[13:20:31.930]                             }
[13:20:31.930]                             base::stop(msg)
[13:20:31.930]                           }
[13:20:31.930]                         })
[13:20:31.930]                       }
[13:20:31.930]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:31.930]                       base::options(mc.cores = 1L)
[13:20:31.930]                     }
[13:20:31.930]                     base::local({
[13:20:31.930]                       for (pkg in "stats") {
[13:20:31.930]                         base::loadNamespace(pkg)
[13:20:31.930]                         base::library(pkg, character.only = TRUE)
[13:20:31.930]                       }
[13:20:31.930]                     })
[13:20:31.930]                   }
[13:20:31.930]                   options(future.plan = NULL)
[13:20:31.930]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:31.930]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:31.930]                 }
[13:20:31.930]                 ...future.workdir <- getwd()
[13:20:31.930]             }
[13:20:31.930]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:31.930]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:31.930]         }
[13:20:31.930]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:31.930]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:31.930]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:31.930]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:31.930]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:31.930]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:31.930]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:31.930]             base::names(...future.oldOptions))
[13:20:31.930]     }
[13:20:31.930]     if (FALSE) {
[13:20:31.930]     }
[13:20:31.930]     else {
[13:20:31.930]         if (TRUE) {
[13:20:31.930]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:31.930]                 open = "w")
[13:20:31.930]         }
[13:20:31.930]         else {
[13:20:31.930]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:31.930]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:31.930]         }
[13:20:31.930]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:31.930]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:31.930]             base::sink(type = "output", split = FALSE)
[13:20:31.930]             base::close(...future.stdout)
[13:20:31.930]         }, add = TRUE)
[13:20:31.930]     }
[13:20:31.930]     ...future.frame <- base::sys.nframe()
[13:20:31.930]     ...future.conditions <- base::list()
[13:20:31.930]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:31.930]     if (FALSE) {
[13:20:31.930]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:31.930]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:31.930]     }
[13:20:31.930]     ...future.result <- base::tryCatch({
[13:20:31.930]         base::withCallingHandlers({
[13:20:31.930]             ...future.value <- base::withVisible(base::local({
[13:20:31.930]                 withCallingHandlers({
[13:20:31.930]                   {
[13:20:31.930]                     lm(weight ~ group - 1)
[13:20:31.930]                   }
[13:20:31.930]                 }, immediateCondition = function(cond) {
[13:20:31.930]                   save_rds <- function (object, pathname, ...) 
[13:20:31.930]                   {
[13:20:31.930]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:31.930]                     if (file_test("-f", pathname_tmp)) {
[13:20:31.930]                       fi_tmp <- file.info(pathname_tmp)
[13:20:31.930]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:31.930]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:31.930]                         fi_tmp[["mtime"]])
[13:20:31.930]                     }
[13:20:31.930]                     tryCatch({
[13:20:31.930]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:31.930]                     }, error = function(ex) {
[13:20:31.930]                       msg <- conditionMessage(ex)
[13:20:31.930]                       fi_tmp <- file.info(pathname_tmp)
[13:20:31.930]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:31.930]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:31.930]                         fi_tmp[["mtime"]], msg)
[13:20:31.930]                       ex$message <- msg
[13:20:31.930]                       stop(ex)
[13:20:31.930]                     })
[13:20:31.930]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:31.930]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:31.930]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:31.930]                       fi_tmp <- file.info(pathname_tmp)
[13:20:31.930]                       fi <- file.info(pathname)
[13:20:31.930]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:31.930]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:31.930]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:31.930]                         fi[["size"]], fi[["mtime"]])
[13:20:31.930]                       stop(msg)
[13:20:31.930]                     }
[13:20:31.930]                     invisible(pathname)
[13:20:31.930]                   }
[13:20:31.930]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:31.930]                     rootPath = tempdir()) 
[13:20:31.930]                   {
[13:20:31.930]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:31.930]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:31.930]                       tmpdir = path, fileext = ".rds")
[13:20:31.930]                     save_rds(obj, file)
[13:20:31.930]                   }
[13:20:31.930]                   saveImmediateCondition(cond, path = "/tmp/Rtmpnh0Esg/.future/immediateConditions")
[13:20:31.930]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:31.930]                   {
[13:20:31.930]                     inherits <- base::inherits
[13:20:31.930]                     invokeRestart <- base::invokeRestart
[13:20:31.930]                     is.null <- base::is.null
[13:20:31.930]                     muffled <- FALSE
[13:20:31.930]                     if (inherits(cond, "message")) {
[13:20:31.930]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:31.930]                       if (muffled) 
[13:20:31.930]                         invokeRestart("muffleMessage")
[13:20:31.930]                     }
[13:20:31.930]                     else if (inherits(cond, "warning")) {
[13:20:31.930]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:31.930]                       if (muffled) 
[13:20:31.930]                         invokeRestart("muffleWarning")
[13:20:31.930]                     }
[13:20:31.930]                     else if (inherits(cond, "condition")) {
[13:20:31.930]                       if (!is.null(pattern)) {
[13:20:31.930]                         computeRestarts <- base::computeRestarts
[13:20:31.930]                         grepl <- base::grepl
[13:20:31.930]                         restarts <- computeRestarts(cond)
[13:20:31.930]                         for (restart in restarts) {
[13:20:31.930]                           name <- restart$name
[13:20:31.930]                           if (is.null(name)) 
[13:20:31.930]                             next
[13:20:31.930]                           if (!grepl(pattern, name)) 
[13:20:31.930]                             next
[13:20:31.930]                           invokeRestart(restart)
[13:20:31.930]                           muffled <- TRUE
[13:20:31.930]                           break
[13:20:31.930]                         }
[13:20:31.930]                       }
[13:20:31.930]                     }
[13:20:31.930]                     invisible(muffled)
[13:20:31.930]                   }
[13:20:31.930]                   muffleCondition(cond)
[13:20:31.930]                 })
[13:20:31.930]             }))
[13:20:31.930]             future::FutureResult(value = ...future.value$value, 
[13:20:31.930]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:31.930]                   ...future.rng), globalenv = if (FALSE) 
[13:20:31.930]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:31.930]                     ...future.globalenv.names))
[13:20:31.930]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:31.930]         }, condition = base::local({
[13:20:31.930]             c <- base::c
[13:20:31.930]             inherits <- base::inherits
[13:20:31.930]             invokeRestart <- base::invokeRestart
[13:20:31.930]             length <- base::length
[13:20:31.930]             list <- base::list
[13:20:31.930]             seq.int <- base::seq.int
[13:20:31.930]             signalCondition <- base::signalCondition
[13:20:31.930]             sys.calls <- base::sys.calls
[13:20:31.930]             `[[` <- base::`[[`
[13:20:31.930]             `+` <- base::`+`
[13:20:31.930]             `<<-` <- base::`<<-`
[13:20:31.930]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:31.930]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:31.930]                   3L)]
[13:20:31.930]             }
[13:20:31.930]             function(cond) {
[13:20:31.930]                 is_error <- inherits(cond, "error")
[13:20:31.930]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:31.930]                   NULL)
[13:20:31.930]                 if (is_error) {
[13:20:31.930]                   sessionInformation <- function() {
[13:20:31.930]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:31.930]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:31.930]                       search = base::search(), system = base::Sys.info())
[13:20:31.930]                   }
[13:20:31.930]                   ...future.conditions[[length(...future.conditions) + 
[13:20:31.930]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:31.930]                     cond$call), session = sessionInformation(), 
[13:20:31.930]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:31.930]                   signalCondition(cond)
[13:20:31.930]                 }
[13:20:31.930]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:31.930]                 "immediateCondition"))) {
[13:20:31.930]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:31.930]                   ...future.conditions[[length(...future.conditions) + 
[13:20:31.930]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:31.930]                   if (TRUE && !signal) {
[13:20:31.930]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:31.930]                     {
[13:20:31.930]                       inherits <- base::inherits
[13:20:31.930]                       invokeRestart <- base::invokeRestart
[13:20:31.930]                       is.null <- base::is.null
[13:20:31.930]                       muffled <- FALSE
[13:20:31.930]                       if (inherits(cond, "message")) {
[13:20:31.930]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:31.930]                         if (muffled) 
[13:20:31.930]                           invokeRestart("muffleMessage")
[13:20:31.930]                       }
[13:20:31.930]                       else if (inherits(cond, "warning")) {
[13:20:31.930]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:31.930]                         if (muffled) 
[13:20:31.930]                           invokeRestart("muffleWarning")
[13:20:31.930]                       }
[13:20:31.930]                       else if (inherits(cond, "condition")) {
[13:20:31.930]                         if (!is.null(pattern)) {
[13:20:31.930]                           computeRestarts <- base::computeRestarts
[13:20:31.930]                           grepl <- base::grepl
[13:20:31.930]                           restarts <- computeRestarts(cond)
[13:20:31.930]                           for (restart in restarts) {
[13:20:31.930]                             name <- restart$name
[13:20:31.930]                             if (is.null(name)) 
[13:20:31.930]                               next
[13:20:31.930]                             if (!grepl(pattern, name)) 
[13:20:31.930]                               next
[13:20:31.930]                             invokeRestart(restart)
[13:20:31.930]                             muffled <- TRUE
[13:20:31.930]                             break
[13:20:31.930]                           }
[13:20:31.930]                         }
[13:20:31.930]                       }
[13:20:31.930]                       invisible(muffled)
[13:20:31.930]                     }
[13:20:31.930]                     muffleCondition(cond, pattern = "^muffle")
[13:20:31.930]                   }
[13:20:31.930]                 }
[13:20:31.930]                 else {
[13:20:31.930]                   if (TRUE) {
[13:20:31.930]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:31.930]                     {
[13:20:31.930]                       inherits <- base::inherits
[13:20:31.930]                       invokeRestart <- base::invokeRestart
[13:20:31.930]                       is.null <- base::is.null
[13:20:31.930]                       muffled <- FALSE
[13:20:31.930]                       if (inherits(cond, "message")) {
[13:20:31.930]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:31.930]                         if (muffled) 
[13:20:31.930]                           invokeRestart("muffleMessage")
[13:20:31.930]                       }
[13:20:31.930]                       else if (inherits(cond, "warning")) {
[13:20:31.930]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:31.930]                         if (muffled) 
[13:20:31.930]                           invokeRestart("muffleWarning")
[13:20:31.930]                       }
[13:20:31.930]                       else if (inherits(cond, "condition")) {
[13:20:31.930]                         if (!is.null(pattern)) {
[13:20:31.930]                           computeRestarts <- base::computeRestarts
[13:20:31.930]                           grepl <- base::grepl
[13:20:31.930]                           restarts <- computeRestarts(cond)
[13:20:31.930]                           for (restart in restarts) {
[13:20:31.930]                             name <- restart$name
[13:20:31.930]                             if (is.null(name)) 
[13:20:31.930]                               next
[13:20:31.930]                             if (!grepl(pattern, name)) 
[13:20:31.930]                               next
[13:20:31.930]                             invokeRestart(restart)
[13:20:31.930]                             muffled <- TRUE
[13:20:31.930]                             break
[13:20:31.930]                           }
[13:20:31.930]                         }
[13:20:31.930]                       }
[13:20:31.930]                       invisible(muffled)
[13:20:31.930]                     }
[13:20:31.930]                     muffleCondition(cond, pattern = "^muffle")
[13:20:31.930]                   }
[13:20:31.930]                 }
[13:20:31.930]             }
[13:20:31.930]         }))
[13:20:31.930]     }, error = function(ex) {
[13:20:31.930]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:31.930]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:31.930]                 ...future.rng), started = ...future.startTime, 
[13:20:31.930]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:31.930]             version = "1.8"), class = "FutureResult")
[13:20:31.930]     }, finally = {
[13:20:31.930]         if (!identical(...future.workdir, getwd())) 
[13:20:31.930]             setwd(...future.workdir)
[13:20:31.930]         {
[13:20:31.930]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:31.930]                 ...future.oldOptions$nwarnings <- NULL
[13:20:31.930]             }
[13:20:31.930]             base::options(...future.oldOptions)
[13:20:31.930]             if (.Platform$OS.type == "windows") {
[13:20:31.930]                 old_names <- names(...future.oldEnvVars)
[13:20:31.930]                 envs <- base::Sys.getenv()
[13:20:31.930]                 names <- names(envs)
[13:20:31.930]                 common <- intersect(names, old_names)
[13:20:31.930]                 added <- setdiff(names, old_names)
[13:20:31.930]                 removed <- setdiff(old_names, names)
[13:20:31.930]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:31.930]                   envs[common]]
[13:20:31.930]                 NAMES <- toupper(changed)
[13:20:31.930]                 args <- list()
[13:20:31.930]                 for (kk in seq_along(NAMES)) {
[13:20:31.930]                   name <- changed[[kk]]
[13:20:31.930]                   NAME <- NAMES[[kk]]
[13:20:31.930]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.930]                     next
[13:20:31.930]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:31.930]                 }
[13:20:31.930]                 NAMES <- toupper(added)
[13:20:31.930]                 for (kk in seq_along(NAMES)) {
[13:20:31.930]                   name <- added[[kk]]
[13:20:31.930]                   NAME <- NAMES[[kk]]
[13:20:31.930]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.930]                     next
[13:20:31.930]                   args[[name]] <- ""
[13:20:31.930]                 }
[13:20:31.930]                 NAMES <- toupper(removed)
[13:20:31.930]                 for (kk in seq_along(NAMES)) {
[13:20:31.930]                   name <- removed[[kk]]
[13:20:31.930]                   NAME <- NAMES[[kk]]
[13:20:31.930]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.930]                     next
[13:20:31.930]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:31.930]                 }
[13:20:31.930]                 if (length(args) > 0) 
[13:20:31.930]                   base::do.call(base::Sys.setenv, args = args)
[13:20:31.930]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:31.930]             }
[13:20:31.930]             else {
[13:20:31.930]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:31.930]             }
[13:20:31.930]             {
[13:20:31.930]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:31.930]                   0L) {
[13:20:31.930]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:31.930]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:31.930]                   base::options(opts)
[13:20:31.930]                 }
[13:20:31.930]                 {
[13:20:31.930]                   {
[13:20:31.930]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:31.930]                     NULL
[13:20:31.930]                   }
[13:20:31.930]                   options(future.plan = NULL)
[13:20:31.930]                   if (is.na(NA_character_)) 
[13:20:31.930]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:31.930]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:31.930]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:31.930]                     envir = parent.frame()) 
[13:20:31.930]                   {
[13:20:31.930]                     default_workers <- missing(workers)
[13:20:31.930]                     if (is.function(workers)) 
[13:20:31.930]                       workers <- workers()
[13:20:31.930]                     workers <- structure(as.integer(workers), 
[13:20:31.930]                       class = class(workers))
[13:20:31.930]                     stop_if_not(is.finite(workers), workers >= 
[13:20:31.930]                       1L)
[13:20:31.930]                     if ((workers == 1L && !inherits(workers, 
[13:20:31.930]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:31.930]                       if (default_workers) 
[13:20:31.930]                         supportsMulticore(warn = TRUE)
[13:20:31.930]                       return(sequential(..., envir = envir))
[13:20:31.930]                     }
[13:20:31.930]                     oopts <- options(mc.cores = workers)
[13:20:31.930]                     on.exit(options(oopts))
[13:20:31.930]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:31.930]                       envir = envir)
[13:20:31.930]                     if (!future$lazy) 
[13:20:31.930]                       future <- run(future)
[13:20:31.930]                     invisible(future)
[13:20:31.930]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:31.930]                 }
[13:20:31.930]             }
[13:20:31.930]         }
[13:20:31.930]     })
[13:20:31.930]     if (TRUE) {
[13:20:31.930]         base::sink(type = "output", split = FALSE)
[13:20:31.930]         if (TRUE) {
[13:20:31.930]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:31.930]         }
[13:20:31.930]         else {
[13:20:31.930]             ...future.result["stdout"] <- base::list(NULL)
[13:20:31.930]         }
[13:20:31.930]         base::close(...future.stdout)
[13:20:31.930]         ...future.stdout <- NULL
[13:20:31.930]     }
[13:20:31.930]     ...future.result$conditions <- ...future.conditions
[13:20:31.930]     ...future.result$finished <- base::Sys.time()
[13:20:31.930]     ...future.result
[13:20:31.930] }
[13:20:31.932] assign_globals() ...
[13:20:31.933] List of 2
[13:20:31.933]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[13:20:31.933]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:31.933]  - attr(*, "where")=List of 2
[13:20:31.933]   ..$ weight:<environment: R_EmptyEnv> 
[13:20:31.933]   ..$ group :<environment: R_EmptyEnv> 
[13:20:31.933]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:31.933]  - attr(*, "resolved")= logi FALSE
[13:20:31.933]  - attr(*, "total_size")= num 896
[13:20:31.933]  - attr(*, "already-done")= logi TRUE
[13:20:31.940] - copied ‘weight’ to environment
[13:20:31.940] - copied ‘group’ to environment
[13:20:31.940] assign_globals() ... done
[13:20:31.941] requestCore(): workers = 2
[13:20:31.943] MulticoreFuture started
[13:20:31.943] - Launch lazy future ... done
[13:20:31.944] run() for ‘MulticoreFuture’ ... done
[13:20:31.945] plan(): Setting new future strategy stack:
[13:20:31.945] List of future strategies:
[13:20:31.945] 1. sequential:
[13:20:31.945]    - args: function (..., envir = parent.frame())
[13:20:31.945]    - tweaked: FALSE
[13:20:31.945]    - call: NULL
[13:20:31.946] plan(): nbrOfWorkers() = 1
[13:20:31.950] plan(): Setting new future strategy stack:
[13:20:31.950] List of future strategies:
[13:20:31.950] 1. multicore:
[13:20:31.950]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:31.950]    - tweaked: FALSE
[13:20:31.950]    - call: plan(strategy)
[13:20:31.955] plan(): nbrOfWorkers() = 2

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[13:20:31.961] getGlobalsAndPackages() ...
[13:20:31.961] Searching for globals...
[13:20:31.963] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:20:31.963] Searching for globals ... DONE
[13:20:31.963] Resolving globals: FALSE
[13:20:31.964] The total size of the 2 globals is 896 bytes (896 bytes)
[13:20:31.964] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:20:31.965] - globals: [2] ‘weight’, ‘group’
[13:20:31.965] - packages: [1] ‘stats’
[13:20:31.965] getGlobalsAndPackages() ... DONE
[13:20:31.965] run() for ‘Future’ ...
[13:20:31.965] - state: ‘created’
[13:20:31.966] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:31.970] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:31.970] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:31.970]   - Field: ‘label’
[13:20:31.970]   - Field: ‘local’
[13:20:31.970]   - Field: ‘owner’
[13:20:31.970]   - Field: ‘envir’
[13:20:31.971]   - Field: ‘workers’
[13:20:31.971]   - Field: ‘packages’
[13:20:31.971]   - Field: ‘gc’
[13:20:31.971]   - Field: ‘job’
[13:20:31.971]   - Field: ‘conditions’
[13:20:31.971]   - Field: ‘expr’
[13:20:31.971]   - Field: ‘uuid’
[13:20:31.971]   - Field: ‘seed’
[13:20:31.972]   - Field: ‘version’
[13:20:31.972]   - Field: ‘result’
[13:20:31.972]   - Field: ‘asynchronous’
[13:20:31.972]   - Field: ‘calls’
[13:20:31.972]   - Field: ‘globals’
[13:20:31.972]   - Field: ‘stdout’
[13:20:31.972]   - Field: ‘earlySignal’
[13:20:31.972]   - Field: ‘lazy’
[13:20:31.972]   - Field: ‘state’
[13:20:31.973] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:31.973] - Launch lazy future ...
[13:20:31.973] Packages needed by the future expression (n = 1): ‘stats’
[13:20:31.973] Packages needed by future strategies (n = 0): <none>
[13:20:31.974] {
[13:20:31.974]     {
[13:20:31.974]         {
[13:20:31.974]             ...future.startTime <- base::Sys.time()
[13:20:31.974]             {
[13:20:31.974]                 {
[13:20:31.974]                   {
[13:20:31.974]                     {
[13:20:31.974]                       {
[13:20:31.974]                         base::local({
[13:20:31.974]                           has_future <- base::requireNamespace("future", 
[13:20:31.974]                             quietly = TRUE)
[13:20:31.974]                           if (has_future) {
[13:20:31.974]                             ns <- base::getNamespace("future")
[13:20:31.974]                             version <- ns[[".package"]][["version"]]
[13:20:31.974]                             if (is.null(version)) 
[13:20:31.974]                               version <- utils::packageVersion("future")
[13:20:31.974]                           }
[13:20:31.974]                           else {
[13:20:31.974]                             version <- NULL
[13:20:31.974]                           }
[13:20:31.974]                           if (!has_future || version < "1.8.0") {
[13:20:31.974]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:31.974]                               "", base::R.version$version.string), 
[13:20:31.974]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:31.974]                                 base::R.version$platform, 8 * 
[13:20:31.974]                                   base::.Machine$sizeof.pointer), 
[13:20:31.974]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:31.974]                                 "release", "version")], collapse = " "), 
[13:20:31.974]                               hostname = base::Sys.info()[["nodename"]])
[13:20:31.974]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:31.974]                               info)
[13:20:31.974]                             info <- base::paste(info, collapse = "; ")
[13:20:31.974]                             if (!has_future) {
[13:20:31.974]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:31.974]                                 info)
[13:20:31.974]                             }
[13:20:31.974]                             else {
[13:20:31.974]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:31.974]                                 info, version)
[13:20:31.974]                             }
[13:20:31.974]                             base::stop(msg)
[13:20:31.974]                           }
[13:20:31.974]                         })
[13:20:31.974]                       }
[13:20:31.974]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:31.974]                       base::options(mc.cores = 1L)
[13:20:31.974]                     }
[13:20:31.974]                     base::local({
[13:20:31.974]                       for (pkg in "stats") {
[13:20:31.974]                         base::loadNamespace(pkg)
[13:20:31.974]                         base::library(pkg, character.only = TRUE)
[13:20:31.974]                       }
[13:20:31.974]                     })
[13:20:31.974]                   }
[13:20:31.974]                   options(future.plan = NULL)
[13:20:31.974]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:31.974]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:31.974]                 }
[13:20:31.974]                 ...future.workdir <- getwd()
[13:20:31.974]             }
[13:20:31.974]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:31.974]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:31.974]         }
[13:20:31.974]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:31.974]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:31.974]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:31.974]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:31.974]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:31.974]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:31.974]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:31.974]             base::names(...future.oldOptions))
[13:20:31.974]     }
[13:20:31.974]     if (FALSE) {
[13:20:31.974]     }
[13:20:31.974]     else {
[13:20:31.974]         if (TRUE) {
[13:20:31.974]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:31.974]                 open = "w")
[13:20:31.974]         }
[13:20:31.974]         else {
[13:20:31.974]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:31.974]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:31.974]         }
[13:20:31.974]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:31.974]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:31.974]             base::sink(type = "output", split = FALSE)
[13:20:31.974]             base::close(...future.stdout)
[13:20:31.974]         }, add = TRUE)
[13:20:31.974]     }
[13:20:31.974]     ...future.frame <- base::sys.nframe()
[13:20:31.974]     ...future.conditions <- base::list()
[13:20:31.974]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:31.974]     if (FALSE) {
[13:20:31.974]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:31.974]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:31.974]     }
[13:20:31.974]     ...future.result <- base::tryCatch({
[13:20:31.974]         base::withCallingHandlers({
[13:20:31.974]             ...future.value <- base::withVisible(base::local({
[13:20:31.974]                 withCallingHandlers({
[13:20:31.974]                   {
[13:20:31.974]                     lm(weight ~ group - 1)
[13:20:31.974]                   }
[13:20:31.974]                 }, immediateCondition = function(cond) {
[13:20:31.974]                   save_rds <- function (object, pathname, ...) 
[13:20:31.974]                   {
[13:20:31.974]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:31.974]                     if (file_test("-f", pathname_tmp)) {
[13:20:31.974]                       fi_tmp <- file.info(pathname_tmp)
[13:20:31.974]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:31.974]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:31.974]                         fi_tmp[["mtime"]])
[13:20:31.974]                     }
[13:20:31.974]                     tryCatch({
[13:20:31.974]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:31.974]                     }, error = function(ex) {
[13:20:31.974]                       msg <- conditionMessage(ex)
[13:20:31.974]                       fi_tmp <- file.info(pathname_tmp)
[13:20:31.974]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:31.974]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:31.974]                         fi_tmp[["mtime"]], msg)
[13:20:31.974]                       ex$message <- msg
[13:20:31.974]                       stop(ex)
[13:20:31.974]                     })
[13:20:31.974]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:31.974]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:31.974]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:31.974]                       fi_tmp <- file.info(pathname_tmp)
[13:20:31.974]                       fi <- file.info(pathname)
[13:20:31.974]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:31.974]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:31.974]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:31.974]                         fi[["size"]], fi[["mtime"]])
[13:20:31.974]                       stop(msg)
[13:20:31.974]                     }
[13:20:31.974]                     invisible(pathname)
[13:20:31.974]                   }
[13:20:31.974]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:31.974]                     rootPath = tempdir()) 
[13:20:31.974]                   {
[13:20:31.974]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:31.974]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:31.974]                       tmpdir = path, fileext = ".rds")
[13:20:31.974]                     save_rds(obj, file)
[13:20:31.974]                   }
[13:20:31.974]                   saveImmediateCondition(cond, path = "/tmp/Rtmpnh0Esg/.future/immediateConditions")
[13:20:31.974]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:31.974]                   {
[13:20:31.974]                     inherits <- base::inherits
[13:20:31.974]                     invokeRestart <- base::invokeRestart
[13:20:31.974]                     is.null <- base::is.null
[13:20:31.974]                     muffled <- FALSE
[13:20:31.974]                     if (inherits(cond, "message")) {
[13:20:31.974]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:31.974]                       if (muffled) 
[13:20:31.974]                         invokeRestart("muffleMessage")
[13:20:31.974]                     }
[13:20:31.974]                     else if (inherits(cond, "warning")) {
[13:20:31.974]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:31.974]                       if (muffled) 
[13:20:31.974]                         invokeRestart("muffleWarning")
[13:20:31.974]                     }
[13:20:31.974]                     else if (inherits(cond, "condition")) {
[13:20:31.974]                       if (!is.null(pattern)) {
[13:20:31.974]                         computeRestarts <- base::computeRestarts
[13:20:31.974]                         grepl <- base::grepl
[13:20:31.974]                         restarts <- computeRestarts(cond)
[13:20:31.974]                         for (restart in restarts) {
[13:20:31.974]                           name <- restart$name
[13:20:31.974]                           if (is.null(name)) 
[13:20:31.974]                             next
[13:20:31.974]                           if (!grepl(pattern, name)) 
[13:20:31.974]                             next
[13:20:31.974]                           invokeRestart(restart)
[13:20:31.974]                           muffled <- TRUE
[13:20:31.974]                           break
[13:20:31.974]                         }
[13:20:31.974]                       }
[13:20:31.974]                     }
[13:20:31.974]                     invisible(muffled)
[13:20:31.974]                   }
[13:20:31.974]                   muffleCondition(cond)
[13:20:31.974]                 })
[13:20:31.974]             }))
[13:20:31.974]             future::FutureResult(value = ...future.value$value, 
[13:20:31.974]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:31.974]                   ...future.rng), globalenv = if (FALSE) 
[13:20:31.974]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:31.974]                     ...future.globalenv.names))
[13:20:31.974]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:31.974]         }, condition = base::local({
[13:20:31.974]             c <- base::c
[13:20:31.974]             inherits <- base::inherits
[13:20:31.974]             invokeRestart <- base::invokeRestart
[13:20:31.974]             length <- base::length
[13:20:31.974]             list <- base::list
[13:20:31.974]             seq.int <- base::seq.int
[13:20:31.974]             signalCondition <- base::signalCondition
[13:20:31.974]             sys.calls <- base::sys.calls
[13:20:31.974]             `[[` <- base::`[[`
[13:20:31.974]             `+` <- base::`+`
[13:20:31.974]             `<<-` <- base::`<<-`
[13:20:31.974]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:31.974]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:31.974]                   3L)]
[13:20:31.974]             }
[13:20:31.974]             function(cond) {
[13:20:31.974]                 is_error <- inherits(cond, "error")
[13:20:31.974]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:31.974]                   NULL)
[13:20:31.974]                 if (is_error) {
[13:20:31.974]                   sessionInformation <- function() {
[13:20:31.974]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:31.974]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:31.974]                       search = base::search(), system = base::Sys.info())
[13:20:31.974]                   }
[13:20:31.974]                   ...future.conditions[[length(...future.conditions) + 
[13:20:31.974]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:31.974]                     cond$call), session = sessionInformation(), 
[13:20:31.974]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:31.974]                   signalCondition(cond)
[13:20:31.974]                 }
[13:20:31.974]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:31.974]                 "immediateCondition"))) {
[13:20:31.974]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:31.974]                   ...future.conditions[[length(...future.conditions) + 
[13:20:31.974]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:31.974]                   if (TRUE && !signal) {
[13:20:31.974]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:31.974]                     {
[13:20:31.974]                       inherits <- base::inherits
[13:20:31.974]                       invokeRestart <- base::invokeRestart
[13:20:31.974]                       is.null <- base::is.null
[13:20:31.974]                       muffled <- FALSE
[13:20:31.974]                       if (inherits(cond, "message")) {
[13:20:31.974]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:31.974]                         if (muffled) 
[13:20:31.974]                           invokeRestart("muffleMessage")
[13:20:31.974]                       }
[13:20:31.974]                       else if (inherits(cond, "warning")) {
[13:20:31.974]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:31.974]                         if (muffled) 
[13:20:31.974]                           invokeRestart("muffleWarning")
[13:20:31.974]                       }
[13:20:31.974]                       else if (inherits(cond, "condition")) {
[13:20:31.974]                         if (!is.null(pattern)) {
[13:20:31.974]                           computeRestarts <- base::computeRestarts
[13:20:31.974]                           grepl <- base::grepl
[13:20:31.974]                           restarts <- computeRestarts(cond)
[13:20:31.974]                           for (restart in restarts) {
[13:20:31.974]                             name <- restart$name
[13:20:31.974]                             if (is.null(name)) 
[13:20:31.974]                               next
[13:20:31.974]                             if (!grepl(pattern, name)) 
[13:20:31.974]                               next
[13:20:31.974]                             invokeRestart(restart)
[13:20:31.974]                             muffled <- TRUE
[13:20:31.974]                             break
[13:20:31.974]                           }
[13:20:31.974]                         }
[13:20:31.974]                       }
[13:20:31.974]                       invisible(muffled)
[13:20:31.974]                     }
[13:20:31.974]                     muffleCondition(cond, pattern = "^muffle")
[13:20:31.974]                   }
[13:20:31.974]                 }
[13:20:31.974]                 else {
[13:20:31.974]                   if (TRUE) {
[13:20:31.974]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:31.974]                     {
[13:20:31.974]                       inherits <- base::inherits
[13:20:31.974]                       invokeRestart <- base::invokeRestart
[13:20:31.974]                       is.null <- base::is.null
[13:20:31.974]                       muffled <- FALSE
[13:20:31.974]                       if (inherits(cond, "message")) {
[13:20:31.974]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:31.974]                         if (muffled) 
[13:20:31.974]                           invokeRestart("muffleMessage")
[13:20:31.974]                       }
[13:20:31.974]                       else if (inherits(cond, "warning")) {
[13:20:31.974]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:31.974]                         if (muffled) 
[13:20:31.974]                           invokeRestart("muffleWarning")
[13:20:31.974]                       }
[13:20:31.974]                       else if (inherits(cond, "condition")) {
[13:20:31.974]                         if (!is.null(pattern)) {
[13:20:31.974]                           computeRestarts <- base::computeRestarts
[13:20:31.974]                           grepl <- base::grepl
[13:20:31.974]                           restarts <- computeRestarts(cond)
[13:20:31.974]                           for (restart in restarts) {
[13:20:31.974]                             name <- restart$name
[13:20:31.974]                             if (is.null(name)) 
[13:20:31.974]                               next
[13:20:31.974]                             if (!grepl(pattern, name)) 
[13:20:31.974]                               next
[13:20:31.974]                             invokeRestart(restart)
[13:20:31.974]                             muffled <- TRUE
[13:20:31.974]                             break
[13:20:31.974]                           }
[13:20:31.974]                         }
[13:20:31.974]                       }
[13:20:31.974]                       invisible(muffled)
[13:20:31.974]                     }
[13:20:31.974]                     muffleCondition(cond, pattern = "^muffle")
[13:20:31.974]                   }
[13:20:31.974]                 }
[13:20:31.974]             }
[13:20:31.974]         }))
[13:20:31.974]     }, error = function(ex) {
[13:20:31.974]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:31.974]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:31.974]                 ...future.rng), started = ...future.startTime, 
[13:20:31.974]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:31.974]             version = "1.8"), class = "FutureResult")
[13:20:31.974]     }, finally = {
[13:20:31.974]         if (!identical(...future.workdir, getwd())) 
[13:20:31.974]             setwd(...future.workdir)
[13:20:31.974]         {
[13:20:31.974]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:31.974]                 ...future.oldOptions$nwarnings <- NULL
[13:20:31.974]             }
[13:20:31.974]             base::options(...future.oldOptions)
[13:20:31.974]             if (.Platform$OS.type == "windows") {
[13:20:31.974]                 old_names <- names(...future.oldEnvVars)
[13:20:31.974]                 envs <- base::Sys.getenv()
[13:20:31.974]                 names <- names(envs)
[13:20:31.974]                 common <- intersect(names, old_names)
[13:20:31.974]                 added <- setdiff(names, old_names)
[13:20:31.974]                 removed <- setdiff(old_names, names)
[13:20:31.974]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:31.974]                   envs[common]]
[13:20:31.974]                 NAMES <- toupper(changed)
[13:20:31.974]                 args <- list()
[13:20:31.974]                 for (kk in seq_along(NAMES)) {
[13:20:31.974]                   name <- changed[[kk]]
[13:20:31.974]                   NAME <- NAMES[[kk]]
[13:20:31.974]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.974]                     next
[13:20:31.974]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:31.974]                 }
[13:20:31.974]                 NAMES <- toupper(added)
[13:20:31.974]                 for (kk in seq_along(NAMES)) {
[13:20:31.974]                   name <- added[[kk]]
[13:20:31.974]                   NAME <- NAMES[[kk]]
[13:20:31.974]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.974]                     next
[13:20:31.974]                   args[[name]] <- ""
[13:20:31.974]                 }
[13:20:31.974]                 NAMES <- toupper(removed)
[13:20:31.974]                 for (kk in seq_along(NAMES)) {
[13:20:31.974]                   name <- removed[[kk]]
[13:20:31.974]                   NAME <- NAMES[[kk]]
[13:20:31.974]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:31.974]                     next
[13:20:31.974]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:31.974]                 }
[13:20:31.974]                 if (length(args) > 0) 
[13:20:31.974]                   base::do.call(base::Sys.setenv, args = args)
[13:20:31.974]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:31.974]             }
[13:20:31.974]             else {
[13:20:31.974]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:31.974]             }
[13:20:31.974]             {
[13:20:31.974]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:31.974]                   0L) {
[13:20:31.974]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:31.974]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:31.974]                   base::options(opts)
[13:20:31.974]                 }
[13:20:31.974]                 {
[13:20:31.974]                   {
[13:20:31.974]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:31.974]                     NULL
[13:20:31.974]                   }
[13:20:31.974]                   options(future.plan = NULL)
[13:20:31.974]                   if (is.na(NA_character_)) 
[13:20:31.974]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:31.974]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:31.974]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:31.974]                     envir = parent.frame()) 
[13:20:31.974]                   {
[13:20:31.974]                     default_workers <- missing(workers)
[13:20:31.974]                     if (is.function(workers)) 
[13:20:31.974]                       workers <- workers()
[13:20:31.974]                     workers <- structure(as.integer(workers), 
[13:20:31.974]                       class = class(workers))
[13:20:31.974]                     stop_if_not(is.finite(workers), workers >= 
[13:20:31.974]                       1L)
[13:20:31.974]                     if ((workers == 1L && !inherits(workers, 
[13:20:31.974]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:31.974]                       if (default_workers) 
[13:20:31.974]                         supportsMulticore(warn = TRUE)
[13:20:31.974]                       return(sequential(..., envir = envir))
[13:20:31.974]                     }
[13:20:31.974]                     oopts <- options(mc.cores = workers)
[13:20:31.974]                     on.exit(options(oopts))
[13:20:31.974]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:31.974]                       envir = envir)
[13:20:31.974]                     if (!future$lazy) 
[13:20:31.974]                       future <- run(future)
[13:20:31.974]                     invisible(future)
[13:20:31.974]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:31.974]                 }
[13:20:31.974]             }
[13:20:31.974]         }
[13:20:31.974]     })
[13:20:31.974]     if (TRUE) {
[13:20:31.974]         base::sink(type = "output", split = FALSE)
[13:20:31.974]         if (TRUE) {
[13:20:31.974]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:31.974]         }
[13:20:31.974]         else {
[13:20:31.974]             ...future.result["stdout"] <- base::list(NULL)
[13:20:31.974]         }
[13:20:31.974]         base::close(...future.stdout)
[13:20:31.974]         ...future.stdout <- NULL
[13:20:31.974]     }
[13:20:31.974]     ...future.result$conditions <- ...future.conditions
[13:20:31.974]     ...future.result$finished <- base::Sys.time()
[13:20:31.974]     ...future.result
[13:20:31.974] }
[13:20:31.977] assign_globals() ...
[13:20:31.977] List of 2
[13:20:31.977]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[13:20:31.977]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:31.977]  - attr(*, "where")=List of 2
[13:20:31.977]   ..$ weight:<environment: R_EmptyEnv> 
[13:20:31.977]   ..$ group :<environment: R_EmptyEnv> 
[13:20:31.977]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:31.977]  - attr(*, "resolved")= logi FALSE
[13:20:31.977]  - attr(*, "total_size")= num 896
[13:20:31.977]  - attr(*, "already-done")= logi TRUE
[13:20:31.981] - copied ‘weight’ to environment
[13:20:31.981] - copied ‘group’ to environment
[13:20:31.981] assign_globals() ... done
[13:20:31.981] requestCore(): workers = 2
[13:20:31.983] MulticoreFuture started
[13:20:31.983] - Launch lazy future ... done
[13:20:31.984] run() for ‘MulticoreFuture’ ... done
[13:20:31.985] plan(): Setting new future strategy stack:
[13:20:31.985] List of future strategies:
[13:20:31.985] 1. sequential:
[13:20:31.985]    - args: function (..., envir = parent.frame())
[13:20:31.985]    - tweaked: FALSE
[13:20:31.985]    - call: NULL
[13:20:31.990] plan(): nbrOfWorkers() = 1
[13:20:31.995] plan(): Setting new future strategy stack:
[13:20:31.995] List of future strategies:
[13:20:31.995] 1. multicore:
[13:20:31.995]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:31.995]    - tweaked: FALSE
[13:20:31.995]    - call: plan(strategy)
[13:20:32.000] plan(): nbrOfWorkers() = 2

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[13:20:32.008] getGlobalsAndPackages() ...
[13:20:32.008] Searching for globals...
[13:20:32.011] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:20:32.011] Searching for globals ... DONE
[13:20:32.011] Resolving globals: FALSE
[13:20:32.012] The total size of the 2 globals is 896 bytes (896 bytes)
[13:20:32.012] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:20:32.012] - globals: [2] ‘weight’, ‘group’
[13:20:32.012] - packages: [1] ‘stats’
[13:20:32.013] getGlobalsAndPackages() ... DONE
[13:20:32.013] run() for ‘Future’ ...
[13:20:32.013] - state: ‘created’
[13:20:32.013] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:32.018] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:32.018] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:32.018]   - Field: ‘label’
[13:20:32.018]   - Field: ‘local’
[13:20:32.018]   - Field: ‘owner’
[13:20:32.018]   - Field: ‘envir’
[13:20:32.018]   - Field: ‘workers’
[13:20:32.018]   - Field: ‘packages’
[13:20:32.019]   - Field: ‘gc’
[13:20:32.019]   - Field: ‘job’
[13:20:32.019]   - Field: ‘conditions’
[13:20:32.019]   - Field: ‘expr’
[13:20:32.019]   - Field: ‘uuid’
[13:20:32.019]   - Field: ‘seed’
[13:20:32.019]   - Field: ‘version’
[13:20:32.019]   - Field: ‘result’
[13:20:32.019]   - Field: ‘asynchronous’
[13:20:32.020]   - Field: ‘calls’
[13:20:32.020]   - Field: ‘globals’
[13:20:32.020]   - Field: ‘stdout’
[13:20:32.020]   - Field: ‘earlySignal’
[13:20:32.020]   - Field: ‘lazy’
[13:20:32.020]   - Field: ‘state’
[13:20:32.020] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:32.020] - Launch lazy future ...
[13:20:32.021] Packages needed by the future expression (n = 1): ‘stats’
[13:20:32.021] Packages needed by future strategies (n = 0): <none>
[13:20:32.022] {
[13:20:32.022]     {
[13:20:32.022]         {
[13:20:32.022]             ...future.startTime <- base::Sys.time()
[13:20:32.022]             {
[13:20:32.022]                 {
[13:20:32.022]                   {
[13:20:32.022]                     {
[13:20:32.022]                       {
[13:20:32.022]                         base::local({
[13:20:32.022]                           has_future <- base::requireNamespace("future", 
[13:20:32.022]                             quietly = TRUE)
[13:20:32.022]                           if (has_future) {
[13:20:32.022]                             ns <- base::getNamespace("future")
[13:20:32.022]                             version <- ns[[".package"]][["version"]]
[13:20:32.022]                             if (is.null(version)) 
[13:20:32.022]                               version <- utils::packageVersion("future")
[13:20:32.022]                           }
[13:20:32.022]                           else {
[13:20:32.022]                             version <- NULL
[13:20:32.022]                           }
[13:20:32.022]                           if (!has_future || version < "1.8.0") {
[13:20:32.022]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:32.022]                               "", base::R.version$version.string), 
[13:20:32.022]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:32.022]                                 base::R.version$platform, 8 * 
[13:20:32.022]                                   base::.Machine$sizeof.pointer), 
[13:20:32.022]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:32.022]                                 "release", "version")], collapse = " "), 
[13:20:32.022]                               hostname = base::Sys.info()[["nodename"]])
[13:20:32.022]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:32.022]                               info)
[13:20:32.022]                             info <- base::paste(info, collapse = "; ")
[13:20:32.022]                             if (!has_future) {
[13:20:32.022]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:32.022]                                 info)
[13:20:32.022]                             }
[13:20:32.022]                             else {
[13:20:32.022]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:32.022]                                 info, version)
[13:20:32.022]                             }
[13:20:32.022]                             base::stop(msg)
[13:20:32.022]                           }
[13:20:32.022]                         })
[13:20:32.022]                       }
[13:20:32.022]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:32.022]                       base::options(mc.cores = 1L)
[13:20:32.022]                     }
[13:20:32.022]                     base::local({
[13:20:32.022]                       for (pkg in "stats") {
[13:20:32.022]                         base::loadNamespace(pkg)
[13:20:32.022]                         base::library(pkg, character.only = TRUE)
[13:20:32.022]                       }
[13:20:32.022]                     })
[13:20:32.022]                   }
[13:20:32.022]                   options(future.plan = NULL)
[13:20:32.022]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:32.022]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:32.022]                 }
[13:20:32.022]                 ...future.workdir <- getwd()
[13:20:32.022]             }
[13:20:32.022]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:32.022]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:32.022]         }
[13:20:32.022]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:32.022]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:32.022]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:32.022]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:32.022]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:32.022]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:32.022]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:32.022]             base::names(...future.oldOptions))
[13:20:32.022]     }
[13:20:32.022]     if (FALSE) {
[13:20:32.022]     }
[13:20:32.022]     else {
[13:20:32.022]         if (TRUE) {
[13:20:32.022]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:32.022]                 open = "w")
[13:20:32.022]         }
[13:20:32.022]         else {
[13:20:32.022]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:32.022]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:32.022]         }
[13:20:32.022]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:32.022]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:32.022]             base::sink(type = "output", split = FALSE)
[13:20:32.022]             base::close(...future.stdout)
[13:20:32.022]         }, add = TRUE)
[13:20:32.022]     }
[13:20:32.022]     ...future.frame <- base::sys.nframe()
[13:20:32.022]     ...future.conditions <- base::list()
[13:20:32.022]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:32.022]     if (FALSE) {
[13:20:32.022]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:32.022]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:32.022]     }
[13:20:32.022]     ...future.result <- base::tryCatch({
[13:20:32.022]         base::withCallingHandlers({
[13:20:32.022]             ...future.value <- base::withVisible(base::local({
[13:20:32.022]                 withCallingHandlers({
[13:20:32.022]                   {
[13:20:32.022]                     lm(weight ~ group - 1)
[13:20:32.022]                   }
[13:20:32.022]                 }, immediateCondition = function(cond) {
[13:20:32.022]                   save_rds <- function (object, pathname, ...) 
[13:20:32.022]                   {
[13:20:32.022]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:32.022]                     if (file_test("-f", pathname_tmp)) {
[13:20:32.022]                       fi_tmp <- file.info(pathname_tmp)
[13:20:32.022]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:32.022]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:32.022]                         fi_tmp[["mtime"]])
[13:20:32.022]                     }
[13:20:32.022]                     tryCatch({
[13:20:32.022]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:32.022]                     }, error = function(ex) {
[13:20:32.022]                       msg <- conditionMessage(ex)
[13:20:32.022]                       fi_tmp <- file.info(pathname_tmp)
[13:20:32.022]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:32.022]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:32.022]                         fi_tmp[["mtime"]], msg)
[13:20:32.022]                       ex$message <- msg
[13:20:32.022]                       stop(ex)
[13:20:32.022]                     })
[13:20:32.022]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:32.022]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:32.022]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:32.022]                       fi_tmp <- file.info(pathname_tmp)
[13:20:32.022]                       fi <- file.info(pathname)
[13:20:32.022]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:32.022]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:32.022]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:32.022]                         fi[["size"]], fi[["mtime"]])
[13:20:32.022]                       stop(msg)
[13:20:32.022]                     }
[13:20:32.022]                     invisible(pathname)
[13:20:32.022]                   }
[13:20:32.022]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:32.022]                     rootPath = tempdir()) 
[13:20:32.022]                   {
[13:20:32.022]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:32.022]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:32.022]                       tmpdir = path, fileext = ".rds")
[13:20:32.022]                     save_rds(obj, file)
[13:20:32.022]                   }
[13:20:32.022]                   saveImmediateCondition(cond, path = "/tmp/Rtmpnh0Esg/.future/immediateConditions")
[13:20:32.022]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:32.022]                   {
[13:20:32.022]                     inherits <- base::inherits
[13:20:32.022]                     invokeRestart <- base::invokeRestart
[13:20:32.022]                     is.null <- base::is.null
[13:20:32.022]                     muffled <- FALSE
[13:20:32.022]                     if (inherits(cond, "message")) {
[13:20:32.022]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:32.022]                       if (muffled) 
[13:20:32.022]                         invokeRestart("muffleMessage")
[13:20:32.022]                     }
[13:20:32.022]                     else if (inherits(cond, "warning")) {
[13:20:32.022]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:32.022]                       if (muffled) 
[13:20:32.022]                         invokeRestart("muffleWarning")
[13:20:32.022]                     }
[13:20:32.022]                     else if (inherits(cond, "condition")) {
[13:20:32.022]                       if (!is.null(pattern)) {
[13:20:32.022]                         computeRestarts <- base::computeRestarts
[13:20:32.022]                         grepl <- base::grepl
[13:20:32.022]                         restarts <- computeRestarts(cond)
[13:20:32.022]                         for (restart in restarts) {
[13:20:32.022]                           name <- restart$name
[13:20:32.022]                           if (is.null(name)) 
[13:20:32.022]                             next
[13:20:32.022]                           if (!grepl(pattern, name)) 
[13:20:32.022]                             next
[13:20:32.022]                           invokeRestart(restart)
[13:20:32.022]                           muffled <- TRUE
[13:20:32.022]                           break
[13:20:32.022]                         }
[13:20:32.022]                       }
[13:20:32.022]                     }
[13:20:32.022]                     invisible(muffled)
[13:20:32.022]                   }
[13:20:32.022]                   muffleCondition(cond)
[13:20:32.022]                 })
[13:20:32.022]             }))
[13:20:32.022]             future::FutureResult(value = ...future.value$value, 
[13:20:32.022]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:32.022]                   ...future.rng), globalenv = if (FALSE) 
[13:20:32.022]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:32.022]                     ...future.globalenv.names))
[13:20:32.022]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:32.022]         }, condition = base::local({
[13:20:32.022]             c <- base::c
[13:20:32.022]             inherits <- base::inherits
[13:20:32.022]             invokeRestart <- base::invokeRestart
[13:20:32.022]             length <- base::length
[13:20:32.022]             list <- base::list
[13:20:32.022]             seq.int <- base::seq.int
[13:20:32.022]             signalCondition <- base::signalCondition
[13:20:32.022]             sys.calls <- base::sys.calls
[13:20:32.022]             `[[` <- base::`[[`
[13:20:32.022]             `+` <- base::`+`
[13:20:32.022]             `<<-` <- base::`<<-`
[13:20:32.022]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:32.022]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:32.022]                   3L)]
[13:20:32.022]             }
[13:20:32.022]             function(cond) {
[13:20:32.022]                 is_error <- inherits(cond, "error")
[13:20:32.022]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:32.022]                   NULL)
[13:20:32.022]                 if (is_error) {
[13:20:32.022]                   sessionInformation <- function() {
[13:20:32.022]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:32.022]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:32.022]                       search = base::search(), system = base::Sys.info())
[13:20:32.022]                   }
[13:20:32.022]                   ...future.conditions[[length(...future.conditions) + 
[13:20:32.022]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:32.022]                     cond$call), session = sessionInformation(), 
[13:20:32.022]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:32.022]                   signalCondition(cond)
[13:20:32.022]                 }
[13:20:32.022]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:32.022]                 "immediateCondition"))) {
[13:20:32.022]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:32.022]                   ...future.conditions[[length(...future.conditions) + 
[13:20:32.022]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:32.022]                   if (TRUE && !signal) {
[13:20:32.022]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:32.022]                     {
[13:20:32.022]                       inherits <- base::inherits
[13:20:32.022]                       invokeRestart <- base::invokeRestart
[13:20:32.022]                       is.null <- base::is.null
[13:20:32.022]                       muffled <- FALSE
[13:20:32.022]                       if (inherits(cond, "message")) {
[13:20:32.022]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:32.022]                         if (muffled) 
[13:20:32.022]                           invokeRestart("muffleMessage")
[13:20:32.022]                       }
[13:20:32.022]                       else if (inherits(cond, "warning")) {
[13:20:32.022]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:32.022]                         if (muffled) 
[13:20:32.022]                           invokeRestart("muffleWarning")
[13:20:32.022]                       }
[13:20:32.022]                       else if (inherits(cond, "condition")) {
[13:20:32.022]                         if (!is.null(pattern)) {
[13:20:32.022]                           computeRestarts <- base::computeRestarts
[13:20:32.022]                           grepl <- base::grepl
[13:20:32.022]                           restarts <- computeRestarts(cond)
[13:20:32.022]                           for (restart in restarts) {
[13:20:32.022]                             name <- restart$name
[13:20:32.022]                             if (is.null(name)) 
[13:20:32.022]                               next
[13:20:32.022]                             if (!grepl(pattern, name)) 
[13:20:32.022]                               next
[13:20:32.022]                             invokeRestart(restart)
[13:20:32.022]                             muffled <- TRUE
[13:20:32.022]                             break
[13:20:32.022]                           }
[13:20:32.022]                         }
[13:20:32.022]                       }
[13:20:32.022]                       invisible(muffled)
[13:20:32.022]                     }
[13:20:32.022]                     muffleCondition(cond, pattern = "^muffle")
[13:20:32.022]                   }
[13:20:32.022]                 }
[13:20:32.022]                 else {
[13:20:32.022]                   if (TRUE) {
[13:20:32.022]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:32.022]                     {
[13:20:32.022]                       inherits <- base::inherits
[13:20:32.022]                       invokeRestart <- base::invokeRestart
[13:20:32.022]                       is.null <- base::is.null
[13:20:32.022]                       muffled <- FALSE
[13:20:32.022]                       if (inherits(cond, "message")) {
[13:20:32.022]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:32.022]                         if (muffled) 
[13:20:32.022]                           invokeRestart("muffleMessage")
[13:20:32.022]                       }
[13:20:32.022]                       else if (inherits(cond, "warning")) {
[13:20:32.022]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:32.022]                         if (muffled) 
[13:20:32.022]                           invokeRestart("muffleWarning")
[13:20:32.022]                       }
[13:20:32.022]                       else if (inherits(cond, "condition")) {
[13:20:32.022]                         if (!is.null(pattern)) {
[13:20:32.022]                           computeRestarts <- base::computeRestarts
[13:20:32.022]                           grepl <- base::grepl
[13:20:32.022]                           restarts <- computeRestarts(cond)
[13:20:32.022]                           for (restart in restarts) {
[13:20:32.022]                             name <- restart$name
[13:20:32.022]                             if (is.null(name)) 
[13:20:32.022]                               next
[13:20:32.022]                             if (!grepl(pattern, name)) 
[13:20:32.022]                               next
[13:20:32.022]                             invokeRestart(restart)
[13:20:32.022]                             muffled <- TRUE
[13:20:32.022]                             break
[13:20:32.022]                           }
[13:20:32.022]                         }
[13:20:32.022]                       }
[13:20:32.022]                       invisible(muffled)
[13:20:32.022]                     }
[13:20:32.022]                     muffleCondition(cond, pattern = "^muffle")
[13:20:32.022]                   }
[13:20:32.022]                 }
[13:20:32.022]             }
[13:20:32.022]         }))
[13:20:32.022]     }, error = function(ex) {
[13:20:32.022]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:32.022]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:32.022]                 ...future.rng), started = ...future.startTime, 
[13:20:32.022]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:32.022]             version = "1.8"), class = "FutureResult")
[13:20:32.022]     }, finally = {
[13:20:32.022]         if (!identical(...future.workdir, getwd())) 
[13:20:32.022]             setwd(...future.workdir)
[13:20:32.022]         {
[13:20:32.022]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:32.022]                 ...future.oldOptions$nwarnings <- NULL
[13:20:32.022]             }
[13:20:32.022]             base::options(...future.oldOptions)
[13:20:32.022]             if (.Platform$OS.type == "windows") {
[13:20:32.022]                 old_names <- names(...future.oldEnvVars)
[13:20:32.022]                 envs <- base::Sys.getenv()
[13:20:32.022]                 names <- names(envs)
[13:20:32.022]                 common <- intersect(names, old_names)
[13:20:32.022]                 added <- setdiff(names, old_names)
[13:20:32.022]                 removed <- setdiff(old_names, names)
[13:20:32.022]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:32.022]                   envs[common]]
[13:20:32.022]                 NAMES <- toupper(changed)
[13:20:32.022]                 args <- list()
[13:20:32.022]                 for (kk in seq_along(NAMES)) {
[13:20:32.022]                   name <- changed[[kk]]
[13:20:32.022]                   NAME <- NAMES[[kk]]
[13:20:32.022]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:32.022]                     next
[13:20:32.022]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:32.022]                 }
[13:20:32.022]                 NAMES <- toupper(added)
[13:20:32.022]                 for (kk in seq_along(NAMES)) {
[13:20:32.022]                   name <- added[[kk]]
[13:20:32.022]                   NAME <- NAMES[[kk]]
[13:20:32.022]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:32.022]                     next
[13:20:32.022]                   args[[name]] <- ""
[13:20:32.022]                 }
[13:20:32.022]                 NAMES <- toupper(removed)
[13:20:32.022]                 for (kk in seq_along(NAMES)) {
[13:20:32.022]                   name <- removed[[kk]]
[13:20:32.022]                   NAME <- NAMES[[kk]]
[13:20:32.022]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:32.022]                     next
[13:20:32.022]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:32.022]                 }
[13:20:32.022]                 if (length(args) > 0) 
[13:20:32.022]                   base::do.call(base::Sys.setenv, args = args)
[13:20:32.022]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:32.022]             }
[13:20:32.022]             else {
[13:20:32.022]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:32.022]             }
[13:20:32.022]             {
[13:20:32.022]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:32.022]                   0L) {
[13:20:32.022]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:32.022]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:32.022]                   base::options(opts)
[13:20:32.022]                 }
[13:20:32.022]                 {
[13:20:32.022]                   {
[13:20:32.022]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:32.022]                     NULL
[13:20:32.022]                   }
[13:20:32.022]                   options(future.plan = NULL)
[13:20:32.022]                   if (is.na(NA_character_)) 
[13:20:32.022]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:32.022]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:32.022]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:32.022]                     envir = parent.frame()) 
[13:20:32.022]                   {
[13:20:32.022]                     default_workers <- missing(workers)
[13:20:32.022]                     if (is.function(workers)) 
[13:20:32.022]                       workers <- workers()
[13:20:32.022]                     workers <- structure(as.integer(workers), 
[13:20:32.022]                       class = class(workers))
[13:20:32.022]                     stop_if_not(is.finite(workers), workers >= 
[13:20:32.022]                       1L)
[13:20:32.022]                     if ((workers == 1L && !inherits(workers, 
[13:20:32.022]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:32.022]                       if (default_workers) 
[13:20:32.022]                         supportsMulticore(warn = TRUE)
[13:20:32.022]                       return(sequential(..., envir = envir))
[13:20:32.022]                     }
[13:20:32.022]                     oopts <- options(mc.cores = workers)
[13:20:32.022]                     on.exit(options(oopts))
[13:20:32.022]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:32.022]                       envir = envir)
[13:20:32.022]                     if (!future$lazy) 
[13:20:32.022]                       future <- run(future)
[13:20:32.022]                     invisible(future)
[13:20:32.022]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:32.022]                 }
[13:20:32.022]             }
[13:20:32.022]         }
[13:20:32.022]     })
[13:20:32.022]     if (TRUE) {
[13:20:32.022]         base::sink(type = "output", split = FALSE)
[13:20:32.022]         if (TRUE) {
[13:20:32.022]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:32.022]         }
[13:20:32.022]         else {
[13:20:32.022]             ...future.result["stdout"] <- base::list(NULL)
[13:20:32.022]         }
[13:20:32.022]         base::close(...future.stdout)
[13:20:32.022]         ...future.stdout <- NULL
[13:20:32.022]     }
[13:20:32.022]     ...future.result$conditions <- ...future.conditions
[13:20:32.022]     ...future.result$finished <- base::Sys.time()
[13:20:32.022]     ...future.result
[13:20:32.022] }
[13:20:32.024] assign_globals() ...
[13:20:32.024] List of 2
[13:20:32.024]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[13:20:32.024]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:32.024]  - attr(*, "where")=List of 2
[13:20:32.024]   ..$ weight:<environment: R_EmptyEnv> 
[13:20:32.024]   ..$ group :<environment: R_EmptyEnv> 
[13:20:32.024]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:32.024]  - attr(*, "resolved")= logi FALSE
[13:20:32.024]  - attr(*, "total_size")= num 896
[13:20:32.024]  - attr(*, "already-done")= logi TRUE
[13:20:32.028] - copied ‘weight’ to environment
[13:20:32.028] - copied ‘group’ to environment
[13:20:32.028] assign_globals() ... done
[13:20:32.028] requestCore(): workers = 2
[13:20:32.030] MulticoreFuture started
[13:20:32.031] - Launch lazy future ... done
[13:20:32.031] run() for ‘MulticoreFuture’ ... done
[13:20:32.032] plan(): Setting new future strategy stack:
[13:20:32.032] List of future strategies:
[13:20:32.032] 1. sequential:
[13:20:32.032]    - args: function (..., envir = parent.frame())
[13:20:32.032]    - tweaked: FALSE
[13:20:32.032]    - call: NULL
[13:20:32.033] plan(): nbrOfWorkers() = 1
[13:20:32.036] plan(): Setting new future strategy stack:
[13:20:32.037] List of future strategies:
[13:20:32.037] 1. multicore:
[13:20:32.037]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:32.037]    - tweaked: FALSE
[13:20:32.037]    - call: plan(strategy)
[13:20:32.042] plan(): nbrOfWorkers() = 2

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[13:20:32.047] getGlobalsAndPackages() ...
[13:20:32.047] Searching for globals...
[13:20:32.052] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:20:32.052] Searching for globals ... DONE
[13:20:32.052] Resolving globals: FALSE
[13:20:32.053] The total size of the 2 globals is 896 bytes (896 bytes)
[13:20:32.054] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:20:32.054] - globals: [2] ‘weight’, ‘group’
[13:20:32.054] - packages: [1] ‘stats’
[13:20:32.054] getGlobalsAndPackages() ... DONE
[13:20:32.055] run() for ‘Future’ ...
[13:20:32.055] - state: ‘created’
[13:20:32.055] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:32.059] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:32.059] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:32.060]   - Field: ‘label’
[13:20:32.060]   - Field: ‘local’
[13:20:32.060]   - Field: ‘owner’
[13:20:32.060]   - Field: ‘envir’
[13:20:32.060]   - Field: ‘workers’
[13:20:32.060]   - Field: ‘packages’
[13:20:32.061]   - Field: ‘gc’
[13:20:32.061]   - Field: ‘job’
[13:20:32.061]   - Field: ‘conditions’
[13:20:32.061]   - Field: ‘expr’
[13:20:32.061]   - Field: ‘uuid’
[13:20:32.061]   - Field: ‘seed’
[13:20:32.061]   - Field: ‘version’
[13:20:32.061]   - Field: ‘result’
[13:20:32.062]   - Field: ‘asynchronous’
[13:20:32.062]   - Field: ‘calls’
[13:20:32.062]   - Field: ‘globals’
[13:20:32.062]   - Field: ‘stdout’
[13:20:32.062]   - Field: ‘earlySignal’
[13:20:32.062]   - Field: ‘lazy’
[13:20:32.062]   - Field: ‘state’
[13:20:32.062] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:32.062] - Launch lazy future ...
[13:20:32.063] Packages needed by the future expression (n = 1): ‘stats’
[13:20:32.063] Packages needed by future strategies (n = 0): <none>
[13:20:32.064] {
[13:20:32.064]     {
[13:20:32.064]         {
[13:20:32.064]             ...future.startTime <- base::Sys.time()
[13:20:32.064]             {
[13:20:32.064]                 {
[13:20:32.064]                   {
[13:20:32.064]                     {
[13:20:32.064]                       {
[13:20:32.064]                         base::local({
[13:20:32.064]                           has_future <- base::requireNamespace("future", 
[13:20:32.064]                             quietly = TRUE)
[13:20:32.064]                           if (has_future) {
[13:20:32.064]                             ns <- base::getNamespace("future")
[13:20:32.064]                             version <- ns[[".package"]][["version"]]
[13:20:32.064]                             if (is.null(version)) 
[13:20:32.064]                               version <- utils::packageVersion("future")
[13:20:32.064]                           }
[13:20:32.064]                           else {
[13:20:32.064]                             version <- NULL
[13:20:32.064]                           }
[13:20:32.064]                           if (!has_future || version < "1.8.0") {
[13:20:32.064]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:32.064]                               "", base::R.version$version.string), 
[13:20:32.064]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:32.064]                                 base::R.version$platform, 8 * 
[13:20:32.064]                                   base::.Machine$sizeof.pointer), 
[13:20:32.064]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:32.064]                                 "release", "version")], collapse = " "), 
[13:20:32.064]                               hostname = base::Sys.info()[["nodename"]])
[13:20:32.064]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:32.064]                               info)
[13:20:32.064]                             info <- base::paste(info, collapse = "; ")
[13:20:32.064]                             if (!has_future) {
[13:20:32.064]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:32.064]                                 info)
[13:20:32.064]                             }
[13:20:32.064]                             else {
[13:20:32.064]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:32.064]                                 info, version)
[13:20:32.064]                             }
[13:20:32.064]                             base::stop(msg)
[13:20:32.064]                           }
[13:20:32.064]                         })
[13:20:32.064]                       }
[13:20:32.064]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:32.064]                       base::options(mc.cores = 1L)
[13:20:32.064]                     }
[13:20:32.064]                     base::local({
[13:20:32.064]                       for (pkg in "stats") {
[13:20:32.064]                         base::loadNamespace(pkg)
[13:20:32.064]                         base::library(pkg, character.only = TRUE)
[13:20:32.064]                       }
[13:20:32.064]                     })
[13:20:32.064]                   }
[13:20:32.064]                   options(future.plan = NULL)
[13:20:32.064]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:32.064]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:32.064]                 }
[13:20:32.064]                 ...future.workdir <- getwd()
[13:20:32.064]             }
[13:20:32.064]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:32.064]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:32.064]         }
[13:20:32.064]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:32.064]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:32.064]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:32.064]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:32.064]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:32.064]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:32.064]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:32.064]             base::names(...future.oldOptions))
[13:20:32.064]     }
[13:20:32.064]     if (FALSE) {
[13:20:32.064]     }
[13:20:32.064]     else {
[13:20:32.064]         if (TRUE) {
[13:20:32.064]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:32.064]                 open = "w")
[13:20:32.064]         }
[13:20:32.064]         else {
[13:20:32.064]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:32.064]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:32.064]         }
[13:20:32.064]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:32.064]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:32.064]             base::sink(type = "output", split = FALSE)
[13:20:32.064]             base::close(...future.stdout)
[13:20:32.064]         }, add = TRUE)
[13:20:32.064]     }
[13:20:32.064]     ...future.frame <- base::sys.nframe()
[13:20:32.064]     ...future.conditions <- base::list()
[13:20:32.064]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:32.064]     if (FALSE) {
[13:20:32.064]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:32.064]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:32.064]     }
[13:20:32.064]     ...future.result <- base::tryCatch({
[13:20:32.064]         base::withCallingHandlers({
[13:20:32.064]             ...future.value <- base::withVisible(base::local({
[13:20:32.064]                 withCallingHandlers({
[13:20:32.064]                   {
[13:20:32.064]                     lm(weight ~ group - 1)
[13:20:32.064]                   }
[13:20:32.064]                 }, immediateCondition = function(cond) {
[13:20:32.064]                   save_rds <- function (object, pathname, ...) 
[13:20:32.064]                   {
[13:20:32.064]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:32.064]                     if (file_test("-f", pathname_tmp)) {
[13:20:32.064]                       fi_tmp <- file.info(pathname_tmp)
[13:20:32.064]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:32.064]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:32.064]                         fi_tmp[["mtime"]])
[13:20:32.064]                     }
[13:20:32.064]                     tryCatch({
[13:20:32.064]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:32.064]                     }, error = function(ex) {
[13:20:32.064]                       msg <- conditionMessage(ex)
[13:20:32.064]                       fi_tmp <- file.info(pathname_tmp)
[13:20:32.064]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:32.064]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:32.064]                         fi_tmp[["mtime"]], msg)
[13:20:32.064]                       ex$message <- msg
[13:20:32.064]                       stop(ex)
[13:20:32.064]                     })
[13:20:32.064]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:32.064]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:32.064]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:32.064]                       fi_tmp <- file.info(pathname_tmp)
[13:20:32.064]                       fi <- file.info(pathname)
[13:20:32.064]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:32.064]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:32.064]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:32.064]                         fi[["size"]], fi[["mtime"]])
[13:20:32.064]                       stop(msg)
[13:20:32.064]                     }
[13:20:32.064]                     invisible(pathname)
[13:20:32.064]                   }
[13:20:32.064]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:32.064]                     rootPath = tempdir()) 
[13:20:32.064]                   {
[13:20:32.064]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:32.064]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:32.064]                       tmpdir = path, fileext = ".rds")
[13:20:32.064]                     save_rds(obj, file)
[13:20:32.064]                   }
[13:20:32.064]                   saveImmediateCondition(cond, path = "/tmp/Rtmpnh0Esg/.future/immediateConditions")
[13:20:32.064]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:32.064]                   {
[13:20:32.064]                     inherits <- base::inherits
[13:20:32.064]                     invokeRestart <- base::invokeRestart
[13:20:32.064]                     is.null <- base::is.null
[13:20:32.064]                     muffled <- FALSE
[13:20:32.064]                     if (inherits(cond, "message")) {
[13:20:32.064]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:32.064]                       if (muffled) 
[13:20:32.064]                         invokeRestart("muffleMessage")
[13:20:32.064]                     }
[13:20:32.064]                     else if (inherits(cond, "warning")) {
[13:20:32.064]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:32.064]                       if (muffled) 
[13:20:32.064]                         invokeRestart("muffleWarning")
[13:20:32.064]                     }
[13:20:32.064]                     else if (inherits(cond, "condition")) {
[13:20:32.064]                       if (!is.null(pattern)) {
[13:20:32.064]                         computeRestarts <- base::computeRestarts
[13:20:32.064]                         grepl <- base::grepl
[13:20:32.064]                         restarts <- computeRestarts(cond)
[13:20:32.064]                         for (restart in restarts) {
[13:20:32.064]                           name <- restart$name
[13:20:32.064]                           if (is.null(name)) 
[13:20:32.064]                             next
[13:20:32.064]                           if (!grepl(pattern, name)) 
[13:20:32.064]                             next
[13:20:32.064]                           invokeRestart(restart)
[13:20:32.064]                           muffled <- TRUE
[13:20:32.064]                           break
[13:20:32.064]                         }
[13:20:32.064]                       }
[13:20:32.064]                     }
[13:20:32.064]                     invisible(muffled)
[13:20:32.064]                   }
[13:20:32.064]                   muffleCondition(cond)
[13:20:32.064]                 })
[13:20:32.064]             }))
[13:20:32.064]             future::FutureResult(value = ...future.value$value, 
[13:20:32.064]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:32.064]                   ...future.rng), globalenv = if (FALSE) 
[13:20:32.064]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:32.064]                     ...future.globalenv.names))
[13:20:32.064]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:32.064]         }, condition = base::local({
[13:20:32.064]             c <- base::c
[13:20:32.064]             inherits <- base::inherits
[13:20:32.064]             invokeRestart <- base::invokeRestart
[13:20:32.064]             length <- base::length
[13:20:32.064]             list <- base::list
[13:20:32.064]             seq.int <- base::seq.int
[13:20:32.064]             signalCondition <- base::signalCondition
[13:20:32.064]             sys.calls <- base::sys.calls
[13:20:32.064]             `[[` <- base::`[[`
[13:20:32.064]             `+` <- base::`+`
[13:20:32.064]             `<<-` <- base::`<<-`
[13:20:32.064]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:32.064]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:32.064]                   3L)]
[13:20:32.064]             }
[13:20:32.064]             function(cond) {
[13:20:32.064]                 is_error <- inherits(cond, "error")
[13:20:32.064]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:32.064]                   NULL)
[13:20:32.064]                 if (is_error) {
[13:20:32.064]                   sessionInformation <- function() {
[13:20:32.064]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:32.064]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:32.064]                       search = base::search(), system = base::Sys.info())
[13:20:32.064]                   }
[13:20:32.064]                   ...future.conditions[[length(...future.conditions) + 
[13:20:32.064]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:32.064]                     cond$call), session = sessionInformation(), 
[13:20:32.064]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:32.064]                   signalCondition(cond)
[13:20:32.064]                 }
[13:20:32.064]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:32.064]                 "immediateCondition"))) {
[13:20:32.064]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:32.064]                   ...future.conditions[[length(...future.conditions) + 
[13:20:32.064]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:32.064]                   if (TRUE && !signal) {
[13:20:32.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:32.064]                     {
[13:20:32.064]                       inherits <- base::inherits
[13:20:32.064]                       invokeRestart <- base::invokeRestart
[13:20:32.064]                       is.null <- base::is.null
[13:20:32.064]                       muffled <- FALSE
[13:20:32.064]                       if (inherits(cond, "message")) {
[13:20:32.064]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:32.064]                         if (muffled) 
[13:20:32.064]                           invokeRestart("muffleMessage")
[13:20:32.064]                       }
[13:20:32.064]                       else if (inherits(cond, "warning")) {
[13:20:32.064]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:32.064]                         if (muffled) 
[13:20:32.064]                           invokeRestart("muffleWarning")
[13:20:32.064]                       }
[13:20:32.064]                       else if (inherits(cond, "condition")) {
[13:20:32.064]                         if (!is.null(pattern)) {
[13:20:32.064]                           computeRestarts <- base::computeRestarts
[13:20:32.064]                           grepl <- base::grepl
[13:20:32.064]                           restarts <- computeRestarts(cond)
[13:20:32.064]                           for (restart in restarts) {
[13:20:32.064]                             name <- restart$name
[13:20:32.064]                             if (is.null(name)) 
[13:20:32.064]                               next
[13:20:32.064]                             if (!grepl(pattern, name)) 
[13:20:32.064]                               next
[13:20:32.064]                             invokeRestart(restart)
[13:20:32.064]                             muffled <- TRUE
[13:20:32.064]                             break
[13:20:32.064]                           }
[13:20:32.064]                         }
[13:20:32.064]                       }
[13:20:32.064]                       invisible(muffled)
[13:20:32.064]                     }
[13:20:32.064]                     muffleCondition(cond, pattern = "^muffle")
[13:20:32.064]                   }
[13:20:32.064]                 }
[13:20:32.064]                 else {
[13:20:32.064]                   if (TRUE) {
[13:20:32.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:32.064]                     {
[13:20:32.064]                       inherits <- base::inherits
[13:20:32.064]                       invokeRestart <- base::invokeRestart
[13:20:32.064]                       is.null <- base::is.null
[13:20:32.064]                       muffled <- FALSE
[13:20:32.064]                       if (inherits(cond, "message")) {
[13:20:32.064]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:32.064]                         if (muffled) 
[13:20:32.064]                           invokeRestart("muffleMessage")
[13:20:32.064]                       }
[13:20:32.064]                       else if (inherits(cond, "warning")) {
[13:20:32.064]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:32.064]                         if (muffled) 
[13:20:32.064]                           invokeRestart("muffleWarning")
[13:20:32.064]                       }
[13:20:32.064]                       else if (inherits(cond, "condition")) {
[13:20:32.064]                         if (!is.null(pattern)) {
[13:20:32.064]                           computeRestarts <- base::computeRestarts
[13:20:32.064]                           grepl <- base::grepl
[13:20:32.064]                           restarts <- computeRestarts(cond)
[13:20:32.064]                           for (restart in restarts) {
[13:20:32.064]                             name <- restart$name
[13:20:32.064]                             if (is.null(name)) 
[13:20:32.064]                               next
[13:20:32.064]                             if (!grepl(pattern, name)) 
[13:20:32.064]                               next
[13:20:32.064]                             invokeRestart(restart)
[13:20:32.064]                             muffled <- TRUE
[13:20:32.064]                             break
[13:20:32.064]                           }
[13:20:32.064]                         }
[13:20:32.064]                       }
[13:20:32.064]                       invisible(muffled)
[13:20:32.064]                     }
[13:20:32.064]                     muffleCondition(cond, pattern = "^muffle")
[13:20:32.064]                   }
[13:20:32.064]                 }
[13:20:32.064]             }
[13:20:32.064]         }))
[13:20:32.064]     }, error = function(ex) {
[13:20:32.064]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:32.064]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:32.064]                 ...future.rng), started = ...future.startTime, 
[13:20:32.064]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:32.064]             version = "1.8"), class = "FutureResult")
[13:20:32.064]     }, finally = {
[13:20:32.064]         if (!identical(...future.workdir, getwd())) 
[13:20:32.064]             setwd(...future.workdir)
[13:20:32.064]         {
[13:20:32.064]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:32.064]                 ...future.oldOptions$nwarnings <- NULL
[13:20:32.064]             }
[13:20:32.064]             base::options(...future.oldOptions)
[13:20:32.064]             if (.Platform$OS.type == "windows") {
[13:20:32.064]                 old_names <- names(...future.oldEnvVars)
[13:20:32.064]                 envs <- base::Sys.getenv()
[13:20:32.064]                 names <- names(envs)
[13:20:32.064]                 common <- intersect(names, old_names)
[13:20:32.064]                 added <- setdiff(names, old_names)
[13:20:32.064]                 removed <- setdiff(old_names, names)
[13:20:32.064]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:32.064]                   envs[common]]
[13:20:32.064]                 NAMES <- toupper(changed)
[13:20:32.064]                 args <- list()
[13:20:32.064]                 for (kk in seq_along(NAMES)) {
[13:20:32.064]                   name <- changed[[kk]]
[13:20:32.064]                   NAME <- NAMES[[kk]]
[13:20:32.064]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:32.064]                     next
[13:20:32.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:32.064]                 }
[13:20:32.064]                 NAMES <- toupper(added)
[13:20:32.064]                 for (kk in seq_along(NAMES)) {
[13:20:32.064]                   name <- added[[kk]]
[13:20:32.064]                   NAME <- NAMES[[kk]]
[13:20:32.064]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:32.064]                     next
[13:20:32.064]                   args[[name]] <- ""
[13:20:32.064]                 }
[13:20:32.064]                 NAMES <- toupper(removed)
[13:20:32.064]                 for (kk in seq_along(NAMES)) {
[13:20:32.064]                   name <- removed[[kk]]
[13:20:32.064]                   NAME <- NAMES[[kk]]
[13:20:32.064]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:32.064]                     next
[13:20:32.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:32.064]                 }
[13:20:32.064]                 if (length(args) > 0) 
[13:20:32.064]                   base::do.call(base::Sys.setenv, args = args)
[13:20:32.064]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:32.064]             }
[13:20:32.064]             else {
[13:20:32.064]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:32.064]             }
[13:20:32.064]             {
[13:20:32.064]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:32.064]                   0L) {
[13:20:32.064]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:32.064]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:32.064]                   base::options(opts)
[13:20:32.064]                 }
[13:20:32.064]                 {
[13:20:32.064]                   {
[13:20:32.064]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:32.064]                     NULL
[13:20:32.064]                   }
[13:20:32.064]                   options(future.plan = NULL)
[13:20:32.064]                   if (is.na(NA_character_)) 
[13:20:32.064]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:32.064]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:32.064]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:32.064]                     envir = parent.frame()) 
[13:20:32.064]                   {
[13:20:32.064]                     default_workers <- missing(workers)
[13:20:32.064]                     if (is.function(workers)) 
[13:20:32.064]                       workers <- workers()
[13:20:32.064]                     workers <- structure(as.integer(workers), 
[13:20:32.064]                       class = class(workers))
[13:20:32.064]                     stop_if_not(is.finite(workers), workers >= 
[13:20:32.064]                       1L)
[13:20:32.064]                     if ((workers == 1L && !inherits(workers, 
[13:20:32.064]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:32.064]                       if (default_workers) 
[13:20:32.064]                         supportsMulticore(warn = TRUE)
[13:20:32.064]                       return(sequential(..., envir = envir))
[13:20:32.064]                     }
[13:20:32.064]                     oopts <- options(mc.cores = workers)
[13:20:32.064]                     on.exit(options(oopts))
[13:20:32.064]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:32.064]                       envir = envir)
[13:20:32.064]                     if (!future$lazy) 
[13:20:32.064]                       future <- run(future)
[13:20:32.064]                     invisible(future)
[13:20:32.064]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:32.064]                 }
[13:20:32.064]             }
[13:20:32.064]         }
[13:20:32.064]     })
[13:20:32.064]     if (TRUE) {
[13:20:32.064]         base::sink(type = "output", split = FALSE)
[13:20:32.064]         if (TRUE) {
[13:20:32.064]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:32.064]         }
[13:20:32.064]         else {
[13:20:32.064]             ...future.result["stdout"] <- base::list(NULL)
[13:20:32.064]         }
[13:20:32.064]         base::close(...future.stdout)
[13:20:32.064]         ...future.stdout <- NULL
[13:20:32.064]     }
[13:20:32.064]     ...future.result$conditions <- ...future.conditions
[13:20:32.064]     ...future.result$finished <- base::Sys.time()
[13:20:32.064]     ...future.result
[13:20:32.064] }
[13:20:32.066] assign_globals() ...
[13:20:32.066] List of 2
[13:20:32.066]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[13:20:32.066]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:32.066]  - attr(*, "where")=List of 2
[13:20:32.066]   ..$ weight:<environment: R_EmptyEnv> 
[13:20:32.066]   ..$ group :<environment: R_EmptyEnv> 
[13:20:32.066]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:32.066]  - attr(*, "resolved")= logi FALSE
[13:20:32.066]  - attr(*, "total_size")= num 896
[13:20:32.066]  - attr(*, "already-done")= logi TRUE
[13:20:32.070] - copied ‘weight’ to environment
[13:20:32.070] - copied ‘group’ to environment
[13:20:32.071] assign_globals() ... done
[13:20:32.071] requestCore(): workers = 2
[13:20:32.073] MulticoreFuture started
[13:20:32.073] - Launch lazy future ... done
[13:20:32.073] run() for ‘MulticoreFuture’ ... done
[13:20:32.074] plan(): Setting new future strategy stack:
[13:20:32.075] List of future strategies:
[13:20:32.075] 1. sequential:
[13:20:32.075]    - args: function (..., envir = parent.frame())
[13:20:32.075]    - tweaked: FALSE
[13:20:32.075]    - call: NULL
[13:20:32.076] plan(): nbrOfWorkers() = 1
[13:20:32.079] plan(): Setting new future strategy stack:
[13:20:32.080] List of future strategies:
[13:20:32.080] 1. multicore:
[13:20:32.080]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:32.080]    - tweaked: FALSE
[13:20:32.080]    - call: plan(strategy)
[13:20:32.085] plan(): nbrOfWorkers() = 2

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[13:20:32.090] getGlobalsAndPackages() ...
[13:20:32.090] Searching for globals...
[13:20:32.091] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[13:20:32.092] Searching for globals ... DONE
[13:20:32.092] Resolving globals: FALSE
[13:20:32.092] The total size of the 1 globals is 96 bytes (96 bytes)
[13:20:32.093] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[13:20:32.093] - globals: [1] ‘x’
[13:20:32.093] - packages: [1] ‘stats’
[13:20:32.093] getGlobalsAndPackages() ... DONE
[13:20:32.094] run() for ‘Future’ ...
[13:20:32.094] - state: ‘created’
[13:20:32.094] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:32.098] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:32.098] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:32.101]   - Field: ‘label’
[13:20:32.101]   - Field: ‘local’
[13:20:32.102]   - Field: ‘owner’
[13:20:32.102]   - Field: ‘envir’
[13:20:32.102]   - Field: ‘workers’
[13:20:32.102]   - Field: ‘packages’
[13:20:32.102]   - Field: ‘gc’
[13:20:32.102]   - Field: ‘job’
[13:20:32.102]   - Field: ‘conditions’
[13:20:32.103]   - Field: ‘expr’
[13:20:32.103]   - Field: ‘uuid’
[13:20:32.103]   - Field: ‘seed’
[13:20:32.103]   - Field: ‘version’
[13:20:32.103]   - Field: ‘result’
[13:20:32.103]   - Field: ‘asynchronous’
[13:20:32.103]   - Field: ‘calls’
[13:20:32.103]   - Field: ‘globals’
[13:20:32.104]   - Field: ‘stdout’
[13:20:32.104]   - Field: ‘earlySignal’
[13:20:32.104]   - Field: ‘lazy’
[13:20:32.104]   - Field: ‘state’
[13:20:32.104] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:32.104] - Launch lazy future ...
[13:20:32.105] Packages needed by the future expression (n = 1): ‘stats’
[13:20:32.105] Packages needed by future strategies (n = 0): <none>
[13:20:32.106] {
[13:20:32.106]     {
[13:20:32.106]         {
[13:20:32.106]             ...future.startTime <- base::Sys.time()
[13:20:32.106]             {
[13:20:32.106]                 {
[13:20:32.106]                   {
[13:20:32.106]                     {
[13:20:32.106]                       {
[13:20:32.106]                         base::local({
[13:20:32.106]                           has_future <- base::requireNamespace("future", 
[13:20:32.106]                             quietly = TRUE)
[13:20:32.106]                           if (has_future) {
[13:20:32.106]                             ns <- base::getNamespace("future")
[13:20:32.106]                             version <- ns[[".package"]][["version"]]
[13:20:32.106]                             if (is.null(version)) 
[13:20:32.106]                               version <- utils::packageVersion("future")
[13:20:32.106]                           }
[13:20:32.106]                           else {
[13:20:32.106]                             version <- NULL
[13:20:32.106]                           }
[13:20:32.106]                           if (!has_future || version < "1.8.0") {
[13:20:32.106]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:32.106]                               "", base::R.version$version.string), 
[13:20:32.106]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:32.106]                                 base::R.version$platform, 8 * 
[13:20:32.106]                                   base::.Machine$sizeof.pointer), 
[13:20:32.106]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:32.106]                                 "release", "version")], collapse = " "), 
[13:20:32.106]                               hostname = base::Sys.info()[["nodename"]])
[13:20:32.106]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:32.106]                               info)
[13:20:32.106]                             info <- base::paste(info, collapse = "; ")
[13:20:32.106]                             if (!has_future) {
[13:20:32.106]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:32.106]                                 info)
[13:20:32.106]                             }
[13:20:32.106]                             else {
[13:20:32.106]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:32.106]                                 info, version)
[13:20:32.106]                             }
[13:20:32.106]                             base::stop(msg)
[13:20:32.106]                           }
[13:20:32.106]                         })
[13:20:32.106]                       }
[13:20:32.106]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:32.106]                       base::options(mc.cores = 1L)
[13:20:32.106]                     }
[13:20:32.106]                     base::local({
[13:20:32.106]                       for (pkg in "stats") {
[13:20:32.106]                         base::loadNamespace(pkg)
[13:20:32.106]                         base::library(pkg, character.only = TRUE)
[13:20:32.106]                       }
[13:20:32.106]                     })
[13:20:32.106]                   }
[13:20:32.106]                   options(future.plan = NULL)
[13:20:32.106]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:32.106]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:32.106]                 }
[13:20:32.106]                 ...future.workdir <- getwd()
[13:20:32.106]             }
[13:20:32.106]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:32.106]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:32.106]         }
[13:20:32.106]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:32.106]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:32.106]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:32.106]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:32.106]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:32.106]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:32.106]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:32.106]             base::names(...future.oldOptions))
[13:20:32.106]     }
[13:20:32.106]     if (FALSE) {
[13:20:32.106]     }
[13:20:32.106]     else {
[13:20:32.106]         if (TRUE) {
[13:20:32.106]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:32.106]                 open = "w")
[13:20:32.106]         }
[13:20:32.106]         else {
[13:20:32.106]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:32.106]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:32.106]         }
[13:20:32.106]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:32.106]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:32.106]             base::sink(type = "output", split = FALSE)
[13:20:32.106]             base::close(...future.stdout)
[13:20:32.106]         }, add = TRUE)
[13:20:32.106]     }
[13:20:32.106]     ...future.frame <- base::sys.nframe()
[13:20:32.106]     ...future.conditions <- base::list()
[13:20:32.106]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:32.106]     if (FALSE) {
[13:20:32.106]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:32.106]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:32.106]     }
[13:20:32.106]     ...future.result <- base::tryCatch({
[13:20:32.106]         base::withCallingHandlers({
[13:20:32.106]             ...future.value <- base::withVisible(base::local({
[13:20:32.106]                 withCallingHandlers({
[13:20:32.106]                   {
[13:20:32.106]                     xtabs(~x)
[13:20:32.106]                   }
[13:20:32.106]                 }, immediateCondition = function(cond) {
[13:20:32.106]                   save_rds <- function (object, pathname, ...) 
[13:20:32.106]                   {
[13:20:32.106]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:32.106]                     if (file_test("-f", pathname_tmp)) {
[13:20:32.106]                       fi_tmp <- file.info(pathname_tmp)
[13:20:32.106]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:32.106]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:32.106]                         fi_tmp[["mtime"]])
[13:20:32.106]                     }
[13:20:32.106]                     tryCatch({
[13:20:32.106]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:32.106]                     }, error = function(ex) {
[13:20:32.106]                       msg <- conditionMessage(ex)
[13:20:32.106]                       fi_tmp <- file.info(pathname_tmp)
[13:20:32.106]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:32.106]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:32.106]                         fi_tmp[["mtime"]], msg)
[13:20:32.106]                       ex$message <- msg
[13:20:32.106]                       stop(ex)
[13:20:32.106]                     })
[13:20:32.106]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:32.106]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:32.106]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:32.106]                       fi_tmp <- file.info(pathname_tmp)
[13:20:32.106]                       fi <- file.info(pathname)
[13:20:32.106]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:32.106]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:32.106]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:32.106]                         fi[["size"]], fi[["mtime"]])
[13:20:32.106]                       stop(msg)
[13:20:32.106]                     }
[13:20:32.106]                     invisible(pathname)
[13:20:32.106]                   }
[13:20:32.106]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:32.106]                     rootPath = tempdir()) 
[13:20:32.106]                   {
[13:20:32.106]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:32.106]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:32.106]                       tmpdir = path, fileext = ".rds")
[13:20:32.106]                     save_rds(obj, file)
[13:20:32.106]                   }
[13:20:32.106]                   saveImmediateCondition(cond, path = "/tmp/Rtmpnh0Esg/.future/immediateConditions")
[13:20:32.106]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:32.106]                   {
[13:20:32.106]                     inherits <- base::inherits
[13:20:32.106]                     invokeRestart <- base::invokeRestart
[13:20:32.106]                     is.null <- base::is.null
[13:20:32.106]                     muffled <- FALSE
[13:20:32.106]                     if (inherits(cond, "message")) {
[13:20:32.106]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:32.106]                       if (muffled) 
[13:20:32.106]                         invokeRestart("muffleMessage")
[13:20:32.106]                     }
[13:20:32.106]                     else if (inherits(cond, "warning")) {
[13:20:32.106]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:32.106]                       if (muffled) 
[13:20:32.106]                         invokeRestart("muffleWarning")
[13:20:32.106]                     }
[13:20:32.106]                     else if (inherits(cond, "condition")) {
[13:20:32.106]                       if (!is.null(pattern)) {
[13:20:32.106]                         computeRestarts <- base::computeRestarts
[13:20:32.106]                         grepl <- base::grepl
[13:20:32.106]                         restarts <- computeRestarts(cond)
[13:20:32.106]                         for (restart in restarts) {
[13:20:32.106]                           name <- restart$name
[13:20:32.106]                           if (is.null(name)) 
[13:20:32.106]                             next
[13:20:32.106]                           if (!grepl(pattern, name)) 
[13:20:32.106]                             next
[13:20:32.106]                           invokeRestart(restart)
[13:20:32.106]                           muffled <- TRUE
[13:20:32.106]                           break
[13:20:32.106]                         }
[13:20:32.106]                       }
[13:20:32.106]                     }
[13:20:32.106]                     invisible(muffled)
[13:20:32.106]                   }
[13:20:32.106]                   muffleCondition(cond)
[13:20:32.106]                 })
[13:20:32.106]             }))
[13:20:32.106]             future::FutureResult(value = ...future.value$value, 
[13:20:32.106]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:32.106]                   ...future.rng), globalenv = if (FALSE) 
[13:20:32.106]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:32.106]                     ...future.globalenv.names))
[13:20:32.106]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:32.106]         }, condition = base::local({
[13:20:32.106]             c <- base::c
[13:20:32.106]             inherits <- base::inherits
[13:20:32.106]             invokeRestart <- base::invokeRestart
[13:20:32.106]             length <- base::length
[13:20:32.106]             list <- base::list
[13:20:32.106]             seq.int <- base::seq.int
[13:20:32.106]             signalCondition <- base::signalCondition
[13:20:32.106]             sys.calls <- base::sys.calls
[13:20:32.106]             `[[` <- base::`[[`
[13:20:32.106]             `+` <- base::`+`
[13:20:32.106]             `<<-` <- base::`<<-`
[13:20:32.106]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:32.106]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:32.106]                   3L)]
[13:20:32.106]             }
[13:20:32.106]             function(cond) {
[13:20:32.106]                 is_error <- inherits(cond, "error")
[13:20:32.106]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:32.106]                   NULL)
[13:20:32.106]                 if (is_error) {
[13:20:32.106]                   sessionInformation <- function() {
[13:20:32.106]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:32.106]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:32.106]                       search = base::search(), system = base::Sys.info())
[13:20:32.106]                   }
[13:20:32.106]                   ...future.conditions[[length(...future.conditions) + 
[13:20:32.106]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:32.106]                     cond$call), session = sessionInformation(), 
[13:20:32.106]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:32.106]                   signalCondition(cond)
[13:20:32.106]                 }
[13:20:32.106]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:32.106]                 "immediateCondition"))) {
[13:20:32.106]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:32.106]                   ...future.conditions[[length(...future.conditions) + 
[13:20:32.106]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:32.106]                   if (TRUE && !signal) {
[13:20:32.106]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:32.106]                     {
[13:20:32.106]                       inherits <- base::inherits
[13:20:32.106]                       invokeRestart <- base::invokeRestart
[13:20:32.106]                       is.null <- base::is.null
[13:20:32.106]                       muffled <- FALSE
[13:20:32.106]                       if (inherits(cond, "message")) {
[13:20:32.106]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:32.106]                         if (muffled) 
[13:20:32.106]                           invokeRestart("muffleMessage")
[13:20:32.106]                       }
[13:20:32.106]                       else if (inherits(cond, "warning")) {
[13:20:32.106]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:32.106]                         if (muffled) 
[13:20:32.106]                           invokeRestart("muffleWarning")
[13:20:32.106]                       }
[13:20:32.106]                       else if (inherits(cond, "condition")) {
[13:20:32.106]                         if (!is.null(pattern)) {
[13:20:32.106]                           computeRestarts <- base::computeRestarts
[13:20:32.106]                           grepl <- base::grepl
[13:20:32.106]                           restarts <- computeRestarts(cond)
[13:20:32.106]                           for (restart in restarts) {
[13:20:32.106]                             name <- restart$name
[13:20:32.106]                             if (is.null(name)) 
[13:20:32.106]                               next
[13:20:32.106]                             if (!grepl(pattern, name)) 
[13:20:32.106]                               next
[13:20:32.106]                             invokeRestart(restart)
[13:20:32.106]                             muffled <- TRUE
[13:20:32.106]                             break
[13:20:32.106]                           }
[13:20:32.106]                         }
[13:20:32.106]                       }
[13:20:32.106]                       invisible(muffled)
[13:20:32.106]                     }
[13:20:32.106]                     muffleCondition(cond, pattern = "^muffle")
[13:20:32.106]                   }
[13:20:32.106]                 }
[13:20:32.106]                 else {
[13:20:32.106]                   if (TRUE) {
[13:20:32.106]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:32.106]                     {
[13:20:32.106]                       inherits <- base::inherits
[13:20:32.106]                       invokeRestart <- base::invokeRestart
[13:20:32.106]                       is.null <- base::is.null
[13:20:32.106]                       muffled <- FALSE
[13:20:32.106]                       if (inherits(cond, "message")) {
[13:20:32.106]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:32.106]                         if (muffled) 
[13:20:32.106]                           invokeRestart("muffleMessage")
[13:20:32.106]                       }
[13:20:32.106]                       else if (inherits(cond, "warning")) {
[13:20:32.106]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:32.106]                         if (muffled) 
[13:20:32.106]                           invokeRestart("muffleWarning")
[13:20:32.106]                       }
[13:20:32.106]                       else if (inherits(cond, "condition")) {
[13:20:32.106]                         if (!is.null(pattern)) {
[13:20:32.106]                           computeRestarts <- base::computeRestarts
[13:20:32.106]                           grepl <- base::grepl
[13:20:32.106]                           restarts <- computeRestarts(cond)
[13:20:32.106]                           for (restart in restarts) {
[13:20:32.106]                             name <- restart$name
[13:20:32.106]                             if (is.null(name)) 
[13:20:32.106]                               next
[13:20:32.106]                             if (!grepl(pattern, name)) 
[13:20:32.106]                               next
[13:20:32.106]                             invokeRestart(restart)
[13:20:32.106]                             muffled <- TRUE
[13:20:32.106]                             break
[13:20:32.106]                           }
[13:20:32.106]                         }
[13:20:32.106]                       }
[13:20:32.106]                       invisible(muffled)
[13:20:32.106]                     }
[13:20:32.106]                     muffleCondition(cond, pattern = "^muffle")
[13:20:32.106]                   }
[13:20:32.106]                 }
[13:20:32.106]             }
[13:20:32.106]         }))
[13:20:32.106]     }, error = function(ex) {
[13:20:32.106]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:32.106]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:32.106]                 ...future.rng), started = ...future.startTime, 
[13:20:32.106]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:32.106]             version = "1.8"), class = "FutureResult")
[13:20:32.106]     }, finally = {
[13:20:32.106]         if (!identical(...future.workdir, getwd())) 
[13:20:32.106]             setwd(...future.workdir)
[13:20:32.106]         {
[13:20:32.106]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:32.106]                 ...future.oldOptions$nwarnings <- NULL
[13:20:32.106]             }
[13:20:32.106]             base::options(...future.oldOptions)
[13:20:32.106]             if (.Platform$OS.type == "windows") {
[13:20:32.106]                 old_names <- names(...future.oldEnvVars)
[13:20:32.106]                 envs <- base::Sys.getenv()
[13:20:32.106]                 names <- names(envs)
[13:20:32.106]                 common <- intersect(names, old_names)
[13:20:32.106]                 added <- setdiff(names, old_names)
[13:20:32.106]                 removed <- setdiff(old_names, names)
[13:20:32.106]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:32.106]                   envs[common]]
[13:20:32.106]                 NAMES <- toupper(changed)
[13:20:32.106]                 args <- list()
[13:20:32.106]                 for (kk in seq_along(NAMES)) {
[13:20:32.106]                   name <- changed[[kk]]
[13:20:32.106]                   NAME <- NAMES[[kk]]
[13:20:32.106]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:32.106]                     next
[13:20:32.106]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:32.106]                 }
[13:20:32.106]                 NAMES <- toupper(added)
[13:20:32.106]                 for (kk in seq_along(NAMES)) {
[13:20:32.106]                   name <- added[[kk]]
[13:20:32.106]                   NAME <- NAMES[[kk]]
[13:20:32.106]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:32.106]                     next
[13:20:32.106]                   args[[name]] <- ""
[13:20:32.106]                 }
[13:20:32.106]                 NAMES <- toupper(removed)
[13:20:32.106]                 for (kk in seq_along(NAMES)) {
[13:20:32.106]                   name <- removed[[kk]]
[13:20:32.106]                   NAME <- NAMES[[kk]]
[13:20:32.106]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:32.106]                     next
[13:20:32.106]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:32.106]                 }
[13:20:32.106]                 if (length(args) > 0) 
[13:20:32.106]                   base::do.call(base::Sys.setenv, args = args)
[13:20:32.106]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:32.106]             }
[13:20:32.106]             else {
[13:20:32.106]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:32.106]             }
[13:20:32.106]             {
[13:20:32.106]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:32.106]                   0L) {
[13:20:32.106]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:32.106]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:32.106]                   base::options(opts)
[13:20:32.106]                 }
[13:20:32.106]                 {
[13:20:32.106]                   {
[13:20:32.106]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:32.106]                     NULL
[13:20:32.106]                   }
[13:20:32.106]                   options(future.plan = NULL)
[13:20:32.106]                   if (is.na(NA_character_)) 
[13:20:32.106]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:32.106]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:32.106]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:32.106]                     envir = parent.frame()) 
[13:20:32.106]                   {
[13:20:32.106]                     default_workers <- missing(workers)
[13:20:32.106]                     if (is.function(workers)) 
[13:20:32.106]                       workers <- workers()
[13:20:32.106]                     workers <- structure(as.integer(workers), 
[13:20:32.106]                       class = class(workers))
[13:20:32.106]                     stop_if_not(is.finite(workers), workers >= 
[13:20:32.106]                       1L)
[13:20:32.106]                     if ((workers == 1L && !inherits(workers, 
[13:20:32.106]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:32.106]                       if (default_workers) 
[13:20:32.106]                         supportsMulticore(warn = TRUE)
[13:20:32.106]                       return(sequential(..., envir = envir))
[13:20:32.106]                     }
[13:20:32.106]                     oopts <- options(mc.cores = workers)
[13:20:32.106]                     on.exit(options(oopts))
[13:20:32.106]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:32.106]                       envir = envir)
[13:20:32.106]                     if (!future$lazy) 
[13:20:32.106]                       future <- run(future)
[13:20:32.106]                     invisible(future)
[13:20:32.106]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:32.106]                 }
[13:20:32.106]             }
[13:20:32.106]         }
[13:20:32.106]     })
[13:20:32.106]     if (TRUE) {
[13:20:32.106]         base::sink(type = "output", split = FALSE)
[13:20:32.106]         if (TRUE) {
[13:20:32.106]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:32.106]         }
[13:20:32.106]         else {
[13:20:32.106]             ...future.result["stdout"] <- base::list(NULL)
[13:20:32.106]         }
[13:20:32.106]         base::close(...future.stdout)
[13:20:32.106]         ...future.stdout <- NULL
[13:20:32.106]     }
[13:20:32.106]     ...future.result$conditions <- ...future.conditions
[13:20:32.106]     ...future.result$finished <- base::Sys.time()
[13:20:32.106]     ...future.result
[13:20:32.106] }
[13:20:32.108] assign_globals() ...
[13:20:32.108] List of 1
[13:20:32.108]  $ x: num [1:5] 1 1 2 2 2
[13:20:32.108]  - attr(*, "where")=List of 1
[13:20:32.108]   ..$ x:<environment: R_EmptyEnv> 
[13:20:32.108]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:32.108]  - attr(*, "resolved")= logi FALSE
[13:20:32.108]  - attr(*, "total_size")= num 96
[13:20:32.108]  - attr(*, "already-done")= logi TRUE
[13:20:32.112] - copied ‘x’ to environment
[13:20:32.112] assign_globals() ... done
[13:20:32.112] requestCore(): workers = 2
[13:20:32.114] MulticoreFuture started
[13:20:32.114] - Launch lazy future ... done
[13:20:32.115] run() for ‘MulticoreFuture’ ... done
[13:20:32.115] plan(): Setting new future strategy stack:
[13:20:32.116] List of future strategies:
[13:20:32.116] 1. sequential:
[13:20:32.116]    - args: function (..., envir = parent.frame())
[13:20:32.116]    - tweaked: FALSE
[13:20:32.116]    - call: NULL
[13:20:32.117] plan(): nbrOfWorkers() = 1
[13:20:32.120] plan(): Setting new future strategy stack:
[13:20:32.120] List of future strategies:
[13:20:32.120] 1. multicore:
[13:20:32.120]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:32.120]    - tweaked: FALSE
[13:20:32.120]    - call: plan(strategy)
[13:20:32.125] plan(): nbrOfWorkers() = 2
x
1 2 
2 3 
[13:20:32.127] getGlobalsAndPackages() ...
[13:20:32.128] Searching for globals...
[13:20:32.129] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[13:20:32.130] Searching for globals ... DONE
[13:20:32.130] Resolving globals: FALSE
[13:20:32.130] The total size of the 1 globals is 96 bytes (96 bytes)
[13:20:32.131] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[13:20:32.131] - globals: [1] ‘x’
[13:20:32.131] - packages: [1] ‘stats’
[13:20:32.131] getGlobalsAndPackages() ... DONE
[13:20:32.132] run() for ‘Future’ ...
[13:20:32.132] - state: ‘created’
[13:20:32.132] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:32.136] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:32.136] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:32.136]   - Field: ‘label’
[13:20:32.137]   - Field: ‘local’
[13:20:32.137]   - Field: ‘owner’
[13:20:32.137]   - Field: ‘envir’
[13:20:32.137]   - Field: ‘workers’
[13:20:32.137]   - Field: ‘packages’
[13:20:32.137]   - Field: ‘gc’
[13:20:32.137]   - Field: ‘job’
[13:20:32.137]   - Field: ‘conditions’
[13:20:32.138]   - Field: ‘expr’
[13:20:32.138]   - Field: ‘uuid’
[13:20:32.138]   - Field: ‘seed’
[13:20:32.138]   - Field: ‘version’
[13:20:32.138]   - Field: ‘result’
[13:20:32.138]   - Field: ‘asynchronous’
[13:20:32.138]   - Field: ‘calls’
[13:20:32.138]   - Field: ‘globals’
[13:20:32.138]   - Field: ‘stdout’
[13:20:32.139]   - Field: ‘earlySignal’
[13:20:32.139]   - Field: ‘lazy’
[13:20:32.139]   - Field: ‘state’
[13:20:32.139] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:32.139] - Launch lazy future ...
[13:20:32.139] Packages needed by the future expression (n = 1): ‘stats’
[13:20:32.140] Packages needed by future strategies (n = 0): <none>
[13:20:32.140] {
[13:20:32.140]     {
[13:20:32.140]         {
[13:20:32.140]             ...future.startTime <- base::Sys.time()
[13:20:32.140]             {
[13:20:32.140]                 {
[13:20:32.140]                   {
[13:20:32.140]                     {
[13:20:32.140]                       {
[13:20:32.140]                         base::local({
[13:20:32.140]                           has_future <- base::requireNamespace("future", 
[13:20:32.140]                             quietly = TRUE)
[13:20:32.140]                           if (has_future) {
[13:20:32.140]                             ns <- base::getNamespace("future")
[13:20:32.140]                             version <- ns[[".package"]][["version"]]
[13:20:32.140]                             if (is.null(version)) 
[13:20:32.140]                               version <- utils::packageVersion("future")
[13:20:32.140]                           }
[13:20:32.140]                           else {
[13:20:32.140]                             version <- NULL
[13:20:32.140]                           }
[13:20:32.140]                           if (!has_future || version < "1.8.0") {
[13:20:32.140]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:32.140]                               "", base::R.version$version.string), 
[13:20:32.140]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:32.140]                                 base::R.version$platform, 8 * 
[13:20:32.140]                                   base::.Machine$sizeof.pointer), 
[13:20:32.140]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:32.140]                                 "release", "version")], collapse = " "), 
[13:20:32.140]                               hostname = base::Sys.info()[["nodename"]])
[13:20:32.140]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:32.140]                               info)
[13:20:32.140]                             info <- base::paste(info, collapse = "; ")
[13:20:32.140]                             if (!has_future) {
[13:20:32.140]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:32.140]                                 info)
[13:20:32.140]                             }
[13:20:32.140]                             else {
[13:20:32.140]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:32.140]                                 info, version)
[13:20:32.140]                             }
[13:20:32.140]                             base::stop(msg)
[13:20:32.140]                           }
[13:20:32.140]                         })
[13:20:32.140]                       }
[13:20:32.140]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:32.140]                       base::options(mc.cores = 1L)
[13:20:32.140]                     }
[13:20:32.140]                     base::local({
[13:20:32.140]                       for (pkg in "stats") {
[13:20:32.140]                         base::loadNamespace(pkg)
[13:20:32.140]                         base::library(pkg, character.only = TRUE)
[13:20:32.140]                       }
[13:20:32.140]                     })
[13:20:32.140]                   }
[13:20:32.140]                   options(future.plan = NULL)
[13:20:32.140]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:32.140]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:32.140]                 }
[13:20:32.140]                 ...future.workdir <- getwd()
[13:20:32.140]             }
[13:20:32.140]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:32.140]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:32.140]         }
[13:20:32.140]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:32.140]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:32.140]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:32.140]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:32.140]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:32.140]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:32.140]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:32.140]             base::names(...future.oldOptions))
[13:20:32.140]     }
[13:20:32.140]     if (FALSE) {
[13:20:32.140]     }
[13:20:32.140]     else {
[13:20:32.140]         if (TRUE) {
[13:20:32.140]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:32.140]                 open = "w")
[13:20:32.140]         }
[13:20:32.140]         else {
[13:20:32.140]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:32.140]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:32.140]         }
[13:20:32.140]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:32.140]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:32.140]             base::sink(type = "output", split = FALSE)
[13:20:32.140]             base::close(...future.stdout)
[13:20:32.140]         }, add = TRUE)
[13:20:32.140]     }
[13:20:32.140]     ...future.frame <- base::sys.nframe()
[13:20:32.140]     ...future.conditions <- base::list()
[13:20:32.140]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:32.140]     if (FALSE) {
[13:20:32.140]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:32.140]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:32.140]     }
[13:20:32.140]     ...future.result <- base::tryCatch({
[13:20:32.140]         base::withCallingHandlers({
[13:20:32.140]             ...future.value <- base::withVisible(base::local({
[13:20:32.140]                 withCallingHandlers({
[13:20:32.140]                   {
[13:20:32.140]                     xtabs(~x)
[13:20:32.140]                   }
[13:20:32.140]                 }, immediateCondition = function(cond) {
[13:20:32.140]                   save_rds <- function (object, pathname, ...) 
[13:20:32.140]                   {
[13:20:32.140]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:32.140]                     if (file_test("-f", pathname_tmp)) {
[13:20:32.140]                       fi_tmp <- file.info(pathname_tmp)
[13:20:32.140]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:32.140]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:32.140]                         fi_tmp[["mtime"]])
[13:20:32.140]                     }
[13:20:32.140]                     tryCatch({
[13:20:32.140]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:32.140]                     }, error = function(ex) {
[13:20:32.140]                       msg <- conditionMessage(ex)
[13:20:32.140]                       fi_tmp <- file.info(pathname_tmp)
[13:20:32.140]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:32.140]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:32.140]                         fi_tmp[["mtime"]], msg)
[13:20:32.140]                       ex$message <- msg
[13:20:32.140]                       stop(ex)
[13:20:32.140]                     })
[13:20:32.140]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:32.140]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:32.140]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:32.140]                       fi_tmp <- file.info(pathname_tmp)
[13:20:32.140]                       fi <- file.info(pathname)
[13:20:32.140]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:32.140]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:32.140]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:32.140]                         fi[["size"]], fi[["mtime"]])
[13:20:32.140]                       stop(msg)
[13:20:32.140]                     }
[13:20:32.140]                     invisible(pathname)
[13:20:32.140]                   }
[13:20:32.140]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:32.140]                     rootPath = tempdir()) 
[13:20:32.140]                   {
[13:20:32.140]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:32.140]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:32.140]                       tmpdir = path, fileext = ".rds")
[13:20:32.140]                     save_rds(obj, file)
[13:20:32.140]                   }
[13:20:32.140]                   saveImmediateCondition(cond, path = "/tmp/Rtmpnh0Esg/.future/immediateConditions")
[13:20:32.140]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:32.140]                   {
[13:20:32.140]                     inherits <- base::inherits
[13:20:32.140]                     invokeRestart <- base::invokeRestart
[13:20:32.140]                     is.null <- base::is.null
[13:20:32.140]                     muffled <- FALSE
[13:20:32.140]                     if (inherits(cond, "message")) {
[13:20:32.140]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:32.140]                       if (muffled) 
[13:20:32.140]                         invokeRestart("muffleMessage")
[13:20:32.140]                     }
[13:20:32.140]                     else if (inherits(cond, "warning")) {
[13:20:32.140]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:32.140]                       if (muffled) 
[13:20:32.140]                         invokeRestart("muffleWarning")
[13:20:32.140]                     }
[13:20:32.140]                     else if (inherits(cond, "condition")) {
[13:20:32.140]                       if (!is.null(pattern)) {
[13:20:32.140]                         computeRestarts <- base::computeRestarts
[13:20:32.140]                         grepl <- base::grepl
[13:20:32.140]                         restarts <- computeRestarts(cond)
[13:20:32.140]                         for (restart in restarts) {
[13:20:32.140]                           name <- restart$name
[13:20:32.140]                           if (is.null(name)) 
[13:20:32.140]                             next
[13:20:32.140]                           if (!grepl(pattern, name)) 
[13:20:32.140]                             next
[13:20:32.140]                           invokeRestart(restart)
[13:20:32.140]                           muffled <- TRUE
[13:20:32.140]                           break
[13:20:32.140]                         }
[13:20:32.140]                       }
[13:20:32.140]                     }
[13:20:32.140]                     invisible(muffled)
[13:20:32.140]                   }
[13:20:32.140]                   muffleCondition(cond)
[13:20:32.140]                 })
[13:20:32.140]             }))
[13:20:32.140]             future::FutureResult(value = ...future.value$value, 
[13:20:32.140]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:32.140]                   ...future.rng), globalenv = if (FALSE) 
[13:20:32.140]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:32.140]                     ...future.globalenv.names))
[13:20:32.140]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:32.140]         }, condition = base::local({
[13:20:32.140]             c <- base::c
[13:20:32.140]             inherits <- base::inherits
[13:20:32.140]             invokeRestart <- base::invokeRestart
[13:20:32.140]             length <- base::length
[13:20:32.140]             list <- base::list
[13:20:32.140]             seq.int <- base::seq.int
[13:20:32.140]             signalCondition <- base::signalCondition
[13:20:32.140]             sys.calls <- base::sys.calls
[13:20:32.140]             `[[` <- base::`[[`
[13:20:32.140]             `+` <- base::`+`
[13:20:32.140]             `<<-` <- base::`<<-`
[13:20:32.140]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:32.140]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:32.140]                   3L)]
[13:20:32.140]             }
[13:20:32.140]             function(cond) {
[13:20:32.140]                 is_error <- inherits(cond, "error")
[13:20:32.140]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:32.140]                   NULL)
[13:20:32.140]                 if (is_error) {
[13:20:32.140]                   sessionInformation <- function() {
[13:20:32.140]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:32.140]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:32.140]                       search = base::search(), system = base::Sys.info())
[13:20:32.140]                   }
[13:20:32.140]                   ...future.conditions[[length(...future.conditions) + 
[13:20:32.140]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:32.140]                     cond$call), session = sessionInformation(), 
[13:20:32.140]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:32.140]                   signalCondition(cond)
[13:20:32.140]                 }
[13:20:32.140]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:32.140]                 "immediateCondition"))) {
[13:20:32.140]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:32.140]                   ...future.conditions[[length(...future.conditions) + 
[13:20:32.140]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:32.140]                   if (TRUE && !signal) {
[13:20:32.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:32.140]                     {
[13:20:32.140]                       inherits <- base::inherits
[13:20:32.140]                       invokeRestart <- base::invokeRestart
[13:20:32.140]                       is.null <- base::is.null
[13:20:32.140]                       muffled <- FALSE
[13:20:32.140]                       if (inherits(cond, "message")) {
[13:20:32.140]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:32.140]                         if (muffled) 
[13:20:32.140]                           invokeRestart("muffleMessage")
[13:20:32.140]                       }
[13:20:32.140]                       else if (inherits(cond, "warning")) {
[13:20:32.140]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:32.140]                         if (muffled) 
[13:20:32.140]                           invokeRestart("muffleWarning")
[13:20:32.140]                       }
[13:20:32.140]                       else if (inherits(cond, "condition")) {
[13:20:32.140]                         if (!is.null(pattern)) {
[13:20:32.140]                           computeRestarts <- base::computeRestarts
[13:20:32.140]                           grepl <- base::grepl
[13:20:32.140]                           restarts <- computeRestarts(cond)
[13:20:32.140]                           for (restart in restarts) {
[13:20:32.140]                             name <- restart$name
[13:20:32.140]                             if (is.null(name)) 
[13:20:32.140]                               next
[13:20:32.140]                             if (!grepl(pattern, name)) 
[13:20:32.140]                               next
[13:20:32.140]                             invokeRestart(restart)
[13:20:32.140]                             muffled <- TRUE
[13:20:32.140]                             break
[13:20:32.140]                           }
[13:20:32.140]                         }
[13:20:32.140]                       }
[13:20:32.140]                       invisible(muffled)
[13:20:32.140]                     }
[13:20:32.140]                     muffleCondition(cond, pattern = "^muffle")
[13:20:32.140]                   }
[13:20:32.140]                 }
[13:20:32.140]                 else {
[13:20:32.140]                   if (TRUE) {
[13:20:32.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:32.140]                     {
[13:20:32.140]                       inherits <- base::inherits
[13:20:32.140]                       invokeRestart <- base::invokeRestart
[13:20:32.140]                       is.null <- base::is.null
[13:20:32.140]                       muffled <- FALSE
[13:20:32.140]                       if (inherits(cond, "message")) {
[13:20:32.140]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:32.140]                         if (muffled) 
[13:20:32.140]                           invokeRestart("muffleMessage")
[13:20:32.140]                       }
[13:20:32.140]                       else if (inherits(cond, "warning")) {
[13:20:32.140]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:32.140]                         if (muffled) 
[13:20:32.140]                           invokeRestart("muffleWarning")
[13:20:32.140]                       }
[13:20:32.140]                       else if (inherits(cond, "condition")) {
[13:20:32.140]                         if (!is.null(pattern)) {
[13:20:32.140]                           computeRestarts <- base::computeRestarts
[13:20:32.140]                           grepl <- base::grepl
[13:20:32.140]                           restarts <- computeRestarts(cond)
[13:20:32.140]                           for (restart in restarts) {
[13:20:32.140]                             name <- restart$name
[13:20:32.140]                             if (is.null(name)) 
[13:20:32.140]                               next
[13:20:32.140]                             if (!grepl(pattern, name)) 
[13:20:32.140]                               next
[13:20:32.140]                             invokeRestart(restart)
[13:20:32.140]                             muffled <- TRUE
[13:20:32.140]                             break
[13:20:32.140]                           }
[13:20:32.140]                         }
[13:20:32.140]                       }
[13:20:32.140]                       invisible(muffled)
[13:20:32.140]                     }
[13:20:32.140]                     muffleCondition(cond, pattern = "^muffle")
[13:20:32.140]                   }
[13:20:32.140]                 }
[13:20:32.140]             }
[13:20:32.140]         }))
[13:20:32.140]     }, error = function(ex) {
[13:20:32.140]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:32.140]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:32.140]                 ...future.rng), started = ...future.startTime, 
[13:20:32.140]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:32.140]             version = "1.8"), class = "FutureResult")
[13:20:32.140]     }, finally = {
[13:20:32.140]         if (!identical(...future.workdir, getwd())) 
[13:20:32.140]             setwd(...future.workdir)
[13:20:32.140]         {
[13:20:32.140]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:32.140]                 ...future.oldOptions$nwarnings <- NULL
[13:20:32.140]             }
[13:20:32.140]             base::options(...future.oldOptions)
[13:20:32.140]             if (.Platform$OS.type == "windows") {
[13:20:32.140]                 old_names <- names(...future.oldEnvVars)
[13:20:32.140]                 envs <- base::Sys.getenv()
[13:20:32.140]                 names <- names(envs)
[13:20:32.140]                 common <- intersect(names, old_names)
[13:20:32.140]                 added <- setdiff(names, old_names)
[13:20:32.140]                 removed <- setdiff(old_names, names)
[13:20:32.140]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:32.140]                   envs[common]]
[13:20:32.140]                 NAMES <- toupper(changed)
[13:20:32.140]                 args <- list()
[13:20:32.140]                 for (kk in seq_along(NAMES)) {
[13:20:32.140]                   name <- changed[[kk]]
[13:20:32.140]                   NAME <- NAMES[[kk]]
[13:20:32.140]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:32.140]                     next
[13:20:32.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:32.140]                 }
[13:20:32.140]                 NAMES <- toupper(added)
[13:20:32.140]                 for (kk in seq_along(NAMES)) {
[13:20:32.140]                   name <- added[[kk]]
[13:20:32.140]                   NAME <- NAMES[[kk]]
[13:20:32.140]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:32.140]                     next
[13:20:32.140]                   args[[name]] <- ""
[13:20:32.140]                 }
[13:20:32.140]                 NAMES <- toupper(removed)
[13:20:32.140]                 for (kk in seq_along(NAMES)) {
[13:20:32.140]                   name <- removed[[kk]]
[13:20:32.140]                   NAME <- NAMES[[kk]]
[13:20:32.140]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:32.140]                     next
[13:20:32.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:32.140]                 }
[13:20:32.140]                 if (length(args) > 0) 
[13:20:32.140]                   base::do.call(base::Sys.setenv, args = args)
[13:20:32.140]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:32.140]             }
[13:20:32.140]             else {
[13:20:32.140]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:32.140]             }
[13:20:32.140]             {
[13:20:32.140]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:32.140]                   0L) {
[13:20:32.140]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:32.140]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:32.140]                   base::options(opts)
[13:20:32.140]                 }
[13:20:32.140]                 {
[13:20:32.140]                   {
[13:20:32.140]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:32.140]                     NULL
[13:20:32.140]                   }
[13:20:32.140]                   options(future.plan = NULL)
[13:20:32.140]                   if (is.na(NA_character_)) 
[13:20:32.140]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:32.140]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:32.140]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:32.140]                     envir = parent.frame()) 
[13:20:32.140]                   {
[13:20:32.140]                     default_workers <- missing(workers)
[13:20:32.140]                     if (is.function(workers)) 
[13:20:32.140]                       workers <- workers()
[13:20:32.140]                     workers <- structure(as.integer(workers), 
[13:20:32.140]                       class = class(workers))
[13:20:32.140]                     stop_if_not(is.finite(workers), workers >= 
[13:20:32.140]                       1L)
[13:20:32.140]                     if ((workers == 1L && !inherits(workers, 
[13:20:32.140]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:32.140]                       if (default_workers) 
[13:20:32.140]                         supportsMulticore(warn = TRUE)
[13:20:32.140]                       return(sequential(..., envir = envir))
[13:20:32.140]                     }
[13:20:32.140]                     oopts <- options(mc.cores = workers)
[13:20:32.140]                     on.exit(options(oopts))
[13:20:32.140]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:32.140]                       envir = envir)
[13:20:32.140]                     if (!future$lazy) 
[13:20:32.140]                       future <- run(future)
[13:20:32.140]                     invisible(future)
[13:20:32.140]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:32.140]                 }
[13:20:32.140]             }
[13:20:32.140]         }
[13:20:32.140]     })
[13:20:32.140]     if (TRUE) {
[13:20:32.140]         base::sink(type = "output", split = FALSE)
[13:20:32.140]         if (TRUE) {
[13:20:32.140]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:32.140]         }
[13:20:32.140]         else {
[13:20:32.140]             ...future.result["stdout"] <- base::list(NULL)
[13:20:32.140]         }
[13:20:32.140]         base::close(...future.stdout)
[13:20:32.140]         ...future.stdout <- NULL
[13:20:32.140]     }
[13:20:32.140]     ...future.result$conditions <- ...future.conditions
[13:20:32.140]     ...future.result$finished <- base::Sys.time()
[13:20:32.140]     ...future.result
[13:20:32.140] }
[13:20:32.143] assign_globals() ...
[13:20:32.143] List of 1
[13:20:32.143]  $ x: num [1:5] 1 1 2 2 2
[13:20:32.143]  - attr(*, "where")=List of 1
[13:20:32.143]   ..$ x:<environment: R_EmptyEnv> 
[13:20:32.143]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:32.143]  - attr(*, "resolved")= logi FALSE
[13:20:32.143]  - attr(*, "total_size")= num 96
[13:20:32.143]  - attr(*, "already-done")= logi TRUE
[13:20:32.149] - copied ‘x’ to environment
[13:20:32.149] assign_globals() ... done
[13:20:32.150] requestCore(): workers = 2
[13:20:32.152] MulticoreFuture started
[13:20:32.153] - Launch lazy future ... done
[13:20:32.153] run() for ‘MulticoreFuture’ ... done
[13:20:32.154] plan(): Setting new future strategy stack:
[13:20:32.154] List of future strategies:
[13:20:32.154] 1. sequential:
[13:20:32.154]    - args: function (..., envir = parent.frame())
[13:20:32.154]    - tweaked: FALSE
[13:20:32.154]    - call: NULL
[13:20:32.155] plan(): nbrOfWorkers() = 1
[13:20:32.158] plan(): Setting new future strategy stack:
[13:20:32.159] List of future strategies:
[13:20:32.159] 1. multicore:
[13:20:32.159]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:32.159]    - tweaked: FALSE
[13:20:32.159]    - call: plan(strategy)
[13:20:32.164] plan(): nbrOfWorkers() = 2
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[13:20:32.169] getGlobalsAndPackages() ...
[13:20:32.169] Searching for globals...
[13:20:32.172] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[13:20:32.172] Searching for globals ... DONE
[13:20:32.172] Resolving globals: FALSE
[13:20:32.173] 
[13:20:32.173] - packages: [2] ‘stats’, ‘datasets’
[13:20:32.173] getGlobalsAndPackages() ... DONE
[13:20:32.173] run() for ‘Future’ ...
[13:20:32.174] - state: ‘created’
[13:20:32.174] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:32.178] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:32.179] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:32.179]   - Field: ‘label’
[13:20:32.179]   - Field: ‘local’
[13:20:32.179]   - Field: ‘owner’
[13:20:32.179]   - Field: ‘envir’
[13:20:32.179]   - Field: ‘workers’
[13:20:32.179]   - Field: ‘packages’
[13:20:32.180]   - Field: ‘gc’
[13:20:32.180]   - Field: ‘job’
[13:20:32.180]   - Field: ‘conditions’
[13:20:32.180]   - Field: ‘expr’
[13:20:32.180]   - Field: ‘uuid’
[13:20:32.180]   - Field: ‘seed’
[13:20:32.180]   - Field: ‘version’
[13:20:32.180]   - Field: ‘result’
[13:20:32.180]   - Field: ‘asynchronous’
[13:20:32.181]   - Field: ‘calls’
[13:20:32.181]   - Field: ‘globals’
[13:20:32.181]   - Field: ‘stdout’
[13:20:32.181]   - Field: ‘earlySignal’
[13:20:32.181]   - Field: ‘lazy’
[13:20:32.181]   - Field: ‘state’
[13:20:32.181] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:32.181] - Launch lazy future ...
[13:20:32.182] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:20:32.182] Packages needed by future strategies (n = 0): <none>
[13:20:32.183] {
[13:20:32.183]     {
[13:20:32.183]         {
[13:20:32.183]             ...future.startTime <- base::Sys.time()
[13:20:32.183]             {
[13:20:32.183]                 {
[13:20:32.183]                   {
[13:20:32.183]                     {
[13:20:32.183]                       {
[13:20:32.183]                         base::local({
[13:20:32.183]                           has_future <- base::requireNamespace("future", 
[13:20:32.183]                             quietly = TRUE)
[13:20:32.183]                           if (has_future) {
[13:20:32.183]                             ns <- base::getNamespace("future")
[13:20:32.183]                             version <- ns[[".package"]][["version"]]
[13:20:32.183]                             if (is.null(version)) 
[13:20:32.183]                               version <- utils::packageVersion("future")
[13:20:32.183]                           }
[13:20:32.183]                           else {
[13:20:32.183]                             version <- NULL
[13:20:32.183]                           }
[13:20:32.183]                           if (!has_future || version < "1.8.0") {
[13:20:32.183]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:32.183]                               "", base::R.version$version.string), 
[13:20:32.183]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:32.183]                                 base::R.version$platform, 8 * 
[13:20:32.183]                                   base::.Machine$sizeof.pointer), 
[13:20:32.183]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:32.183]                                 "release", "version")], collapse = " "), 
[13:20:32.183]                               hostname = base::Sys.info()[["nodename"]])
[13:20:32.183]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:32.183]                               info)
[13:20:32.183]                             info <- base::paste(info, collapse = "; ")
[13:20:32.183]                             if (!has_future) {
[13:20:32.183]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:32.183]                                 info)
[13:20:32.183]                             }
[13:20:32.183]                             else {
[13:20:32.183]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:32.183]                                 info, version)
[13:20:32.183]                             }
[13:20:32.183]                             base::stop(msg)
[13:20:32.183]                           }
[13:20:32.183]                         })
[13:20:32.183]                       }
[13:20:32.183]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:32.183]                       base::options(mc.cores = 1L)
[13:20:32.183]                     }
[13:20:32.183]                     base::local({
[13:20:32.183]                       for (pkg in c("stats", "datasets")) {
[13:20:32.183]                         base::loadNamespace(pkg)
[13:20:32.183]                         base::library(pkg, character.only = TRUE)
[13:20:32.183]                       }
[13:20:32.183]                     })
[13:20:32.183]                   }
[13:20:32.183]                   options(future.plan = NULL)
[13:20:32.183]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:32.183]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:32.183]                 }
[13:20:32.183]                 ...future.workdir <- getwd()
[13:20:32.183]             }
[13:20:32.183]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:32.183]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:32.183]         }
[13:20:32.183]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:32.183]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:32.183]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:32.183]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:32.183]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:32.183]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:32.183]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:32.183]             base::names(...future.oldOptions))
[13:20:32.183]     }
[13:20:32.183]     if (FALSE) {
[13:20:32.183]     }
[13:20:32.183]     else {
[13:20:32.183]         if (TRUE) {
[13:20:32.183]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:32.183]                 open = "w")
[13:20:32.183]         }
[13:20:32.183]         else {
[13:20:32.183]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:32.183]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:32.183]         }
[13:20:32.183]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:32.183]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:32.183]             base::sink(type = "output", split = FALSE)
[13:20:32.183]             base::close(...future.stdout)
[13:20:32.183]         }, add = TRUE)
[13:20:32.183]     }
[13:20:32.183]     ...future.frame <- base::sys.nframe()
[13:20:32.183]     ...future.conditions <- base::list()
[13:20:32.183]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:32.183]     if (FALSE) {
[13:20:32.183]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:32.183]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:32.183]     }
[13:20:32.183]     ...future.result <- base::tryCatch({
[13:20:32.183]         base::withCallingHandlers({
[13:20:32.183]             ...future.value <- base::withVisible(base::local({
[13:20:32.183]                 withCallingHandlers({
[13:20:32.183]                   {
[13:20:32.183]                     lm(dist ~ . - 1, data = cars)
[13:20:32.183]                   }
[13:20:32.183]                 }, immediateCondition = function(cond) {
[13:20:32.183]                   save_rds <- function (object, pathname, ...) 
[13:20:32.183]                   {
[13:20:32.183]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:32.183]                     if (file_test("-f", pathname_tmp)) {
[13:20:32.183]                       fi_tmp <- file.info(pathname_tmp)
[13:20:32.183]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:32.183]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:32.183]                         fi_tmp[["mtime"]])
[13:20:32.183]                     }
[13:20:32.183]                     tryCatch({
[13:20:32.183]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:32.183]                     }, error = function(ex) {
[13:20:32.183]                       msg <- conditionMessage(ex)
[13:20:32.183]                       fi_tmp <- file.info(pathname_tmp)
[13:20:32.183]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:32.183]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:32.183]                         fi_tmp[["mtime"]], msg)
[13:20:32.183]                       ex$message <- msg
[13:20:32.183]                       stop(ex)
[13:20:32.183]                     })
[13:20:32.183]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:32.183]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:32.183]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:32.183]                       fi_tmp <- file.info(pathname_tmp)
[13:20:32.183]                       fi <- file.info(pathname)
[13:20:32.183]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:32.183]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:32.183]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:32.183]                         fi[["size"]], fi[["mtime"]])
[13:20:32.183]                       stop(msg)
[13:20:32.183]                     }
[13:20:32.183]                     invisible(pathname)
[13:20:32.183]                   }
[13:20:32.183]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:32.183]                     rootPath = tempdir()) 
[13:20:32.183]                   {
[13:20:32.183]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:32.183]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:32.183]                       tmpdir = path, fileext = ".rds")
[13:20:32.183]                     save_rds(obj, file)
[13:20:32.183]                   }
[13:20:32.183]                   saveImmediateCondition(cond, path = "/tmp/Rtmpnh0Esg/.future/immediateConditions")
[13:20:32.183]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:32.183]                   {
[13:20:32.183]                     inherits <- base::inherits
[13:20:32.183]                     invokeRestart <- base::invokeRestart
[13:20:32.183]                     is.null <- base::is.null
[13:20:32.183]                     muffled <- FALSE
[13:20:32.183]                     if (inherits(cond, "message")) {
[13:20:32.183]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:32.183]                       if (muffled) 
[13:20:32.183]                         invokeRestart("muffleMessage")
[13:20:32.183]                     }
[13:20:32.183]                     else if (inherits(cond, "warning")) {
[13:20:32.183]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:32.183]                       if (muffled) 
[13:20:32.183]                         invokeRestart("muffleWarning")
[13:20:32.183]                     }
[13:20:32.183]                     else if (inherits(cond, "condition")) {
[13:20:32.183]                       if (!is.null(pattern)) {
[13:20:32.183]                         computeRestarts <- base::computeRestarts
[13:20:32.183]                         grepl <- base::grepl
[13:20:32.183]                         restarts <- computeRestarts(cond)
[13:20:32.183]                         for (restart in restarts) {
[13:20:32.183]                           name <- restart$name
[13:20:32.183]                           if (is.null(name)) 
[13:20:32.183]                             next
[13:20:32.183]                           if (!grepl(pattern, name)) 
[13:20:32.183]                             next
[13:20:32.183]                           invokeRestart(restart)
[13:20:32.183]                           muffled <- TRUE
[13:20:32.183]                           break
[13:20:32.183]                         }
[13:20:32.183]                       }
[13:20:32.183]                     }
[13:20:32.183]                     invisible(muffled)
[13:20:32.183]                   }
[13:20:32.183]                   muffleCondition(cond)
[13:20:32.183]                 })
[13:20:32.183]             }))
[13:20:32.183]             future::FutureResult(value = ...future.value$value, 
[13:20:32.183]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:32.183]                   ...future.rng), globalenv = if (FALSE) 
[13:20:32.183]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:32.183]                     ...future.globalenv.names))
[13:20:32.183]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:32.183]         }, condition = base::local({
[13:20:32.183]             c <- base::c
[13:20:32.183]             inherits <- base::inherits
[13:20:32.183]             invokeRestart <- base::invokeRestart
[13:20:32.183]             length <- base::length
[13:20:32.183]             list <- base::list
[13:20:32.183]             seq.int <- base::seq.int
[13:20:32.183]             signalCondition <- base::signalCondition
[13:20:32.183]             sys.calls <- base::sys.calls
[13:20:32.183]             `[[` <- base::`[[`
[13:20:32.183]             `+` <- base::`+`
[13:20:32.183]             `<<-` <- base::`<<-`
[13:20:32.183]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:32.183]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:32.183]                   3L)]
[13:20:32.183]             }
[13:20:32.183]             function(cond) {
[13:20:32.183]                 is_error <- inherits(cond, "error")
[13:20:32.183]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:32.183]                   NULL)
[13:20:32.183]                 if (is_error) {
[13:20:32.183]                   sessionInformation <- function() {
[13:20:32.183]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:32.183]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:32.183]                       search = base::search(), system = base::Sys.info())
[13:20:32.183]                   }
[13:20:32.183]                   ...future.conditions[[length(...future.conditions) + 
[13:20:32.183]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:32.183]                     cond$call), session = sessionInformation(), 
[13:20:32.183]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:32.183]                   signalCondition(cond)
[13:20:32.183]                 }
[13:20:32.183]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:32.183]                 "immediateCondition"))) {
[13:20:32.183]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:32.183]                   ...future.conditions[[length(...future.conditions) + 
[13:20:32.183]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:32.183]                   if (TRUE && !signal) {
[13:20:32.183]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:32.183]                     {
[13:20:32.183]                       inherits <- base::inherits
[13:20:32.183]                       invokeRestart <- base::invokeRestart
[13:20:32.183]                       is.null <- base::is.null
[13:20:32.183]                       muffled <- FALSE
[13:20:32.183]                       if (inherits(cond, "message")) {
[13:20:32.183]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:32.183]                         if (muffled) 
[13:20:32.183]                           invokeRestart("muffleMessage")
[13:20:32.183]                       }
[13:20:32.183]                       else if (inherits(cond, "warning")) {
[13:20:32.183]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:32.183]                         if (muffled) 
[13:20:32.183]                           invokeRestart("muffleWarning")
[13:20:32.183]                       }
[13:20:32.183]                       else if (inherits(cond, "condition")) {
[13:20:32.183]                         if (!is.null(pattern)) {
[13:20:32.183]                           computeRestarts <- base::computeRestarts
[13:20:32.183]                           grepl <- base::grepl
[13:20:32.183]                           restarts <- computeRestarts(cond)
[13:20:32.183]                           for (restart in restarts) {
[13:20:32.183]                             name <- restart$name
[13:20:32.183]                             if (is.null(name)) 
[13:20:32.183]                               next
[13:20:32.183]                             if (!grepl(pattern, name)) 
[13:20:32.183]                               next
[13:20:32.183]                             invokeRestart(restart)
[13:20:32.183]                             muffled <- TRUE
[13:20:32.183]                             break
[13:20:32.183]                           }
[13:20:32.183]                         }
[13:20:32.183]                       }
[13:20:32.183]                       invisible(muffled)
[13:20:32.183]                     }
[13:20:32.183]                     muffleCondition(cond, pattern = "^muffle")
[13:20:32.183]                   }
[13:20:32.183]                 }
[13:20:32.183]                 else {
[13:20:32.183]                   if (TRUE) {
[13:20:32.183]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:32.183]                     {
[13:20:32.183]                       inherits <- base::inherits
[13:20:32.183]                       invokeRestart <- base::invokeRestart
[13:20:32.183]                       is.null <- base::is.null
[13:20:32.183]                       muffled <- FALSE
[13:20:32.183]                       if (inherits(cond, "message")) {
[13:20:32.183]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:32.183]                         if (muffled) 
[13:20:32.183]                           invokeRestart("muffleMessage")
[13:20:32.183]                       }
[13:20:32.183]                       else if (inherits(cond, "warning")) {
[13:20:32.183]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:32.183]                         if (muffled) 
[13:20:32.183]                           invokeRestart("muffleWarning")
[13:20:32.183]                       }
[13:20:32.183]                       else if (inherits(cond, "condition")) {
[13:20:32.183]                         if (!is.null(pattern)) {
[13:20:32.183]                           computeRestarts <- base::computeRestarts
[13:20:32.183]                           grepl <- base::grepl
[13:20:32.183]                           restarts <- computeRestarts(cond)
[13:20:32.183]                           for (restart in restarts) {
[13:20:32.183]                             name <- restart$name
[13:20:32.183]                             if (is.null(name)) 
[13:20:32.183]                               next
[13:20:32.183]                             if (!grepl(pattern, name)) 
[13:20:32.183]                               next
[13:20:32.183]                             invokeRestart(restart)
[13:20:32.183]                             muffled <- TRUE
[13:20:32.183]                             break
[13:20:32.183]                           }
[13:20:32.183]                         }
[13:20:32.183]                       }
[13:20:32.183]                       invisible(muffled)
[13:20:32.183]                     }
[13:20:32.183]                     muffleCondition(cond, pattern = "^muffle")
[13:20:32.183]                   }
[13:20:32.183]                 }
[13:20:32.183]             }
[13:20:32.183]         }))
[13:20:32.183]     }, error = function(ex) {
[13:20:32.183]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:32.183]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:32.183]                 ...future.rng), started = ...future.startTime, 
[13:20:32.183]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:32.183]             version = "1.8"), class = "FutureResult")
[13:20:32.183]     }, finally = {
[13:20:32.183]         if (!identical(...future.workdir, getwd())) 
[13:20:32.183]             setwd(...future.workdir)
[13:20:32.183]         {
[13:20:32.183]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:32.183]                 ...future.oldOptions$nwarnings <- NULL
[13:20:32.183]             }
[13:20:32.183]             base::options(...future.oldOptions)
[13:20:32.183]             if (.Platform$OS.type == "windows") {
[13:20:32.183]                 old_names <- names(...future.oldEnvVars)
[13:20:32.183]                 envs <- base::Sys.getenv()
[13:20:32.183]                 names <- names(envs)
[13:20:32.183]                 common <- intersect(names, old_names)
[13:20:32.183]                 added <- setdiff(names, old_names)
[13:20:32.183]                 removed <- setdiff(old_names, names)
[13:20:32.183]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:32.183]                   envs[common]]
[13:20:32.183]                 NAMES <- toupper(changed)
[13:20:32.183]                 args <- list()
[13:20:32.183]                 for (kk in seq_along(NAMES)) {
[13:20:32.183]                   name <- changed[[kk]]
[13:20:32.183]                   NAME <- NAMES[[kk]]
[13:20:32.183]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:32.183]                     next
[13:20:32.183]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:32.183]                 }
[13:20:32.183]                 NAMES <- toupper(added)
[13:20:32.183]                 for (kk in seq_along(NAMES)) {
[13:20:32.183]                   name <- added[[kk]]
[13:20:32.183]                   NAME <- NAMES[[kk]]
[13:20:32.183]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:32.183]                     next
[13:20:32.183]                   args[[name]] <- ""
[13:20:32.183]                 }
[13:20:32.183]                 NAMES <- toupper(removed)
[13:20:32.183]                 for (kk in seq_along(NAMES)) {
[13:20:32.183]                   name <- removed[[kk]]
[13:20:32.183]                   NAME <- NAMES[[kk]]
[13:20:32.183]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:32.183]                     next
[13:20:32.183]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:32.183]                 }
[13:20:32.183]                 if (length(args) > 0) 
[13:20:32.183]                   base::do.call(base::Sys.setenv, args = args)
[13:20:32.183]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:32.183]             }
[13:20:32.183]             else {
[13:20:32.183]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:32.183]             }
[13:20:32.183]             {
[13:20:32.183]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:32.183]                   0L) {
[13:20:32.183]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:32.183]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:32.183]                   base::options(opts)
[13:20:32.183]                 }
[13:20:32.183]                 {
[13:20:32.183]                   {
[13:20:32.183]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:32.183]                     NULL
[13:20:32.183]                   }
[13:20:32.183]                   options(future.plan = NULL)
[13:20:32.183]                   if (is.na(NA_character_)) 
[13:20:32.183]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:32.183]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:32.183]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:32.183]                     envir = parent.frame()) 
[13:20:32.183]                   {
[13:20:32.183]                     default_workers <- missing(workers)
[13:20:32.183]                     if (is.function(workers)) 
[13:20:32.183]                       workers <- workers()
[13:20:32.183]                     workers <- structure(as.integer(workers), 
[13:20:32.183]                       class = class(workers))
[13:20:32.183]                     stop_if_not(is.finite(workers), workers >= 
[13:20:32.183]                       1L)
[13:20:32.183]                     if ((workers == 1L && !inherits(workers, 
[13:20:32.183]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:32.183]                       if (default_workers) 
[13:20:32.183]                         supportsMulticore(warn = TRUE)
[13:20:32.183]                       return(sequential(..., envir = envir))
[13:20:32.183]                     }
[13:20:32.183]                     oopts <- options(mc.cores = workers)
[13:20:32.183]                     on.exit(options(oopts))
[13:20:32.183]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:32.183]                       envir = envir)
[13:20:32.183]                     if (!future$lazy) 
[13:20:32.183]                       future <- run(future)
[13:20:32.183]                     invisible(future)
[13:20:32.183]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:32.183]                 }
[13:20:32.183]             }
[13:20:32.183]         }
[13:20:32.183]     })
[13:20:32.183]     if (TRUE) {
[13:20:32.183]         base::sink(type = "output", split = FALSE)
[13:20:32.183]         if (TRUE) {
[13:20:32.183]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:32.183]         }
[13:20:32.183]         else {
[13:20:32.183]             ...future.result["stdout"] <- base::list(NULL)
[13:20:32.183]         }
[13:20:32.183]         base::close(...future.stdout)
[13:20:32.183]         ...future.stdout <- NULL
[13:20:32.183]     }
[13:20:32.183]     ...future.result$conditions <- ...future.conditions
[13:20:32.183]     ...future.result$finished <- base::Sys.time()
[13:20:32.183]     ...future.result
[13:20:32.183] }
[13:20:32.186] requestCore(): workers = 2
[13:20:32.188] MulticoreFuture started
[13:20:32.188] - Launch lazy future ... done
[13:20:32.188] run() for ‘MulticoreFuture’ ... done
[13:20:32.190] plan(): Setting new future strategy stack:
[13:20:32.190] List of future strategies:
[13:20:32.190] 1. sequential:
[13:20:32.190]    - args: function (..., envir = parent.frame())
[13:20:32.190]    - tweaked: FALSE
[13:20:32.190]    - call: NULL
[13:20:32.191] plan(): nbrOfWorkers() = 1
[13:20:32.194] plan(): Setting new future strategy stack:
[13:20:32.194] List of future strategies:
[13:20:32.194] 1. multicore:
[13:20:32.194]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:32.194]    - tweaked: FALSE
[13:20:32.194]    - call: plan(strategy)
[13:20:32.200] plan(): nbrOfWorkers() = 2

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[13:20:32.206] getGlobalsAndPackages() ...
[13:20:32.206] Searching for globals...
[13:20:32.208] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[13:20:32.208] Searching for globals ... DONE
[13:20:32.208] Resolving globals: FALSE
[13:20:32.209] 
[13:20:32.209] - packages: [2] ‘stats’, ‘datasets’
[13:20:32.209] getGlobalsAndPackages() ... DONE
[13:20:32.210] run() for ‘Future’ ...
[13:20:32.210] - state: ‘created’
[13:20:32.210] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:32.253] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:32.253] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:32.254]   - Field: ‘label’
[13:20:32.254]   - Field: ‘local’
[13:20:32.254]   - Field: ‘owner’
[13:20:32.254]   - Field: ‘envir’
[13:20:32.254]   - Field: ‘workers’
[13:20:32.254]   - Field: ‘packages’
[13:20:32.254]   - Field: ‘gc’
[13:20:32.254]   - Field: ‘job’
[13:20:32.254]   - Field: ‘conditions’
[13:20:32.255]   - Field: ‘expr’
[13:20:32.255]   - Field: ‘uuid’
[13:20:32.255]   - Field: ‘seed’
[13:20:32.255]   - Field: ‘version’
[13:20:32.255]   - Field: ‘result’
[13:20:32.255]   - Field: ‘asynchronous’
[13:20:32.255]   - Field: ‘calls’
[13:20:32.255]   - Field: ‘globals’
[13:20:32.255]   - Field: ‘stdout’
[13:20:32.256]   - Field: ‘earlySignal’
[13:20:32.256]   - Field: ‘lazy’
[13:20:32.256]   - Field: ‘state’
[13:20:32.256] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:32.256] - Launch lazy future ...
[13:20:32.256] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:20:32.256] Packages needed by future strategies (n = 0): <none>
[13:20:32.257] {
[13:20:32.257]     {
[13:20:32.257]         {
[13:20:32.257]             ...future.startTime <- base::Sys.time()
[13:20:32.257]             {
[13:20:32.257]                 {
[13:20:32.257]                   {
[13:20:32.257]                     {
[13:20:32.257]                       {
[13:20:32.257]                         base::local({
[13:20:32.257]                           has_future <- base::requireNamespace("future", 
[13:20:32.257]                             quietly = TRUE)
[13:20:32.257]                           if (has_future) {
[13:20:32.257]                             ns <- base::getNamespace("future")
[13:20:32.257]                             version <- ns[[".package"]][["version"]]
[13:20:32.257]                             if (is.null(version)) 
[13:20:32.257]                               version <- utils::packageVersion("future")
[13:20:32.257]                           }
[13:20:32.257]                           else {
[13:20:32.257]                             version <- NULL
[13:20:32.257]                           }
[13:20:32.257]                           if (!has_future || version < "1.8.0") {
[13:20:32.257]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:32.257]                               "", base::R.version$version.string), 
[13:20:32.257]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:32.257]                                 base::R.version$platform, 8 * 
[13:20:32.257]                                   base::.Machine$sizeof.pointer), 
[13:20:32.257]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:32.257]                                 "release", "version")], collapse = " "), 
[13:20:32.257]                               hostname = base::Sys.info()[["nodename"]])
[13:20:32.257]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:32.257]                               info)
[13:20:32.257]                             info <- base::paste(info, collapse = "; ")
[13:20:32.257]                             if (!has_future) {
[13:20:32.257]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:32.257]                                 info)
[13:20:32.257]                             }
[13:20:32.257]                             else {
[13:20:32.257]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:32.257]                                 info, version)
[13:20:32.257]                             }
[13:20:32.257]                             base::stop(msg)
[13:20:32.257]                           }
[13:20:32.257]                         })
[13:20:32.257]                       }
[13:20:32.257]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:32.257]                       base::options(mc.cores = 1L)
[13:20:32.257]                     }
[13:20:32.257]                     base::local({
[13:20:32.257]                       for (pkg in c("stats", "datasets")) {
[13:20:32.257]                         base::loadNamespace(pkg)
[13:20:32.257]                         base::library(pkg, character.only = TRUE)
[13:20:32.257]                       }
[13:20:32.257]                     })
[13:20:32.257]                   }
[13:20:32.257]                   options(future.plan = NULL)
[13:20:32.257]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:32.257]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:32.257]                 }
[13:20:32.257]                 ...future.workdir <- getwd()
[13:20:32.257]             }
[13:20:32.257]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:32.257]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:32.257]         }
[13:20:32.257]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:32.257]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:32.257]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:32.257]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:32.257]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:32.257]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:32.257]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:32.257]             base::names(...future.oldOptions))
[13:20:32.257]     }
[13:20:32.257]     if (FALSE) {
[13:20:32.257]     }
[13:20:32.257]     else {
[13:20:32.257]         if (TRUE) {
[13:20:32.257]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:32.257]                 open = "w")
[13:20:32.257]         }
[13:20:32.257]         else {
[13:20:32.257]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:32.257]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:32.257]         }
[13:20:32.257]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:32.257]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:32.257]             base::sink(type = "output", split = FALSE)
[13:20:32.257]             base::close(...future.stdout)
[13:20:32.257]         }, add = TRUE)
[13:20:32.257]     }
[13:20:32.257]     ...future.frame <- base::sys.nframe()
[13:20:32.257]     ...future.conditions <- base::list()
[13:20:32.257]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:32.257]     if (FALSE) {
[13:20:32.257]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:32.257]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:32.257]     }
[13:20:32.257]     ...future.result <- base::tryCatch({
[13:20:32.257]         base::withCallingHandlers({
[13:20:32.257]             ...future.value <- base::withVisible(base::local({
[13:20:32.257]                 withCallingHandlers({
[13:20:32.257]                   {
[13:20:32.257]                     lm(dist ~ . + 0, data = cars)
[13:20:32.257]                   }
[13:20:32.257]                 }, immediateCondition = function(cond) {
[13:20:32.257]                   save_rds <- function (object, pathname, ...) 
[13:20:32.257]                   {
[13:20:32.257]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:32.257]                     if (file_test("-f", pathname_tmp)) {
[13:20:32.257]                       fi_tmp <- file.info(pathname_tmp)
[13:20:32.257]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:32.257]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:32.257]                         fi_tmp[["mtime"]])
[13:20:32.257]                     }
[13:20:32.257]                     tryCatch({
[13:20:32.257]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:32.257]                     }, error = function(ex) {
[13:20:32.257]                       msg <- conditionMessage(ex)
[13:20:32.257]                       fi_tmp <- file.info(pathname_tmp)
[13:20:32.257]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:32.257]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:32.257]                         fi_tmp[["mtime"]], msg)
[13:20:32.257]                       ex$message <- msg
[13:20:32.257]                       stop(ex)
[13:20:32.257]                     })
[13:20:32.257]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:32.257]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:32.257]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:32.257]                       fi_tmp <- file.info(pathname_tmp)
[13:20:32.257]                       fi <- file.info(pathname)
[13:20:32.257]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:32.257]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:32.257]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:32.257]                         fi[["size"]], fi[["mtime"]])
[13:20:32.257]                       stop(msg)
[13:20:32.257]                     }
[13:20:32.257]                     invisible(pathname)
[13:20:32.257]                   }
[13:20:32.257]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:32.257]                     rootPath = tempdir()) 
[13:20:32.257]                   {
[13:20:32.257]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:32.257]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:32.257]                       tmpdir = path, fileext = ".rds")
[13:20:32.257]                     save_rds(obj, file)
[13:20:32.257]                   }
[13:20:32.257]                   saveImmediateCondition(cond, path = "/tmp/Rtmpnh0Esg/.future/immediateConditions")
[13:20:32.257]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:32.257]                   {
[13:20:32.257]                     inherits <- base::inherits
[13:20:32.257]                     invokeRestart <- base::invokeRestart
[13:20:32.257]                     is.null <- base::is.null
[13:20:32.257]                     muffled <- FALSE
[13:20:32.257]                     if (inherits(cond, "message")) {
[13:20:32.257]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:32.257]                       if (muffled) 
[13:20:32.257]                         invokeRestart("muffleMessage")
[13:20:32.257]                     }
[13:20:32.257]                     else if (inherits(cond, "warning")) {
[13:20:32.257]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:32.257]                       if (muffled) 
[13:20:32.257]                         invokeRestart("muffleWarning")
[13:20:32.257]                     }
[13:20:32.257]                     else if (inherits(cond, "condition")) {
[13:20:32.257]                       if (!is.null(pattern)) {
[13:20:32.257]                         computeRestarts <- base::computeRestarts
[13:20:32.257]                         grepl <- base::grepl
[13:20:32.257]                         restarts <- computeRestarts(cond)
[13:20:32.257]                         for (restart in restarts) {
[13:20:32.257]                           name <- restart$name
[13:20:32.257]                           if (is.null(name)) 
[13:20:32.257]                             next
[13:20:32.257]                           if (!grepl(pattern, name)) 
[13:20:32.257]                             next
[13:20:32.257]                           invokeRestart(restart)
[13:20:32.257]                           muffled <- TRUE
[13:20:32.257]                           break
[13:20:32.257]                         }
[13:20:32.257]                       }
[13:20:32.257]                     }
[13:20:32.257]                     invisible(muffled)
[13:20:32.257]                   }
[13:20:32.257]                   muffleCondition(cond)
[13:20:32.257]                 })
[13:20:32.257]             }))
[13:20:32.257]             future::FutureResult(value = ...future.value$value, 
[13:20:32.257]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:32.257]                   ...future.rng), globalenv = if (FALSE) 
[13:20:32.257]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:32.257]                     ...future.globalenv.names))
[13:20:32.257]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:32.257]         }, condition = base::local({
[13:20:32.257]             c <- base::c
[13:20:32.257]             inherits <- base::inherits
[13:20:32.257]             invokeRestart <- base::invokeRestart
[13:20:32.257]             length <- base::length
[13:20:32.257]             list <- base::list
[13:20:32.257]             seq.int <- base::seq.int
[13:20:32.257]             signalCondition <- base::signalCondition
[13:20:32.257]             sys.calls <- base::sys.calls
[13:20:32.257]             `[[` <- base::`[[`
[13:20:32.257]             `+` <- base::`+`
[13:20:32.257]             `<<-` <- base::`<<-`
[13:20:32.257]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:32.257]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:32.257]                   3L)]
[13:20:32.257]             }
[13:20:32.257]             function(cond) {
[13:20:32.257]                 is_error <- inherits(cond, "error")
[13:20:32.257]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:32.257]                   NULL)
[13:20:32.257]                 if (is_error) {
[13:20:32.257]                   sessionInformation <- function() {
[13:20:32.257]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:32.257]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:32.257]                       search = base::search(), system = base::Sys.info())
[13:20:32.257]                   }
[13:20:32.257]                   ...future.conditions[[length(...future.conditions) + 
[13:20:32.257]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:32.257]                     cond$call), session = sessionInformation(), 
[13:20:32.257]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:32.257]                   signalCondition(cond)
[13:20:32.257]                 }
[13:20:32.257]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:32.257]                 "immediateCondition"))) {
[13:20:32.257]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:32.257]                   ...future.conditions[[length(...future.conditions) + 
[13:20:32.257]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:32.257]                   if (TRUE && !signal) {
[13:20:32.257]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:32.257]                     {
[13:20:32.257]                       inherits <- base::inherits
[13:20:32.257]                       invokeRestart <- base::invokeRestart
[13:20:32.257]                       is.null <- base::is.null
[13:20:32.257]                       muffled <- FALSE
[13:20:32.257]                       if (inherits(cond, "message")) {
[13:20:32.257]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:32.257]                         if (muffled) 
[13:20:32.257]                           invokeRestart("muffleMessage")
[13:20:32.257]                       }
[13:20:32.257]                       else if (inherits(cond, "warning")) {
[13:20:32.257]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:32.257]                         if (muffled) 
[13:20:32.257]                           invokeRestart("muffleWarning")
[13:20:32.257]                       }
[13:20:32.257]                       else if (inherits(cond, "condition")) {
[13:20:32.257]                         if (!is.null(pattern)) {
[13:20:32.257]                           computeRestarts <- base::computeRestarts
[13:20:32.257]                           grepl <- base::grepl
[13:20:32.257]                           restarts <- computeRestarts(cond)
[13:20:32.257]                           for (restart in restarts) {
[13:20:32.257]                             name <- restart$name
[13:20:32.257]                             if (is.null(name)) 
[13:20:32.257]                               next
[13:20:32.257]                             if (!grepl(pattern, name)) 
[13:20:32.257]                               next
[13:20:32.257]                             invokeRestart(restart)
[13:20:32.257]                             muffled <- TRUE
[13:20:32.257]                             break
[13:20:32.257]                           }
[13:20:32.257]                         }
[13:20:32.257]                       }
[13:20:32.257]                       invisible(muffled)
[13:20:32.257]                     }
[13:20:32.257]                     muffleCondition(cond, pattern = "^muffle")
[13:20:32.257]                   }
[13:20:32.257]                 }
[13:20:32.257]                 else {
[13:20:32.257]                   if (TRUE) {
[13:20:32.257]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:32.257]                     {
[13:20:32.257]                       inherits <- base::inherits
[13:20:32.257]                       invokeRestart <- base::invokeRestart
[13:20:32.257]                       is.null <- base::is.null
[13:20:32.257]                       muffled <- FALSE
[13:20:32.257]                       if (inherits(cond, "message")) {
[13:20:32.257]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:32.257]                         if (muffled) 
[13:20:32.257]                           invokeRestart("muffleMessage")
[13:20:32.257]                       }
[13:20:32.257]                       else if (inherits(cond, "warning")) {
[13:20:32.257]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:32.257]                         if (muffled) 
[13:20:32.257]                           invokeRestart("muffleWarning")
[13:20:32.257]                       }
[13:20:32.257]                       else if (inherits(cond, "condition")) {
[13:20:32.257]                         if (!is.null(pattern)) {
[13:20:32.257]                           computeRestarts <- base::computeRestarts
[13:20:32.257]                           grepl <- base::grepl
[13:20:32.257]                           restarts <- computeRestarts(cond)
[13:20:32.257]                           for (restart in restarts) {
[13:20:32.257]                             name <- restart$name
[13:20:32.257]                             if (is.null(name)) 
[13:20:32.257]                               next
[13:20:32.257]                             if (!grepl(pattern, name)) 
[13:20:32.257]                               next
[13:20:32.257]                             invokeRestart(restart)
[13:20:32.257]                             muffled <- TRUE
[13:20:32.257]                             break
[13:20:32.257]                           }
[13:20:32.257]                         }
[13:20:32.257]                       }
[13:20:32.257]                       invisible(muffled)
[13:20:32.257]                     }
[13:20:32.257]                     muffleCondition(cond, pattern = "^muffle")
[13:20:32.257]                   }
[13:20:32.257]                 }
[13:20:32.257]             }
[13:20:32.257]         }))
[13:20:32.257]     }, error = function(ex) {
[13:20:32.257]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:32.257]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:32.257]                 ...future.rng), started = ...future.startTime, 
[13:20:32.257]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:32.257]             version = "1.8"), class = "FutureResult")
[13:20:32.257]     }, finally = {
[13:20:32.257]         if (!identical(...future.workdir, getwd())) 
[13:20:32.257]             setwd(...future.workdir)
[13:20:32.257]         {
[13:20:32.257]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:32.257]                 ...future.oldOptions$nwarnings <- NULL
[13:20:32.257]             }
[13:20:32.257]             base::options(...future.oldOptions)
[13:20:32.257]             if (.Platform$OS.type == "windows") {
[13:20:32.257]                 old_names <- names(...future.oldEnvVars)
[13:20:32.257]                 envs <- base::Sys.getenv()
[13:20:32.257]                 names <- names(envs)
[13:20:32.257]                 common <- intersect(names, old_names)
[13:20:32.257]                 added <- setdiff(names, old_names)
[13:20:32.257]                 removed <- setdiff(old_names, names)
[13:20:32.257]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:32.257]                   envs[common]]
[13:20:32.257]                 NAMES <- toupper(changed)
[13:20:32.257]                 args <- list()
[13:20:32.257]                 for (kk in seq_along(NAMES)) {
[13:20:32.257]                   name <- changed[[kk]]
[13:20:32.257]                   NAME <- NAMES[[kk]]
[13:20:32.257]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:32.257]                     next
[13:20:32.257]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:32.257]                 }
[13:20:32.257]                 NAMES <- toupper(added)
[13:20:32.257]                 for (kk in seq_along(NAMES)) {
[13:20:32.257]                   name <- added[[kk]]
[13:20:32.257]                   NAME <- NAMES[[kk]]
[13:20:32.257]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:32.257]                     next
[13:20:32.257]                   args[[name]] <- ""
[13:20:32.257]                 }
[13:20:32.257]                 NAMES <- toupper(removed)
[13:20:32.257]                 for (kk in seq_along(NAMES)) {
[13:20:32.257]                   name <- removed[[kk]]
[13:20:32.257]                   NAME <- NAMES[[kk]]
[13:20:32.257]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:32.257]                     next
[13:20:32.257]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:32.257]                 }
[13:20:32.257]                 if (length(args) > 0) 
[13:20:32.257]                   base::do.call(base::Sys.setenv, args = args)
[13:20:32.257]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:32.257]             }
[13:20:32.257]             else {
[13:20:32.257]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:32.257]             }
[13:20:32.257]             {
[13:20:32.257]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:32.257]                   0L) {
[13:20:32.257]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:32.257]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:32.257]                   base::options(opts)
[13:20:32.257]                 }
[13:20:32.257]                 {
[13:20:32.257]                   {
[13:20:32.257]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:32.257]                     NULL
[13:20:32.257]                   }
[13:20:32.257]                   options(future.plan = NULL)
[13:20:32.257]                   if (is.na(NA_character_)) 
[13:20:32.257]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:32.257]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:32.257]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:32.257]                     envir = parent.frame()) 
[13:20:32.257]                   {
[13:20:32.257]                     default_workers <- missing(workers)
[13:20:32.257]                     if (is.function(workers)) 
[13:20:32.257]                       workers <- workers()
[13:20:32.257]                     workers <- structure(as.integer(workers), 
[13:20:32.257]                       class = class(workers))
[13:20:32.257]                     stop_if_not(is.finite(workers), workers >= 
[13:20:32.257]                       1L)
[13:20:32.257]                     if ((workers == 1L && !inherits(workers, 
[13:20:32.257]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:32.257]                       if (default_workers) 
[13:20:32.257]                         supportsMulticore(warn = TRUE)
[13:20:32.257]                       return(sequential(..., envir = envir))
[13:20:32.257]                     }
[13:20:32.257]                     oopts <- options(mc.cores = workers)
[13:20:32.257]                     on.exit(options(oopts))
[13:20:32.257]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:32.257]                       envir = envir)
[13:20:32.257]                     if (!future$lazy) 
[13:20:32.257]                       future <- run(future)
[13:20:32.257]                     invisible(future)
[13:20:32.257]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:32.257]                 }
[13:20:32.257]             }
[13:20:32.257]         }
[13:20:32.257]     })
[13:20:32.257]     if (TRUE) {
[13:20:32.257]         base::sink(type = "output", split = FALSE)
[13:20:32.257]         if (TRUE) {
[13:20:32.257]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:32.257]         }
[13:20:32.257]         else {
[13:20:32.257]             ...future.result["stdout"] <- base::list(NULL)
[13:20:32.257]         }
[13:20:32.257]         base::close(...future.stdout)
[13:20:32.257]         ...future.stdout <- NULL
[13:20:32.257]     }
[13:20:32.257]     ...future.result$conditions <- ...future.conditions
[13:20:32.257]     ...future.result$finished <- base::Sys.time()
[13:20:32.257]     ...future.result
[13:20:32.257] }
[13:20:32.259] requestCore(): workers = 2
[13:20:32.262] MulticoreFuture started
[13:20:32.262] - Launch lazy future ... done
[13:20:32.262] run() for ‘MulticoreFuture’ ... done
[13:20:32.263] plan(): Setting new future strategy stack:
[13:20:32.264] List of future strategies:
[13:20:32.264] 1. sequential:
[13:20:32.264]    - args: function (..., envir = parent.frame())
[13:20:32.264]    - tweaked: FALSE
[13:20:32.264]    - call: NULL
[13:20:32.265] plan(): nbrOfWorkers() = 1
[13:20:32.269] plan(): Setting new future strategy stack:
[13:20:32.269] List of future strategies:
[13:20:32.269] 1. multicore:
[13:20:32.269]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:32.269]    - tweaked: FALSE
[13:20:32.269]    - call: plan(strategy)
[13:20:32.275] plan(): nbrOfWorkers() = 2

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[13:20:32.281] getGlobalsAndPackages() ...
[13:20:32.281] Searching for globals...
[13:20:32.284] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[13:20:32.284] Searching for globals ... DONE
[13:20:32.284] Resolving globals: FALSE
[13:20:32.285] 
[13:20:32.285] - packages: [2] ‘stats’, ‘datasets’
[13:20:32.285] getGlobalsAndPackages() ... DONE
[13:20:32.285] run() for ‘Future’ ...
[13:20:32.286] - state: ‘created’
[13:20:32.286] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:32.290] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:32.290] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:32.290]   - Field: ‘label’
[13:20:32.290]   - Field: ‘local’
[13:20:32.290]   - Field: ‘owner’
[13:20:32.290]   - Field: ‘envir’
[13:20:32.291]   - Field: ‘workers’
[13:20:32.291]   - Field: ‘packages’
[13:20:32.291]   - Field: ‘gc’
[13:20:32.291]   - Field: ‘job’
[13:20:32.291]   - Field: ‘conditions’
[13:20:32.291]   - Field: ‘expr’
[13:20:32.291]   - Field: ‘uuid’
[13:20:32.291]   - Field: ‘seed’
[13:20:32.292]   - Field: ‘version’
[13:20:32.292]   - Field: ‘result’
[13:20:32.292]   - Field: ‘asynchronous’
[13:20:32.292]   - Field: ‘calls’
[13:20:32.292]   - Field: ‘globals’
[13:20:32.292]   - Field: ‘stdout’
[13:20:32.292]   - Field: ‘earlySignal’
[13:20:32.292]   - Field: ‘lazy’
[13:20:32.292]   - Field: ‘state’
[13:20:32.293] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:32.293] - Launch lazy future ...
[13:20:32.293] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:20:32.293] Packages needed by future strategies (n = 0): <none>
[13:20:32.294] {
[13:20:32.294]     {
[13:20:32.294]         {
[13:20:32.294]             ...future.startTime <- base::Sys.time()
[13:20:32.294]             {
[13:20:32.294]                 {
[13:20:32.294]                   {
[13:20:32.294]                     {
[13:20:32.294]                       {
[13:20:32.294]                         base::local({
[13:20:32.294]                           has_future <- base::requireNamespace("future", 
[13:20:32.294]                             quietly = TRUE)
[13:20:32.294]                           if (has_future) {
[13:20:32.294]                             ns <- base::getNamespace("future")
[13:20:32.294]                             version <- ns[[".package"]][["version"]]
[13:20:32.294]                             if (is.null(version)) 
[13:20:32.294]                               version <- utils::packageVersion("future")
[13:20:32.294]                           }
[13:20:32.294]                           else {
[13:20:32.294]                             version <- NULL
[13:20:32.294]                           }
[13:20:32.294]                           if (!has_future || version < "1.8.0") {
[13:20:32.294]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:32.294]                               "", base::R.version$version.string), 
[13:20:32.294]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:32.294]                                 base::R.version$platform, 8 * 
[13:20:32.294]                                   base::.Machine$sizeof.pointer), 
[13:20:32.294]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:32.294]                                 "release", "version")], collapse = " "), 
[13:20:32.294]                               hostname = base::Sys.info()[["nodename"]])
[13:20:32.294]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:32.294]                               info)
[13:20:32.294]                             info <- base::paste(info, collapse = "; ")
[13:20:32.294]                             if (!has_future) {
[13:20:32.294]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:32.294]                                 info)
[13:20:32.294]                             }
[13:20:32.294]                             else {
[13:20:32.294]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:32.294]                                 info, version)
[13:20:32.294]                             }
[13:20:32.294]                             base::stop(msg)
[13:20:32.294]                           }
[13:20:32.294]                         })
[13:20:32.294]                       }
[13:20:32.294]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:32.294]                       base::options(mc.cores = 1L)
[13:20:32.294]                     }
[13:20:32.294]                     base::local({
[13:20:32.294]                       for (pkg in c("stats", "datasets")) {
[13:20:32.294]                         base::loadNamespace(pkg)
[13:20:32.294]                         base::library(pkg, character.only = TRUE)
[13:20:32.294]                       }
[13:20:32.294]                     })
[13:20:32.294]                   }
[13:20:32.294]                   options(future.plan = NULL)
[13:20:32.294]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:32.294]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:32.294]                 }
[13:20:32.294]                 ...future.workdir <- getwd()
[13:20:32.294]             }
[13:20:32.294]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:32.294]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:32.294]         }
[13:20:32.294]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:32.294]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:32.294]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:32.294]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:32.294]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:32.294]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:32.294]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:32.294]             base::names(...future.oldOptions))
[13:20:32.294]     }
[13:20:32.294]     if (FALSE) {
[13:20:32.294]     }
[13:20:32.294]     else {
[13:20:32.294]         if (TRUE) {
[13:20:32.294]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:32.294]                 open = "w")
[13:20:32.294]         }
[13:20:32.294]         else {
[13:20:32.294]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:32.294]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:32.294]         }
[13:20:32.294]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:32.294]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:32.294]             base::sink(type = "output", split = FALSE)
[13:20:32.294]             base::close(...future.stdout)
[13:20:32.294]         }, add = TRUE)
[13:20:32.294]     }
[13:20:32.294]     ...future.frame <- base::sys.nframe()
[13:20:32.294]     ...future.conditions <- base::list()
[13:20:32.294]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:32.294]     if (FALSE) {
[13:20:32.294]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:32.294]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:32.294]     }
[13:20:32.294]     ...future.result <- base::tryCatch({
[13:20:32.294]         base::withCallingHandlers({
[13:20:32.294]             ...future.value <- base::withVisible(base::local({
[13:20:32.294]                 withCallingHandlers({
[13:20:32.294]                   {
[13:20:32.294]                     lm(dist ~ speed + speed^2, data = cars)
[13:20:32.294]                   }
[13:20:32.294]                 }, immediateCondition = function(cond) {
[13:20:32.294]                   save_rds <- function (object, pathname, ...) 
[13:20:32.294]                   {
[13:20:32.294]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:32.294]                     if (file_test("-f", pathname_tmp)) {
[13:20:32.294]                       fi_tmp <- file.info(pathname_tmp)
[13:20:32.294]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:32.294]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:32.294]                         fi_tmp[["mtime"]])
[13:20:32.294]                     }
[13:20:32.294]                     tryCatch({
[13:20:32.294]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:32.294]                     }, error = function(ex) {
[13:20:32.294]                       msg <- conditionMessage(ex)
[13:20:32.294]                       fi_tmp <- file.info(pathname_tmp)
[13:20:32.294]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:32.294]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:32.294]                         fi_tmp[["mtime"]], msg)
[13:20:32.294]                       ex$message <- msg
[13:20:32.294]                       stop(ex)
[13:20:32.294]                     })
[13:20:32.294]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:32.294]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:32.294]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:32.294]                       fi_tmp <- file.info(pathname_tmp)
[13:20:32.294]                       fi <- file.info(pathname)
[13:20:32.294]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:32.294]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:32.294]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:32.294]                         fi[["size"]], fi[["mtime"]])
[13:20:32.294]                       stop(msg)
[13:20:32.294]                     }
[13:20:32.294]                     invisible(pathname)
[13:20:32.294]                   }
[13:20:32.294]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:32.294]                     rootPath = tempdir()) 
[13:20:32.294]                   {
[13:20:32.294]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:32.294]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:32.294]                       tmpdir = path, fileext = ".rds")
[13:20:32.294]                     save_rds(obj, file)
[13:20:32.294]                   }
[13:20:32.294]                   saveImmediateCondition(cond, path = "/tmp/Rtmpnh0Esg/.future/immediateConditions")
[13:20:32.294]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:32.294]                   {
[13:20:32.294]                     inherits <- base::inherits
[13:20:32.294]                     invokeRestart <- base::invokeRestart
[13:20:32.294]                     is.null <- base::is.null
[13:20:32.294]                     muffled <- FALSE
[13:20:32.294]                     if (inherits(cond, "message")) {
[13:20:32.294]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:32.294]                       if (muffled) 
[13:20:32.294]                         invokeRestart("muffleMessage")
[13:20:32.294]                     }
[13:20:32.294]                     else if (inherits(cond, "warning")) {
[13:20:32.294]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:32.294]                       if (muffled) 
[13:20:32.294]                         invokeRestart("muffleWarning")
[13:20:32.294]                     }
[13:20:32.294]                     else if (inherits(cond, "condition")) {
[13:20:32.294]                       if (!is.null(pattern)) {
[13:20:32.294]                         computeRestarts <- base::computeRestarts
[13:20:32.294]                         grepl <- base::grepl
[13:20:32.294]                         restarts <- computeRestarts(cond)
[13:20:32.294]                         for (restart in restarts) {
[13:20:32.294]                           name <- restart$name
[13:20:32.294]                           if (is.null(name)) 
[13:20:32.294]                             next
[13:20:32.294]                           if (!grepl(pattern, name)) 
[13:20:32.294]                             next
[13:20:32.294]                           invokeRestart(restart)
[13:20:32.294]                           muffled <- TRUE
[13:20:32.294]                           break
[13:20:32.294]                         }
[13:20:32.294]                       }
[13:20:32.294]                     }
[13:20:32.294]                     invisible(muffled)
[13:20:32.294]                   }
[13:20:32.294]                   muffleCondition(cond)
[13:20:32.294]                 })
[13:20:32.294]             }))
[13:20:32.294]             future::FutureResult(value = ...future.value$value, 
[13:20:32.294]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:32.294]                   ...future.rng), globalenv = if (FALSE) 
[13:20:32.294]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:32.294]                     ...future.globalenv.names))
[13:20:32.294]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:32.294]         }, condition = base::local({
[13:20:32.294]             c <- base::c
[13:20:32.294]             inherits <- base::inherits
[13:20:32.294]             invokeRestart <- base::invokeRestart
[13:20:32.294]             length <- base::length
[13:20:32.294]             list <- base::list
[13:20:32.294]             seq.int <- base::seq.int
[13:20:32.294]             signalCondition <- base::signalCondition
[13:20:32.294]             sys.calls <- base::sys.calls
[13:20:32.294]             `[[` <- base::`[[`
[13:20:32.294]             `+` <- base::`+`
[13:20:32.294]             `<<-` <- base::`<<-`
[13:20:32.294]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:32.294]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:32.294]                   3L)]
[13:20:32.294]             }
[13:20:32.294]             function(cond) {
[13:20:32.294]                 is_error <- inherits(cond, "error")
[13:20:32.294]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:32.294]                   NULL)
[13:20:32.294]                 if (is_error) {
[13:20:32.294]                   sessionInformation <- function() {
[13:20:32.294]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:32.294]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:32.294]                       search = base::search(), system = base::Sys.info())
[13:20:32.294]                   }
[13:20:32.294]                   ...future.conditions[[length(...future.conditions) + 
[13:20:32.294]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:32.294]                     cond$call), session = sessionInformation(), 
[13:20:32.294]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:32.294]                   signalCondition(cond)
[13:20:32.294]                 }
[13:20:32.294]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:32.294]                 "immediateCondition"))) {
[13:20:32.294]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:32.294]                   ...future.conditions[[length(...future.conditions) + 
[13:20:32.294]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:32.294]                   if (TRUE && !signal) {
[13:20:32.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:32.294]                     {
[13:20:32.294]                       inherits <- base::inherits
[13:20:32.294]                       invokeRestart <- base::invokeRestart
[13:20:32.294]                       is.null <- base::is.null
[13:20:32.294]                       muffled <- FALSE
[13:20:32.294]                       if (inherits(cond, "message")) {
[13:20:32.294]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:32.294]                         if (muffled) 
[13:20:32.294]                           invokeRestart("muffleMessage")
[13:20:32.294]                       }
[13:20:32.294]                       else if (inherits(cond, "warning")) {
[13:20:32.294]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:32.294]                         if (muffled) 
[13:20:32.294]                           invokeRestart("muffleWarning")
[13:20:32.294]                       }
[13:20:32.294]                       else if (inherits(cond, "condition")) {
[13:20:32.294]                         if (!is.null(pattern)) {
[13:20:32.294]                           computeRestarts <- base::computeRestarts
[13:20:32.294]                           grepl <- base::grepl
[13:20:32.294]                           restarts <- computeRestarts(cond)
[13:20:32.294]                           for (restart in restarts) {
[13:20:32.294]                             name <- restart$name
[13:20:32.294]                             if (is.null(name)) 
[13:20:32.294]                               next
[13:20:32.294]                             if (!grepl(pattern, name)) 
[13:20:32.294]                               next
[13:20:32.294]                             invokeRestart(restart)
[13:20:32.294]                             muffled <- TRUE
[13:20:32.294]                             break
[13:20:32.294]                           }
[13:20:32.294]                         }
[13:20:32.294]                       }
[13:20:32.294]                       invisible(muffled)
[13:20:32.294]                     }
[13:20:32.294]                     muffleCondition(cond, pattern = "^muffle")
[13:20:32.294]                   }
[13:20:32.294]                 }
[13:20:32.294]                 else {
[13:20:32.294]                   if (TRUE) {
[13:20:32.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:32.294]                     {
[13:20:32.294]                       inherits <- base::inherits
[13:20:32.294]                       invokeRestart <- base::invokeRestart
[13:20:32.294]                       is.null <- base::is.null
[13:20:32.294]                       muffled <- FALSE
[13:20:32.294]                       if (inherits(cond, "message")) {
[13:20:32.294]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:32.294]                         if (muffled) 
[13:20:32.294]                           invokeRestart("muffleMessage")
[13:20:32.294]                       }
[13:20:32.294]                       else if (inherits(cond, "warning")) {
[13:20:32.294]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:32.294]                         if (muffled) 
[13:20:32.294]                           invokeRestart("muffleWarning")
[13:20:32.294]                       }
[13:20:32.294]                       else if (inherits(cond, "condition")) {
[13:20:32.294]                         if (!is.null(pattern)) {
[13:20:32.294]                           computeRestarts <- base::computeRestarts
[13:20:32.294]                           grepl <- base::grepl
[13:20:32.294]                           restarts <- computeRestarts(cond)
[13:20:32.294]                           for (restart in restarts) {
[13:20:32.294]                             name <- restart$name
[13:20:32.294]                             if (is.null(name)) 
[13:20:32.294]                               next
[13:20:32.294]                             if (!grepl(pattern, name)) 
[13:20:32.294]                               next
[13:20:32.294]                             invokeRestart(restart)
[13:20:32.294]                             muffled <- TRUE
[13:20:32.294]                             break
[13:20:32.294]                           }
[13:20:32.294]                         }
[13:20:32.294]                       }
[13:20:32.294]                       invisible(muffled)
[13:20:32.294]                     }
[13:20:32.294]                     muffleCondition(cond, pattern = "^muffle")
[13:20:32.294]                   }
[13:20:32.294]                 }
[13:20:32.294]             }
[13:20:32.294]         }))
[13:20:32.294]     }, error = function(ex) {
[13:20:32.294]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:32.294]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:32.294]                 ...future.rng), started = ...future.startTime, 
[13:20:32.294]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:32.294]             version = "1.8"), class = "FutureResult")
[13:20:32.294]     }, finally = {
[13:20:32.294]         if (!identical(...future.workdir, getwd())) 
[13:20:32.294]             setwd(...future.workdir)
[13:20:32.294]         {
[13:20:32.294]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:32.294]                 ...future.oldOptions$nwarnings <- NULL
[13:20:32.294]             }
[13:20:32.294]             base::options(...future.oldOptions)
[13:20:32.294]             if (.Platform$OS.type == "windows") {
[13:20:32.294]                 old_names <- names(...future.oldEnvVars)
[13:20:32.294]                 envs <- base::Sys.getenv()
[13:20:32.294]                 names <- names(envs)
[13:20:32.294]                 common <- intersect(names, old_names)
[13:20:32.294]                 added <- setdiff(names, old_names)
[13:20:32.294]                 removed <- setdiff(old_names, names)
[13:20:32.294]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:32.294]                   envs[common]]
[13:20:32.294]                 NAMES <- toupper(changed)
[13:20:32.294]                 args <- list()
[13:20:32.294]                 for (kk in seq_along(NAMES)) {
[13:20:32.294]                   name <- changed[[kk]]
[13:20:32.294]                   NAME <- NAMES[[kk]]
[13:20:32.294]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:32.294]                     next
[13:20:32.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:32.294]                 }
[13:20:32.294]                 NAMES <- toupper(added)
[13:20:32.294]                 for (kk in seq_along(NAMES)) {
[13:20:32.294]                   name <- added[[kk]]
[13:20:32.294]                   NAME <- NAMES[[kk]]
[13:20:32.294]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:32.294]                     next
[13:20:32.294]                   args[[name]] <- ""
[13:20:32.294]                 }
[13:20:32.294]                 NAMES <- toupper(removed)
[13:20:32.294]                 for (kk in seq_along(NAMES)) {
[13:20:32.294]                   name <- removed[[kk]]
[13:20:32.294]                   NAME <- NAMES[[kk]]
[13:20:32.294]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:32.294]                     next
[13:20:32.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:32.294]                 }
[13:20:32.294]                 if (length(args) > 0) 
[13:20:32.294]                   base::do.call(base::Sys.setenv, args = args)
[13:20:32.294]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:32.294]             }
[13:20:32.294]             else {
[13:20:32.294]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:32.294]             }
[13:20:32.294]             {
[13:20:32.294]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:32.294]                   0L) {
[13:20:32.294]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:32.294]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:32.294]                   base::options(opts)
[13:20:32.294]                 }
[13:20:32.294]                 {
[13:20:32.294]                   {
[13:20:32.294]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:32.294]                     NULL
[13:20:32.294]                   }
[13:20:32.294]                   options(future.plan = NULL)
[13:20:32.294]                   if (is.na(NA_character_)) 
[13:20:32.294]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:32.294]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:32.294]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:32.294]                     envir = parent.frame()) 
[13:20:32.294]                   {
[13:20:32.294]                     default_workers <- missing(workers)
[13:20:32.294]                     if (is.function(workers)) 
[13:20:32.294]                       workers <- workers()
[13:20:32.294]                     workers <- structure(as.integer(workers), 
[13:20:32.294]                       class = class(workers))
[13:20:32.294]                     stop_if_not(is.finite(workers), workers >= 
[13:20:32.294]                       1L)
[13:20:32.294]                     if ((workers == 1L && !inherits(workers, 
[13:20:32.294]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:32.294]                       if (default_workers) 
[13:20:32.294]                         supportsMulticore(warn = TRUE)
[13:20:32.294]                       return(sequential(..., envir = envir))
[13:20:32.294]                     }
[13:20:32.294]                     oopts <- options(mc.cores = workers)
[13:20:32.294]                     on.exit(options(oopts))
[13:20:32.294]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:32.294]                       envir = envir)
[13:20:32.294]                     if (!future$lazy) 
[13:20:32.294]                       future <- run(future)
[13:20:32.294]                     invisible(future)
[13:20:32.294]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:32.294]                 }
[13:20:32.294]             }
[13:20:32.294]         }
[13:20:32.294]     })
[13:20:32.294]     if (TRUE) {
[13:20:32.294]         base::sink(type = "output", split = FALSE)
[13:20:32.294]         if (TRUE) {
[13:20:32.294]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:32.294]         }
[13:20:32.294]         else {
[13:20:32.294]             ...future.result["stdout"] <- base::list(NULL)
[13:20:32.294]         }
[13:20:32.294]         base::close(...future.stdout)
[13:20:32.294]         ...future.stdout <- NULL
[13:20:32.294]     }
[13:20:32.294]     ...future.result$conditions <- ...future.conditions
[13:20:32.294]     ...future.result$finished <- base::Sys.time()
[13:20:32.294]     ...future.result
[13:20:32.294] }
[13:20:32.297] requestCore(): workers = 2
[13:20:32.299] MulticoreFuture started
[13:20:32.299] - Launch lazy future ... done
[13:20:32.300] run() for ‘MulticoreFuture’ ... done
[13:20:32.301] plan(): Setting new future strategy stack:
[13:20:32.301] List of future strategies:
[13:20:32.301] 1. sequential:
[13:20:32.301]    - args: function (..., envir = parent.frame())
[13:20:32.301]    - tweaked: FALSE
[13:20:32.301]    - call: NULL
[13:20:32.302] plan(): nbrOfWorkers() = 1
[13:20:32.305] plan(): Setting new future strategy stack:
[13:20:32.306] List of future strategies:
[13:20:32.306] 1. multicore:
[13:20:32.306]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:32.306]    - tweaked: FALSE
[13:20:32.306]    - call: plan(strategy)
[13:20:32.311] plan(): nbrOfWorkers() = 2

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[13:20:32.318] getGlobalsAndPackages() ...
[13:20:32.318] Searching for globals...
[13:20:32.324] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[13:20:32.324] Searching for globals ... DONE
[13:20:32.324] Resolving globals: FALSE
[13:20:32.325] 
[13:20:32.325] - packages: [2] ‘stats’, ‘datasets’
[13:20:32.325] getGlobalsAndPackages() ... DONE
[13:20:32.326] run() for ‘Future’ ...
[13:20:32.326] - state: ‘created’
[13:20:32.326] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:32.330] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:32.330] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:32.330]   - Field: ‘label’
[13:20:32.330]   - Field: ‘local’
[13:20:32.330]   - Field: ‘owner’
[13:20:32.331]   - Field: ‘envir’
[13:20:32.331]   - Field: ‘workers’
[13:20:32.331]   - Field: ‘packages’
[13:20:32.331]   - Field: ‘gc’
[13:20:32.331]   - Field: ‘job’
[13:20:32.331]   - Field: ‘conditions’
[13:20:32.331]   - Field: ‘expr’
[13:20:32.331]   - Field: ‘uuid’
[13:20:32.332]   - Field: ‘seed’
[13:20:32.332]   - Field: ‘version’
[13:20:32.332]   - Field: ‘result’
[13:20:32.332]   - Field: ‘asynchronous’
[13:20:32.332]   - Field: ‘calls’
[13:20:32.332]   - Field: ‘globals’
[13:20:32.332]   - Field: ‘stdout’
[13:20:32.333]   - Field: ‘earlySignal’
[13:20:32.333]   - Field: ‘lazy’
[13:20:32.333]   - Field: ‘state’
[13:20:32.333] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:32.333] - Launch lazy future ...
[13:20:32.333] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:20:32.334] Packages needed by future strategies (n = 0): <none>
[13:20:32.334] {
[13:20:32.334]     {
[13:20:32.334]         {
[13:20:32.334]             ...future.startTime <- base::Sys.time()
[13:20:32.334]             {
[13:20:32.334]                 {
[13:20:32.334]                   {
[13:20:32.334]                     {
[13:20:32.334]                       {
[13:20:32.334]                         base::local({
[13:20:32.334]                           has_future <- base::requireNamespace("future", 
[13:20:32.334]                             quietly = TRUE)
[13:20:32.334]                           if (has_future) {
[13:20:32.334]                             ns <- base::getNamespace("future")
[13:20:32.334]                             version <- ns[[".package"]][["version"]]
[13:20:32.334]                             if (is.null(version)) 
[13:20:32.334]                               version <- utils::packageVersion("future")
[13:20:32.334]                           }
[13:20:32.334]                           else {
[13:20:32.334]                             version <- NULL
[13:20:32.334]                           }
[13:20:32.334]                           if (!has_future || version < "1.8.0") {
[13:20:32.334]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:32.334]                               "", base::R.version$version.string), 
[13:20:32.334]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:32.334]                                 base::R.version$platform, 8 * 
[13:20:32.334]                                   base::.Machine$sizeof.pointer), 
[13:20:32.334]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:32.334]                                 "release", "version")], collapse = " "), 
[13:20:32.334]                               hostname = base::Sys.info()[["nodename"]])
[13:20:32.334]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:32.334]                               info)
[13:20:32.334]                             info <- base::paste(info, collapse = "; ")
[13:20:32.334]                             if (!has_future) {
[13:20:32.334]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:32.334]                                 info)
[13:20:32.334]                             }
[13:20:32.334]                             else {
[13:20:32.334]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:32.334]                                 info, version)
[13:20:32.334]                             }
[13:20:32.334]                             base::stop(msg)
[13:20:32.334]                           }
[13:20:32.334]                         })
[13:20:32.334]                       }
[13:20:32.334]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:32.334]                       base::options(mc.cores = 1L)
[13:20:32.334]                     }
[13:20:32.334]                     base::local({
[13:20:32.334]                       for (pkg in c("stats", "datasets")) {
[13:20:32.334]                         base::loadNamespace(pkg)
[13:20:32.334]                         base::library(pkg, character.only = TRUE)
[13:20:32.334]                       }
[13:20:32.334]                     })
[13:20:32.334]                   }
[13:20:32.334]                   options(future.plan = NULL)
[13:20:32.334]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:32.334]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:32.334]                 }
[13:20:32.334]                 ...future.workdir <- getwd()
[13:20:32.334]             }
[13:20:32.334]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:32.334]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:32.334]         }
[13:20:32.334]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:32.334]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:32.334]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:32.334]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:32.334]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:32.334]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:32.334]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:32.334]             base::names(...future.oldOptions))
[13:20:32.334]     }
[13:20:32.334]     if (FALSE) {
[13:20:32.334]     }
[13:20:32.334]     else {
[13:20:32.334]         if (TRUE) {
[13:20:32.334]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:32.334]                 open = "w")
[13:20:32.334]         }
[13:20:32.334]         else {
[13:20:32.334]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:32.334]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:32.334]         }
[13:20:32.334]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:32.334]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:32.334]             base::sink(type = "output", split = FALSE)
[13:20:32.334]             base::close(...future.stdout)
[13:20:32.334]         }, add = TRUE)
[13:20:32.334]     }
[13:20:32.334]     ...future.frame <- base::sys.nframe()
[13:20:32.334]     ...future.conditions <- base::list()
[13:20:32.334]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:32.334]     if (FALSE) {
[13:20:32.334]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:32.334]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:32.334]     }
[13:20:32.334]     ...future.result <- base::tryCatch({
[13:20:32.334]         base::withCallingHandlers({
[13:20:32.334]             ...future.value <- base::withVisible(base::local({
[13:20:32.334]                 withCallingHandlers({
[13:20:32.334]                   {
[13:20:32.334]                     lm(dist ~ speed + I(speed^2), data = cars)
[13:20:32.334]                   }
[13:20:32.334]                 }, immediateCondition = function(cond) {
[13:20:32.334]                   save_rds <- function (object, pathname, ...) 
[13:20:32.334]                   {
[13:20:32.334]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:32.334]                     if (file_test("-f", pathname_tmp)) {
[13:20:32.334]                       fi_tmp <- file.info(pathname_tmp)
[13:20:32.334]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:32.334]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:32.334]                         fi_tmp[["mtime"]])
[13:20:32.334]                     }
[13:20:32.334]                     tryCatch({
[13:20:32.334]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:32.334]                     }, error = function(ex) {
[13:20:32.334]                       msg <- conditionMessage(ex)
[13:20:32.334]                       fi_tmp <- file.info(pathname_tmp)
[13:20:32.334]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:32.334]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:32.334]                         fi_tmp[["mtime"]], msg)
[13:20:32.334]                       ex$message <- msg
[13:20:32.334]                       stop(ex)
[13:20:32.334]                     })
[13:20:32.334]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:32.334]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:32.334]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:32.334]                       fi_tmp <- file.info(pathname_tmp)
[13:20:32.334]                       fi <- file.info(pathname)
[13:20:32.334]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:32.334]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:32.334]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:32.334]                         fi[["size"]], fi[["mtime"]])
[13:20:32.334]                       stop(msg)
[13:20:32.334]                     }
[13:20:32.334]                     invisible(pathname)
[13:20:32.334]                   }
[13:20:32.334]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:32.334]                     rootPath = tempdir()) 
[13:20:32.334]                   {
[13:20:32.334]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:32.334]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:32.334]                       tmpdir = path, fileext = ".rds")
[13:20:32.334]                     save_rds(obj, file)
[13:20:32.334]                   }
[13:20:32.334]                   saveImmediateCondition(cond, path = "/tmp/Rtmpnh0Esg/.future/immediateConditions")
[13:20:32.334]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:32.334]                   {
[13:20:32.334]                     inherits <- base::inherits
[13:20:32.334]                     invokeRestart <- base::invokeRestart
[13:20:32.334]                     is.null <- base::is.null
[13:20:32.334]                     muffled <- FALSE
[13:20:32.334]                     if (inherits(cond, "message")) {
[13:20:32.334]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:32.334]                       if (muffled) 
[13:20:32.334]                         invokeRestart("muffleMessage")
[13:20:32.334]                     }
[13:20:32.334]                     else if (inherits(cond, "warning")) {
[13:20:32.334]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:32.334]                       if (muffled) 
[13:20:32.334]                         invokeRestart("muffleWarning")
[13:20:32.334]                     }
[13:20:32.334]                     else if (inherits(cond, "condition")) {
[13:20:32.334]                       if (!is.null(pattern)) {
[13:20:32.334]                         computeRestarts <- base::computeRestarts
[13:20:32.334]                         grepl <- base::grepl
[13:20:32.334]                         restarts <- computeRestarts(cond)
[13:20:32.334]                         for (restart in restarts) {
[13:20:32.334]                           name <- restart$name
[13:20:32.334]                           if (is.null(name)) 
[13:20:32.334]                             next
[13:20:32.334]                           if (!grepl(pattern, name)) 
[13:20:32.334]                             next
[13:20:32.334]                           invokeRestart(restart)
[13:20:32.334]                           muffled <- TRUE
[13:20:32.334]                           break
[13:20:32.334]                         }
[13:20:32.334]                       }
[13:20:32.334]                     }
[13:20:32.334]                     invisible(muffled)
[13:20:32.334]                   }
[13:20:32.334]                   muffleCondition(cond)
[13:20:32.334]                 })
[13:20:32.334]             }))
[13:20:32.334]             future::FutureResult(value = ...future.value$value, 
[13:20:32.334]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:32.334]                   ...future.rng), globalenv = if (FALSE) 
[13:20:32.334]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:32.334]                     ...future.globalenv.names))
[13:20:32.334]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:32.334]         }, condition = base::local({
[13:20:32.334]             c <- base::c
[13:20:32.334]             inherits <- base::inherits
[13:20:32.334]             invokeRestart <- base::invokeRestart
[13:20:32.334]             length <- base::length
[13:20:32.334]             list <- base::list
[13:20:32.334]             seq.int <- base::seq.int
[13:20:32.334]             signalCondition <- base::signalCondition
[13:20:32.334]             sys.calls <- base::sys.calls
[13:20:32.334]             `[[` <- base::`[[`
[13:20:32.334]             `+` <- base::`+`
[13:20:32.334]             `<<-` <- base::`<<-`
[13:20:32.334]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:32.334]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:32.334]                   3L)]
[13:20:32.334]             }
[13:20:32.334]             function(cond) {
[13:20:32.334]                 is_error <- inherits(cond, "error")
[13:20:32.334]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:32.334]                   NULL)
[13:20:32.334]                 if (is_error) {
[13:20:32.334]                   sessionInformation <- function() {
[13:20:32.334]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:32.334]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:32.334]                       search = base::search(), system = base::Sys.info())
[13:20:32.334]                   }
[13:20:32.334]                   ...future.conditions[[length(...future.conditions) + 
[13:20:32.334]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:32.334]                     cond$call), session = sessionInformation(), 
[13:20:32.334]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:32.334]                   signalCondition(cond)
[13:20:32.334]                 }
[13:20:32.334]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:32.334]                 "immediateCondition"))) {
[13:20:32.334]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:32.334]                   ...future.conditions[[length(...future.conditions) + 
[13:20:32.334]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:32.334]                   if (TRUE && !signal) {
[13:20:32.334]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:32.334]                     {
[13:20:32.334]                       inherits <- base::inherits
[13:20:32.334]                       invokeRestart <- base::invokeRestart
[13:20:32.334]                       is.null <- base::is.null
[13:20:32.334]                       muffled <- FALSE
[13:20:32.334]                       if (inherits(cond, "message")) {
[13:20:32.334]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:32.334]                         if (muffled) 
[13:20:32.334]                           invokeRestart("muffleMessage")
[13:20:32.334]                       }
[13:20:32.334]                       else if (inherits(cond, "warning")) {
[13:20:32.334]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:32.334]                         if (muffled) 
[13:20:32.334]                           invokeRestart("muffleWarning")
[13:20:32.334]                       }
[13:20:32.334]                       else if (inherits(cond, "condition")) {
[13:20:32.334]                         if (!is.null(pattern)) {
[13:20:32.334]                           computeRestarts <- base::computeRestarts
[13:20:32.334]                           grepl <- base::grepl
[13:20:32.334]                           restarts <- computeRestarts(cond)
[13:20:32.334]                           for (restart in restarts) {
[13:20:32.334]                             name <- restart$name
[13:20:32.334]                             if (is.null(name)) 
[13:20:32.334]                               next
[13:20:32.334]                             if (!grepl(pattern, name)) 
[13:20:32.334]                               next
[13:20:32.334]                             invokeRestart(restart)
[13:20:32.334]                             muffled <- TRUE
[13:20:32.334]                             break
[13:20:32.334]                           }
[13:20:32.334]                         }
[13:20:32.334]                       }
[13:20:32.334]                       invisible(muffled)
[13:20:32.334]                     }
[13:20:32.334]                     muffleCondition(cond, pattern = "^muffle")
[13:20:32.334]                   }
[13:20:32.334]                 }
[13:20:32.334]                 else {
[13:20:32.334]                   if (TRUE) {
[13:20:32.334]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:32.334]                     {
[13:20:32.334]                       inherits <- base::inherits
[13:20:32.334]                       invokeRestart <- base::invokeRestart
[13:20:32.334]                       is.null <- base::is.null
[13:20:32.334]                       muffled <- FALSE
[13:20:32.334]                       if (inherits(cond, "message")) {
[13:20:32.334]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:32.334]                         if (muffled) 
[13:20:32.334]                           invokeRestart("muffleMessage")
[13:20:32.334]                       }
[13:20:32.334]                       else if (inherits(cond, "warning")) {
[13:20:32.334]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:32.334]                         if (muffled) 
[13:20:32.334]                           invokeRestart("muffleWarning")
[13:20:32.334]                       }
[13:20:32.334]                       else if (inherits(cond, "condition")) {
[13:20:32.334]                         if (!is.null(pattern)) {
[13:20:32.334]                           computeRestarts <- base::computeRestarts
[13:20:32.334]                           grepl <- base::grepl
[13:20:32.334]                           restarts <- computeRestarts(cond)
[13:20:32.334]                           for (restart in restarts) {
[13:20:32.334]                             name <- restart$name
[13:20:32.334]                             if (is.null(name)) 
[13:20:32.334]                               next
[13:20:32.334]                             if (!grepl(pattern, name)) 
[13:20:32.334]                               next
[13:20:32.334]                             invokeRestart(restart)
[13:20:32.334]                             muffled <- TRUE
[13:20:32.334]                             break
[13:20:32.334]                           }
[13:20:32.334]                         }
[13:20:32.334]                       }
[13:20:32.334]                       invisible(muffled)
[13:20:32.334]                     }
[13:20:32.334]                     muffleCondition(cond, pattern = "^muffle")
[13:20:32.334]                   }
[13:20:32.334]                 }
[13:20:32.334]             }
[13:20:32.334]         }))
[13:20:32.334]     }, error = function(ex) {
[13:20:32.334]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:32.334]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:32.334]                 ...future.rng), started = ...future.startTime, 
[13:20:32.334]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:32.334]             version = "1.8"), class = "FutureResult")
[13:20:32.334]     }, finally = {
[13:20:32.334]         if (!identical(...future.workdir, getwd())) 
[13:20:32.334]             setwd(...future.workdir)
[13:20:32.334]         {
[13:20:32.334]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:32.334]                 ...future.oldOptions$nwarnings <- NULL
[13:20:32.334]             }
[13:20:32.334]             base::options(...future.oldOptions)
[13:20:32.334]             if (.Platform$OS.type == "windows") {
[13:20:32.334]                 old_names <- names(...future.oldEnvVars)
[13:20:32.334]                 envs <- base::Sys.getenv()
[13:20:32.334]                 names <- names(envs)
[13:20:32.334]                 common <- intersect(names, old_names)
[13:20:32.334]                 added <- setdiff(names, old_names)
[13:20:32.334]                 removed <- setdiff(old_names, names)
[13:20:32.334]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:32.334]                   envs[common]]
[13:20:32.334]                 NAMES <- toupper(changed)
[13:20:32.334]                 args <- list()
[13:20:32.334]                 for (kk in seq_along(NAMES)) {
[13:20:32.334]                   name <- changed[[kk]]
[13:20:32.334]                   NAME <- NAMES[[kk]]
[13:20:32.334]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:32.334]                     next
[13:20:32.334]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:32.334]                 }
[13:20:32.334]                 NAMES <- toupper(added)
[13:20:32.334]                 for (kk in seq_along(NAMES)) {
[13:20:32.334]                   name <- added[[kk]]
[13:20:32.334]                   NAME <- NAMES[[kk]]
[13:20:32.334]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:32.334]                     next
[13:20:32.334]                   args[[name]] <- ""
[13:20:32.334]                 }
[13:20:32.334]                 NAMES <- toupper(removed)
[13:20:32.334]                 for (kk in seq_along(NAMES)) {
[13:20:32.334]                   name <- removed[[kk]]
[13:20:32.334]                   NAME <- NAMES[[kk]]
[13:20:32.334]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:32.334]                     next
[13:20:32.334]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:32.334]                 }
[13:20:32.334]                 if (length(args) > 0) 
[13:20:32.334]                   base::do.call(base::Sys.setenv, args = args)
[13:20:32.334]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:32.334]             }
[13:20:32.334]             else {
[13:20:32.334]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:32.334]             }
[13:20:32.334]             {
[13:20:32.334]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:32.334]                   0L) {
[13:20:32.334]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:32.334]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:32.334]                   base::options(opts)
[13:20:32.334]                 }
[13:20:32.334]                 {
[13:20:32.334]                   {
[13:20:32.334]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:32.334]                     NULL
[13:20:32.334]                   }
[13:20:32.334]                   options(future.plan = NULL)
[13:20:32.334]                   if (is.na(NA_character_)) 
[13:20:32.334]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:32.334]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:32.334]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:32.334]                     envir = parent.frame()) 
[13:20:32.334]                   {
[13:20:32.334]                     default_workers <- missing(workers)
[13:20:32.334]                     if (is.function(workers)) 
[13:20:32.334]                       workers <- workers()
[13:20:32.334]                     workers <- structure(as.integer(workers), 
[13:20:32.334]                       class = class(workers))
[13:20:32.334]                     stop_if_not(is.finite(workers), workers >= 
[13:20:32.334]                       1L)
[13:20:32.334]                     if ((workers == 1L && !inherits(workers, 
[13:20:32.334]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:32.334]                       if (default_workers) 
[13:20:32.334]                         supportsMulticore(warn = TRUE)
[13:20:32.334]                       return(sequential(..., envir = envir))
[13:20:32.334]                     }
[13:20:32.334]                     oopts <- options(mc.cores = workers)
[13:20:32.334]                     on.exit(options(oopts))
[13:20:32.334]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:32.334]                       envir = envir)
[13:20:32.334]                     if (!future$lazy) 
[13:20:32.334]                       future <- run(future)
[13:20:32.334]                     invisible(future)
[13:20:32.334]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:32.334]                 }
[13:20:32.334]             }
[13:20:32.334]         }
[13:20:32.334]     })
[13:20:32.334]     if (TRUE) {
[13:20:32.334]         base::sink(type = "output", split = FALSE)
[13:20:32.334]         if (TRUE) {
[13:20:32.334]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:32.334]         }
[13:20:32.334]         else {
[13:20:32.334]             ...future.result["stdout"] <- base::list(NULL)
[13:20:32.334]         }
[13:20:32.334]         base::close(...future.stdout)
[13:20:32.334]         ...future.stdout <- NULL
[13:20:32.334]     }
[13:20:32.334]     ...future.result$conditions <- ...future.conditions
[13:20:32.334]     ...future.result$finished <- base::Sys.time()
[13:20:32.334]     ...future.result
[13:20:32.334] }
[13:20:32.337] requestCore(): workers = 2
[13:20:32.339] MulticoreFuture started
[13:20:32.339] - Launch lazy future ... done
[13:20:32.339] run() for ‘MulticoreFuture’ ... done
[13:20:32.340] plan(): Setting new future strategy stack:
[13:20:32.341] List of future strategies:
[13:20:32.341] 1. sequential:
[13:20:32.341]    - args: function (..., envir = parent.frame())
[13:20:32.341]    - tweaked: FALSE
[13:20:32.341]    - call: NULL
[13:20:32.342] plan(): nbrOfWorkers() = 1
[13:20:32.346] plan(): Setting new future strategy stack:
[13:20:32.346] List of future strategies:
[13:20:32.346] 1. multicore:
[13:20:32.346]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:32.346]    - tweaked: FALSE
[13:20:32.346]    - call: plan(strategy)
[13:20:32.351] plan(): nbrOfWorkers() = 2

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[13:20:32.357] getGlobalsAndPackages() ...
[13:20:32.357] Searching for globals...
[13:20:32.359] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[13:20:32.360] Searching for globals ... DONE
[13:20:32.360] Resolving globals: FALSE
[13:20:32.360] 
[13:20:32.360] - packages: [2] ‘stats’, ‘datasets’
[13:20:32.361] getGlobalsAndPackages() ... DONE
[13:20:32.361] run() for ‘Future’ ...
[13:20:32.361] - state: ‘created’
[13:20:32.361] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:32.365] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:32.365] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:32.366]   - Field: ‘label’
[13:20:32.366]   - Field: ‘local’
[13:20:32.366]   - Field: ‘owner’
[13:20:32.366]   - Field: ‘envir’
[13:20:32.366]   - Field: ‘workers’
[13:20:32.366]   - Field: ‘packages’
[13:20:32.366]   - Field: ‘gc’
[13:20:32.366]   - Field: ‘job’
[13:20:32.366]   - Field: ‘conditions’
[13:20:32.367]   - Field: ‘expr’
[13:20:32.367]   - Field: ‘uuid’
[13:20:32.367]   - Field: ‘seed’
[13:20:32.367]   - Field: ‘version’
[13:20:32.367]   - Field: ‘result’
[13:20:32.367]   - Field: ‘asynchronous’
[13:20:32.367]   - Field: ‘calls’
[13:20:32.367]   - Field: ‘globals’
[13:20:32.367]   - Field: ‘stdout’
[13:20:32.368]   - Field: ‘earlySignal’
[13:20:32.368]   - Field: ‘lazy’
[13:20:32.368]   - Field: ‘state’
[13:20:32.368] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:32.368] - Launch lazy future ...
[13:20:32.368] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:20:32.369] Packages needed by future strategies (n = 0): <none>
[13:20:32.369] {
[13:20:32.369]     {
[13:20:32.369]         {
[13:20:32.369]             ...future.startTime <- base::Sys.time()
[13:20:32.369]             {
[13:20:32.369]                 {
[13:20:32.369]                   {
[13:20:32.369]                     {
[13:20:32.369]                       {
[13:20:32.369]                         base::local({
[13:20:32.369]                           has_future <- base::requireNamespace("future", 
[13:20:32.369]                             quietly = TRUE)
[13:20:32.369]                           if (has_future) {
[13:20:32.369]                             ns <- base::getNamespace("future")
[13:20:32.369]                             version <- ns[[".package"]][["version"]]
[13:20:32.369]                             if (is.null(version)) 
[13:20:32.369]                               version <- utils::packageVersion("future")
[13:20:32.369]                           }
[13:20:32.369]                           else {
[13:20:32.369]                             version <- NULL
[13:20:32.369]                           }
[13:20:32.369]                           if (!has_future || version < "1.8.0") {
[13:20:32.369]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:32.369]                               "", base::R.version$version.string), 
[13:20:32.369]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:32.369]                                 base::R.version$platform, 8 * 
[13:20:32.369]                                   base::.Machine$sizeof.pointer), 
[13:20:32.369]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:32.369]                                 "release", "version")], collapse = " "), 
[13:20:32.369]                               hostname = base::Sys.info()[["nodename"]])
[13:20:32.369]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:32.369]                               info)
[13:20:32.369]                             info <- base::paste(info, collapse = "; ")
[13:20:32.369]                             if (!has_future) {
[13:20:32.369]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:32.369]                                 info)
[13:20:32.369]                             }
[13:20:32.369]                             else {
[13:20:32.369]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:32.369]                                 info, version)
[13:20:32.369]                             }
[13:20:32.369]                             base::stop(msg)
[13:20:32.369]                           }
[13:20:32.369]                         })
[13:20:32.369]                       }
[13:20:32.369]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:32.369]                       base::options(mc.cores = 1L)
[13:20:32.369]                     }
[13:20:32.369]                     base::local({
[13:20:32.369]                       for (pkg in c("stats", "datasets")) {
[13:20:32.369]                         base::loadNamespace(pkg)
[13:20:32.369]                         base::library(pkg, character.only = TRUE)
[13:20:32.369]                       }
[13:20:32.369]                     })
[13:20:32.369]                   }
[13:20:32.369]                   options(future.plan = NULL)
[13:20:32.369]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:32.369]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:32.369]                 }
[13:20:32.369]                 ...future.workdir <- getwd()
[13:20:32.369]             }
[13:20:32.369]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:32.369]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:32.369]         }
[13:20:32.369]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:32.369]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:32.369]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:32.369]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:32.369]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:32.369]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:32.369]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:32.369]             base::names(...future.oldOptions))
[13:20:32.369]     }
[13:20:32.369]     if (FALSE) {
[13:20:32.369]     }
[13:20:32.369]     else {
[13:20:32.369]         if (TRUE) {
[13:20:32.369]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:32.369]                 open = "w")
[13:20:32.369]         }
[13:20:32.369]         else {
[13:20:32.369]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:32.369]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:32.369]         }
[13:20:32.369]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:32.369]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:32.369]             base::sink(type = "output", split = FALSE)
[13:20:32.369]             base::close(...future.stdout)
[13:20:32.369]         }, add = TRUE)
[13:20:32.369]     }
[13:20:32.369]     ...future.frame <- base::sys.nframe()
[13:20:32.369]     ...future.conditions <- base::list()
[13:20:32.369]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:32.369]     if (FALSE) {
[13:20:32.369]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:32.369]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:32.369]     }
[13:20:32.369]     ...future.result <- base::tryCatch({
[13:20:32.369]         base::withCallingHandlers({
[13:20:32.369]             ...future.value <- base::withVisible(base::local({
[13:20:32.369]                 withCallingHandlers({
[13:20:32.369]                   {
[13:20:32.369]                     lm(dist ~ poly(speed, 2), data = cars)
[13:20:32.369]                   }
[13:20:32.369]                 }, immediateCondition = function(cond) {
[13:20:32.369]                   save_rds <- function (object, pathname, ...) 
[13:20:32.369]                   {
[13:20:32.369]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:32.369]                     if (file_test("-f", pathname_tmp)) {
[13:20:32.369]                       fi_tmp <- file.info(pathname_tmp)
[13:20:32.369]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:32.369]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:32.369]                         fi_tmp[["mtime"]])
[13:20:32.369]                     }
[13:20:32.369]                     tryCatch({
[13:20:32.369]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:32.369]                     }, error = function(ex) {
[13:20:32.369]                       msg <- conditionMessage(ex)
[13:20:32.369]                       fi_tmp <- file.info(pathname_tmp)
[13:20:32.369]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:32.369]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:32.369]                         fi_tmp[["mtime"]], msg)
[13:20:32.369]                       ex$message <- msg
[13:20:32.369]                       stop(ex)
[13:20:32.369]                     })
[13:20:32.369]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:32.369]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:32.369]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:32.369]                       fi_tmp <- file.info(pathname_tmp)
[13:20:32.369]                       fi <- file.info(pathname)
[13:20:32.369]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:32.369]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:32.369]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:32.369]                         fi[["size"]], fi[["mtime"]])
[13:20:32.369]                       stop(msg)
[13:20:32.369]                     }
[13:20:32.369]                     invisible(pathname)
[13:20:32.369]                   }
[13:20:32.369]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:32.369]                     rootPath = tempdir()) 
[13:20:32.369]                   {
[13:20:32.369]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:32.369]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:32.369]                       tmpdir = path, fileext = ".rds")
[13:20:32.369]                     save_rds(obj, file)
[13:20:32.369]                   }
[13:20:32.369]                   saveImmediateCondition(cond, path = "/tmp/Rtmpnh0Esg/.future/immediateConditions")
[13:20:32.369]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:32.369]                   {
[13:20:32.369]                     inherits <- base::inherits
[13:20:32.369]                     invokeRestart <- base::invokeRestart
[13:20:32.369]                     is.null <- base::is.null
[13:20:32.369]                     muffled <- FALSE
[13:20:32.369]                     if (inherits(cond, "message")) {
[13:20:32.369]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:32.369]                       if (muffled) 
[13:20:32.369]                         invokeRestart("muffleMessage")
[13:20:32.369]                     }
[13:20:32.369]                     else if (inherits(cond, "warning")) {
[13:20:32.369]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:32.369]                       if (muffled) 
[13:20:32.369]                         invokeRestart("muffleWarning")
[13:20:32.369]                     }
[13:20:32.369]                     else if (inherits(cond, "condition")) {
[13:20:32.369]                       if (!is.null(pattern)) {
[13:20:32.369]                         computeRestarts <- base::computeRestarts
[13:20:32.369]                         grepl <- base::grepl
[13:20:32.369]                         restarts <- computeRestarts(cond)
[13:20:32.369]                         for (restart in restarts) {
[13:20:32.369]                           name <- restart$name
[13:20:32.369]                           if (is.null(name)) 
[13:20:32.369]                             next
[13:20:32.369]                           if (!grepl(pattern, name)) 
[13:20:32.369]                             next
[13:20:32.369]                           invokeRestart(restart)
[13:20:32.369]                           muffled <- TRUE
[13:20:32.369]                           break
[13:20:32.369]                         }
[13:20:32.369]                       }
[13:20:32.369]                     }
[13:20:32.369]                     invisible(muffled)
[13:20:32.369]                   }
[13:20:32.369]                   muffleCondition(cond)
[13:20:32.369]                 })
[13:20:32.369]             }))
[13:20:32.369]             future::FutureResult(value = ...future.value$value, 
[13:20:32.369]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:32.369]                   ...future.rng), globalenv = if (FALSE) 
[13:20:32.369]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:32.369]                     ...future.globalenv.names))
[13:20:32.369]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:32.369]         }, condition = base::local({
[13:20:32.369]             c <- base::c
[13:20:32.369]             inherits <- base::inherits
[13:20:32.369]             invokeRestart <- base::invokeRestart
[13:20:32.369]             length <- base::length
[13:20:32.369]             list <- base::list
[13:20:32.369]             seq.int <- base::seq.int
[13:20:32.369]             signalCondition <- base::signalCondition
[13:20:32.369]             sys.calls <- base::sys.calls
[13:20:32.369]             `[[` <- base::`[[`
[13:20:32.369]             `+` <- base::`+`
[13:20:32.369]             `<<-` <- base::`<<-`
[13:20:32.369]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:32.369]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:32.369]                   3L)]
[13:20:32.369]             }
[13:20:32.369]             function(cond) {
[13:20:32.369]                 is_error <- inherits(cond, "error")
[13:20:32.369]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:32.369]                   NULL)
[13:20:32.369]                 if (is_error) {
[13:20:32.369]                   sessionInformation <- function() {
[13:20:32.369]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:32.369]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:32.369]                       search = base::search(), system = base::Sys.info())
[13:20:32.369]                   }
[13:20:32.369]                   ...future.conditions[[length(...future.conditions) + 
[13:20:32.369]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:32.369]                     cond$call), session = sessionInformation(), 
[13:20:32.369]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:32.369]                   signalCondition(cond)
[13:20:32.369]                 }
[13:20:32.369]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:32.369]                 "immediateCondition"))) {
[13:20:32.369]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:32.369]                   ...future.conditions[[length(...future.conditions) + 
[13:20:32.369]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:32.369]                   if (TRUE && !signal) {
[13:20:32.369]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:32.369]                     {
[13:20:32.369]                       inherits <- base::inherits
[13:20:32.369]                       invokeRestart <- base::invokeRestart
[13:20:32.369]                       is.null <- base::is.null
[13:20:32.369]                       muffled <- FALSE
[13:20:32.369]                       if (inherits(cond, "message")) {
[13:20:32.369]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:32.369]                         if (muffled) 
[13:20:32.369]                           invokeRestart("muffleMessage")
[13:20:32.369]                       }
[13:20:32.369]                       else if (inherits(cond, "warning")) {
[13:20:32.369]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:32.369]                         if (muffled) 
[13:20:32.369]                           invokeRestart("muffleWarning")
[13:20:32.369]                       }
[13:20:32.369]                       else if (inherits(cond, "condition")) {
[13:20:32.369]                         if (!is.null(pattern)) {
[13:20:32.369]                           computeRestarts <- base::computeRestarts
[13:20:32.369]                           grepl <- base::grepl
[13:20:32.369]                           restarts <- computeRestarts(cond)
[13:20:32.369]                           for (restart in restarts) {
[13:20:32.369]                             name <- restart$name
[13:20:32.369]                             if (is.null(name)) 
[13:20:32.369]                               next
[13:20:32.369]                             if (!grepl(pattern, name)) 
[13:20:32.369]                               next
[13:20:32.369]                             invokeRestart(restart)
[13:20:32.369]                             muffled <- TRUE
[13:20:32.369]                             break
[13:20:32.369]                           }
[13:20:32.369]                         }
[13:20:32.369]                       }
[13:20:32.369]                       invisible(muffled)
[13:20:32.369]                     }
[13:20:32.369]                     muffleCondition(cond, pattern = "^muffle")
[13:20:32.369]                   }
[13:20:32.369]                 }
[13:20:32.369]                 else {
[13:20:32.369]                   if (TRUE) {
[13:20:32.369]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:32.369]                     {
[13:20:32.369]                       inherits <- base::inherits
[13:20:32.369]                       invokeRestart <- base::invokeRestart
[13:20:32.369]                       is.null <- base::is.null
[13:20:32.369]                       muffled <- FALSE
[13:20:32.369]                       if (inherits(cond, "message")) {
[13:20:32.369]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:32.369]                         if (muffled) 
[13:20:32.369]                           invokeRestart("muffleMessage")
[13:20:32.369]                       }
[13:20:32.369]                       else if (inherits(cond, "warning")) {
[13:20:32.369]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:32.369]                         if (muffled) 
[13:20:32.369]                           invokeRestart("muffleWarning")
[13:20:32.369]                       }
[13:20:32.369]                       else if (inherits(cond, "condition")) {
[13:20:32.369]                         if (!is.null(pattern)) {
[13:20:32.369]                           computeRestarts <- base::computeRestarts
[13:20:32.369]                           grepl <- base::grepl
[13:20:32.369]                           restarts <- computeRestarts(cond)
[13:20:32.369]                           for (restart in restarts) {
[13:20:32.369]                             name <- restart$name
[13:20:32.369]                             if (is.null(name)) 
[13:20:32.369]                               next
[13:20:32.369]                             if (!grepl(pattern, name)) 
[13:20:32.369]                               next
[13:20:32.369]                             invokeRestart(restart)
[13:20:32.369]                             muffled <- TRUE
[13:20:32.369]                             break
[13:20:32.369]                           }
[13:20:32.369]                         }
[13:20:32.369]                       }
[13:20:32.369]                       invisible(muffled)
[13:20:32.369]                     }
[13:20:32.369]                     muffleCondition(cond, pattern = "^muffle")
[13:20:32.369]                   }
[13:20:32.369]                 }
[13:20:32.369]             }
[13:20:32.369]         }))
[13:20:32.369]     }, error = function(ex) {
[13:20:32.369]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:32.369]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:32.369]                 ...future.rng), started = ...future.startTime, 
[13:20:32.369]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:32.369]             version = "1.8"), class = "FutureResult")
[13:20:32.369]     }, finally = {
[13:20:32.369]         if (!identical(...future.workdir, getwd())) 
[13:20:32.369]             setwd(...future.workdir)
[13:20:32.369]         {
[13:20:32.369]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:32.369]                 ...future.oldOptions$nwarnings <- NULL
[13:20:32.369]             }
[13:20:32.369]             base::options(...future.oldOptions)
[13:20:32.369]             if (.Platform$OS.type == "windows") {
[13:20:32.369]                 old_names <- names(...future.oldEnvVars)
[13:20:32.369]                 envs <- base::Sys.getenv()
[13:20:32.369]                 names <- names(envs)
[13:20:32.369]                 common <- intersect(names, old_names)
[13:20:32.369]                 added <- setdiff(names, old_names)
[13:20:32.369]                 removed <- setdiff(old_names, names)
[13:20:32.369]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:32.369]                   envs[common]]
[13:20:32.369]                 NAMES <- toupper(changed)
[13:20:32.369]                 args <- list()
[13:20:32.369]                 for (kk in seq_along(NAMES)) {
[13:20:32.369]                   name <- changed[[kk]]
[13:20:32.369]                   NAME <- NAMES[[kk]]
[13:20:32.369]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:32.369]                     next
[13:20:32.369]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:32.369]                 }
[13:20:32.369]                 NAMES <- toupper(added)
[13:20:32.369]                 for (kk in seq_along(NAMES)) {
[13:20:32.369]                   name <- added[[kk]]
[13:20:32.369]                   NAME <- NAMES[[kk]]
[13:20:32.369]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:32.369]                     next
[13:20:32.369]                   args[[name]] <- ""
[13:20:32.369]                 }
[13:20:32.369]                 NAMES <- toupper(removed)
[13:20:32.369]                 for (kk in seq_along(NAMES)) {
[13:20:32.369]                   name <- removed[[kk]]
[13:20:32.369]                   NAME <- NAMES[[kk]]
[13:20:32.369]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:32.369]                     next
[13:20:32.369]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:32.369]                 }
[13:20:32.369]                 if (length(args) > 0) 
[13:20:32.369]                   base::do.call(base::Sys.setenv, args = args)
[13:20:32.369]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:32.369]             }
[13:20:32.369]             else {
[13:20:32.369]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:32.369]             }
[13:20:32.369]             {
[13:20:32.369]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:32.369]                   0L) {
[13:20:32.369]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:32.369]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:32.369]                   base::options(opts)
[13:20:32.369]                 }
[13:20:32.369]                 {
[13:20:32.369]                   {
[13:20:32.369]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:32.369]                     NULL
[13:20:32.369]                   }
[13:20:32.369]                   options(future.plan = NULL)
[13:20:32.369]                   if (is.na(NA_character_)) 
[13:20:32.369]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:32.369]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:32.369]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:32.369]                     envir = parent.frame()) 
[13:20:32.369]                   {
[13:20:32.369]                     default_workers <- missing(workers)
[13:20:32.369]                     if (is.function(workers)) 
[13:20:32.369]                       workers <- workers()
[13:20:32.369]                     workers <- structure(as.integer(workers), 
[13:20:32.369]                       class = class(workers))
[13:20:32.369]                     stop_if_not(is.finite(workers), workers >= 
[13:20:32.369]                       1L)
[13:20:32.369]                     if ((workers == 1L && !inherits(workers, 
[13:20:32.369]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:32.369]                       if (default_workers) 
[13:20:32.369]                         supportsMulticore(warn = TRUE)
[13:20:32.369]                       return(sequential(..., envir = envir))
[13:20:32.369]                     }
[13:20:32.369]                     oopts <- options(mc.cores = workers)
[13:20:32.369]                     on.exit(options(oopts))
[13:20:32.369]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:32.369]                       envir = envir)
[13:20:32.369]                     if (!future$lazy) 
[13:20:32.369]                       future <- run(future)
[13:20:32.369]                     invisible(future)
[13:20:32.369]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:32.369]                 }
[13:20:32.369]             }
[13:20:32.369]         }
[13:20:32.369]     })
[13:20:32.369]     if (TRUE) {
[13:20:32.369]         base::sink(type = "output", split = FALSE)
[13:20:32.369]         if (TRUE) {
[13:20:32.369]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:32.369]         }
[13:20:32.369]         else {
[13:20:32.369]             ...future.result["stdout"] <- base::list(NULL)
[13:20:32.369]         }
[13:20:32.369]         base::close(...future.stdout)
[13:20:32.369]         ...future.stdout <- NULL
[13:20:32.369]     }
[13:20:32.369]     ...future.result$conditions <- ...future.conditions
[13:20:32.369]     ...future.result$finished <- base::Sys.time()
[13:20:32.369]     ...future.result
[13:20:32.369] }
[13:20:32.372] requestCore(): workers = 2
[13:20:32.374] MulticoreFuture started
[13:20:32.374] - Launch lazy future ... done
[13:20:32.374] run() for ‘MulticoreFuture’ ... done
[13:20:32.375] plan(): Setting new future strategy stack:
[13:20:32.375] List of future strategies:
[13:20:32.375] 1. sequential:
[13:20:32.375]    - args: function (..., envir = parent.frame())
[13:20:32.375]    - tweaked: FALSE
[13:20:32.375]    - call: NULL
[13:20:32.376] plan(): nbrOfWorkers() = 1
[13:20:32.386] plan(): Setting new future strategy stack:
[13:20:32.386] List of future strategies:
[13:20:32.386] 1. multicore:
[13:20:32.386]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:32.386]    - tweaked: FALSE
[13:20:32.386]    - call: plan(strategy)
[13:20:32.392] plan(): nbrOfWorkers() = 2

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[13:20:32.401] getGlobalsAndPackages() ...
[13:20:32.401] Searching for globals...
[13:20:32.407] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[13:20:32.407] Searching for globals ... DONE
[13:20:32.407] Resolving globals: FALSE
[13:20:32.408] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[13:20:32.409] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[13:20:32.409] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[13:20:32.409] 
[13:20:32.409] getGlobalsAndPackages() ... DONE
[13:20:32.409] run() for ‘Future’ ...
[13:20:32.409] - state: ‘created’
[13:20:32.410] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:32.414] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:32.414] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:32.414]   - Field: ‘label’
[13:20:32.414]   - Field: ‘local’
[13:20:32.414]   - Field: ‘owner’
[13:20:32.414]   - Field: ‘envir’
[13:20:32.415]   - Field: ‘workers’
[13:20:32.415]   - Field: ‘packages’
[13:20:32.415]   - Field: ‘gc’
[13:20:32.415]   - Field: ‘job’
[13:20:32.415]   - Field: ‘conditions’
[13:20:32.415]   - Field: ‘expr’
[13:20:32.415]   - Field: ‘uuid’
[13:20:32.415]   - Field: ‘seed’
[13:20:32.415]   - Field: ‘version’
[13:20:32.415]   - Field: ‘result’
[13:20:32.416]   - Field: ‘asynchronous’
[13:20:32.416]   - Field: ‘calls’
[13:20:32.416]   - Field: ‘globals’
[13:20:32.416]   - Field: ‘stdout’
[13:20:32.416]   - Field: ‘earlySignal’
[13:20:32.416]   - Field: ‘lazy’
[13:20:32.416]   - Field: ‘state’
[13:20:32.416] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:32.416] - Launch lazy future ...
[13:20:32.417] Packages needed by the future expression (n = 0): <none>
[13:20:32.417] Packages needed by future strategies (n = 0): <none>
[13:20:32.417] {
[13:20:32.417]     {
[13:20:32.417]         {
[13:20:32.417]             ...future.startTime <- base::Sys.time()
[13:20:32.417]             {
[13:20:32.417]                 {
[13:20:32.417]                   {
[13:20:32.417]                     {
[13:20:32.417]                       base::local({
[13:20:32.417]                         has_future <- base::requireNamespace("future", 
[13:20:32.417]                           quietly = TRUE)
[13:20:32.417]                         if (has_future) {
[13:20:32.417]                           ns <- base::getNamespace("future")
[13:20:32.417]                           version <- ns[[".package"]][["version"]]
[13:20:32.417]                           if (is.null(version)) 
[13:20:32.417]                             version <- utils::packageVersion("future")
[13:20:32.417]                         }
[13:20:32.417]                         else {
[13:20:32.417]                           version <- NULL
[13:20:32.417]                         }
[13:20:32.417]                         if (!has_future || version < "1.8.0") {
[13:20:32.417]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:32.417]                             "", base::R.version$version.string), 
[13:20:32.417]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:32.417]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:32.417]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:32.417]                               "release", "version")], collapse = " "), 
[13:20:32.417]                             hostname = base::Sys.info()[["nodename"]])
[13:20:32.417]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:32.417]                             info)
[13:20:32.417]                           info <- base::paste(info, collapse = "; ")
[13:20:32.417]                           if (!has_future) {
[13:20:32.417]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:32.417]                               info)
[13:20:32.417]                           }
[13:20:32.417]                           else {
[13:20:32.417]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:32.417]                               info, version)
[13:20:32.417]                           }
[13:20:32.417]                           base::stop(msg)
[13:20:32.417]                         }
[13:20:32.417]                       })
[13:20:32.417]                     }
[13:20:32.417]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:32.417]                     base::options(mc.cores = 1L)
[13:20:32.417]                   }
[13:20:32.417]                   options(future.plan = NULL)
[13:20:32.417]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:32.417]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:32.417]                 }
[13:20:32.417]                 ...future.workdir <- getwd()
[13:20:32.417]             }
[13:20:32.417]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:32.417]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:32.417]         }
[13:20:32.417]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:32.417]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:32.417]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:32.417]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:32.417]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:32.417]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:32.417]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:32.417]             base::names(...future.oldOptions))
[13:20:32.417]     }
[13:20:32.417]     if (FALSE) {
[13:20:32.417]     }
[13:20:32.417]     else {
[13:20:32.417]         if (TRUE) {
[13:20:32.417]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:32.417]                 open = "w")
[13:20:32.417]         }
[13:20:32.417]         else {
[13:20:32.417]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:32.417]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:32.417]         }
[13:20:32.417]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:32.417]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:32.417]             base::sink(type = "output", split = FALSE)
[13:20:32.417]             base::close(...future.stdout)
[13:20:32.417]         }, add = TRUE)
[13:20:32.417]     }
[13:20:32.417]     ...future.frame <- base::sys.nframe()
[13:20:32.417]     ...future.conditions <- base::list()
[13:20:32.417]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:32.417]     if (FALSE) {
[13:20:32.417]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:32.417]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:32.417]     }
[13:20:32.417]     ...future.result <- base::tryCatch({
[13:20:32.417]         base::withCallingHandlers({
[13:20:32.417]             ...future.value <- base::withVisible(base::local({
[13:20:32.417]                 withCallingHandlers({
[13:20:32.417]                   {
[13:20:32.417]                     outer_function(1L)
[13:20:32.417]                   }
[13:20:32.417]                 }, immediateCondition = function(cond) {
[13:20:32.417]                   save_rds <- function (object, pathname, ...) 
[13:20:32.417]                   {
[13:20:32.417]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:32.417]                     if (file_test("-f", pathname_tmp)) {
[13:20:32.417]                       fi_tmp <- file.info(pathname_tmp)
[13:20:32.417]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:32.417]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:32.417]                         fi_tmp[["mtime"]])
[13:20:32.417]                     }
[13:20:32.417]                     tryCatch({
[13:20:32.417]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:32.417]                     }, error = function(ex) {
[13:20:32.417]                       msg <- conditionMessage(ex)
[13:20:32.417]                       fi_tmp <- file.info(pathname_tmp)
[13:20:32.417]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:32.417]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:32.417]                         fi_tmp[["mtime"]], msg)
[13:20:32.417]                       ex$message <- msg
[13:20:32.417]                       stop(ex)
[13:20:32.417]                     })
[13:20:32.417]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:32.417]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:32.417]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:32.417]                       fi_tmp <- file.info(pathname_tmp)
[13:20:32.417]                       fi <- file.info(pathname)
[13:20:32.417]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:32.417]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:32.417]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:32.417]                         fi[["size"]], fi[["mtime"]])
[13:20:32.417]                       stop(msg)
[13:20:32.417]                     }
[13:20:32.417]                     invisible(pathname)
[13:20:32.417]                   }
[13:20:32.417]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:32.417]                     rootPath = tempdir()) 
[13:20:32.417]                   {
[13:20:32.417]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:32.417]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:32.417]                       tmpdir = path, fileext = ".rds")
[13:20:32.417]                     save_rds(obj, file)
[13:20:32.417]                   }
[13:20:32.417]                   saveImmediateCondition(cond, path = "/tmp/Rtmpnh0Esg/.future/immediateConditions")
[13:20:32.417]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:32.417]                   {
[13:20:32.417]                     inherits <- base::inherits
[13:20:32.417]                     invokeRestart <- base::invokeRestart
[13:20:32.417]                     is.null <- base::is.null
[13:20:32.417]                     muffled <- FALSE
[13:20:32.417]                     if (inherits(cond, "message")) {
[13:20:32.417]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:32.417]                       if (muffled) 
[13:20:32.417]                         invokeRestart("muffleMessage")
[13:20:32.417]                     }
[13:20:32.417]                     else if (inherits(cond, "warning")) {
[13:20:32.417]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:32.417]                       if (muffled) 
[13:20:32.417]                         invokeRestart("muffleWarning")
[13:20:32.417]                     }
[13:20:32.417]                     else if (inherits(cond, "condition")) {
[13:20:32.417]                       if (!is.null(pattern)) {
[13:20:32.417]                         computeRestarts <- base::computeRestarts
[13:20:32.417]                         grepl <- base::grepl
[13:20:32.417]                         restarts <- computeRestarts(cond)
[13:20:32.417]                         for (restart in restarts) {
[13:20:32.417]                           name <- restart$name
[13:20:32.417]                           if (is.null(name)) 
[13:20:32.417]                             next
[13:20:32.417]                           if (!grepl(pattern, name)) 
[13:20:32.417]                             next
[13:20:32.417]                           invokeRestart(restart)
[13:20:32.417]                           muffled <- TRUE
[13:20:32.417]                           break
[13:20:32.417]                         }
[13:20:32.417]                       }
[13:20:32.417]                     }
[13:20:32.417]                     invisible(muffled)
[13:20:32.417]                   }
[13:20:32.417]                   muffleCondition(cond)
[13:20:32.417]                 })
[13:20:32.417]             }))
[13:20:32.417]             future::FutureResult(value = ...future.value$value, 
[13:20:32.417]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:32.417]                   ...future.rng), globalenv = if (FALSE) 
[13:20:32.417]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:32.417]                     ...future.globalenv.names))
[13:20:32.417]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:32.417]         }, condition = base::local({
[13:20:32.417]             c <- base::c
[13:20:32.417]             inherits <- base::inherits
[13:20:32.417]             invokeRestart <- base::invokeRestart
[13:20:32.417]             length <- base::length
[13:20:32.417]             list <- base::list
[13:20:32.417]             seq.int <- base::seq.int
[13:20:32.417]             signalCondition <- base::signalCondition
[13:20:32.417]             sys.calls <- base::sys.calls
[13:20:32.417]             `[[` <- base::`[[`
[13:20:32.417]             `+` <- base::`+`
[13:20:32.417]             `<<-` <- base::`<<-`
[13:20:32.417]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:32.417]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:32.417]                   3L)]
[13:20:32.417]             }
[13:20:32.417]             function(cond) {
[13:20:32.417]                 is_error <- inherits(cond, "error")
[13:20:32.417]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:32.417]                   NULL)
[13:20:32.417]                 if (is_error) {
[13:20:32.417]                   sessionInformation <- function() {
[13:20:32.417]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:32.417]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:32.417]                       search = base::search(), system = base::Sys.info())
[13:20:32.417]                   }
[13:20:32.417]                   ...future.conditions[[length(...future.conditions) + 
[13:20:32.417]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:32.417]                     cond$call), session = sessionInformation(), 
[13:20:32.417]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:32.417]                   signalCondition(cond)
[13:20:32.417]                 }
[13:20:32.417]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:32.417]                 "immediateCondition"))) {
[13:20:32.417]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:32.417]                   ...future.conditions[[length(...future.conditions) + 
[13:20:32.417]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:32.417]                   if (TRUE && !signal) {
[13:20:32.417]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:32.417]                     {
[13:20:32.417]                       inherits <- base::inherits
[13:20:32.417]                       invokeRestart <- base::invokeRestart
[13:20:32.417]                       is.null <- base::is.null
[13:20:32.417]                       muffled <- FALSE
[13:20:32.417]                       if (inherits(cond, "message")) {
[13:20:32.417]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:32.417]                         if (muffled) 
[13:20:32.417]                           invokeRestart("muffleMessage")
[13:20:32.417]                       }
[13:20:32.417]                       else if (inherits(cond, "warning")) {
[13:20:32.417]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:32.417]                         if (muffled) 
[13:20:32.417]                           invokeRestart("muffleWarning")
[13:20:32.417]                       }
[13:20:32.417]                       else if (inherits(cond, "condition")) {
[13:20:32.417]                         if (!is.null(pattern)) {
[13:20:32.417]                           computeRestarts <- base::computeRestarts
[13:20:32.417]                           grepl <- base::grepl
[13:20:32.417]                           restarts <- computeRestarts(cond)
[13:20:32.417]                           for (restart in restarts) {
[13:20:32.417]                             name <- restart$name
[13:20:32.417]                             if (is.null(name)) 
[13:20:32.417]                               next
[13:20:32.417]                             if (!grepl(pattern, name)) 
[13:20:32.417]                               next
[13:20:32.417]                             invokeRestart(restart)
[13:20:32.417]                             muffled <- TRUE
[13:20:32.417]                             break
[13:20:32.417]                           }
[13:20:32.417]                         }
[13:20:32.417]                       }
[13:20:32.417]                       invisible(muffled)
[13:20:32.417]                     }
[13:20:32.417]                     muffleCondition(cond, pattern = "^muffle")
[13:20:32.417]                   }
[13:20:32.417]                 }
[13:20:32.417]                 else {
[13:20:32.417]                   if (TRUE) {
[13:20:32.417]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:32.417]                     {
[13:20:32.417]                       inherits <- base::inherits
[13:20:32.417]                       invokeRestart <- base::invokeRestart
[13:20:32.417]                       is.null <- base::is.null
[13:20:32.417]                       muffled <- FALSE
[13:20:32.417]                       if (inherits(cond, "message")) {
[13:20:32.417]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:32.417]                         if (muffled) 
[13:20:32.417]                           invokeRestart("muffleMessage")
[13:20:32.417]                       }
[13:20:32.417]                       else if (inherits(cond, "warning")) {
[13:20:32.417]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:32.417]                         if (muffled) 
[13:20:32.417]                           invokeRestart("muffleWarning")
[13:20:32.417]                       }
[13:20:32.417]                       else if (inherits(cond, "condition")) {
[13:20:32.417]                         if (!is.null(pattern)) {
[13:20:32.417]                           computeRestarts <- base::computeRestarts
[13:20:32.417]                           grepl <- base::grepl
[13:20:32.417]                           restarts <- computeRestarts(cond)
[13:20:32.417]                           for (restart in restarts) {
[13:20:32.417]                             name <- restart$name
[13:20:32.417]                             if (is.null(name)) 
[13:20:32.417]                               next
[13:20:32.417]                             if (!grepl(pattern, name)) 
[13:20:32.417]                               next
[13:20:32.417]                             invokeRestart(restart)
[13:20:32.417]                             muffled <- TRUE
[13:20:32.417]                             break
[13:20:32.417]                           }
[13:20:32.417]                         }
[13:20:32.417]                       }
[13:20:32.417]                       invisible(muffled)
[13:20:32.417]                     }
[13:20:32.417]                     muffleCondition(cond, pattern = "^muffle")
[13:20:32.417]                   }
[13:20:32.417]                 }
[13:20:32.417]             }
[13:20:32.417]         }))
[13:20:32.417]     }, error = function(ex) {
[13:20:32.417]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:32.417]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:32.417]                 ...future.rng), started = ...future.startTime, 
[13:20:32.417]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:32.417]             version = "1.8"), class = "FutureResult")
[13:20:32.417]     }, finally = {
[13:20:32.417]         if (!identical(...future.workdir, getwd())) 
[13:20:32.417]             setwd(...future.workdir)
[13:20:32.417]         {
[13:20:32.417]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:32.417]                 ...future.oldOptions$nwarnings <- NULL
[13:20:32.417]             }
[13:20:32.417]             base::options(...future.oldOptions)
[13:20:32.417]             if (.Platform$OS.type == "windows") {
[13:20:32.417]                 old_names <- names(...future.oldEnvVars)
[13:20:32.417]                 envs <- base::Sys.getenv()
[13:20:32.417]                 names <- names(envs)
[13:20:32.417]                 common <- intersect(names, old_names)
[13:20:32.417]                 added <- setdiff(names, old_names)
[13:20:32.417]                 removed <- setdiff(old_names, names)
[13:20:32.417]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:32.417]                   envs[common]]
[13:20:32.417]                 NAMES <- toupper(changed)
[13:20:32.417]                 args <- list()
[13:20:32.417]                 for (kk in seq_along(NAMES)) {
[13:20:32.417]                   name <- changed[[kk]]
[13:20:32.417]                   NAME <- NAMES[[kk]]
[13:20:32.417]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:32.417]                     next
[13:20:32.417]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:32.417]                 }
[13:20:32.417]                 NAMES <- toupper(added)
[13:20:32.417]                 for (kk in seq_along(NAMES)) {
[13:20:32.417]                   name <- added[[kk]]
[13:20:32.417]                   NAME <- NAMES[[kk]]
[13:20:32.417]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:32.417]                     next
[13:20:32.417]                   args[[name]] <- ""
[13:20:32.417]                 }
[13:20:32.417]                 NAMES <- toupper(removed)
[13:20:32.417]                 for (kk in seq_along(NAMES)) {
[13:20:32.417]                   name <- removed[[kk]]
[13:20:32.417]                   NAME <- NAMES[[kk]]
[13:20:32.417]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:32.417]                     next
[13:20:32.417]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:32.417]                 }
[13:20:32.417]                 if (length(args) > 0) 
[13:20:32.417]                   base::do.call(base::Sys.setenv, args = args)
[13:20:32.417]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:32.417]             }
[13:20:32.417]             else {
[13:20:32.417]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:32.417]             }
[13:20:32.417]             {
[13:20:32.417]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:32.417]                   0L) {
[13:20:32.417]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:32.417]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:32.417]                   base::options(opts)
[13:20:32.417]                 }
[13:20:32.417]                 {
[13:20:32.417]                   {
[13:20:32.417]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:32.417]                     NULL
[13:20:32.417]                   }
[13:20:32.417]                   options(future.plan = NULL)
[13:20:32.417]                   if (is.na(NA_character_)) 
[13:20:32.417]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:32.417]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:32.417]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:32.417]                     envir = parent.frame()) 
[13:20:32.417]                   {
[13:20:32.417]                     default_workers <- missing(workers)
[13:20:32.417]                     if (is.function(workers)) 
[13:20:32.417]                       workers <- workers()
[13:20:32.417]                     workers <- structure(as.integer(workers), 
[13:20:32.417]                       class = class(workers))
[13:20:32.417]                     stop_if_not(is.finite(workers), workers >= 
[13:20:32.417]                       1L)
[13:20:32.417]                     if ((workers == 1L && !inherits(workers, 
[13:20:32.417]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:32.417]                       if (default_workers) 
[13:20:32.417]                         supportsMulticore(warn = TRUE)
[13:20:32.417]                       return(sequential(..., envir = envir))
[13:20:32.417]                     }
[13:20:32.417]                     oopts <- options(mc.cores = workers)
[13:20:32.417]                     on.exit(options(oopts))
[13:20:32.417]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:32.417]                       envir = envir)
[13:20:32.417]                     if (!future$lazy) 
[13:20:32.417]                       future <- run(future)
[13:20:32.417]                     invisible(future)
[13:20:32.417]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:32.417]                 }
[13:20:32.417]             }
[13:20:32.417]         }
[13:20:32.417]     })
[13:20:32.417]     if (TRUE) {
[13:20:32.417]         base::sink(type = "output", split = FALSE)
[13:20:32.417]         if (TRUE) {
[13:20:32.417]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:32.417]         }
[13:20:32.417]         else {
[13:20:32.417]             ...future.result["stdout"] <- base::list(NULL)
[13:20:32.417]         }
[13:20:32.417]         base::close(...future.stdout)
[13:20:32.417]         ...future.stdout <- NULL
[13:20:32.417]     }
[13:20:32.417]     ...future.result$conditions <- ...future.conditions
[13:20:32.417]     ...future.result$finished <- base::Sys.time()
[13:20:32.417]     ...future.result
[13:20:32.417] }
[13:20:32.420] assign_globals() ...
[13:20:32.420] List of 3
[13:20:32.420]  $ outer_function:function (x)  
[13:20:32.420]  $ map           :function (.x, .f, ...)  
[13:20:32.420]  $ inner_function:function (x)  
[13:20:32.420]  - attr(*, "where")=List of 3
[13:20:32.420]   ..$ outer_function:<environment: R_EmptyEnv> 
[13:20:32.420]   ..$ map           :<environment: R_EmptyEnv> 
[13:20:32.420]   ..$ inner_function:<environment: R_EmptyEnv> 
[13:20:32.420]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:32.420]  - attr(*, "resolved")= logi FALSE
[13:20:32.420]  - attr(*, "total_size")= num 7704
[13:20:32.420]  - attr(*, "already-done")= logi TRUE
[13:20:32.424] - reassign environment for ‘outer_function’
[13:20:32.424] - copied ‘outer_function’ to environment
[13:20:32.424] - reassign environment for ‘map’
[13:20:32.424] - copied ‘map’ to environment
[13:20:32.424] - reassign environment for ‘inner_function’
[13:20:32.424] - copied ‘inner_function’ to environment
[13:20:32.424] assign_globals() ... done
[13:20:32.425] requestCore(): workers = 2
[13:20:32.427] MulticoreFuture started
[13:20:32.427] - Launch lazy future ... done
[13:20:32.427] run() for ‘MulticoreFuture’ ... done
[13:20:32.428] plan(): Setting new future strategy stack:
[13:20:32.428] List of future strategies:
[13:20:32.428] 1. sequential:
[13:20:32.428]    - args: function (..., envir = parent.frame())
[13:20:32.428]    - tweaked: FALSE
[13:20:32.428]    - call: NULL
[13:20:32.429] plan(): nbrOfWorkers() = 1
[13:20:32.431] plan(): Setting new future strategy stack:
[13:20:32.431] List of future strategies:
[13:20:32.431] 1. multicore:
[13:20:32.431]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:32.431]    - tweaked: FALSE
[13:20:32.431]    - call: plan(strategy)
[13:20:32.437] plan(): nbrOfWorkers() = 2
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[13:20:32.443] getGlobalsAndPackages() ...
[13:20:32.443] Searching for globals...
[13:20:32.452] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[13:20:32.453] Searching for globals ... DONE
[13:20:32.453] Resolving globals: FALSE
[13:20:32.454] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[13:20:32.454] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[13:20:32.454] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[13:20:32.455] 
[13:20:32.455] getGlobalsAndPackages() ... DONE
[13:20:32.455] run() for ‘Future’ ...
[13:20:32.455] - state: ‘created’
[13:20:32.455] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:32.460] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:32.460] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:32.460]   - Field: ‘label’
[13:20:32.460]   - Field: ‘local’
[13:20:32.460]   - Field: ‘owner’
[13:20:32.460]   - Field: ‘envir’
[13:20:32.460]   - Field: ‘workers’
[13:20:32.460]   - Field: ‘packages’
[13:20:32.461]   - Field: ‘gc’
[13:20:32.461]   - Field: ‘job’
[13:20:32.461]   - Field: ‘conditions’
[13:20:32.461]   - Field: ‘expr’
[13:20:32.461]   - Field: ‘uuid’
[13:20:32.461]   - Field: ‘seed’
[13:20:32.461]   - Field: ‘version’
[13:20:32.461]   - Field: ‘result’
[13:20:32.462]   - Field: ‘asynchronous’
[13:20:32.462]   - Field: ‘calls’
[13:20:32.462]   - Field: ‘globals’
[13:20:32.462]   - Field: ‘stdout’
[13:20:32.462]   - Field: ‘earlySignal’
[13:20:32.462]   - Field: ‘lazy’
[13:20:32.462]   - Field: ‘state’
[13:20:32.462] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:32.462] - Launch lazy future ...
[13:20:32.463] Packages needed by the future expression (n = 0): <none>
[13:20:32.463] Packages needed by future strategies (n = 0): <none>
[13:20:32.463] {
[13:20:32.463]     {
[13:20:32.463]         {
[13:20:32.463]             ...future.startTime <- base::Sys.time()
[13:20:32.463]             {
[13:20:32.463]                 {
[13:20:32.463]                   {
[13:20:32.463]                     {
[13:20:32.463]                       base::local({
[13:20:32.463]                         has_future <- base::requireNamespace("future", 
[13:20:32.463]                           quietly = TRUE)
[13:20:32.463]                         if (has_future) {
[13:20:32.463]                           ns <- base::getNamespace("future")
[13:20:32.463]                           version <- ns[[".package"]][["version"]]
[13:20:32.463]                           if (is.null(version)) 
[13:20:32.463]                             version <- utils::packageVersion("future")
[13:20:32.463]                         }
[13:20:32.463]                         else {
[13:20:32.463]                           version <- NULL
[13:20:32.463]                         }
[13:20:32.463]                         if (!has_future || version < "1.8.0") {
[13:20:32.463]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:32.463]                             "", base::R.version$version.string), 
[13:20:32.463]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:32.463]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:32.463]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:32.463]                               "release", "version")], collapse = " "), 
[13:20:32.463]                             hostname = base::Sys.info()[["nodename"]])
[13:20:32.463]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:32.463]                             info)
[13:20:32.463]                           info <- base::paste(info, collapse = "; ")
[13:20:32.463]                           if (!has_future) {
[13:20:32.463]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:32.463]                               info)
[13:20:32.463]                           }
[13:20:32.463]                           else {
[13:20:32.463]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:32.463]                               info, version)
[13:20:32.463]                           }
[13:20:32.463]                           base::stop(msg)
[13:20:32.463]                         }
[13:20:32.463]                       })
[13:20:32.463]                     }
[13:20:32.463]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:32.463]                     base::options(mc.cores = 1L)
[13:20:32.463]                   }
[13:20:32.463]                   options(future.plan = NULL)
[13:20:32.463]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:32.463]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:32.463]                 }
[13:20:32.463]                 ...future.workdir <- getwd()
[13:20:32.463]             }
[13:20:32.463]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:32.463]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:32.463]         }
[13:20:32.463]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:32.463]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:32.463]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:32.463]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:32.463]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:32.463]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:32.463]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:32.463]             base::names(...future.oldOptions))
[13:20:32.463]     }
[13:20:32.463]     if (FALSE) {
[13:20:32.463]     }
[13:20:32.463]     else {
[13:20:32.463]         if (TRUE) {
[13:20:32.463]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:32.463]                 open = "w")
[13:20:32.463]         }
[13:20:32.463]         else {
[13:20:32.463]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:32.463]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:32.463]         }
[13:20:32.463]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:32.463]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:32.463]             base::sink(type = "output", split = FALSE)
[13:20:32.463]             base::close(...future.stdout)
[13:20:32.463]         }, add = TRUE)
[13:20:32.463]     }
[13:20:32.463]     ...future.frame <- base::sys.nframe()
[13:20:32.463]     ...future.conditions <- base::list()
[13:20:32.463]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:32.463]     if (FALSE) {
[13:20:32.463]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:32.463]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:32.463]     }
[13:20:32.463]     ...future.result <- base::tryCatch({
[13:20:32.463]         base::withCallingHandlers({
[13:20:32.463]             ...future.value <- base::withVisible(base::local({
[13:20:32.463]                 withCallingHandlers({
[13:20:32.463]                   {
[13:20:32.463]                     outer_function(1L)
[13:20:32.463]                   }
[13:20:32.463]                 }, immediateCondition = function(cond) {
[13:20:32.463]                   save_rds <- function (object, pathname, ...) 
[13:20:32.463]                   {
[13:20:32.463]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:32.463]                     if (file_test("-f", pathname_tmp)) {
[13:20:32.463]                       fi_tmp <- file.info(pathname_tmp)
[13:20:32.463]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:32.463]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:32.463]                         fi_tmp[["mtime"]])
[13:20:32.463]                     }
[13:20:32.463]                     tryCatch({
[13:20:32.463]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:32.463]                     }, error = function(ex) {
[13:20:32.463]                       msg <- conditionMessage(ex)
[13:20:32.463]                       fi_tmp <- file.info(pathname_tmp)
[13:20:32.463]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:32.463]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:32.463]                         fi_tmp[["mtime"]], msg)
[13:20:32.463]                       ex$message <- msg
[13:20:32.463]                       stop(ex)
[13:20:32.463]                     })
[13:20:32.463]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:32.463]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:32.463]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:32.463]                       fi_tmp <- file.info(pathname_tmp)
[13:20:32.463]                       fi <- file.info(pathname)
[13:20:32.463]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:32.463]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:32.463]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:32.463]                         fi[["size"]], fi[["mtime"]])
[13:20:32.463]                       stop(msg)
[13:20:32.463]                     }
[13:20:32.463]                     invisible(pathname)
[13:20:32.463]                   }
[13:20:32.463]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:32.463]                     rootPath = tempdir()) 
[13:20:32.463]                   {
[13:20:32.463]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:32.463]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:32.463]                       tmpdir = path, fileext = ".rds")
[13:20:32.463]                     save_rds(obj, file)
[13:20:32.463]                   }
[13:20:32.463]                   saveImmediateCondition(cond, path = "/tmp/Rtmpnh0Esg/.future/immediateConditions")
[13:20:32.463]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:32.463]                   {
[13:20:32.463]                     inherits <- base::inherits
[13:20:32.463]                     invokeRestart <- base::invokeRestart
[13:20:32.463]                     is.null <- base::is.null
[13:20:32.463]                     muffled <- FALSE
[13:20:32.463]                     if (inherits(cond, "message")) {
[13:20:32.463]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:32.463]                       if (muffled) 
[13:20:32.463]                         invokeRestart("muffleMessage")
[13:20:32.463]                     }
[13:20:32.463]                     else if (inherits(cond, "warning")) {
[13:20:32.463]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:32.463]                       if (muffled) 
[13:20:32.463]                         invokeRestart("muffleWarning")
[13:20:32.463]                     }
[13:20:32.463]                     else if (inherits(cond, "condition")) {
[13:20:32.463]                       if (!is.null(pattern)) {
[13:20:32.463]                         computeRestarts <- base::computeRestarts
[13:20:32.463]                         grepl <- base::grepl
[13:20:32.463]                         restarts <- computeRestarts(cond)
[13:20:32.463]                         for (restart in restarts) {
[13:20:32.463]                           name <- restart$name
[13:20:32.463]                           if (is.null(name)) 
[13:20:32.463]                             next
[13:20:32.463]                           if (!grepl(pattern, name)) 
[13:20:32.463]                             next
[13:20:32.463]                           invokeRestart(restart)
[13:20:32.463]                           muffled <- TRUE
[13:20:32.463]                           break
[13:20:32.463]                         }
[13:20:32.463]                       }
[13:20:32.463]                     }
[13:20:32.463]                     invisible(muffled)
[13:20:32.463]                   }
[13:20:32.463]                   muffleCondition(cond)
[13:20:32.463]                 })
[13:20:32.463]             }))
[13:20:32.463]             future::FutureResult(value = ...future.value$value, 
[13:20:32.463]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:32.463]                   ...future.rng), globalenv = if (FALSE) 
[13:20:32.463]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:32.463]                     ...future.globalenv.names))
[13:20:32.463]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:32.463]         }, condition = base::local({
[13:20:32.463]             c <- base::c
[13:20:32.463]             inherits <- base::inherits
[13:20:32.463]             invokeRestart <- base::invokeRestart
[13:20:32.463]             length <- base::length
[13:20:32.463]             list <- base::list
[13:20:32.463]             seq.int <- base::seq.int
[13:20:32.463]             signalCondition <- base::signalCondition
[13:20:32.463]             sys.calls <- base::sys.calls
[13:20:32.463]             `[[` <- base::`[[`
[13:20:32.463]             `+` <- base::`+`
[13:20:32.463]             `<<-` <- base::`<<-`
[13:20:32.463]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:32.463]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:32.463]                   3L)]
[13:20:32.463]             }
[13:20:32.463]             function(cond) {
[13:20:32.463]                 is_error <- inherits(cond, "error")
[13:20:32.463]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:32.463]                   NULL)
[13:20:32.463]                 if (is_error) {
[13:20:32.463]                   sessionInformation <- function() {
[13:20:32.463]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:32.463]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:32.463]                       search = base::search(), system = base::Sys.info())
[13:20:32.463]                   }
[13:20:32.463]                   ...future.conditions[[length(...future.conditions) + 
[13:20:32.463]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:32.463]                     cond$call), session = sessionInformation(), 
[13:20:32.463]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:32.463]                   signalCondition(cond)
[13:20:32.463]                 }
[13:20:32.463]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:32.463]                 "immediateCondition"))) {
[13:20:32.463]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:32.463]                   ...future.conditions[[length(...future.conditions) + 
[13:20:32.463]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:32.463]                   if (TRUE && !signal) {
[13:20:32.463]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:32.463]                     {
[13:20:32.463]                       inherits <- base::inherits
[13:20:32.463]                       invokeRestart <- base::invokeRestart
[13:20:32.463]                       is.null <- base::is.null
[13:20:32.463]                       muffled <- FALSE
[13:20:32.463]                       if (inherits(cond, "message")) {
[13:20:32.463]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:32.463]                         if (muffled) 
[13:20:32.463]                           invokeRestart("muffleMessage")
[13:20:32.463]                       }
[13:20:32.463]                       else if (inherits(cond, "warning")) {
[13:20:32.463]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:32.463]                         if (muffled) 
[13:20:32.463]                           invokeRestart("muffleWarning")
[13:20:32.463]                       }
[13:20:32.463]                       else if (inherits(cond, "condition")) {
[13:20:32.463]                         if (!is.null(pattern)) {
[13:20:32.463]                           computeRestarts <- base::computeRestarts
[13:20:32.463]                           grepl <- base::grepl
[13:20:32.463]                           restarts <- computeRestarts(cond)
[13:20:32.463]                           for (restart in restarts) {
[13:20:32.463]                             name <- restart$name
[13:20:32.463]                             if (is.null(name)) 
[13:20:32.463]                               next
[13:20:32.463]                             if (!grepl(pattern, name)) 
[13:20:32.463]                               next
[13:20:32.463]                             invokeRestart(restart)
[13:20:32.463]                             muffled <- TRUE
[13:20:32.463]                             break
[13:20:32.463]                           }
[13:20:32.463]                         }
[13:20:32.463]                       }
[13:20:32.463]                       invisible(muffled)
[13:20:32.463]                     }
[13:20:32.463]                     muffleCondition(cond, pattern = "^muffle")
[13:20:32.463]                   }
[13:20:32.463]                 }
[13:20:32.463]                 else {
[13:20:32.463]                   if (TRUE) {
[13:20:32.463]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:32.463]                     {
[13:20:32.463]                       inherits <- base::inherits
[13:20:32.463]                       invokeRestart <- base::invokeRestart
[13:20:32.463]                       is.null <- base::is.null
[13:20:32.463]                       muffled <- FALSE
[13:20:32.463]                       if (inherits(cond, "message")) {
[13:20:32.463]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:32.463]                         if (muffled) 
[13:20:32.463]                           invokeRestart("muffleMessage")
[13:20:32.463]                       }
[13:20:32.463]                       else if (inherits(cond, "warning")) {
[13:20:32.463]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:32.463]                         if (muffled) 
[13:20:32.463]                           invokeRestart("muffleWarning")
[13:20:32.463]                       }
[13:20:32.463]                       else if (inherits(cond, "condition")) {
[13:20:32.463]                         if (!is.null(pattern)) {
[13:20:32.463]                           computeRestarts <- base::computeRestarts
[13:20:32.463]                           grepl <- base::grepl
[13:20:32.463]                           restarts <- computeRestarts(cond)
[13:20:32.463]                           for (restart in restarts) {
[13:20:32.463]                             name <- restart$name
[13:20:32.463]                             if (is.null(name)) 
[13:20:32.463]                               next
[13:20:32.463]                             if (!grepl(pattern, name)) 
[13:20:32.463]                               next
[13:20:32.463]                             invokeRestart(restart)
[13:20:32.463]                             muffled <- TRUE
[13:20:32.463]                             break
[13:20:32.463]                           }
[13:20:32.463]                         }
[13:20:32.463]                       }
[13:20:32.463]                       invisible(muffled)
[13:20:32.463]                     }
[13:20:32.463]                     muffleCondition(cond, pattern = "^muffle")
[13:20:32.463]                   }
[13:20:32.463]                 }
[13:20:32.463]             }
[13:20:32.463]         }))
[13:20:32.463]     }, error = function(ex) {
[13:20:32.463]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:32.463]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:32.463]                 ...future.rng), started = ...future.startTime, 
[13:20:32.463]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:32.463]             version = "1.8"), class = "FutureResult")
[13:20:32.463]     }, finally = {
[13:20:32.463]         if (!identical(...future.workdir, getwd())) 
[13:20:32.463]             setwd(...future.workdir)
[13:20:32.463]         {
[13:20:32.463]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:32.463]                 ...future.oldOptions$nwarnings <- NULL
[13:20:32.463]             }
[13:20:32.463]             base::options(...future.oldOptions)
[13:20:32.463]             if (.Platform$OS.type == "windows") {
[13:20:32.463]                 old_names <- names(...future.oldEnvVars)
[13:20:32.463]                 envs <- base::Sys.getenv()
[13:20:32.463]                 names <- names(envs)
[13:20:32.463]                 common <- intersect(names, old_names)
[13:20:32.463]                 added <- setdiff(names, old_names)
[13:20:32.463]                 removed <- setdiff(old_names, names)
[13:20:32.463]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:32.463]                   envs[common]]
[13:20:32.463]                 NAMES <- toupper(changed)
[13:20:32.463]                 args <- list()
[13:20:32.463]                 for (kk in seq_along(NAMES)) {
[13:20:32.463]                   name <- changed[[kk]]
[13:20:32.463]                   NAME <- NAMES[[kk]]
[13:20:32.463]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:32.463]                     next
[13:20:32.463]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:32.463]                 }
[13:20:32.463]                 NAMES <- toupper(added)
[13:20:32.463]                 for (kk in seq_along(NAMES)) {
[13:20:32.463]                   name <- added[[kk]]
[13:20:32.463]                   NAME <- NAMES[[kk]]
[13:20:32.463]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:32.463]                     next
[13:20:32.463]                   args[[name]] <- ""
[13:20:32.463]                 }
[13:20:32.463]                 NAMES <- toupper(removed)
[13:20:32.463]                 for (kk in seq_along(NAMES)) {
[13:20:32.463]                   name <- removed[[kk]]
[13:20:32.463]                   NAME <- NAMES[[kk]]
[13:20:32.463]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:32.463]                     next
[13:20:32.463]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:32.463]                 }
[13:20:32.463]                 if (length(args) > 0) 
[13:20:32.463]                   base::do.call(base::Sys.setenv, args = args)
[13:20:32.463]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:32.463]             }
[13:20:32.463]             else {
[13:20:32.463]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:32.463]             }
[13:20:32.463]             {
[13:20:32.463]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:32.463]                   0L) {
[13:20:32.463]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:32.463]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:32.463]                   base::options(opts)
[13:20:32.463]                 }
[13:20:32.463]                 {
[13:20:32.463]                   {
[13:20:32.463]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:32.463]                     NULL
[13:20:32.463]                   }
[13:20:32.463]                   options(future.plan = NULL)
[13:20:32.463]                   if (is.na(NA_character_)) 
[13:20:32.463]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:32.463]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:32.463]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:32.463]                     envir = parent.frame()) 
[13:20:32.463]                   {
[13:20:32.463]                     default_workers <- missing(workers)
[13:20:32.463]                     if (is.function(workers)) 
[13:20:32.463]                       workers <- workers()
[13:20:32.463]                     workers <- structure(as.integer(workers), 
[13:20:32.463]                       class = class(workers))
[13:20:32.463]                     stop_if_not(is.finite(workers), workers >= 
[13:20:32.463]                       1L)
[13:20:32.463]                     if ((workers == 1L && !inherits(workers, 
[13:20:32.463]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:32.463]                       if (default_workers) 
[13:20:32.463]                         supportsMulticore(warn = TRUE)
[13:20:32.463]                       return(sequential(..., envir = envir))
[13:20:32.463]                     }
[13:20:32.463]                     oopts <- options(mc.cores = workers)
[13:20:32.463]                     on.exit(options(oopts))
[13:20:32.463]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:32.463]                       envir = envir)
[13:20:32.463]                     if (!future$lazy) 
[13:20:32.463]                       future <- run(future)
[13:20:32.463]                     invisible(future)
[13:20:32.463]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:32.463]                 }
[13:20:32.463]             }
[13:20:32.463]         }
[13:20:32.463]     })
[13:20:32.463]     if (TRUE) {
[13:20:32.463]         base::sink(type = "output", split = FALSE)
[13:20:32.463]         if (TRUE) {
[13:20:32.463]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:32.463]         }
[13:20:32.463]         else {
[13:20:32.463]             ...future.result["stdout"] <- base::list(NULL)
[13:20:32.463]         }
[13:20:32.463]         base::close(...future.stdout)
[13:20:32.463]         ...future.stdout <- NULL
[13:20:32.463]     }
[13:20:32.463]     ...future.result$conditions <- ...future.conditions
[13:20:32.463]     ...future.result$finished <- base::Sys.time()
[13:20:32.463]     ...future.result
[13:20:32.463] }
[13:20:32.466] assign_globals() ...
[13:20:32.466] List of 3
[13:20:32.466]  $ outer_function:function (x)  
[13:20:32.466]  $ map           :function (.x, .f, ...)  
[13:20:32.466]  $ inner_function:function (x)  
[13:20:32.466]  - attr(*, "where")=List of 3
[13:20:32.466]   ..$ outer_function:<environment: R_EmptyEnv> 
[13:20:32.466]   ..$ map           :<environment: R_EmptyEnv> 
[13:20:32.466]   ..$ inner_function:<environment: R_EmptyEnv> 
[13:20:32.466]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:32.466]  - attr(*, "resolved")= logi FALSE
[13:20:32.466]  - attr(*, "total_size")= num 7704
[13:20:32.466]  - attr(*, "already-done")= logi TRUE
[13:20:32.470] - reassign environment for ‘outer_function’
[13:20:32.470] - copied ‘outer_function’ to environment
[13:20:32.470] - reassign environment for ‘map’
[13:20:32.470] - copied ‘map’ to environment
[13:20:32.470] - reassign environment for ‘inner_function’
[13:20:32.470] - copied ‘inner_function’ to environment
[13:20:32.470] assign_globals() ... done
[13:20:32.470] requestCore(): workers = 2
[13:20:32.473] MulticoreFuture started
[13:20:32.473] - Launch lazy future ... done
[13:20:32.473] run() for ‘MulticoreFuture’ ... done
[13:20:32.474] plan(): Setting new future strategy stack:
[13:20:32.474] List of future strategies:
[13:20:32.474] 1. sequential:
[13:20:32.474]    - args: function (..., envir = parent.frame())
[13:20:32.474]    - tweaked: FALSE
[13:20:32.474]    - call: NULL
[13:20:32.475] plan(): nbrOfWorkers() = 1
[13:20:32.477] plan(): Setting new future strategy stack:
[13:20:32.478] List of future strategies:
[13:20:32.478] 1. multicore:
[13:20:32.478]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:32.478]    - tweaked: FALSE
[13:20:32.478]    - call: plan(strategy)
[13:20:32.483] plan(): nbrOfWorkers() = 2
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
- plan('multisession') ...
[13:20:32.486] plan(): Setting new future strategy stack:
[13:20:32.486] List of future strategies:
[13:20:32.486] 1. multisession:
[13:20:32.486]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:20:32.486]    - tweaked: FALSE
[13:20:32.486]    - call: plan(strategy)
[13:20:32.487] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:20:32.487] multisession:
[13:20:32.487] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:20:32.487] - tweaked: FALSE
[13:20:32.487] - call: plan(strategy)
[13:20:32.494] getGlobalsAndPackages() ...
[13:20:32.494] Not searching for globals
[13:20:32.497] - globals: [0] <none>
[13:20:32.497] getGlobalsAndPackages() ... DONE
[13:20:32.498] [local output] makeClusterPSOCK() ...
[13:20:32.540] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:20:32.545] [local output] Base port: 11574
[13:20:32.546] [local output] Getting setup options for 2 cluster nodes ...
[13:20:32.546] [local output]  - Node 1 of 2 ...
[13:20:32.546] [local output] localMachine=TRUE => revtunnel=FALSE

[13:20:32.547] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmpnh0Esg/worker.rank=1.parallelly.parent=85147.14c9b651951a9.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmpnh0Esg/worker.rank=1.parallelly.parent=85147.14c9b651951a9.pid")'’
[13:20:32.738] - Possible to infer worker's PID: TRUE
[13:20:32.738] [local output] Rscript port: 11574

[13:20:32.739] [local output]  - Node 2 of 2 ...
[13:20:32.739] [local output] localMachine=TRUE => revtunnel=FALSE

[13:20:32.740] [local output] Rscript port: 11574

[13:20:32.740] [local output] Getting setup options for 2 cluster nodes ... done
[13:20:32.740] [local output]  - Parallel setup requested for some PSOCK nodes
[13:20:32.741] [local output] Setting up PSOCK nodes in parallel
[13:20:32.741] List of 36
[13:20:32.741]  $ worker          : chr "localhost"
[13:20:32.741]   ..- attr(*, "localhost")= logi TRUE
[13:20:32.741]  $ master          : chr "localhost"
[13:20:32.741]  $ port            : int 11574
[13:20:32.741]  $ connectTimeout  : num 120
[13:20:32.741]  $ timeout         : num 2592000
[13:20:32.741]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:20:32.741]  $ homogeneous     : logi TRUE
[13:20:32.741]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:20:32.741]  $ rscript_envs    : NULL
[13:20:32.741]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:20:32.741]  $ rscript_startup : NULL
[13:20:32.741]  $ rscript_sh      : chr "sh"
[13:20:32.741]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:20:32.741]  $ methods         : logi TRUE
[13:20:32.741]  $ socketOptions   : chr "no-delay"
[13:20:32.741]  $ useXDR          : logi FALSE
[13:20:32.741]  $ outfile         : chr "/dev/null"
[13:20:32.741]  $ renice          : int NA
[13:20:32.741]  $ rshcmd          : NULL
[13:20:32.741]  $ user            : chr(0) 
[13:20:32.741]  $ revtunnel       : logi FALSE
[13:20:32.741]  $ rshlogfile      : NULL
[13:20:32.741]  $ rshopts         : chr(0) 
[13:20:32.741]  $ rank            : int 1
[13:20:32.741]  $ manual          : logi FALSE
[13:20:32.741]  $ dryrun          : logi FALSE
[13:20:32.741]  $ quiet           : logi FALSE
[13:20:32.741]  $ setup_strategy  : chr "parallel"
[13:20:32.741]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:20:32.741]  $ pidfile         : chr "/tmp/Rtmpnh0Esg/worker.rank=1.parallelly.parent=85147.14c9b651951a9.pid"
[13:20:32.741]  $ rshcmd_label    : NULL
[13:20:32.741]  $ rsh_call        : NULL
[13:20:32.741]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:20:32.741]  $ localMachine    : logi TRUE
[13:20:32.741]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:20:32.741]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:20:32.741]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:20:32.741]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:20:32.741]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:20:32.741]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:20:32.741]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:20:32.741]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:20:32.741]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:20:32.741]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:20:32.741]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:20:32.741]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:20:32.741]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:20:32.741]  $ arguments       :List of 28
[13:20:32.741]   ..$ worker          : chr "localhost"
[13:20:32.741]   ..$ master          : NULL
[13:20:32.741]   ..$ port            : int 11574
[13:20:32.741]   ..$ connectTimeout  : num 120
[13:20:32.741]   ..$ timeout         : num 2592000
[13:20:32.741]   ..$ rscript         : NULL
[13:20:32.741]   ..$ homogeneous     : NULL
[13:20:32.741]   ..$ rscript_args    : NULL
[13:20:32.741]   ..$ rscript_envs    : NULL
[13:20:32.741]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:20:32.741]   ..$ rscript_startup : NULL
[13:20:32.741]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:20:32.741]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:20:32.741]   ..$ methods         : logi TRUE
[13:20:32.741]   ..$ socketOptions   : chr "no-delay"
[13:20:32.741]   ..$ useXDR          : logi FALSE
[13:20:32.741]   ..$ outfile         : chr "/dev/null"
[13:20:32.741]   ..$ renice          : int NA
[13:20:32.741]   ..$ rshcmd          : NULL
[13:20:32.741]   ..$ user            : NULL
[13:20:32.741]   ..$ revtunnel       : logi NA
[13:20:32.741]   ..$ rshlogfile      : NULL
[13:20:32.741]   ..$ rshopts         : NULL
[13:20:32.741]   ..$ rank            : int 1
[13:20:32.741]   ..$ manual          : logi FALSE
[13:20:32.741]   ..$ dryrun          : logi FALSE
[13:20:32.741]   ..$ quiet           : logi FALSE
[13:20:32.741]   ..$ setup_strategy  : chr "parallel"
[13:20:32.741]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:20:32.758] [local output] System call to launch all workers:
[13:20:32.758] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmpnh0Esg/worker.rank=1.parallelly.parent=85147.14c9b651951a9.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11574 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:20:32.758] [local output] Starting PSOCK main server
[13:20:32.759] [local output] Workers launched
[13:20:32.759] [local output] Waiting for workers to connect back
[13:20:32.760]  - [local output] 0 workers out of 2 ready
[13:20:33.007]  - [local output] 0 workers out of 2 ready
[13:20:33.008]  - [local output] 1 workers out of 2 ready
[13:20:33.012]  - [local output] 1 workers out of 2 ready
[13:20:33.012]  - [local output] 2 workers out of 2 ready
[13:20:33.012] [local output] Launching of workers completed
[13:20:33.012] [local output] Collecting session information from workers
[13:20:33.013] [local output]  - Worker #1 of 2
[13:20:33.014] [local output]  - Worker #2 of 2
[13:20:33.014] [local output] makeClusterPSOCK() ... done
[13:20:33.026] Packages needed by the future expression (n = 0): <none>
[13:20:33.026] Packages needed by future strategies (n = 0): <none>
[13:20:33.026] {
[13:20:33.026]     {
[13:20:33.026]         {
[13:20:33.026]             ...future.startTime <- base::Sys.time()
[13:20:33.026]             {
[13:20:33.026]                 {
[13:20:33.026]                   {
[13:20:33.026]                     {
[13:20:33.026]                       base::local({
[13:20:33.026]                         has_future <- base::requireNamespace("future", 
[13:20:33.026]                           quietly = TRUE)
[13:20:33.026]                         if (has_future) {
[13:20:33.026]                           ns <- base::getNamespace("future")
[13:20:33.026]                           version <- ns[[".package"]][["version"]]
[13:20:33.026]                           if (is.null(version)) 
[13:20:33.026]                             version <- utils::packageVersion("future")
[13:20:33.026]                         }
[13:20:33.026]                         else {
[13:20:33.026]                           version <- NULL
[13:20:33.026]                         }
[13:20:33.026]                         if (!has_future || version < "1.8.0") {
[13:20:33.026]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:33.026]                             "", base::R.version$version.string), 
[13:20:33.026]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:33.026]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:33.026]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:33.026]                               "release", "version")], collapse = " "), 
[13:20:33.026]                             hostname = base::Sys.info()[["nodename"]])
[13:20:33.026]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:33.026]                             info)
[13:20:33.026]                           info <- base::paste(info, collapse = "; ")
[13:20:33.026]                           if (!has_future) {
[13:20:33.026]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:33.026]                               info)
[13:20:33.026]                           }
[13:20:33.026]                           else {
[13:20:33.026]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:33.026]                               info, version)
[13:20:33.026]                           }
[13:20:33.026]                           base::stop(msg)
[13:20:33.026]                         }
[13:20:33.026]                       })
[13:20:33.026]                     }
[13:20:33.026]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:33.026]                     base::options(mc.cores = 1L)
[13:20:33.026]                   }
[13:20:33.026]                   options(future.plan = NULL)
[13:20:33.026]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:33.026]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:33.026]                 }
[13:20:33.026]                 ...future.workdir <- getwd()
[13:20:33.026]             }
[13:20:33.026]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:33.026]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:33.026]         }
[13:20:33.026]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:33.026]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:33.026]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:33.026]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:33.026]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:33.026]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:33.026]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:33.026]             base::names(...future.oldOptions))
[13:20:33.026]     }
[13:20:33.026]     if (FALSE) {
[13:20:33.026]     }
[13:20:33.026]     else {
[13:20:33.026]         if (TRUE) {
[13:20:33.026]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:33.026]                 open = "w")
[13:20:33.026]         }
[13:20:33.026]         else {
[13:20:33.026]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:33.026]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:33.026]         }
[13:20:33.026]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:33.026]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:33.026]             base::sink(type = "output", split = FALSE)
[13:20:33.026]             base::close(...future.stdout)
[13:20:33.026]         }, add = TRUE)
[13:20:33.026]     }
[13:20:33.026]     ...future.frame <- base::sys.nframe()
[13:20:33.026]     ...future.conditions <- base::list()
[13:20:33.026]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:33.026]     if (FALSE) {
[13:20:33.026]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:33.026]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:33.026]     }
[13:20:33.026]     ...future.result <- base::tryCatch({
[13:20:33.026]         base::withCallingHandlers({
[13:20:33.026]             ...future.value <- base::withVisible(base::local({
[13:20:33.026]                 ...future.makeSendCondition <- local({
[13:20:33.026]                   sendCondition <- NULL
[13:20:33.026]                   function(frame = 1L) {
[13:20:33.026]                     if (is.function(sendCondition)) 
[13:20:33.026]                       return(sendCondition)
[13:20:33.026]                     ns <- getNamespace("parallel")
[13:20:33.026]                     if (exists("sendData", mode = "function", 
[13:20:33.026]                       envir = ns)) {
[13:20:33.026]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:33.026]                         envir = ns)
[13:20:33.026]                       envir <- sys.frame(frame)
[13:20:33.026]                       master <- NULL
[13:20:33.026]                       while (!identical(envir, .GlobalEnv) && 
[13:20:33.026]                         !identical(envir, emptyenv())) {
[13:20:33.026]                         if (exists("master", mode = "list", envir = envir, 
[13:20:33.026]                           inherits = FALSE)) {
[13:20:33.026]                           master <- get("master", mode = "list", 
[13:20:33.026]                             envir = envir, inherits = FALSE)
[13:20:33.026]                           if (inherits(master, c("SOCKnode", 
[13:20:33.026]                             "SOCK0node"))) {
[13:20:33.026]                             sendCondition <<- function(cond) {
[13:20:33.026]                               data <- list(type = "VALUE", value = cond, 
[13:20:33.026]                                 success = TRUE)
[13:20:33.026]                               parallel_sendData(master, data)
[13:20:33.026]                             }
[13:20:33.026]                             return(sendCondition)
[13:20:33.026]                           }
[13:20:33.026]                         }
[13:20:33.026]                         frame <- frame + 1L
[13:20:33.026]                         envir <- sys.frame(frame)
[13:20:33.026]                       }
[13:20:33.026]                     }
[13:20:33.026]                     sendCondition <<- function(cond) NULL
[13:20:33.026]                   }
[13:20:33.026]                 })
[13:20:33.026]                 withCallingHandlers({
[13:20:33.026]                   NA
[13:20:33.026]                 }, immediateCondition = function(cond) {
[13:20:33.026]                   sendCondition <- ...future.makeSendCondition()
[13:20:33.026]                   sendCondition(cond)
[13:20:33.026]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:33.026]                   {
[13:20:33.026]                     inherits <- base::inherits
[13:20:33.026]                     invokeRestart <- base::invokeRestart
[13:20:33.026]                     is.null <- base::is.null
[13:20:33.026]                     muffled <- FALSE
[13:20:33.026]                     if (inherits(cond, "message")) {
[13:20:33.026]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:33.026]                       if (muffled) 
[13:20:33.026]                         invokeRestart("muffleMessage")
[13:20:33.026]                     }
[13:20:33.026]                     else if (inherits(cond, "warning")) {
[13:20:33.026]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:33.026]                       if (muffled) 
[13:20:33.026]                         invokeRestart("muffleWarning")
[13:20:33.026]                     }
[13:20:33.026]                     else if (inherits(cond, "condition")) {
[13:20:33.026]                       if (!is.null(pattern)) {
[13:20:33.026]                         computeRestarts <- base::computeRestarts
[13:20:33.026]                         grepl <- base::grepl
[13:20:33.026]                         restarts <- computeRestarts(cond)
[13:20:33.026]                         for (restart in restarts) {
[13:20:33.026]                           name <- restart$name
[13:20:33.026]                           if (is.null(name)) 
[13:20:33.026]                             next
[13:20:33.026]                           if (!grepl(pattern, name)) 
[13:20:33.026]                             next
[13:20:33.026]                           invokeRestart(restart)
[13:20:33.026]                           muffled <- TRUE
[13:20:33.026]                           break
[13:20:33.026]                         }
[13:20:33.026]                       }
[13:20:33.026]                     }
[13:20:33.026]                     invisible(muffled)
[13:20:33.026]                   }
[13:20:33.026]                   muffleCondition(cond)
[13:20:33.026]                 })
[13:20:33.026]             }))
[13:20:33.026]             future::FutureResult(value = ...future.value$value, 
[13:20:33.026]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:33.026]                   ...future.rng), globalenv = if (FALSE) 
[13:20:33.026]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:33.026]                     ...future.globalenv.names))
[13:20:33.026]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:33.026]         }, condition = base::local({
[13:20:33.026]             c <- base::c
[13:20:33.026]             inherits <- base::inherits
[13:20:33.026]             invokeRestart <- base::invokeRestart
[13:20:33.026]             length <- base::length
[13:20:33.026]             list <- base::list
[13:20:33.026]             seq.int <- base::seq.int
[13:20:33.026]             signalCondition <- base::signalCondition
[13:20:33.026]             sys.calls <- base::sys.calls
[13:20:33.026]             `[[` <- base::`[[`
[13:20:33.026]             `+` <- base::`+`
[13:20:33.026]             `<<-` <- base::`<<-`
[13:20:33.026]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:33.026]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:33.026]                   3L)]
[13:20:33.026]             }
[13:20:33.026]             function(cond) {
[13:20:33.026]                 is_error <- inherits(cond, "error")
[13:20:33.026]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:33.026]                   NULL)
[13:20:33.026]                 if (is_error) {
[13:20:33.026]                   sessionInformation <- function() {
[13:20:33.026]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:33.026]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:33.026]                       search = base::search(), system = base::Sys.info())
[13:20:33.026]                   }
[13:20:33.026]                   ...future.conditions[[length(...future.conditions) + 
[13:20:33.026]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:33.026]                     cond$call), session = sessionInformation(), 
[13:20:33.026]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:33.026]                   signalCondition(cond)
[13:20:33.026]                 }
[13:20:33.026]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:33.026]                 "immediateCondition"))) {
[13:20:33.026]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:33.026]                   ...future.conditions[[length(...future.conditions) + 
[13:20:33.026]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:33.026]                   if (TRUE && !signal) {
[13:20:33.026]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:33.026]                     {
[13:20:33.026]                       inherits <- base::inherits
[13:20:33.026]                       invokeRestart <- base::invokeRestart
[13:20:33.026]                       is.null <- base::is.null
[13:20:33.026]                       muffled <- FALSE
[13:20:33.026]                       if (inherits(cond, "message")) {
[13:20:33.026]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:33.026]                         if (muffled) 
[13:20:33.026]                           invokeRestart("muffleMessage")
[13:20:33.026]                       }
[13:20:33.026]                       else if (inherits(cond, "warning")) {
[13:20:33.026]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:33.026]                         if (muffled) 
[13:20:33.026]                           invokeRestart("muffleWarning")
[13:20:33.026]                       }
[13:20:33.026]                       else if (inherits(cond, "condition")) {
[13:20:33.026]                         if (!is.null(pattern)) {
[13:20:33.026]                           computeRestarts <- base::computeRestarts
[13:20:33.026]                           grepl <- base::grepl
[13:20:33.026]                           restarts <- computeRestarts(cond)
[13:20:33.026]                           for (restart in restarts) {
[13:20:33.026]                             name <- restart$name
[13:20:33.026]                             if (is.null(name)) 
[13:20:33.026]                               next
[13:20:33.026]                             if (!grepl(pattern, name)) 
[13:20:33.026]                               next
[13:20:33.026]                             invokeRestart(restart)
[13:20:33.026]                             muffled <- TRUE
[13:20:33.026]                             break
[13:20:33.026]                           }
[13:20:33.026]                         }
[13:20:33.026]                       }
[13:20:33.026]                       invisible(muffled)
[13:20:33.026]                     }
[13:20:33.026]                     muffleCondition(cond, pattern = "^muffle")
[13:20:33.026]                   }
[13:20:33.026]                 }
[13:20:33.026]                 else {
[13:20:33.026]                   if (TRUE) {
[13:20:33.026]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:33.026]                     {
[13:20:33.026]                       inherits <- base::inherits
[13:20:33.026]                       invokeRestart <- base::invokeRestart
[13:20:33.026]                       is.null <- base::is.null
[13:20:33.026]                       muffled <- FALSE
[13:20:33.026]                       if (inherits(cond, "message")) {
[13:20:33.026]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:33.026]                         if (muffled) 
[13:20:33.026]                           invokeRestart("muffleMessage")
[13:20:33.026]                       }
[13:20:33.026]                       else if (inherits(cond, "warning")) {
[13:20:33.026]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:33.026]                         if (muffled) 
[13:20:33.026]                           invokeRestart("muffleWarning")
[13:20:33.026]                       }
[13:20:33.026]                       else if (inherits(cond, "condition")) {
[13:20:33.026]                         if (!is.null(pattern)) {
[13:20:33.026]                           computeRestarts <- base::computeRestarts
[13:20:33.026]                           grepl <- base::grepl
[13:20:33.026]                           restarts <- computeRestarts(cond)
[13:20:33.026]                           for (restart in restarts) {
[13:20:33.026]                             name <- restart$name
[13:20:33.026]                             if (is.null(name)) 
[13:20:33.026]                               next
[13:20:33.026]                             if (!grepl(pattern, name)) 
[13:20:33.026]                               next
[13:20:33.026]                             invokeRestart(restart)
[13:20:33.026]                             muffled <- TRUE
[13:20:33.026]                             break
[13:20:33.026]                           }
[13:20:33.026]                         }
[13:20:33.026]                       }
[13:20:33.026]                       invisible(muffled)
[13:20:33.026]                     }
[13:20:33.026]                     muffleCondition(cond, pattern = "^muffle")
[13:20:33.026]                   }
[13:20:33.026]                 }
[13:20:33.026]             }
[13:20:33.026]         }))
[13:20:33.026]     }, error = function(ex) {
[13:20:33.026]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:33.026]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:33.026]                 ...future.rng), started = ...future.startTime, 
[13:20:33.026]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:33.026]             version = "1.8"), class = "FutureResult")
[13:20:33.026]     }, finally = {
[13:20:33.026]         if (!identical(...future.workdir, getwd())) 
[13:20:33.026]             setwd(...future.workdir)
[13:20:33.026]         {
[13:20:33.026]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:33.026]                 ...future.oldOptions$nwarnings <- NULL
[13:20:33.026]             }
[13:20:33.026]             base::options(...future.oldOptions)
[13:20:33.026]             if (.Platform$OS.type == "windows") {
[13:20:33.026]                 old_names <- names(...future.oldEnvVars)
[13:20:33.026]                 envs <- base::Sys.getenv()
[13:20:33.026]                 names <- names(envs)
[13:20:33.026]                 common <- intersect(names, old_names)
[13:20:33.026]                 added <- setdiff(names, old_names)
[13:20:33.026]                 removed <- setdiff(old_names, names)
[13:20:33.026]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:33.026]                   envs[common]]
[13:20:33.026]                 NAMES <- toupper(changed)
[13:20:33.026]                 args <- list()
[13:20:33.026]                 for (kk in seq_along(NAMES)) {
[13:20:33.026]                   name <- changed[[kk]]
[13:20:33.026]                   NAME <- NAMES[[kk]]
[13:20:33.026]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:33.026]                     next
[13:20:33.026]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:33.026]                 }
[13:20:33.026]                 NAMES <- toupper(added)
[13:20:33.026]                 for (kk in seq_along(NAMES)) {
[13:20:33.026]                   name <- added[[kk]]
[13:20:33.026]                   NAME <- NAMES[[kk]]
[13:20:33.026]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:33.026]                     next
[13:20:33.026]                   args[[name]] <- ""
[13:20:33.026]                 }
[13:20:33.026]                 NAMES <- toupper(removed)
[13:20:33.026]                 for (kk in seq_along(NAMES)) {
[13:20:33.026]                   name <- removed[[kk]]
[13:20:33.026]                   NAME <- NAMES[[kk]]
[13:20:33.026]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:33.026]                     next
[13:20:33.026]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:33.026]                 }
[13:20:33.026]                 if (length(args) > 0) 
[13:20:33.026]                   base::do.call(base::Sys.setenv, args = args)
[13:20:33.026]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:33.026]             }
[13:20:33.026]             else {
[13:20:33.026]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:33.026]             }
[13:20:33.026]             {
[13:20:33.026]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:33.026]                   0L) {
[13:20:33.026]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:33.026]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:33.026]                   base::options(opts)
[13:20:33.026]                 }
[13:20:33.026]                 {
[13:20:33.026]                   {
[13:20:33.026]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:33.026]                     NULL
[13:20:33.026]                   }
[13:20:33.026]                   options(future.plan = NULL)
[13:20:33.026]                   if (is.na(NA_character_)) 
[13:20:33.026]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:33.026]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:33.026]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:33.026]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:33.026]                     envir = parent.frame()) 
[13:20:33.026]                   {
[13:20:33.026]                     if (is.function(workers)) 
[13:20:33.026]                       workers <- workers()
[13:20:33.026]                     workers <- structure(as.integer(workers), 
[13:20:33.026]                       class = class(workers))
[13:20:33.026]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:33.026]                       workers >= 1)
[13:20:33.026]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:33.026]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:33.026]                     }
[13:20:33.026]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:33.026]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:33.026]                       envir = envir)
[13:20:33.026]                     if (!future$lazy) 
[13:20:33.026]                       future <- run(future)
[13:20:33.026]                     invisible(future)
[13:20:33.026]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:33.026]                 }
[13:20:33.026]             }
[13:20:33.026]         }
[13:20:33.026]     })
[13:20:33.026]     if (TRUE) {
[13:20:33.026]         base::sink(type = "output", split = FALSE)
[13:20:33.026]         if (TRUE) {
[13:20:33.026]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:33.026]         }
[13:20:33.026]         else {
[13:20:33.026]             ...future.result["stdout"] <- base::list(NULL)
[13:20:33.026]         }
[13:20:33.026]         base::close(...future.stdout)
[13:20:33.026]         ...future.stdout <- NULL
[13:20:33.026]     }
[13:20:33.026]     ...future.result$conditions <- ...future.conditions
[13:20:33.026]     ...future.result$finished <- base::Sys.time()
[13:20:33.026]     ...future.result
[13:20:33.026] }
[13:20:33.100] MultisessionFuture started
[13:20:33.101] result() for ClusterFuture ...
[13:20:33.102] receiveMessageFromWorker() for ClusterFuture ...
[13:20:33.102] - Validating connection of MultisessionFuture
[13:20:33.135] - received message: FutureResult
[13:20:33.135] - Received FutureResult
[13:20:33.135] - Erased future from FutureRegistry
[13:20:33.136] result() for ClusterFuture ...
[13:20:33.136] - result already collected: FutureResult
[13:20:33.136] result() for ClusterFuture ... done
[13:20:33.136] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:33.136] result() for ClusterFuture ... done
[13:20:33.136] result() for ClusterFuture ...
[13:20:33.136] - result already collected: FutureResult
[13:20:33.136] result() for ClusterFuture ... done
[13:20:33.137] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:20:33.140] plan(): nbrOfWorkers() = 2
- lm(<formula>) ...
[13:20:33.141] getGlobalsAndPackages() ...
[13:20:33.141] Searching for globals...
[13:20:33.143] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:20:33.143] Searching for globals ... DONE
[13:20:33.143] Resolving globals: FALSE
[13:20:33.144] The total size of the 2 globals is 896 bytes (896 bytes)
[13:20:33.144] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:20:33.144] - globals: [2] ‘weight’, ‘group’
[13:20:33.144] - packages: [1] ‘stats’
[13:20:33.144] getGlobalsAndPackages() ... DONE
[13:20:33.145] run() for ‘Future’ ...
[13:20:33.145] - state: ‘created’
[13:20:33.145] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:33.160] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:33.160] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:33.160]   - Field: ‘node’
[13:20:33.160]   - Field: ‘label’
[13:20:33.161]   - Field: ‘local’
[13:20:33.161]   - Field: ‘owner’
[13:20:33.161]   - Field: ‘envir’
[13:20:33.161]   - Field: ‘workers’
[13:20:33.161]   - Field: ‘packages’
[13:20:33.161]   - Field: ‘gc’
[13:20:33.161]   - Field: ‘conditions’
[13:20:33.161]   - Field: ‘persistent’
[13:20:33.161]   - Field: ‘expr’
[13:20:33.162]   - Field: ‘uuid’
[13:20:33.162]   - Field: ‘seed’
[13:20:33.162]   - Field: ‘version’
[13:20:33.162]   - Field: ‘result’
[13:20:33.162]   - Field: ‘asynchronous’
[13:20:33.162]   - Field: ‘calls’
[13:20:33.162]   - Field: ‘globals’
[13:20:33.162]   - Field: ‘stdout’
[13:20:33.162]   - Field: ‘earlySignal’
[13:20:33.163]   - Field: ‘lazy’
[13:20:33.163]   - Field: ‘state’
[13:20:33.163] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:33.163] - Launch lazy future ...
[13:20:33.163] Packages needed by the future expression (n = 1): ‘stats’
[13:20:33.163] Packages needed by future strategies (n = 0): <none>
[13:20:33.164] {
[13:20:33.164]     {
[13:20:33.164]         {
[13:20:33.164]             ...future.startTime <- base::Sys.time()
[13:20:33.164]             {
[13:20:33.164]                 {
[13:20:33.164]                   {
[13:20:33.164]                     {
[13:20:33.164]                       {
[13:20:33.164]                         base::local({
[13:20:33.164]                           has_future <- base::requireNamespace("future", 
[13:20:33.164]                             quietly = TRUE)
[13:20:33.164]                           if (has_future) {
[13:20:33.164]                             ns <- base::getNamespace("future")
[13:20:33.164]                             version <- ns[[".package"]][["version"]]
[13:20:33.164]                             if (is.null(version)) 
[13:20:33.164]                               version <- utils::packageVersion("future")
[13:20:33.164]                           }
[13:20:33.164]                           else {
[13:20:33.164]                             version <- NULL
[13:20:33.164]                           }
[13:20:33.164]                           if (!has_future || version < "1.8.0") {
[13:20:33.164]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:33.164]                               "", base::R.version$version.string), 
[13:20:33.164]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:33.164]                                 base::R.version$platform, 8 * 
[13:20:33.164]                                   base::.Machine$sizeof.pointer), 
[13:20:33.164]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:33.164]                                 "release", "version")], collapse = " "), 
[13:20:33.164]                               hostname = base::Sys.info()[["nodename"]])
[13:20:33.164]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:33.164]                               info)
[13:20:33.164]                             info <- base::paste(info, collapse = "; ")
[13:20:33.164]                             if (!has_future) {
[13:20:33.164]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:33.164]                                 info)
[13:20:33.164]                             }
[13:20:33.164]                             else {
[13:20:33.164]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:33.164]                                 info, version)
[13:20:33.164]                             }
[13:20:33.164]                             base::stop(msg)
[13:20:33.164]                           }
[13:20:33.164]                         })
[13:20:33.164]                       }
[13:20:33.164]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:33.164]                       base::options(mc.cores = 1L)
[13:20:33.164]                     }
[13:20:33.164]                     base::local({
[13:20:33.164]                       for (pkg in "stats") {
[13:20:33.164]                         base::loadNamespace(pkg)
[13:20:33.164]                         base::library(pkg, character.only = TRUE)
[13:20:33.164]                       }
[13:20:33.164]                     })
[13:20:33.164]                   }
[13:20:33.164]                   options(future.plan = NULL)
[13:20:33.164]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:33.164]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:33.164]                 }
[13:20:33.164]                 ...future.workdir <- getwd()
[13:20:33.164]             }
[13:20:33.164]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:33.164]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:33.164]         }
[13:20:33.164]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:33.164]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:33.164]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:33.164]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:33.164]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:33.164]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:33.164]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:33.164]             base::names(...future.oldOptions))
[13:20:33.164]     }
[13:20:33.164]     if (FALSE) {
[13:20:33.164]     }
[13:20:33.164]     else {
[13:20:33.164]         if (TRUE) {
[13:20:33.164]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:33.164]                 open = "w")
[13:20:33.164]         }
[13:20:33.164]         else {
[13:20:33.164]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:33.164]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:33.164]         }
[13:20:33.164]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:33.164]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:33.164]             base::sink(type = "output", split = FALSE)
[13:20:33.164]             base::close(...future.stdout)
[13:20:33.164]         }, add = TRUE)
[13:20:33.164]     }
[13:20:33.164]     ...future.frame <- base::sys.nframe()
[13:20:33.164]     ...future.conditions <- base::list()
[13:20:33.164]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:33.164]     if (FALSE) {
[13:20:33.164]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:33.164]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:33.164]     }
[13:20:33.164]     ...future.result <- base::tryCatch({
[13:20:33.164]         base::withCallingHandlers({
[13:20:33.164]             ...future.value <- base::withVisible(base::local({
[13:20:33.164]                 ...future.makeSendCondition <- local({
[13:20:33.164]                   sendCondition <- NULL
[13:20:33.164]                   function(frame = 1L) {
[13:20:33.164]                     if (is.function(sendCondition)) 
[13:20:33.164]                       return(sendCondition)
[13:20:33.164]                     ns <- getNamespace("parallel")
[13:20:33.164]                     if (exists("sendData", mode = "function", 
[13:20:33.164]                       envir = ns)) {
[13:20:33.164]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:33.164]                         envir = ns)
[13:20:33.164]                       envir <- sys.frame(frame)
[13:20:33.164]                       master <- NULL
[13:20:33.164]                       while (!identical(envir, .GlobalEnv) && 
[13:20:33.164]                         !identical(envir, emptyenv())) {
[13:20:33.164]                         if (exists("master", mode = "list", envir = envir, 
[13:20:33.164]                           inherits = FALSE)) {
[13:20:33.164]                           master <- get("master", mode = "list", 
[13:20:33.164]                             envir = envir, inherits = FALSE)
[13:20:33.164]                           if (inherits(master, c("SOCKnode", 
[13:20:33.164]                             "SOCK0node"))) {
[13:20:33.164]                             sendCondition <<- function(cond) {
[13:20:33.164]                               data <- list(type = "VALUE", value = cond, 
[13:20:33.164]                                 success = TRUE)
[13:20:33.164]                               parallel_sendData(master, data)
[13:20:33.164]                             }
[13:20:33.164]                             return(sendCondition)
[13:20:33.164]                           }
[13:20:33.164]                         }
[13:20:33.164]                         frame <- frame + 1L
[13:20:33.164]                         envir <- sys.frame(frame)
[13:20:33.164]                       }
[13:20:33.164]                     }
[13:20:33.164]                     sendCondition <<- function(cond) NULL
[13:20:33.164]                   }
[13:20:33.164]                 })
[13:20:33.164]                 withCallingHandlers({
[13:20:33.164]                   {
[13:20:33.164]                     lm(weight ~ group - 1)
[13:20:33.164]                   }
[13:20:33.164]                 }, immediateCondition = function(cond) {
[13:20:33.164]                   sendCondition <- ...future.makeSendCondition()
[13:20:33.164]                   sendCondition(cond)
[13:20:33.164]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:33.164]                   {
[13:20:33.164]                     inherits <- base::inherits
[13:20:33.164]                     invokeRestart <- base::invokeRestart
[13:20:33.164]                     is.null <- base::is.null
[13:20:33.164]                     muffled <- FALSE
[13:20:33.164]                     if (inherits(cond, "message")) {
[13:20:33.164]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:33.164]                       if (muffled) 
[13:20:33.164]                         invokeRestart("muffleMessage")
[13:20:33.164]                     }
[13:20:33.164]                     else if (inherits(cond, "warning")) {
[13:20:33.164]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:33.164]                       if (muffled) 
[13:20:33.164]                         invokeRestart("muffleWarning")
[13:20:33.164]                     }
[13:20:33.164]                     else if (inherits(cond, "condition")) {
[13:20:33.164]                       if (!is.null(pattern)) {
[13:20:33.164]                         computeRestarts <- base::computeRestarts
[13:20:33.164]                         grepl <- base::grepl
[13:20:33.164]                         restarts <- computeRestarts(cond)
[13:20:33.164]                         for (restart in restarts) {
[13:20:33.164]                           name <- restart$name
[13:20:33.164]                           if (is.null(name)) 
[13:20:33.164]                             next
[13:20:33.164]                           if (!grepl(pattern, name)) 
[13:20:33.164]                             next
[13:20:33.164]                           invokeRestart(restart)
[13:20:33.164]                           muffled <- TRUE
[13:20:33.164]                           break
[13:20:33.164]                         }
[13:20:33.164]                       }
[13:20:33.164]                     }
[13:20:33.164]                     invisible(muffled)
[13:20:33.164]                   }
[13:20:33.164]                   muffleCondition(cond)
[13:20:33.164]                 })
[13:20:33.164]             }))
[13:20:33.164]             future::FutureResult(value = ...future.value$value, 
[13:20:33.164]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:33.164]                   ...future.rng), globalenv = if (FALSE) 
[13:20:33.164]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:33.164]                     ...future.globalenv.names))
[13:20:33.164]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:33.164]         }, condition = base::local({
[13:20:33.164]             c <- base::c
[13:20:33.164]             inherits <- base::inherits
[13:20:33.164]             invokeRestart <- base::invokeRestart
[13:20:33.164]             length <- base::length
[13:20:33.164]             list <- base::list
[13:20:33.164]             seq.int <- base::seq.int
[13:20:33.164]             signalCondition <- base::signalCondition
[13:20:33.164]             sys.calls <- base::sys.calls
[13:20:33.164]             `[[` <- base::`[[`
[13:20:33.164]             `+` <- base::`+`
[13:20:33.164]             `<<-` <- base::`<<-`
[13:20:33.164]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:33.164]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:33.164]                   3L)]
[13:20:33.164]             }
[13:20:33.164]             function(cond) {
[13:20:33.164]                 is_error <- inherits(cond, "error")
[13:20:33.164]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:33.164]                   NULL)
[13:20:33.164]                 if (is_error) {
[13:20:33.164]                   sessionInformation <- function() {
[13:20:33.164]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:33.164]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:33.164]                       search = base::search(), system = base::Sys.info())
[13:20:33.164]                   }
[13:20:33.164]                   ...future.conditions[[length(...future.conditions) + 
[13:20:33.164]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:33.164]                     cond$call), session = sessionInformation(), 
[13:20:33.164]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:33.164]                   signalCondition(cond)
[13:20:33.164]                 }
[13:20:33.164]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:33.164]                 "immediateCondition"))) {
[13:20:33.164]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:33.164]                   ...future.conditions[[length(...future.conditions) + 
[13:20:33.164]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:33.164]                   if (TRUE && !signal) {
[13:20:33.164]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:33.164]                     {
[13:20:33.164]                       inherits <- base::inherits
[13:20:33.164]                       invokeRestart <- base::invokeRestart
[13:20:33.164]                       is.null <- base::is.null
[13:20:33.164]                       muffled <- FALSE
[13:20:33.164]                       if (inherits(cond, "message")) {
[13:20:33.164]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:33.164]                         if (muffled) 
[13:20:33.164]                           invokeRestart("muffleMessage")
[13:20:33.164]                       }
[13:20:33.164]                       else if (inherits(cond, "warning")) {
[13:20:33.164]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:33.164]                         if (muffled) 
[13:20:33.164]                           invokeRestart("muffleWarning")
[13:20:33.164]                       }
[13:20:33.164]                       else if (inherits(cond, "condition")) {
[13:20:33.164]                         if (!is.null(pattern)) {
[13:20:33.164]                           computeRestarts <- base::computeRestarts
[13:20:33.164]                           grepl <- base::grepl
[13:20:33.164]                           restarts <- computeRestarts(cond)
[13:20:33.164]                           for (restart in restarts) {
[13:20:33.164]                             name <- restart$name
[13:20:33.164]                             if (is.null(name)) 
[13:20:33.164]                               next
[13:20:33.164]                             if (!grepl(pattern, name)) 
[13:20:33.164]                               next
[13:20:33.164]                             invokeRestart(restart)
[13:20:33.164]                             muffled <- TRUE
[13:20:33.164]                             break
[13:20:33.164]                           }
[13:20:33.164]                         }
[13:20:33.164]                       }
[13:20:33.164]                       invisible(muffled)
[13:20:33.164]                     }
[13:20:33.164]                     muffleCondition(cond, pattern = "^muffle")
[13:20:33.164]                   }
[13:20:33.164]                 }
[13:20:33.164]                 else {
[13:20:33.164]                   if (TRUE) {
[13:20:33.164]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:33.164]                     {
[13:20:33.164]                       inherits <- base::inherits
[13:20:33.164]                       invokeRestart <- base::invokeRestart
[13:20:33.164]                       is.null <- base::is.null
[13:20:33.164]                       muffled <- FALSE
[13:20:33.164]                       if (inherits(cond, "message")) {
[13:20:33.164]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:33.164]                         if (muffled) 
[13:20:33.164]                           invokeRestart("muffleMessage")
[13:20:33.164]                       }
[13:20:33.164]                       else if (inherits(cond, "warning")) {
[13:20:33.164]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:33.164]                         if (muffled) 
[13:20:33.164]                           invokeRestart("muffleWarning")
[13:20:33.164]                       }
[13:20:33.164]                       else if (inherits(cond, "condition")) {
[13:20:33.164]                         if (!is.null(pattern)) {
[13:20:33.164]                           computeRestarts <- base::computeRestarts
[13:20:33.164]                           grepl <- base::grepl
[13:20:33.164]                           restarts <- computeRestarts(cond)
[13:20:33.164]                           for (restart in restarts) {
[13:20:33.164]                             name <- restart$name
[13:20:33.164]                             if (is.null(name)) 
[13:20:33.164]                               next
[13:20:33.164]                             if (!grepl(pattern, name)) 
[13:20:33.164]                               next
[13:20:33.164]                             invokeRestart(restart)
[13:20:33.164]                             muffled <- TRUE
[13:20:33.164]                             break
[13:20:33.164]                           }
[13:20:33.164]                         }
[13:20:33.164]                       }
[13:20:33.164]                       invisible(muffled)
[13:20:33.164]                     }
[13:20:33.164]                     muffleCondition(cond, pattern = "^muffle")
[13:20:33.164]                   }
[13:20:33.164]                 }
[13:20:33.164]             }
[13:20:33.164]         }))
[13:20:33.164]     }, error = function(ex) {
[13:20:33.164]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:33.164]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:33.164]                 ...future.rng), started = ...future.startTime, 
[13:20:33.164]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:33.164]             version = "1.8"), class = "FutureResult")
[13:20:33.164]     }, finally = {
[13:20:33.164]         if (!identical(...future.workdir, getwd())) 
[13:20:33.164]             setwd(...future.workdir)
[13:20:33.164]         {
[13:20:33.164]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:33.164]                 ...future.oldOptions$nwarnings <- NULL
[13:20:33.164]             }
[13:20:33.164]             base::options(...future.oldOptions)
[13:20:33.164]             if (.Platform$OS.type == "windows") {
[13:20:33.164]                 old_names <- names(...future.oldEnvVars)
[13:20:33.164]                 envs <- base::Sys.getenv()
[13:20:33.164]                 names <- names(envs)
[13:20:33.164]                 common <- intersect(names, old_names)
[13:20:33.164]                 added <- setdiff(names, old_names)
[13:20:33.164]                 removed <- setdiff(old_names, names)
[13:20:33.164]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:33.164]                   envs[common]]
[13:20:33.164]                 NAMES <- toupper(changed)
[13:20:33.164]                 args <- list()
[13:20:33.164]                 for (kk in seq_along(NAMES)) {
[13:20:33.164]                   name <- changed[[kk]]
[13:20:33.164]                   NAME <- NAMES[[kk]]
[13:20:33.164]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:33.164]                     next
[13:20:33.164]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:33.164]                 }
[13:20:33.164]                 NAMES <- toupper(added)
[13:20:33.164]                 for (kk in seq_along(NAMES)) {
[13:20:33.164]                   name <- added[[kk]]
[13:20:33.164]                   NAME <- NAMES[[kk]]
[13:20:33.164]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:33.164]                     next
[13:20:33.164]                   args[[name]] <- ""
[13:20:33.164]                 }
[13:20:33.164]                 NAMES <- toupper(removed)
[13:20:33.164]                 for (kk in seq_along(NAMES)) {
[13:20:33.164]                   name <- removed[[kk]]
[13:20:33.164]                   NAME <- NAMES[[kk]]
[13:20:33.164]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:33.164]                     next
[13:20:33.164]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:33.164]                 }
[13:20:33.164]                 if (length(args) > 0) 
[13:20:33.164]                   base::do.call(base::Sys.setenv, args = args)
[13:20:33.164]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:33.164]             }
[13:20:33.164]             else {
[13:20:33.164]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:33.164]             }
[13:20:33.164]             {
[13:20:33.164]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:33.164]                   0L) {
[13:20:33.164]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:33.164]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:33.164]                   base::options(opts)
[13:20:33.164]                 }
[13:20:33.164]                 {
[13:20:33.164]                   {
[13:20:33.164]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:33.164]                     NULL
[13:20:33.164]                   }
[13:20:33.164]                   options(future.plan = NULL)
[13:20:33.164]                   if (is.na(NA_character_)) 
[13:20:33.164]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:33.164]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:33.164]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:33.164]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:33.164]                     envir = parent.frame()) 
[13:20:33.164]                   {
[13:20:33.164]                     if (is.function(workers)) 
[13:20:33.164]                       workers <- workers()
[13:20:33.164]                     workers <- structure(as.integer(workers), 
[13:20:33.164]                       class = class(workers))
[13:20:33.164]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:33.164]                       workers >= 1)
[13:20:33.164]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:33.164]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:33.164]                     }
[13:20:33.164]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:33.164]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:33.164]                       envir = envir)
[13:20:33.164]                     if (!future$lazy) 
[13:20:33.164]                       future <- run(future)
[13:20:33.164]                     invisible(future)
[13:20:33.164]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:33.164]                 }
[13:20:33.164]             }
[13:20:33.164]         }
[13:20:33.164]     })
[13:20:33.164]     if (TRUE) {
[13:20:33.164]         base::sink(type = "output", split = FALSE)
[13:20:33.164]         if (TRUE) {
[13:20:33.164]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:33.164]         }
[13:20:33.164]         else {
[13:20:33.164]             ...future.result["stdout"] <- base::list(NULL)
[13:20:33.164]         }
[13:20:33.164]         base::close(...future.stdout)
[13:20:33.164]         ...future.stdout <- NULL
[13:20:33.164]     }
[13:20:33.164]     ...future.result$conditions <- ...future.conditions
[13:20:33.164]     ...future.result$finished <- base::Sys.time()
[13:20:33.164]     ...future.result
[13:20:33.164] }
[13:20:33.167] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[13:20:33.167] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[13:20:33.168] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[13:20:33.168] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[13:20:33.168] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[13:20:33.169] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[13:20:33.169] MultisessionFuture started
[13:20:33.170] - Launch lazy future ... done
[13:20:33.170] run() for ‘MultisessionFuture’ ... done
[13:20:33.170] result() for ClusterFuture ...
[13:20:33.170] receiveMessageFromWorker() for ClusterFuture ...
[13:20:33.170] - Validating connection of MultisessionFuture
[13:20:33.222] - received message: FutureResult
[13:20:33.222] - Received FutureResult
[13:20:33.222] - Erased future from FutureRegistry
[13:20:33.222] result() for ClusterFuture ...
[13:20:33.222] - result already collected: FutureResult
[13:20:33.222] result() for ClusterFuture ... done
[13:20:33.222] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:33.223] result() for ClusterFuture ... done
[13:20:33.223] result() for ClusterFuture ...
[13:20:33.223] - result already collected: FutureResult
[13:20:33.223] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[13:20:33.225] getGlobalsAndPackages() ...
[13:20:33.225] Searching for globals...
[13:20:33.227] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:20:33.227] Searching for globals ... DONE
[13:20:33.227] Resolving globals: FALSE
[13:20:33.228] The total size of the 2 globals is 896 bytes (896 bytes)
[13:20:33.229] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:20:33.229] - globals: [2] ‘weight’, ‘group’
[13:20:33.229] - packages: [1] ‘stats’
[13:20:33.229] getGlobalsAndPackages() ... DONE
[13:20:33.229] run() for ‘Future’ ...
[13:20:33.229] - state: ‘created’
[13:20:33.230] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:33.245] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:33.245] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:33.245]   - Field: ‘node’
[13:20:33.245]   - Field: ‘label’
[13:20:33.245]   - Field: ‘local’
[13:20:33.245]   - Field: ‘owner’
[13:20:33.245]   - Field: ‘envir’
[13:20:33.246]   - Field: ‘workers’
[13:20:33.246]   - Field: ‘packages’
[13:20:33.246]   - Field: ‘gc’
[13:20:33.246]   - Field: ‘conditions’
[13:20:33.246]   - Field: ‘persistent’
[13:20:33.246]   - Field: ‘expr’
[13:20:33.246]   - Field: ‘uuid’
[13:20:33.246]   - Field: ‘seed’
[13:20:33.246]   - Field: ‘version’
[13:20:33.247]   - Field: ‘result’
[13:20:33.247]   - Field: ‘asynchronous’
[13:20:33.247]   - Field: ‘calls’
[13:20:33.247]   - Field: ‘globals’
[13:20:33.247]   - Field: ‘stdout’
[13:20:33.247]   - Field: ‘earlySignal’
[13:20:33.247]   - Field: ‘lazy’
[13:20:33.247]   - Field: ‘state’
[13:20:33.247] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:33.248] - Launch lazy future ...
[13:20:33.248] Packages needed by the future expression (n = 1): ‘stats’
[13:20:33.248] Packages needed by future strategies (n = 0): <none>
[13:20:33.249] {
[13:20:33.249]     {
[13:20:33.249]         {
[13:20:33.249]             ...future.startTime <- base::Sys.time()
[13:20:33.249]             {
[13:20:33.249]                 {
[13:20:33.249]                   {
[13:20:33.249]                     {
[13:20:33.249]                       {
[13:20:33.249]                         base::local({
[13:20:33.249]                           has_future <- base::requireNamespace("future", 
[13:20:33.249]                             quietly = TRUE)
[13:20:33.249]                           if (has_future) {
[13:20:33.249]                             ns <- base::getNamespace("future")
[13:20:33.249]                             version <- ns[[".package"]][["version"]]
[13:20:33.249]                             if (is.null(version)) 
[13:20:33.249]                               version <- utils::packageVersion("future")
[13:20:33.249]                           }
[13:20:33.249]                           else {
[13:20:33.249]                             version <- NULL
[13:20:33.249]                           }
[13:20:33.249]                           if (!has_future || version < "1.8.0") {
[13:20:33.249]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:33.249]                               "", base::R.version$version.string), 
[13:20:33.249]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:33.249]                                 base::R.version$platform, 8 * 
[13:20:33.249]                                   base::.Machine$sizeof.pointer), 
[13:20:33.249]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:33.249]                                 "release", "version")], collapse = " "), 
[13:20:33.249]                               hostname = base::Sys.info()[["nodename"]])
[13:20:33.249]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:33.249]                               info)
[13:20:33.249]                             info <- base::paste(info, collapse = "; ")
[13:20:33.249]                             if (!has_future) {
[13:20:33.249]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:33.249]                                 info)
[13:20:33.249]                             }
[13:20:33.249]                             else {
[13:20:33.249]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:33.249]                                 info, version)
[13:20:33.249]                             }
[13:20:33.249]                             base::stop(msg)
[13:20:33.249]                           }
[13:20:33.249]                         })
[13:20:33.249]                       }
[13:20:33.249]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:33.249]                       base::options(mc.cores = 1L)
[13:20:33.249]                     }
[13:20:33.249]                     base::local({
[13:20:33.249]                       for (pkg in "stats") {
[13:20:33.249]                         base::loadNamespace(pkg)
[13:20:33.249]                         base::library(pkg, character.only = TRUE)
[13:20:33.249]                       }
[13:20:33.249]                     })
[13:20:33.249]                   }
[13:20:33.249]                   options(future.plan = NULL)
[13:20:33.249]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:33.249]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:33.249]                 }
[13:20:33.249]                 ...future.workdir <- getwd()
[13:20:33.249]             }
[13:20:33.249]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:33.249]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:33.249]         }
[13:20:33.249]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:33.249]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:33.249]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:33.249]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:33.249]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:33.249]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:33.249]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:33.249]             base::names(...future.oldOptions))
[13:20:33.249]     }
[13:20:33.249]     if (FALSE) {
[13:20:33.249]     }
[13:20:33.249]     else {
[13:20:33.249]         if (TRUE) {
[13:20:33.249]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:33.249]                 open = "w")
[13:20:33.249]         }
[13:20:33.249]         else {
[13:20:33.249]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:33.249]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:33.249]         }
[13:20:33.249]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:33.249]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:33.249]             base::sink(type = "output", split = FALSE)
[13:20:33.249]             base::close(...future.stdout)
[13:20:33.249]         }, add = TRUE)
[13:20:33.249]     }
[13:20:33.249]     ...future.frame <- base::sys.nframe()
[13:20:33.249]     ...future.conditions <- base::list()
[13:20:33.249]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:33.249]     if (FALSE) {
[13:20:33.249]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:33.249]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:33.249]     }
[13:20:33.249]     ...future.result <- base::tryCatch({
[13:20:33.249]         base::withCallingHandlers({
[13:20:33.249]             ...future.value <- base::withVisible(base::local({
[13:20:33.249]                 ...future.makeSendCondition <- local({
[13:20:33.249]                   sendCondition <- NULL
[13:20:33.249]                   function(frame = 1L) {
[13:20:33.249]                     if (is.function(sendCondition)) 
[13:20:33.249]                       return(sendCondition)
[13:20:33.249]                     ns <- getNamespace("parallel")
[13:20:33.249]                     if (exists("sendData", mode = "function", 
[13:20:33.249]                       envir = ns)) {
[13:20:33.249]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:33.249]                         envir = ns)
[13:20:33.249]                       envir <- sys.frame(frame)
[13:20:33.249]                       master <- NULL
[13:20:33.249]                       while (!identical(envir, .GlobalEnv) && 
[13:20:33.249]                         !identical(envir, emptyenv())) {
[13:20:33.249]                         if (exists("master", mode = "list", envir = envir, 
[13:20:33.249]                           inherits = FALSE)) {
[13:20:33.249]                           master <- get("master", mode = "list", 
[13:20:33.249]                             envir = envir, inherits = FALSE)
[13:20:33.249]                           if (inherits(master, c("SOCKnode", 
[13:20:33.249]                             "SOCK0node"))) {
[13:20:33.249]                             sendCondition <<- function(cond) {
[13:20:33.249]                               data <- list(type = "VALUE", value = cond, 
[13:20:33.249]                                 success = TRUE)
[13:20:33.249]                               parallel_sendData(master, data)
[13:20:33.249]                             }
[13:20:33.249]                             return(sendCondition)
[13:20:33.249]                           }
[13:20:33.249]                         }
[13:20:33.249]                         frame <- frame + 1L
[13:20:33.249]                         envir <- sys.frame(frame)
[13:20:33.249]                       }
[13:20:33.249]                     }
[13:20:33.249]                     sendCondition <<- function(cond) NULL
[13:20:33.249]                   }
[13:20:33.249]                 })
[13:20:33.249]                 withCallingHandlers({
[13:20:33.249]                   {
[13:20:33.249]                     lm(weight ~ group - 1)
[13:20:33.249]                   }
[13:20:33.249]                 }, immediateCondition = function(cond) {
[13:20:33.249]                   sendCondition <- ...future.makeSendCondition()
[13:20:33.249]                   sendCondition(cond)
[13:20:33.249]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:33.249]                   {
[13:20:33.249]                     inherits <- base::inherits
[13:20:33.249]                     invokeRestart <- base::invokeRestart
[13:20:33.249]                     is.null <- base::is.null
[13:20:33.249]                     muffled <- FALSE
[13:20:33.249]                     if (inherits(cond, "message")) {
[13:20:33.249]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:33.249]                       if (muffled) 
[13:20:33.249]                         invokeRestart("muffleMessage")
[13:20:33.249]                     }
[13:20:33.249]                     else if (inherits(cond, "warning")) {
[13:20:33.249]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:33.249]                       if (muffled) 
[13:20:33.249]                         invokeRestart("muffleWarning")
[13:20:33.249]                     }
[13:20:33.249]                     else if (inherits(cond, "condition")) {
[13:20:33.249]                       if (!is.null(pattern)) {
[13:20:33.249]                         computeRestarts <- base::computeRestarts
[13:20:33.249]                         grepl <- base::grepl
[13:20:33.249]                         restarts <- computeRestarts(cond)
[13:20:33.249]                         for (restart in restarts) {
[13:20:33.249]                           name <- restart$name
[13:20:33.249]                           if (is.null(name)) 
[13:20:33.249]                             next
[13:20:33.249]                           if (!grepl(pattern, name)) 
[13:20:33.249]                             next
[13:20:33.249]                           invokeRestart(restart)
[13:20:33.249]                           muffled <- TRUE
[13:20:33.249]                           break
[13:20:33.249]                         }
[13:20:33.249]                       }
[13:20:33.249]                     }
[13:20:33.249]                     invisible(muffled)
[13:20:33.249]                   }
[13:20:33.249]                   muffleCondition(cond)
[13:20:33.249]                 })
[13:20:33.249]             }))
[13:20:33.249]             future::FutureResult(value = ...future.value$value, 
[13:20:33.249]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:33.249]                   ...future.rng), globalenv = if (FALSE) 
[13:20:33.249]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:33.249]                     ...future.globalenv.names))
[13:20:33.249]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:33.249]         }, condition = base::local({
[13:20:33.249]             c <- base::c
[13:20:33.249]             inherits <- base::inherits
[13:20:33.249]             invokeRestart <- base::invokeRestart
[13:20:33.249]             length <- base::length
[13:20:33.249]             list <- base::list
[13:20:33.249]             seq.int <- base::seq.int
[13:20:33.249]             signalCondition <- base::signalCondition
[13:20:33.249]             sys.calls <- base::sys.calls
[13:20:33.249]             `[[` <- base::`[[`
[13:20:33.249]             `+` <- base::`+`
[13:20:33.249]             `<<-` <- base::`<<-`
[13:20:33.249]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:33.249]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:33.249]                   3L)]
[13:20:33.249]             }
[13:20:33.249]             function(cond) {
[13:20:33.249]                 is_error <- inherits(cond, "error")
[13:20:33.249]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:33.249]                   NULL)
[13:20:33.249]                 if (is_error) {
[13:20:33.249]                   sessionInformation <- function() {
[13:20:33.249]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:33.249]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:33.249]                       search = base::search(), system = base::Sys.info())
[13:20:33.249]                   }
[13:20:33.249]                   ...future.conditions[[length(...future.conditions) + 
[13:20:33.249]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:33.249]                     cond$call), session = sessionInformation(), 
[13:20:33.249]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:33.249]                   signalCondition(cond)
[13:20:33.249]                 }
[13:20:33.249]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:33.249]                 "immediateCondition"))) {
[13:20:33.249]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:33.249]                   ...future.conditions[[length(...future.conditions) + 
[13:20:33.249]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:33.249]                   if (TRUE && !signal) {
[13:20:33.249]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:33.249]                     {
[13:20:33.249]                       inherits <- base::inherits
[13:20:33.249]                       invokeRestart <- base::invokeRestart
[13:20:33.249]                       is.null <- base::is.null
[13:20:33.249]                       muffled <- FALSE
[13:20:33.249]                       if (inherits(cond, "message")) {
[13:20:33.249]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:33.249]                         if (muffled) 
[13:20:33.249]                           invokeRestart("muffleMessage")
[13:20:33.249]                       }
[13:20:33.249]                       else if (inherits(cond, "warning")) {
[13:20:33.249]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:33.249]                         if (muffled) 
[13:20:33.249]                           invokeRestart("muffleWarning")
[13:20:33.249]                       }
[13:20:33.249]                       else if (inherits(cond, "condition")) {
[13:20:33.249]                         if (!is.null(pattern)) {
[13:20:33.249]                           computeRestarts <- base::computeRestarts
[13:20:33.249]                           grepl <- base::grepl
[13:20:33.249]                           restarts <- computeRestarts(cond)
[13:20:33.249]                           for (restart in restarts) {
[13:20:33.249]                             name <- restart$name
[13:20:33.249]                             if (is.null(name)) 
[13:20:33.249]                               next
[13:20:33.249]                             if (!grepl(pattern, name)) 
[13:20:33.249]                               next
[13:20:33.249]                             invokeRestart(restart)
[13:20:33.249]                             muffled <- TRUE
[13:20:33.249]                             break
[13:20:33.249]                           }
[13:20:33.249]                         }
[13:20:33.249]                       }
[13:20:33.249]                       invisible(muffled)
[13:20:33.249]                     }
[13:20:33.249]                     muffleCondition(cond, pattern = "^muffle")
[13:20:33.249]                   }
[13:20:33.249]                 }
[13:20:33.249]                 else {
[13:20:33.249]                   if (TRUE) {
[13:20:33.249]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:33.249]                     {
[13:20:33.249]                       inherits <- base::inherits
[13:20:33.249]                       invokeRestart <- base::invokeRestart
[13:20:33.249]                       is.null <- base::is.null
[13:20:33.249]                       muffled <- FALSE
[13:20:33.249]                       if (inherits(cond, "message")) {
[13:20:33.249]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:33.249]                         if (muffled) 
[13:20:33.249]                           invokeRestart("muffleMessage")
[13:20:33.249]                       }
[13:20:33.249]                       else if (inherits(cond, "warning")) {
[13:20:33.249]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:33.249]                         if (muffled) 
[13:20:33.249]                           invokeRestart("muffleWarning")
[13:20:33.249]                       }
[13:20:33.249]                       else if (inherits(cond, "condition")) {
[13:20:33.249]                         if (!is.null(pattern)) {
[13:20:33.249]                           computeRestarts <- base::computeRestarts
[13:20:33.249]                           grepl <- base::grepl
[13:20:33.249]                           restarts <- computeRestarts(cond)
[13:20:33.249]                           for (restart in restarts) {
[13:20:33.249]                             name <- restart$name
[13:20:33.249]                             if (is.null(name)) 
[13:20:33.249]                               next
[13:20:33.249]                             if (!grepl(pattern, name)) 
[13:20:33.249]                               next
[13:20:33.249]                             invokeRestart(restart)
[13:20:33.249]                             muffled <- TRUE
[13:20:33.249]                             break
[13:20:33.249]                           }
[13:20:33.249]                         }
[13:20:33.249]                       }
[13:20:33.249]                       invisible(muffled)
[13:20:33.249]                     }
[13:20:33.249]                     muffleCondition(cond, pattern = "^muffle")
[13:20:33.249]                   }
[13:20:33.249]                 }
[13:20:33.249]             }
[13:20:33.249]         }))
[13:20:33.249]     }, error = function(ex) {
[13:20:33.249]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:33.249]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:33.249]                 ...future.rng), started = ...future.startTime, 
[13:20:33.249]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:33.249]             version = "1.8"), class = "FutureResult")
[13:20:33.249]     }, finally = {
[13:20:33.249]         if (!identical(...future.workdir, getwd())) 
[13:20:33.249]             setwd(...future.workdir)
[13:20:33.249]         {
[13:20:33.249]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:33.249]                 ...future.oldOptions$nwarnings <- NULL
[13:20:33.249]             }
[13:20:33.249]             base::options(...future.oldOptions)
[13:20:33.249]             if (.Platform$OS.type == "windows") {
[13:20:33.249]                 old_names <- names(...future.oldEnvVars)
[13:20:33.249]                 envs <- base::Sys.getenv()
[13:20:33.249]                 names <- names(envs)
[13:20:33.249]                 common <- intersect(names, old_names)
[13:20:33.249]                 added <- setdiff(names, old_names)
[13:20:33.249]                 removed <- setdiff(old_names, names)
[13:20:33.249]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:33.249]                   envs[common]]
[13:20:33.249]                 NAMES <- toupper(changed)
[13:20:33.249]                 args <- list()
[13:20:33.249]                 for (kk in seq_along(NAMES)) {
[13:20:33.249]                   name <- changed[[kk]]
[13:20:33.249]                   NAME <- NAMES[[kk]]
[13:20:33.249]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:33.249]                     next
[13:20:33.249]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:33.249]                 }
[13:20:33.249]                 NAMES <- toupper(added)
[13:20:33.249]                 for (kk in seq_along(NAMES)) {
[13:20:33.249]                   name <- added[[kk]]
[13:20:33.249]                   NAME <- NAMES[[kk]]
[13:20:33.249]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:33.249]                     next
[13:20:33.249]                   args[[name]] <- ""
[13:20:33.249]                 }
[13:20:33.249]                 NAMES <- toupper(removed)
[13:20:33.249]                 for (kk in seq_along(NAMES)) {
[13:20:33.249]                   name <- removed[[kk]]
[13:20:33.249]                   NAME <- NAMES[[kk]]
[13:20:33.249]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:33.249]                     next
[13:20:33.249]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:33.249]                 }
[13:20:33.249]                 if (length(args) > 0) 
[13:20:33.249]                   base::do.call(base::Sys.setenv, args = args)
[13:20:33.249]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:33.249]             }
[13:20:33.249]             else {
[13:20:33.249]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:33.249]             }
[13:20:33.249]             {
[13:20:33.249]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:33.249]                   0L) {
[13:20:33.249]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:33.249]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:33.249]                   base::options(opts)
[13:20:33.249]                 }
[13:20:33.249]                 {
[13:20:33.249]                   {
[13:20:33.249]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:33.249]                     NULL
[13:20:33.249]                   }
[13:20:33.249]                   options(future.plan = NULL)
[13:20:33.249]                   if (is.na(NA_character_)) 
[13:20:33.249]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:33.249]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:33.249]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:33.249]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:33.249]                     envir = parent.frame()) 
[13:20:33.249]                   {
[13:20:33.249]                     if (is.function(workers)) 
[13:20:33.249]                       workers <- workers()
[13:20:33.249]                     workers <- structure(as.integer(workers), 
[13:20:33.249]                       class = class(workers))
[13:20:33.249]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:33.249]                       workers >= 1)
[13:20:33.249]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:33.249]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:33.249]                     }
[13:20:33.249]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:33.249]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:33.249]                       envir = envir)
[13:20:33.249]                     if (!future$lazy) 
[13:20:33.249]                       future <- run(future)
[13:20:33.249]                     invisible(future)
[13:20:33.249]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:33.249]                 }
[13:20:33.249]             }
[13:20:33.249]         }
[13:20:33.249]     })
[13:20:33.249]     if (TRUE) {
[13:20:33.249]         base::sink(type = "output", split = FALSE)
[13:20:33.249]         if (TRUE) {
[13:20:33.249]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:33.249]         }
[13:20:33.249]         else {
[13:20:33.249]             ...future.result["stdout"] <- base::list(NULL)
[13:20:33.249]         }
[13:20:33.249]         base::close(...future.stdout)
[13:20:33.249]         ...future.stdout <- NULL
[13:20:33.249]     }
[13:20:33.249]     ...future.result$conditions <- ...future.conditions
[13:20:33.249]     ...future.result$finished <- base::Sys.time()
[13:20:33.249]     ...future.result
[13:20:33.249] }
[13:20:33.252] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[13:20:33.252] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[13:20:33.253] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[13:20:33.253] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[13:20:33.253] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[13:20:33.253] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[13:20:33.254] MultisessionFuture started
[13:20:33.254] - Launch lazy future ... done
[13:20:33.254] run() for ‘MultisessionFuture’ ... done
[13:20:33.254] result() for ClusterFuture ...
[13:20:33.255] receiveMessageFromWorker() for ClusterFuture ...
[13:20:33.255] - Validating connection of MultisessionFuture
[13:20:33.303] - received message: FutureResult
[13:20:33.303] - Received FutureResult
[13:20:33.303] - Erased future from FutureRegistry
[13:20:33.303] result() for ClusterFuture ...
[13:20:33.304] - result already collected: FutureResult
[13:20:33.304] result() for ClusterFuture ... done
[13:20:33.304] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:33.304] result() for ClusterFuture ... done
[13:20:33.304] result() for ClusterFuture ...
[13:20:33.304] - result already collected: FutureResult
[13:20:33.304] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[13:20:33.307] getGlobalsAndPackages() ...
[13:20:33.307] Searching for globals...
[13:20:33.309] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:20:33.309] Searching for globals ... DONE
[13:20:33.309] Resolving globals: FALSE
[13:20:33.310] The total size of the 2 globals is 896 bytes (896 bytes)
[13:20:33.310] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:20:33.310] - globals: [2] ‘weight’, ‘group’
[13:20:33.310] - packages: [1] ‘stats’
[13:20:33.311] getGlobalsAndPackages() ... DONE
[13:20:33.311] run() for ‘Future’ ...
[13:20:33.311] - state: ‘created’
[13:20:33.311] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:33.326] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:33.326] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:33.327]   - Field: ‘node’
[13:20:33.327]   - Field: ‘label’
[13:20:33.327]   - Field: ‘local’
[13:20:33.327]   - Field: ‘owner’
[13:20:33.327]   - Field: ‘envir’
[13:20:33.327]   - Field: ‘workers’
[13:20:33.327]   - Field: ‘packages’
[13:20:33.327]   - Field: ‘gc’
[13:20:33.327]   - Field: ‘conditions’
[13:20:33.328]   - Field: ‘persistent’
[13:20:33.328]   - Field: ‘expr’
[13:20:33.328]   - Field: ‘uuid’
[13:20:33.328]   - Field: ‘seed’
[13:20:33.328]   - Field: ‘version’
[13:20:33.328]   - Field: ‘result’
[13:20:33.328]   - Field: ‘asynchronous’
[13:20:33.328]   - Field: ‘calls’
[13:20:33.328]   - Field: ‘globals’
[13:20:33.329]   - Field: ‘stdout’
[13:20:33.329]   - Field: ‘earlySignal’
[13:20:33.329]   - Field: ‘lazy’
[13:20:33.329]   - Field: ‘state’
[13:20:33.329] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:33.329] - Launch lazy future ...
[13:20:33.330] Packages needed by the future expression (n = 1): ‘stats’
[13:20:33.330] Packages needed by future strategies (n = 0): <none>
[13:20:33.330] {
[13:20:33.330]     {
[13:20:33.330]         {
[13:20:33.330]             ...future.startTime <- base::Sys.time()
[13:20:33.330]             {
[13:20:33.330]                 {
[13:20:33.330]                   {
[13:20:33.330]                     {
[13:20:33.330]                       {
[13:20:33.330]                         base::local({
[13:20:33.330]                           has_future <- base::requireNamespace("future", 
[13:20:33.330]                             quietly = TRUE)
[13:20:33.330]                           if (has_future) {
[13:20:33.330]                             ns <- base::getNamespace("future")
[13:20:33.330]                             version <- ns[[".package"]][["version"]]
[13:20:33.330]                             if (is.null(version)) 
[13:20:33.330]                               version <- utils::packageVersion("future")
[13:20:33.330]                           }
[13:20:33.330]                           else {
[13:20:33.330]                             version <- NULL
[13:20:33.330]                           }
[13:20:33.330]                           if (!has_future || version < "1.8.0") {
[13:20:33.330]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:33.330]                               "", base::R.version$version.string), 
[13:20:33.330]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:33.330]                                 base::R.version$platform, 8 * 
[13:20:33.330]                                   base::.Machine$sizeof.pointer), 
[13:20:33.330]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:33.330]                                 "release", "version")], collapse = " "), 
[13:20:33.330]                               hostname = base::Sys.info()[["nodename"]])
[13:20:33.330]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:33.330]                               info)
[13:20:33.330]                             info <- base::paste(info, collapse = "; ")
[13:20:33.330]                             if (!has_future) {
[13:20:33.330]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:33.330]                                 info)
[13:20:33.330]                             }
[13:20:33.330]                             else {
[13:20:33.330]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:33.330]                                 info, version)
[13:20:33.330]                             }
[13:20:33.330]                             base::stop(msg)
[13:20:33.330]                           }
[13:20:33.330]                         })
[13:20:33.330]                       }
[13:20:33.330]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:33.330]                       base::options(mc.cores = 1L)
[13:20:33.330]                     }
[13:20:33.330]                     base::local({
[13:20:33.330]                       for (pkg in "stats") {
[13:20:33.330]                         base::loadNamespace(pkg)
[13:20:33.330]                         base::library(pkg, character.only = TRUE)
[13:20:33.330]                       }
[13:20:33.330]                     })
[13:20:33.330]                   }
[13:20:33.330]                   options(future.plan = NULL)
[13:20:33.330]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:33.330]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:33.330]                 }
[13:20:33.330]                 ...future.workdir <- getwd()
[13:20:33.330]             }
[13:20:33.330]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:33.330]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:33.330]         }
[13:20:33.330]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:33.330]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:33.330]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:33.330]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:33.330]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:33.330]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:33.330]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:33.330]             base::names(...future.oldOptions))
[13:20:33.330]     }
[13:20:33.330]     if (FALSE) {
[13:20:33.330]     }
[13:20:33.330]     else {
[13:20:33.330]         if (TRUE) {
[13:20:33.330]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:33.330]                 open = "w")
[13:20:33.330]         }
[13:20:33.330]         else {
[13:20:33.330]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:33.330]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:33.330]         }
[13:20:33.330]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:33.330]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:33.330]             base::sink(type = "output", split = FALSE)
[13:20:33.330]             base::close(...future.stdout)
[13:20:33.330]         }, add = TRUE)
[13:20:33.330]     }
[13:20:33.330]     ...future.frame <- base::sys.nframe()
[13:20:33.330]     ...future.conditions <- base::list()
[13:20:33.330]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:33.330]     if (FALSE) {
[13:20:33.330]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:33.330]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:33.330]     }
[13:20:33.330]     ...future.result <- base::tryCatch({
[13:20:33.330]         base::withCallingHandlers({
[13:20:33.330]             ...future.value <- base::withVisible(base::local({
[13:20:33.330]                 ...future.makeSendCondition <- local({
[13:20:33.330]                   sendCondition <- NULL
[13:20:33.330]                   function(frame = 1L) {
[13:20:33.330]                     if (is.function(sendCondition)) 
[13:20:33.330]                       return(sendCondition)
[13:20:33.330]                     ns <- getNamespace("parallel")
[13:20:33.330]                     if (exists("sendData", mode = "function", 
[13:20:33.330]                       envir = ns)) {
[13:20:33.330]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:33.330]                         envir = ns)
[13:20:33.330]                       envir <- sys.frame(frame)
[13:20:33.330]                       master <- NULL
[13:20:33.330]                       while (!identical(envir, .GlobalEnv) && 
[13:20:33.330]                         !identical(envir, emptyenv())) {
[13:20:33.330]                         if (exists("master", mode = "list", envir = envir, 
[13:20:33.330]                           inherits = FALSE)) {
[13:20:33.330]                           master <- get("master", mode = "list", 
[13:20:33.330]                             envir = envir, inherits = FALSE)
[13:20:33.330]                           if (inherits(master, c("SOCKnode", 
[13:20:33.330]                             "SOCK0node"))) {
[13:20:33.330]                             sendCondition <<- function(cond) {
[13:20:33.330]                               data <- list(type = "VALUE", value = cond, 
[13:20:33.330]                                 success = TRUE)
[13:20:33.330]                               parallel_sendData(master, data)
[13:20:33.330]                             }
[13:20:33.330]                             return(sendCondition)
[13:20:33.330]                           }
[13:20:33.330]                         }
[13:20:33.330]                         frame <- frame + 1L
[13:20:33.330]                         envir <- sys.frame(frame)
[13:20:33.330]                       }
[13:20:33.330]                     }
[13:20:33.330]                     sendCondition <<- function(cond) NULL
[13:20:33.330]                   }
[13:20:33.330]                 })
[13:20:33.330]                 withCallingHandlers({
[13:20:33.330]                   {
[13:20:33.330]                     lm(weight ~ group - 1)
[13:20:33.330]                   }
[13:20:33.330]                 }, immediateCondition = function(cond) {
[13:20:33.330]                   sendCondition <- ...future.makeSendCondition()
[13:20:33.330]                   sendCondition(cond)
[13:20:33.330]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:33.330]                   {
[13:20:33.330]                     inherits <- base::inherits
[13:20:33.330]                     invokeRestart <- base::invokeRestart
[13:20:33.330]                     is.null <- base::is.null
[13:20:33.330]                     muffled <- FALSE
[13:20:33.330]                     if (inherits(cond, "message")) {
[13:20:33.330]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:33.330]                       if (muffled) 
[13:20:33.330]                         invokeRestart("muffleMessage")
[13:20:33.330]                     }
[13:20:33.330]                     else if (inherits(cond, "warning")) {
[13:20:33.330]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:33.330]                       if (muffled) 
[13:20:33.330]                         invokeRestart("muffleWarning")
[13:20:33.330]                     }
[13:20:33.330]                     else if (inherits(cond, "condition")) {
[13:20:33.330]                       if (!is.null(pattern)) {
[13:20:33.330]                         computeRestarts <- base::computeRestarts
[13:20:33.330]                         grepl <- base::grepl
[13:20:33.330]                         restarts <- computeRestarts(cond)
[13:20:33.330]                         for (restart in restarts) {
[13:20:33.330]                           name <- restart$name
[13:20:33.330]                           if (is.null(name)) 
[13:20:33.330]                             next
[13:20:33.330]                           if (!grepl(pattern, name)) 
[13:20:33.330]                             next
[13:20:33.330]                           invokeRestart(restart)
[13:20:33.330]                           muffled <- TRUE
[13:20:33.330]                           break
[13:20:33.330]                         }
[13:20:33.330]                       }
[13:20:33.330]                     }
[13:20:33.330]                     invisible(muffled)
[13:20:33.330]                   }
[13:20:33.330]                   muffleCondition(cond)
[13:20:33.330]                 })
[13:20:33.330]             }))
[13:20:33.330]             future::FutureResult(value = ...future.value$value, 
[13:20:33.330]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:33.330]                   ...future.rng), globalenv = if (FALSE) 
[13:20:33.330]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:33.330]                     ...future.globalenv.names))
[13:20:33.330]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:33.330]         }, condition = base::local({
[13:20:33.330]             c <- base::c
[13:20:33.330]             inherits <- base::inherits
[13:20:33.330]             invokeRestart <- base::invokeRestart
[13:20:33.330]             length <- base::length
[13:20:33.330]             list <- base::list
[13:20:33.330]             seq.int <- base::seq.int
[13:20:33.330]             signalCondition <- base::signalCondition
[13:20:33.330]             sys.calls <- base::sys.calls
[13:20:33.330]             `[[` <- base::`[[`
[13:20:33.330]             `+` <- base::`+`
[13:20:33.330]             `<<-` <- base::`<<-`
[13:20:33.330]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:33.330]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:33.330]                   3L)]
[13:20:33.330]             }
[13:20:33.330]             function(cond) {
[13:20:33.330]                 is_error <- inherits(cond, "error")
[13:20:33.330]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:33.330]                   NULL)
[13:20:33.330]                 if (is_error) {
[13:20:33.330]                   sessionInformation <- function() {
[13:20:33.330]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:33.330]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:33.330]                       search = base::search(), system = base::Sys.info())
[13:20:33.330]                   }
[13:20:33.330]                   ...future.conditions[[length(...future.conditions) + 
[13:20:33.330]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:33.330]                     cond$call), session = sessionInformation(), 
[13:20:33.330]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:33.330]                   signalCondition(cond)
[13:20:33.330]                 }
[13:20:33.330]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:33.330]                 "immediateCondition"))) {
[13:20:33.330]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:33.330]                   ...future.conditions[[length(...future.conditions) + 
[13:20:33.330]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:33.330]                   if (TRUE && !signal) {
[13:20:33.330]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:33.330]                     {
[13:20:33.330]                       inherits <- base::inherits
[13:20:33.330]                       invokeRestart <- base::invokeRestart
[13:20:33.330]                       is.null <- base::is.null
[13:20:33.330]                       muffled <- FALSE
[13:20:33.330]                       if (inherits(cond, "message")) {
[13:20:33.330]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:33.330]                         if (muffled) 
[13:20:33.330]                           invokeRestart("muffleMessage")
[13:20:33.330]                       }
[13:20:33.330]                       else if (inherits(cond, "warning")) {
[13:20:33.330]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:33.330]                         if (muffled) 
[13:20:33.330]                           invokeRestart("muffleWarning")
[13:20:33.330]                       }
[13:20:33.330]                       else if (inherits(cond, "condition")) {
[13:20:33.330]                         if (!is.null(pattern)) {
[13:20:33.330]                           computeRestarts <- base::computeRestarts
[13:20:33.330]                           grepl <- base::grepl
[13:20:33.330]                           restarts <- computeRestarts(cond)
[13:20:33.330]                           for (restart in restarts) {
[13:20:33.330]                             name <- restart$name
[13:20:33.330]                             if (is.null(name)) 
[13:20:33.330]                               next
[13:20:33.330]                             if (!grepl(pattern, name)) 
[13:20:33.330]                               next
[13:20:33.330]                             invokeRestart(restart)
[13:20:33.330]                             muffled <- TRUE
[13:20:33.330]                             break
[13:20:33.330]                           }
[13:20:33.330]                         }
[13:20:33.330]                       }
[13:20:33.330]                       invisible(muffled)
[13:20:33.330]                     }
[13:20:33.330]                     muffleCondition(cond, pattern = "^muffle")
[13:20:33.330]                   }
[13:20:33.330]                 }
[13:20:33.330]                 else {
[13:20:33.330]                   if (TRUE) {
[13:20:33.330]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:33.330]                     {
[13:20:33.330]                       inherits <- base::inherits
[13:20:33.330]                       invokeRestart <- base::invokeRestart
[13:20:33.330]                       is.null <- base::is.null
[13:20:33.330]                       muffled <- FALSE
[13:20:33.330]                       if (inherits(cond, "message")) {
[13:20:33.330]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:33.330]                         if (muffled) 
[13:20:33.330]                           invokeRestart("muffleMessage")
[13:20:33.330]                       }
[13:20:33.330]                       else if (inherits(cond, "warning")) {
[13:20:33.330]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:33.330]                         if (muffled) 
[13:20:33.330]                           invokeRestart("muffleWarning")
[13:20:33.330]                       }
[13:20:33.330]                       else if (inherits(cond, "condition")) {
[13:20:33.330]                         if (!is.null(pattern)) {
[13:20:33.330]                           computeRestarts <- base::computeRestarts
[13:20:33.330]                           grepl <- base::grepl
[13:20:33.330]                           restarts <- computeRestarts(cond)
[13:20:33.330]                           for (restart in restarts) {
[13:20:33.330]                             name <- restart$name
[13:20:33.330]                             if (is.null(name)) 
[13:20:33.330]                               next
[13:20:33.330]                             if (!grepl(pattern, name)) 
[13:20:33.330]                               next
[13:20:33.330]                             invokeRestart(restart)
[13:20:33.330]                             muffled <- TRUE
[13:20:33.330]                             break
[13:20:33.330]                           }
[13:20:33.330]                         }
[13:20:33.330]                       }
[13:20:33.330]                       invisible(muffled)
[13:20:33.330]                     }
[13:20:33.330]                     muffleCondition(cond, pattern = "^muffle")
[13:20:33.330]                   }
[13:20:33.330]                 }
[13:20:33.330]             }
[13:20:33.330]         }))
[13:20:33.330]     }, error = function(ex) {
[13:20:33.330]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:33.330]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:33.330]                 ...future.rng), started = ...future.startTime, 
[13:20:33.330]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:33.330]             version = "1.8"), class = "FutureResult")
[13:20:33.330]     }, finally = {
[13:20:33.330]         if (!identical(...future.workdir, getwd())) 
[13:20:33.330]             setwd(...future.workdir)
[13:20:33.330]         {
[13:20:33.330]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:33.330]                 ...future.oldOptions$nwarnings <- NULL
[13:20:33.330]             }
[13:20:33.330]             base::options(...future.oldOptions)
[13:20:33.330]             if (.Platform$OS.type == "windows") {
[13:20:33.330]                 old_names <- names(...future.oldEnvVars)
[13:20:33.330]                 envs <- base::Sys.getenv()
[13:20:33.330]                 names <- names(envs)
[13:20:33.330]                 common <- intersect(names, old_names)
[13:20:33.330]                 added <- setdiff(names, old_names)
[13:20:33.330]                 removed <- setdiff(old_names, names)
[13:20:33.330]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:33.330]                   envs[common]]
[13:20:33.330]                 NAMES <- toupper(changed)
[13:20:33.330]                 args <- list()
[13:20:33.330]                 for (kk in seq_along(NAMES)) {
[13:20:33.330]                   name <- changed[[kk]]
[13:20:33.330]                   NAME <- NAMES[[kk]]
[13:20:33.330]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:33.330]                     next
[13:20:33.330]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:33.330]                 }
[13:20:33.330]                 NAMES <- toupper(added)
[13:20:33.330]                 for (kk in seq_along(NAMES)) {
[13:20:33.330]                   name <- added[[kk]]
[13:20:33.330]                   NAME <- NAMES[[kk]]
[13:20:33.330]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:33.330]                     next
[13:20:33.330]                   args[[name]] <- ""
[13:20:33.330]                 }
[13:20:33.330]                 NAMES <- toupper(removed)
[13:20:33.330]                 for (kk in seq_along(NAMES)) {
[13:20:33.330]                   name <- removed[[kk]]
[13:20:33.330]                   NAME <- NAMES[[kk]]
[13:20:33.330]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:33.330]                     next
[13:20:33.330]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:33.330]                 }
[13:20:33.330]                 if (length(args) > 0) 
[13:20:33.330]                   base::do.call(base::Sys.setenv, args = args)
[13:20:33.330]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:33.330]             }
[13:20:33.330]             else {
[13:20:33.330]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:33.330]             }
[13:20:33.330]             {
[13:20:33.330]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:33.330]                   0L) {
[13:20:33.330]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:33.330]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:33.330]                   base::options(opts)
[13:20:33.330]                 }
[13:20:33.330]                 {
[13:20:33.330]                   {
[13:20:33.330]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:33.330]                     NULL
[13:20:33.330]                   }
[13:20:33.330]                   options(future.plan = NULL)
[13:20:33.330]                   if (is.na(NA_character_)) 
[13:20:33.330]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:33.330]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:33.330]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:33.330]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:33.330]                     envir = parent.frame()) 
[13:20:33.330]                   {
[13:20:33.330]                     if (is.function(workers)) 
[13:20:33.330]                       workers <- workers()
[13:20:33.330]                     workers <- structure(as.integer(workers), 
[13:20:33.330]                       class = class(workers))
[13:20:33.330]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:33.330]                       workers >= 1)
[13:20:33.330]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:33.330]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:33.330]                     }
[13:20:33.330]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:33.330]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:33.330]                       envir = envir)
[13:20:33.330]                     if (!future$lazy) 
[13:20:33.330]                       future <- run(future)
[13:20:33.330]                     invisible(future)
[13:20:33.330]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:33.330]                 }
[13:20:33.330]             }
[13:20:33.330]         }
[13:20:33.330]     })
[13:20:33.330]     if (TRUE) {
[13:20:33.330]         base::sink(type = "output", split = FALSE)
[13:20:33.330]         if (TRUE) {
[13:20:33.330]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:33.330]         }
[13:20:33.330]         else {
[13:20:33.330]             ...future.result["stdout"] <- base::list(NULL)
[13:20:33.330]         }
[13:20:33.330]         base::close(...future.stdout)
[13:20:33.330]         ...future.stdout <- NULL
[13:20:33.330]     }
[13:20:33.330]     ...future.result$conditions <- ...future.conditions
[13:20:33.330]     ...future.result$finished <- base::Sys.time()
[13:20:33.330]     ...future.result
[13:20:33.330] }
[13:20:33.333] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[13:20:33.334] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[13:20:33.336] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[13:20:33.336] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[13:20:33.337] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[13:20:33.337] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[13:20:33.338] MultisessionFuture started
[13:20:33.338] - Launch lazy future ... done
[13:20:33.338] run() for ‘MultisessionFuture’ ... done
[13:20:33.338] result() for ClusterFuture ...
[13:20:33.338] receiveMessageFromWorker() for ClusterFuture ...
[13:20:33.338] - Validating connection of MultisessionFuture
[13:20:33.387] - received message: FutureResult
[13:20:33.387] - Received FutureResult
[13:20:33.387] - Erased future from FutureRegistry
[13:20:33.387] result() for ClusterFuture ...
[13:20:33.388] - result already collected: FutureResult
[13:20:33.388] result() for ClusterFuture ... done
[13:20:33.388] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:33.388] result() for ClusterFuture ... done
[13:20:33.388] result() for ClusterFuture ...
[13:20:33.388] - result already collected: FutureResult
[13:20:33.388] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[13:20:33.390] getGlobalsAndPackages() ...
[13:20:33.390] Searching for globals...
[13:20:33.392] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:20:33.392] Searching for globals ... DONE
[13:20:33.392] Resolving globals: FALSE
[13:20:33.392] The total size of the 2 globals is 896 bytes (896 bytes)
[13:20:33.393] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:20:33.393] - globals: [2] ‘weight’, ‘group’
[13:20:33.393] - packages: [1] ‘stats’
[13:20:33.393] getGlobalsAndPackages() ... DONE
[13:20:33.394] run() for ‘Future’ ...
[13:20:33.394] - state: ‘created’
[13:20:33.394] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:33.408] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:33.408] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:33.408]   - Field: ‘node’
[13:20:33.408]   - Field: ‘label’
[13:20:33.408]   - Field: ‘local’
[13:20:33.409]   - Field: ‘owner’
[13:20:33.409]   - Field: ‘envir’
[13:20:33.409]   - Field: ‘workers’
[13:20:33.409]   - Field: ‘packages’
[13:20:33.409]   - Field: ‘gc’
[13:20:33.409]   - Field: ‘conditions’
[13:20:33.409]   - Field: ‘persistent’
[13:20:33.409]   - Field: ‘expr’
[13:20:33.409]   - Field: ‘uuid’
[13:20:33.409]   - Field: ‘seed’
[13:20:33.409]   - Field: ‘version’
[13:20:33.410]   - Field: ‘result’
[13:20:33.410]   - Field: ‘asynchronous’
[13:20:33.410]   - Field: ‘calls’
[13:20:33.410]   - Field: ‘globals’
[13:20:33.410]   - Field: ‘stdout’
[13:20:33.410]   - Field: ‘earlySignal’
[13:20:33.410]   - Field: ‘lazy’
[13:20:33.410]   - Field: ‘state’
[13:20:33.410] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:33.410] - Launch lazy future ...
[13:20:33.411] Packages needed by the future expression (n = 1): ‘stats’
[13:20:33.411] Packages needed by future strategies (n = 0): <none>
[13:20:33.411] {
[13:20:33.411]     {
[13:20:33.411]         {
[13:20:33.411]             ...future.startTime <- base::Sys.time()
[13:20:33.411]             {
[13:20:33.411]                 {
[13:20:33.411]                   {
[13:20:33.411]                     {
[13:20:33.411]                       {
[13:20:33.411]                         base::local({
[13:20:33.411]                           has_future <- base::requireNamespace("future", 
[13:20:33.411]                             quietly = TRUE)
[13:20:33.411]                           if (has_future) {
[13:20:33.411]                             ns <- base::getNamespace("future")
[13:20:33.411]                             version <- ns[[".package"]][["version"]]
[13:20:33.411]                             if (is.null(version)) 
[13:20:33.411]                               version <- utils::packageVersion("future")
[13:20:33.411]                           }
[13:20:33.411]                           else {
[13:20:33.411]                             version <- NULL
[13:20:33.411]                           }
[13:20:33.411]                           if (!has_future || version < "1.8.0") {
[13:20:33.411]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:33.411]                               "", base::R.version$version.string), 
[13:20:33.411]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:33.411]                                 base::R.version$platform, 8 * 
[13:20:33.411]                                   base::.Machine$sizeof.pointer), 
[13:20:33.411]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:33.411]                                 "release", "version")], collapse = " "), 
[13:20:33.411]                               hostname = base::Sys.info()[["nodename"]])
[13:20:33.411]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:33.411]                               info)
[13:20:33.411]                             info <- base::paste(info, collapse = "; ")
[13:20:33.411]                             if (!has_future) {
[13:20:33.411]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:33.411]                                 info)
[13:20:33.411]                             }
[13:20:33.411]                             else {
[13:20:33.411]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:33.411]                                 info, version)
[13:20:33.411]                             }
[13:20:33.411]                             base::stop(msg)
[13:20:33.411]                           }
[13:20:33.411]                         })
[13:20:33.411]                       }
[13:20:33.411]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:33.411]                       base::options(mc.cores = 1L)
[13:20:33.411]                     }
[13:20:33.411]                     base::local({
[13:20:33.411]                       for (pkg in "stats") {
[13:20:33.411]                         base::loadNamespace(pkg)
[13:20:33.411]                         base::library(pkg, character.only = TRUE)
[13:20:33.411]                       }
[13:20:33.411]                     })
[13:20:33.411]                   }
[13:20:33.411]                   options(future.plan = NULL)
[13:20:33.411]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:33.411]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:33.411]                 }
[13:20:33.411]                 ...future.workdir <- getwd()
[13:20:33.411]             }
[13:20:33.411]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:33.411]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:33.411]         }
[13:20:33.411]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:33.411]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:33.411]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:33.411]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:33.411]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:33.411]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:33.411]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:33.411]             base::names(...future.oldOptions))
[13:20:33.411]     }
[13:20:33.411]     if (FALSE) {
[13:20:33.411]     }
[13:20:33.411]     else {
[13:20:33.411]         if (TRUE) {
[13:20:33.411]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:33.411]                 open = "w")
[13:20:33.411]         }
[13:20:33.411]         else {
[13:20:33.411]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:33.411]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:33.411]         }
[13:20:33.411]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:33.411]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:33.411]             base::sink(type = "output", split = FALSE)
[13:20:33.411]             base::close(...future.stdout)
[13:20:33.411]         }, add = TRUE)
[13:20:33.411]     }
[13:20:33.411]     ...future.frame <- base::sys.nframe()
[13:20:33.411]     ...future.conditions <- base::list()
[13:20:33.411]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:33.411]     if (FALSE) {
[13:20:33.411]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:33.411]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:33.411]     }
[13:20:33.411]     ...future.result <- base::tryCatch({
[13:20:33.411]         base::withCallingHandlers({
[13:20:33.411]             ...future.value <- base::withVisible(base::local({
[13:20:33.411]                 ...future.makeSendCondition <- local({
[13:20:33.411]                   sendCondition <- NULL
[13:20:33.411]                   function(frame = 1L) {
[13:20:33.411]                     if (is.function(sendCondition)) 
[13:20:33.411]                       return(sendCondition)
[13:20:33.411]                     ns <- getNamespace("parallel")
[13:20:33.411]                     if (exists("sendData", mode = "function", 
[13:20:33.411]                       envir = ns)) {
[13:20:33.411]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:33.411]                         envir = ns)
[13:20:33.411]                       envir <- sys.frame(frame)
[13:20:33.411]                       master <- NULL
[13:20:33.411]                       while (!identical(envir, .GlobalEnv) && 
[13:20:33.411]                         !identical(envir, emptyenv())) {
[13:20:33.411]                         if (exists("master", mode = "list", envir = envir, 
[13:20:33.411]                           inherits = FALSE)) {
[13:20:33.411]                           master <- get("master", mode = "list", 
[13:20:33.411]                             envir = envir, inherits = FALSE)
[13:20:33.411]                           if (inherits(master, c("SOCKnode", 
[13:20:33.411]                             "SOCK0node"))) {
[13:20:33.411]                             sendCondition <<- function(cond) {
[13:20:33.411]                               data <- list(type = "VALUE", value = cond, 
[13:20:33.411]                                 success = TRUE)
[13:20:33.411]                               parallel_sendData(master, data)
[13:20:33.411]                             }
[13:20:33.411]                             return(sendCondition)
[13:20:33.411]                           }
[13:20:33.411]                         }
[13:20:33.411]                         frame <- frame + 1L
[13:20:33.411]                         envir <- sys.frame(frame)
[13:20:33.411]                       }
[13:20:33.411]                     }
[13:20:33.411]                     sendCondition <<- function(cond) NULL
[13:20:33.411]                   }
[13:20:33.411]                 })
[13:20:33.411]                 withCallingHandlers({
[13:20:33.411]                   {
[13:20:33.411]                     lm(weight ~ group - 1)
[13:20:33.411]                   }
[13:20:33.411]                 }, immediateCondition = function(cond) {
[13:20:33.411]                   sendCondition <- ...future.makeSendCondition()
[13:20:33.411]                   sendCondition(cond)
[13:20:33.411]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:33.411]                   {
[13:20:33.411]                     inherits <- base::inherits
[13:20:33.411]                     invokeRestart <- base::invokeRestart
[13:20:33.411]                     is.null <- base::is.null
[13:20:33.411]                     muffled <- FALSE
[13:20:33.411]                     if (inherits(cond, "message")) {
[13:20:33.411]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:33.411]                       if (muffled) 
[13:20:33.411]                         invokeRestart("muffleMessage")
[13:20:33.411]                     }
[13:20:33.411]                     else if (inherits(cond, "warning")) {
[13:20:33.411]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:33.411]                       if (muffled) 
[13:20:33.411]                         invokeRestart("muffleWarning")
[13:20:33.411]                     }
[13:20:33.411]                     else if (inherits(cond, "condition")) {
[13:20:33.411]                       if (!is.null(pattern)) {
[13:20:33.411]                         computeRestarts <- base::computeRestarts
[13:20:33.411]                         grepl <- base::grepl
[13:20:33.411]                         restarts <- computeRestarts(cond)
[13:20:33.411]                         for (restart in restarts) {
[13:20:33.411]                           name <- restart$name
[13:20:33.411]                           if (is.null(name)) 
[13:20:33.411]                             next
[13:20:33.411]                           if (!grepl(pattern, name)) 
[13:20:33.411]                             next
[13:20:33.411]                           invokeRestart(restart)
[13:20:33.411]                           muffled <- TRUE
[13:20:33.411]                           break
[13:20:33.411]                         }
[13:20:33.411]                       }
[13:20:33.411]                     }
[13:20:33.411]                     invisible(muffled)
[13:20:33.411]                   }
[13:20:33.411]                   muffleCondition(cond)
[13:20:33.411]                 })
[13:20:33.411]             }))
[13:20:33.411]             future::FutureResult(value = ...future.value$value, 
[13:20:33.411]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:33.411]                   ...future.rng), globalenv = if (FALSE) 
[13:20:33.411]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:33.411]                     ...future.globalenv.names))
[13:20:33.411]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:33.411]         }, condition = base::local({
[13:20:33.411]             c <- base::c
[13:20:33.411]             inherits <- base::inherits
[13:20:33.411]             invokeRestart <- base::invokeRestart
[13:20:33.411]             length <- base::length
[13:20:33.411]             list <- base::list
[13:20:33.411]             seq.int <- base::seq.int
[13:20:33.411]             signalCondition <- base::signalCondition
[13:20:33.411]             sys.calls <- base::sys.calls
[13:20:33.411]             `[[` <- base::`[[`
[13:20:33.411]             `+` <- base::`+`
[13:20:33.411]             `<<-` <- base::`<<-`
[13:20:33.411]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:33.411]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:33.411]                   3L)]
[13:20:33.411]             }
[13:20:33.411]             function(cond) {
[13:20:33.411]                 is_error <- inherits(cond, "error")
[13:20:33.411]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:33.411]                   NULL)
[13:20:33.411]                 if (is_error) {
[13:20:33.411]                   sessionInformation <- function() {
[13:20:33.411]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:33.411]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:33.411]                       search = base::search(), system = base::Sys.info())
[13:20:33.411]                   }
[13:20:33.411]                   ...future.conditions[[length(...future.conditions) + 
[13:20:33.411]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:33.411]                     cond$call), session = sessionInformation(), 
[13:20:33.411]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:33.411]                   signalCondition(cond)
[13:20:33.411]                 }
[13:20:33.411]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:33.411]                 "immediateCondition"))) {
[13:20:33.411]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:33.411]                   ...future.conditions[[length(...future.conditions) + 
[13:20:33.411]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:33.411]                   if (TRUE && !signal) {
[13:20:33.411]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:33.411]                     {
[13:20:33.411]                       inherits <- base::inherits
[13:20:33.411]                       invokeRestart <- base::invokeRestart
[13:20:33.411]                       is.null <- base::is.null
[13:20:33.411]                       muffled <- FALSE
[13:20:33.411]                       if (inherits(cond, "message")) {
[13:20:33.411]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:33.411]                         if (muffled) 
[13:20:33.411]                           invokeRestart("muffleMessage")
[13:20:33.411]                       }
[13:20:33.411]                       else if (inherits(cond, "warning")) {
[13:20:33.411]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:33.411]                         if (muffled) 
[13:20:33.411]                           invokeRestart("muffleWarning")
[13:20:33.411]                       }
[13:20:33.411]                       else if (inherits(cond, "condition")) {
[13:20:33.411]                         if (!is.null(pattern)) {
[13:20:33.411]                           computeRestarts <- base::computeRestarts
[13:20:33.411]                           grepl <- base::grepl
[13:20:33.411]                           restarts <- computeRestarts(cond)
[13:20:33.411]                           for (restart in restarts) {
[13:20:33.411]                             name <- restart$name
[13:20:33.411]                             if (is.null(name)) 
[13:20:33.411]                               next
[13:20:33.411]                             if (!grepl(pattern, name)) 
[13:20:33.411]                               next
[13:20:33.411]                             invokeRestart(restart)
[13:20:33.411]                             muffled <- TRUE
[13:20:33.411]                             break
[13:20:33.411]                           }
[13:20:33.411]                         }
[13:20:33.411]                       }
[13:20:33.411]                       invisible(muffled)
[13:20:33.411]                     }
[13:20:33.411]                     muffleCondition(cond, pattern = "^muffle")
[13:20:33.411]                   }
[13:20:33.411]                 }
[13:20:33.411]                 else {
[13:20:33.411]                   if (TRUE) {
[13:20:33.411]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:33.411]                     {
[13:20:33.411]                       inherits <- base::inherits
[13:20:33.411]                       invokeRestart <- base::invokeRestart
[13:20:33.411]                       is.null <- base::is.null
[13:20:33.411]                       muffled <- FALSE
[13:20:33.411]                       if (inherits(cond, "message")) {
[13:20:33.411]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:33.411]                         if (muffled) 
[13:20:33.411]                           invokeRestart("muffleMessage")
[13:20:33.411]                       }
[13:20:33.411]                       else if (inherits(cond, "warning")) {
[13:20:33.411]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:33.411]                         if (muffled) 
[13:20:33.411]                           invokeRestart("muffleWarning")
[13:20:33.411]                       }
[13:20:33.411]                       else if (inherits(cond, "condition")) {
[13:20:33.411]                         if (!is.null(pattern)) {
[13:20:33.411]                           computeRestarts <- base::computeRestarts
[13:20:33.411]                           grepl <- base::grepl
[13:20:33.411]                           restarts <- computeRestarts(cond)
[13:20:33.411]                           for (restart in restarts) {
[13:20:33.411]                             name <- restart$name
[13:20:33.411]                             if (is.null(name)) 
[13:20:33.411]                               next
[13:20:33.411]                             if (!grepl(pattern, name)) 
[13:20:33.411]                               next
[13:20:33.411]                             invokeRestart(restart)
[13:20:33.411]                             muffled <- TRUE
[13:20:33.411]                             break
[13:20:33.411]                           }
[13:20:33.411]                         }
[13:20:33.411]                       }
[13:20:33.411]                       invisible(muffled)
[13:20:33.411]                     }
[13:20:33.411]                     muffleCondition(cond, pattern = "^muffle")
[13:20:33.411]                   }
[13:20:33.411]                 }
[13:20:33.411]             }
[13:20:33.411]         }))
[13:20:33.411]     }, error = function(ex) {
[13:20:33.411]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:33.411]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:33.411]                 ...future.rng), started = ...future.startTime, 
[13:20:33.411]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:33.411]             version = "1.8"), class = "FutureResult")
[13:20:33.411]     }, finally = {
[13:20:33.411]         if (!identical(...future.workdir, getwd())) 
[13:20:33.411]             setwd(...future.workdir)
[13:20:33.411]         {
[13:20:33.411]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:33.411]                 ...future.oldOptions$nwarnings <- NULL
[13:20:33.411]             }
[13:20:33.411]             base::options(...future.oldOptions)
[13:20:33.411]             if (.Platform$OS.type == "windows") {
[13:20:33.411]                 old_names <- names(...future.oldEnvVars)
[13:20:33.411]                 envs <- base::Sys.getenv()
[13:20:33.411]                 names <- names(envs)
[13:20:33.411]                 common <- intersect(names, old_names)
[13:20:33.411]                 added <- setdiff(names, old_names)
[13:20:33.411]                 removed <- setdiff(old_names, names)
[13:20:33.411]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:33.411]                   envs[common]]
[13:20:33.411]                 NAMES <- toupper(changed)
[13:20:33.411]                 args <- list()
[13:20:33.411]                 for (kk in seq_along(NAMES)) {
[13:20:33.411]                   name <- changed[[kk]]
[13:20:33.411]                   NAME <- NAMES[[kk]]
[13:20:33.411]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:33.411]                     next
[13:20:33.411]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:33.411]                 }
[13:20:33.411]                 NAMES <- toupper(added)
[13:20:33.411]                 for (kk in seq_along(NAMES)) {
[13:20:33.411]                   name <- added[[kk]]
[13:20:33.411]                   NAME <- NAMES[[kk]]
[13:20:33.411]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:33.411]                     next
[13:20:33.411]                   args[[name]] <- ""
[13:20:33.411]                 }
[13:20:33.411]                 NAMES <- toupper(removed)
[13:20:33.411]                 for (kk in seq_along(NAMES)) {
[13:20:33.411]                   name <- removed[[kk]]
[13:20:33.411]                   NAME <- NAMES[[kk]]
[13:20:33.411]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:33.411]                     next
[13:20:33.411]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:33.411]                 }
[13:20:33.411]                 if (length(args) > 0) 
[13:20:33.411]                   base::do.call(base::Sys.setenv, args = args)
[13:20:33.411]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:33.411]             }
[13:20:33.411]             else {
[13:20:33.411]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:33.411]             }
[13:20:33.411]             {
[13:20:33.411]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:33.411]                   0L) {
[13:20:33.411]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:33.411]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:33.411]                   base::options(opts)
[13:20:33.411]                 }
[13:20:33.411]                 {
[13:20:33.411]                   {
[13:20:33.411]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:33.411]                     NULL
[13:20:33.411]                   }
[13:20:33.411]                   options(future.plan = NULL)
[13:20:33.411]                   if (is.na(NA_character_)) 
[13:20:33.411]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:33.411]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:33.411]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:33.411]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:33.411]                     envir = parent.frame()) 
[13:20:33.411]                   {
[13:20:33.411]                     if (is.function(workers)) 
[13:20:33.411]                       workers <- workers()
[13:20:33.411]                     workers <- structure(as.integer(workers), 
[13:20:33.411]                       class = class(workers))
[13:20:33.411]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:33.411]                       workers >= 1)
[13:20:33.411]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:33.411]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:33.411]                     }
[13:20:33.411]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:33.411]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:33.411]                       envir = envir)
[13:20:33.411]                     if (!future$lazy) 
[13:20:33.411]                       future <- run(future)
[13:20:33.411]                     invisible(future)
[13:20:33.411]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:33.411]                 }
[13:20:33.411]             }
[13:20:33.411]         }
[13:20:33.411]     })
[13:20:33.411]     if (TRUE) {
[13:20:33.411]         base::sink(type = "output", split = FALSE)
[13:20:33.411]         if (TRUE) {
[13:20:33.411]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:33.411]         }
[13:20:33.411]         else {
[13:20:33.411]             ...future.result["stdout"] <- base::list(NULL)
[13:20:33.411]         }
[13:20:33.411]         base::close(...future.stdout)
[13:20:33.411]         ...future.stdout <- NULL
[13:20:33.411]     }
[13:20:33.411]     ...future.result$conditions <- ...future.conditions
[13:20:33.411]     ...future.result$finished <- base::Sys.time()
[13:20:33.411]     ...future.result
[13:20:33.411] }
[13:20:33.414] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[13:20:33.414] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[13:20:33.415] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[13:20:33.415] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[13:20:33.415] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[13:20:33.415] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[13:20:33.416] MultisessionFuture started
[13:20:33.416] - Launch lazy future ... done
[13:20:33.416] run() for ‘MultisessionFuture’ ... done
[13:20:33.416] result() for ClusterFuture ...
[13:20:33.416] receiveMessageFromWorker() for ClusterFuture ...
[13:20:33.417] - Validating connection of MultisessionFuture
[13:20:33.463] - received message: FutureResult
[13:20:33.463] - Received FutureResult
[13:20:33.463] - Erased future from FutureRegistry
[13:20:33.464] result() for ClusterFuture ...
[13:20:33.464] - result already collected: FutureResult
[13:20:33.464] result() for ClusterFuture ... done
[13:20:33.464] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:33.464] result() for ClusterFuture ... done
[13:20:33.464] result() for ClusterFuture ...
[13:20:33.464] - result already collected: FutureResult
[13:20:33.464] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[13:20:33.466] getGlobalsAndPackages() ...
[13:20:33.466] Searching for globals...
[13:20:33.468] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:20:33.468] Searching for globals ... DONE
[13:20:33.468] Resolving globals: FALSE
[13:20:33.469] The total size of the 2 globals is 896 bytes (896 bytes)
[13:20:33.469] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:20:33.469] - globals: [2] ‘weight’, ‘group’
[13:20:33.469] - packages: [1] ‘stats’
[13:20:33.469] getGlobalsAndPackages() ... DONE
[13:20:33.470] run() for ‘Future’ ...
[13:20:33.470] - state: ‘created’
[13:20:33.470] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:33.486] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:33.487] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:33.487]   - Field: ‘node’
[13:20:33.487]   - Field: ‘label’
[13:20:33.487]   - Field: ‘local’
[13:20:33.487]   - Field: ‘owner’
[13:20:33.487]   - Field: ‘envir’
[13:20:33.487]   - Field: ‘workers’
[13:20:33.487]   - Field: ‘packages’
[13:20:33.487]   - Field: ‘gc’
[13:20:33.487]   - Field: ‘conditions’
[13:20:33.488]   - Field: ‘persistent’
[13:20:33.488]   - Field: ‘expr’
[13:20:33.488]   - Field: ‘uuid’
[13:20:33.488]   - Field: ‘seed’
[13:20:33.488]   - Field: ‘version’
[13:20:33.488]   - Field: ‘result’
[13:20:33.488]   - Field: ‘asynchronous’
[13:20:33.488]   - Field: ‘calls’
[13:20:33.488]   - Field: ‘globals’
[13:20:33.488]   - Field: ‘stdout’
[13:20:33.489]   - Field: ‘earlySignal’
[13:20:33.489]   - Field: ‘lazy’
[13:20:33.489]   - Field: ‘state’
[13:20:33.489] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:33.489] - Launch lazy future ...
[13:20:33.489] Packages needed by the future expression (n = 1): ‘stats’
[13:20:33.489] Packages needed by future strategies (n = 0): <none>
[13:20:33.490] {
[13:20:33.490]     {
[13:20:33.490]         {
[13:20:33.490]             ...future.startTime <- base::Sys.time()
[13:20:33.490]             {
[13:20:33.490]                 {
[13:20:33.490]                   {
[13:20:33.490]                     {
[13:20:33.490]                       {
[13:20:33.490]                         base::local({
[13:20:33.490]                           has_future <- base::requireNamespace("future", 
[13:20:33.490]                             quietly = TRUE)
[13:20:33.490]                           if (has_future) {
[13:20:33.490]                             ns <- base::getNamespace("future")
[13:20:33.490]                             version <- ns[[".package"]][["version"]]
[13:20:33.490]                             if (is.null(version)) 
[13:20:33.490]                               version <- utils::packageVersion("future")
[13:20:33.490]                           }
[13:20:33.490]                           else {
[13:20:33.490]                             version <- NULL
[13:20:33.490]                           }
[13:20:33.490]                           if (!has_future || version < "1.8.0") {
[13:20:33.490]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:33.490]                               "", base::R.version$version.string), 
[13:20:33.490]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:33.490]                                 base::R.version$platform, 8 * 
[13:20:33.490]                                   base::.Machine$sizeof.pointer), 
[13:20:33.490]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:33.490]                                 "release", "version")], collapse = " "), 
[13:20:33.490]                               hostname = base::Sys.info()[["nodename"]])
[13:20:33.490]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:33.490]                               info)
[13:20:33.490]                             info <- base::paste(info, collapse = "; ")
[13:20:33.490]                             if (!has_future) {
[13:20:33.490]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:33.490]                                 info)
[13:20:33.490]                             }
[13:20:33.490]                             else {
[13:20:33.490]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:33.490]                                 info, version)
[13:20:33.490]                             }
[13:20:33.490]                             base::stop(msg)
[13:20:33.490]                           }
[13:20:33.490]                         })
[13:20:33.490]                       }
[13:20:33.490]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:33.490]                       base::options(mc.cores = 1L)
[13:20:33.490]                     }
[13:20:33.490]                     base::local({
[13:20:33.490]                       for (pkg in "stats") {
[13:20:33.490]                         base::loadNamespace(pkg)
[13:20:33.490]                         base::library(pkg, character.only = TRUE)
[13:20:33.490]                       }
[13:20:33.490]                     })
[13:20:33.490]                   }
[13:20:33.490]                   options(future.plan = NULL)
[13:20:33.490]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:33.490]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:33.490]                 }
[13:20:33.490]                 ...future.workdir <- getwd()
[13:20:33.490]             }
[13:20:33.490]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:33.490]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:33.490]         }
[13:20:33.490]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:33.490]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:33.490]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:33.490]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:33.490]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:33.490]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:33.490]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:33.490]             base::names(...future.oldOptions))
[13:20:33.490]     }
[13:20:33.490]     if (FALSE) {
[13:20:33.490]     }
[13:20:33.490]     else {
[13:20:33.490]         if (TRUE) {
[13:20:33.490]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:33.490]                 open = "w")
[13:20:33.490]         }
[13:20:33.490]         else {
[13:20:33.490]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:33.490]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:33.490]         }
[13:20:33.490]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:33.490]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:33.490]             base::sink(type = "output", split = FALSE)
[13:20:33.490]             base::close(...future.stdout)
[13:20:33.490]         }, add = TRUE)
[13:20:33.490]     }
[13:20:33.490]     ...future.frame <- base::sys.nframe()
[13:20:33.490]     ...future.conditions <- base::list()
[13:20:33.490]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:33.490]     if (FALSE) {
[13:20:33.490]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:33.490]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:33.490]     }
[13:20:33.490]     ...future.result <- base::tryCatch({
[13:20:33.490]         base::withCallingHandlers({
[13:20:33.490]             ...future.value <- base::withVisible(base::local({
[13:20:33.490]                 ...future.makeSendCondition <- local({
[13:20:33.490]                   sendCondition <- NULL
[13:20:33.490]                   function(frame = 1L) {
[13:20:33.490]                     if (is.function(sendCondition)) 
[13:20:33.490]                       return(sendCondition)
[13:20:33.490]                     ns <- getNamespace("parallel")
[13:20:33.490]                     if (exists("sendData", mode = "function", 
[13:20:33.490]                       envir = ns)) {
[13:20:33.490]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:33.490]                         envir = ns)
[13:20:33.490]                       envir <- sys.frame(frame)
[13:20:33.490]                       master <- NULL
[13:20:33.490]                       while (!identical(envir, .GlobalEnv) && 
[13:20:33.490]                         !identical(envir, emptyenv())) {
[13:20:33.490]                         if (exists("master", mode = "list", envir = envir, 
[13:20:33.490]                           inherits = FALSE)) {
[13:20:33.490]                           master <- get("master", mode = "list", 
[13:20:33.490]                             envir = envir, inherits = FALSE)
[13:20:33.490]                           if (inherits(master, c("SOCKnode", 
[13:20:33.490]                             "SOCK0node"))) {
[13:20:33.490]                             sendCondition <<- function(cond) {
[13:20:33.490]                               data <- list(type = "VALUE", value = cond, 
[13:20:33.490]                                 success = TRUE)
[13:20:33.490]                               parallel_sendData(master, data)
[13:20:33.490]                             }
[13:20:33.490]                             return(sendCondition)
[13:20:33.490]                           }
[13:20:33.490]                         }
[13:20:33.490]                         frame <- frame + 1L
[13:20:33.490]                         envir <- sys.frame(frame)
[13:20:33.490]                       }
[13:20:33.490]                     }
[13:20:33.490]                     sendCondition <<- function(cond) NULL
[13:20:33.490]                   }
[13:20:33.490]                 })
[13:20:33.490]                 withCallingHandlers({
[13:20:33.490]                   {
[13:20:33.490]                     lm(weight ~ group - 1)
[13:20:33.490]                   }
[13:20:33.490]                 }, immediateCondition = function(cond) {
[13:20:33.490]                   sendCondition <- ...future.makeSendCondition()
[13:20:33.490]                   sendCondition(cond)
[13:20:33.490]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:33.490]                   {
[13:20:33.490]                     inherits <- base::inherits
[13:20:33.490]                     invokeRestart <- base::invokeRestart
[13:20:33.490]                     is.null <- base::is.null
[13:20:33.490]                     muffled <- FALSE
[13:20:33.490]                     if (inherits(cond, "message")) {
[13:20:33.490]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:33.490]                       if (muffled) 
[13:20:33.490]                         invokeRestart("muffleMessage")
[13:20:33.490]                     }
[13:20:33.490]                     else if (inherits(cond, "warning")) {
[13:20:33.490]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:33.490]                       if (muffled) 
[13:20:33.490]                         invokeRestart("muffleWarning")
[13:20:33.490]                     }
[13:20:33.490]                     else if (inherits(cond, "condition")) {
[13:20:33.490]                       if (!is.null(pattern)) {
[13:20:33.490]                         computeRestarts <- base::computeRestarts
[13:20:33.490]                         grepl <- base::grepl
[13:20:33.490]                         restarts <- computeRestarts(cond)
[13:20:33.490]                         for (restart in restarts) {
[13:20:33.490]                           name <- restart$name
[13:20:33.490]                           if (is.null(name)) 
[13:20:33.490]                             next
[13:20:33.490]                           if (!grepl(pattern, name)) 
[13:20:33.490]                             next
[13:20:33.490]                           invokeRestart(restart)
[13:20:33.490]                           muffled <- TRUE
[13:20:33.490]                           break
[13:20:33.490]                         }
[13:20:33.490]                       }
[13:20:33.490]                     }
[13:20:33.490]                     invisible(muffled)
[13:20:33.490]                   }
[13:20:33.490]                   muffleCondition(cond)
[13:20:33.490]                 })
[13:20:33.490]             }))
[13:20:33.490]             future::FutureResult(value = ...future.value$value, 
[13:20:33.490]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:33.490]                   ...future.rng), globalenv = if (FALSE) 
[13:20:33.490]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:33.490]                     ...future.globalenv.names))
[13:20:33.490]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:33.490]         }, condition = base::local({
[13:20:33.490]             c <- base::c
[13:20:33.490]             inherits <- base::inherits
[13:20:33.490]             invokeRestart <- base::invokeRestart
[13:20:33.490]             length <- base::length
[13:20:33.490]             list <- base::list
[13:20:33.490]             seq.int <- base::seq.int
[13:20:33.490]             signalCondition <- base::signalCondition
[13:20:33.490]             sys.calls <- base::sys.calls
[13:20:33.490]             `[[` <- base::`[[`
[13:20:33.490]             `+` <- base::`+`
[13:20:33.490]             `<<-` <- base::`<<-`
[13:20:33.490]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:33.490]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:33.490]                   3L)]
[13:20:33.490]             }
[13:20:33.490]             function(cond) {
[13:20:33.490]                 is_error <- inherits(cond, "error")
[13:20:33.490]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:33.490]                   NULL)
[13:20:33.490]                 if (is_error) {
[13:20:33.490]                   sessionInformation <- function() {
[13:20:33.490]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:33.490]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:33.490]                       search = base::search(), system = base::Sys.info())
[13:20:33.490]                   }
[13:20:33.490]                   ...future.conditions[[length(...future.conditions) + 
[13:20:33.490]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:33.490]                     cond$call), session = sessionInformation(), 
[13:20:33.490]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:33.490]                   signalCondition(cond)
[13:20:33.490]                 }
[13:20:33.490]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:33.490]                 "immediateCondition"))) {
[13:20:33.490]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:33.490]                   ...future.conditions[[length(...future.conditions) + 
[13:20:33.490]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:33.490]                   if (TRUE && !signal) {
[13:20:33.490]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:33.490]                     {
[13:20:33.490]                       inherits <- base::inherits
[13:20:33.490]                       invokeRestart <- base::invokeRestart
[13:20:33.490]                       is.null <- base::is.null
[13:20:33.490]                       muffled <- FALSE
[13:20:33.490]                       if (inherits(cond, "message")) {
[13:20:33.490]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:33.490]                         if (muffled) 
[13:20:33.490]                           invokeRestart("muffleMessage")
[13:20:33.490]                       }
[13:20:33.490]                       else if (inherits(cond, "warning")) {
[13:20:33.490]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:33.490]                         if (muffled) 
[13:20:33.490]                           invokeRestart("muffleWarning")
[13:20:33.490]                       }
[13:20:33.490]                       else if (inherits(cond, "condition")) {
[13:20:33.490]                         if (!is.null(pattern)) {
[13:20:33.490]                           computeRestarts <- base::computeRestarts
[13:20:33.490]                           grepl <- base::grepl
[13:20:33.490]                           restarts <- computeRestarts(cond)
[13:20:33.490]                           for (restart in restarts) {
[13:20:33.490]                             name <- restart$name
[13:20:33.490]                             if (is.null(name)) 
[13:20:33.490]                               next
[13:20:33.490]                             if (!grepl(pattern, name)) 
[13:20:33.490]                               next
[13:20:33.490]                             invokeRestart(restart)
[13:20:33.490]                             muffled <- TRUE
[13:20:33.490]                             break
[13:20:33.490]                           }
[13:20:33.490]                         }
[13:20:33.490]                       }
[13:20:33.490]                       invisible(muffled)
[13:20:33.490]                     }
[13:20:33.490]                     muffleCondition(cond, pattern = "^muffle")
[13:20:33.490]                   }
[13:20:33.490]                 }
[13:20:33.490]                 else {
[13:20:33.490]                   if (TRUE) {
[13:20:33.490]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:33.490]                     {
[13:20:33.490]                       inherits <- base::inherits
[13:20:33.490]                       invokeRestart <- base::invokeRestart
[13:20:33.490]                       is.null <- base::is.null
[13:20:33.490]                       muffled <- FALSE
[13:20:33.490]                       if (inherits(cond, "message")) {
[13:20:33.490]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:33.490]                         if (muffled) 
[13:20:33.490]                           invokeRestart("muffleMessage")
[13:20:33.490]                       }
[13:20:33.490]                       else if (inherits(cond, "warning")) {
[13:20:33.490]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:33.490]                         if (muffled) 
[13:20:33.490]                           invokeRestart("muffleWarning")
[13:20:33.490]                       }
[13:20:33.490]                       else if (inherits(cond, "condition")) {
[13:20:33.490]                         if (!is.null(pattern)) {
[13:20:33.490]                           computeRestarts <- base::computeRestarts
[13:20:33.490]                           grepl <- base::grepl
[13:20:33.490]                           restarts <- computeRestarts(cond)
[13:20:33.490]                           for (restart in restarts) {
[13:20:33.490]                             name <- restart$name
[13:20:33.490]                             if (is.null(name)) 
[13:20:33.490]                               next
[13:20:33.490]                             if (!grepl(pattern, name)) 
[13:20:33.490]                               next
[13:20:33.490]                             invokeRestart(restart)
[13:20:33.490]                             muffled <- TRUE
[13:20:33.490]                             break
[13:20:33.490]                           }
[13:20:33.490]                         }
[13:20:33.490]                       }
[13:20:33.490]                       invisible(muffled)
[13:20:33.490]                     }
[13:20:33.490]                     muffleCondition(cond, pattern = "^muffle")
[13:20:33.490]                   }
[13:20:33.490]                 }
[13:20:33.490]             }
[13:20:33.490]         }))
[13:20:33.490]     }, error = function(ex) {
[13:20:33.490]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:33.490]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:33.490]                 ...future.rng), started = ...future.startTime, 
[13:20:33.490]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:33.490]             version = "1.8"), class = "FutureResult")
[13:20:33.490]     }, finally = {
[13:20:33.490]         if (!identical(...future.workdir, getwd())) 
[13:20:33.490]             setwd(...future.workdir)
[13:20:33.490]         {
[13:20:33.490]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:33.490]                 ...future.oldOptions$nwarnings <- NULL
[13:20:33.490]             }
[13:20:33.490]             base::options(...future.oldOptions)
[13:20:33.490]             if (.Platform$OS.type == "windows") {
[13:20:33.490]                 old_names <- names(...future.oldEnvVars)
[13:20:33.490]                 envs <- base::Sys.getenv()
[13:20:33.490]                 names <- names(envs)
[13:20:33.490]                 common <- intersect(names, old_names)
[13:20:33.490]                 added <- setdiff(names, old_names)
[13:20:33.490]                 removed <- setdiff(old_names, names)
[13:20:33.490]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:33.490]                   envs[common]]
[13:20:33.490]                 NAMES <- toupper(changed)
[13:20:33.490]                 args <- list()
[13:20:33.490]                 for (kk in seq_along(NAMES)) {
[13:20:33.490]                   name <- changed[[kk]]
[13:20:33.490]                   NAME <- NAMES[[kk]]
[13:20:33.490]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:33.490]                     next
[13:20:33.490]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:33.490]                 }
[13:20:33.490]                 NAMES <- toupper(added)
[13:20:33.490]                 for (kk in seq_along(NAMES)) {
[13:20:33.490]                   name <- added[[kk]]
[13:20:33.490]                   NAME <- NAMES[[kk]]
[13:20:33.490]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:33.490]                     next
[13:20:33.490]                   args[[name]] <- ""
[13:20:33.490]                 }
[13:20:33.490]                 NAMES <- toupper(removed)
[13:20:33.490]                 for (kk in seq_along(NAMES)) {
[13:20:33.490]                   name <- removed[[kk]]
[13:20:33.490]                   NAME <- NAMES[[kk]]
[13:20:33.490]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:33.490]                     next
[13:20:33.490]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:33.490]                 }
[13:20:33.490]                 if (length(args) > 0) 
[13:20:33.490]                   base::do.call(base::Sys.setenv, args = args)
[13:20:33.490]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:33.490]             }
[13:20:33.490]             else {
[13:20:33.490]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:33.490]             }
[13:20:33.490]             {
[13:20:33.490]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:33.490]                   0L) {
[13:20:33.490]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:33.490]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:33.490]                   base::options(opts)
[13:20:33.490]                 }
[13:20:33.490]                 {
[13:20:33.490]                   {
[13:20:33.490]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:33.490]                     NULL
[13:20:33.490]                   }
[13:20:33.490]                   options(future.plan = NULL)
[13:20:33.490]                   if (is.na(NA_character_)) 
[13:20:33.490]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:33.490]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:33.490]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:33.490]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:33.490]                     envir = parent.frame()) 
[13:20:33.490]                   {
[13:20:33.490]                     if (is.function(workers)) 
[13:20:33.490]                       workers <- workers()
[13:20:33.490]                     workers <- structure(as.integer(workers), 
[13:20:33.490]                       class = class(workers))
[13:20:33.490]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:33.490]                       workers >= 1)
[13:20:33.490]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:33.490]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:33.490]                     }
[13:20:33.490]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:33.490]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:33.490]                       envir = envir)
[13:20:33.490]                     if (!future$lazy) 
[13:20:33.490]                       future <- run(future)
[13:20:33.490]                     invisible(future)
[13:20:33.490]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:33.490]                 }
[13:20:33.490]             }
[13:20:33.490]         }
[13:20:33.490]     })
[13:20:33.490]     if (TRUE) {
[13:20:33.490]         base::sink(type = "output", split = FALSE)
[13:20:33.490]         if (TRUE) {
[13:20:33.490]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:33.490]         }
[13:20:33.490]         else {
[13:20:33.490]             ...future.result["stdout"] <- base::list(NULL)
[13:20:33.490]         }
[13:20:33.490]         base::close(...future.stdout)
[13:20:33.490]         ...future.stdout <- NULL
[13:20:33.490]     }
[13:20:33.490]     ...future.result$conditions <- ...future.conditions
[13:20:33.490]     ...future.result$finished <- base::Sys.time()
[13:20:33.490]     ...future.result
[13:20:33.490] }
[13:20:33.493] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[13:20:33.493] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[13:20:33.493] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[13:20:33.493] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[13:20:33.494] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[13:20:33.494] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[13:20:33.495] MultisessionFuture started
[13:20:33.495] - Launch lazy future ... done
[13:20:33.495] run() for ‘MultisessionFuture’ ... done
[13:20:33.495] result() for ClusterFuture ...
[13:20:33.495] receiveMessageFromWorker() for ClusterFuture ...
[13:20:33.495] - Validating connection of MultisessionFuture
[13:20:33.543] - received message: FutureResult
[13:20:33.544] - Received FutureResult
[13:20:33.544] - Erased future from FutureRegistry
[13:20:33.544] result() for ClusterFuture ...
[13:20:33.544] - result already collected: FutureResult
[13:20:33.544] result() for ClusterFuture ... done
[13:20:33.544] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:33.544] result() for ClusterFuture ... done
[13:20:33.544] result() for ClusterFuture ...
[13:20:33.544] - result already collected: FutureResult
[13:20:33.545] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[13:20:33.546] getGlobalsAndPackages() ...
[13:20:33.547] Searching for globals...
[13:20:33.548] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[13:20:33.548] Searching for globals ... DONE
[13:20:33.548] Resolving globals: FALSE
[13:20:33.548] The total size of the 1 globals is 96 bytes (96 bytes)
[13:20:33.549] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[13:20:33.549] - globals: [1] ‘x’
[13:20:33.549] - packages: [1] ‘stats’
[13:20:33.549] getGlobalsAndPackages() ... DONE
[13:20:33.549] run() for ‘Future’ ...
[13:20:33.550] - state: ‘created’
[13:20:33.550] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:33.564] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:33.564] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:33.564]   - Field: ‘node’
[13:20:33.564]   - Field: ‘label’
[13:20:33.564]   - Field: ‘local’
[13:20:33.564]   - Field: ‘owner’
[13:20:33.565]   - Field: ‘envir’
[13:20:33.565]   - Field: ‘workers’
[13:20:33.565]   - Field: ‘packages’
[13:20:33.565]   - Field: ‘gc’
[13:20:33.565]   - Field: ‘conditions’
[13:20:33.565]   - Field: ‘persistent’
[13:20:33.565]   - Field: ‘expr’
[13:20:33.565]   - Field: ‘uuid’
[13:20:33.565]   - Field: ‘seed’
[13:20:33.565]   - Field: ‘version’
[13:20:33.566]   - Field: ‘result’
[13:20:33.566]   - Field: ‘asynchronous’
[13:20:33.566]   - Field: ‘calls’
[13:20:33.566]   - Field: ‘globals’
[13:20:33.566]   - Field: ‘stdout’
[13:20:33.566]   - Field: ‘earlySignal’
[13:20:33.566]   - Field: ‘lazy’
[13:20:33.566]   - Field: ‘state’
[13:20:33.566] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:33.566] - Launch lazy future ...
[13:20:33.567] Packages needed by the future expression (n = 1): ‘stats’
[13:20:33.567] Packages needed by future strategies (n = 0): <none>
[13:20:33.567] {
[13:20:33.567]     {
[13:20:33.567]         {
[13:20:33.567]             ...future.startTime <- base::Sys.time()
[13:20:33.567]             {
[13:20:33.567]                 {
[13:20:33.567]                   {
[13:20:33.567]                     {
[13:20:33.567]                       {
[13:20:33.567]                         base::local({
[13:20:33.567]                           has_future <- base::requireNamespace("future", 
[13:20:33.567]                             quietly = TRUE)
[13:20:33.567]                           if (has_future) {
[13:20:33.567]                             ns <- base::getNamespace("future")
[13:20:33.567]                             version <- ns[[".package"]][["version"]]
[13:20:33.567]                             if (is.null(version)) 
[13:20:33.567]                               version <- utils::packageVersion("future")
[13:20:33.567]                           }
[13:20:33.567]                           else {
[13:20:33.567]                             version <- NULL
[13:20:33.567]                           }
[13:20:33.567]                           if (!has_future || version < "1.8.0") {
[13:20:33.567]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:33.567]                               "", base::R.version$version.string), 
[13:20:33.567]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:33.567]                                 base::R.version$platform, 8 * 
[13:20:33.567]                                   base::.Machine$sizeof.pointer), 
[13:20:33.567]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:33.567]                                 "release", "version")], collapse = " "), 
[13:20:33.567]                               hostname = base::Sys.info()[["nodename"]])
[13:20:33.567]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:33.567]                               info)
[13:20:33.567]                             info <- base::paste(info, collapse = "; ")
[13:20:33.567]                             if (!has_future) {
[13:20:33.567]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:33.567]                                 info)
[13:20:33.567]                             }
[13:20:33.567]                             else {
[13:20:33.567]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:33.567]                                 info, version)
[13:20:33.567]                             }
[13:20:33.567]                             base::stop(msg)
[13:20:33.567]                           }
[13:20:33.567]                         })
[13:20:33.567]                       }
[13:20:33.567]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:33.567]                       base::options(mc.cores = 1L)
[13:20:33.567]                     }
[13:20:33.567]                     base::local({
[13:20:33.567]                       for (pkg in "stats") {
[13:20:33.567]                         base::loadNamespace(pkg)
[13:20:33.567]                         base::library(pkg, character.only = TRUE)
[13:20:33.567]                       }
[13:20:33.567]                     })
[13:20:33.567]                   }
[13:20:33.567]                   options(future.plan = NULL)
[13:20:33.567]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:33.567]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:33.567]                 }
[13:20:33.567]                 ...future.workdir <- getwd()
[13:20:33.567]             }
[13:20:33.567]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:33.567]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:33.567]         }
[13:20:33.567]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:33.567]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:33.567]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:33.567]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:33.567]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:33.567]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:33.567]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:33.567]             base::names(...future.oldOptions))
[13:20:33.567]     }
[13:20:33.567]     if (FALSE) {
[13:20:33.567]     }
[13:20:33.567]     else {
[13:20:33.567]         if (TRUE) {
[13:20:33.567]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:33.567]                 open = "w")
[13:20:33.567]         }
[13:20:33.567]         else {
[13:20:33.567]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:33.567]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:33.567]         }
[13:20:33.567]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:33.567]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:33.567]             base::sink(type = "output", split = FALSE)
[13:20:33.567]             base::close(...future.stdout)
[13:20:33.567]         }, add = TRUE)
[13:20:33.567]     }
[13:20:33.567]     ...future.frame <- base::sys.nframe()
[13:20:33.567]     ...future.conditions <- base::list()
[13:20:33.567]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:33.567]     if (FALSE) {
[13:20:33.567]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:33.567]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:33.567]     }
[13:20:33.567]     ...future.result <- base::tryCatch({
[13:20:33.567]         base::withCallingHandlers({
[13:20:33.567]             ...future.value <- base::withVisible(base::local({
[13:20:33.567]                 ...future.makeSendCondition <- local({
[13:20:33.567]                   sendCondition <- NULL
[13:20:33.567]                   function(frame = 1L) {
[13:20:33.567]                     if (is.function(sendCondition)) 
[13:20:33.567]                       return(sendCondition)
[13:20:33.567]                     ns <- getNamespace("parallel")
[13:20:33.567]                     if (exists("sendData", mode = "function", 
[13:20:33.567]                       envir = ns)) {
[13:20:33.567]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:33.567]                         envir = ns)
[13:20:33.567]                       envir <- sys.frame(frame)
[13:20:33.567]                       master <- NULL
[13:20:33.567]                       while (!identical(envir, .GlobalEnv) && 
[13:20:33.567]                         !identical(envir, emptyenv())) {
[13:20:33.567]                         if (exists("master", mode = "list", envir = envir, 
[13:20:33.567]                           inherits = FALSE)) {
[13:20:33.567]                           master <- get("master", mode = "list", 
[13:20:33.567]                             envir = envir, inherits = FALSE)
[13:20:33.567]                           if (inherits(master, c("SOCKnode", 
[13:20:33.567]                             "SOCK0node"))) {
[13:20:33.567]                             sendCondition <<- function(cond) {
[13:20:33.567]                               data <- list(type = "VALUE", value = cond, 
[13:20:33.567]                                 success = TRUE)
[13:20:33.567]                               parallel_sendData(master, data)
[13:20:33.567]                             }
[13:20:33.567]                             return(sendCondition)
[13:20:33.567]                           }
[13:20:33.567]                         }
[13:20:33.567]                         frame <- frame + 1L
[13:20:33.567]                         envir <- sys.frame(frame)
[13:20:33.567]                       }
[13:20:33.567]                     }
[13:20:33.567]                     sendCondition <<- function(cond) NULL
[13:20:33.567]                   }
[13:20:33.567]                 })
[13:20:33.567]                 withCallingHandlers({
[13:20:33.567]                   {
[13:20:33.567]                     xtabs(~x)
[13:20:33.567]                   }
[13:20:33.567]                 }, immediateCondition = function(cond) {
[13:20:33.567]                   sendCondition <- ...future.makeSendCondition()
[13:20:33.567]                   sendCondition(cond)
[13:20:33.567]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:33.567]                   {
[13:20:33.567]                     inherits <- base::inherits
[13:20:33.567]                     invokeRestart <- base::invokeRestart
[13:20:33.567]                     is.null <- base::is.null
[13:20:33.567]                     muffled <- FALSE
[13:20:33.567]                     if (inherits(cond, "message")) {
[13:20:33.567]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:33.567]                       if (muffled) 
[13:20:33.567]                         invokeRestart("muffleMessage")
[13:20:33.567]                     }
[13:20:33.567]                     else if (inherits(cond, "warning")) {
[13:20:33.567]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:33.567]                       if (muffled) 
[13:20:33.567]                         invokeRestart("muffleWarning")
[13:20:33.567]                     }
[13:20:33.567]                     else if (inherits(cond, "condition")) {
[13:20:33.567]                       if (!is.null(pattern)) {
[13:20:33.567]                         computeRestarts <- base::computeRestarts
[13:20:33.567]                         grepl <- base::grepl
[13:20:33.567]                         restarts <- computeRestarts(cond)
[13:20:33.567]                         for (restart in restarts) {
[13:20:33.567]                           name <- restart$name
[13:20:33.567]                           if (is.null(name)) 
[13:20:33.567]                             next
[13:20:33.567]                           if (!grepl(pattern, name)) 
[13:20:33.567]                             next
[13:20:33.567]                           invokeRestart(restart)
[13:20:33.567]                           muffled <- TRUE
[13:20:33.567]                           break
[13:20:33.567]                         }
[13:20:33.567]                       }
[13:20:33.567]                     }
[13:20:33.567]                     invisible(muffled)
[13:20:33.567]                   }
[13:20:33.567]                   muffleCondition(cond)
[13:20:33.567]                 })
[13:20:33.567]             }))
[13:20:33.567]             future::FutureResult(value = ...future.value$value, 
[13:20:33.567]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:33.567]                   ...future.rng), globalenv = if (FALSE) 
[13:20:33.567]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:33.567]                     ...future.globalenv.names))
[13:20:33.567]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:33.567]         }, condition = base::local({
[13:20:33.567]             c <- base::c
[13:20:33.567]             inherits <- base::inherits
[13:20:33.567]             invokeRestart <- base::invokeRestart
[13:20:33.567]             length <- base::length
[13:20:33.567]             list <- base::list
[13:20:33.567]             seq.int <- base::seq.int
[13:20:33.567]             signalCondition <- base::signalCondition
[13:20:33.567]             sys.calls <- base::sys.calls
[13:20:33.567]             `[[` <- base::`[[`
[13:20:33.567]             `+` <- base::`+`
[13:20:33.567]             `<<-` <- base::`<<-`
[13:20:33.567]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:33.567]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:33.567]                   3L)]
[13:20:33.567]             }
[13:20:33.567]             function(cond) {
[13:20:33.567]                 is_error <- inherits(cond, "error")
[13:20:33.567]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:33.567]                   NULL)
[13:20:33.567]                 if (is_error) {
[13:20:33.567]                   sessionInformation <- function() {
[13:20:33.567]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:33.567]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:33.567]                       search = base::search(), system = base::Sys.info())
[13:20:33.567]                   }
[13:20:33.567]                   ...future.conditions[[length(...future.conditions) + 
[13:20:33.567]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:33.567]                     cond$call), session = sessionInformation(), 
[13:20:33.567]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:33.567]                   signalCondition(cond)
[13:20:33.567]                 }
[13:20:33.567]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:33.567]                 "immediateCondition"))) {
[13:20:33.567]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:33.567]                   ...future.conditions[[length(...future.conditions) + 
[13:20:33.567]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:33.567]                   if (TRUE && !signal) {
[13:20:33.567]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:33.567]                     {
[13:20:33.567]                       inherits <- base::inherits
[13:20:33.567]                       invokeRestart <- base::invokeRestart
[13:20:33.567]                       is.null <- base::is.null
[13:20:33.567]                       muffled <- FALSE
[13:20:33.567]                       if (inherits(cond, "message")) {
[13:20:33.567]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:33.567]                         if (muffled) 
[13:20:33.567]                           invokeRestart("muffleMessage")
[13:20:33.567]                       }
[13:20:33.567]                       else if (inherits(cond, "warning")) {
[13:20:33.567]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:33.567]                         if (muffled) 
[13:20:33.567]                           invokeRestart("muffleWarning")
[13:20:33.567]                       }
[13:20:33.567]                       else if (inherits(cond, "condition")) {
[13:20:33.567]                         if (!is.null(pattern)) {
[13:20:33.567]                           computeRestarts <- base::computeRestarts
[13:20:33.567]                           grepl <- base::grepl
[13:20:33.567]                           restarts <- computeRestarts(cond)
[13:20:33.567]                           for (restart in restarts) {
[13:20:33.567]                             name <- restart$name
[13:20:33.567]                             if (is.null(name)) 
[13:20:33.567]                               next
[13:20:33.567]                             if (!grepl(pattern, name)) 
[13:20:33.567]                               next
[13:20:33.567]                             invokeRestart(restart)
[13:20:33.567]                             muffled <- TRUE
[13:20:33.567]                             break
[13:20:33.567]                           }
[13:20:33.567]                         }
[13:20:33.567]                       }
[13:20:33.567]                       invisible(muffled)
[13:20:33.567]                     }
[13:20:33.567]                     muffleCondition(cond, pattern = "^muffle")
[13:20:33.567]                   }
[13:20:33.567]                 }
[13:20:33.567]                 else {
[13:20:33.567]                   if (TRUE) {
[13:20:33.567]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:33.567]                     {
[13:20:33.567]                       inherits <- base::inherits
[13:20:33.567]                       invokeRestart <- base::invokeRestart
[13:20:33.567]                       is.null <- base::is.null
[13:20:33.567]                       muffled <- FALSE
[13:20:33.567]                       if (inherits(cond, "message")) {
[13:20:33.567]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:33.567]                         if (muffled) 
[13:20:33.567]                           invokeRestart("muffleMessage")
[13:20:33.567]                       }
[13:20:33.567]                       else if (inherits(cond, "warning")) {
[13:20:33.567]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:33.567]                         if (muffled) 
[13:20:33.567]                           invokeRestart("muffleWarning")
[13:20:33.567]                       }
[13:20:33.567]                       else if (inherits(cond, "condition")) {
[13:20:33.567]                         if (!is.null(pattern)) {
[13:20:33.567]                           computeRestarts <- base::computeRestarts
[13:20:33.567]                           grepl <- base::grepl
[13:20:33.567]                           restarts <- computeRestarts(cond)
[13:20:33.567]                           for (restart in restarts) {
[13:20:33.567]                             name <- restart$name
[13:20:33.567]                             if (is.null(name)) 
[13:20:33.567]                               next
[13:20:33.567]                             if (!grepl(pattern, name)) 
[13:20:33.567]                               next
[13:20:33.567]                             invokeRestart(restart)
[13:20:33.567]                             muffled <- TRUE
[13:20:33.567]                             break
[13:20:33.567]                           }
[13:20:33.567]                         }
[13:20:33.567]                       }
[13:20:33.567]                       invisible(muffled)
[13:20:33.567]                     }
[13:20:33.567]                     muffleCondition(cond, pattern = "^muffle")
[13:20:33.567]                   }
[13:20:33.567]                 }
[13:20:33.567]             }
[13:20:33.567]         }))
[13:20:33.567]     }, error = function(ex) {
[13:20:33.567]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:33.567]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:33.567]                 ...future.rng), started = ...future.startTime, 
[13:20:33.567]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:33.567]             version = "1.8"), class = "FutureResult")
[13:20:33.567]     }, finally = {
[13:20:33.567]         if (!identical(...future.workdir, getwd())) 
[13:20:33.567]             setwd(...future.workdir)
[13:20:33.567]         {
[13:20:33.567]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:33.567]                 ...future.oldOptions$nwarnings <- NULL
[13:20:33.567]             }
[13:20:33.567]             base::options(...future.oldOptions)
[13:20:33.567]             if (.Platform$OS.type == "windows") {
[13:20:33.567]                 old_names <- names(...future.oldEnvVars)
[13:20:33.567]                 envs <- base::Sys.getenv()
[13:20:33.567]                 names <- names(envs)
[13:20:33.567]                 common <- intersect(names, old_names)
[13:20:33.567]                 added <- setdiff(names, old_names)
[13:20:33.567]                 removed <- setdiff(old_names, names)
[13:20:33.567]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:33.567]                   envs[common]]
[13:20:33.567]                 NAMES <- toupper(changed)
[13:20:33.567]                 args <- list()
[13:20:33.567]                 for (kk in seq_along(NAMES)) {
[13:20:33.567]                   name <- changed[[kk]]
[13:20:33.567]                   NAME <- NAMES[[kk]]
[13:20:33.567]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:33.567]                     next
[13:20:33.567]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:33.567]                 }
[13:20:33.567]                 NAMES <- toupper(added)
[13:20:33.567]                 for (kk in seq_along(NAMES)) {
[13:20:33.567]                   name <- added[[kk]]
[13:20:33.567]                   NAME <- NAMES[[kk]]
[13:20:33.567]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:33.567]                     next
[13:20:33.567]                   args[[name]] <- ""
[13:20:33.567]                 }
[13:20:33.567]                 NAMES <- toupper(removed)
[13:20:33.567]                 for (kk in seq_along(NAMES)) {
[13:20:33.567]                   name <- removed[[kk]]
[13:20:33.567]                   NAME <- NAMES[[kk]]
[13:20:33.567]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:33.567]                     next
[13:20:33.567]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:33.567]                 }
[13:20:33.567]                 if (length(args) > 0) 
[13:20:33.567]                   base::do.call(base::Sys.setenv, args = args)
[13:20:33.567]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:33.567]             }
[13:20:33.567]             else {
[13:20:33.567]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:33.567]             }
[13:20:33.567]             {
[13:20:33.567]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:33.567]                   0L) {
[13:20:33.567]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:33.567]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:33.567]                   base::options(opts)
[13:20:33.567]                 }
[13:20:33.567]                 {
[13:20:33.567]                   {
[13:20:33.567]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:33.567]                     NULL
[13:20:33.567]                   }
[13:20:33.567]                   options(future.plan = NULL)
[13:20:33.567]                   if (is.na(NA_character_)) 
[13:20:33.567]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:33.567]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:33.567]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:33.567]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:33.567]                     envir = parent.frame()) 
[13:20:33.567]                   {
[13:20:33.567]                     if (is.function(workers)) 
[13:20:33.567]                       workers <- workers()
[13:20:33.567]                     workers <- structure(as.integer(workers), 
[13:20:33.567]                       class = class(workers))
[13:20:33.567]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:33.567]                       workers >= 1)
[13:20:33.567]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:33.567]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:33.567]                     }
[13:20:33.567]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:33.567]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:33.567]                       envir = envir)
[13:20:33.567]                     if (!future$lazy) 
[13:20:33.567]                       future <- run(future)
[13:20:33.567]                     invisible(future)
[13:20:33.567]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:33.567]                 }
[13:20:33.567]             }
[13:20:33.567]         }
[13:20:33.567]     })
[13:20:33.567]     if (TRUE) {
[13:20:33.567]         base::sink(type = "output", split = FALSE)
[13:20:33.567]         if (TRUE) {
[13:20:33.567]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:33.567]         }
[13:20:33.567]         else {
[13:20:33.567]             ...future.result["stdout"] <- base::list(NULL)
[13:20:33.567]         }
[13:20:33.567]         base::close(...future.stdout)
[13:20:33.567]         ...future.stdout <- NULL
[13:20:33.567]     }
[13:20:33.567]     ...future.result$conditions <- ...future.conditions
[13:20:33.567]     ...future.result$finished <- base::Sys.time()
[13:20:33.567]     ...future.result
[13:20:33.567] }
[13:20:33.570] Exporting 1 global objects (96 bytes) to cluster node #1 ...
[13:20:33.570] Exporting ‘x’ (96 bytes) to cluster node #1 ...
[13:20:33.571] Exporting ‘x’ (96 bytes) to cluster node #1 ... DONE
[13:20:33.571] Exporting 1 global objects (96 bytes) to cluster node #1 ... DONE
[13:20:33.571] MultisessionFuture started
[13:20:33.572] - Launch lazy future ... done
[13:20:33.572] run() for ‘MultisessionFuture’ ... done
[13:20:33.572] result() for ClusterFuture ...
[13:20:33.572] receiveMessageFromWorker() for ClusterFuture ...
[13:20:33.572] - Validating connection of MultisessionFuture
[13:20:33.619] - received message: FutureResult
[13:20:33.619] - Received FutureResult
[13:20:33.620] - Erased future from FutureRegistry
[13:20:33.620] result() for ClusterFuture ...
[13:20:33.620] - result already collected: FutureResult
[13:20:33.620] result() for ClusterFuture ... done
[13:20:33.620] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:33.620] result() for ClusterFuture ... done
[13:20:33.620] result() for ClusterFuture ...
[13:20:33.620] - result already collected: FutureResult
[13:20:33.620] result() for ClusterFuture ... done
x
1 2 
2 3 
[13:20:33.621] getGlobalsAndPackages() ...
[13:20:33.621] Searching for globals...
[13:20:33.622] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[13:20:33.623] Searching for globals ... DONE
[13:20:33.623] Resolving globals: FALSE
[13:20:33.623] The total size of the 1 globals is 96 bytes (96 bytes)
[13:20:33.623] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[13:20:33.624] - globals: [1] ‘x’
[13:20:33.624] - packages: [1] ‘stats’
[13:20:33.624] getGlobalsAndPackages() ... DONE
[13:20:33.624] run() for ‘Future’ ...
[13:20:33.624] - state: ‘created’
[13:20:33.624] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:33.639] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:33.639] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:33.639]   - Field: ‘node’
[13:20:33.639]   - Field: ‘label’
[13:20:33.639]   - Field: ‘local’
[13:20:33.639]   - Field: ‘owner’
[13:20:33.639]   - Field: ‘envir’
[13:20:33.639]   - Field: ‘workers’
[13:20:33.639]   - Field: ‘packages’
[13:20:33.640]   - Field: ‘gc’
[13:20:33.640]   - Field: ‘conditions’
[13:20:33.640]   - Field: ‘persistent’
[13:20:33.640]   - Field: ‘expr’
[13:20:33.640]   - Field: ‘uuid’
[13:20:33.640]   - Field: ‘seed’
[13:20:33.640]   - Field: ‘version’
[13:20:33.640]   - Field: ‘result’
[13:20:33.640]   - Field: ‘asynchronous’
[13:20:33.640]   - Field: ‘calls’
[13:20:33.640]   - Field: ‘globals’
[13:20:33.641]   - Field: ‘stdout’
[13:20:33.641]   - Field: ‘earlySignal’
[13:20:33.641]   - Field: ‘lazy’
[13:20:33.641]   - Field: ‘state’
[13:20:33.641] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:33.641] - Launch lazy future ...
[13:20:33.641] Packages needed by the future expression (n = 1): ‘stats’
[13:20:33.641] Packages needed by future strategies (n = 0): <none>
[13:20:33.642] {
[13:20:33.642]     {
[13:20:33.642]         {
[13:20:33.642]             ...future.startTime <- base::Sys.time()
[13:20:33.642]             {
[13:20:33.642]                 {
[13:20:33.642]                   {
[13:20:33.642]                     {
[13:20:33.642]                       {
[13:20:33.642]                         base::local({
[13:20:33.642]                           has_future <- base::requireNamespace("future", 
[13:20:33.642]                             quietly = TRUE)
[13:20:33.642]                           if (has_future) {
[13:20:33.642]                             ns <- base::getNamespace("future")
[13:20:33.642]                             version <- ns[[".package"]][["version"]]
[13:20:33.642]                             if (is.null(version)) 
[13:20:33.642]                               version <- utils::packageVersion("future")
[13:20:33.642]                           }
[13:20:33.642]                           else {
[13:20:33.642]                             version <- NULL
[13:20:33.642]                           }
[13:20:33.642]                           if (!has_future || version < "1.8.0") {
[13:20:33.642]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:33.642]                               "", base::R.version$version.string), 
[13:20:33.642]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:33.642]                                 base::R.version$platform, 8 * 
[13:20:33.642]                                   base::.Machine$sizeof.pointer), 
[13:20:33.642]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:33.642]                                 "release", "version")], collapse = " "), 
[13:20:33.642]                               hostname = base::Sys.info()[["nodename"]])
[13:20:33.642]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:33.642]                               info)
[13:20:33.642]                             info <- base::paste(info, collapse = "; ")
[13:20:33.642]                             if (!has_future) {
[13:20:33.642]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:33.642]                                 info)
[13:20:33.642]                             }
[13:20:33.642]                             else {
[13:20:33.642]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:33.642]                                 info, version)
[13:20:33.642]                             }
[13:20:33.642]                             base::stop(msg)
[13:20:33.642]                           }
[13:20:33.642]                         })
[13:20:33.642]                       }
[13:20:33.642]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:33.642]                       base::options(mc.cores = 1L)
[13:20:33.642]                     }
[13:20:33.642]                     base::local({
[13:20:33.642]                       for (pkg in "stats") {
[13:20:33.642]                         base::loadNamespace(pkg)
[13:20:33.642]                         base::library(pkg, character.only = TRUE)
[13:20:33.642]                       }
[13:20:33.642]                     })
[13:20:33.642]                   }
[13:20:33.642]                   options(future.plan = NULL)
[13:20:33.642]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:33.642]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:33.642]                 }
[13:20:33.642]                 ...future.workdir <- getwd()
[13:20:33.642]             }
[13:20:33.642]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:33.642]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:33.642]         }
[13:20:33.642]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:33.642]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:33.642]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:33.642]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:33.642]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:33.642]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:33.642]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:33.642]             base::names(...future.oldOptions))
[13:20:33.642]     }
[13:20:33.642]     if (FALSE) {
[13:20:33.642]     }
[13:20:33.642]     else {
[13:20:33.642]         if (TRUE) {
[13:20:33.642]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:33.642]                 open = "w")
[13:20:33.642]         }
[13:20:33.642]         else {
[13:20:33.642]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:33.642]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:33.642]         }
[13:20:33.642]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:33.642]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:33.642]             base::sink(type = "output", split = FALSE)
[13:20:33.642]             base::close(...future.stdout)
[13:20:33.642]         }, add = TRUE)
[13:20:33.642]     }
[13:20:33.642]     ...future.frame <- base::sys.nframe()
[13:20:33.642]     ...future.conditions <- base::list()
[13:20:33.642]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:33.642]     if (FALSE) {
[13:20:33.642]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:33.642]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:33.642]     }
[13:20:33.642]     ...future.result <- base::tryCatch({
[13:20:33.642]         base::withCallingHandlers({
[13:20:33.642]             ...future.value <- base::withVisible(base::local({
[13:20:33.642]                 ...future.makeSendCondition <- local({
[13:20:33.642]                   sendCondition <- NULL
[13:20:33.642]                   function(frame = 1L) {
[13:20:33.642]                     if (is.function(sendCondition)) 
[13:20:33.642]                       return(sendCondition)
[13:20:33.642]                     ns <- getNamespace("parallel")
[13:20:33.642]                     if (exists("sendData", mode = "function", 
[13:20:33.642]                       envir = ns)) {
[13:20:33.642]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:33.642]                         envir = ns)
[13:20:33.642]                       envir <- sys.frame(frame)
[13:20:33.642]                       master <- NULL
[13:20:33.642]                       while (!identical(envir, .GlobalEnv) && 
[13:20:33.642]                         !identical(envir, emptyenv())) {
[13:20:33.642]                         if (exists("master", mode = "list", envir = envir, 
[13:20:33.642]                           inherits = FALSE)) {
[13:20:33.642]                           master <- get("master", mode = "list", 
[13:20:33.642]                             envir = envir, inherits = FALSE)
[13:20:33.642]                           if (inherits(master, c("SOCKnode", 
[13:20:33.642]                             "SOCK0node"))) {
[13:20:33.642]                             sendCondition <<- function(cond) {
[13:20:33.642]                               data <- list(type = "VALUE", value = cond, 
[13:20:33.642]                                 success = TRUE)
[13:20:33.642]                               parallel_sendData(master, data)
[13:20:33.642]                             }
[13:20:33.642]                             return(sendCondition)
[13:20:33.642]                           }
[13:20:33.642]                         }
[13:20:33.642]                         frame <- frame + 1L
[13:20:33.642]                         envir <- sys.frame(frame)
[13:20:33.642]                       }
[13:20:33.642]                     }
[13:20:33.642]                     sendCondition <<- function(cond) NULL
[13:20:33.642]                   }
[13:20:33.642]                 })
[13:20:33.642]                 withCallingHandlers({
[13:20:33.642]                   {
[13:20:33.642]                     xtabs(~x)
[13:20:33.642]                   }
[13:20:33.642]                 }, immediateCondition = function(cond) {
[13:20:33.642]                   sendCondition <- ...future.makeSendCondition()
[13:20:33.642]                   sendCondition(cond)
[13:20:33.642]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:33.642]                   {
[13:20:33.642]                     inherits <- base::inherits
[13:20:33.642]                     invokeRestart <- base::invokeRestart
[13:20:33.642]                     is.null <- base::is.null
[13:20:33.642]                     muffled <- FALSE
[13:20:33.642]                     if (inherits(cond, "message")) {
[13:20:33.642]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:33.642]                       if (muffled) 
[13:20:33.642]                         invokeRestart("muffleMessage")
[13:20:33.642]                     }
[13:20:33.642]                     else if (inherits(cond, "warning")) {
[13:20:33.642]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:33.642]                       if (muffled) 
[13:20:33.642]                         invokeRestart("muffleWarning")
[13:20:33.642]                     }
[13:20:33.642]                     else if (inherits(cond, "condition")) {
[13:20:33.642]                       if (!is.null(pattern)) {
[13:20:33.642]                         computeRestarts <- base::computeRestarts
[13:20:33.642]                         grepl <- base::grepl
[13:20:33.642]                         restarts <- computeRestarts(cond)
[13:20:33.642]                         for (restart in restarts) {
[13:20:33.642]                           name <- restart$name
[13:20:33.642]                           if (is.null(name)) 
[13:20:33.642]                             next
[13:20:33.642]                           if (!grepl(pattern, name)) 
[13:20:33.642]                             next
[13:20:33.642]                           invokeRestart(restart)
[13:20:33.642]                           muffled <- TRUE
[13:20:33.642]                           break
[13:20:33.642]                         }
[13:20:33.642]                       }
[13:20:33.642]                     }
[13:20:33.642]                     invisible(muffled)
[13:20:33.642]                   }
[13:20:33.642]                   muffleCondition(cond)
[13:20:33.642]                 })
[13:20:33.642]             }))
[13:20:33.642]             future::FutureResult(value = ...future.value$value, 
[13:20:33.642]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:33.642]                   ...future.rng), globalenv = if (FALSE) 
[13:20:33.642]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:33.642]                     ...future.globalenv.names))
[13:20:33.642]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:33.642]         }, condition = base::local({
[13:20:33.642]             c <- base::c
[13:20:33.642]             inherits <- base::inherits
[13:20:33.642]             invokeRestart <- base::invokeRestart
[13:20:33.642]             length <- base::length
[13:20:33.642]             list <- base::list
[13:20:33.642]             seq.int <- base::seq.int
[13:20:33.642]             signalCondition <- base::signalCondition
[13:20:33.642]             sys.calls <- base::sys.calls
[13:20:33.642]             `[[` <- base::`[[`
[13:20:33.642]             `+` <- base::`+`
[13:20:33.642]             `<<-` <- base::`<<-`
[13:20:33.642]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:33.642]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:33.642]                   3L)]
[13:20:33.642]             }
[13:20:33.642]             function(cond) {
[13:20:33.642]                 is_error <- inherits(cond, "error")
[13:20:33.642]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:33.642]                   NULL)
[13:20:33.642]                 if (is_error) {
[13:20:33.642]                   sessionInformation <- function() {
[13:20:33.642]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:33.642]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:33.642]                       search = base::search(), system = base::Sys.info())
[13:20:33.642]                   }
[13:20:33.642]                   ...future.conditions[[length(...future.conditions) + 
[13:20:33.642]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:33.642]                     cond$call), session = sessionInformation(), 
[13:20:33.642]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:33.642]                   signalCondition(cond)
[13:20:33.642]                 }
[13:20:33.642]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:33.642]                 "immediateCondition"))) {
[13:20:33.642]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:33.642]                   ...future.conditions[[length(...future.conditions) + 
[13:20:33.642]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:33.642]                   if (TRUE && !signal) {
[13:20:33.642]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:33.642]                     {
[13:20:33.642]                       inherits <- base::inherits
[13:20:33.642]                       invokeRestart <- base::invokeRestart
[13:20:33.642]                       is.null <- base::is.null
[13:20:33.642]                       muffled <- FALSE
[13:20:33.642]                       if (inherits(cond, "message")) {
[13:20:33.642]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:33.642]                         if (muffled) 
[13:20:33.642]                           invokeRestart("muffleMessage")
[13:20:33.642]                       }
[13:20:33.642]                       else if (inherits(cond, "warning")) {
[13:20:33.642]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:33.642]                         if (muffled) 
[13:20:33.642]                           invokeRestart("muffleWarning")
[13:20:33.642]                       }
[13:20:33.642]                       else if (inherits(cond, "condition")) {
[13:20:33.642]                         if (!is.null(pattern)) {
[13:20:33.642]                           computeRestarts <- base::computeRestarts
[13:20:33.642]                           grepl <- base::grepl
[13:20:33.642]                           restarts <- computeRestarts(cond)
[13:20:33.642]                           for (restart in restarts) {
[13:20:33.642]                             name <- restart$name
[13:20:33.642]                             if (is.null(name)) 
[13:20:33.642]                               next
[13:20:33.642]                             if (!grepl(pattern, name)) 
[13:20:33.642]                               next
[13:20:33.642]                             invokeRestart(restart)
[13:20:33.642]                             muffled <- TRUE
[13:20:33.642]                             break
[13:20:33.642]                           }
[13:20:33.642]                         }
[13:20:33.642]                       }
[13:20:33.642]                       invisible(muffled)
[13:20:33.642]                     }
[13:20:33.642]                     muffleCondition(cond, pattern = "^muffle")
[13:20:33.642]                   }
[13:20:33.642]                 }
[13:20:33.642]                 else {
[13:20:33.642]                   if (TRUE) {
[13:20:33.642]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:33.642]                     {
[13:20:33.642]                       inherits <- base::inherits
[13:20:33.642]                       invokeRestart <- base::invokeRestart
[13:20:33.642]                       is.null <- base::is.null
[13:20:33.642]                       muffled <- FALSE
[13:20:33.642]                       if (inherits(cond, "message")) {
[13:20:33.642]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:33.642]                         if (muffled) 
[13:20:33.642]                           invokeRestart("muffleMessage")
[13:20:33.642]                       }
[13:20:33.642]                       else if (inherits(cond, "warning")) {
[13:20:33.642]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:33.642]                         if (muffled) 
[13:20:33.642]                           invokeRestart("muffleWarning")
[13:20:33.642]                       }
[13:20:33.642]                       else if (inherits(cond, "condition")) {
[13:20:33.642]                         if (!is.null(pattern)) {
[13:20:33.642]                           computeRestarts <- base::computeRestarts
[13:20:33.642]                           grepl <- base::grepl
[13:20:33.642]                           restarts <- computeRestarts(cond)
[13:20:33.642]                           for (restart in restarts) {
[13:20:33.642]                             name <- restart$name
[13:20:33.642]                             if (is.null(name)) 
[13:20:33.642]                               next
[13:20:33.642]                             if (!grepl(pattern, name)) 
[13:20:33.642]                               next
[13:20:33.642]                             invokeRestart(restart)
[13:20:33.642]                             muffled <- TRUE
[13:20:33.642]                             break
[13:20:33.642]                           }
[13:20:33.642]                         }
[13:20:33.642]                       }
[13:20:33.642]                       invisible(muffled)
[13:20:33.642]                     }
[13:20:33.642]                     muffleCondition(cond, pattern = "^muffle")
[13:20:33.642]                   }
[13:20:33.642]                 }
[13:20:33.642]             }
[13:20:33.642]         }))
[13:20:33.642]     }, error = function(ex) {
[13:20:33.642]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:33.642]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:33.642]                 ...future.rng), started = ...future.startTime, 
[13:20:33.642]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:33.642]             version = "1.8"), class = "FutureResult")
[13:20:33.642]     }, finally = {
[13:20:33.642]         if (!identical(...future.workdir, getwd())) 
[13:20:33.642]             setwd(...future.workdir)
[13:20:33.642]         {
[13:20:33.642]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:33.642]                 ...future.oldOptions$nwarnings <- NULL
[13:20:33.642]             }
[13:20:33.642]             base::options(...future.oldOptions)
[13:20:33.642]             if (.Platform$OS.type == "windows") {
[13:20:33.642]                 old_names <- names(...future.oldEnvVars)
[13:20:33.642]                 envs <- base::Sys.getenv()
[13:20:33.642]                 names <- names(envs)
[13:20:33.642]                 common <- intersect(names, old_names)
[13:20:33.642]                 added <- setdiff(names, old_names)
[13:20:33.642]                 removed <- setdiff(old_names, names)
[13:20:33.642]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:33.642]                   envs[common]]
[13:20:33.642]                 NAMES <- toupper(changed)
[13:20:33.642]                 args <- list()
[13:20:33.642]                 for (kk in seq_along(NAMES)) {
[13:20:33.642]                   name <- changed[[kk]]
[13:20:33.642]                   NAME <- NAMES[[kk]]
[13:20:33.642]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:33.642]                     next
[13:20:33.642]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:33.642]                 }
[13:20:33.642]                 NAMES <- toupper(added)
[13:20:33.642]                 for (kk in seq_along(NAMES)) {
[13:20:33.642]                   name <- added[[kk]]
[13:20:33.642]                   NAME <- NAMES[[kk]]
[13:20:33.642]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:33.642]                     next
[13:20:33.642]                   args[[name]] <- ""
[13:20:33.642]                 }
[13:20:33.642]                 NAMES <- toupper(removed)
[13:20:33.642]                 for (kk in seq_along(NAMES)) {
[13:20:33.642]                   name <- removed[[kk]]
[13:20:33.642]                   NAME <- NAMES[[kk]]
[13:20:33.642]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:33.642]                     next
[13:20:33.642]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:33.642]                 }
[13:20:33.642]                 if (length(args) > 0) 
[13:20:33.642]                   base::do.call(base::Sys.setenv, args = args)
[13:20:33.642]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:33.642]             }
[13:20:33.642]             else {
[13:20:33.642]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:33.642]             }
[13:20:33.642]             {
[13:20:33.642]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:33.642]                   0L) {
[13:20:33.642]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:33.642]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:33.642]                   base::options(opts)
[13:20:33.642]                 }
[13:20:33.642]                 {
[13:20:33.642]                   {
[13:20:33.642]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:33.642]                     NULL
[13:20:33.642]                   }
[13:20:33.642]                   options(future.plan = NULL)
[13:20:33.642]                   if (is.na(NA_character_)) 
[13:20:33.642]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:33.642]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:33.642]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:33.642]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:33.642]                     envir = parent.frame()) 
[13:20:33.642]                   {
[13:20:33.642]                     if (is.function(workers)) 
[13:20:33.642]                       workers <- workers()
[13:20:33.642]                     workers <- structure(as.integer(workers), 
[13:20:33.642]                       class = class(workers))
[13:20:33.642]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:33.642]                       workers >= 1)
[13:20:33.642]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:33.642]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:33.642]                     }
[13:20:33.642]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:33.642]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:33.642]                       envir = envir)
[13:20:33.642]                     if (!future$lazy) 
[13:20:33.642]                       future <- run(future)
[13:20:33.642]                     invisible(future)
[13:20:33.642]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:33.642]                 }
[13:20:33.642]             }
[13:20:33.642]         }
[13:20:33.642]     })
[13:20:33.642]     if (TRUE) {
[13:20:33.642]         base::sink(type = "output", split = FALSE)
[13:20:33.642]         if (TRUE) {
[13:20:33.642]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:33.642]         }
[13:20:33.642]         else {
[13:20:33.642]             ...future.result["stdout"] <- base::list(NULL)
[13:20:33.642]         }
[13:20:33.642]         base::close(...future.stdout)
[13:20:33.642]         ...future.stdout <- NULL
[13:20:33.642]     }
[13:20:33.642]     ...future.result$conditions <- ...future.conditions
[13:20:33.642]     ...future.result$finished <- base::Sys.time()
[13:20:33.642]     ...future.result
[13:20:33.642] }
[13:20:33.645] Exporting 1 global objects (96 bytes) to cluster node #1 ...
[13:20:33.645] Exporting ‘x’ (96 bytes) to cluster node #1 ...
[13:20:33.645] Exporting ‘x’ (96 bytes) to cluster node #1 ... DONE
[13:20:33.645] Exporting 1 global objects (96 bytes) to cluster node #1 ... DONE
[13:20:33.646] MultisessionFuture started
[13:20:33.646] - Launch lazy future ... done
[13:20:33.646] run() for ‘MultisessionFuture’ ... done
[13:20:33.646] result() for ClusterFuture ...
[13:20:33.647] receiveMessageFromWorker() for ClusterFuture ...
[13:20:33.647] - Validating connection of MultisessionFuture
[13:20:33.694] - received message: FutureResult
[13:20:33.694] - Received FutureResult
[13:20:33.695] - Erased future from FutureRegistry
[13:20:33.695] result() for ClusterFuture ...
[13:20:33.695] - result already collected: FutureResult
[13:20:33.695] result() for ClusterFuture ... done
[13:20:33.695] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:33.695] result() for ClusterFuture ... done
[13:20:33.695] result() for ClusterFuture ...
[13:20:33.695] - result already collected: FutureResult
[13:20:33.695] result() for ClusterFuture ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[13:20:33.697] getGlobalsAndPackages() ...
[13:20:33.697] Searching for globals...
[13:20:33.699] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[13:20:33.699] Searching for globals ... DONE
[13:20:33.699] Resolving globals: FALSE
[13:20:33.699] 
[13:20:33.699] - packages: [2] ‘stats’, ‘datasets’
[13:20:33.700] getGlobalsAndPackages() ... DONE
[13:20:33.700] run() for ‘Future’ ...
[13:20:33.700] - state: ‘created’
[13:20:33.700] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:33.715] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:33.715] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:33.715]   - Field: ‘node’
[13:20:33.715]   - Field: ‘label’
[13:20:33.715]   - Field: ‘local’
[13:20:33.715]   - Field: ‘owner’
[13:20:33.715]   - Field: ‘envir’
[13:20:33.716]   - Field: ‘workers’
[13:20:33.716]   - Field: ‘packages’
[13:20:33.716]   - Field: ‘gc’
[13:20:33.716]   - Field: ‘conditions’
[13:20:33.716]   - Field: ‘persistent’
[13:20:33.716]   - Field: ‘expr’
[13:20:33.716]   - Field: ‘uuid’
[13:20:33.716]   - Field: ‘seed’
[13:20:33.716]   - Field: ‘version’
[13:20:33.716]   - Field: ‘result’
[13:20:33.716]   - Field: ‘asynchronous’
[13:20:33.717]   - Field: ‘calls’
[13:20:33.717]   - Field: ‘globals’
[13:20:33.717]   - Field: ‘stdout’
[13:20:33.717]   - Field: ‘earlySignal’
[13:20:33.717]   - Field: ‘lazy’
[13:20:33.717]   - Field: ‘state’
[13:20:33.717] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:33.717] - Launch lazy future ...
[13:20:33.717] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:20:33.718] Packages needed by future strategies (n = 0): <none>
[13:20:33.718] {
[13:20:33.718]     {
[13:20:33.718]         {
[13:20:33.718]             ...future.startTime <- base::Sys.time()
[13:20:33.718]             {
[13:20:33.718]                 {
[13:20:33.718]                   {
[13:20:33.718]                     {
[13:20:33.718]                       {
[13:20:33.718]                         base::local({
[13:20:33.718]                           has_future <- base::requireNamespace("future", 
[13:20:33.718]                             quietly = TRUE)
[13:20:33.718]                           if (has_future) {
[13:20:33.718]                             ns <- base::getNamespace("future")
[13:20:33.718]                             version <- ns[[".package"]][["version"]]
[13:20:33.718]                             if (is.null(version)) 
[13:20:33.718]                               version <- utils::packageVersion("future")
[13:20:33.718]                           }
[13:20:33.718]                           else {
[13:20:33.718]                             version <- NULL
[13:20:33.718]                           }
[13:20:33.718]                           if (!has_future || version < "1.8.0") {
[13:20:33.718]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:33.718]                               "", base::R.version$version.string), 
[13:20:33.718]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:33.718]                                 base::R.version$platform, 8 * 
[13:20:33.718]                                   base::.Machine$sizeof.pointer), 
[13:20:33.718]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:33.718]                                 "release", "version")], collapse = " "), 
[13:20:33.718]                               hostname = base::Sys.info()[["nodename"]])
[13:20:33.718]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:33.718]                               info)
[13:20:33.718]                             info <- base::paste(info, collapse = "; ")
[13:20:33.718]                             if (!has_future) {
[13:20:33.718]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:33.718]                                 info)
[13:20:33.718]                             }
[13:20:33.718]                             else {
[13:20:33.718]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:33.718]                                 info, version)
[13:20:33.718]                             }
[13:20:33.718]                             base::stop(msg)
[13:20:33.718]                           }
[13:20:33.718]                         })
[13:20:33.718]                       }
[13:20:33.718]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:33.718]                       base::options(mc.cores = 1L)
[13:20:33.718]                     }
[13:20:33.718]                     base::local({
[13:20:33.718]                       for (pkg in c("stats", "datasets")) {
[13:20:33.718]                         base::loadNamespace(pkg)
[13:20:33.718]                         base::library(pkg, character.only = TRUE)
[13:20:33.718]                       }
[13:20:33.718]                     })
[13:20:33.718]                   }
[13:20:33.718]                   options(future.plan = NULL)
[13:20:33.718]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:33.718]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:33.718]                 }
[13:20:33.718]                 ...future.workdir <- getwd()
[13:20:33.718]             }
[13:20:33.718]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:33.718]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:33.718]         }
[13:20:33.718]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:33.718]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:33.718]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:33.718]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:33.718]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:33.718]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:33.718]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:33.718]             base::names(...future.oldOptions))
[13:20:33.718]     }
[13:20:33.718]     if (FALSE) {
[13:20:33.718]     }
[13:20:33.718]     else {
[13:20:33.718]         if (TRUE) {
[13:20:33.718]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:33.718]                 open = "w")
[13:20:33.718]         }
[13:20:33.718]         else {
[13:20:33.718]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:33.718]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:33.718]         }
[13:20:33.718]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:33.718]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:33.718]             base::sink(type = "output", split = FALSE)
[13:20:33.718]             base::close(...future.stdout)
[13:20:33.718]         }, add = TRUE)
[13:20:33.718]     }
[13:20:33.718]     ...future.frame <- base::sys.nframe()
[13:20:33.718]     ...future.conditions <- base::list()
[13:20:33.718]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:33.718]     if (FALSE) {
[13:20:33.718]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:33.718]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:33.718]     }
[13:20:33.718]     ...future.result <- base::tryCatch({
[13:20:33.718]         base::withCallingHandlers({
[13:20:33.718]             ...future.value <- base::withVisible(base::local({
[13:20:33.718]                 ...future.makeSendCondition <- local({
[13:20:33.718]                   sendCondition <- NULL
[13:20:33.718]                   function(frame = 1L) {
[13:20:33.718]                     if (is.function(sendCondition)) 
[13:20:33.718]                       return(sendCondition)
[13:20:33.718]                     ns <- getNamespace("parallel")
[13:20:33.718]                     if (exists("sendData", mode = "function", 
[13:20:33.718]                       envir = ns)) {
[13:20:33.718]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:33.718]                         envir = ns)
[13:20:33.718]                       envir <- sys.frame(frame)
[13:20:33.718]                       master <- NULL
[13:20:33.718]                       while (!identical(envir, .GlobalEnv) && 
[13:20:33.718]                         !identical(envir, emptyenv())) {
[13:20:33.718]                         if (exists("master", mode = "list", envir = envir, 
[13:20:33.718]                           inherits = FALSE)) {
[13:20:33.718]                           master <- get("master", mode = "list", 
[13:20:33.718]                             envir = envir, inherits = FALSE)
[13:20:33.718]                           if (inherits(master, c("SOCKnode", 
[13:20:33.718]                             "SOCK0node"))) {
[13:20:33.718]                             sendCondition <<- function(cond) {
[13:20:33.718]                               data <- list(type = "VALUE", value = cond, 
[13:20:33.718]                                 success = TRUE)
[13:20:33.718]                               parallel_sendData(master, data)
[13:20:33.718]                             }
[13:20:33.718]                             return(sendCondition)
[13:20:33.718]                           }
[13:20:33.718]                         }
[13:20:33.718]                         frame <- frame + 1L
[13:20:33.718]                         envir <- sys.frame(frame)
[13:20:33.718]                       }
[13:20:33.718]                     }
[13:20:33.718]                     sendCondition <<- function(cond) NULL
[13:20:33.718]                   }
[13:20:33.718]                 })
[13:20:33.718]                 withCallingHandlers({
[13:20:33.718]                   {
[13:20:33.718]                     lm(dist ~ . - 1, data = cars)
[13:20:33.718]                   }
[13:20:33.718]                 }, immediateCondition = function(cond) {
[13:20:33.718]                   sendCondition <- ...future.makeSendCondition()
[13:20:33.718]                   sendCondition(cond)
[13:20:33.718]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:33.718]                   {
[13:20:33.718]                     inherits <- base::inherits
[13:20:33.718]                     invokeRestart <- base::invokeRestart
[13:20:33.718]                     is.null <- base::is.null
[13:20:33.718]                     muffled <- FALSE
[13:20:33.718]                     if (inherits(cond, "message")) {
[13:20:33.718]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:33.718]                       if (muffled) 
[13:20:33.718]                         invokeRestart("muffleMessage")
[13:20:33.718]                     }
[13:20:33.718]                     else if (inherits(cond, "warning")) {
[13:20:33.718]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:33.718]                       if (muffled) 
[13:20:33.718]                         invokeRestart("muffleWarning")
[13:20:33.718]                     }
[13:20:33.718]                     else if (inherits(cond, "condition")) {
[13:20:33.718]                       if (!is.null(pattern)) {
[13:20:33.718]                         computeRestarts <- base::computeRestarts
[13:20:33.718]                         grepl <- base::grepl
[13:20:33.718]                         restarts <- computeRestarts(cond)
[13:20:33.718]                         for (restart in restarts) {
[13:20:33.718]                           name <- restart$name
[13:20:33.718]                           if (is.null(name)) 
[13:20:33.718]                             next
[13:20:33.718]                           if (!grepl(pattern, name)) 
[13:20:33.718]                             next
[13:20:33.718]                           invokeRestart(restart)
[13:20:33.718]                           muffled <- TRUE
[13:20:33.718]                           break
[13:20:33.718]                         }
[13:20:33.718]                       }
[13:20:33.718]                     }
[13:20:33.718]                     invisible(muffled)
[13:20:33.718]                   }
[13:20:33.718]                   muffleCondition(cond)
[13:20:33.718]                 })
[13:20:33.718]             }))
[13:20:33.718]             future::FutureResult(value = ...future.value$value, 
[13:20:33.718]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:33.718]                   ...future.rng), globalenv = if (FALSE) 
[13:20:33.718]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:33.718]                     ...future.globalenv.names))
[13:20:33.718]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:33.718]         }, condition = base::local({
[13:20:33.718]             c <- base::c
[13:20:33.718]             inherits <- base::inherits
[13:20:33.718]             invokeRestart <- base::invokeRestart
[13:20:33.718]             length <- base::length
[13:20:33.718]             list <- base::list
[13:20:33.718]             seq.int <- base::seq.int
[13:20:33.718]             signalCondition <- base::signalCondition
[13:20:33.718]             sys.calls <- base::sys.calls
[13:20:33.718]             `[[` <- base::`[[`
[13:20:33.718]             `+` <- base::`+`
[13:20:33.718]             `<<-` <- base::`<<-`
[13:20:33.718]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:33.718]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:33.718]                   3L)]
[13:20:33.718]             }
[13:20:33.718]             function(cond) {
[13:20:33.718]                 is_error <- inherits(cond, "error")
[13:20:33.718]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:33.718]                   NULL)
[13:20:33.718]                 if (is_error) {
[13:20:33.718]                   sessionInformation <- function() {
[13:20:33.718]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:33.718]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:33.718]                       search = base::search(), system = base::Sys.info())
[13:20:33.718]                   }
[13:20:33.718]                   ...future.conditions[[length(...future.conditions) + 
[13:20:33.718]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:33.718]                     cond$call), session = sessionInformation(), 
[13:20:33.718]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:33.718]                   signalCondition(cond)
[13:20:33.718]                 }
[13:20:33.718]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:33.718]                 "immediateCondition"))) {
[13:20:33.718]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:33.718]                   ...future.conditions[[length(...future.conditions) + 
[13:20:33.718]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:33.718]                   if (TRUE && !signal) {
[13:20:33.718]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:33.718]                     {
[13:20:33.718]                       inherits <- base::inherits
[13:20:33.718]                       invokeRestart <- base::invokeRestart
[13:20:33.718]                       is.null <- base::is.null
[13:20:33.718]                       muffled <- FALSE
[13:20:33.718]                       if (inherits(cond, "message")) {
[13:20:33.718]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:33.718]                         if (muffled) 
[13:20:33.718]                           invokeRestart("muffleMessage")
[13:20:33.718]                       }
[13:20:33.718]                       else if (inherits(cond, "warning")) {
[13:20:33.718]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:33.718]                         if (muffled) 
[13:20:33.718]                           invokeRestart("muffleWarning")
[13:20:33.718]                       }
[13:20:33.718]                       else if (inherits(cond, "condition")) {
[13:20:33.718]                         if (!is.null(pattern)) {
[13:20:33.718]                           computeRestarts <- base::computeRestarts
[13:20:33.718]                           grepl <- base::grepl
[13:20:33.718]                           restarts <- computeRestarts(cond)
[13:20:33.718]                           for (restart in restarts) {
[13:20:33.718]                             name <- restart$name
[13:20:33.718]                             if (is.null(name)) 
[13:20:33.718]                               next
[13:20:33.718]                             if (!grepl(pattern, name)) 
[13:20:33.718]                               next
[13:20:33.718]                             invokeRestart(restart)
[13:20:33.718]                             muffled <- TRUE
[13:20:33.718]                             break
[13:20:33.718]                           }
[13:20:33.718]                         }
[13:20:33.718]                       }
[13:20:33.718]                       invisible(muffled)
[13:20:33.718]                     }
[13:20:33.718]                     muffleCondition(cond, pattern = "^muffle")
[13:20:33.718]                   }
[13:20:33.718]                 }
[13:20:33.718]                 else {
[13:20:33.718]                   if (TRUE) {
[13:20:33.718]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:33.718]                     {
[13:20:33.718]                       inherits <- base::inherits
[13:20:33.718]                       invokeRestart <- base::invokeRestart
[13:20:33.718]                       is.null <- base::is.null
[13:20:33.718]                       muffled <- FALSE
[13:20:33.718]                       if (inherits(cond, "message")) {
[13:20:33.718]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:33.718]                         if (muffled) 
[13:20:33.718]                           invokeRestart("muffleMessage")
[13:20:33.718]                       }
[13:20:33.718]                       else if (inherits(cond, "warning")) {
[13:20:33.718]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:33.718]                         if (muffled) 
[13:20:33.718]                           invokeRestart("muffleWarning")
[13:20:33.718]                       }
[13:20:33.718]                       else if (inherits(cond, "condition")) {
[13:20:33.718]                         if (!is.null(pattern)) {
[13:20:33.718]                           computeRestarts <- base::computeRestarts
[13:20:33.718]                           grepl <- base::grepl
[13:20:33.718]                           restarts <- computeRestarts(cond)
[13:20:33.718]                           for (restart in restarts) {
[13:20:33.718]                             name <- restart$name
[13:20:33.718]                             if (is.null(name)) 
[13:20:33.718]                               next
[13:20:33.718]                             if (!grepl(pattern, name)) 
[13:20:33.718]                               next
[13:20:33.718]                             invokeRestart(restart)
[13:20:33.718]                             muffled <- TRUE
[13:20:33.718]                             break
[13:20:33.718]                           }
[13:20:33.718]                         }
[13:20:33.718]                       }
[13:20:33.718]                       invisible(muffled)
[13:20:33.718]                     }
[13:20:33.718]                     muffleCondition(cond, pattern = "^muffle")
[13:20:33.718]                   }
[13:20:33.718]                 }
[13:20:33.718]             }
[13:20:33.718]         }))
[13:20:33.718]     }, error = function(ex) {
[13:20:33.718]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:33.718]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:33.718]                 ...future.rng), started = ...future.startTime, 
[13:20:33.718]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:33.718]             version = "1.8"), class = "FutureResult")
[13:20:33.718]     }, finally = {
[13:20:33.718]         if (!identical(...future.workdir, getwd())) 
[13:20:33.718]             setwd(...future.workdir)
[13:20:33.718]         {
[13:20:33.718]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:33.718]                 ...future.oldOptions$nwarnings <- NULL
[13:20:33.718]             }
[13:20:33.718]             base::options(...future.oldOptions)
[13:20:33.718]             if (.Platform$OS.type == "windows") {
[13:20:33.718]                 old_names <- names(...future.oldEnvVars)
[13:20:33.718]                 envs <- base::Sys.getenv()
[13:20:33.718]                 names <- names(envs)
[13:20:33.718]                 common <- intersect(names, old_names)
[13:20:33.718]                 added <- setdiff(names, old_names)
[13:20:33.718]                 removed <- setdiff(old_names, names)
[13:20:33.718]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:33.718]                   envs[common]]
[13:20:33.718]                 NAMES <- toupper(changed)
[13:20:33.718]                 args <- list()
[13:20:33.718]                 for (kk in seq_along(NAMES)) {
[13:20:33.718]                   name <- changed[[kk]]
[13:20:33.718]                   NAME <- NAMES[[kk]]
[13:20:33.718]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:33.718]                     next
[13:20:33.718]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:33.718]                 }
[13:20:33.718]                 NAMES <- toupper(added)
[13:20:33.718]                 for (kk in seq_along(NAMES)) {
[13:20:33.718]                   name <- added[[kk]]
[13:20:33.718]                   NAME <- NAMES[[kk]]
[13:20:33.718]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:33.718]                     next
[13:20:33.718]                   args[[name]] <- ""
[13:20:33.718]                 }
[13:20:33.718]                 NAMES <- toupper(removed)
[13:20:33.718]                 for (kk in seq_along(NAMES)) {
[13:20:33.718]                   name <- removed[[kk]]
[13:20:33.718]                   NAME <- NAMES[[kk]]
[13:20:33.718]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:33.718]                     next
[13:20:33.718]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:33.718]                 }
[13:20:33.718]                 if (length(args) > 0) 
[13:20:33.718]                   base::do.call(base::Sys.setenv, args = args)
[13:20:33.718]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:33.718]             }
[13:20:33.718]             else {
[13:20:33.718]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:33.718]             }
[13:20:33.718]             {
[13:20:33.718]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:33.718]                   0L) {
[13:20:33.718]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:33.718]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:33.718]                   base::options(opts)
[13:20:33.718]                 }
[13:20:33.718]                 {
[13:20:33.718]                   {
[13:20:33.718]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:33.718]                     NULL
[13:20:33.718]                   }
[13:20:33.718]                   options(future.plan = NULL)
[13:20:33.718]                   if (is.na(NA_character_)) 
[13:20:33.718]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:33.718]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:33.718]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:33.718]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:33.718]                     envir = parent.frame()) 
[13:20:33.718]                   {
[13:20:33.718]                     if (is.function(workers)) 
[13:20:33.718]                       workers <- workers()
[13:20:33.718]                     workers <- structure(as.integer(workers), 
[13:20:33.718]                       class = class(workers))
[13:20:33.718]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:33.718]                       workers >= 1)
[13:20:33.718]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:33.718]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:33.718]                     }
[13:20:33.718]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:33.718]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:33.718]                       envir = envir)
[13:20:33.718]                     if (!future$lazy) 
[13:20:33.718]                       future <- run(future)
[13:20:33.718]                     invisible(future)
[13:20:33.718]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:33.718]                 }
[13:20:33.718]             }
[13:20:33.718]         }
[13:20:33.718]     })
[13:20:33.718]     if (TRUE) {
[13:20:33.718]         base::sink(type = "output", split = FALSE)
[13:20:33.718]         if (TRUE) {
[13:20:33.718]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:33.718]         }
[13:20:33.718]         else {
[13:20:33.718]             ...future.result["stdout"] <- base::list(NULL)
[13:20:33.718]         }
[13:20:33.718]         base::close(...future.stdout)
[13:20:33.718]         ...future.stdout <- NULL
[13:20:33.718]     }
[13:20:33.718]     ...future.result$conditions <- ...future.conditions
[13:20:33.718]     ...future.result$finished <- base::Sys.time()
[13:20:33.718]     ...future.result
[13:20:33.718] }
[13:20:33.722] MultisessionFuture started
[13:20:33.722] - Launch lazy future ... done
[13:20:33.722] run() for ‘MultisessionFuture’ ... done
[13:20:33.722] result() for ClusterFuture ...
[13:20:33.722] receiveMessageFromWorker() for ClusterFuture ...
[13:20:33.722] - Validating connection of MultisessionFuture
[13:20:33.773] - received message: FutureResult
[13:20:33.773] - Received FutureResult
[13:20:33.773] - Erased future from FutureRegistry
[13:20:33.773] result() for ClusterFuture ...
[13:20:33.774] - result already collected: FutureResult
[13:20:33.774] result() for ClusterFuture ... done
[13:20:33.774] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:33.774] result() for ClusterFuture ... done
[13:20:33.774] result() for ClusterFuture ...
[13:20:33.774] - result already collected: FutureResult
[13:20:33.774] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[13:20:33.779] getGlobalsAndPackages() ...
[13:20:33.779] Searching for globals...
[13:20:33.780] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[13:20:33.780] Searching for globals ... DONE
[13:20:33.781] Resolving globals: FALSE
[13:20:33.781] 
[13:20:33.781] - packages: [2] ‘stats’, ‘datasets’
[13:20:33.781] getGlobalsAndPackages() ... DONE
[13:20:33.782] run() for ‘Future’ ...
[13:20:33.782] - state: ‘created’
[13:20:33.782] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:33.796] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:33.796] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:33.796]   - Field: ‘node’
[13:20:33.796]   - Field: ‘label’
[13:20:33.796]   - Field: ‘local’
[13:20:33.797]   - Field: ‘owner’
[13:20:33.797]   - Field: ‘envir’
[13:20:33.797]   - Field: ‘workers’
[13:20:33.797]   - Field: ‘packages’
[13:20:33.797]   - Field: ‘gc’
[13:20:33.797]   - Field: ‘conditions’
[13:20:33.797]   - Field: ‘persistent’
[13:20:33.797]   - Field: ‘expr’
[13:20:33.797]   - Field: ‘uuid’
[13:20:33.797]   - Field: ‘seed’
[13:20:33.798]   - Field: ‘version’
[13:20:33.798]   - Field: ‘result’
[13:20:33.798]   - Field: ‘asynchronous’
[13:20:33.798]   - Field: ‘calls’
[13:20:33.798]   - Field: ‘globals’
[13:20:33.798]   - Field: ‘stdout’
[13:20:33.798]   - Field: ‘earlySignal’
[13:20:33.798]   - Field: ‘lazy’
[13:20:33.798]   - Field: ‘state’
[13:20:33.798] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:33.798] - Launch lazy future ...
[13:20:33.799] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:20:33.799] Packages needed by future strategies (n = 0): <none>
[13:20:33.799] {
[13:20:33.799]     {
[13:20:33.799]         {
[13:20:33.799]             ...future.startTime <- base::Sys.time()
[13:20:33.799]             {
[13:20:33.799]                 {
[13:20:33.799]                   {
[13:20:33.799]                     {
[13:20:33.799]                       {
[13:20:33.799]                         base::local({
[13:20:33.799]                           has_future <- base::requireNamespace("future", 
[13:20:33.799]                             quietly = TRUE)
[13:20:33.799]                           if (has_future) {
[13:20:33.799]                             ns <- base::getNamespace("future")
[13:20:33.799]                             version <- ns[[".package"]][["version"]]
[13:20:33.799]                             if (is.null(version)) 
[13:20:33.799]                               version <- utils::packageVersion("future")
[13:20:33.799]                           }
[13:20:33.799]                           else {
[13:20:33.799]                             version <- NULL
[13:20:33.799]                           }
[13:20:33.799]                           if (!has_future || version < "1.8.0") {
[13:20:33.799]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:33.799]                               "", base::R.version$version.string), 
[13:20:33.799]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:33.799]                                 base::R.version$platform, 8 * 
[13:20:33.799]                                   base::.Machine$sizeof.pointer), 
[13:20:33.799]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:33.799]                                 "release", "version")], collapse = " "), 
[13:20:33.799]                               hostname = base::Sys.info()[["nodename"]])
[13:20:33.799]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:33.799]                               info)
[13:20:33.799]                             info <- base::paste(info, collapse = "; ")
[13:20:33.799]                             if (!has_future) {
[13:20:33.799]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:33.799]                                 info)
[13:20:33.799]                             }
[13:20:33.799]                             else {
[13:20:33.799]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:33.799]                                 info, version)
[13:20:33.799]                             }
[13:20:33.799]                             base::stop(msg)
[13:20:33.799]                           }
[13:20:33.799]                         })
[13:20:33.799]                       }
[13:20:33.799]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:33.799]                       base::options(mc.cores = 1L)
[13:20:33.799]                     }
[13:20:33.799]                     base::local({
[13:20:33.799]                       for (pkg in c("stats", "datasets")) {
[13:20:33.799]                         base::loadNamespace(pkg)
[13:20:33.799]                         base::library(pkg, character.only = TRUE)
[13:20:33.799]                       }
[13:20:33.799]                     })
[13:20:33.799]                   }
[13:20:33.799]                   options(future.plan = NULL)
[13:20:33.799]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:33.799]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:33.799]                 }
[13:20:33.799]                 ...future.workdir <- getwd()
[13:20:33.799]             }
[13:20:33.799]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:33.799]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:33.799]         }
[13:20:33.799]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:33.799]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:33.799]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:33.799]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:33.799]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:33.799]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:33.799]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:33.799]             base::names(...future.oldOptions))
[13:20:33.799]     }
[13:20:33.799]     if (FALSE) {
[13:20:33.799]     }
[13:20:33.799]     else {
[13:20:33.799]         if (TRUE) {
[13:20:33.799]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:33.799]                 open = "w")
[13:20:33.799]         }
[13:20:33.799]         else {
[13:20:33.799]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:33.799]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:33.799]         }
[13:20:33.799]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:33.799]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:33.799]             base::sink(type = "output", split = FALSE)
[13:20:33.799]             base::close(...future.stdout)
[13:20:33.799]         }, add = TRUE)
[13:20:33.799]     }
[13:20:33.799]     ...future.frame <- base::sys.nframe()
[13:20:33.799]     ...future.conditions <- base::list()
[13:20:33.799]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:33.799]     if (FALSE) {
[13:20:33.799]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:33.799]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:33.799]     }
[13:20:33.799]     ...future.result <- base::tryCatch({
[13:20:33.799]         base::withCallingHandlers({
[13:20:33.799]             ...future.value <- base::withVisible(base::local({
[13:20:33.799]                 ...future.makeSendCondition <- local({
[13:20:33.799]                   sendCondition <- NULL
[13:20:33.799]                   function(frame = 1L) {
[13:20:33.799]                     if (is.function(sendCondition)) 
[13:20:33.799]                       return(sendCondition)
[13:20:33.799]                     ns <- getNamespace("parallel")
[13:20:33.799]                     if (exists("sendData", mode = "function", 
[13:20:33.799]                       envir = ns)) {
[13:20:33.799]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:33.799]                         envir = ns)
[13:20:33.799]                       envir <- sys.frame(frame)
[13:20:33.799]                       master <- NULL
[13:20:33.799]                       while (!identical(envir, .GlobalEnv) && 
[13:20:33.799]                         !identical(envir, emptyenv())) {
[13:20:33.799]                         if (exists("master", mode = "list", envir = envir, 
[13:20:33.799]                           inherits = FALSE)) {
[13:20:33.799]                           master <- get("master", mode = "list", 
[13:20:33.799]                             envir = envir, inherits = FALSE)
[13:20:33.799]                           if (inherits(master, c("SOCKnode", 
[13:20:33.799]                             "SOCK0node"))) {
[13:20:33.799]                             sendCondition <<- function(cond) {
[13:20:33.799]                               data <- list(type = "VALUE", value = cond, 
[13:20:33.799]                                 success = TRUE)
[13:20:33.799]                               parallel_sendData(master, data)
[13:20:33.799]                             }
[13:20:33.799]                             return(sendCondition)
[13:20:33.799]                           }
[13:20:33.799]                         }
[13:20:33.799]                         frame <- frame + 1L
[13:20:33.799]                         envir <- sys.frame(frame)
[13:20:33.799]                       }
[13:20:33.799]                     }
[13:20:33.799]                     sendCondition <<- function(cond) NULL
[13:20:33.799]                   }
[13:20:33.799]                 })
[13:20:33.799]                 withCallingHandlers({
[13:20:33.799]                   {
[13:20:33.799]                     lm(dist ~ . + 0, data = cars)
[13:20:33.799]                   }
[13:20:33.799]                 }, immediateCondition = function(cond) {
[13:20:33.799]                   sendCondition <- ...future.makeSendCondition()
[13:20:33.799]                   sendCondition(cond)
[13:20:33.799]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:33.799]                   {
[13:20:33.799]                     inherits <- base::inherits
[13:20:33.799]                     invokeRestart <- base::invokeRestart
[13:20:33.799]                     is.null <- base::is.null
[13:20:33.799]                     muffled <- FALSE
[13:20:33.799]                     if (inherits(cond, "message")) {
[13:20:33.799]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:33.799]                       if (muffled) 
[13:20:33.799]                         invokeRestart("muffleMessage")
[13:20:33.799]                     }
[13:20:33.799]                     else if (inherits(cond, "warning")) {
[13:20:33.799]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:33.799]                       if (muffled) 
[13:20:33.799]                         invokeRestart("muffleWarning")
[13:20:33.799]                     }
[13:20:33.799]                     else if (inherits(cond, "condition")) {
[13:20:33.799]                       if (!is.null(pattern)) {
[13:20:33.799]                         computeRestarts <- base::computeRestarts
[13:20:33.799]                         grepl <- base::grepl
[13:20:33.799]                         restarts <- computeRestarts(cond)
[13:20:33.799]                         for (restart in restarts) {
[13:20:33.799]                           name <- restart$name
[13:20:33.799]                           if (is.null(name)) 
[13:20:33.799]                             next
[13:20:33.799]                           if (!grepl(pattern, name)) 
[13:20:33.799]                             next
[13:20:33.799]                           invokeRestart(restart)
[13:20:33.799]                           muffled <- TRUE
[13:20:33.799]                           break
[13:20:33.799]                         }
[13:20:33.799]                       }
[13:20:33.799]                     }
[13:20:33.799]                     invisible(muffled)
[13:20:33.799]                   }
[13:20:33.799]                   muffleCondition(cond)
[13:20:33.799]                 })
[13:20:33.799]             }))
[13:20:33.799]             future::FutureResult(value = ...future.value$value, 
[13:20:33.799]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:33.799]                   ...future.rng), globalenv = if (FALSE) 
[13:20:33.799]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:33.799]                     ...future.globalenv.names))
[13:20:33.799]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:33.799]         }, condition = base::local({
[13:20:33.799]             c <- base::c
[13:20:33.799]             inherits <- base::inherits
[13:20:33.799]             invokeRestart <- base::invokeRestart
[13:20:33.799]             length <- base::length
[13:20:33.799]             list <- base::list
[13:20:33.799]             seq.int <- base::seq.int
[13:20:33.799]             signalCondition <- base::signalCondition
[13:20:33.799]             sys.calls <- base::sys.calls
[13:20:33.799]             `[[` <- base::`[[`
[13:20:33.799]             `+` <- base::`+`
[13:20:33.799]             `<<-` <- base::`<<-`
[13:20:33.799]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:33.799]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:33.799]                   3L)]
[13:20:33.799]             }
[13:20:33.799]             function(cond) {
[13:20:33.799]                 is_error <- inherits(cond, "error")
[13:20:33.799]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:33.799]                   NULL)
[13:20:33.799]                 if (is_error) {
[13:20:33.799]                   sessionInformation <- function() {
[13:20:33.799]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:33.799]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:33.799]                       search = base::search(), system = base::Sys.info())
[13:20:33.799]                   }
[13:20:33.799]                   ...future.conditions[[length(...future.conditions) + 
[13:20:33.799]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:33.799]                     cond$call), session = sessionInformation(), 
[13:20:33.799]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:33.799]                   signalCondition(cond)
[13:20:33.799]                 }
[13:20:33.799]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:33.799]                 "immediateCondition"))) {
[13:20:33.799]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:33.799]                   ...future.conditions[[length(...future.conditions) + 
[13:20:33.799]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:33.799]                   if (TRUE && !signal) {
[13:20:33.799]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:33.799]                     {
[13:20:33.799]                       inherits <- base::inherits
[13:20:33.799]                       invokeRestart <- base::invokeRestart
[13:20:33.799]                       is.null <- base::is.null
[13:20:33.799]                       muffled <- FALSE
[13:20:33.799]                       if (inherits(cond, "message")) {
[13:20:33.799]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:33.799]                         if (muffled) 
[13:20:33.799]                           invokeRestart("muffleMessage")
[13:20:33.799]                       }
[13:20:33.799]                       else if (inherits(cond, "warning")) {
[13:20:33.799]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:33.799]                         if (muffled) 
[13:20:33.799]                           invokeRestart("muffleWarning")
[13:20:33.799]                       }
[13:20:33.799]                       else if (inherits(cond, "condition")) {
[13:20:33.799]                         if (!is.null(pattern)) {
[13:20:33.799]                           computeRestarts <- base::computeRestarts
[13:20:33.799]                           grepl <- base::grepl
[13:20:33.799]                           restarts <- computeRestarts(cond)
[13:20:33.799]                           for (restart in restarts) {
[13:20:33.799]                             name <- restart$name
[13:20:33.799]                             if (is.null(name)) 
[13:20:33.799]                               next
[13:20:33.799]                             if (!grepl(pattern, name)) 
[13:20:33.799]                               next
[13:20:33.799]                             invokeRestart(restart)
[13:20:33.799]                             muffled <- TRUE
[13:20:33.799]                             break
[13:20:33.799]                           }
[13:20:33.799]                         }
[13:20:33.799]                       }
[13:20:33.799]                       invisible(muffled)
[13:20:33.799]                     }
[13:20:33.799]                     muffleCondition(cond, pattern = "^muffle")
[13:20:33.799]                   }
[13:20:33.799]                 }
[13:20:33.799]                 else {
[13:20:33.799]                   if (TRUE) {
[13:20:33.799]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:33.799]                     {
[13:20:33.799]                       inherits <- base::inherits
[13:20:33.799]                       invokeRestart <- base::invokeRestart
[13:20:33.799]                       is.null <- base::is.null
[13:20:33.799]                       muffled <- FALSE
[13:20:33.799]                       if (inherits(cond, "message")) {
[13:20:33.799]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:33.799]                         if (muffled) 
[13:20:33.799]                           invokeRestart("muffleMessage")
[13:20:33.799]                       }
[13:20:33.799]                       else if (inherits(cond, "warning")) {
[13:20:33.799]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:33.799]                         if (muffled) 
[13:20:33.799]                           invokeRestart("muffleWarning")
[13:20:33.799]                       }
[13:20:33.799]                       else if (inherits(cond, "condition")) {
[13:20:33.799]                         if (!is.null(pattern)) {
[13:20:33.799]                           computeRestarts <- base::computeRestarts
[13:20:33.799]                           grepl <- base::grepl
[13:20:33.799]                           restarts <- computeRestarts(cond)
[13:20:33.799]                           for (restart in restarts) {
[13:20:33.799]                             name <- restart$name
[13:20:33.799]                             if (is.null(name)) 
[13:20:33.799]                               next
[13:20:33.799]                             if (!grepl(pattern, name)) 
[13:20:33.799]                               next
[13:20:33.799]                             invokeRestart(restart)
[13:20:33.799]                             muffled <- TRUE
[13:20:33.799]                             break
[13:20:33.799]                           }
[13:20:33.799]                         }
[13:20:33.799]                       }
[13:20:33.799]                       invisible(muffled)
[13:20:33.799]                     }
[13:20:33.799]                     muffleCondition(cond, pattern = "^muffle")
[13:20:33.799]                   }
[13:20:33.799]                 }
[13:20:33.799]             }
[13:20:33.799]         }))
[13:20:33.799]     }, error = function(ex) {
[13:20:33.799]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:33.799]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:33.799]                 ...future.rng), started = ...future.startTime, 
[13:20:33.799]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:33.799]             version = "1.8"), class = "FutureResult")
[13:20:33.799]     }, finally = {
[13:20:33.799]         if (!identical(...future.workdir, getwd())) 
[13:20:33.799]             setwd(...future.workdir)
[13:20:33.799]         {
[13:20:33.799]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:33.799]                 ...future.oldOptions$nwarnings <- NULL
[13:20:33.799]             }
[13:20:33.799]             base::options(...future.oldOptions)
[13:20:33.799]             if (.Platform$OS.type == "windows") {
[13:20:33.799]                 old_names <- names(...future.oldEnvVars)
[13:20:33.799]                 envs <- base::Sys.getenv()
[13:20:33.799]                 names <- names(envs)
[13:20:33.799]                 common <- intersect(names, old_names)
[13:20:33.799]                 added <- setdiff(names, old_names)
[13:20:33.799]                 removed <- setdiff(old_names, names)
[13:20:33.799]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:33.799]                   envs[common]]
[13:20:33.799]                 NAMES <- toupper(changed)
[13:20:33.799]                 args <- list()
[13:20:33.799]                 for (kk in seq_along(NAMES)) {
[13:20:33.799]                   name <- changed[[kk]]
[13:20:33.799]                   NAME <- NAMES[[kk]]
[13:20:33.799]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:33.799]                     next
[13:20:33.799]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:33.799]                 }
[13:20:33.799]                 NAMES <- toupper(added)
[13:20:33.799]                 for (kk in seq_along(NAMES)) {
[13:20:33.799]                   name <- added[[kk]]
[13:20:33.799]                   NAME <- NAMES[[kk]]
[13:20:33.799]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:33.799]                     next
[13:20:33.799]                   args[[name]] <- ""
[13:20:33.799]                 }
[13:20:33.799]                 NAMES <- toupper(removed)
[13:20:33.799]                 for (kk in seq_along(NAMES)) {
[13:20:33.799]                   name <- removed[[kk]]
[13:20:33.799]                   NAME <- NAMES[[kk]]
[13:20:33.799]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:33.799]                     next
[13:20:33.799]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:33.799]                 }
[13:20:33.799]                 if (length(args) > 0) 
[13:20:33.799]                   base::do.call(base::Sys.setenv, args = args)
[13:20:33.799]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:33.799]             }
[13:20:33.799]             else {
[13:20:33.799]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:33.799]             }
[13:20:33.799]             {
[13:20:33.799]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:33.799]                   0L) {
[13:20:33.799]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:33.799]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:33.799]                   base::options(opts)
[13:20:33.799]                 }
[13:20:33.799]                 {
[13:20:33.799]                   {
[13:20:33.799]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:33.799]                     NULL
[13:20:33.799]                   }
[13:20:33.799]                   options(future.plan = NULL)
[13:20:33.799]                   if (is.na(NA_character_)) 
[13:20:33.799]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:33.799]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:33.799]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:33.799]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:33.799]                     envir = parent.frame()) 
[13:20:33.799]                   {
[13:20:33.799]                     if (is.function(workers)) 
[13:20:33.799]                       workers <- workers()
[13:20:33.799]                     workers <- structure(as.integer(workers), 
[13:20:33.799]                       class = class(workers))
[13:20:33.799]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:33.799]                       workers >= 1)
[13:20:33.799]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:33.799]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:33.799]                     }
[13:20:33.799]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:33.799]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:33.799]                       envir = envir)
[13:20:33.799]                     if (!future$lazy) 
[13:20:33.799]                       future <- run(future)
[13:20:33.799]                     invisible(future)
[13:20:33.799]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:33.799]                 }
[13:20:33.799]             }
[13:20:33.799]         }
[13:20:33.799]     })
[13:20:33.799]     if (TRUE) {
[13:20:33.799]         base::sink(type = "output", split = FALSE)
[13:20:33.799]         if (TRUE) {
[13:20:33.799]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:33.799]         }
[13:20:33.799]         else {
[13:20:33.799]             ...future.result["stdout"] <- base::list(NULL)
[13:20:33.799]         }
[13:20:33.799]         base::close(...future.stdout)
[13:20:33.799]         ...future.stdout <- NULL
[13:20:33.799]     }
[13:20:33.799]     ...future.result$conditions <- ...future.conditions
[13:20:33.799]     ...future.result$finished <- base::Sys.time()
[13:20:33.799]     ...future.result
[13:20:33.799] }
[13:20:33.802] MultisessionFuture started
[13:20:33.802] - Launch lazy future ... done
[13:20:33.803] run() for ‘MultisessionFuture’ ... done
[13:20:33.803] result() for ClusterFuture ...
[13:20:33.803] receiveMessageFromWorker() for ClusterFuture ...
[13:20:33.803] - Validating connection of MultisessionFuture
[13:20:33.850] - received message: FutureResult
[13:20:33.851] - Received FutureResult
[13:20:33.851] - Erased future from FutureRegistry
[13:20:33.851] result() for ClusterFuture ...
[13:20:33.851] - result already collected: FutureResult
[13:20:33.851] result() for ClusterFuture ... done
[13:20:33.851] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:33.851] result() for ClusterFuture ... done
[13:20:33.852] result() for ClusterFuture ...
[13:20:33.852] - result already collected: FutureResult
[13:20:33.852] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[13:20:33.854] getGlobalsAndPackages() ...
[13:20:33.855] Searching for globals...
[13:20:33.856] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[13:20:33.857] Searching for globals ... DONE
[13:20:33.857] Resolving globals: FALSE
[13:20:33.857] 
[13:20:33.857] - packages: [2] ‘stats’, ‘datasets’
[13:20:33.857] getGlobalsAndPackages() ... DONE
[13:20:33.858] run() for ‘Future’ ...
[13:20:33.858] - state: ‘created’
[13:20:33.858] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:33.873] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:33.874] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:33.874]   - Field: ‘node’
[13:20:33.874]   - Field: ‘label’
[13:20:33.874]   - Field: ‘local’
[13:20:33.874]   - Field: ‘owner’
[13:20:33.874]   - Field: ‘envir’
[13:20:33.874]   - Field: ‘workers’
[13:20:33.874]   - Field: ‘packages’
[13:20:33.874]   - Field: ‘gc’
[13:20:33.874]   - Field: ‘conditions’
[13:20:33.875]   - Field: ‘persistent’
[13:20:33.875]   - Field: ‘expr’
[13:20:33.875]   - Field: ‘uuid’
[13:20:33.875]   - Field: ‘seed’
[13:20:33.875]   - Field: ‘version’
[13:20:33.875]   - Field: ‘result’
[13:20:33.875]   - Field: ‘asynchronous’
[13:20:33.875]   - Field: ‘calls’
[13:20:33.875]   - Field: ‘globals’
[13:20:33.875]   - Field: ‘stdout’
[13:20:33.875]   - Field: ‘earlySignal’
[13:20:33.876]   - Field: ‘lazy’
[13:20:33.876]   - Field: ‘state’
[13:20:33.876] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:33.876] - Launch lazy future ...
[13:20:33.876] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:20:33.876] Packages needed by future strategies (n = 0): <none>
[13:20:33.877] {
[13:20:33.877]     {
[13:20:33.877]         {
[13:20:33.877]             ...future.startTime <- base::Sys.time()
[13:20:33.877]             {
[13:20:33.877]                 {
[13:20:33.877]                   {
[13:20:33.877]                     {
[13:20:33.877]                       {
[13:20:33.877]                         base::local({
[13:20:33.877]                           has_future <- base::requireNamespace("future", 
[13:20:33.877]                             quietly = TRUE)
[13:20:33.877]                           if (has_future) {
[13:20:33.877]                             ns <- base::getNamespace("future")
[13:20:33.877]                             version <- ns[[".package"]][["version"]]
[13:20:33.877]                             if (is.null(version)) 
[13:20:33.877]                               version <- utils::packageVersion("future")
[13:20:33.877]                           }
[13:20:33.877]                           else {
[13:20:33.877]                             version <- NULL
[13:20:33.877]                           }
[13:20:33.877]                           if (!has_future || version < "1.8.0") {
[13:20:33.877]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:33.877]                               "", base::R.version$version.string), 
[13:20:33.877]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:33.877]                                 base::R.version$platform, 8 * 
[13:20:33.877]                                   base::.Machine$sizeof.pointer), 
[13:20:33.877]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:33.877]                                 "release", "version")], collapse = " "), 
[13:20:33.877]                               hostname = base::Sys.info()[["nodename"]])
[13:20:33.877]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:33.877]                               info)
[13:20:33.877]                             info <- base::paste(info, collapse = "; ")
[13:20:33.877]                             if (!has_future) {
[13:20:33.877]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:33.877]                                 info)
[13:20:33.877]                             }
[13:20:33.877]                             else {
[13:20:33.877]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:33.877]                                 info, version)
[13:20:33.877]                             }
[13:20:33.877]                             base::stop(msg)
[13:20:33.877]                           }
[13:20:33.877]                         })
[13:20:33.877]                       }
[13:20:33.877]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:33.877]                       base::options(mc.cores = 1L)
[13:20:33.877]                     }
[13:20:33.877]                     base::local({
[13:20:33.877]                       for (pkg in c("stats", "datasets")) {
[13:20:33.877]                         base::loadNamespace(pkg)
[13:20:33.877]                         base::library(pkg, character.only = TRUE)
[13:20:33.877]                       }
[13:20:33.877]                     })
[13:20:33.877]                   }
[13:20:33.877]                   options(future.plan = NULL)
[13:20:33.877]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:33.877]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:33.877]                 }
[13:20:33.877]                 ...future.workdir <- getwd()
[13:20:33.877]             }
[13:20:33.877]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:33.877]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:33.877]         }
[13:20:33.877]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:33.877]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:33.877]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:33.877]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:33.877]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:33.877]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:33.877]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:33.877]             base::names(...future.oldOptions))
[13:20:33.877]     }
[13:20:33.877]     if (FALSE) {
[13:20:33.877]     }
[13:20:33.877]     else {
[13:20:33.877]         if (TRUE) {
[13:20:33.877]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:33.877]                 open = "w")
[13:20:33.877]         }
[13:20:33.877]         else {
[13:20:33.877]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:33.877]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:33.877]         }
[13:20:33.877]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:33.877]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:33.877]             base::sink(type = "output", split = FALSE)
[13:20:33.877]             base::close(...future.stdout)
[13:20:33.877]         }, add = TRUE)
[13:20:33.877]     }
[13:20:33.877]     ...future.frame <- base::sys.nframe()
[13:20:33.877]     ...future.conditions <- base::list()
[13:20:33.877]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:33.877]     if (FALSE) {
[13:20:33.877]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:33.877]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:33.877]     }
[13:20:33.877]     ...future.result <- base::tryCatch({
[13:20:33.877]         base::withCallingHandlers({
[13:20:33.877]             ...future.value <- base::withVisible(base::local({
[13:20:33.877]                 ...future.makeSendCondition <- local({
[13:20:33.877]                   sendCondition <- NULL
[13:20:33.877]                   function(frame = 1L) {
[13:20:33.877]                     if (is.function(sendCondition)) 
[13:20:33.877]                       return(sendCondition)
[13:20:33.877]                     ns <- getNamespace("parallel")
[13:20:33.877]                     if (exists("sendData", mode = "function", 
[13:20:33.877]                       envir = ns)) {
[13:20:33.877]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:33.877]                         envir = ns)
[13:20:33.877]                       envir <- sys.frame(frame)
[13:20:33.877]                       master <- NULL
[13:20:33.877]                       while (!identical(envir, .GlobalEnv) && 
[13:20:33.877]                         !identical(envir, emptyenv())) {
[13:20:33.877]                         if (exists("master", mode = "list", envir = envir, 
[13:20:33.877]                           inherits = FALSE)) {
[13:20:33.877]                           master <- get("master", mode = "list", 
[13:20:33.877]                             envir = envir, inherits = FALSE)
[13:20:33.877]                           if (inherits(master, c("SOCKnode", 
[13:20:33.877]                             "SOCK0node"))) {
[13:20:33.877]                             sendCondition <<- function(cond) {
[13:20:33.877]                               data <- list(type = "VALUE", value = cond, 
[13:20:33.877]                                 success = TRUE)
[13:20:33.877]                               parallel_sendData(master, data)
[13:20:33.877]                             }
[13:20:33.877]                             return(sendCondition)
[13:20:33.877]                           }
[13:20:33.877]                         }
[13:20:33.877]                         frame <- frame + 1L
[13:20:33.877]                         envir <- sys.frame(frame)
[13:20:33.877]                       }
[13:20:33.877]                     }
[13:20:33.877]                     sendCondition <<- function(cond) NULL
[13:20:33.877]                   }
[13:20:33.877]                 })
[13:20:33.877]                 withCallingHandlers({
[13:20:33.877]                   {
[13:20:33.877]                     lm(dist ~ speed + speed^2, data = cars)
[13:20:33.877]                   }
[13:20:33.877]                 }, immediateCondition = function(cond) {
[13:20:33.877]                   sendCondition <- ...future.makeSendCondition()
[13:20:33.877]                   sendCondition(cond)
[13:20:33.877]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:33.877]                   {
[13:20:33.877]                     inherits <- base::inherits
[13:20:33.877]                     invokeRestart <- base::invokeRestart
[13:20:33.877]                     is.null <- base::is.null
[13:20:33.877]                     muffled <- FALSE
[13:20:33.877]                     if (inherits(cond, "message")) {
[13:20:33.877]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:33.877]                       if (muffled) 
[13:20:33.877]                         invokeRestart("muffleMessage")
[13:20:33.877]                     }
[13:20:33.877]                     else if (inherits(cond, "warning")) {
[13:20:33.877]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:33.877]                       if (muffled) 
[13:20:33.877]                         invokeRestart("muffleWarning")
[13:20:33.877]                     }
[13:20:33.877]                     else if (inherits(cond, "condition")) {
[13:20:33.877]                       if (!is.null(pattern)) {
[13:20:33.877]                         computeRestarts <- base::computeRestarts
[13:20:33.877]                         grepl <- base::grepl
[13:20:33.877]                         restarts <- computeRestarts(cond)
[13:20:33.877]                         for (restart in restarts) {
[13:20:33.877]                           name <- restart$name
[13:20:33.877]                           if (is.null(name)) 
[13:20:33.877]                             next
[13:20:33.877]                           if (!grepl(pattern, name)) 
[13:20:33.877]                             next
[13:20:33.877]                           invokeRestart(restart)
[13:20:33.877]                           muffled <- TRUE
[13:20:33.877]                           break
[13:20:33.877]                         }
[13:20:33.877]                       }
[13:20:33.877]                     }
[13:20:33.877]                     invisible(muffled)
[13:20:33.877]                   }
[13:20:33.877]                   muffleCondition(cond)
[13:20:33.877]                 })
[13:20:33.877]             }))
[13:20:33.877]             future::FutureResult(value = ...future.value$value, 
[13:20:33.877]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:33.877]                   ...future.rng), globalenv = if (FALSE) 
[13:20:33.877]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:33.877]                     ...future.globalenv.names))
[13:20:33.877]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:33.877]         }, condition = base::local({
[13:20:33.877]             c <- base::c
[13:20:33.877]             inherits <- base::inherits
[13:20:33.877]             invokeRestart <- base::invokeRestart
[13:20:33.877]             length <- base::length
[13:20:33.877]             list <- base::list
[13:20:33.877]             seq.int <- base::seq.int
[13:20:33.877]             signalCondition <- base::signalCondition
[13:20:33.877]             sys.calls <- base::sys.calls
[13:20:33.877]             `[[` <- base::`[[`
[13:20:33.877]             `+` <- base::`+`
[13:20:33.877]             `<<-` <- base::`<<-`
[13:20:33.877]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:33.877]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:33.877]                   3L)]
[13:20:33.877]             }
[13:20:33.877]             function(cond) {
[13:20:33.877]                 is_error <- inherits(cond, "error")
[13:20:33.877]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:33.877]                   NULL)
[13:20:33.877]                 if (is_error) {
[13:20:33.877]                   sessionInformation <- function() {
[13:20:33.877]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:33.877]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:33.877]                       search = base::search(), system = base::Sys.info())
[13:20:33.877]                   }
[13:20:33.877]                   ...future.conditions[[length(...future.conditions) + 
[13:20:33.877]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:33.877]                     cond$call), session = sessionInformation(), 
[13:20:33.877]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:33.877]                   signalCondition(cond)
[13:20:33.877]                 }
[13:20:33.877]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:33.877]                 "immediateCondition"))) {
[13:20:33.877]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:33.877]                   ...future.conditions[[length(...future.conditions) + 
[13:20:33.877]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:33.877]                   if (TRUE && !signal) {
[13:20:33.877]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:33.877]                     {
[13:20:33.877]                       inherits <- base::inherits
[13:20:33.877]                       invokeRestart <- base::invokeRestart
[13:20:33.877]                       is.null <- base::is.null
[13:20:33.877]                       muffled <- FALSE
[13:20:33.877]                       if (inherits(cond, "message")) {
[13:20:33.877]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:33.877]                         if (muffled) 
[13:20:33.877]                           invokeRestart("muffleMessage")
[13:20:33.877]                       }
[13:20:33.877]                       else if (inherits(cond, "warning")) {
[13:20:33.877]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:33.877]                         if (muffled) 
[13:20:33.877]                           invokeRestart("muffleWarning")
[13:20:33.877]                       }
[13:20:33.877]                       else if (inherits(cond, "condition")) {
[13:20:33.877]                         if (!is.null(pattern)) {
[13:20:33.877]                           computeRestarts <- base::computeRestarts
[13:20:33.877]                           grepl <- base::grepl
[13:20:33.877]                           restarts <- computeRestarts(cond)
[13:20:33.877]                           for (restart in restarts) {
[13:20:33.877]                             name <- restart$name
[13:20:33.877]                             if (is.null(name)) 
[13:20:33.877]                               next
[13:20:33.877]                             if (!grepl(pattern, name)) 
[13:20:33.877]                               next
[13:20:33.877]                             invokeRestart(restart)
[13:20:33.877]                             muffled <- TRUE
[13:20:33.877]                             break
[13:20:33.877]                           }
[13:20:33.877]                         }
[13:20:33.877]                       }
[13:20:33.877]                       invisible(muffled)
[13:20:33.877]                     }
[13:20:33.877]                     muffleCondition(cond, pattern = "^muffle")
[13:20:33.877]                   }
[13:20:33.877]                 }
[13:20:33.877]                 else {
[13:20:33.877]                   if (TRUE) {
[13:20:33.877]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:33.877]                     {
[13:20:33.877]                       inherits <- base::inherits
[13:20:33.877]                       invokeRestart <- base::invokeRestart
[13:20:33.877]                       is.null <- base::is.null
[13:20:33.877]                       muffled <- FALSE
[13:20:33.877]                       if (inherits(cond, "message")) {
[13:20:33.877]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:33.877]                         if (muffled) 
[13:20:33.877]                           invokeRestart("muffleMessage")
[13:20:33.877]                       }
[13:20:33.877]                       else if (inherits(cond, "warning")) {
[13:20:33.877]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:33.877]                         if (muffled) 
[13:20:33.877]                           invokeRestart("muffleWarning")
[13:20:33.877]                       }
[13:20:33.877]                       else if (inherits(cond, "condition")) {
[13:20:33.877]                         if (!is.null(pattern)) {
[13:20:33.877]                           computeRestarts <- base::computeRestarts
[13:20:33.877]                           grepl <- base::grepl
[13:20:33.877]                           restarts <- computeRestarts(cond)
[13:20:33.877]                           for (restart in restarts) {
[13:20:33.877]                             name <- restart$name
[13:20:33.877]                             if (is.null(name)) 
[13:20:33.877]                               next
[13:20:33.877]                             if (!grepl(pattern, name)) 
[13:20:33.877]                               next
[13:20:33.877]                             invokeRestart(restart)
[13:20:33.877]                             muffled <- TRUE
[13:20:33.877]                             break
[13:20:33.877]                           }
[13:20:33.877]                         }
[13:20:33.877]                       }
[13:20:33.877]                       invisible(muffled)
[13:20:33.877]                     }
[13:20:33.877]                     muffleCondition(cond, pattern = "^muffle")
[13:20:33.877]                   }
[13:20:33.877]                 }
[13:20:33.877]             }
[13:20:33.877]         }))
[13:20:33.877]     }, error = function(ex) {
[13:20:33.877]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:33.877]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:33.877]                 ...future.rng), started = ...future.startTime, 
[13:20:33.877]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:33.877]             version = "1.8"), class = "FutureResult")
[13:20:33.877]     }, finally = {
[13:20:33.877]         if (!identical(...future.workdir, getwd())) 
[13:20:33.877]             setwd(...future.workdir)
[13:20:33.877]         {
[13:20:33.877]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:33.877]                 ...future.oldOptions$nwarnings <- NULL
[13:20:33.877]             }
[13:20:33.877]             base::options(...future.oldOptions)
[13:20:33.877]             if (.Platform$OS.type == "windows") {
[13:20:33.877]                 old_names <- names(...future.oldEnvVars)
[13:20:33.877]                 envs <- base::Sys.getenv()
[13:20:33.877]                 names <- names(envs)
[13:20:33.877]                 common <- intersect(names, old_names)
[13:20:33.877]                 added <- setdiff(names, old_names)
[13:20:33.877]                 removed <- setdiff(old_names, names)
[13:20:33.877]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:33.877]                   envs[common]]
[13:20:33.877]                 NAMES <- toupper(changed)
[13:20:33.877]                 args <- list()
[13:20:33.877]                 for (kk in seq_along(NAMES)) {
[13:20:33.877]                   name <- changed[[kk]]
[13:20:33.877]                   NAME <- NAMES[[kk]]
[13:20:33.877]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:33.877]                     next
[13:20:33.877]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:33.877]                 }
[13:20:33.877]                 NAMES <- toupper(added)
[13:20:33.877]                 for (kk in seq_along(NAMES)) {
[13:20:33.877]                   name <- added[[kk]]
[13:20:33.877]                   NAME <- NAMES[[kk]]
[13:20:33.877]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:33.877]                     next
[13:20:33.877]                   args[[name]] <- ""
[13:20:33.877]                 }
[13:20:33.877]                 NAMES <- toupper(removed)
[13:20:33.877]                 for (kk in seq_along(NAMES)) {
[13:20:33.877]                   name <- removed[[kk]]
[13:20:33.877]                   NAME <- NAMES[[kk]]
[13:20:33.877]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:33.877]                     next
[13:20:33.877]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:33.877]                 }
[13:20:33.877]                 if (length(args) > 0) 
[13:20:33.877]                   base::do.call(base::Sys.setenv, args = args)
[13:20:33.877]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:33.877]             }
[13:20:33.877]             else {
[13:20:33.877]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:33.877]             }
[13:20:33.877]             {
[13:20:33.877]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:33.877]                   0L) {
[13:20:33.877]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:33.877]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:33.877]                   base::options(opts)
[13:20:33.877]                 }
[13:20:33.877]                 {
[13:20:33.877]                   {
[13:20:33.877]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:33.877]                     NULL
[13:20:33.877]                   }
[13:20:33.877]                   options(future.plan = NULL)
[13:20:33.877]                   if (is.na(NA_character_)) 
[13:20:33.877]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:33.877]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:33.877]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:33.877]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:33.877]                     envir = parent.frame()) 
[13:20:33.877]                   {
[13:20:33.877]                     if (is.function(workers)) 
[13:20:33.877]                       workers <- workers()
[13:20:33.877]                     workers <- structure(as.integer(workers), 
[13:20:33.877]                       class = class(workers))
[13:20:33.877]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:33.877]                       workers >= 1)
[13:20:33.877]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:33.877]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:33.877]                     }
[13:20:33.877]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:33.877]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:33.877]                       envir = envir)
[13:20:33.877]                     if (!future$lazy) 
[13:20:33.877]                       future <- run(future)
[13:20:33.877]                     invisible(future)
[13:20:33.877]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:33.877]                 }
[13:20:33.877]             }
[13:20:33.877]         }
[13:20:33.877]     })
[13:20:33.877]     if (TRUE) {
[13:20:33.877]         base::sink(type = "output", split = FALSE)
[13:20:33.877]         if (TRUE) {
[13:20:33.877]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:33.877]         }
[13:20:33.877]         else {
[13:20:33.877]             ...future.result["stdout"] <- base::list(NULL)
[13:20:33.877]         }
[13:20:33.877]         base::close(...future.stdout)
[13:20:33.877]         ...future.stdout <- NULL
[13:20:33.877]     }
[13:20:33.877]     ...future.result$conditions <- ...future.conditions
[13:20:33.877]     ...future.result$finished <- base::Sys.time()
[13:20:33.877]     ...future.result
[13:20:33.877] }
[13:20:33.880] MultisessionFuture started
[13:20:33.880] - Launch lazy future ... done
[13:20:33.880] run() for ‘MultisessionFuture’ ... done
[13:20:33.880] result() for ClusterFuture ...
[13:20:33.881] receiveMessageFromWorker() for ClusterFuture ...
[13:20:33.881] - Validating connection of MultisessionFuture
[13:20:33.927] - received message: FutureResult
[13:20:33.927] - Received FutureResult
[13:20:33.927] - Erased future from FutureRegistry
[13:20:33.927] result() for ClusterFuture ...
[13:20:33.927] - result already collected: FutureResult
[13:20:33.928] result() for ClusterFuture ... done
[13:20:33.928] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:33.928] result() for ClusterFuture ... done
[13:20:33.928] result() for ClusterFuture ...
[13:20:33.928] - result already collected: FutureResult
[13:20:33.928] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[13:20:33.931] getGlobalsAndPackages() ...
[13:20:33.931] Searching for globals...
[13:20:33.933] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[13:20:33.933] Searching for globals ... DONE
[13:20:33.933] Resolving globals: FALSE
[13:20:33.934] 
[13:20:33.934] - packages: [2] ‘stats’, ‘datasets’
[13:20:33.934] getGlobalsAndPackages() ... DONE
[13:20:33.934] run() for ‘Future’ ...
[13:20:33.934] - state: ‘created’
[13:20:33.934] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:33.949] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:33.949] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:33.949]   - Field: ‘node’
[13:20:33.949]   - Field: ‘label’
[13:20:33.949]   - Field: ‘local’
[13:20:33.949]   - Field: ‘owner’
[13:20:33.949]   - Field: ‘envir’
[13:20:33.949]   - Field: ‘workers’
[13:20:33.949]   - Field: ‘packages’
[13:20:33.950]   - Field: ‘gc’
[13:20:33.950]   - Field: ‘conditions’
[13:20:33.950]   - Field: ‘persistent’
[13:20:33.950]   - Field: ‘expr’
[13:20:33.950]   - Field: ‘uuid’
[13:20:33.950]   - Field: ‘seed’
[13:20:33.950]   - Field: ‘version’
[13:20:33.950]   - Field: ‘result’
[13:20:33.950]   - Field: ‘asynchronous’
[13:20:33.950]   - Field: ‘calls’
[13:20:33.950]   - Field: ‘globals’
[13:20:33.951]   - Field: ‘stdout’
[13:20:33.951]   - Field: ‘earlySignal’
[13:20:33.951]   - Field: ‘lazy’
[13:20:33.951]   - Field: ‘state’
[13:20:33.951] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:33.951] - Launch lazy future ...
[13:20:33.951] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:20:33.951] Packages needed by future strategies (n = 0): <none>
[13:20:33.952] {
[13:20:33.952]     {
[13:20:33.952]         {
[13:20:33.952]             ...future.startTime <- base::Sys.time()
[13:20:33.952]             {
[13:20:33.952]                 {
[13:20:33.952]                   {
[13:20:33.952]                     {
[13:20:33.952]                       {
[13:20:33.952]                         base::local({
[13:20:33.952]                           has_future <- base::requireNamespace("future", 
[13:20:33.952]                             quietly = TRUE)
[13:20:33.952]                           if (has_future) {
[13:20:33.952]                             ns <- base::getNamespace("future")
[13:20:33.952]                             version <- ns[[".package"]][["version"]]
[13:20:33.952]                             if (is.null(version)) 
[13:20:33.952]                               version <- utils::packageVersion("future")
[13:20:33.952]                           }
[13:20:33.952]                           else {
[13:20:33.952]                             version <- NULL
[13:20:33.952]                           }
[13:20:33.952]                           if (!has_future || version < "1.8.0") {
[13:20:33.952]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:33.952]                               "", base::R.version$version.string), 
[13:20:33.952]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:33.952]                                 base::R.version$platform, 8 * 
[13:20:33.952]                                   base::.Machine$sizeof.pointer), 
[13:20:33.952]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:33.952]                                 "release", "version")], collapse = " "), 
[13:20:33.952]                               hostname = base::Sys.info()[["nodename"]])
[13:20:33.952]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:33.952]                               info)
[13:20:33.952]                             info <- base::paste(info, collapse = "; ")
[13:20:33.952]                             if (!has_future) {
[13:20:33.952]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:33.952]                                 info)
[13:20:33.952]                             }
[13:20:33.952]                             else {
[13:20:33.952]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:33.952]                                 info, version)
[13:20:33.952]                             }
[13:20:33.952]                             base::stop(msg)
[13:20:33.952]                           }
[13:20:33.952]                         })
[13:20:33.952]                       }
[13:20:33.952]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:33.952]                       base::options(mc.cores = 1L)
[13:20:33.952]                     }
[13:20:33.952]                     base::local({
[13:20:33.952]                       for (pkg in c("stats", "datasets")) {
[13:20:33.952]                         base::loadNamespace(pkg)
[13:20:33.952]                         base::library(pkg, character.only = TRUE)
[13:20:33.952]                       }
[13:20:33.952]                     })
[13:20:33.952]                   }
[13:20:33.952]                   options(future.plan = NULL)
[13:20:33.952]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:33.952]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:33.952]                 }
[13:20:33.952]                 ...future.workdir <- getwd()
[13:20:33.952]             }
[13:20:33.952]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:33.952]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:33.952]         }
[13:20:33.952]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:33.952]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:33.952]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:33.952]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:33.952]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:33.952]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:33.952]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:33.952]             base::names(...future.oldOptions))
[13:20:33.952]     }
[13:20:33.952]     if (FALSE) {
[13:20:33.952]     }
[13:20:33.952]     else {
[13:20:33.952]         if (TRUE) {
[13:20:33.952]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:33.952]                 open = "w")
[13:20:33.952]         }
[13:20:33.952]         else {
[13:20:33.952]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:33.952]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:33.952]         }
[13:20:33.952]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:33.952]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:33.952]             base::sink(type = "output", split = FALSE)
[13:20:33.952]             base::close(...future.stdout)
[13:20:33.952]         }, add = TRUE)
[13:20:33.952]     }
[13:20:33.952]     ...future.frame <- base::sys.nframe()
[13:20:33.952]     ...future.conditions <- base::list()
[13:20:33.952]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:33.952]     if (FALSE) {
[13:20:33.952]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:33.952]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:33.952]     }
[13:20:33.952]     ...future.result <- base::tryCatch({
[13:20:33.952]         base::withCallingHandlers({
[13:20:33.952]             ...future.value <- base::withVisible(base::local({
[13:20:33.952]                 ...future.makeSendCondition <- local({
[13:20:33.952]                   sendCondition <- NULL
[13:20:33.952]                   function(frame = 1L) {
[13:20:33.952]                     if (is.function(sendCondition)) 
[13:20:33.952]                       return(sendCondition)
[13:20:33.952]                     ns <- getNamespace("parallel")
[13:20:33.952]                     if (exists("sendData", mode = "function", 
[13:20:33.952]                       envir = ns)) {
[13:20:33.952]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:33.952]                         envir = ns)
[13:20:33.952]                       envir <- sys.frame(frame)
[13:20:33.952]                       master <- NULL
[13:20:33.952]                       while (!identical(envir, .GlobalEnv) && 
[13:20:33.952]                         !identical(envir, emptyenv())) {
[13:20:33.952]                         if (exists("master", mode = "list", envir = envir, 
[13:20:33.952]                           inherits = FALSE)) {
[13:20:33.952]                           master <- get("master", mode = "list", 
[13:20:33.952]                             envir = envir, inherits = FALSE)
[13:20:33.952]                           if (inherits(master, c("SOCKnode", 
[13:20:33.952]                             "SOCK0node"))) {
[13:20:33.952]                             sendCondition <<- function(cond) {
[13:20:33.952]                               data <- list(type = "VALUE", value = cond, 
[13:20:33.952]                                 success = TRUE)
[13:20:33.952]                               parallel_sendData(master, data)
[13:20:33.952]                             }
[13:20:33.952]                             return(sendCondition)
[13:20:33.952]                           }
[13:20:33.952]                         }
[13:20:33.952]                         frame <- frame + 1L
[13:20:33.952]                         envir <- sys.frame(frame)
[13:20:33.952]                       }
[13:20:33.952]                     }
[13:20:33.952]                     sendCondition <<- function(cond) NULL
[13:20:33.952]                   }
[13:20:33.952]                 })
[13:20:33.952]                 withCallingHandlers({
[13:20:33.952]                   {
[13:20:33.952]                     lm(dist ~ speed + I(speed^2), data = cars)
[13:20:33.952]                   }
[13:20:33.952]                 }, immediateCondition = function(cond) {
[13:20:33.952]                   sendCondition <- ...future.makeSendCondition()
[13:20:33.952]                   sendCondition(cond)
[13:20:33.952]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:33.952]                   {
[13:20:33.952]                     inherits <- base::inherits
[13:20:33.952]                     invokeRestart <- base::invokeRestart
[13:20:33.952]                     is.null <- base::is.null
[13:20:33.952]                     muffled <- FALSE
[13:20:33.952]                     if (inherits(cond, "message")) {
[13:20:33.952]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:33.952]                       if (muffled) 
[13:20:33.952]                         invokeRestart("muffleMessage")
[13:20:33.952]                     }
[13:20:33.952]                     else if (inherits(cond, "warning")) {
[13:20:33.952]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:33.952]                       if (muffled) 
[13:20:33.952]                         invokeRestart("muffleWarning")
[13:20:33.952]                     }
[13:20:33.952]                     else if (inherits(cond, "condition")) {
[13:20:33.952]                       if (!is.null(pattern)) {
[13:20:33.952]                         computeRestarts <- base::computeRestarts
[13:20:33.952]                         grepl <- base::grepl
[13:20:33.952]                         restarts <- computeRestarts(cond)
[13:20:33.952]                         for (restart in restarts) {
[13:20:33.952]                           name <- restart$name
[13:20:33.952]                           if (is.null(name)) 
[13:20:33.952]                             next
[13:20:33.952]                           if (!grepl(pattern, name)) 
[13:20:33.952]                             next
[13:20:33.952]                           invokeRestart(restart)
[13:20:33.952]                           muffled <- TRUE
[13:20:33.952]                           break
[13:20:33.952]                         }
[13:20:33.952]                       }
[13:20:33.952]                     }
[13:20:33.952]                     invisible(muffled)
[13:20:33.952]                   }
[13:20:33.952]                   muffleCondition(cond)
[13:20:33.952]                 })
[13:20:33.952]             }))
[13:20:33.952]             future::FutureResult(value = ...future.value$value, 
[13:20:33.952]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:33.952]                   ...future.rng), globalenv = if (FALSE) 
[13:20:33.952]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:33.952]                     ...future.globalenv.names))
[13:20:33.952]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:33.952]         }, condition = base::local({
[13:20:33.952]             c <- base::c
[13:20:33.952]             inherits <- base::inherits
[13:20:33.952]             invokeRestart <- base::invokeRestart
[13:20:33.952]             length <- base::length
[13:20:33.952]             list <- base::list
[13:20:33.952]             seq.int <- base::seq.int
[13:20:33.952]             signalCondition <- base::signalCondition
[13:20:33.952]             sys.calls <- base::sys.calls
[13:20:33.952]             `[[` <- base::`[[`
[13:20:33.952]             `+` <- base::`+`
[13:20:33.952]             `<<-` <- base::`<<-`
[13:20:33.952]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:33.952]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:33.952]                   3L)]
[13:20:33.952]             }
[13:20:33.952]             function(cond) {
[13:20:33.952]                 is_error <- inherits(cond, "error")
[13:20:33.952]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:33.952]                   NULL)
[13:20:33.952]                 if (is_error) {
[13:20:33.952]                   sessionInformation <- function() {
[13:20:33.952]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:33.952]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:33.952]                       search = base::search(), system = base::Sys.info())
[13:20:33.952]                   }
[13:20:33.952]                   ...future.conditions[[length(...future.conditions) + 
[13:20:33.952]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:33.952]                     cond$call), session = sessionInformation(), 
[13:20:33.952]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:33.952]                   signalCondition(cond)
[13:20:33.952]                 }
[13:20:33.952]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:33.952]                 "immediateCondition"))) {
[13:20:33.952]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:33.952]                   ...future.conditions[[length(...future.conditions) + 
[13:20:33.952]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:33.952]                   if (TRUE && !signal) {
[13:20:33.952]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:33.952]                     {
[13:20:33.952]                       inherits <- base::inherits
[13:20:33.952]                       invokeRestart <- base::invokeRestart
[13:20:33.952]                       is.null <- base::is.null
[13:20:33.952]                       muffled <- FALSE
[13:20:33.952]                       if (inherits(cond, "message")) {
[13:20:33.952]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:33.952]                         if (muffled) 
[13:20:33.952]                           invokeRestart("muffleMessage")
[13:20:33.952]                       }
[13:20:33.952]                       else if (inherits(cond, "warning")) {
[13:20:33.952]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:33.952]                         if (muffled) 
[13:20:33.952]                           invokeRestart("muffleWarning")
[13:20:33.952]                       }
[13:20:33.952]                       else if (inherits(cond, "condition")) {
[13:20:33.952]                         if (!is.null(pattern)) {
[13:20:33.952]                           computeRestarts <- base::computeRestarts
[13:20:33.952]                           grepl <- base::grepl
[13:20:33.952]                           restarts <- computeRestarts(cond)
[13:20:33.952]                           for (restart in restarts) {
[13:20:33.952]                             name <- restart$name
[13:20:33.952]                             if (is.null(name)) 
[13:20:33.952]                               next
[13:20:33.952]                             if (!grepl(pattern, name)) 
[13:20:33.952]                               next
[13:20:33.952]                             invokeRestart(restart)
[13:20:33.952]                             muffled <- TRUE
[13:20:33.952]                             break
[13:20:33.952]                           }
[13:20:33.952]                         }
[13:20:33.952]                       }
[13:20:33.952]                       invisible(muffled)
[13:20:33.952]                     }
[13:20:33.952]                     muffleCondition(cond, pattern = "^muffle")
[13:20:33.952]                   }
[13:20:33.952]                 }
[13:20:33.952]                 else {
[13:20:33.952]                   if (TRUE) {
[13:20:33.952]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:33.952]                     {
[13:20:33.952]                       inherits <- base::inherits
[13:20:33.952]                       invokeRestart <- base::invokeRestart
[13:20:33.952]                       is.null <- base::is.null
[13:20:33.952]                       muffled <- FALSE
[13:20:33.952]                       if (inherits(cond, "message")) {
[13:20:33.952]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:33.952]                         if (muffled) 
[13:20:33.952]                           invokeRestart("muffleMessage")
[13:20:33.952]                       }
[13:20:33.952]                       else if (inherits(cond, "warning")) {
[13:20:33.952]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:33.952]                         if (muffled) 
[13:20:33.952]                           invokeRestart("muffleWarning")
[13:20:33.952]                       }
[13:20:33.952]                       else if (inherits(cond, "condition")) {
[13:20:33.952]                         if (!is.null(pattern)) {
[13:20:33.952]                           computeRestarts <- base::computeRestarts
[13:20:33.952]                           grepl <- base::grepl
[13:20:33.952]                           restarts <- computeRestarts(cond)
[13:20:33.952]                           for (restart in restarts) {
[13:20:33.952]                             name <- restart$name
[13:20:33.952]                             if (is.null(name)) 
[13:20:33.952]                               next
[13:20:33.952]                             if (!grepl(pattern, name)) 
[13:20:33.952]                               next
[13:20:33.952]                             invokeRestart(restart)
[13:20:33.952]                             muffled <- TRUE
[13:20:33.952]                             break
[13:20:33.952]                           }
[13:20:33.952]                         }
[13:20:33.952]                       }
[13:20:33.952]                       invisible(muffled)
[13:20:33.952]                     }
[13:20:33.952]                     muffleCondition(cond, pattern = "^muffle")
[13:20:33.952]                   }
[13:20:33.952]                 }
[13:20:33.952]             }
[13:20:33.952]         }))
[13:20:33.952]     }, error = function(ex) {
[13:20:33.952]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:33.952]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:33.952]                 ...future.rng), started = ...future.startTime, 
[13:20:33.952]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:33.952]             version = "1.8"), class = "FutureResult")
[13:20:33.952]     }, finally = {
[13:20:33.952]         if (!identical(...future.workdir, getwd())) 
[13:20:33.952]             setwd(...future.workdir)
[13:20:33.952]         {
[13:20:33.952]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:33.952]                 ...future.oldOptions$nwarnings <- NULL
[13:20:33.952]             }
[13:20:33.952]             base::options(...future.oldOptions)
[13:20:33.952]             if (.Platform$OS.type == "windows") {
[13:20:33.952]                 old_names <- names(...future.oldEnvVars)
[13:20:33.952]                 envs <- base::Sys.getenv()
[13:20:33.952]                 names <- names(envs)
[13:20:33.952]                 common <- intersect(names, old_names)
[13:20:33.952]                 added <- setdiff(names, old_names)
[13:20:33.952]                 removed <- setdiff(old_names, names)
[13:20:33.952]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:33.952]                   envs[common]]
[13:20:33.952]                 NAMES <- toupper(changed)
[13:20:33.952]                 args <- list()
[13:20:33.952]                 for (kk in seq_along(NAMES)) {
[13:20:33.952]                   name <- changed[[kk]]
[13:20:33.952]                   NAME <- NAMES[[kk]]
[13:20:33.952]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:33.952]                     next
[13:20:33.952]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:33.952]                 }
[13:20:33.952]                 NAMES <- toupper(added)
[13:20:33.952]                 for (kk in seq_along(NAMES)) {
[13:20:33.952]                   name <- added[[kk]]
[13:20:33.952]                   NAME <- NAMES[[kk]]
[13:20:33.952]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:33.952]                     next
[13:20:33.952]                   args[[name]] <- ""
[13:20:33.952]                 }
[13:20:33.952]                 NAMES <- toupper(removed)
[13:20:33.952]                 for (kk in seq_along(NAMES)) {
[13:20:33.952]                   name <- removed[[kk]]
[13:20:33.952]                   NAME <- NAMES[[kk]]
[13:20:33.952]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:33.952]                     next
[13:20:33.952]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:33.952]                 }
[13:20:33.952]                 if (length(args) > 0) 
[13:20:33.952]                   base::do.call(base::Sys.setenv, args = args)
[13:20:33.952]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:33.952]             }
[13:20:33.952]             else {
[13:20:33.952]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:33.952]             }
[13:20:33.952]             {
[13:20:33.952]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:33.952]                   0L) {
[13:20:33.952]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:33.952]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:33.952]                   base::options(opts)
[13:20:33.952]                 }
[13:20:33.952]                 {
[13:20:33.952]                   {
[13:20:33.952]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:33.952]                     NULL
[13:20:33.952]                   }
[13:20:33.952]                   options(future.plan = NULL)
[13:20:33.952]                   if (is.na(NA_character_)) 
[13:20:33.952]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:33.952]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:33.952]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:33.952]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:33.952]                     envir = parent.frame()) 
[13:20:33.952]                   {
[13:20:33.952]                     if (is.function(workers)) 
[13:20:33.952]                       workers <- workers()
[13:20:33.952]                     workers <- structure(as.integer(workers), 
[13:20:33.952]                       class = class(workers))
[13:20:33.952]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:33.952]                       workers >= 1)
[13:20:33.952]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:33.952]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:33.952]                     }
[13:20:33.952]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:33.952]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:33.952]                       envir = envir)
[13:20:33.952]                     if (!future$lazy) 
[13:20:33.952]                       future <- run(future)
[13:20:33.952]                     invisible(future)
[13:20:33.952]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:33.952]                 }
[13:20:33.952]             }
[13:20:33.952]         }
[13:20:33.952]     })
[13:20:33.952]     if (TRUE) {
[13:20:33.952]         base::sink(type = "output", split = FALSE)
[13:20:33.952]         if (TRUE) {
[13:20:33.952]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:33.952]         }
[13:20:33.952]         else {
[13:20:33.952]             ...future.result["stdout"] <- base::list(NULL)
[13:20:33.952]         }
[13:20:33.952]         base::close(...future.stdout)
[13:20:33.952]         ...future.stdout <- NULL
[13:20:33.952]     }
[13:20:33.952]     ...future.result$conditions <- ...future.conditions
[13:20:33.952]     ...future.result$finished <- base::Sys.time()
[13:20:33.952]     ...future.result
[13:20:33.952] }
[13:20:33.955] MultisessionFuture started
[13:20:33.955] - Launch lazy future ... done
[13:20:33.955] run() for ‘MultisessionFuture’ ... done
[13:20:33.956] result() for ClusterFuture ...
[13:20:33.956] receiveMessageFromWorker() for ClusterFuture ...
[13:20:33.956] - Validating connection of MultisessionFuture
[13:20:34.003] - received message: FutureResult
[13:20:34.003] - Received FutureResult
[13:20:34.004] - Erased future from FutureRegistry
[13:20:34.004] result() for ClusterFuture ...
[13:20:34.004] - result already collected: FutureResult
[13:20:34.004] result() for ClusterFuture ... done
[13:20:34.004] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:34.004] result() for ClusterFuture ... done
[13:20:34.004] result() for ClusterFuture ...
[13:20:34.004] - result already collected: FutureResult
[13:20:34.005] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[13:20:34.008] getGlobalsAndPackages() ...
[13:20:34.008] Searching for globals...
[13:20:34.009] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[13:20:34.009] Searching for globals ... DONE
[13:20:34.009] Resolving globals: FALSE
[13:20:34.010] 
[13:20:34.010] - packages: [2] ‘stats’, ‘datasets’
[13:20:34.010] getGlobalsAndPackages() ... DONE
[13:20:34.010] run() for ‘Future’ ...
[13:20:34.011] - state: ‘created’
[13:20:34.011] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:34.025] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:34.025] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:34.026]   - Field: ‘node’
[13:20:34.026]   - Field: ‘label’
[13:20:34.026]   - Field: ‘local’
[13:20:34.026]   - Field: ‘owner’
[13:20:34.026]   - Field: ‘envir’
[13:20:34.026]   - Field: ‘workers’
[13:20:34.026]   - Field: ‘packages’
[13:20:34.026]   - Field: ‘gc’
[13:20:34.026]   - Field: ‘conditions’
[13:20:34.026]   - Field: ‘persistent’
[13:20:34.026]   - Field: ‘expr’
[13:20:34.027]   - Field: ‘uuid’
[13:20:34.027]   - Field: ‘seed’
[13:20:34.027]   - Field: ‘version’
[13:20:34.027]   - Field: ‘result’
[13:20:34.027]   - Field: ‘asynchronous’
[13:20:34.027]   - Field: ‘calls’
[13:20:34.027]   - Field: ‘globals’
[13:20:34.027]   - Field: ‘stdout’
[13:20:34.027]   - Field: ‘earlySignal’
[13:20:34.027]   - Field: ‘lazy’
[13:20:34.027]   - Field: ‘state’
[13:20:34.028] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:34.028] - Launch lazy future ...
[13:20:34.028] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:20:34.028] Packages needed by future strategies (n = 0): <none>
[13:20:34.029] {
[13:20:34.029]     {
[13:20:34.029]         {
[13:20:34.029]             ...future.startTime <- base::Sys.time()
[13:20:34.029]             {
[13:20:34.029]                 {
[13:20:34.029]                   {
[13:20:34.029]                     {
[13:20:34.029]                       {
[13:20:34.029]                         base::local({
[13:20:34.029]                           has_future <- base::requireNamespace("future", 
[13:20:34.029]                             quietly = TRUE)
[13:20:34.029]                           if (has_future) {
[13:20:34.029]                             ns <- base::getNamespace("future")
[13:20:34.029]                             version <- ns[[".package"]][["version"]]
[13:20:34.029]                             if (is.null(version)) 
[13:20:34.029]                               version <- utils::packageVersion("future")
[13:20:34.029]                           }
[13:20:34.029]                           else {
[13:20:34.029]                             version <- NULL
[13:20:34.029]                           }
[13:20:34.029]                           if (!has_future || version < "1.8.0") {
[13:20:34.029]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:34.029]                               "", base::R.version$version.string), 
[13:20:34.029]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:34.029]                                 base::R.version$platform, 8 * 
[13:20:34.029]                                   base::.Machine$sizeof.pointer), 
[13:20:34.029]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:34.029]                                 "release", "version")], collapse = " "), 
[13:20:34.029]                               hostname = base::Sys.info()[["nodename"]])
[13:20:34.029]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:34.029]                               info)
[13:20:34.029]                             info <- base::paste(info, collapse = "; ")
[13:20:34.029]                             if (!has_future) {
[13:20:34.029]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:34.029]                                 info)
[13:20:34.029]                             }
[13:20:34.029]                             else {
[13:20:34.029]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:34.029]                                 info, version)
[13:20:34.029]                             }
[13:20:34.029]                             base::stop(msg)
[13:20:34.029]                           }
[13:20:34.029]                         })
[13:20:34.029]                       }
[13:20:34.029]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:34.029]                       base::options(mc.cores = 1L)
[13:20:34.029]                     }
[13:20:34.029]                     base::local({
[13:20:34.029]                       for (pkg in c("stats", "datasets")) {
[13:20:34.029]                         base::loadNamespace(pkg)
[13:20:34.029]                         base::library(pkg, character.only = TRUE)
[13:20:34.029]                       }
[13:20:34.029]                     })
[13:20:34.029]                   }
[13:20:34.029]                   options(future.plan = NULL)
[13:20:34.029]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:34.029]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:34.029]                 }
[13:20:34.029]                 ...future.workdir <- getwd()
[13:20:34.029]             }
[13:20:34.029]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:34.029]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:34.029]         }
[13:20:34.029]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:34.029]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:34.029]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:34.029]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:34.029]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:34.029]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:34.029]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:34.029]             base::names(...future.oldOptions))
[13:20:34.029]     }
[13:20:34.029]     if (FALSE) {
[13:20:34.029]     }
[13:20:34.029]     else {
[13:20:34.029]         if (TRUE) {
[13:20:34.029]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:34.029]                 open = "w")
[13:20:34.029]         }
[13:20:34.029]         else {
[13:20:34.029]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:34.029]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:34.029]         }
[13:20:34.029]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:34.029]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:34.029]             base::sink(type = "output", split = FALSE)
[13:20:34.029]             base::close(...future.stdout)
[13:20:34.029]         }, add = TRUE)
[13:20:34.029]     }
[13:20:34.029]     ...future.frame <- base::sys.nframe()
[13:20:34.029]     ...future.conditions <- base::list()
[13:20:34.029]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:34.029]     if (FALSE) {
[13:20:34.029]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:34.029]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:34.029]     }
[13:20:34.029]     ...future.result <- base::tryCatch({
[13:20:34.029]         base::withCallingHandlers({
[13:20:34.029]             ...future.value <- base::withVisible(base::local({
[13:20:34.029]                 ...future.makeSendCondition <- local({
[13:20:34.029]                   sendCondition <- NULL
[13:20:34.029]                   function(frame = 1L) {
[13:20:34.029]                     if (is.function(sendCondition)) 
[13:20:34.029]                       return(sendCondition)
[13:20:34.029]                     ns <- getNamespace("parallel")
[13:20:34.029]                     if (exists("sendData", mode = "function", 
[13:20:34.029]                       envir = ns)) {
[13:20:34.029]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:34.029]                         envir = ns)
[13:20:34.029]                       envir <- sys.frame(frame)
[13:20:34.029]                       master <- NULL
[13:20:34.029]                       while (!identical(envir, .GlobalEnv) && 
[13:20:34.029]                         !identical(envir, emptyenv())) {
[13:20:34.029]                         if (exists("master", mode = "list", envir = envir, 
[13:20:34.029]                           inherits = FALSE)) {
[13:20:34.029]                           master <- get("master", mode = "list", 
[13:20:34.029]                             envir = envir, inherits = FALSE)
[13:20:34.029]                           if (inherits(master, c("SOCKnode", 
[13:20:34.029]                             "SOCK0node"))) {
[13:20:34.029]                             sendCondition <<- function(cond) {
[13:20:34.029]                               data <- list(type = "VALUE", value = cond, 
[13:20:34.029]                                 success = TRUE)
[13:20:34.029]                               parallel_sendData(master, data)
[13:20:34.029]                             }
[13:20:34.029]                             return(sendCondition)
[13:20:34.029]                           }
[13:20:34.029]                         }
[13:20:34.029]                         frame <- frame + 1L
[13:20:34.029]                         envir <- sys.frame(frame)
[13:20:34.029]                       }
[13:20:34.029]                     }
[13:20:34.029]                     sendCondition <<- function(cond) NULL
[13:20:34.029]                   }
[13:20:34.029]                 })
[13:20:34.029]                 withCallingHandlers({
[13:20:34.029]                   {
[13:20:34.029]                     lm(dist ~ poly(speed, 2), data = cars)
[13:20:34.029]                   }
[13:20:34.029]                 }, immediateCondition = function(cond) {
[13:20:34.029]                   sendCondition <- ...future.makeSendCondition()
[13:20:34.029]                   sendCondition(cond)
[13:20:34.029]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:34.029]                   {
[13:20:34.029]                     inherits <- base::inherits
[13:20:34.029]                     invokeRestart <- base::invokeRestart
[13:20:34.029]                     is.null <- base::is.null
[13:20:34.029]                     muffled <- FALSE
[13:20:34.029]                     if (inherits(cond, "message")) {
[13:20:34.029]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:34.029]                       if (muffled) 
[13:20:34.029]                         invokeRestart("muffleMessage")
[13:20:34.029]                     }
[13:20:34.029]                     else if (inherits(cond, "warning")) {
[13:20:34.029]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:34.029]                       if (muffled) 
[13:20:34.029]                         invokeRestart("muffleWarning")
[13:20:34.029]                     }
[13:20:34.029]                     else if (inherits(cond, "condition")) {
[13:20:34.029]                       if (!is.null(pattern)) {
[13:20:34.029]                         computeRestarts <- base::computeRestarts
[13:20:34.029]                         grepl <- base::grepl
[13:20:34.029]                         restarts <- computeRestarts(cond)
[13:20:34.029]                         for (restart in restarts) {
[13:20:34.029]                           name <- restart$name
[13:20:34.029]                           if (is.null(name)) 
[13:20:34.029]                             next
[13:20:34.029]                           if (!grepl(pattern, name)) 
[13:20:34.029]                             next
[13:20:34.029]                           invokeRestart(restart)
[13:20:34.029]                           muffled <- TRUE
[13:20:34.029]                           break
[13:20:34.029]                         }
[13:20:34.029]                       }
[13:20:34.029]                     }
[13:20:34.029]                     invisible(muffled)
[13:20:34.029]                   }
[13:20:34.029]                   muffleCondition(cond)
[13:20:34.029]                 })
[13:20:34.029]             }))
[13:20:34.029]             future::FutureResult(value = ...future.value$value, 
[13:20:34.029]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:34.029]                   ...future.rng), globalenv = if (FALSE) 
[13:20:34.029]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:34.029]                     ...future.globalenv.names))
[13:20:34.029]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:34.029]         }, condition = base::local({
[13:20:34.029]             c <- base::c
[13:20:34.029]             inherits <- base::inherits
[13:20:34.029]             invokeRestart <- base::invokeRestart
[13:20:34.029]             length <- base::length
[13:20:34.029]             list <- base::list
[13:20:34.029]             seq.int <- base::seq.int
[13:20:34.029]             signalCondition <- base::signalCondition
[13:20:34.029]             sys.calls <- base::sys.calls
[13:20:34.029]             `[[` <- base::`[[`
[13:20:34.029]             `+` <- base::`+`
[13:20:34.029]             `<<-` <- base::`<<-`
[13:20:34.029]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:34.029]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:34.029]                   3L)]
[13:20:34.029]             }
[13:20:34.029]             function(cond) {
[13:20:34.029]                 is_error <- inherits(cond, "error")
[13:20:34.029]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:34.029]                   NULL)
[13:20:34.029]                 if (is_error) {
[13:20:34.029]                   sessionInformation <- function() {
[13:20:34.029]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:34.029]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:34.029]                       search = base::search(), system = base::Sys.info())
[13:20:34.029]                   }
[13:20:34.029]                   ...future.conditions[[length(...future.conditions) + 
[13:20:34.029]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:34.029]                     cond$call), session = sessionInformation(), 
[13:20:34.029]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:34.029]                   signalCondition(cond)
[13:20:34.029]                 }
[13:20:34.029]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:34.029]                 "immediateCondition"))) {
[13:20:34.029]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:34.029]                   ...future.conditions[[length(...future.conditions) + 
[13:20:34.029]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:34.029]                   if (TRUE && !signal) {
[13:20:34.029]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:34.029]                     {
[13:20:34.029]                       inherits <- base::inherits
[13:20:34.029]                       invokeRestart <- base::invokeRestart
[13:20:34.029]                       is.null <- base::is.null
[13:20:34.029]                       muffled <- FALSE
[13:20:34.029]                       if (inherits(cond, "message")) {
[13:20:34.029]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:34.029]                         if (muffled) 
[13:20:34.029]                           invokeRestart("muffleMessage")
[13:20:34.029]                       }
[13:20:34.029]                       else if (inherits(cond, "warning")) {
[13:20:34.029]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:34.029]                         if (muffled) 
[13:20:34.029]                           invokeRestart("muffleWarning")
[13:20:34.029]                       }
[13:20:34.029]                       else if (inherits(cond, "condition")) {
[13:20:34.029]                         if (!is.null(pattern)) {
[13:20:34.029]                           computeRestarts <- base::computeRestarts
[13:20:34.029]                           grepl <- base::grepl
[13:20:34.029]                           restarts <- computeRestarts(cond)
[13:20:34.029]                           for (restart in restarts) {
[13:20:34.029]                             name <- restart$name
[13:20:34.029]                             if (is.null(name)) 
[13:20:34.029]                               next
[13:20:34.029]                             if (!grepl(pattern, name)) 
[13:20:34.029]                               next
[13:20:34.029]                             invokeRestart(restart)
[13:20:34.029]                             muffled <- TRUE
[13:20:34.029]                             break
[13:20:34.029]                           }
[13:20:34.029]                         }
[13:20:34.029]                       }
[13:20:34.029]                       invisible(muffled)
[13:20:34.029]                     }
[13:20:34.029]                     muffleCondition(cond, pattern = "^muffle")
[13:20:34.029]                   }
[13:20:34.029]                 }
[13:20:34.029]                 else {
[13:20:34.029]                   if (TRUE) {
[13:20:34.029]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:34.029]                     {
[13:20:34.029]                       inherits <- base::inherits
[13:20:34.029]                       invokeRestart <- base::invokeRestart
[13:20:34.029]                       is.null <- base::is.null
[13:20:34.029]                       muffled <- FALSE
[13:20:34.029]                       if (inherits(cond, "message")) {
[13:20:34.029]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:34.029]                         if (muffled) 
[13:20:34.029]                           invokeRestart("muffleMessage")
[13:20:34.029]                       }
[13:20:34.029]                       else if (inherits(cond, "warning")) {
[13:20:34.029]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:34.029]                         if (muffled) 
[13:20:34.029]                           invokeRestart("muffleWarning")
[13:20:34.029]                       }
[13:20:34.029]                       else if (inherits(cond, "condition")) {
[13:20:34.029]                         if (!is.null(pattern)) {
[13:20:34.029]                           computeRestarts <- base::computeRestarts
[13:20:34.029]                           grepl <- base::grepl
[13:20:34.029]                           restarts <- computeRestarts(cond)
[13:20:34.029]                           for (restart in restarts) {
[13:20:34.029]                             name <- restart$name
[13:20:34.029]                             if (is.null(name)) 
[13:20:34.029]                               next
[13:20:34.029]                             if (!grepl(pattern, name)) 
[13:20:34.029]                               next
[13:20:34.029]                             invokeRestart(restart)
[13:20:34.029]                             muffled <- TRUE
[13:20:34.029]                             break
[13:20:34.029]                           }
[13:20:34.029]                         }
[13:20:34.029]                       }
[13:20:34.029]                       invisible(muffled)
[13:20:34.029]                     }
[13:20:34.029]                     muffleCondition(cond, pattern = "^muffle")
[13:20:34.029]                   }
[13:20:34.029]                 }
[13:20:34.029]             }
[13:20:34.029]         }))
[13:20:34.029]     }, error = function(ex) {
[13:20:34.029]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:34.029]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:34.029]                 ...future.rng), started = ...future.startTime, 
[13:20:34.029]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:34.029]             version = "1.8"), class = "FutureResult")
[13:20:34.029]     }, finally = {
[13:20:34.029]         if (!identical(...future.workdir, getwd())) 
[13:20:34.029]             setwd(...future.workdir)
[13:20:34.029]         {
[13:20:34.029]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:34.029]                 ...future.oldOptions$nwarnings <- NULL
[13:20:34.029]             }
[13:20:34.029]             base::options(...future.oldOptions)
[13:20:34.029]             if (.Platform$OS.type == "windows") {
[13:20:34.029]                 old_names <- names(...future.oldEnvVars)
[13:20:34.029]                 envs <- base::Sys.getenv()
[13:20:34.029]                 names <- names(envs)
[13:20:34.029]                 common <- intersect(names, old_names)
[13:20:34.029]                 added <- setdiff(names, old_names)
[13:20:34.029]                 removed <- setdiff(old_names, names)
[13:20:34.029]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:34.029]                   envs[common]]
[13:20:34.029]                 NAMES <- toupper(changed)
[13:20:34.029]                 args <- list()
[13:20:34.029]                 for (kk in seq_along(NAMES)) {
[13:20:34.029]                   name <- changed[[kk]]
[13:20:34.029]                   NAME <- NAMES[[kk]]
[13:20:34.029]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:34.029]                     next
[13:20:34.029]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:34.029]                 }
[13:20:34.029]                 NAMES <- toupper(added)
[13:20:34.029]                 for (kk in seq_along(NAMES)) {
[13:20:34.029]                   name <- added[[kk]]
[13:20:34.029]                   NAME <- NAMES[[kk]]
[13:20:34.029]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:34.029]                     next
[13:20:34.029]                   args[[name]] <- ""
[13:20:34.029]                 }
[13:20:34.029]                 NAMES <- toupper(removed)
[13:20:34.029]                 for (kk in seq_along(NAMES)) {
[13:20:34.029]                   name <- removed[[kk]]
[13:20:34.029]                   NAME <- NAMES[[kk]]
[13:20:34.029]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:34.029]                     next
[13:20:34.029]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:34.029]                 }
[13:20:34.029]                 if (length(args) > 0) 
[13:20:34.029]                   base::do.call(base::Sys.setenv, args = args)
[13:20:34.029]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:34.029]             }
[13:20:34.029]             else {
[13:20:34.029]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:34.029]             }
[13:20:34.029]             {
[13:20:34.029]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:34.029]                   0L) {
[13:20:34.029]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:34.029]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:34.029]                   base::options(opts)
[13:20:34.029]                 }
[13:20:34.029]                 {
[13:20:34.029]                   {
[13:20:34.029]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:34.029]                     NULL
[13:20:34.029]                   }
[13:20:34.029]                   options(future.plan = NULL)
[13:20:34.029]                   if (is.na(NA_character_)) 
[13:20:34.029]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:34.029]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:34.029]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:34.029]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:34.029]                     envir = parent.frame()) 
[13:20:34.029]                   {
[13:20:34.029]                     if (is.function(workers)) 
[13:20:34.029]                       workers <- workers()
[13:20:34.029]                     workers <- structure(as.integer(workers), 
[13:20:34.029]                       class = class(workers))
[13:20:34.029]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:34.029]                       workers >= 1)
[13:20:34.029]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:34.029]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:34.029]                     }
[13:20:34.029]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:34.029]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:34.029]                       envir = envir)
[13:20:34.029]                     if (!future$lazy) 
[13:20:34.029]                       future <- run(future)
[13:20:34.029]                     invisible(future)
[13:20:34.029]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:34.029]                 }
[13:20:34.029]             }
[13:20:34.029]         }
[13:20:34.029]     })
[13:20:34.029]     if (TRUE) {
[13:20:34.029]         base::sink(type = "output", split = FALSE)
[13:20:34.029]         if (TRUE) {
[13:20:34.029]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:34.029]         }
[13:20:34.029]         else {
[13:20:34.029]             ...future.result["stdout"] <- base::list(NULL)
[13:20:34.029]         }
[13:20:34.029]         base::close(...future.stdout)
[13:20:34.029]         ...future.stdout <- NULL
[13:20:34.029]     }
[13:20:34.029]     ...future.result$conditions <- ...future.conditions
[13:20:34.029]     ...future.result$finished <- base::Sys.time()
[13:20:34.029]     ...future.result
[13:20:34.029] }
[13:20:34.032] MultisessionFuture started
[13:20:34.032] - Launch lazy future ... done
[13:20:34.032] run() for ‘MultisessionFuture’ ... done
[13:20:34.032] result() for ClusterFuture ...
[13:20:34.032] receiveMessageFromWorker() for ClusterFuture ...
[13:20:34.032] - Validating connection of MultisessionFuture
[13:20:34.080] - received message: FutureResult
[13:20:34.080] - Received FutureResult
[13:20:34.081] - Erased future from FutureRegistry
[13:20:34.081] result() for ClusterFuture ...
[13:20:34.081] - result already collected: FutureResult
[13:20:34.081] result() for ClusterFuture ... done
[13:20:34.081] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:34.081] result() for ClusterFuture ... done
[13:20:34.081] result() for ClusterFuture ...
[13:20:34.081] - result already collected: FutureResult
[13:20:34.081] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[13:20:34.083] getGlobalsAndPackages() ...
[13:20:34.083] Searching for globals...
[13:20:34.088] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[13:20:34.088] Searching for globals ... DONE
[13:20:34.088] Resolving globals: FALSE
[13:20:34.089] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[13:20:34.089] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[13:20:34.089] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[13:20:34.089] 
[13:20:34.089] getGlobalsAndPackages() ... DONE
[13:20:34.090] run() for ‘Future’ ...
[13:20:34.090] - state: ‘created’
[13:20:34.090] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:34.105] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:34.105] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:34.105]   - Field: ‘node’
[13:20:34.105]   - Field: ‘label’
[13:20:34.105]   - Field: ‘local’
[13:20:34.105]   - Field: ‘owner’
[13:20:34.106]   - Field: ‘envir’
[13:20:34.106]   - Field: ‘workers’
[13:20:34.108]   - Field: ‘packages’
[13:20:34.108]   - Field: ‘gc’
[13:20:34.108]   - Field: ‘conditions’
[13:20:34.108]   - Field: ‘persistent’
[13:20:34.108]   - Field: ‘expr’
[13:20:34.108]   - Field: ‘uuid’
[13:20:34.109]   - Field: ‘seed’
[13:20:34.109]   - Field: ‘version’
[13:20:34.109]   - Field: ‘result’
[13:20:34.109]   - Field: ‘asynchronous’
[13:20:34.109]   - Field: ‘calls’
[13:20:34.109]   - Field: ‘globals’
[13:20:34.109]   - Field: ‘stdout’
[13:20:34.109]   - Field: ‘earlySignal’
[13:20:34.109]   - Field: ‘lazy’
[13:20:34.109]   - Field: ‘state’
[13:20:34.109] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:34.110] - Launch lazy future ...
[13:20:34.110] Packages needed by the future expression (n = 0): <none>
[13:20:34.110] Packages needed by future strategies (n = 0): <none>
[13:20:34.110] {
[13:20:34.110]     {
[13:20:34.110]         {
[13:20:34.110]             ...future.startTime <- base::Sys.time()
[13:20:34.110]             {
[13:20:34.110]                 {
[13:20:34.110]                   {
[13:20:34.110]                     {
[13:20:34.110]                       base::local({
[13:20:34.110]                         has_future <- base::requireNamespace("future", 
[13:20:34.110]                           quietly = TRUE)
[13:20:34.110]                         if (has_future) {
[13:20:34.110]                           ns <- base::getNamespace("future")
[13:20:34.110]                           version <- ns[[".package"]][["version"]]
[13:20:34.110]                           if (is.null(version)) 
[13:20:34.110]                             version <- utils::packageVersion("future")
[13:20:34.110]                         }
[13:20:34.110]                         else {
[13:20:34.110]                           version <- NULL
[13:20:34.110]                         }
[13:20:34.110]                         if (!has_future || version < "1.8.0") {
[13:20:34.110]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:34.110]                             "", base::R.version$version.string), 
[13:20:34.110]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:34.110]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:34.110]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:34.110]                               "release", "version")], collapse = " "), 
[13:20:34.110]                             hostname = base::Sys.info()[["nodename"]])
[13:20:34.110]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:34.110]                             info)
[13:20:34.110]                           info <- base::paste(info, collapse = "; ")
[13:20:34.110]                           if (!has_future) {
[13:20:34.110]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:34.110]                               info)
[13:20:34.110]                           }
[13:20:34.110]                           else {
[13:20:34.110]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:34.110]                               info, version)
[13:20:34.110]                           }
[13:20:34.110]                           base::stop(msg)
[13:20:34.110]                         }
[13:20:34.110]                       })
[13:20:34.110]                     }
[13:20:34.110]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:34.110]                     base::options(mc.cores = 1L)
[13:20:34.110]                   }
[13:20:34.110]                   options(future.plan = NULL)
[13:20:34.110]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:34.110]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:34.110]                 }
[13:20:34.110]                 ...future.workdir <- getwd()
[13:20:34.110]             }
[13:20:34.110]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:34.110]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:34.110]         }
[13:20:34.110]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:34.110]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:34.110]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:34.110]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:34.110]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:34.110]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:34.110]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:34.110]             base::names(...future.oldOptions))
[13:20:34.110]     }
[13:20:34.110]     if (FALSE) {
[13:20:34.110]     }
[13:20:34.110]     else {
[13:20:34.110]         if (TRUE) {
[13:20:34.110]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:34.110]                 open = "w")
[13:20:34.110]         }
[13:20:34.110]         else {
[13:20:34.110]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:34.110]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:34.110]         }
[13:20:34.110]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:34.110]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:34.110]             base::sink(type = "output", split = FALSE)
[13:20:34.110]             base::close(...future.stdout)
[13:20:34.110]         }, add = TRUE)
[13:20:34.110]     }
[13:20:34.110]     ...future.frame <- base::sys.nframe()
[13:20:34.110]     ...future.conditions <- base::list()
[13:20:34.110]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:34.110]     if (FALSE) {
[13:20:34.110]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:34.110]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:34.110]     }
[13:20:34.110]     ...future.result <- base::tryCatch({
[13:20:34.110]         base::withCallingHandlers({
[13:20:34.110]             ...future.value <- base::withVisible(base::local({
[13:20:34.110]                 ...future.makeSendCondition <- local({
[13:20:34.110]                   sendCondition <- NULL
[13:20:34.110]                   function(frame = 1L) {
[13:20:34.110]                     if (is.function(sendCondition)) 
[13:20:34.110]                       return(sendCondition)
[13:20:34.110]                     ns <- getNamespace("parallel")
[13:20:34.110]                     if (exists("sendData", mode = "function", 
[13:20:34.110]                       envir = ns)) {
[13:20:34.110]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:34.110]                         envir = ns)
[13:20:34.110]                       envir <- sys.frame(frame)
[13:20:34.110]                       master <- NULL
[13:20:34.110]                       while (!identical(envir, .GlobalEnv) && 
[13:20:34.110]                         !identical(envir, emptyenv())) {
[13:20:34.110]                         if (exists("master", mode = "list", envir = envir, 
[13:20:34.110]                           inherits = FALSE)) {
[13:20:34.110]                           master <- get("master", mode = "list", 
[13:20:34.110]                             envir = envir, inherits = FALSE)
[13:20:34.110]                           if (inherits(master, c("SOCKnode", 
[13:20:34.110]                             "SOCK0node"))) {
[13:20:34.110]                             sendCondition <<- function(cond) {
[13:20:34.110]                               data <- list(type = "VALUE", value = cond, 
[13:20:34.110]                                 success = TRUE)
[13:20:34.110]                               parallel_sendData(master, data)
[13:20:34.110]                             }
[13:20:34.110]                             return(sendCondition)
[13:20:34.110]                           }
[13:20:34.110]                         }
[13:20:34.110]                         frame <- frame + 1L
[13:20:34.110]                         envir <- sys.frame(frame)
[13:20:34.110]                       }
[13:20:34.110]                     }
[13:20:34.110]                     sendCondition <<- function(cond) NULL
[13:20:34.110]                   }
[13:20:34.110]                 })
[13:20:34.110]                 withCallingHandlers({
[13:20:34.110]                   {
[13:20:34.110]                     outer_function(1L)
[13:20:34.110]                   }
[13:20:34.110]                 }, immediateCondition = function(cond) {
[13:20:34.110]                   sendCondition <- ...future.makeSendCondition()
[13:20:34.110]                   sendCondition(cond)
[13:20:34.110]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:34.110]                   {
[13:20:34.110]                     inherits <- base::inherits
[13:20:34.110]                     invokeRestart <- base::invokeRestart
[13:20:34.110]                     is.null <- base::is.null
[13:20:34.110]                     muffled <- FALSE
[13:20:34.110]                     if (inherits(cond, "message")) {
[13:20:34.110]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:34.110]                       if (muffled) 
[13:20:34.110]                         invokeRestart("muffleMessage")
[13:20:34.110]                     }
[13:20:34.110]                     else if (inherits(cond, "warning")) {
[13:20:34.110]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:34.110]                       if (muffled) 
[13:20:34.110]                         invokeRestart("muffleWarning")
[13:20:34.110]                     }
[13:20:34.110]                     else if (inherits(cond, "condition")) {
[13:20:34.110]                       if (!is.null(pattern)) {
[13:20:34.110]                         computeRestarts <- base::computeRestarts
[13:20:34.110]                         grepl <- base::grepl
[13:20:34.110]                         restarts <- computeRestarts(cond)
[13:20:34.110]                         for (restart in restarts) {
[13:20:34.110]                           name <- restart$name
[13:20:34.110]                           if (is.null(name)) 
[13:20:34.110]                             next
[13:20:34.110]                           if (!grepl(pattern, name)) 
[13:20:34.110]                             next
[13:20:34.110]                           invokeRestart(restart)
[13:20:34.110]                           muffled <- TRUE
[13:20:34.110]                           break
[13:20:34.110]                         }
[13:20:34.110]                       }
[13:20:34.110]                     }
[13:20:34.110]                     invisible(muffled)
[13:20:34.110]                   }
[13:20:34.110]                   muffleCondition(cond)
[13:20:34.110]                 })
[13:20:34.110]             }))
[13:20:34.110]             future::FutureResult(value = ...future.value$value, 
[13:20:34.110]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:34.110]                   ...future.rng), globalenv = if (FALSE) 
[13:20:34.110]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:34.110]                     ...future.globalenv.names))
[13:20:34.110]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:34.110]         }, condition = base::local({
[13:20:34.110]             c <- base::c
[13:20:34.110]             inherits <- base::inherits
[13:20:34.110]             invokeRestart <- base::invokeRestart
[13:20:34.110]             length <- base::length
[13:20:34.110]             list <- base::list
[13:20:34.110]             seq.int <- base::seq.int
[13:20:34.110]             signalCondition <- base::signalCondition
[13:20:34.110]             sys.calls <- base::sys.calls
[13:20:34.110]             `[[` <- base::`[[`
[13:20:34.110]             `+` <- base::`+`
[13:20:34.110]             `<<-` <- base::`<<-`
[13:20:34.110]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:34.110]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:34.110]                   3L)]
[13:20:34.110]             }
[13:20:34.110]             function(cond) {
[13:20:34.110]                 is_error <- inherits(cond, "error")
[13:20:34.110]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:34.110]                   NULL)
[13:20:34.110]                 if (is_error) {
[13:20:34.110]                   sessionInformation <- function() {
[13:20:34.110]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:34.110]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:34.110]                       search = base::search(), system = base::Sys.info())
[13:20:34.110]                   }
[13:20:34.110]                   ...future.conditions[[length(...future.conditions) + 
[13:20:34.110]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:34.110]                     cond$call), session = sessionInformation(), 
[13:20:34.110]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:34.110]                   signalCondition(cond)
[13:20:34.110]                 }
[13:20:34.110]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:34.110]                 "immediateCondition"))) {
[13:20:34.110]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:34.110]                   ...future.conditions[[length(...future.conditions) + 
[13:20:34.110]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:34.110]                   if (TRUE && !signal) {
[13:20:34.110]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:34.110]                     {
[13:20:34.110]                       inherits <- base::inherits
[13:20:34.110]                       invokeRestart <- base::invokeRestart
[13:20:34.110]                       is.null <- base::is.null
[13:20:34.110]                       muffled <- FALSE
[13:20:34.110]                       if (inherits(cond, "message")) {
[13:20:34.110]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:34.110]                         if (muffled) 
[13:20:34.110]                           invokeRestart("muffleMessage")
[13:20:34.110]                       }
[13:20:34.110]                       else if (inherits(cond, "warning")) {
[13:20:34.110]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:34.110]                         if (muffled) 
[13:20:34.110]                           invokeRestart("muffleWarning")
[13:20:34.110]                       }
[13:20:34.110]                       else if (inherits(cond, "condition")) {
[13:20:34.110]                         if (!is.null(pattern)) {
[13:20:34.110]                           computeRestarts <- base::computeRestarts
[13:20:34.110]                           grepl <- base::grepl
[13:20:34.110]                           restarts <- computeRestarts(cond)
[13:20:34.110]                           for (restart in restarts) {
[13:20:34.110]                             name <- restart$name
[13:20:34.110]                             if (is.null(name)) 
[13:20:34.110]                               next
[13:20:34.110]                             if (!grepl(pattern, name)) 
[13:20:34.110]                               next
[13:20:34.110]                             invokeRestart(restart)
[13:20:34.110]                             muffled <- TRUE
[13:20:34.110]                             break
[13:20:34.110]                           }
[13:20:34.110]                         }
[13:20:34.110]                       }
[13:20:34.110]                       invisible(muffled)
[13:20:34.110]                     }
[13:20:34.110]                     muffleCondition(cond, pattern = "^muffle")
[13:20:34.110]                   }
[13:20:34.110]                 }
[13:20:34.110]                 else {
[13:20:34.110]                   if (TRUE) {
[13:20:34.110]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:34.110]                     {
[13:20:34.110]                       inherits <- base::inherits
[13:20:34.110]                       invokeRestart <- base::invokeRestart
[13:20:34.110]                       is.null <- base::is.null
[13:20:34.110]                       muffled <- FALSE
[13:20:34.110]                       if (inherits(cond, "message")) {
[13:20:34.110]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:34.110]                         if (muffled) 
[13:20:34.110]                           invokeRestart("muffleMessage")
[13:20:34.110]                       }
[13:20:34.110]                       else if (inherits(cond, "warning")) {
[13:20:34.110]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:34.110]                         if (muffled) 
[13:20:34.110]                           invokeRestart("muffleWarning")
[13:20:34.110]                       }
[13:20:34.110]                       else if (inherits(cond, "condition")) {
[13:20:34.110]                         if (!is.null(pattern)) {
[13:20:34.110]                           computeRestarts <- base::computeRestarts
[13:20:34.110]                           grepl <- base::grepl
[13:20:34.110]                           restarts <- computeRestarts(cond)
[13:20:34.110]                           for (restart in restarts) {
[13:20:34.110]                             name <- restart$name
[13:20:34.110]                             if (is.null(name)) 
[13:20:34.110]                               next
[13:20:34.110]                             if (!grepl(pattern, name)) 
[13:20:34.110]                               next
[13:20:34.110]                             invokeRestart(restart)
[13:20:34.110]                             muffled <- TRUE
[13:20:34.110]                             break
[13:20:34.110]                           }
[13:20:34.110]                         }
[13:20:34.110]                       }
[13:20:34.110]                       invisible(muffled)
[13:20:34.110]                     }
[13:20:34.110]                     muffleCondition(cond, pattern = "^muffle")
[13:20:34.110]                   }
[13:20:34.110]                 }
[13:20:34.110]             }
[13:20:34.110]         }))
[13:20:34.110]     }, error = function(ex) {
[13:20:34.110]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:34.110]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:34.110]                 ...future.rng), started = ...future.startTime, 
[13:20:34.110]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:34.110]             version = "1.8"), class = "FutureResult")
[13:20:34.110]     }, finally = {
[13:20:34.110]         if (!identical(...future.workdir, getwd())) 
[13:20:34.110]             setwd(...future.workdir)
[13:20:34.110]         {
[13:20:34.110]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:34.110]                 ...future.oldOptions$nwarnings <- NULL
[13:20:34.110]             }
[13:20:34.110]             base::options(...future.oldOptions)
[13:20:34.110]             if (.Platform$OS.type == "windows") {
[13:20:34.110]                 old_names <- names(...future.oldEnvVars)
[13:20:34.110]                 envs <- base::Sys.getenv()
[13:20:34.110]                 names <- names(envs)
[13:20:34.110]                 common <- intersect(names, old_names)
[13:20:34.110]                 added <- setdiff(names, old_names)
[13:20:34.110]                 removed <- setdiff(old_names, names)
[13:20:34.110]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:34.110]                   envs[common]]
[13:20:34.110]                 NAMES <- toupper(changed)
[13:20:34.110]                 args <- list()
[13:20:34.110]                 for (kk in seq_along(NAMES)) {
[13:20:34.110]                   name <- changed[[kk]]
[13:20:34.110]                   NAME <- NAMES[[kk]]
[13:20:34.110]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:34.110]                     next
[13:20:34.110]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:34.110]                 }
[13:20:34.110]                 NAMES <- toupper(added)
[13:20:34.110]                 for (kk in seq_along(NAMES)) {
[13:20:34.110]                   name <- added[[kk]]
[13:20:34.110]                   NAME <- NAMES[[kk]]
[13:20:34.110]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:34.110]                     next
[13:20:34.110]                   args[[name]] <- ""
[13:20:34.110]                 }
[13:20:34.110]                 NAMES <- toupper(removed)
[13:20:34.110]                 for (kk in seq_along(NAMES)) {
[13:20:34.110]                   name <- removed[[kk]]
[13:20:34.110]                   NAME <- NAMES[[kk]]
[13:20:34.110]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:34.110]                     next
[13:20:34.110]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:34.110]                 }
[13:20:34.110]                 if (length(args) > 0) 
[13:20:34.110]                   base::do.call(base::Sys.setenv, args = args)
[13:20:34.110]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:34.110]             }
[13:20:34.110]             else {
[13:20:34.110]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:34.110]             }
[13:20:34.110]             {
[13:20:34.110]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:34.110]                   0L) {
[13:20:34.110]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:34.110]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:34.110]                   base::options(opts)
[13:20:34.110]                 }
[13:20:34.110]                 {
[13:20:34.110]                   {
[13:20:34.110]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:34.110]                     NULL
[13:20:34.110]                   }
[13:20:34.110]                   options(future.plan = NULL)
[13:20:34.110]                   if (is.na(NA_character_)) 
[13:20:34.110]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:34.110]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:34.110]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:34.110]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:34.110]                     envir = parent.frame()) 
[13:20:34.110]                   {
[13:20:34.110]                     if (is.function(workers)) 
[13:20:34.110]                       workers <- workers()
[13:20:34.110]                     workers <- structure(as.integer(workers), 
[13:20:34.110]                       class = class(workers))
[13:20:34.110]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:34.110]                       workers >= 1)
[13:20:34.110]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:34.110]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:34.110]                     }
[13:20:34.110]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:34.110]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:34.110]                       envir = envir)
[13:20:34.110]                     if (!future$lazy) 
[13:20:34.110]                       future <- run(future)
[13:20:34.110]                     invisible(future)
[13:20:34.110]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:34.110]                 }
[13:20:34.110]             }
[13:20:34.110]         }
[13:20:34.110]     })
[13:20:34.110]     if (TRUE) {
[13:20:34.110]         base::sink(type = "output", split = FALSE)
[13:20:34.110]         if (TRUE) {
[13:20:34.110]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:34.110]         }
[13:20:34.110]         else {
[13:20:34.110]             ...future.result["stdout"] <- base::list(NULL)
[13:20:34.110]         }
[13:20:34.110]         base::close(...future.stdout)
[13:20:34.110]         ...future.stdout <- NULL
[13:20:34.110]     }
[13:20:34.110]     ...future.result$conditions <- ...future.conditions
[13:20:34.110]     ...future.result$finished <- base::Sys.time()
[13:20:34.110]     ...future.result
[13:20:34.110] }
[13:20:34.113] Exporting 3 global objects (7.52 KiB) to cluster node #1 ...
[13:20:34.113] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ...
[13:20:34.114] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ... DONE
[13:20:34.114] Exporting ‘map’ (4.43 KiB) to cluster node #1 ...
[13:20:34.114] Exporting ‘map’ (4.43 KiB) to cluster node #1 ... DONE
[13:20:34.115] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ...
[13:20:34.115] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ... DONE
[13:20:34.115] Exporting 3 global objects (7.52 KiB) to cluster node #1 ... DONE
[13:20:34.116] MultisessionFuture started
[13:20:34.116] - Launch lazy future ... done
[13:20:34.116] run() for ‘MultisessionFuture’ ... done
[13:20:34.116] result() for ClusterFuture ...
[13:20:34.116] receiveMessageFromWorker() for ClusterFuture ...
[13:20:34.116] - Validating connection of MultisessionFuture
[13:20:34.167] - received message: FutureResult
[13:20:34.167] - Received FutureResult
[13:20:34.167] - Erased future from FutureRegistry
[13:20:34.167] result() for ClusterFuture ...
[13:20:34.168] - result already collected: FutureResult
[13:20:34.168] result() for ClusterFuture ... done
[13:20:34.168] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:34.168] result() for ClusterFuture ... done
[13:20:34.168] result() for ClusterFuture ...
[13:20:34.168] - result already collected: FutureResult
[13:20:34.168] result() for ClusterFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[13:20:34.170] getGlobalsAndPackages() ...
[13:20:34.170] Searching for globals...
[13:20:34.174] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[13:20:34.174] Searching for globals ... DONE
[13:20:34.174] Resolving globals: FALSE
[13:20:34.175] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[13:20:34.175] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[13:20:34.176] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[13:20:34.176] 
[13:20:34.176] getGlobalsAndPackages() ... DONE
[13:20:34.176] run() for ‘Future’ ...
[13:20:34.176] - state: ‘created’
[13:20:34.176] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:34.191] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:34.191] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:34.191]   - Field: ‘node’
[13:20:34.191]   - Field: ‘label’
[13:20:34.191]   - Field: ‘local’
[13:20:34.191]   - Field: ‘owner’
[13:20:34.191]   - Field: ‘envir’
[13:20:34.192]   - Field: ‘workers’
[13:20:34.192]   - Field: ‘packages’
[13:20:34.192]   - Field: ‘gc’
[13:20:34.192]   - Field: ‘conditions’
[13:20:34.192]   - Field: ‘persistent’
[13:20:34.192]   - Field: ‘expr’
[13:20:34.192]   - Field: ‘uuid’
[13:20:34.192]   - Field: ‘seed’
[13:20:34.192]   - Field: ‘version’
[13:20:34.192]   - Field: ‘result’
[13:20:34.192]   - Field: ‘asynchronous’
[13:20:34.193]   - Field: ‘calls’
[13:20:34.193]   - Field: ‘globals’
[13:20:34.193]   - Field: ‘stdout’
[13:20:34.193]   - Field: ‘earlySignal’
[13:20:34.193]   - Field: ‘lazy’
[13:20:34.193]   - Field: ‘state’
[13:20:34.193] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:34.193] - Launch lazy future ...
[13:20:34.194] Packages needed by the future expression (n = 0): <none>
[13:20:34.194] Packages needed by future strategies (n = 0): <none>
[13:20:34.194] {
[13:20:34.194]     {
[13:20:34.194]         {
[13:20:34.194]             ...future.startTime <- base::Sys.time()
[13:20:34.194]             {
[13:20:34.194]                 {
[13:20:34.194]                   {
[13:20:34.194]                     {
[13:20:34.194]                       base::local({
[13:20:34.194]                         has_future <- base::requireNamespace("future", 
[13:20:34.194]                           quietly = TRUE)
[13:20:34.194]                         if (has_future) {
[13:20:34.194]                           ns <- base::getNamespace("future")
[13:20:34.194]                           version <- ns[[".package"]][["version"]]
[13:20:34.194]                           if (is.null(version)) 
[13:20:34.194]                             version <- utils::packageVersion("future")
[13:20:34.194]                         }
[13:20:34.194]                         else {
[13:20:34.194]                           version <- NULL
[13:20:34.194]                         }
[13:20:34.194]                         if (!has_future || version < "1.8.0") {
[13:20:34.194]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:34.194]                             "", base::R.version$version.string), 
[13:20:34.194]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:34.194]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:34.194]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:34.194]                               "release", "version")], collapse = " "), 
[13:20:34.194]                             hostname = base::Sys.info()[["nodename"]])
[13:20:34.194]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:34.194]                             info)
[13:20:34.194]                           info <- base::paste(info, collapse = "; ")
[13:20:34.194]                           if (!has_future) {
[13:20:34.194]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:34.194]                               info)
[13:20:34.194]                           }
[13:20:34.194]                           else {
[13:20:34.194]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:34.194]                               info, version)
[13:20:34.194]                           }
[13:20:34.194]                           base::stop(msg)
[13:20:34.194]                         }
[13:20:34.194]                       })
[13:20:34.194]                     }
[13:20:34.194]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:34.194]                     base::options(mc.cores = 1L)
[13:20:34.194]                   }
[13:20:34.194]                   options(future.plan = NULL)
[13:20:34.194]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:34.194]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:34.194]                 }
[13:20:34.194]                 ...future.workdir <- getwd()
[13:20:34.194]             }
[13:20:34.194]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:34.194]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:34.194]         }
[13:20:34.194]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:34.194]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:34.194]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:34.194]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:34.194]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:34.194]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:34.194]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:34.194]             base::names(...future.oldOptions))
[13:20:34.194]     }
[13:20:34.194]     if (FALSE) {
[13:20:34.194]     }
[13:20:34.194]     else {
[13:20:34.194]         if (TRUE) {
[13:20:34.194]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:34.194]                 open = "w")
[13:20:34.194]         }
[13:20:34.194]         else {
[13:20:34.194]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:34.194]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:34.194]         }
[13:20:34.194]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:34.194]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:34.194]             base::sink(type = "output", split = FALSE)
[13:20:34.194]             base::close(...future.stdout)
[13:20:34.194]         }, add = TRUE)
[13:20:34.194]     }
[13:20:34.194]     ...future.frame <- base::sys.nframe()
[13:20:34.194]     ...future.conditions <- base::list()
[13:20:34.194]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:34.194]     if (FALSE) {
[13:20:34.194]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:34.194]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:34.194]     }
[13:20:34.194]     ...future.result <- base::tryCatch({
[13:20:34.194]         base::withCallingHandlers({
[13:20:34.194]             ...future.value <- base::withVisible(base::local({
[13:20:34.194]                 ...future.makeSendCondition <- local({
[13:20:34.194]                   sendCondition <- NULL
[13:20:34.194]                   function(frame = 1L) {
[13:20:34.194]                     if (is.function(sendCondition)) 
[13:20:34.194]                       return(sendCondition)
[13:20:34.194]                     ns <- getNamespace("parallel")
[13:20:34.194]                     if (exists("sendData", mode = "function", 
[13:20:34.194]                       envir = ns)) {
[13:20:34.194]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:34.194]                         envir = ns)
[13:20:34.194]                       envir <- sys.frame(frame)
[13:20:34.194]                       master <- NULL
[13:20:34.194]                       while (!identical(envir, .GlobalEnv) && 
[13:20:34.194]                         !identical(envir, emptyenv())) {
[13:20:34.194]                         if (exists("master", mode = "list", envir = envir, 
[13:20:34.194]                           inherits = FALSE)) {
[13:20:34.194]                           master <- get("master", mode = "list", 
[13:20:34.194]                             envir = envir, inherits = FALSE)
[13:20:34.194]                           if (inherits(master, c("SOCKnode", 
[13:20:34.194]                             "SOCK0node"))) {
[13:20:34.194]                             sendCondition <<- function(cond) {
[13:20:34.194]                               data <- list(type = "VALUE", value = cond, 
[13:20:34.194]                                 success = TRUE)
[13:20:34.194]                               parallel_sendData(master, data)
[13:20:34.194]                             }
[13:20:34.194]                             return(sendCondition)
[13:20:34.194]                           }
[13:20:34.194]                         }
[13:20:34.194]                         frame <- frame + 1L
[13:20:34.194]                         envir <- sys.frame(frame)
[13:20:34.194]                       }
[13:20:34.194]                     }
[13:20:34.194]                     sendCondition <<- function(cond) NULL
[13:20:34.194]                   }
[13:20:34.194]                 })
[13:20:34.194]                 withCallingHandlers({
[13:20:34.194]                   {
[13:20:34.194]                     outer_function(1L)
[13:20:34.194]                   }
[13:20:34.194]                 }, immediateCondition = function(cond) {
[13:20:34.194]                   sendCondition <- ...future.makeSendCondition()
[13:20:34.194]                   sendCondition(cond)
[13:20:34.194]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:34.194]                   {
[13:20:34.194]                     inherits <- base::inherits
[13:20:34.194]                     invokeRestart <- base::invokeRestart
[13:20:34.194]                     is.null <- base::is.null
[13:20:34.194]                     muffled <- FALSE
[13:20:34.194]                     if (inherits(cond, "message")) {
[13:20:34.194]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:34.194]                       if (muffled) 
[13:20:34.194]                         invokeRestart("muffleMessage")
[13:20:34.194]                     }
[13:20:34.194]                     else if (inherits(cond, "warning")) {
[13:20:34.194]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:34.194]                       if (muffled) 
[13:20:34.194]                         invokeRestart("muffleWarning")
[13:20:34.194]                     }
[13:20:34.194]                     else if (inherits(cond, "condition")) {
[13:20:34.194]                       if (!is.null(pattern)) {
[13:20:34.194]                         computeRestarts <- base::computeRestarts
[13:20:34.194]                         grepl <- base::grepl
[13:20:34.194]                         restarts <- computeRestarts(cond)
[13:20:34.194]                         for (restart in restarts) {
[13:20:34.194]                           name <- restart$name
[13:20:34.194]                           if (is.null(name)) 
[13:20:34.194]                             next
[13:20:34.194]                           if (!grepl(pattern, name)) 
[13:20:34.194]                             next
[13:20:34.194]                           invokeRestart(restart)
[13:20:34.194]                           muffled <- TRUE
[13:20:34.194]                           break
[13:20:34.194]                         }
[13:20:34.194]                       }
[13:20:34.194]                     }
[13:20:34.194]                     invisible(muffled)
[13:20:34.194]                   }
[13:20:34.194]                   muffleCondition(cond)
[13:20:34.194]                 })
[13:20:34.194]             }))
[13:20:34.194]             future::FutureResult(value = ...future.value$value, 
[13:20:34.194]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:34.194]                   ...future.rng), globalenv = if (FALSE) 
[13:20:34.194]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:34.194]                     ...future.globalenv.names))
[13:20:34.194]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:34.194]         }, condition = base::local({
[13:20:34.194]             c <- base::c
[13:20:34.194]             inherits <- base::inherits
[13:20:34.194]             invokeRestart <- base::invokeRestart
[13:20:34.194]             length <- base::length
[13:20:34.194]             list <- base::list
[13:20:34.194]             seq.int <- base::seq.int
[13:20:34.194]             signalCondition <- base::signalCondition
[13:20:34.194]             sys.calls <- base::sys.calls
[13:20:34.194]             `[[` <- base::`[[`
[13:20:34.194]             `+` <- base::`+`
[13:20:34.194]             `<<-` <- base::`<<-`
[13:20:34.194]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:34.194]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:34.194]                   3L)]
[13:20:34.194]             }
[13:20:34.194]             function(cond) {
[13:20:34.194]                 is_error <- inherits(cond, "error")
[13:20:34.194]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:34.194]                   NULL)
[13:20:34.194]                 if (is_error) {
[13:20:34.194]                   sessionInformation <- function() {
[13:20:34.194]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:34.194]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:34.194]                       search = base::search(), system = base::Sys.info())
[13:20:34.194]                   }
[13:20:34.194]                   ...future.conditions[[length(...future.conditions) + 
[13:20:34.194]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:34.194]                     cond$call), session = sessionInformation(), 
[13:20:34.194]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:34.194]                   signalCondition(cond)
[13:20:34.194]                 }
[13:20:34.194]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:34.194]                 "immediateCondition"))) {
[13:20:34.194]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:34.194]                   ...future.conditions[[length(...future.conditions) + 
[13:20:34.194]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:34.194]                   if (TRUE && !signal) {
[13:20:34.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:34.194]                     {
[13:20:34.194]                       inherits <- base::inherits
[13:20:34.194]                       invokeRestart <- base::invokeRestart
[13:20:34.194]                       is.null <- base::is.null
[13:20:34.194]                       muffled <- FALSE
[13:20:34.194]                       if (inherits(cond, "message")) {
[13:20:34.194]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:34.194]                         if (muffled) 
[13:20:34.194]                           invokeRestart("muffleMessage")
[13:20:34.194]                       }
[13:20:34.194]                       else if (inherits(cond, "warning")) {
[13:20:34.194]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:34.194]                         if (muffled) 
[13:20:34.194]                           invokeRestart("muffleWarning")
[13:20:34.194]                       }
[13:20:34.194]                       else if (inherits(cond, "condition")) {
[13:20:34.194]                         if (!is.null(pattern)) {
[13:20:34.194]                           computeRestarts <- base::computeRestarts
[13:20:34.194]                           grepl <- base::grepl
[13:20:34.194]                           restarts <- computeRestarts(cond)
[13:20:34.194]                           for (restart in restarts) {
[13:20:34.194]                             name <- restart$name
[13:20:34.194]                             if (is.null(name)) 
[13:20:34.194]                               next
[13:20:34.194]                             if (!grepl(pattern, name)) 
[13:20:34.194]                               next
[13:20:34.194]                             invokeRestart(restart)
[13:20:34.194]                             muffled <- TRUE
[13:20:34.194]                             break
[13:20:34.194]                           }
[13:20:34.194]                         }
[13:20:34.194]                       }
[13:20:34.194]                       invisible(muffled)
[13:20:34.194]                     }
[13:20:34.194]                     muffleCondition(cond, pattern = "^muffle")
[13:20:34.194]                   }
[13:20:34.194]                 }
[13:20:34.194]                 else {
[13:20:34.194]                   if (TRUE) {
[13:20:34.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:34.194]                     {
[13:20:34.194]                       inherits <- base::inherits
[13:20:34.194]                       invokeRestart <- base::invokeRestart
[13:20:34.194]                       is.null <- base::is.null
[13:20:34.194]                       muffled <- FALSE
[13:20:34.194]                       if (inherits(cond, "message")) {
[13:20:34.194]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:34.194]                         if (muffled) 
[13:20:34.194]                           invokeRestart("muffleMessage")
[13:20:34.194]                       }
[13:20:34.194]                       else if (inherits(cond, "warning")) {
[13:20:34.194]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:34.194]                         if (muffled) 
[13:20:34.194]                           invokeRestart("muffleWarning")
[13:20:34.194]                       }
[13:20:34.194]                       else if (inherits(cond, "condition")) {
[13:20:34.194]                         if (!is.null(pattern)) {
[13:20:34.194]                           computeRestarts <- base::computeRestarts
[13:20:34.194]                           grepl <- base::grepl
[13:20:34.194]                           restarts <- computeRestarts(cond)
[13:20:34.194]                           for (restart in restarts) {
[13:20:34.194]                             name <- restart$name
[13:20:34.194]                             if (is.null(name)) 
[13:20:34.194]                               next
[13:20:34.194]                             if (!grepl(pattern, name)) 
[13:20:34.194]                               next
[13:20:34.194]                             invokeRestart(restart)
[13:20:34.194]                             muffled <- TRUE
[13:20:34.194]                             break
[13:20:34.194]                           }
[13:20:34.194]                         }
[13:20:34.194]                       }
[13:20:34.194]                       invisible(muffled)
[13:20:34.194]                     }
[13:20:34.194]                     muffleCondition(cond, pattern = "^muffle")
[13:20:34.194]                   }
[13:20:34.194]                 }
[13:20:34.194]             }
[13:20:34.194]         }))
[13:20:34.194]     }, error = function(ex) {
[13:20:34.194]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:34.194]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:34.194]                 ...future.rng), started = ...future.startTime, 
[13:20:34.194]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:34.194]             version = "1.8"), class = "FutureResult")
[13:20:34.194]     }, finally = {
[13:20:34.194]         if (!identical(...future.workdir, getwd())) 
[13:20:34.194]             setwd(...future.workdir)
[13:20:34.194]         {
[13:20:34.194]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:34.194]                 ...future.oldOptions$nwarnings <- NULL
[13:20:34.194]             }
[13:20:34.194]             base::options(...future.oldOptions)
[13:20:34.194]             if (.Platform$OS.type == "windows") {
[13:20:34.194]                 old_names <- names(...future.oldEnvVars)
[13:20:34.194]                 envs <- base::Sys.getenv()
[13:20:34.194]                 names <- names(envs)
[13:20:34.194]                 common <- intersect(names, old_names)
[13:20:34.194]                 added <- setdiff(names, old_names)
[13:20:34.194]                 removed <- setdiff(old_names, names)
[13:20:34.194]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:34.194]                   envs[common]]
[13:20:34.194]                 NAMES <- toupper(changed)
[13:20:34.194]                 args <- list()
[13:20:34.194]                 for (kk in seq_along(NAMES)) {
[13:20:34.194]                   name <- changed[[kk]]
[13:20:34.194]                   NAME <- NAMES[[kk]]
[13:20:34.194]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:34.194]                     next
[13:20:34.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:34.194]                 }
[13:20:34.194]                 NAMES <- toupper(added)
[13:20:34.194]                 for (kk in seq_along(NAMES)) {
[13:20:34.194]                   name <- added[[kk]]
[13:20:34.194]                   NAME <- NAMES[[kk]]
[13:20:34.194]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:34.194]                     next
[13:20:34.194]                   args[[name]] <- ""
[13:20:34.194]                 }
[13:20:34.194]                 NAMES <- toupper(removed)
[13:20:34.194]                 for (kk in seq_along(NAMES)) {
[13:20:34.194]                   name <- removed[[kk]]
[13:20:34.194]                   NAME <- NAMES[[kk]]
[13:20:34.194]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:34.194]                     next
[13:20:34.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:34.194]                 }
[13:20:34.194]                 if (length(args) > 0) 
[13:20:34.194]                   base::do.call(base::Sys.setenv, args = args)
[13:20:34.194]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:34.194]             }
[13:20:34.194]             else {
[13:20:34.194]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:34.194]             }
[13:20:34.194]             {
[13:20:34.194]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:34.194]                   0L) {
[13:20:34.194]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:34.194]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:34.194]                   base::options(opts)
[13:20:34.194]                 }
[13:20:34.194]                 {
[13:20:34.194]                   {
[13:20:34.194]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:34.194]                     NULL
[13:20:34.194]                   }
[13:20:34.194]                   options(future.plan = NULL)
[13:20:34.194]                   if (is.na(NA_character_)) 
[13:20:34.194]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:34.194]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:34.194]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:34.194]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:34.194]                     envir = parent.frame()) 
[13:20:34.194]                   {
[13:20:34.194]                     if (is.function(workers)) 
[13:20:34.194]                       workers <- workers()
[13:20:34.194]                     workers <- structure(as.integer(workers), 
[13:20:34.194]                       class = class(workers))
[13:20:34.194]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:34.194]                       workers >= 1)
[13:20:34.194]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:34.194]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:34.194]                     }
[13:20:34.194]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:34.194]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:34.194]                       envir = envir)
[13:20:34.194]                     if (!future$lazy) 
[13:20:34.194]                       future <- run(future)
[13:20:34.194]                     invisible(future)
[13:20:34.194]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:34.194]                 }
[13:20:34.194]             }
[13:20:34.194]         }
[13:20:34.194]     })
[13:20:34.194]     if (TRUE) {
[13:20:34.194]         base::sink(type = "output", split = FALSE)
[13:20:34.194]         if (TRUE) {
[13:20:34.194]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:34.194]         }
[13:20:34.194]         else {
[13:20:34.194]             ...future.result["stdout"] <- base::list(NULL)
[13:20:34.194]         }
[13:20:34.194]         base::close(...future.stdout)
[13:20:34.194]         ...future.stdout <- NULL
[13:20:34.194]     }
[13:20:34.194]     ...future.result$conditions <- ...future.conditions
[13:20:34.194]     ...future.result$finished <- base::Sys.time()
[13:20:34.194]     ...future.result
[13:20:34.194] }
[13:20:34.197] Exporting 3 global objects (7.52 KiB) to cluster node #1 ...
[13:20:34.197] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ...
[13:20:34.197] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ... DONE
[13:20:34.198] Exporting ‘map’ (4.43 KiB) to cluster node #1 ...
[13:20:34.198] Exporting ‘map’ (4.43 KiB) to cluster node #1 ... DONE
[13:20:34.198] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ...
[13:20:34.199] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ... DONE
[13:20:34.199] Exporting 3 global objects (7.52 KiB) to cluster node #1 ... DONE
[13:20:34.199] MultisessionFuture started
[13:20:34.199] - Launch lazy future ... done
[13:20:34.200] run() for ‘MultisessionFuture’ ... done
[13:20:34.200] result() for ClusterFuture ...
[13:20:34.200] receiveMessageFromWorker() for ClusterFuture ...
[13:20:34.200] - Validating connection of MultisessionFuture
[13:20:34.246] - received message: FutureResult
[13:20:34.246] - Received FutureResult
[13:20:34.246] - Erased future from FutureRegistry
[13:20:34.246] result() for ClusterFuture ...
[13:20:34.246] - result already collected: FutureResult
[13:20:34.246] result() for ClusterFuture ... done
[13:20:34.246] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:34.247] result() for ClusterFuture ... done
[13:20:34.247] result() for ClusterFuture ...
[13:20:34.247] - result already collected: FutureResult
[13:20:34.247] result() for ClusterFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
Testing with 2 cores ... DONE
> 
> message("*** Globals - formulas ... DONE")
*** Globals - formulas ... DONE
> 
> source("incl/end.R")
[13:20:34.249] plan(): Setting new future strategy stack:
[13:20:34.249] List of future strategies:
[13:20:34.249] 1. FutureStrategy:
[13:20:34.249]    - args: function (..., envir = parent.frame())
[13:20:34.249]    - tweaked: FALSE
[13:20:34.249]    - call: future::plan(oplan)
[13:20:34.250] plan(): nbrOfWorkers() = 1
> 
